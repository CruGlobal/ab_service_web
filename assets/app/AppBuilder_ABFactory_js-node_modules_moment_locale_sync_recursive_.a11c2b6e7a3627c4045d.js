(self["webpackChunkab_platform_web"] = self["webpackChunkab_platform_web"] || []).push([["AppBuilder_ABFactory_js-node_modules_moment_locale_sync_recursive_"],{

/***/ 28893:
/*!******************************************************************!*\
  !*** ./ABDesigner/ab_work_object_workspace_popupNewDataField.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ab_work_object_workspace_popupNewDataField
 *
 * Manage the Add New Data Field popup.
 *
 */

const ABComponent = __webpack_require__(/*! ../AppBuilder/platform/ABComponent */ 8030);
const ABFieldManager = __webpack_require__(/*! ../AppBuilder/core/ABFieldManager */ 69594);

module.exports = class AB_Work_Object_Workspace_PopupNewDataField extends (
   ABComponent
) {
   //.extend(idBase, function(App) {

   constructor(App, idBase) {
      idBase = idBase || "ab_work_object_workspace_popupNewDataField";

      super(App, idBase);
      var L = this.Label();

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: this.unique(`${idBase}_popNewField`),
         types: this.unique(`${idBase}_popNewField_types`),
         editDefinitions: this.unique(`${idBase}_popNewField_editDefinitions`),

         buttonSave: this.unique(`${idBase}_popNewField_buttonSave`),
         buttonCancel: this.unique(`${idBase}_popNewField_buttonCancel`),
      };

      // Our webix UI definition:
      this.ui = {
         view: "window",
         position: "center",
         id: ids.component,
         resize: true,
         modal: true,
         height: 500,
         width: 700,
         head: {
            view: "toolbar",
            css: "webix_dark",
            cols: [
               {
                  view: "label",
                  label: L("Add new field"),
                  css: "modal_title",
                  align: "center",
               },
               {
                  view: "button",
                  label: L("Close"),
                  autowidth: true,
                  align: "center",
                  click: function () {
                     _logic.buttonCancel();
                  },
               },
            ],
         },
         // ready: function () {
         //  console.error('ready() called!!!')
         //  _logic.resetState();
         // },

         body: {
            view: "scrollview",
            scroll: "y",
            css: "ab-add-fields-popup",
            borderless: true,
            body: {
               type: "form",
               rows: [
                  {
                     view: "richselect",
                     id: ids.types,
                     label: L("Field type"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [
                        //We will add these later
                        { id: "temporary", view: "temporary" },
                     ],
                     on: {
                        onChange: function (id, ev, node) {
                           _logic.onChange(id);
                        },
                     },
                  },
                  {
                     height: 10,
                     type: "line",
                  },
                  {
                     view: "multiview",
                     id: ids.editDefinitions,
                     padding: 0,
                     // NOTE: can't leave this an empty []. We redefine this value later.
                     cells: [
                        {
                           id: "del_me",
                           view: "label",
                           label: L("edit definition here"),
                        },
                     ],
                  },
                  { height: 10 },
                  {
                     cols: [
                        { fillspace: true },
                        {
                           view: "button",
                           value: L("Cancel"),
                           css: "ab-cancel-button",
                           autowidth: true,
                           click: function () {
                              _logic.buttonCancel();
                           },
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           id: ids.buttonSave,
                           label: L("Add Column"),
                           autowidth: true,
                           type: "form",
                           click: function () {
                              _logic.buttonSave();
                           },
                        },
                     ],
                  },
               ],
            },
         },
         on: {
            //onBeforeShow: function () {
            //  _logic.resetState();
            //},
            onHide: function () {
               _logic.resetState();
            },
         },
      };

      var _objectHash = {}; // 'name' => ABFieldXXX object
      var _componentHash = {}; // 'name' => ABFieldXXX ui component
      var _componentsByType = {}; // 'type' => ABFieldXXX ui component
      var _currentEditor = null;
      var _currentApplication = null;
      var _currentObject = null;

      var defaultEditorComponent = null; // the default editor.
      var defaultEditorID = null; // the default editor id.
      var submenus = []; // Create the submenus for our Data Fields:

      var _editField = null; // field instance being edited

      // Our init() function for setting up our UI
      this.init = (options) => {
         // register our callbacks:
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         // initialize our components
         webix.ui(this.ui);
         webix.extend($$(ids.component), webix.ProgressBar);

         var Fields = ABFieldManager.allFields();

         //// we need to load a submenu entry and an editor definition for each
         //// of our Fields

         var newEditorList = {
            view: "multiview",
            id: ids.editDefinitions,
            animate: false,
            rows: [],
         };

         Fields.forEach(function (F) {
            var menuName = F.defaults().menuName;
            var key = F.defaults().key;

            // add a submenu for the fields multilingual key
            submenus.push({ id: menuName, value: menuName });

            // Add the Field's definition editor here:
            var editorComponent = F.propertiesComponent(App, idBase);
            if (!defaultEditorComponent) {
               defaultEditorComponent = editorComponent;
               defaultEditorID = menuName;
            }
            newEditorList.rows.push(editorComponent.ui);

            _objectHash[menuName] = F;
            _componentHash[menuName] = editorComponent;
            _componentsByType[key] = editorComponent;
         });

         // the submenu button has a placeholder we need to remove and update
         // with one that has all our submenus in it.
         // var firstID = $$(ids.types).getFirstId();
         // $$(ids.types).updateItem(firstID, {
         //  value: labels.component.chooseType,
         //  submenu: submenus
         // })
         $$(ids.types).define("options", submenus);
         $$(ids.types).refresh();

         // now remove the 'del_me' definition editor placeholder.
         webix.ui(newEditorList, $$(ids.editDefinitions));

         // init & hide all the unused editors:
         for (let c in _componentHash) {
            _componentHash[c].init();

            _componentHash[c].hide();
         }

         defaultEditorComponent.show(); // show the default editor
         _currentEditor = defaultEditorComponent;

         // set the richselect to the first option by default.
         $$(ids.types).setValue(submenus[0].id);

         // $$(ids.editDefinitions).show();

         // $$(ids.editDefinitions).cells() // define the edit Definitions here.
      };

      // our internal business logic
      var _logic = (this._logic = {
         applicationLoad: (application) => {
            _currentApplication = application;

            // TODO : should load ABApplication to data field popup here ?
            for (var menuName in _componentHash) {
               if (
                  _componentHash[menuName] &&
                  _componentHash[menuName]._logic.applicationLoad
               ) {
                  _componentHash[menuName]._logic.applicationLoad(application);
               }
            }
         },

         objectLoad: (object) => {
            _currentObject = object;

            // TODO : should load current object to data field popup here ?
            for (var menuName in _componentHash) {
               if (
                  _componentHash[menuName] &&
                  _componentHash[menuName]._logic.objectLoad
               ) {
                  _componentHash[menuName]._logic.objectLoad(_currentObject);
               }
            }
         },

         buttonCancel: function () {
            _logic.resetState();

            // clear all editors:
            for (var c in _componentHash) {
               _componentHash[c].clear();
            }

            // hide this popup.
            $$(ids.component).hide();
         },

         buttonSave: async function () {
            $$(ids.buttonSave).disable();
            // show progress
            $$(ids.component).showProgress();

            var editor = _currentEditor;
            if (editor) {
               // the editor can define some basic form validations.
               if (editor.isValid()) {
                  var vals = this.AB.cloneDeep(editor.values());

                  var field = null;
                  var oldData = null;

                  var linkCol;

                  // if this is an ADD operation, (_editField will be undefined)
                  if (!_editField) {
                     // get a new instance of a field:
                     field = _currentObject.fieldNew(vals);

                     // Provide a default width based on the column label
                     var width = 20 + field.label.length * 10;
                     if (field.settings.showIcon) {
                        width = width + 20;
                     }
                     if (width < 100) {
                        width = 100;
                     }

                     field.settings.width = width;

                     // TODO workaround : where should I add a new link field to link object
                     if (field.key == "connectObject") {
                        let rand = Math.floor(Math.random() * 1000);
                        field.settings.isSource = 1;

                        var linkObject = field.datasourceLink;

                        // 1:1, 1:M, M:1 should have same column name
                        let linkColumnName = field.columnName;

                        // check duplicate column
                        if (
                           linkObject.fields(
                              (f) => f.columnName == linkColumnName
                           ).length
                        ) {
                           linkColumnName = `${linkColumnName}${rand}`;
                        }

                        // M:N should have different column name into the join table
                        if (
                           field.settings.linkType == "many" &&
                           field.settings.linkViaType == "many"
                        ) {
                           // NOTE : include random number to prevent duplicate column names
                           linkColumnName = `${_currentObject.name}${rand}`;
                        }

                        linkCol = linkObject.fieldNew({
                           // id: OP.Util.uuid(),

                           key: field.key,

                           columnName: linkColumnName,
                           label: _currentObject.label,

                           settings: {
                              showIcon: field.settings.showIcon,

                              linkObject: field.object.id,
                              linkType: field.settings.linkViaType,
                              linkViaType: field.settings.linkType,
                              isCustomFK: field.settings.isCustomFK,
                              indexField: field.settings.indexField,
                              indexField2: field.settings.indexField2,
                              isSource: 0,
                              width: width,
                           },
                        });

                        // Update link column id to source column
                        // field.settings.linkColumn = linkCol.id;
                     }
                  } else {
                     // NOTE: update label before .toObj for .unTranslate to .translations
                     if (vals.label) _editField.label = vals.label;

                     // use our _editField, backup our oldData
                     oldData = _editField.toObj();

                     // update changed values to old data
                     var updateValues = this.AB.cloneDeep(oldData);
                     for (let key in vals) {
                        // update each values of .settings
                        if (
                           key == "settings" &&
                           vals["settings"] &&
                           typeof vals["settings"] == "object"
                        ) {
                           updateValues["settings"] =
                              updateValues["settings"] || {};

                           for (let keySetting in vals["settings"]) {
                              updateValues["settings"][keySetting] =
                                 vals["settings"][keySetting];
                           }
                        } else {
                           updateValues[key] = vals[key];
                        }
                     }

                     _editField.fromValues(updateValues);

                     field = _editField;
                  }

                  var validator = field.isValid();
                  if (validator.fail()) {
                     validator.updateForm($$(editor.ui.id));
                     // OP.Form.isValidationError(errors, $$(editor.ui.id));

                     // keep our old data
                     if (oldData) {
                        field.fromValues(oldData);
                     }

                     $$(ids.buttonSave).enable();
                     $$(ids.component).hideProgress();
                  } else {
                     try {
                        await field.save();

                        let finishUpdateField = () => {
                           $$(ids.buttonSave).enable();
                           $$(ids.component).hideProgress();
                           _currentEditor.clear();
                           _logic.hide();
                           _logic.callbacks.onSave(field);
                        };

                        let refreshModels = () => {
                           // refresh linked object model
                           linkCol.object.model().refresh();

                           // refresh source object model
                           // NOTE: M:1 relation has to refresh model after linked object's refreshed
                           field.object.model().refresh();
                        };

                        // TODO workaround : update link column id
                        if (linkCol != null) {
                           linkCol.settings.linkColumn = field.id;
                           await linkCol.save();

                           // now linkCol has an .id, so update our field:
                           field.settings.linkColumn = linkCol.id;
                           await field.save();

                           // when add new link fields, then run create migrate fields here
                           if (!_editField) {
                              await field.migrateCreate();
                              await linkCol.migrateCreate();
                           }

                           refreshModels();
                           finishUpdateField();
                        } else {
                           finishUpdateField();
                        }
                     } catch (err) {
                        // if (
                        //    OP.Validation.isFormValidationError(
                        //       err,
                        //       $$(editor.ui.id)
                        //    )
                        // ) {
                        //    // for validation errors, keep things in place
                        //    // and let the user fix the data:
                        //    $$(ids.buttonSave).enable();
                        //    $$(ids.component).hideProgress();
                        // } else {
                        //    var errMsg = err.toString();
                        //    if (err.message) {
                        //       errMsg = err.message;
                        //    }
                        //    webix.alert({
                        //       title: "Error saving fields.",
                        //       ok: "tell appdev",
                        //       text: errMsg,
                        //       type: "alert-error",
                        //    });
                        //    // Q: if not validation error, do we
                        //    // then field.destroy() ? and let them try again?
                        //    // $$(ids.buttonSave).enable();
                        //    // $$(ids.component).hideProgress();
                        // }
                     }
                  }
               } else {
                  $$(ids.buttonSave).enable();
                  $$(ids.component).hideProgress();
               }
            } else {
               this.AB.notify.developer(
                  new Error("Could not find the current editor."),
                  {}
               );

               $$(ids.buttonSave).enable();
               $$(ids.component).hideProgress();
            }

            // if (!inputValidator.validateFormat(fieldInfo.name)) {
            //  self.enable();
            //  return;
            // }

            // // Validate duplicate field name
            // var existsColumn = $.grep(dataTable.config.columns, function (c) { return c.id == fieldInfo.name.replace(/ /g, '_'); });
            // if (existsColumn && existsColumn.length > 0 && !data.editFieldId) {
            //  webix.alert({
            //      title: labels.add_fields.duplicateFieldTitle,
            //      text: labels.add_fields.duplicateFieldDescription,
            //      ok: labels.common.ok
            //  });
            //  this.enable();
            //  return;
            // }

            // if (fieldInfo.weight == null)
            //  fieldInfo.weight = dataTable.config.columns.length;

            // // Call callback function
            // if (base.saveFieldCallback && base.fieldName) {
            //  base.saveFieldCallback(base.fieldName, fieldInfo)
            //      .then(function () {
            //          self.enable();
            //          base.resetState();
            //          base.hide();
            //      });
            // }
         },

         callbacks: {
            onCancel: function () {
               console.warn("NO onCancel()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         hide: function () {
            $$(ids.component).hide();
         },

         modeAdd: function (allowFieldKey) {
            // show default editor:
            defaultEditorComponent.show(false, false);
            _currentEditor = defaultEditorComponent;

            // allow add the connect field only to import object
            if (_currentObject.isImported) allowFieldKey = "connectObject";

            if (allowFieldKey) {
               var connectField = ABFieldManager.allFields().filter(
                  (f) => f.defaults().key == allowFieldKey
               )[0];
               if (!connectField) return;
               var connectMenuName = connectField.defaults().menuName;
               $$(ids.types).setValue(connectMenuName);
               $$(ids.types).disable();
            }
            // show the ability to switch data types
            else {
               $$(ids.types).enable();
            }

            $$(ids.types).show();

            // change button text to 'add'
            $$(ids.buttonSave).define("label", L("Add Column"));
            $$(ids.buttonSave).refresh();
         },

         modeEdit: function (field) {
            if (_currentEditor) _currentEditor.hide();

            // switch to this field's editor:
            // hide the rest
            for (var c in _componentsByType) {
               if (c == field.key) {
                  _componentsByType[c].show(false, false);
                  _componentsByType[c].populate(field);
                  _currentEditor = _componentsByType[c];
               } else {
                  _componentsByType[c].hide();
               }
            }

            // disable elements that disallow to edit
            if (
               _currentEditor &&
               _currentEditor.ui &&
               _currentEditor.ui.elements
            ) {
               var disableElem = (elem) => {
                  if (elem.disallowEdit && $$(elem.id) && $$(elem.id).disable) {
                     $$(elem.id).disable();
                  }
               };

               _currentEditor.ui.elements.forEach((elem) => {
                  disableElem(elem);

                  // disable elements are in rows/cols
                  var childElems = elem.cols || elem.rows;
                  if (childElems && childElems.forEach) {
                     childElems.forEach((childElem) => {
                        disableElem(childElem);
                     });
                  }
               });
            }

            // hide the ability to switch data types
            $$(ids.types).hide();

            // change button text to 'save'
            $$(ids.buttonSave).define("label", L("Save"));
            $$(ids.buttonSave).refresh();
         },

         /**
          * @function onChange
          * swap the editor view to match the data field selected in the menu.
          *
          * @param {string} name  the menuName() of the submenu that was selected.
          */
         onChange: function (name) {
            // note, the submenu returns the Field.menuName() values.
            // we use that to lookup the Field here:
            var editor = _componentHash[name];
            if (editor) {
               editor.show();
               _currentEditor = editor;
               $$(ids.types).blur();
            } else {
               // most likely they clicked on the menu button itself.
               // do nothing.
               // OP.Error.log("App Builder:Workspace:Object:NewDataField: could not find editor for submenu item:"+name, { name:name });
            }
         },

         resetState: function () {
            // enable elements that disallow to edit
            if (
               _currentEditor &&
               _currentEditor.ui &&
               _currentEditor.ui.elements
            ) {
               var enableElem = (elem) => {
                  if (elem.disallowEdit && $$(elem.id) && $$(elem.id).enable) {
                     $$(elem.id).enable();
                  }
               };

               _currentEditor.ui.elements.forEach((elem) => {
                  enableElem(elem);

                  // enable elements are in rows/cols
                  var childElems = elem.cols || elem.rows;
                  if (childElems && childElems.forEach) {
                     childElems.forEach((childElem) => {
                        enableElem(childElem);
                     });
                  }
               });
            }

            defaultEditorComponent.show(); // show the default editor
            _currentEditor = defaultEditorComponent;

            // set the richselect to the first option by default.
            $$(ids.types).setValue(submenus[0].id);
         },

         /**
          * @function show()
          *
          * Show this component.
          * @param {ABField} field    the ABField to edit.  If not provided, then
          *                           this is an ADD operation.
          * @param {string} fieldKey  allow only this field type
          */
         show: function (field, fieldKey) {
            _editField = field;

            if (_editField) {
               _logic.modeEdit(field);
            } else {
               _logic.modeAdd(fieldKey);
            }

            $$(ids.component).show();
         },

         typeClick: function () {
            // NOTE: for functional testing we need a way to display the submenu
            // (functional tests don't do .hover very well)
            // so this routine is to enable .click() to show the submenu.

            var subMenuId = $$(ids.types).config.data[0].submenu;

            // #HACK Sub-menu popup does not render on initial
            // Force it to render popup by use .getSubMenu()
            if (typeof subMenuId != "string") {
               $$(ids.types).getSubMenu($$(ids.types).config.data[0].id);
               subMenuId = $$(ids.types).config.data[0].submenu;
            }

            if ($$(subMenuId)) $$(subMenuId).show();
         },
      });

      // Expose any globally accessible Actions:
      this.actions({});

      //
      // Define our external interface methods:
      //
      this.applicationLoad = _logic.applicationLoad; // {fn}     fn(ABApplication)
      this.objectLoad = _logic.objectLoad; // {fn}     fn(ABObject)
      this.show = _logic.show; // {fn}     fn(node, ABField)
   }
};


/***/ }),

/***/ 43947:
/*!****************************************************************!*\
  !*** ./ABDesigner/ab_work_object_workspace_popupSortFields.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ab_work_object_workspace_popupSortFields
 *
 * Manage the Sort Fields popup.
 *
 */

const ABComponent = __webpack_require__(/*! ../AppBuilder/platform/ABComponent */ 8030);

module.exports = class AB_Work_Object_Workspace_PopupSortFields extends ABComponent {
   //.extend(idBase, function(App) {

   constructor(App, idBase) {
      idBase = idBase || "ab_work_object_workspace_popupSortFields";

      super(App, idBase);
      var L = this.Label();

      // internal list of Webix IDs to reference our UI components
      var ids = {
         component: this.unique(`${idBase}_popupSort`),
         list: this.unique(`${idBase}_popupSort_list`),
         form: this.unique(`${idBase}_popupSort_form`),
      };

      // Our webix UI definition:
      var formUI = {
         view: "form",
         id: ids.form,
         // autoheight: true,
         borderless: true,
         elements: [
            {
               view: "button",
               type: "form",
               css: "webix_primary",
               value: L("Add new sort"),
               on: {
                  onItemClick: function (id, e, node) {
                     _logic.clickAddNewSort();
                     _logic.triggerOnChange();
                  },
               },
            },
         ],
      };

      this.ui = {
         view: "popup",
         id: ids.component,
         // autoheight:true,
         width: 600,
         body: formUI,
         on: {
            onShow: function () {
               _logic.onShow();
            },
         },
      };

      // Our init() function for setting up our UI
      this.init = (options) => {
         // register our callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         webix.ui(this.ui);
      };

      let CurrentObject = null;

      // our internal business logic
      var _logic = (this._logic = {
         callbacks: {
            /**
             * @function onChange
             * called when we have made changes to the hidden field settings
             * of our Current Object.
             *
             * this is meant to alert our parent component to respond to the
             * change.
             */
            onChange: function () {},
         },

         /**
          * @function clickAddNewSort
          * the user clicked the add new sort buttton. I don't know what it does...will update later
          */
         // clickAddNewSort: function(by, dir, isMulti, id) {
         clickAddNewSort: function (fieldId, dir) {
            var sort_form = $$(ids.form);

            var viewIndex = sort_form.getChildViews().length - 1;
            var listFields = _logic.getFieldList(true);
            sort_form.addView(
               {
                  id: "sort" + webix.uid(),
                  cols: [
                     {
                        view: "combo",
                        width: 220,
                        options: listFields,
                        on: {
                           onChange: function (columnId) {
                              var el = this;
                              _logic.onChangeCombo(columnId, el);
                           },
                        },
                     },
                     {
                        view: "segmented",
                        width: 200,
                        options: [
                           {
                              id: "",
                              value: L("Please select field"),
                           },
                        ],
                        on: {
                           onChange: function (newv, oldv) {
                              // 'asc' or 'desc' values
                              _logic.triggerOnChange();
                           },
                        },
                     },
                     {
                        view: "button",
                        css: "webix_danger",
                        icon: "fa fa-trash",
                        type: "icon",
                        width: 30,
                        on: {
                           onItemClick: function () {
                              sort_form.removeView(this.getParentView());
                              _logic.refreshFieldList(true);
                              _logic.triggerOnChange();
                           },
                        },
                     },
                  ],
               },
               viewIndex
            );

            // Select field
            if (fieldId) {
               var fieldsCombo = sort_form
                  .getChildViews()
                  [viewIndex].getChildViews()[0];
               fieldsCombo.setValue(fieldId);
            }
            if (dir) {
               var segmentButton = sort_form
                  .getChildViews()
                  [viewIndex].getChildViews()[1];
               segmentButton.setValue(dir);
            }
            // if (isMulti) {
            // 	var isMultilingualField = sort_form.getChildViews()[viewIndex].getChildViews()[2];
            // 	isMultilingualField.setValue(isMulti);
            // }
         },

         /**
          * @function getFieldList
          * return field list so we can present a custom UI for view
          */
         getFieldList: function (excludeSelected) {
            var sort_popup = $$(ids.component),
               sort_form = $$(ids.form),
               listFields = [];

            if (!CurrentObject.fields()) return listFields;

            // Get all fields include hidden fields
            var allFields = CurrentObject.fields();
            allFields.forEach((f) => {
               if (f.fieldIsSortable()) {
                  listFields.push({
                     id: f.id,
                     value: f.label,
                  });
               }
            });

            // Remove selected field
            if (excludeSelected) {
               var childViews = sort_form.getChildViews();
               if (childViews.length > 1) {
                  // Ignore 'Add new sort' button
                  childViews.forEach(function (cView, index) {
                     if (childViews.length - 1 <= index) return false;

                     var selectedValue = cView.getChildViews()[0].getValue();
                     if (selectedValue) {
                        var removeIndex = null;
                        var removeItem = listFields.filter(function (f, index) {
                           if (f.id == selectedValue) {
                              removeIndex = index;
                              return true;
                           } else {
                              return false;
                           }
                        });
                        // var removeItem = $.grep(listFields, function (f, index) {
                        // 	if (f.id == selectedValue) {
                        // 		removeIndex = index;
                        // 		return true;
                        // 	}
                        // 	else {
                        // 		return false;
                        // 	}
                        // });
                        listFields.splice(removeIndex, 1);
                     }
                  });
               }
            }
            return listFields;
         },

         /**
          * @function objectLoad
          * Ready the Popup according to the current object
          * @param {ABObject} object  the currently selected object.
          */
         objectLoad: function (object) {
            CurrentObject = object;
         },

         /**
          * @method setSettings
          *
          * @param {Array} settings - [
          * 								{
          * 									key: uuid,		// id of ABField
          *	 								dir: string,	// 'asc' or 'desc'
          * 								}
          * 							]
          */
         setSettings: (settings) => {
            this._settings = this.AB.cloneDeep(settings);
         },

         /**
          * @function getSettings
          *
          * @return {Array} - [
          * 						{
          * 							key: uuid,		// id of ABField
          * 							dir: string,	// 'asc' or 'desc'
          * 						}
          * 					]
          */
         getSettings: function () {
            var sort_form = $$(ids.form),
               sortFields = [];

            var childViews = sort_form.getChildViews();
            if (childViews.length > 1) {
               // Ignore 'Add new sort' button
               childViews.forEach(function (cView, index) {
                  if (childViews.length - 1 <= index) return false;

                  var fieldId = cView.getChildViews()[0].getValue();
                  var dir = cView.getChildViews()[1].getValue();
                  sortFields.push({
                     // "by":by,
                     key: fieldId,
                     dir: dir,
                     // "isMulti":isMultiLingual
                  });
               });
            }

            return sortFields;
         },

         onChangeCombo: function (columnId, el) {
            var allFields = CurrentObject.fields();
            var columnConfig = "",
               sortDir = el.getParentView().getChildViews()[1],
               // isMultiLingual = el.getParentView().getChildViews()[2],
               // isMulti = 0,
               options = null;

            allFields.forEach((f) => {
               if (f.id == columnId) {
                  columnConfig = f;
               }
            });

            if (!columnConfig) return;

            switch (columnConfig.key) {
               case "string":
                  options = [
                     { id: "asc", value: L("A -> Z") },
                     { id: "desc", value: L("Z -> A") },
                  ];
                  break;
               case "date":
                  options = [
                     { id: "asc", value: L("Before -> After") },
                     { id: "desc", value: L("After -> Before") },
                  ];
                  break;
               case "number":
                  options = [
                     { id: "asc", value: L("1 -> 9") },
                     { id: "desc", value: L("9 -> 1") },
                  ];
                  break;
               default:
                  options = [
                     { id: "asc", value: L("A -> Z") },
                     { id: "desc", value: L("Z -> A") },
                  ];
                  break;
            }

            sortDir.define("options", options);
            sortDir.refresh();

            // if (columnConfig.settings.supportMultilingual)
            // 	isMulti = columnConfig.settings.supportMultilingual;

            // isMultiLingual.setValue(isMulti);

            _logic.refreshFieldList();

            _logic.triggerOnChange();
         },

         /**
          * @function objectLoad
          * Ready the Popup according to the current object
          * @param {ABObject} object  the currently selected object.
          */
         onShow: () => {
            var sort_form = $$(ids.form);

            // clear field options in the form
            webix.ui(formUI, sort_form);
            // var childViews = sort_form.getChildViews();
            // childViews.forEach(function(i, idx, array){
            // 	if (idx !== array.length - 1){
            // 		sort_form.removeView(i);
            // 	}
            // });

            var sorts = this._settings;
            if (sorts && sorts.forEach) {
               sorts.forEach((s) => {
                  _logic.clickAddNewSort(s.key, s.dir);
               });
            }

            if (sorts == null || sorts.length == 0) {
               _logic.clickAddNewSort();
            }
         },

         /**
          * @function refreshFieldList
          * return an updated field list so you cannot duplicate a sort
          */
         refreshFieldList: function (ignoreRemoveViews) {
            var sort_form = $$(ids.form),
               listFields = _logic.getFieldList(false),
               selectedFields = [],
               removeChildViews = [];

            var childViews = sort_form.getChildViews();
            if (childViews.length > 1) {
               // Ignore 'Add new sort' button
               childViews.forEach(function (cView, index) {
                  if (childViews.length - 1 <= index) return false;

                  var fieldId = cView.getChildViews()[0].getValue(),
                     // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId });
                     fieldObj = listFields.filter(function (f) {
                        return f.id == fieldId;
                     });

                  if (fieldObj.length > 0) {
                     // Add selected field to list
                     selectedFields.push(fieldObj[0]);
                  } else {
                     // Add condition to remove
                     removeChildViews.push(cView);
                  }
               });
            }

            // Remove filter conditions when column is deleted
            if (!ignoreRemoveViews) {
               removeChildViews.forEach(function (cView, index) {
                  sort_form.removeView(cView);
               });
            }

            // Field list should not duplicate field items
            childViews = sort_form.getChildViews();
            if (childViews.length > 1) {
               // Ignore 'Add new sort' button
               childViews.forEach(function (cView, index) {
                  if (childViews.length - 1 <= index) return false;

                  var fieldId = cView.getChildViews()[0].getValue(),
                     // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId }),
                     fieldObj = listFields.filter(function (f) {
                        return f.id == fieldId;
                     });

                  // var selectedFieldsExcludeCurField = $(selectedFields).not(fieldObj);
                  var selectedFieldsExcludeCurField = selectedFields.filter(
                     function (x) {
                        if (
                           Array.isArray(fieldObj) &&
                           fieldObj.indexOf(x) !== -1
                        ) {
                           return false;
                        }
                        return true;
                     }
                  );

                  // var enableFields = $(listFields).not(selectedFieldsExcludeCurField).get();
                  var enableFields = listFields.filter(function (x) {
                     if (
                        Array.isArray(selectedFieldsExcludeCurField) &&
                        selectedFieldsExcludeCurField.indexOf(x) !== -1
                     ) {
                        return false;
                     }
                     return true;
                  });

                  // Update field list
                  cView.getChildViews()[0].define("options", enableFields);
                  cView.getChildViews()[0].refresh();
               });
            }
         },

         /**
          * @function triggerOnChange
          * This parses the sort form to build in order the sorts then saves to the application object workspace
          */
         triggerOnChange: () => {
            // block .onChange callback
            if (this._blockOnChange) return;

            this._settings = _logic.getSettings();

            _logic.callbacks.onChange(this._settings);

            // if (CurrentView != null) {
            // 	CurrentView.settings = CurrentView.settings || {};
            // 	CurrentView.settings.objectWorkspace = CurrentView.settings.objectWorkspace || {};
            // 	CurrentView.settings.objectWorkspace.sortFields = sortFields;
            // 	_logic.callbacks.onChange(CurrentView.settings.objectWorkspace);
            // } else {
            // 	CurrentObject.workspaceSortFields = sortFields;
            // 	CurrentObject.save()
            // 	.then(function(){
            // 		_logic.callbacks.onChange();
            // 	})
            // 	.catch(function(err){
            // 		OP.Error.log('Error trying to save workspaceSortFields', {error:err, fields:sortFields });
            // 	});
            // }
         },

         blockOnChange: () => {
            this._blockOnChange = true;
         },

         unblockOnChange: () => {
            this._blockOnChange = false;
         },

         /**
          * @function show()
          *
          * Show this component.
          * @param {obj} $view  the webix.$view to hover the popup around.
          * @param {uuid} fieldId the fieldId we want to prefill the sort with
          */
         show: ($view, fieldId, options) => {
            _logic.blockOnChange();

            $$(ids.component).show($view, options || null);

            if (fieldId) {
               _logic.clickAddNewSort(fieldId);
            }

            _logic.unblockOnChange();
         },

         /**
          * @function sort()
          * client sort data in list
          *
          * @param {Object} a
          * @param {Object} b
          */
         sort: function (a, b) {
            var result = 0;

            var childViews = $$(ids.form).getChildViews();
            if (childViews.length > 1) {
               // Ignore 'Add new sort' button
               childViews.forEach(function (cView, index) {
                  if (childViews.length - 1 <= index || result != 0) return;

                  var fieldId = cView.getChildViews()[0].getValue();
                  var dir = cView.getChildViews()[1].getValue();

                  var field = CurrentObject.fieldByID(fieldId);
                  if (!field) return;

                  var by = field.columnName; // column name

                  var aValue = a[by],
                     bValue = b[by];

                  if (Array.isArray(aValue)) {
                     aValue = (aValue || [])
                        .map(function (item) {
                           return item.text || item;
                        })
                        .join(" ");
                  }

                  if (Array.isArray(bValue)) {
                     bValue = (bValue || [])
                        .map(function (item) {
                           return item.text || item;
                        })
                        .join(" ");
                  }

                  if (aValue != bValue) {
                     if (dir == "asc") {
                        result = aValue > bValue ? 1 : -1;
                     } else {
                        result = aValue < bValue ? 1 : -1;
                     }
                  }
               });
            }

            return result;
         },
      });

      // Expose any globally accessible Actions:
      this.actions({});

      //
      // Define our external interface methods:
      //
      this.objectLoad = _logic.objectLoad;
      this.show = _logic.show;
      this.sort = _logic.sort;

      this.setValue = _logic.setSettings;
      this.getValue = _logic.getSettings;
   }
};


/***/ }),

/***/ 68768:
/*!*********************************!*\
  !*** ./AppBuilder/ABFactory.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/ABFactoryCore */ 35095);
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ 30381);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! nanoid */ 53416);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! uuid */ 72045);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./platform/FilterComplex */ 21021);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _config_Config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/Config.js */ 24998);
/* harmony import */ var _resources_Account_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/Account.js */ 32383);
/* harmony import */ var _ui_ClassUI_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ui/ClassUI.js */ 32735);
/* harmony import */ var _factory_utils_Dialog_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_factory_utils/Dialog.js */ 5594);
/* harmony import */ var _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../resources/Multilingual.js */ 50616);
/* harmony import */ var _resources_Network_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../resources/Network.js */ 66921);
/* harmony import */ var _resources_Storage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../resources/Storage.js */ 53113);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/ABViewManagerCore */ 15753);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../resources/Tenant.js */ 23325);
/* harmony import */ var _uiSettings_config_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./uiSettings/config.js */ 6534);
/* harmony import */ var _js_webix_webix_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../js/webix/webix.js */ 93794);
/* harmony import */ var _js_webix_webix_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_js_webix_webix_js__WEBPACK_IMPORTED_MODULE_11__);









//
// Our Common Resources
//

// Config : responsible for all the configuration/settings of our instance.


// Account : manages the current Logged in User and Account information.




// Dialog : common UI dialogs.


// Multilingual: our interface Labels and language options


// Network: our interface for communicating to our server


// Storage: manages our interface for local storage




// Tenant: manages the Tenant information of the current instance


// UISettings: detailed settings for our common UI elements


// NOTE: moved to require() because using import with webix_debug.js
// really messed things up!
// var Webix = require("../js/webix/webix-debug.js");

class ABValidator {
   constructor(AB) {
      this.AB = AB;
      this.errors = [];
   }

   addError(name, message) {
      this.errors.push({ name: name, message: message });
   }

   pass() {
      return this.errors.length == 0;
   }

   fail() {
      return this.errors.length > 0;
   }

   toValidationObject() {
      var obj = {
         error: "E_VALIDATION",
         invalidAttributes: {},
      };

      var attr = obj.invalidAttributes;

      this.errors.forEach((e) => {
         attr[e.name] = attr[e.name] || [];
         attr[e.name].push(e);
      });

      return obj;
   }

   updateForm(form) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isFormValidationError(vObj, form);
   }

   updateGrid(rowID, grid) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isGridValidationError(vObj, rowID, grid);
   }
}

//
// AppBuilder Objects
//

class ABFactory extends (_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2___default()) {
   constructor(definitions) {
      super(definitions);

      // Common Reference to Configuration Values
      this.Config = _config_Config_js__WEBPACK_IMPORTED_MODULE_3__["default"];

      this.Class.FilterComplex = (_platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4___default());

      //
      // Resources
      //
      this.Account = _resources_Account_js__WEBPACK_IMPORTED_MODULE_5__["default"];
      this.Dialog = _factory_utils_Dialog_js__WEBPACK_IMPORTED_MODULE_6__["default"];
      this.Multilingual = _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_7__["default"];
      this.Network = _resources_Network_js__WEBPACK_IMPORTED_MODULE_8__["default"];
      this.Storage = _resources_Storage_js__WEBPACK_IMPORTED_MODULE_9__["default"];
      this.Tenant = _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_10__["default"];
      this.Webix = (_js_webix_webix_js__WEBPACK_IMPORTED_MODULE_11___default());

      // Plugin Classes
      this.ClassUI = _ui_ClassUI_js__WEBPACK_IMPORTED_MODULE_12__["default"];

      // additional Class definitions
      this.Class.ABViewManager = (_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_13___default());

      // Temp placeholders until Resources are implemented:
      this.Analytics = {
         log: () => {},
         logError: () => {},
      };
      this.Lock = class Lock {
         constructor() {}

         acquire() {
            return Promise.resolve();
         }
         release() {
            return Promise.resolve();
         }
      };

      this.UISettings = _uiSettings_config_js__WEBPACK_IMPORTED_MODULE_14__["default"];

      this.Validation = {
         validator: () => {
            return new ABValidator(this);
         },

         errorSailsCleanup: function (error) {
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               // dig down to sails provided error object:
               if (
                  error.error &&
                  error.error == "E_UNKNOWN" &&
                  error.raw &&
                  error.raw.length > 0
               ) {
                  error = error.raw[0];
               }

               // drill down to the embedded .err object if it exists
               if (error.err) {
                  error = error.err;
               }

               // if this is from our server response:
               if (
                  error.data &&
                  error.data.error &&
                  error.data.error == "E_VALIDATION"
               ) {
                  error = error.data;
               }
            }

            return error;
         },

         /**
          * @function AB.Validation.isFormValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of the form elements.
          *
          * @codestart
          * var form = $$('formID');
          * var values = form.getValues();
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Form.isFormValidationError(err, form)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {obj} error
          *        the error response object
          * @param {obj} form
          *        the webix form instance (or reference)
          * @return {bool}
          *         true if error was about a form element.
          *         false otherwise.
          */
         isFormValidationError: function (error, form) {
            var hasFocused = false;
            // {bool} have we set focus to form component?

            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasForm = false;
                     for (var attr in attrs) {
                        // if this is a field in the form:
                        if (form.elements[attr]) {
                           var errors = attrs[attr];
                           var msg = [];
                           errors.forEach(function (err) {
                              msg.push(err.message);
                           });

                           // set the invalid error message
                           form.markInvalid(attr, msg.join(", "));

                           // set focus to the 1st form element we mark:
                           if (!hasFocused) {
                              form.elements[attr].focus();
                              hasFocused = true;
                           }

                           wasForm = true;
                        }
                     }

                     if (wasForm) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our form with an error
            // this was not a validation error so return false
            return false;
         },

         /**
          * @method AB.Validation.isGridValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of our grid columns.
          *
          * @codestart
          * var grid = $$('myGrid');
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Validation.isGridValidationError(err, editor, grid)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {Error} error
          *        the error response object
          * @param {integer} row
          *        the row id of the Grid to update.
          * @param {webix.datatable} Grid
          *        the webix grid instance (or reference)
          * @return {bool}
          *         true if error was about a grid column.
          *         false otherwise.
          */
         isGridValidationError: function (error, row, Grid) {
            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasGrid = false;
                     for (var attr in attrs) {
                        Grid.addCellCss(row, attr, "webix_invalid");
                        Grid.addCellCss(row, attr, "webix_invalid_cell");

                        var msg = [];
                        attrs[attr].forEach((e) => {
                           msg.push(e.message);
                        });

                        webix.alert({
                           text: attr + ": " + msg.join(", "),
                        });

                        wasGrid = true;
                     }

                     Grid.refresh(row);
                     Grid.clearSelection();

                     if (wasGrid) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our Grid with an error
            // this was not a validation error so return false
            return false;
         },
      };

      // TODO: make sure "error" s are handled and sent to logs
      // this.on("error", ()=>{ Analytics.error })

      this.Definitions = {};
      // {obj} the provided interface for working with the ABDefinition table.
      // NOTE: on the web client, we simply perform web API calls to perform
      // the actions.  These are defined below.

      this.on("error", (err) => {
         // this simply prevents thrown errors if there are no listeners.
         console.error(err);
      });

      this._plugins = [];
      // {array} of loaded Plugin.applications.

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our definitionsXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this.Network.on("definition.create", (context, err, fullDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // this.error(err);
            pending?.reject(err);
            return;
         }

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: fullDef.id,
            data: fullDef,
         };
         this.emit("ab.abdefinition.create", pkt);

         let newDef = this.definitionNew(fullDef);
         pending?.resolve(newDef);
      });

      this.Network.on("definition.update", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            if (err.toString().indexOf("Not Found") > -1) {
               return this.definitionCreate(context.values)
                  .then(pending?.resolve)
                  .catch(pending?.reject);
            }
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         this._definitions[context.id] = serverDef;

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: serverDef.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.update", pkt);

         pending?.resolve(serverDef);
      });

      this.Network.on("definition.delete", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         delete this._definitions[context.id];

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: context.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.delete", pkt);

         pending?.resolve();
      });
   }

   /**
    * init()
    * prepare the ABFactory for operation. This includes parsing the
    * definitions into useable objects, preparing the System Resources, etc.
    * @return {Promise}
    */
   async init() {
      //
      // Prepare our Resources First
      //
      var allInits = [];

      allInits.push(this.Account.init(this));
      allInits.push(this.Multilingual.init(this));
      allInits.push(this.Network.init(this));
      allInits.push(this.Tenant.init(this));

      await Promise.all(allInits);
      await this.Storage.init(this);
      var data = await this.Storage.get("local_settings");
      this._localSettings = data || {};

      //
      // Real Time Update Handlers
      //

      // new ABDefinition created:
      this.on("ab.abdefinition.create", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition

         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("created", pkt.id, pkt.data);
      });

      // ABDefinition updated:
      this.on("ab.abdefinition.update", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("updated", pkt.id, pkt.data);
      });

      // ABDefinition delete:
      this.on("ab.abdefinition.delete", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         delete this._definitions[pkt.id];
         this.definitionSync("destroyed", pkt.id, pkt.data);
      });

      return super.init();

      // return Promise.all(allInits)
      //    .then(() => {
      //       // some Resources depend on the above to be .init() before they can
      //       // .init() themselves.
      //       return this.Storage.init(this).then(() => {
      //          return this.Storage.get("local_settings").then((data) => {
      //             this._localSettings = data || {};
      //          });
      //       });
      //    })
      //    .then(() => {
      //       //
      //       // RealTime Updates of our ABDefinitions
      //       //

      //       // new ABDefinition created:
      //       this.on("ab.abdefinition.create", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition

      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("created", pkt.id, pkt.data);
      //       });

      //       // ABDefinition updated:
      //       this.on("ab.abdefinition.update", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("updated", pkt.id, pkt.data);
      //       });

      //       // ABDefinition delete:
      //       this.on("ab.abdefinition.delete", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          delete this._definitions[pkt.id];
      //          this.definitionSync("destroyed", pkt.id, pkt.data);
      //       });

      //       return super.init();
      //    });
   }

   /**
    * definiitonCreate(def)
    * create a new ABDefinition
    * @param {obj} def
    *        the value hash of the new definition entry
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionCreate(def) {
      // we will set our uuid
      if (typeof def.id == "undefined") {
         def.id = this.uuid();
         def.json.id = def.id;
      }

      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.create",
            context: {
               uuid,
            },
         };
         this.Network.post(
            {
               url: `/definition/create`,
               data: def,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to CREATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to CREATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionCreate()",
               message,
               def,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionDestroy(id)
    * delete an ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @return {Promise}
    */
   async definitionDestroy(id) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.delete",
            context: {
               id,
               uuid,
            },
         };
         this.Network.delete(
            {
               url: `/definition/${id}`,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to DESTROY definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to DELETE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionDestroy()",
               message,
               id,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionUpdate(id, def)
    * update an existing ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to update.
    * @param {obj} values
    *        the value hash of the new definition values
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionUpdate(id, values) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.update",
            context: {
               id,
               uuid,
               values,
            },
         };
         this.Network.put(
            {
               url: `/definition/${id}`,
               data: values,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to UPDATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to UPDATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionUpdate()",
               message,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   // definitionsParse(defs = []) {
   //    if (!Array.isArray(defs)) {
   //       defs = [defs];
   //    }

   //    // store/replace the incoming definitions
   //    // 1st: insert ALL our definitions internally
   //    defs.forEach((d) => {
   //       this._definitions[d.id] = d;
   //    });
   //    // 2nd: Now we can then go through and signal the "updates"
   //    // and the related objects can find their dependent definitions.
   //    defs.forEach((d) => {
   //       this.definitionSync("updated", d.id, d);
   //    });

   //    return Promise.resolve();
   // }

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(domain, error, info) {
      console.error("TODO: ABFactory.notify(): pass error off to analytics");
      console.error(error);
      console.error(info);
   }

   plugins() {
      return this._plugins;
   }
   pluginLoad(p) {
      this._plugins.push(p);
   }

   //
   // Utilities
   //
   alert(options) {
      _js_webix_webix_js__WEBPACK_IMPORTED_MODULE_11___default().alert(options);
   }

   cloneDeep(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(value);
   }

   error(message, ...rest) {
      var emitData = {
         message: `ABFactory[${this.Tenant.id()}]:${message.toString()}`,
      };

      console.error(emitData.message);
      if (message instanceof Error) {
         emitData.error = message;
         // this dumps the error.stack
         console.error(message);
      }

      if (rest && rest.length > 0) {
         rest.forEach((r) => {
            if (r instanceof Error) {
               emitData.error = r;
               // this dumps the error.stack
               console.error(r);
            }

            if (typeof r == "object") {
               for (var k in r) {
                  emitData[k] = r[k];
                  console.error(k, r[k]);
               }
            }
         });
      }
      this.emit("error", emitData);
   }

   jobID() {
      return (0,nanoid__WEBPACK_IMPORTED_MODULE_15__.nanoid)();
   }

   Label() {
      return (...params) => {
         return this.Multilingual.label(...params);
      };
   }

   localSettings(key, value) {
      if (typeof value == "undefined") {
         // this is a getter:
         return this._localSettings[key];
      } else {
         // setting a value:
         this._localSettings[key] = value;
         return this.Storage.set(`local_settings`, this._localSettings);
      }
   }

   log(message, ...rest) {
      console.log(message);
      rest.forEach((r) => {
         console.log(r);
      });
   }

   /**
    * @method rules.isUUID
    * evaluate a given value to see if it matches the format of a uuid
    * @param {string} key
    * @return {boolean}
    */
   isUUID(key) {
      var checker = RegExp(
         "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
         "i"
      );
      return checker.test(key);
   }

   merge(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().merge(...params);
   }

   orderBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().orderBy(...params);
   }

   uniq(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().uniq(...params);
   }

   kebabCase(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().kebabCase(...params);
   }

   sumBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().sumBy(...params);
   }

   meanBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().meanBy(...params);
   }

   maxBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().maxBy(...params);
   }

   minBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().minBy(...params);
   }

   uuid() {
      return (0,uuid__WEBPACK_IMPORTED_MODULE_16__["default"])();
   }

   warn(message, ...rest) {
      console.warn(message);
      rest.forEach((r) => {
         console.warn(r);
      });
   }

   /**
    * @method toDate
    *
    * @param {string} dateText
    * @param {Object} options - {
    *                               format: "string",
    *                               ignoreTime: boolean
    *                            }
    * @return {Date}
    */
   toDate(dateText = "", options = {}) {
      if (!dateText) return;

      if (options.ignoreTime) dateText = dateText.replace(/T.*/, "");

      let result = options.format
         ? moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText, options.format)
         : moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText);

      let supportFormats = [
         "YYYY-MM-DD",
         "YYYY/MM/DD",
         "DD/MM/YYYY",
         "MM/DD/YYYY",
         "DD-MM-YYYY",
         "MM-DD-YYYY",
      ];

      supportFormats.forEach((format) => {
         if (!result || !result.isValid()) result = moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText, format);
      });

      return new Date(result);
   }

   /**
    * @method toDateFormat
    *
    * @param {Date} date
    * @param {Object} options - {
    *           format: "string",
    *           localeCode: "string"
    *         }
    *
    * @return {string}
    */
   toDateFormat(date, options) {
      if (!date) return "";

      let momentObj = moment__WEBPACK_IMPORTED_MODULE_1___default()(date);

      if (options.localeCode) momentObj.locale(options.localeCode);

      return momentObj.format(options.format);
   }

   /**
    * @method subtractDate
    *
    * @param {Date} date
    * @param {number} number
    * @param {string} unit
    *
    * @return {Date}
    */
   subtractDate(date, number, unit) {
      return moment__WEBPACK_IMPORTED_MODULE_1___default()(date).subtract(number, unit).toDate();
   }

   /**
    * @method addDate
    *
    * @param {Date} date
    * @param {number} number
    * @param {string} unit
    *
    * @return {Date}
    */
   addDate(date, number, unit) {
      return moment__WEBPACK_IMPORTED_MODULE_1___default()(date).add(number, unit).toDate();
   }

   isString(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABFactory);


/***/ }),

/***/ 5594:
/*!*********************************************!*\
  !*** ./AppBuilder/_factory_utils/Dialog.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
// Dialog
// A common set of UI dialogs to show the User.
//
// NOTE: IN TRANSITION: this is our previous method of handling
// dialogs.  In future, refactor to use webix directly in code.
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Instance properties

   // Alert
   // A dialogue that popup with a message, and requires an [ok] button press
   Alert: function (opts) {
      webix.alert({
         title:
            opts.title ||
            AB.Multilingual.label("opp.dialog.alert.title", "*Alert"),
         text:
            opts.text ||
            opts.message ||
            AB.Multilingual.label(
               "opp.dialog.alert.text",
               "*Something is wrong."
            ),
         ok: opts.ok || AB.Multilingual.label("opp.dialog.alert.ok", "*OK"),
      });
   },

   // Confirm
   // A [Yes] [No] dialogue that pops up with a message
   Confirm: function (opts) {
      var title =
         opts.title ||
         AB.Multilingual.label("opp.dialog.confirm.confirmTitle", "* Confirm");
      var message =
         opts.text ||
         opts.message ||
         AB.Multilingual.label(
            "opp.dialog.confirm.confirmMsg",
            "* Are you sure you want to do this?"
         );

      var labelYes =
         opts.labelYes ||
         opts.ok ||
         AB.Multilingual.label("opp.common.yes", "* yes");
      var labelNo =
         opts.labelNo ||
         opts.cancel ||
         AB.Multilingual.label("opp.common.no", "* no");

      // var fnYes = opts.fnYes || function () { };
      // var fnNo = opts.fnNo || function () { };

      webix.confirm({
         title: title,
         text: message,

         ok: labelYes,
         cancel: labelNo,

         callback: function (result) {
            if (result) {
               if (opts.fnYes) opts.fnYes();
            } else {
               if (opts.fnNo) opts.fnNo();
            }

            if (opts.callback) opts.callback(result);
         },
      });

      // bootbox.dialog({
      //     title: title,
      //     message: message,
      //     buttons: {
      //         yes: {
      //             label: labelYes,
      //             className: 'btn-primary',
      //             callback: fnYes
      //         },
      //         no: {
      //             label: labelNo,
      //             className: 'btn-default',
      //             callback: fnNo
      //         }
      //     }
      // });
   },

   // ConfirmDelete
   // A Confirm dialogue geared towards deleting items.
   // [delete] [cancel]
   ConfirmDelete: function (opts) {
      this.Confirm({
         title:
            opts.title ||
            AB.Multilingual.label(
               "opp.dialog.confirm.deleteTitle",
               "* Confirm Delete"
            ),
         ok: opts.ok || AB.Multilingual.label("opp.common.delete", "* Delete"),
         cancel:
            opts.cancel ||
            AB.Multilingual.label("opp.common.cancel", "* Cancel"),
         text:
            opts.text ||
            opts.message ||
            AB.Multilingual.label(
               "opp.dialog.confirm.deleteMsg",
               "* Are you sure you want to delete this?",
               ["this"]
            ),
         callback: function (result) {
            if (result) {
               if (opts.fnYes) opts.fnYes();
            } else {
               if (opts.fnNo) opts.fnNo();
            }

            if (opts.callback) opts.callback(result);
         },
      });
   },

   // Message
   // A simple message displayed to the user.  Can time out
   Message: function (opts) {
      var message = opts.text || opts.message;
      var timeout = opts.timeout || 2000;

      webix.message({
         text: message,
         expire: timeout,
      });
   },
});


/***/ }),

/***/ 69885:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABApplicationCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABApplicationCore
 *
 * This is the core ABApplication class that manages the common operations
 * of an ABApplication across platforms.
 *
 * It's primary responsibility is to decode a given set of attributes into
 * a working instance of an ABApplication that can return instances of
 * it's defined sub objects.
 *
 * Platform Specific versions of those objects should be defined in a peer
 * directory named platform. These versions of the objects should override
 * these Core objects with platform specific methods of operation (like
 * .save()).
 *
 * Initially your target application should load your platform/ABApplication.js
 * file, which will include this file and sub class it.
 *
 * However, this file will include the remaining files from your platform/*
 * versions.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
const ABViewManager = __webpack_require__(/*! ../platform/ABViewManager */ 44312);
var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);

function toBool(val) {
   if (typeof val == "undefined") {
      return false;
   }

   if (val === "" || val === "false" || val === "0") {
      return false;
   }

   if (val === "true" || val === "1") {
      return true;
   }

   return val;
}

module.exports = class ABApplicationCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label", "description"], AB);

      // attributes should be in format:
      // {
      //    id:##,
      //    json:{},
      //    name:"XYZ"
      // }
      attributes.json = attributes.json || {};

      // ABApplication Attributes
      this.id = attributes.id;
      // {string} uuid

      this.type = attributes.type || "application";
      // {string} .type
      // the ABDefinition.type of this object.

      this.json = attributes.json;
      if (typeof this.json == "string") this.json = JSON.parse(this.json);
      // {obj} .json
      // the full settings of this ABApplication

      this.name = attributes.name || this.json.name || "";
      // {string} .name
      // the hard coded name of this ABDefinition Object, not to be confused
      // with the .label.  The .name is created at design time and is a text
      // reference for this object.

      this.icon = attributes.icon || "fa-rocket";
      // {string} .icon
      // this is a reference to a font awesome icon including the `fa-`
      // example `fa-child` should be stored for the `child` icon to be used
      // if user wants to get creative they can add more to this field following
      // these examples https://fontawesome.com/v4/examples/

      this.isSystemObject = toBool(attributes.isSystemObject);
      // {bool} .isSystemObject
      // is this one of the integrated System Objects used by our framework?
      // Some ABApplications and ABObjects are central to the running of the
      // AppBuilder site.  They are marked with .isSystemObject = true;  It
      // requires the role "System Designer" in order to edit/modify them.

      this.roleAccess = attributes.roleAccess || [];
      if (!Array.isArray(this.roleAccess)) {
         this.roleAccess = [this.roleAccess];
      }
      this.roleAccess = this.roleAccess.filter((r) => r);
      // {array}
      // the {ABSiteRole.id}s of the roles allowed to work with this
      // ABApplication. (see .isAccessManaged for more info)

      this.isAccessManaged = JSON.parse(attributes.isAccessManaged || false);
      // {bool} .isAccessManaged
      // does this Application imploy the more sophisticated  Access
      // permissions, or the simpler Role access permissions.
      // {true} : allows an administrator to set which role can View|Edit|Delete
      //          elements of an application.
      // {false}: indicates users having one of the .roleAccess values can have
      //          full access to this application

      this.accessManagers = attributes.accessManagers;
      if (typeof this.accessManagers == "string")
         this.accessManagers = JSON.parse(this.accessManagers);
      // {??} .accessManagers
      // if .isAccessManaged == true, then .accessManagers contain the definitions
      // of the detailed access permissions.

      this.isTranslationManaged = JSON.parse(
         attributes.isTranslationManaged || false
      );
      this.translationManagers = attributes.translationManagers;
      if (typeof this.translationManagers == "string")
         this.translationManagers = JSON.parse(this.translationManagers);

      this.objectIDs = attributes.json.objectIDs || [];
      // {array} .objectIDs
      // All the {ABObject.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObject}s are included or excluded from this app.

      this.queryIDs = attributes.json.queryIDs || [];
      // {array} .queryIDs
      // All the {ABObjectQuery.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObjectQueries}s are included or excluded from
      // this app.

      this.datacollectionIDs = attributes.json.datacollectionIDs || [];
      // {array} .datacollectionIDs
      // All the {ABDataCollection.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABDataCollection}s are included or excluded from
      // this app.

      // import all our {ABViewPage}s
      let newPages = [];
      (attributes.json.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            newPages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.id}] is referenceing an unknown Page[${id}]`,
               {
                  appID: this.id,
                  pageID: id,
               }
            );
            // console.error(
            //    `App[${this.id}] is referenceing an unknown Page[${id}]`
            // );
         }
      });
      this._pages = newPages;
      // {array} ._pages
      // an array of all the {ABViewPages} this ABApplication offers as
      // interfaces for working with our Data.
      // ABViewPages operate within the confines of an ABApplication so
      // they are created/stored/accessed from within an ABApplication

      var newProcesses = [];
      var removePIDs = [];
      (attributes.json.processIDs || []).forEach((pID) => {
         var p = this.AB.processByID(pID);
         if (p) {
            newProcesses.push(p);
         } else {
            this.emit(
               "warning",
               `Application is referencing an unknown process.`,
               { appID: this.id, processID: pID }
            );
            //    removePIDs.push(pID);
         }
      });
      if (attributes.json.processIDs) {
         // remove those missing pIDs.
         attributes.json.processIDs = attributes.json.processIDs.filter(
            (pr) => {
               return removePIDs.indexOf(pr) == -1;
            }
         );
      }

      this._processes = newProcesses;
      // {array} ._processes
      // the ABProcess instances created by this ABApplication.

      this.processIDs = attributes.json.processIDs || [];
      // {array} .processIDs
      // an array of all the {ABProcess.id}s referenced by this Application.

      // Object List Settings
      attributes.json.objectListSettings =
         attributes.json.objectListSettings || {};
      this.objectListSettings = this.objectListSettings || {};
      this.objectListSettings.isOpen = JSON.parse(
         attributes.json.objectListSettings.isOpen || false
      );
      this.objectListSettings.searchText =
         attributes.json.objectListSettings.searchText || "";
      this.objectListSettings.sortDirection =
         attributes.json.objectListSettings.sortDirection || "asc";
      this.objectListSettings.isGroup = JSON.parse(
         attributes.json.objectListSettings.isGroup || false
      );

      // let the MLClass now process the translations:
      // transition issues:
      attributes.translations =
         attributes.translations || attributes.json.translations;

      super.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods
   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABApplication is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      // if we are on the basic Role assignments:
      if (!this.isAccessManaged) {
         (roles || []).forEach((r) => {
            if (this.roleAccess.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
         return foundRole;
      }

      // isAccessManaged has been set, so 2 kinds of ppl can
      // see this App
      // 1) an AccessManager
      if (parseInt(this.accessManagers.useRole)) {
         (roles || []).forEach((r) => {
            if (this.accessManagers.role.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
      }

      // stop here if found.
      if (foundRole) return foundRole;

      // 2) someone who has a role that can see one of it's pages.
      // scan each Page of this Application
      (this.pages() || []).forEach((p) => {
         // check to see if that page.isAccessibleForRoles()
         if (p.isAccessibleForRoles(roles)) {
            foundRole = true;
         }
      });
      return foundRole;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      this.json = super.toObj();

      this.json.name = this.name;

      this.json.objectIDs = this.objectIDs;

      this.json.objectListSettings = this.objectListSettings;

      this.json.queryIDs = this.queryIDs;

      this.json.datacollectionIDs = this.datacollectionIDs;

      this.json.pageIDs = (this._pages || []).map((p) => p.id);

      this.json.processIDs = (this._processes || []).map((p) => {
         return p.id;
      });

      // // for each MobileApp: compile to json
      // var currApps = [];
      // this._mobileApps.forEach((app) => {
      //    currApps.push(app.toObj())
      // })
      // this.json.mobileApps = currApps;

      return {
         id: this.id,
         type: this.type || "application",
         name: this.name,
         icon: this.icon,
         isSystemObject: this.isSystemObject,
         json: this.json,
         roleAccess: this.roleAccess,
         translations: this.json.translations,
         isAccessManaged: this.isAccessManaged,
         isTranslationManaged: this.isTranslationManaged,
         accessManagers: this.accessManagers,
         translationManagers: this.translationManagers,
      };
   }

   ///
   /// Mobile Apps
   ///

   /**
    * @method mobileApps()
    *
    * return an array of all the ABObjectQueries for this ABApplication.
    *
    * @param {fn} filter   a filter fn to return a set of ABObjectQueries that
    *                this fn returns true for.
    * @return {array}   array of ABObjectQueries
    */
   mobileApps(filter = () => true) {
      return (this._mobileApps || []).filter(filter);
   }

   ///
   /// Datacollections
   ///

   ///
   /// Data collections
   ///

   // datacollectionNew(values) {
   //    return new ABDataCollectionCore(values, this);
   // }

   datacollectionsExcluded(filter = () => true) {
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   datacollectionsIncluded(filter = () => true) {
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) > -1;
      }).filter(filter);
   }

   ///
   /// Objects
   ///

   objectsExcluded(filter = () => true) {
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   objectsIncluded(filter = () => true) {
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) > -1;
      }).filter(filter);
   }

   /**
    * @method connectedObjects()
    *
    * return an array of all the connected ABObjects for a given ABObject.
    *
    * @param {string} id
    *        an ID of an ABObject
    * @return {array}   array of options for webix select
    *         [ {id, value}, ... ]
    */
   connectedObjects(id) {
      console.error(
         "ABApplicationCore.connectedObjects(): who is calling this?"
      );

      if (id == "") return [];

      // Determine the object from the ID
      var myObj = this.AB.objectByID(id);

      // Get all the connected Fields for that object
      var connectedFields = myObj.connectFields();
      // Store the related fields associatively inside their related Objects ID
      var connectedObj = {};
      connectedFields.forEach((f) => {
         connectedObj[f.settings.linkObject] = this.AB.objectByID(
            f.settings.linkObject
         );
      });
      // Look up the objects by their ID and push them in an options array
      var linkedObjects = [];
      Object.keys(connectedObj).forEach(function (key /*, index */) {
         linkedObjects.push({
            id: this[key].id,
            value: this[key].label,
         });
      }, connectedObj /* = this. inside fn */);

      return linkedObjects;
   }

   /**
    * @method connectedFields()
    * return an array of all the connected ABFields for a given ABObject
    * @param {string} currObjID
    *        an ID of the current ABObject
    * @param {string} linkedObjectID
    *        an ID of the linked ABObject
    * @return {array}
    *        array of options for webix select
    */
   connectedFields(currObjID, linkedObjectID) {
      console.error("!!! Who is calling this?");

      // Determine the object from the currObjID
      var myObj = this.AB.objectByID(currObjID);

      // Get all the connected Fields for our object that match the linkedObjectID
      var connectedFields = myObj.connectFields(
         (f) => f.settings.linkObject == linkedObjectID
      );
      // Build an arry of options for the webix select
      var linkedFields = [];
      connectedFields.forEach((f) => {
         linkedFields.push({ id: f.columnName, value: f.label });
      });

      return linkedFields;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    * return an array of all the ABViewPages for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABViewPages that this fn
    *        returns true for.
    * @param {boolean} deep
    *        flag to search in sub pages
    * @return {array}
    *        array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      if (!this._pages || this._pages.length < 1) return result;

      // find into sub-pages recursively
      if (filter && deep) {
         result = this._pages.filter(filter);

         if (result.length < 1) {
            this._pages.forEach((p) => {
               var subPages = p.pages(filter, deep);
               if (subPages && subPages.length > 0) {
                  result = subPages;
               }
            });
         }
      }
      // find root pages
      else {
         result = (this._pages || []).filter(filter);
      }

      return result;
   }

   ///
   /// Processes
   ///

   /**
    * @method processes()
    * return an array of all the ABProcesses for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABProcesses that
    *        this fn returns true for.
    * @return {array}
    *        array of ABProcesses
    */
   processes(filter = () => true) {
      return this._processes.filter(filter);
   }

   hasProcess(process) {
      if (process && process.id) {
         return this.processIDs.indexOf(process.id) > -1;
      } else {
         return false;
      }
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    * return an array of all the Views for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of Views that this fn
    *        returns true for.
    * @return {array}
    *        array of Views
    */
   views(filter) {
      var result = [];
      var views = [];
      var pages = [];

      if (
         (!this._pages || this._pages.length < 1) &&
         (!this._views || this._views.length < 1)
      )
         return result;

      function lookDeep(view) {
         if (view._pages && view._pages.length) {
            view._pages.forEach((p) => {
               // check the page views recusively
               var pageViews = p.views(filter, true);
               // if there was a match store it
               if (pageViews && pageViews.length > 0) {
                  result = pageViews;
               }
               // if no match move on to the subpages
               if (result.length < 1) {
                  // loop through each subpage recursively
                  var subPages = p.pages(filter, true);
                  // if there was a match store it
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
                  if (result.length < 1) {
                     lookDeep(p);
                  }
               }
            });
         }
      }

      // look at views recursively
      if (filter) {
         // look at views recursively (views can have subviews and so on)
         if (this._views) {
            views = this._views.filter(filter);

            if (views.length < 1) {
               this._views.forEach((v) => {
                  var subViews = v.views(filter, true);
                  if (subViews && subViews.length > 0) {
                     views = subViews;
                  }
               });
            }
         }

         // if no views of the root page match now look at the sub pages and their views
         if (views.length) {
            result = views;
         } else {
            // check the first level subpages
            result = this._pages.filter(filter);

            // if no match check each pages views and subpages
            if (result.length < 1) {
               // looping through pages
               lookDeep(this);
            }
         }
      }
      // find all views
      else {
         // recusively gather all views on this view
         if (this._views) {
            views = this._views;
            if (views.length) {
               views.forEach((v) => {
                  var subViews = v.views(() => true, true);
                  if (subViews && subViews.length) {
                     views = views.concat(subViews);
                  }
               });
            }
         }

         // recursively gather all pages and their views
         if (this._pages) {
            pages = this._pages;
            if (pages.length) {
               pages.forEach((p) => {
                  // grab all views on this page
                  var pageViews = p.views(() => true, true);
                  if (pageViews && pageViews.length) {
                     views = views.concat(pageViews);
                  }
                  // grab all subpages on this page
                  var subPages = p.pages(() => true, true);
                  if (subPages && subPages.length) {
                     pages = pages.concat(subPages);
                     subPages.forEach((sub) => {
                        var subViews = sub.views(() => true, true);
                        if (subViews && subViews.length) {
                           views = views.concat(subViews);
                        }
                     });
                  }
               });
            }
         }

         result = result.concat(pages, views);
      }

      return result;
   }

   /**
    * @method viewAll()
    * return a list of all the {ABViewxxx} classes available.
    * @return {array} of ABView objects
    */
   viewAll(fn = () => true) {
      return ABViewManager.allViews(fn);
   }

   ///
   /// Queries
   ///

   /**
    * queriesExcluded()
    * return a list of ABObjectQuery(s) that are not included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @return {array}
    */
   queriesExcluded(filter = () => true) {
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) == -1;
      }).filter(filter);
   }

   /**
    * queriesIncluded()
    * return a list of ABObjectQuery(s) that are included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @return {array}
    */
   queriesIncluded(filter = () => true) {
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) > -1;
      }).filter(filter);
   }

   ///
   /// Roles
   ///

   /**
    * @method roles()
    * return an array of all the ABRole for this ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which roles to return.
    * @return {array}   array of ABRole
    */
   // roles(filter = () => true) {
   //    return (this.role || []).filter(filter);
   // }

   /**
    * @method urlResolve()
    * given an object pointer, return the specific object referenced.
    * pointer must start with a '#', use '/' as delimiters, and either
    * reference an object's .id, or an object's .property.
    * for example:
    * #/_objects   : resolves to the array of ._objects pointed to by this
    *               application.
    * #/_objects/[object.id] : reolved to a specific object
    * #/_objects/[object.id]/_fields/[field.id] : resolves to a specific data field
    *               refereced by object.id.
    *
    * @param {string} pointer : the string url referencing the object you want
    *                       to retrieve.
    * @return {obj}
    */
   urlResolve(pointer) {
      var parts = pointer.split("/");

      var parseStep = (obj, steps) => {
         // we're done.  obj is what we are looking for:
         if (steps.length == 0) {
            return obj;
         }

         // pull the next step key:
         var key = steps.shift();

         // special case, "#" makes sure we are talking about the
         // Application object
         if (key == "#") {
            return parseStep(this, steps);
         }

         // if obj is an [], then key should be an .id reference to
         // lookup:
         if (Array.isArray(obj)) {
            obj = obj.filter(function (o) {
               return o.id == key;
            })[0];
            return parseStep(obj, steps);
         }

         // otherwise obj should be an {} and key a property:
         if (obj && obj[key]) {
            return parseStep(obj[key], steps);
         }

         if (key == "_objects") {
            console.error(new Error("REFACTOR: old objectBy url reference:"));

            // This can be gotten from our AB
            var id = steps.shift();
            return parseStep(this.AB.objectByID(id), steps);
         }

         // if we got here, there is an error!
         // console.error('!!! failed to lookup url:'+pointer);
         console.error("!!! failed to lookup url:" + pointer);
         return null;
      };

      return parseStep(this, parts);
   }

   /**
    * @method urlPointer()
    * return the url pointer for this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      // NOTE: if we need to expand this to search across
      // applications, then add in this application.id here:
      if (acrossApp) return "#/" + this.id + "/";
      else return "#/";
   }

   /**
    * @method urlObject()
    * return the url pointer for objects in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlObject(acrossApp) {
      return this.urlPointer(acrossApp) + "_objects/";
   }

   /**
    * @method urlView()
    * return the url pointer for pages in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPage(acrossApp) {
      return this.urlPointer(acrossApp) + "_pages/";
   }

   /**
    * @method urlQuery()
    * return the url pointer for queries in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlQuery(acrossApp) {
      return this.urlPointer(acrossApp) + "_queries/";
   }

   ///
   ///   Object List Settings
   ///
   get objectlistIsOpen() {
      return this.objectListSettings.isOpen;
   }

   set objectlistIsOpen(isOpen) {
      this.objectListSettings.isOpen = isOpen;
   }

   get objectlistSearchText() {
      return this.objectListSettings.searchText;
   }

   set objectlistSearchText(searchText) {
      this.objectListSettings.searchText = searchText;
   }

   get objectlistSortDirection() {
      return this.objectListSettings.sortDirection;
   }

   set objectlistSortDirection(sortDirection) {
      this.objectListSettings.sortDirection = sortDirection;
   }

   get objectlistIsGroup() {
      return this.objectListSettings.isGroup;
   }

   set objectlistIsGroup(isGroup) {
      this.objectListSettings.isGroup = isGroup;
   }

   ///
   /// Instance generators
   ///

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABApplication.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      // values.key = ABViewPageCore.common().key;
      values.key = "page";

      return ABViewManager.newView(values, this, null);
   }

   /**
    * @method pageByID()
    * return pages from the given {id}
    * @param {string} id
    *        the uuid of the page to return.
    * @return {ABViewPage}
    */
   pageByID(id) {
      return this.pages((f) => f.id == id)[0];
   }

   /**
    * @method viewNew()
    *
    * return an instance of a new (unsaved) ABView.
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return ABViewManager.newView(values, application, parent);
   }

   ///
   /// Utilities
   ///

   cloneDeep(/* object */) {
      var errorDepreciated = new Error(
         "ABApplicationCore.cloneDeep(): Depreciated!  Use AB.cloneDeep() instead."
      );
      throw errorDepreciated;

      // return JSON.parse(JSON.stringify(object));
   }
};


/***/ }),

/***/ 6980:
/*!*************************************************!*\
  !*** ./AppBuilder/core/ABDataCollectionCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABDataCollection
 * Defines a set of data that other parts of the Application can work with.
 * it can point to either an ABObject, or ABObjectQuery, and can have an
 * filter, and sorts defined.
 *
 *
 *
 */
// const ABEmitter = require("../platform/ABEmitter");
const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);

// const ABObject = require("../platform/ABObject");
// const ABObjectQuery = require("../platform/ABObjectQuery");
// const RowFilter = require("../platform/RowFilter");

var DefaultValues = {
   id: "uuid",
   label: "", // label
   object: {}, // json of ABObject
   query: {}, // json of ABObjectQuery
   settings: {
      datasourceID: "", // id of ABObject or ABObjectQuery
      linkDatacollectionID: "", // id of ABDatacollection
      linkFieldID: "", // id of ABField
      objectWorkspace: {
         filterConditions: {
            // array of filters to apply to the data table
            glue: "and",
            rules: [],
         },
         sortFields: [], // array of columns with their sort configurations
      },
      loadAll: false,
      // preventPopulate: false, depreciating in favour of populate
      populate: true, // true/false or array of columns to populate.
      isQuery: false, // if true it is a query, otherwise it is a object.

      fixSelect: "", // _CurrentUser, _FirstRecord, _FirstRecordDefault or row id

      syncType: 1, // 1 (Server), 2 (Client)
   },
};

const QueuedOperations = [];
// {array} of operations that we want to perform but allow some space
// between operations.
var _queueTimer = null;

function runQueue() {
   // if (!_queueTimer) {
   //    _queueTimer = setInterval(() => {
   //       runQueue();
   //    }, 20);
   // }
   if (QueuedOperations.length == 0) {
      // stop
      // clearInterval(_queueTimer);
      _queueTimer = null;
      return;
   }
   var op = QueuedOperations.shift();
   op.fn();
   _queueTimer = setTimeout(runQueue, op.timeout);
}
function queueOperation(fn, timeout = 20) {
   QueuedOperations.push({ fn, timeout });
   if (!_queueTimer) {
      runQueue();
   }
}

module.exports = class ABDataCollectionCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      attributes = attributes || {};

      // this.application = application;

      this.fromValues(attributes);

      this.__dataCollection = this._dataCollectionNew([]);
      // {DataCollection}
      // This is a working instance of a DataCollection, not an {ABDatacCollection}
      // On web/mobile this is a webix component.  So keep the creation as part of
      // the platform/ABDataCollection implementation.

      // Set filter value
      this.refreshFilterConditions();

      this.__bindComponentIds = [];
      this.__flexComponentIds = [];

      // refresh a data collection
      // this.init();

      // mark data status does not be initialized
      this._dataStatus = this.dataStatusFlag.notInitial;

      this.__filterCond = null;
      // {QueryCondition}
      // A passed in Query Condition for filtering our DataCollection.
      // This value is ANDed with our normal filter conditions.
   }

   /**
    * contextKey()
    *
    * return a unique key that represents data from/for this type of object.
    *
    * used when creating Network jobs and needing to be notified when a job
    * is complete.  We send a contextKey() to the Network job and then listen
    * for it to know when it is complete.
    * @return {string}
    */
   static contextKey() {
      return "datacollection";
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id;
      // {string} .id
      // the uuid of this ABDataCollection Definition.

      this.name = values.name || null;
      // {string} .name
      // the unchanging name of this ABDataCollection

      this.type = values.type || "datacollection";
      // {string} .type
      // the type of ABDefinition this is.

      values.settings = values.settings || {};
      this.settings = this.settings || {};
      // {obj} .settings
      // the specific operation values for this ABDataCollection

      this.settings.linkDatacollectionID =
         values.settings.linkDatacollectionID ||
         DefaultValues.settings.linkDatacollectionID;
      // {string} .settings.linkDaacollectionID
      // the uuid of another ABDataCollection that provides the link/trigger
      // for filtering the values of this ABDataCollection.

      this.settings.linkFieldID =
         values.settings.linkFieldID || DefaultValues.settings.linkFieldID;
      // {string} .settings.linkFieldID
      // the uuid of the ABDataField of the .linkDatacollection ABObject
      // whose value is the trigger value for this ABDataCollection

      this.settings.objectWorkspace = values.settings.objectWorkspace || {
         filterConditions:
            DefaultValues.settings.objectWorkspace.filterConditions,
         sortFields: DefaultValues.settings.objectWorkspace.sortFields,
      };
      // {obj} .settings.objectWorkspace
      // the default settings for what is shown in the AppBuilder's
      // DataCollection workspace

      this.settings.fixSelect = values.settings.fixSelect;

      // Convert to boolean
      this.settings.loadAll = JSON.parse(
         values.settings.loadAll || DefaultValues.settings.loadAll
      );
      // {bool} .settings.loadAll
      // do we load all the data at one time? false == load by pages.

      this.settings.isQuery = JSON.parse(
         values.settings.isQuery || DefaultValues.settings.isQuery
      );
      // {bool} .settings.isQuery
      // is the data source for this ABDataCollection based upon an
      // ABObjectQuery?

      this.settings.populate = (() => {
         // First check .populate
         if (values.settings.populate != undefined) {
            return values.settings.populate;
            // Then check legacy .preventPopulate
         } else if (
            values.settings.preventPopulate == true ||
            values.settings.preventPopulate == "1"
         ) {
            return false;
         } else return DefaultValues.settings.populate;
      })();
      // {bool | array} populate
      // Control whcih related connections to populate. Default, true, populates
      // all connections. False loads no connnections. Also accepts an array of
      // column names to load specefic connections.

      // Convert to number
      this.settings.syncType = parseInt(
         values.settings.syncType || DefaultValues.settings.syncType
      );
      // {int} .settings.syncType
      // how is the data between this ABDataCollection and it's
      // .datasource synced?

      this.__datasource = null;
      // {obj} .__datasource
      // the reference to the ABObject/ABObjectQuery that this ABDataCollection
      // is based off of.

      this.settings.datasourceID =
         values.settings.datasourceID || DefaultValues.settings.datasourceID;
      // {string} .settings.datasourceID
      // the uuid of the .__datasource object to use

      // now lookup and reference the proper datasource
      if (this.settings.datasourceID) {
         // check for an ABObject
         var obj = this.AB.objectByID(this.settings.datasourceID);
         if (!obj) {
            // this must be an ABObjectQuery then ...
            obj = this.AB.queryByID(this.settings.datasourceID);
         }

         if (obj) {
            this.__datasource = obj;
            this.settings.isQuery = obj.type === "query";
            if (this.settings.isQuery) {
               if (this.__datasource.isGroup) {
                  if (!this.__treeCollection)
                     this.__treeCollection = this._treeCollectionNew();
                  // {TreeCollection}
                  // This is a webix TreeCollection (or similar)
                  // keep it's implementation as part of the platform

                  this.__isGroup = true;
               }
            }
         } else {
            console.error(
               `ABDataCollection[${this.name}][${this.id}] unable to find datasource [${this.settings.datasourceID}]`
            );
         }
      }

      // // Populate data source: ABObject or ABObjectQuery
      // if (values.query && values.query[0]) {
      //    this.__datasource = new ABObjectQuery(
      //       values.query[0],
      //       this.application
      //    );
      //    this.settings.isQuery = true;

      //    if (this.__datasource.isGroup) {
      //       if (!this.__treeCollection)
      //          this.__treeCollection = this._treeCollectionNew();

      //       this.__isGroup = true;
      //    }
      // } else if (values.object && values.object[0]) {
      //    this.__datasource = new ABObject(values.object[0], this.application);
      //    this.settings.isQuery = false;
      // }

      // let the MLClass now process the translations:
      super.fromValues(values);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj(); // untranslate the object

      return {
         id: this.id,
         name: this.name || this.label,
         type: this.type || "datacollection",
         settings: this.AB.cloneDeep(this.settings || {}),
         translations: obj.translations,
      };
   }

   /**
    * @method save()
    *
    * persist this instance of ABDatacollection with it's parent
    *
    *
    * @return {Promise}
    *      .resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      return this;
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABDatacollection
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      var removeFromApplications = () => {
         return new Promise((next, err) => {
            this.AB.applications().then((apps) => {
               // NOTE: apps is a webix datacollection

               var allRemoves = [];

               var appsWithObject = apps.filter((a) => {
                  return a.datacollectionsIncluded((o) => o.id == this.id);
               });
               appsWithObject.forEach((app) => {
                  allRemoves.push(app.datacollectionRemove(this));
               });

               return Promise.all(allRemoves).then(next).catch(err);
            });
         });
      };

      return Promise.resolve()
         .then(() => {
            return removeFromApplications();
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @property $dc
    * return the underlying webix datacollection
    * @return {webix.datacollection}
    */
   get $dc() {
      return this.__dataCollection;
   }

   /**
    * @property datasource
    * return a object of this component.
    *
    * @return {ABObject|ABObjectQuery}
    */
   get datasource() {
      if (!this.__datasource) {
         if (this.id && this.name) {
            // occassionally we have blank DCs (without .id or .name)
            // and I don't want to see errors for those
            var err = new Error(
               `DataCollection[${this.name}][${this.id}] missing reference datasource`
            );
            this.AB.notify("builder", err, { datacollection: this.toObj() });
         }
         return null;
      }
      var obj = this.AB.objectByID(this.__datasource.id);
      if (!obj) {
         obj = this.AB.queryByID(this.__datasource.id);
      }
      return obj;
   }

   /**
    * @property datasource
    * set a object to data collection
    *
    * @param {ABObject|ABObjectQuery} object
    */
   set datasource(object) {
      this.__datasource = object;

      this.refreshFilterConditions();
   }

   /**
    * @property sourceType
    * return type of source.
    *
    * @return {string} - 'object' or 'query'
    */
   get sourceType() {
      return this.settings.isQuery ? "query" : "object";
   }

   /**
    * @method datacollectionLink
    * return a ABDatacollection that link of this.
    *
    * @return {ABDatacollection}
    */
   get datacollectionLink() {
      if (!this.AB) return null;

      return this.AB.datacollectionByID(this.settings.linkDatacollectionID);
   }

   /**
    * @property fieldLink
    * return a ABFieldConnect field that link of this.
    *
    * @return {ABFieldConnect}
    */
   get fieldLink() {
      let object = this.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.linkFieldID);
   }

   /**
    * @property model
    * return a source model
    *
    * @return ABModel
    */
   get model() {
      let object = this.datasource; // already notified

      return object ? object.model() : null;
   }

   get dataStatusFlag() {
      return {
         notInitial: 0,
         initializing: 1,
         initialized: 2,
      };
   }

   get dataStatus() {
      return this._dataStatus;
   }

   ///
   /// Cursor
   ///

   setCursor(itemId) {
      // If the static cursor is set, then this DC could not set cursor to other rows
      if (
         this.settings.fixSelect &&
         (this.settings.fixSelect != "_FirstRecordDefault" ||
            this.settings.fixSelect == itemId)
      )
         return;

      if (this.__treeCollection) {
         // set cursor of tree collection
         this.setCursorTree(itemId);

         // pull current row id
         let currTreeId = this.__treeCollection.getCursor();
         if (currTreeId) {
            let currTreeItem = this.__treeCollection.getItem(currTreeId);
            if (currTreeItem) itemId = currTreeItem._itemId;
         }
      }

      let dc = this.__dataCollection;
      if (dc) {
         // clear cursor
         if (itemId == null) {
            dc.setCursor(null);
         }
         // If set rowId equal current cursor, it will not trigger .onAfterCursorChange event
         else if (dc.getCursor() == itemId) {
            this.emit("changeCursor", this.getCursor());
         }
         // set new cursor
         else if (dc.exists(itemId)) {
            dc.setCursor(itemId);
         }
      }
   }

   /**
    *
    * @param {string|number} itemId - Id of item or Id of row data
    */
   setCursorTree(itemId) {
      let tc = this.__treeCollection;
      if (tc && tc.getCursor() != itemId) {
         // If it is id of tree collection, then find row id of data
         let treeCursor = tc.find({ id: itemId }, true);
         if (treeCursor) {
            tc.setCursor(itemId);
         }
         // If it is not id of tree collection, then find/set root of data
         else {
            let treeItem = tc.find({ _itemId: itemId, $parent: 0 }, true);
            if (treeItem) tc.setCursor(treeItem.id);
            else tc.setCursor(null);
         }
      }
   }

   getCursor(treeCursor = false) {
      // Cursor of tree collection
      if (treeCursor && this.__treeCollection) {
         let currId = this.__treeCollection.getCursor();
         if (currId) {
            let currItem = this.__treeCollection.getItem(currId);

            // filter current id for serialize
            this.__treeCollection.filter(
               (item) => item._itemId == currItem._itemId
            );

            // pull item with child items
            let currItemAndChilds =
               this.__treeCollection.serialize()[0] || null;

            // refresh filter
            this.refreshLinkCursor();

            return currItemAndChilds;
         }
      }

      let dc = this.__dataCollection;
      if (dc == null) return null;

      let currId = dc.getCursor();
      let currItem = dc.getItem(currId);

      return currItem;
   }

   getFirstRecord() {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getFirstId();
      var currItem = dc.getItem(currId);

      return currItem;
   }

   getNextRecord(record) {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getNextId(record.id);
      var currItem = dc.getItem(currId);

      return currItem;
   }

   /**
    * @method refreshLinkCursor
    *    If the data collection is bound to another and it is the child connection
    *    it finds it's parents current set cursor and then filters its data
    *    based off of the cursor.
    */
   refreshLinkCursor() {
      // do not set the filter unless this dc is initialized "dataStatusFlag==2"
      // if (this.dataStatus != this.dataStatusFlag.initialized) return;

      // filter the data in the data collection
      // using its parents current cursor because all the data in this child
      // data collection has been loaded and the frontend can decide what is
      // seen or not seen
      let linkCursor;
      let dvLink = this.datacollectionLink;
      if (dvLink) {
         linkCursor = dvLink.getCursor();
      }

      let filterData = (rowData) => {
         // if link dc cursor is null, then show all data
         if (linkCursor == null) return true;
         else return this.isParentFilterValid(rowData);
      };

      if (this.__dataCollection) this.__dataCollection.filter(filterData);
      if (this.__treeCollection) this.__treeCollection.filter(filterData);
   }

   setStaticCursor() {
      if (this.settings.fixSelect) {
         // set cursor to the current user
         if (this.settings.fixSelect == "_CurrentUser") {
            var username = this.currentUserUsername();
            var userFields = this.datasource.fields((f) => f.key == "user");

            // find a row that contains the current user
            var row = this.__dataCollection.find((r) => {
               var found = false;

               userFields.forEach((f) => {
                  if (found || r[f.columnName] == null) return;

                  if (r[f.columnName].filter) {
                     // Array - isMultiple
                     found =
                        r[f.columnName].filter((data) => data.id == username)
                           .length > 0;
                  } else if (r[f.columnName] == username) {
                     found = true;
                  }
               });

               return found;
            }, true);

            // set a first row of current user to cursor
            if (row) {
               this.__dataCollection.setCursor(row.id);

               this.setCursorTree(row.id);
            }
         } else if (
            this.settings.fixSelect == "_FirstRecord" ||
            this.settings.fixSelect == "_FirstRecordDefault"
         ) {
            // // find a row that contains the current user
            // var row = this.__dataCollection.find((r) => {

            //  var found = false;
            //  if (!found) {
            //    found = true;
            //    return true; // just give us the first record
            //  }

            // }, true);

            // // set a first row of current user to cursor
            // if (row)
            //  this.__dataCollection.setCursor(row.id);

            let currRowId = this.__dataCollection.getCursor();
            if (
               !currRowId ||
               (currRowId && !this.__dataCollection.exists(currRowId))
            ) {
               // If current cursor is filtered by parent DC, then select new cursor

               // set a first row to cursor
               let rowId = this.__dataCollection.getFirstId();
               // if (rowId) {
               this.__dataCollection.setCursor(rowId || null);

               this.setCursorTree(rowId);
               // }
            }
         } else {
            this.__dataCollection.setCursor(this.settings.fixSelect);

            this.setCursorTree(this.settings.fixSelect);
         }
      }
   }

   ///
   /// Data
   ///

   /**
    * @method filterCondition()
    * Provide a temporary filter condition to modify the data we are returning.
    * Used by User search criterias.
    * @param {json} cond
    *        A valid QueryCondition to filter the response.
    */
   filterCondition(cond = null) {
      this.__filterCond = cond;
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      this.initialized = true;

      if (!this.__dataCollection.___AD.onAfterCursorChange) {
         this.__dataCollection.___AD.onAfterCursorChange =
            this.__dataCollection.attachEvent("onAfterCursorChange", () => {
               // debugger;
               var currData = this.getCursor();

               this.emit("changeCursor", currData);
            });
      }

      // relate data functions
      let isRelated = (relateData, rowId, PK = "id") => {
         if (Array.isArray(relateData)) {
            return relateData.filter((v) => (v[PK] || v) == rowId).length > 0;
         } else {
            return relateData && (relateData[PK] || relateData) == rowId;
         }
      };

      // events
      this.on("ab.datacollection.create", (data) => {
         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         if (!data || !data.data) return;

         let needAdd = false;
         let updatedVals = [];

         Promise.resolve()
            .then(() => {
               return new Promise((next, bad) => {
                  // Query
                  if (obj instanceof this.AB.Class.ABObjectQuery) {
                     let objList =
                        obj.objects((o) => o.id == data.objectId) || [];

                     needAdd = objList.length > 0;

                     if (!needAdd) return next();

                     let where = {
                        glue: "or",
                        rules: [],
                     };

                     objList.forEach((o) => {
                        let newDataId = data.data[`${o.PK()}`];
                        if (!newDataId) return;

                        where.rules.push({
                           key: `${o.alias || obj.objectAlias(o.id)}.${o.PK()}`,
                           rule: "equals",
                           value: newDataId,
                        });
                     });

                     obj.model()
                        .findAll({
                           where: where,
                        })
                        .then((newQueryData) => {
                           updatedVals = newQueryData.data || [];
                           updatedVals.forEach((v) => {
                              delete v.id;
                           });

                           next();
                        })
                        .catch(bad);
                  }
                  // Object
                  else {
                     needAdd = obj.id == data.objectId;
                     updatedVals = [data.data];
                     next();
                  }
               });
            })
            .then(() => {
               if (needAdd) {
                  // normalize data before add to data collection
                  var model = obj.model();
                  model.normalizeData(updatedVals);

                  (updatedVals || []).forEach((updatedV) => {
                     // filter condition before add
                     if (!this.isValidData(updatedV)) return;

                     // check to see if item already exisits in data collection
                     // and check to see that we are not loading the data serverside from cursor
                     if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        !this.__reloadWheres
                     ) {
                        this.__dataCollection.add(updatedV, 0);
                        this.emit("create", updatedV);
                        // this.__dataCollection.setCursor(rowData.id);
                     } else if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        this.__reloadWheres
                     ) {
                        // debugger;
                        if (this.isParentFilterValid(updatedV)) {
                           // we track bound components and flexlayout components
                           var attachedComponents =
                              this.__bindComponentIds.concat(
                                 this.__flexComponentIds
                              );
                           attachedComponents.forEach((bcids) => {
                              // if the reload button already exisits move on
                              if ($$(bcids + "_reloadView")) {
                                 return false;
                              }

                              // find the position of the data view
                              var pos = 0;
                              var parent = $$(bcids).getParentView();
                              if ($$(bcids).getParentView().index) {
                                 pos = $$(bcids)
                                    .getParentView()
                                    .index($$(bcids));
                              } else if (
                                 $$(bcids).getParentView().getParentView().index
                              ) {
                                 // this is a data view and it is inside a
                                 // scroll view that is inside an accodion
                                 // so we need to go deeper to add the button
                                 parent = $$(bcids)
                                    .getParentView()
                                    .getParentView();
                                 pos = $$(bcids)
                                    .getParentView()
                                    .getParentView()
                                    .index($$(bcids).getParentView());
                              }

                              // store the datacollection so we can pass it to the button later
                              var DC = this;
                              // add a button that reloads the view when clicked
                              if (parent.addView) {
                                 var L = this.AB.Label();
                                 parent.addView(
                                    {
                                       id: bcids + "_reloadView",
                                       view: "button",
                                       value: L(
                                          "New data available. Click to reload."
                                       ),
                                       css: "webix_primary webix_warn",
                                       click: function (id, event) {
                                          DC.reloadData();
                                          $$(id).getParentView().removeView(id);
                                       },
                                    },
                                    pos
                                 );
                              }
                           });
                           // this.emit("create", updatedV);
                        }
                     }
                  });

                  if (
                     this.__treeCollection // && this.__treeCollection.exists(updatedVals.id)
                  ) {
                     this.parseTreeCollection({
                        data: updatedVals,
                     });
                  }
               }

               // ABObject only
               if (!(obj instanceof this.AB.Class.ABObjectQuery)) {
                  // if it is a linked object
                  let connectedFields = this.datasource.connectFields(
                     (f) =>
                        f.datasourceLink && f.datasourceLink.id == data.objectId
                  );

                  // It should always be only one item for ABObject
                  updatedVals = updatedVals[0];

                  // update relation data
                  if (
                     updatedVals &&
                     connectedFields &&
                     connectedFields.length > 0
                  ) {
                     // various PK name
                     let PK = connectedFields[0].object.PK();
                     if (!updatedVals.id && PK != "id")
                        updatedVals.id = updatedVals[PK];

                     this.__dataCollection.find({}).forEach((d) => {
                        let updateItemData = {};

                        connectedFields.forEach((f) => {
                           var updateRelateVal = {};
                           if (f && f.fieldLink) {
                              updateRelateVal =
                                 updatedVals[f.fieldLink.relationName()] || {};
                           }

                           let rowRelateVal = d[f.relationName()] || {};

                           let valIsRelated = isRelated(
                              updateRelateVal,
                              d.id,
                              PK
                           );

                           // Relate data
                           if (
                              Array.isArray(rowRelateVal) &&
                              rowRelateVal.filter(
                                 (v) =>
                                    v == updatedVals.id ||
                                    v.id == updatedVals.id ||
                                    v[PK] == updatedVals.id
                              ).length < 1 &&
                              valIsRelated
                           ) {
                              rowRelateVal.push(updatedVals);

                              updateItemData[f.relationName()] = rowRelateVal;
                              updateItemData[f.columnName] = updateItemData[
                                 f.relationName()
                              ].map((v) => v.id || v[PK] || v);
                           } else if (
                              !Array.isArray(rowRelateVal) &&
                              (rowRelateVal != updatedVals.id ||
                                 rowRelateVal.id != updatedVals.id ||
                                 rowRelateVal[PK] != updatedVals.id) &&
                              valIsRelated
                           ) {
                              updateItemData[f.relationName()] = updatedVals;
                              updateItemData[f.columnName] =
                                 updatedVals.id || updatedVals;
                           }
                        });

                        // If this item needs to update
                        if (Object.keys(updateItemData).length > 0) {
                           // normalize data before add to data collection
                           var model = obj.model();
                           model.normalizeData(updateItemData);

                           this.__dataCollection.updateItem(
                              d.id,
                              updateItemData
                           );

                           if (this.__treeCollection)
                              this.__treeCollection.updateItem(
                                 d.id,
                                 updateItemData
                              );

                           this.emit(
                              "update",
                              this.__dataCollection.getItem(d.id)
                           );
                        }
                     });
                  }
               }

               // filter link data collection's cursor
               this.refreshLinkCursor();
               this.setStaticCursor();
            });
      });

      this.on("ab.datacollection.update", (data) => {
         // {json} data
         // incoming socket payload:
         // data.objectId {string} uuid of the ABObject's row that was updated
         // data.data {json} the new updated value of that row entry.

         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         // updated values
         let values = data.data;
         if (!values) return;

         let needUpdate = false;
         let isExists = false;
         let updatedIds = [];
         // {array}
         // an array of the row indexs in our DataCollection that have values
         // that need to be updated.

         let updatedTreeIds = [];
         let updatedVals = {};

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needUpdate = objList.length > 0;
            if (needUpdate) {
               (objList || []).forEach((o) => {
                  updatedIds = updatedIds.concat(
                     this.__dataCollection
                        .find((item) => {
                           return (
                              item[
                                 `${this.datasource.objectAlias(
                                    o.id
                                 )}.${o.PK()}`
                              ] == (values[o.PK()] || values.id)
                           );
                        })
                        .map((o) => o.id) || []
                  );

                  // grouped queries
                  if (this.__treeCollection) {
                     updatedTreeIds = updatedTreeIds.concat(
                        this.__treeCollection
                           .find((item) => {
                              return (
                                 item[
                                    `${this.datasource.objectAlias(
                                       o.id
                                    )}.${o.PK()}`
                                 ] == (values[o.PK()] || values.id)
                              );
                           })
                           .map((o) => o.id) || []
                     );
                  }
               });

               isExists = updatedIds.length > 0;

               updatedVals = this._queryUpdateData(objList, values);
            }
         }
         // Object
         else {
            needUpdate = obj.id == data.objectId;
            if (needUpdate) {
               // various PK name
               if (!values.id && obj.PK() != "id") values.id = values[obj.PK()];

               updatedIds.push(values.id);

               isExists = this.__dataCollection.exists(values.id);
               updatedVals = values;
            }
         }

         // if it is the source object
         if (needUpdate) {
            if (isExists) {
               if (this.isValidData(updatedVals)) {
                  // NOTE: this is now done in NetworkRestSocket before
                  // we start the update events.
                  // normalize data before update data collection
                  // var model = obj.model();
                  // model.normalizeData(updatedVals);

                  if (this.__dataCollection) {
                     updatedIds = this.AB.uniq(updatedIds);
                     updatedIds.forEach((itemId) => {
                        this.__dataCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  if (this.__treeCollection) {
                     // update data in tree
                     updatedTreeIds = this.AB.uniq(updatedTreeIds);
                     updatedTreeIds.forEach((itemId) => {
                        this.__treeCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  this.emit("update", updatedVals);

                  // If the update item is current cursor, then should tell components to update.
                  let currData = this.getCursor();
                  if (currData && currData.id == updatedVals.id) {
                     this.emit("changeCursor", currData);
                  }
               } else {
                  // Johnny: Here we are simply removing the DataCollection Entries that are
                  // no longer valid.
                  // Just cycle through the collected updatedIds and remove them.
                  updatedIds.forEach((id) => {
                     // If the item is current cursor, then the current cursor should be cleared.
                     let currData = this.getCursor();
                     if (currData && currData.id == id)
                        this.emit("changeCursor", null);

                     this.__dataCollection.remove(id);

                     // TODO: update tree list
                     // if (this.__treeCollection) {
                     //  this.__treeCollection.remove(id);
                     // }

                     this.emit("delete", id);
                  });
               }
            }
            // filter before add new record
            else if (this.isValidData(updatedVals)) {
               // this means the updated record was not loaded yet so we are adding it to the top of the grid
               // the placement will probably change on the next load of the data
               this.__dataCollection.add(updatedVals, 0);

               if (this.__treeCollection)
                  this.parseTreeCollection({
                     data: [updatedVals],
                  });

               this.emit("create", updatedVals);
            }
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();
            if (!values.id && PK != "id") values.id = values[PK];

            if (this.__dataCollection.count() > 0) {
               this.__dataCollection.find({}).forEach((d) => {
                  let updateItemData = {};

                  connectedFields.forEach((f) => {
                     if (!f) return;

                     let updateRelateVal = {};
                     let rowRelateVal = d[f.relationName()] || {};

                     if (f.fieldLink)
                        updateRelateVal =
                           values[f.fieldLink.relationName()] || {};

                     let valIsRelated = isRelated(updateRelateVal, d.id, PK);

                     // Unrelate data
                     if (
                        Array.isArray(rowRelateVal) &&
                        rowRelateVal.filter(
                           (v) =>
                              v == values.id ||
                              v.id == values.id ||
                              v[PK] == values.id
                        ).length > 0 &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = rowRelateVal.filter(
                           (v) => (v.id || v[PK] || v) != values.id
                        );
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal == values.id ||
                           rowRelateVal.id == values.id ||
                           rowRelateVal[PK] == values.id) &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = null;
                        updateItemData[f.columnName] = null;
                     }

                     // Relate data or Update
                     if (Array.isArray(rowRelateVal) && valIsRelated) {
                        // update relate data
                        if (
                           rowRelateVal.filter(
                              (v) =>
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                           ).length > 0
                        ) {
                           rowRelateVal.forEach((v, index) => {
                              if (
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                              )
                                 rowRelateVal[index] = values;
                           });
                        }
                        // add new relate
                        else {
                           rowRelateVal.push(values);
                        }

                        updateItemData[f.relationName()] = rowRelateVal;
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal != values.id ||
                           rowRelateVal.id != values.id ||
                           rowRelateVal[PK] != values.id) &&
                        valIsRelated
                     ) {
                        updateItemData[f.relationName()] = values;
                        updateItemData[f.columnName] = values.id || values;
                     }
                  });

                  // If this item needs to update
                  if (Object.keys(updateItemData).length > 0) {
                     // normalize data before add to data collection
                     var model = obj.model();
                     model.normalizeData(updateItemData);
                     if (
                        this.__treeCollection &&
                        this.__treeCollection.exists(d.id)
                     )
                        this.__treeCollection.updateItem(d.id, updateItemData);

                     if (
                        this.__dataCollection &&
                        this.__dataCollection.exists(d.id)
                     ) {
                        this.__dataCollection.updateItem(d.id, updateItemData);
                        this.emit(
                           "update",
                           this.__dataCollection.getItem(d.id)
                        );
                     }
                  }
               });
            }
         }

         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      // We are subscribing to notifications from the server that an item may be stale and needs updating
      // We will improve this later and verify that it needs updating before attempting the update on the client side
      this.on("ab.datacollection.stale", (data) => {
         // debugger;
         // if we don't have a datasource or model, there is nothing we can do here:
         // Verify the datasource has the object we are listening for if not just stop here
         if (
            !this.datasource ||
            !this.model ||
            this.datasource.id != data.objectId
         ) {
            return;
         }

         // updated values
         var values = data.data;

         if (!values) return;

         // use the Object's defined Primary Key:
         var PK = this.model.object.PK();
         if (!values[PK]) {
            PK = "id";
         }

         if (values) {
            if (this.__dataCollection.exists(values[PK])) {
               var cond = { where: {} };
               cond.where[PK] = values[PK];
               // this data collection has the record so we need to query the server to find out what it's latest data is so we can update all instances
               this.model.staleRefresh(cond).then((res) => {
                  // check to make sure there is data to work with
                  if (Array.isArray(res.data) && res.data.length) {
                     // debugger;
                     let obj = this.datasource;
                     if (!obj) return;
                     // normalize data before add to data collection
                     var model = obj.model();
                     model.normalizeData(res.data[0]);
                     // tell the webix data collection to update using their API with the row id (values.id) and content (res.data[0])
                     if (this.__dataCollection.exists(values[PK])) {
                        this.__dataCollection.updateItem(
                           values[PK],
                           res.data[0]
                        );
                     }

                     // If the update item is current cursor, then should tell components to update.
                     var currData = this.getCursor();
                     if (currData && currData[PK] == values[PK]) {
                        this.emit("changeCursor", currData);
                     }
                  } else {
                     // If there is no data in the object then it was deleted...lets clean things up
                     // If the deleted item is current cursor, then the current cursor should be cleared.
                     var currId = this.getCursor();
                     if (currId == values[PK]) this.emit("changeCursor", null);

                     this.__dataCollection.remove(values[PK]);
                     this.emit("delete", values[PK]);
                  }
               });
            }
         }

         // filter link data collection's cursor
         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      this.on("ab.datacollection.delete", (data) => {
         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         let deleteId = data.data;
         let needDelete = false;
         let deletedIds = [];
         let deletedTreeIds = [];

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needDelete = objList.length > 0;
            if (needDelete) {
               (objList || []).forEach((o) => {
                  deletedIds =
                     this.__dataCollection
                        .find((item) => {
                           return item[`${o.alias}.${o.PK()}`] == deleteId;
                        })
                        .map((o) => o.id) || [];

                  // grouped queries
                  if (this.__treeCollection) {
                     deletedTreeIds =
                        this.__treeCollection
                           .find((item) => {
                              return item[`${o.alias}.${o.PK()}`] == deleteId;
                           })
                           .map((o) => o.id) || [];
                  }
               });
            }
         }
         // Object
         else {
            needDelete = obj.id == data.objectId;
            if (needDelete) {
               deletedIds.push(deleteId);
            }
         }

         // if it is the source object
         if (needDelete) {
            // If the deleted item is current cursor, then the current cursor should be cleared.
            var currData = this.getCursor();

            deletedIds.forEach((delId) => {
               if (currData && currData[obj.PK()] == delId)
                  this.emit("changeCursor", null);

               if (this.__dataCollection.exists(delId))
                  this.__dataCollection.remove(delId);
            });

            if (this.__treeCollection) {
               deletedTreeIds.forEach((delId) => {
                  if (this.__treeCollection.exists(delId))
                     this.__treeCollection.remove(delId);
               });
            }

            if (deletedIds[0]) this.emit("delete", deletedIds[0]);
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();

            this.__dataCollection.find({}).forEach((d) => {
               let updateRelateVals = {};

               connectedFields.forEach((f) => {
                  let relateVal = d[f.relationName()];
                  if (relateVal == null) return;

                  if (
                     Array.isArray(relateVal) &&
                     relateVal.filter(
                        (v) =>
                           v == deleteId ||
                           v.id == deleteId ||
                           v[PK] == deleteId
                     ).length > 0
                  ) {
                     updateRelateVals[f.relationName()] = relateVal.filter(
                        (v) => (v.id || v[PK] || v) != deleteId
                     );
                     updateRelateVals[f.columnName] = updateRelateVals[
                        f.relationName()
                     ].map((v) => v.id || v[PK] || v);
                  } else if (
                     relateVal == deleteId ||
                     relateVal.id == deleteId ||
                     relateVal[PK] == deleteId
                  ) {
                     updateRelateVals[f.relationName()] = null;
                     updateRelateVals[f.columnName] = null;
                  }
               });

               // If this item needs to update
               if (Object.keys(updateRelateVals).length > 0) {
                  // normalize data before add to data collection
                  var model = obj.model();
                  model.normalizeData(updateRelateVals);

                  this.__dataCollection.updateItem(d.id, updateRelateVals);

                  if (this.__treeCollection)
                     this.__treeCollection.updateItem(d.id, updateRelateVals);

                  this.emit("update", this.__dataCollection.getItem(d.id));
               }
            });
         }
      });

      // add listeners when cursor of link data collection is changed
      let linkDv = this.datacollectionLink;
      if (linkDv && this.settings.loadAll) {
         this.eventAdd({
            emitter: linkDv,
            eventName: "changeCursor",
            listener: () => {
               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });
      }
   }

   /*
    * waitForDataCollectionToInitialize()
    * there are certain situations where this datacollection shouldn't
    * load until another one has loaded.  In those cases, the fn()
    * will wait for the required datacollection to emit "initializedData"
    * before continuing on.
    * @param {ABViewDataCollection} DC
    *      the DC this datacollection depends on.
    * @returns {Promise}
    */
   waitForDataCollectionToInitialize(DC, msg) {
      return new Promise((resolve, reject) => {
         switch (DC.dataStatus) {
            // if that DC hasn't started initializing yet, start it!
            case DC.dataStatusFlag.notInitial:
               DC.loadData().catch(reject);
            // no break;

            // once in the process of initializing
            /* eslint-disable no-fallthrough*/
            case DC.dataStatusFlag.initializing:
               /* eslint-enable no-fallthrough*/
               // listen for "initializedData" event from the DC
               // then we can continue.
               this.eventAdd({
                  emitter: DC,
                  eventName: "initializedData",
                  listener: () => {
                     // go next
                     resolve();
                  },
               });
               break;

            // if it is already initialized, we can continue:
            case DC.dataStatusFlag.initialized:
               resolve();
               break;

            // just in case, if the status is not known, just continue
            default:
               resolve();
               break;
         }
      });
   }

   loadData(start, limit) {
      // mark data status is initializing
      if (this._dataStatus == this.dataStatusFlag.notInitial) {
         this._dataStatus = this.dataStatusFlag.initializing;
         this.emit("initializingData", {});
      }

      var obj = this.datasource;
      if (obj == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      var model = obj.model();
      if (model == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      // pull the defined sort values
      var sorts = this.settings.objectWorkspace.sortFields || [];

      // pull filter conditions
      var wheres = this.settings.objectWorkspace.filterConditions || null;
      // if we pass new wheres with a reload use them instead
      if (this.__reloadWheres) {
         wheres = this.__reloadWheres;
      }

      if (this.__filterCond) {
         if (wheres.rules.length) {
            // combine them together:
            wheres = {
               glue: "and",
               rules: [wheres, this.__filterCond],
            };
         } else {
            // simplify to just use filterCond
            wheres = this.__filterCond;
         }
      }

      // set query condition
      var cond = {
         where: wheres || {},
         // limit: limit || 20,
         skip: start || 0,
         sort: sorts,
         populate:
            this.settings.populate ??
            (this.settings.preventPopulate ? false : true),
      };

      //// NOTE: we no longer set a default limit on loadData() but
      //// require the platform.loadData() to pass in a default limit.
      if (limit) {
         cond.limit = limit;
      }

      // if settings specify loadAll, then remove the limit
      if (this.settings.loadAll) {
         delete cond.limit;
      }

      return (
         Promise.resolve()
            //
            // Step 1: make sure any DataCollections we are linked to are
            // initialized first.  Then proceed with our initialization.
            //
            .then(() => {
               // If we are linked to another datacollection then wait for it
               let linkDc = this.datacollectionLink;
               if (!linkDc) return Promise.resolve(); // TODO: refactor in v2

               return this.waitForDataCollectionToInitialize(linkDc);
            })
            //
            // Step 2: if we have any filter rules that depend on other DataCollections,
            // then wait for them to be initialized first.
            // eg: "(not_)in_data_collection" rule filters
            .then(() => {
               return new Promise((resolve, reject) => {
                  if (
                     wheres == null ||
                     wheres.rules == null ||
                     !wheres.rules.length
                  )
                     return resolve();

                  var dcFilters = [];

                  wheres.rules.forEach((rule) => {
                     // if this collection is filtered by data collections we need to load them in case we need to validate from them later
                     if (
                        rule.rule == "in_data_collection" ||
                        rule.rule == "not_in_data_collection"
                     ) {
                        var dv = this.AB.datacollectionByID(rule.value);
                        if (dv) {
                           dcFilters.push(
                              this.waitForDataCollectionToInitialize(dv)
                           );
                        }
                     }
                  });

                  Promise.all(dcFilters)
                     .then(() => {
                        resolve();
                     })
                     .catch(reject);
               });
            })

            // pull data to data collection
            .then(() => {
               return new Promise((resolve, reject) => {
                  // we will keep track of the resolve, reject for this
                  // operation.
                  // the actual resolve() should happen in the
                  // .processIncomingData() after the  data is processed.
                  this._pendingLoadDataResolve = {
                     resolve: resolve,
                     reject: reject,
                  };

                  this.platformFind(model, cond).catch((err) => {
                     reject(err);
                  });
               });
            })
      );
   }

   platformFind(model, cond) {
      //// Core Migration Note:
      //// the ABViewDataCollectionCore now manages data in a different way:
      //// local data  vs  Remote Data
      //// this will need to be updated to reflect that management:
      //// (and also explains why we refactored things into .processIncomingData())
      return model.findAll(cond).then((data) => {
         return this.processIncomingData(data);
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      return Promise.resolve().then(() => {
         // store total count
         this.__totalCount = data.total_count;
         // In order to get the total_count updated I had to use .load()
         queueOperation(() => {
            this.__dataCollection.load(() => {
               // If this dc loads all, then it has to filter data by the parent dc
               if (this.settings.loadAll) {
                  setTimeout(() => {
                     this.refreshLinkCursor();
                  }, 250);
               }

               return data;
            });
         }, 5);

         // In order to keep detail and graphs loading properly I had to keep .parse()
         queueOperation(() => {
            this.__dataCollection.parse(data);
         }, 50);

         // this does nothing???
         this.parseTreeCollection(data);

         queueOperation(() => {
            // if we are linked, then refresh our cursor
            var linkDv = this.datacollectionLink;
            if (linkDv) {
               // filter data by match link data collection
               this.refreshLinkCursor();
               this.setStaticCursor();
            } else {
               // set static cursor
               this.setStaticCursor();
            }
         }, 5);
         queueOperation(() => {
            // mark initialized data
            if (this._dataStatus != this.dataStatusFlag.initialized) {
               this._dataStatus = this.dataStatusFlag.initialized;
               this.emit("initializedData", {});
            }
         }, 20);
         queueOperation(() => {
            // If dc set load all, then it will not trigger .loadData in dc at
            // .onAfterLoad event
            if (this.settings.loadAll) {
               this.emit("loadData", {});
            }
         }, 10);
         queueOperation(() => {
            // now we close out our .loadData() promise.resolve() :
            if (this._pendingLoadDataResolve) {
               this._pendingLoadDataResolve.resolve();

               // after we call .resolve() stop tracking this:
               this._pendingLoadDataResolve = null;
            }
         }, 5);
      });
   }

   /**
    * @method reloadData()
    * Trigger the DataCollection to reload its data from the server.
    * @param {int} start
    *        Start position of where we want the data to load.
    * @param {int} limit
    *        How many entries to load at a time.
    * @return {Promise}
    */
   reloadData(start, limit) {
      // var waitForDataCollectionToInitialize = (DC) => {
      //    return new Promise((resolve, reject) => {
      //       switch (DC.dataStatus) {
      //          // if that DC hasn't started initializing yet, start it!
      //          case DC.dataStatusFlag.notInitial:
      //             DC.loadData().catch(reject);
      //          // no break;

      //          // once in the process of initializing
      //          /* eslint-disable no-fallthrough*/
      //          case DC.dataStatusFlag.initializing:
      //             /* eslint-enable no-fallthrough*/
      //             // listen for "initializedData" event from the DC
      //             // then we can continue.
      //             this.eventAdd({
      //                emitter: DC,
      //                eventName: "initializedData",
      //                listener: () => {
      //                   // go next
      //                   resolve();
      //                },
      //             });
      //             break;

      //          // if it is already initialized, we can continue:
      //          case DC.dataStatusFlag.initialized:
      //             resolve();
      //             break;

      //          // just in case, if the status is not known, just continue
      //          default:
      //             resolve();
      //             break;
      //       }
      //    });
      // };

      return Promise.resolve().then(() => {
         // check if we are currently waiting for more data requests on this datacollection before continuing
         if (this.reloadTimer) {
            // if we are already waiting delete the current timer
            clearTimeout(this.reloadTimer);
            delete this.reloadTimer;
         }

         // return a promise
         if (!this.reloadPromise) {
            this.reloadPromise = new Promise((resolve, reject) => {
               this.reloadPromise__resolve = resolve;
               this.reloadPromise__reject = reject;
            });
         }

         // then create a new timeout to delete current timeout, clear data
         // and load new
         this.reloadTimer = setTimeout(() => {
            // clear the data from the dataCollection,
            this.clearAll();
            // then loads new data from the server
            return this.loadData(start, limit)
               .then(() => {
                  if (this.reloadPromise) {
                     this.reloadPromise__resolve();
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }

                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               })
               .catch((err) => {
                  if (this.reloadPromise) {
                     this.reloadPromise__reject(err);
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }
                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               });
         }, 50);
         // setting to 50ms because right now we do not see many
         // concurrent calls,  we need to increase this if we begin to

         return this.reloadPromise;
      });
   }

   /**
    * reloadWheres()
    * stores the child data collections filters for subsequent loads.
    * It is called from bindParentDc() when child data collections that are not
    * marked to load all data are initializing. To do this we use webix
    * server side binding by setting the param of "dataFeed".
    * @param {obj} wheres  the new filters for the data collection
    *        This is a combination of any exisiting filters the data collection
    *        alreay had as well as the filter for the current cursor set by the
    *        master data collection. We store this in __reloadWheres for when
    *        the data needs to be updated.
    *        The format of the wheres is our Query Builder Format
    *        ex: {
    *              "glue": "and",
    *              "rules": [{
    *                "key": "33ba8957-6b9c-4ddb-9533-c46b13878ae1",
    *                "rule": "contains",
    *                "value": "1594176994894"
    *              }]
    *            }
    */
   reloadWheres(wheres) {
      this.__reloadWheres = wheres;
   }

   getData(filter) {
      var dc = this.__dataCollection;
      if (dc) {
         return dc.find((row) => {
            let isValid = true;

            // data collection filter
            // isValid = this.isValidData(row);

            // NOTE: data are filtered from the server side (webix.dataFeed)
            // parent dc filter
            let linkDv = this.datacollectionLink;
            if (linkDv && this.settings.loadAll && isValid) {
               isValid = this.isParentFilterValid(row);
            }

            // addition filter
            if (isValid && filter) {
               isValid = filter(row);
            }

            return isValid;
         });
      } else {
         return [];
      }
   }

   isParentFilterValid(rowData) {
      // data is empty
      if (rowData == null) return null;

      var linkDv = this.datacollectionLink;
      if (linkDv == null) return true;

      var fieldLink = this.fieldLink;
      if (fieldLink == null) return true;

      // if the parent's cursor is not set we have not filted this collection
      // yet so the data that comes back should be valid
      var linkCursor = linkDv.getCursor();
      if (linkCursor == null) {
         return true;
      }

      var linkVal = rowData[fieldLink.relationName()];
      if (linkVal == null) {
         // try to get relation value(id) again
         if (rowData[fieldLink.columnName]) {
            linkVal = rowData[fieldLink.columnName];
         } else {
            return false;
         }
      }

      let PK = fieldLink.object.PK();

      // array - 1:M , M:N
      if (linkVal.filter) {
         return (
            linkVal.filter((val) => (val.id || val[PK] || val) == linkCursor.id)
               .length > 0
         );
      } else {
         return (linkVal.id || linkVal[PK] || linkVal) == linkCursor.id;
      }
   }

   clearAll() {
      if (this.__dataCollection) this.__dataCollection.clearAll();

      if (this.__treeCollection) this.__treeCollection.clearAll();

      this._dataStatus = this.dataStatusFlag.notInitial;
   }

   get totalCount() {
      return this.__totalCount || 0;
   }

   ///
   /// Components
   ///

   /**
    * @method bind
    * @param {Object} component - a webix element instance
    */
   bind(/* component */) {
      console.error("Platform.ABDataCollection.bind() Not implemented");
   }

   unbind(/* component */) {
      console.error("Platform.ABDataCollection.unbind() Not implemented");
   }

   removeComponent(comId) {
      // get index
      let index = this.__bindComponentIds.indexOf(comId);

      // delete
      this.__bindComponentIds.splice(index, 1);
   }

   /**
    * @method refreshFilterConditions()
    * This is called in two primary cases:
    *    - on initialization of a DC to setup our filters.
    *    - in the operation of the ABDesigner when using a DC to display data
    *      in the Work_object_grid and the datacollection_work(?)
    * In the case of the ABDesigner, new temporary where conditions are provided
    * from the possible filters we can set, and those need to effect the data
    * we display.
    * @param {ABRowFilter.where} wheres
    *        The filter condition from the ABRowFilter values we are storing.
    */
   refreshFilterConditions(wheres = null) {
      // There are 3 Filters that help us know if our data is Valid:
      // 1) A filter for any ABObjectQuery we are managing.
      // 2) A filter for our own filter condition
      // 3) A filter that represents what our scopes allows

      // Set filter of ABObject
      if (this.__filterDatasource == null)
         this.__filterDatasource = this.AB.filterComplexNew(
            `${this.id}_filterDatasource`
         );

      if (this.datasource) {
         // this.__filterDatasource.applicationLoad(this.datasource.application);
         this.__filterDatasource.fieldsLoad(this.datasource.fields());

         let filterConditions;

         // Query
         if (this.datasource instanceof this.AB.Class.ABObjectQuery) {
            filterConditions = this.datasource.where;
         }
         // Apr 29, 2021 Removed this because we do not want Object filters to
         // effect validation of DataCollections
         // Object

         // else if (this.datasource instanceof ABObject) {
         //    let currentView = this.datasource.currentView();
         //    if (currentView && currentView.filterConditions)
         //       filterConditions = currentView.filterConditions;
         // }

         if (filterConditions)
            this.__filterDatasource.setValue(filterConditions);
         else this.__filterDatasource.setValue({});
      } else {
         this.__filterDatasource.fieldsLoad([]);
         this.__filterDatasource.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of data view
      // Apr 29, 2021 Added this code back to validate with DataCollection Filters
      if (this.__filterDatacollection == null)
         this.__filterDatacollection = this.AB.filterComplexNew(
            `${this.id}_filterDatacollection`
         );

      // this.__filterDatacollection.applicationLoad(
      //    this.datasource ? this.datasource.application : null
      // );
      this.__filterDatacollection.fieldsLoad(
         this.datasource ? this.datasource.fields() : []
      );

      if (wheres) this.settings.objectWorkspace.filterConditions = wheres;

      if (
         this.settings &&
         this.settings.objectWorkspace &&
         this.settings.objectWorkspace.filterConditions
      ) {
         this.__filterDatacollection.setValue(
            this.settings.objectWorkspace.filterConditions
         );
      } else {
         this.__filterDatacollection.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of user's scope
      if (this.__filterScope == null)
         this.__filterScope = this.AB.filterComplexNew(
            `${this.id}_filterScope`
         );

      if (this.datasource) {
         let scopeList = (this.userScopes || []).filter(
            (s) =>
               !s.allowAll &&
               (s.objectIds || []).indexOf(this.datasource.id) > -1
         );
         if (scopeList && scopeList.length > 0) {
            // this.__filterScope.applicationLoad(this.datasource.application);
            this.__filterScope.fieldsLoad(this.datasource.fields() || []);

            // concat all rules of scopes
            let scopeRules = [];
            scopeList
               .filter(
                  (s) => s.filter && s.filter.rules && s.filter.rules.length
               )
               .forEach((s) => {
                  let sRules = (s.filter.rules || []).filter(
                     (r) =>
                        this.datasource.fields((f) => f.id == r.key).length > 0
                  );

                  scopeRules = scopeRules.concat(sRules);
               });

            let scopeWhere = {
               glue: "or",
               rules: scopeRules,
            };
            this.__filterScope.setValue(scopeWhere);
         }
      }
   }

   get isGroup() {
      return this.__isGroup || false;
   }

   ///
   /// Sync type
   ///

   get syncTypeFlag() {
      return {
         server: 1,
         client: 2,
      };
   }

   get syncType() {
      return this.settings.syncType || DefaultValues.syncType;
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(/*data*/) {
      var error = new Error(
         "the platform.ABDataCollection._dataCollectionNew() is expected to return a proper DataCollection!"
      );
      console.error(error);
      return null;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      console.error(
         "the platform.ABDataCollection._treeCollectionNew() is expected to return a proper TreeCollection!"
      );
      return null;
   }

   parseTreeCollection(data = {}) {
      // TODO all this does is log "is missing?"
      if (data === {}) {
         console.log(
            "Platform.ABDataCollection.parseTreeCollection() missing!"
         );
      }
   }
   // parseTreeCollection(data = {}) {

   //  if (!(this.__datasource instanceof ABObjectQuery) ||
   //    !this.__datasource.isGroup ||
   //    !this.__treeCollection)
   //    return;

   //  let addRowToTree = (join = {}, parentAlias = null) => {

   //    let alias = join.alias;

   //    (data.data || []).forEach(row => {

   //      let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
   //      if (!dataId) return;

   //      // find parent nodes
   //      let parentItemIds = [];
   //      let parentId = row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
   //      if (parentId) {
   //        parentItemIds = this.__treeCollection
   //          .find(item => item._alias == parentAlias && item._dataId == parentId)
   //          .map(item => item.id);
   //      }

   //      // check exists
   //      let exists = this.__treeCollection.find(item => {
   //        return item._alias == alias &&
   //          item._dataId == dataId &&
   //          (parentItemIds.length == 0 || parentItemIds.indexOf(item.$parent) > -1);
   //      }, true);
   //      if (exists) return;

   //      let treeNode = {};
   //      treeNode._alias = alias;
   //      treeNode._dataId = dataId;
   //      treeNode._itemId = row.id; // Keep row id for set cursor to data collection

   //      Object.keys(row).forEach(propName => {

   //        // Pull value from alias
   //        if (propName.indexOf(`${alias}.`) == 0) {
   //          treeNode[propName] = row[propName];
   //        }

   //      });

   //      if (row.translations)
   //        treeNode.translations = row.translations;

   //      // child nodes
   //      if (parentItemIds.length > 0)
   //        parentItemIds.forEach(parentItemId => {
   //          this.__treeCollection.add(treeNode, null, parentItemId);
   //        });
   //      // root node
   //      else
   //        this.__treeCollection.add(treeNode, null);

   //    });

   //    // Sub-joins
   //    (join.links || []).forEach(link => {
   //      addRowToTree(link, alias);
   //    });

   //  };

   //  // Show loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.showProgress)
   //      boundComp.showProgress({ type: "icon" });

   //  });

   //  addRowToTree(this.__datasource.joins());

   //  // Hide loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.hideProgress)
   //      boundComp.hideProgress();

   //  })
   // }

   /**
    * @method _queryUpdateData
    *
    * @param {Array} objList - List of ABObject
    * @param {Object} values
    */
   _queryUpdateData(objList, values) {
      let updatedVals = {};

      // Add alias to properties of update data
      Object.keys(values).forEach((key) => {
         objList.forEach((oItem) => {
            let alias = this.datasource.objectAlias(oItem.id);

            updatedVals[`${alias}.${key}`] = values[key];

            // Add alias to properties of .translations
            if (
               key == "translations" &&
               values["translations"] &&
               values["translations"].length
            ) {
               updatedVals.translations = [];

               values["translations"].forEach((tran) => {
                  let updatedTran = {};

                  Object.keys(tran).forEach((tranKey) => {
                     if (tranKey == "language_code")
                        updatedTran["language_code"] = tran["language_code"];
                     else updatedTran[`${alias}.${tranKey}`] = tran[tranKey];
                  });

                  updatedVals.translations.push(updatedTran);
               });
            }
         });
      });

      return updatedVals;
   }

   isValidData(rowData) {
      let result = true;

      // NOTE: should we use filter of the current view of object to filter
      //        if yes, update .wheres condition in .loadData too
      if (this.__filterDatasource)
         result = result && this.__filterDatasource.isValid(rowData);

      if (this.__filterDatacollection)
         result = result && this.__filterDatacollection.isValid(rowData);

      if (result && this.__filterScope)
         result = result && this.__filterScope.isValid(rowData);

      return result;
   }

   // Clone

   clone(settings) {
      settings = settings || this.toObj();
      var clonedDatacollection = new this.constructor(settings, this.AB);
      clonedDatacollection.__datasource = this.__datasource;
      clonedDatacollection._dataStatus = this._dataStatus;

      // clonedDatacollection.__dataCollection = this.__dataCollection.copy();
      clonedDatacollection.__filterDatacollection.setValue(
         settings.settings.objectWorkspace.filterConditions
      );

      var parseMe = () => {
         if (clonedDatacollection.__dataCollection) {
            clonedDatacollection.__dataCollection.parse(
               this.__dataCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
         if (clonedDatacollection.__treeCollection) {
            clonedDatacollection.__treeCollection.parse(
               this.__treeCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
      };

      parseMe();

      // return new Promise((resolve, reject) => {
      //    // load the data
      //    clonedDatacollection
      //       .loadData()
      //       .then(() => {

      // set the cursor
      clonedDatacollection.setStaticCursor();

      var cursorID = this.getCursor();
      if (cursorID) {
         // NOTE: webix documentation issue: .getCursor() is supposed to return
         // the .id of the item.  However it seems to be returning the {obj}
         if (cursorID.id) cursorID = cursorID.id;

         clonedDatacollection.setCursor(cursorID);
      }

      return clonedDatacollection;

      // resolve(clonedDatacollection);
      //       })
      //       .catch(reject);
      // });
   }

   filteredClone(filters) {
      var obj = this.toObj();

      // check to see that filters are set (this is sometimes helpful to select the first record without doing so at the data collection level)
      if (filters?.rules?.length) {
         if (obj.settings.objectWorkspace.filterConditions?.rules?.length) {
            obj.settings.objectWorkspace.filterConditions.rules =
               obj.settings.objectWorkspace.filterConditions.rules.concat(
                  filters.rules
               );
         } else {
            obj.settings.objectWorkspace.filterConditions = filters;
         }
      }
      let clonedDC = this.clone(obj);
      return clonedDC; // new ABViewDataCollection(settings, this.application, this.parent);
   }

   //
   // Event handles
   //

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    *              emitter: object,
    *              eventName: string,
    *              listener: function
    *            }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      this.__events = this.__events || [];

      let exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    */
   eventClear() {
      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   get userScopes() {
      return [];
   }
};


/***/ }),

/***/ 40052:
/*!*********************************************!*\
  !*** ./AppBuilder/core/ABDefinitionCore.js ***!
  \*********************************************/
/***/ ((module) => {

// import ABApplication from "./ABApplication"

module.exports = class ABDefinitionCore {
   constructor(attributes, AB) {
      this.AB = AB;
      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			type: 'xxxxx',
			json: "{json}"
		}
		*/
      if (attributes.id) {
         this.id = attributes.id;
      }
      this.name =
         attributes?.name ||
         attributes?.json?.name ||
         attributes?.json?.label ||
         attributes?.json?.translations?.[0]?.label ||
         "";
      if (!this.name) {
         this.AB.notify.builder(
            new Error("Attributes for definition had no 'name'"),
            {
               context: "ABDefinitionCore.fromValues()",
               attributes,
            }
         );
      }
      this.type = attributes.type || attributes?.json?.type || "";
      this.json = attributes.json || null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      return {
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.json,
      };
   }

   /**
    * @method destroy()
    * destroy the current instance of ABDefinition
    * Also remove it from our parent application
    * @return {Promise}
    */
   destroy() {
      return this.AB.definitionDestroy(this.id);
   }

   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    *         .resolve( {this} )
    */
   async save() {
      if (this.id) {
         return this.AB.definitionUpdate(this.id, this.toObj());
      } else {
         return this.AB.definitionCreate(this.toObj());
      }
   }
};


/***/ }),

/***/ 35095:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABFactoryCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFactoryCore
 * an object that contains the definitions and references for a single tenant.
 * It is expected that an instance of this should be returned from an
 * ABBootstrap.init(req).then((AB)=>{}) call.
 */

// const _ = require("lodash");
// const uuidv4 = require("uuid");

const ABApplication = __webpack_require__(/*! ../platform/ABApplication */ 51827);
const ABDefinition = __webpack_require__(/*! ../platform/ABDefinition */ 65741);

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 8030);

const ABFieldManager = __webpack_require__(/*! ./ABFieldManager */ 69594);

const ABIndex = __webpack_require__(/*! ../platform/ABIndex */ 5437);
const ABObject = __webpack_require__(/*! ../platform/ABObject */ 67826);
const ABObjectExternal = __webpack_require__(/*! ../platform/ABObjectExternal */ 54509);
const ABObjectImport = __webpack_require__(/*! ../platform/ABObjectImport */ 41557);
const ABDataCollection = __webpack_require__(/*! ../platform/ABDataCollection */ 11579);
const ABObjectQuery = __webpack_require__(/*! ../platform/ABObjectQuery */ 88447);

const ABProcess = __webpack_require__(/*! ../platform/ABProcess */ 68836);

const ABProcessParticipant = __webpack_require__(/*! ../platform/process/ABProcessParticipant */ 67692);
const ABProcessLane = __webpack_require__(/*! ../platform/process/ABProcessLane */ 30144);
const ABProcessTaskManager = __webpack_require__(/*! ./process/ABProcessTaskManager */ 52719);

const ABViewFormComponent = __webpack_require__(/*! ../platform/views/ABViewFormComponent */ 93787);

// const ABObjectWorkspaceViewGrid = require("../platform/workspaceViews/ABObjectWorkspaceViewGrid");
// const ABObjectWorkspaceViewKanban = require("../platform/workspaceViews/ABObjectWorkspaceViewKanban");
// const ABObjectWorkspaceViewGantt = require("../platform/workspaceViews/ABObjectWorkspaceViewGantt");

const RowFilter = __webpack_require__(/*! ../platform/RowFilter */ 41688);
const FilterComplex = __webpack_require__(/*! ../platform/FilterComplex */ 21021);

const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);

const EventEmitter = __webpack_require__(/*! ../platform/ABEmitter */ 73686);

class ABFactory extends EventEmitter {
   constructor(definitions) {
      /**
       * @param {hash} definitions
       *        { ABDefinition.id : {ABDefinition} }
       *        of all the definitions defined for the current Tenant
       */

      super();
      this.setMaxListeners(0);

      this._definitions = definitions || {};
      // {hash}  { ABDefinition.id : {ABDefinition} }
      // ensure ._definitions is a HASH{ ID : {ABDefinition}}
      if (Array.isArray(definitions)) {
         var hash = {};
         definitions.forEach((d) => {
            hash[d.id] = d;
         });
         this._definitions = hash;
      }

      //
      //
      // Manage our working objects
      //

      this._allApplications = [];
      // {array} of all the ABApplication(s) in our site.

      this._allObjects = [];
      // {array} of all the ABObject(s) in our site.

      this._allProcesses = [];
      // {array} of all the ABProcess(s) in our site.

      this._allQueries = [];
      // {array} of all the ABObjectQuery(s) in our site.

      this._allDatacollections = [];
      // {array} of all the ABDataCollection(s) in our site.

      //
      // Class References
      //
      this.Class = {
         ABApplication,
         ABComponent,
         ABDefinition,
         ABFieldManager,
         ABIndex,
         ABMLClass,
         ABObject,
         ABObjectExternal,
         ABObjectImport,
         ABObjectQuery,
         ABProcessParticipant,
         // ABRole      // Do we need this anymore?

         // ABObjectWorkspaceViewGrid,
         // ABObjectWorkspaceViewKanban,
         // ABObjectWorkspaceViewGantt,

         ABProcessTaskManager,

         ABViewFormComponent,
      };

      //
      // Rules
      // These are a common set of "rules" for all platforms.
      //
      this.rules = {
         /**
          * @method AB.rules.isUUID
          * evaluate a given value to see if it matches the format of a uuid
          * @param {string} key
          * @return {boolean}
          */
         isUUID: function (key) {
            var checker = RegExp(
               "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
               "i"
            );
            return checker.test(key);
         },

         /**
          * @method AB.rules.nameFilter()
          * return a properly formatted name for an AppBuilder object.
          * @param {string} name
          *        The name of the object we are conditioning.
          * @return {string}
          */
         nameFilter: function (name) {
            return String(name).replace(/[^a-z0-9_.]/gi, "");
         },

         /**
          * @method AB.rules.toApplicationNameFormat()
          * return a properly formatted Application Name
          * @param {string} name
          *        The name of the Application we are conditioning.
          * @return {string}
          */
         toApplicationNameFormat: function (name) {
            return "AB_" + this.nameFilter(name);
         },

         /**
          * @method AB.rules.toFieldRelationFormat()
          * This function uses for define relation name of Knex Objection
          * return a relation name of column
          * @param {string} colName
          *        The name of the Column
          * @return {string}
          */
         toFieldRelationFormat: function (colName) {
            return this.nameFilter(colName) + "__relation";
         },

         /**
          * @method AB.rules.toJunctionTableFK()
          * return foriegnkey (FK) column name for a junction table name
          * @param {string} objectName
          *        The name of the Object with a connection
          * @param {string} columnName
          *        The name of the connection columnName.
          * @return {string}
          */
         toJunctionTableFK: function (objectName, columnName) {
            var fkName = objectName + "_" + columnName;

            if (fkName.length > 64) fkName = fkName.substring(0, 64);

            return fkName;
         },

         /**
          * @method AB.rules.toJunctionTableNameFormat()
          * return many-to-many junction table name
          * @param {string} appName
          *        The name of the Application for this object
          * @param {string} sourceTableName
          *        The name of the source object we are conditioning.
          * @param {string} targetTableName
          *        The name of the target object we are conditioning.
          * @param {string} colName
          * @return {string}
          */
         toJunctionTableNameFormat: function (
            appName,
            sourceTableName,
            targetTableName,
            colName
         ) {
            // The maximum length of a table name in MySql is 64 characters
            appName = this.toApplicationNameFormat(appName);
            if (appName.length > 17) appName = appName.substring(0, 17);

            if (sourceTableName.length > 15)
               sourceTableName = sourceTableName.substring(0, 15);

            if (targetTableName.length > 15)
               targetTableName = targetTableName.substring(0, 15);

            colName = this.nameFilter(colName);
            if (colName.length > 14) colName = colName.substring(0, 14);

            return "{appName}_{sourceName}_{targetName}_{colName}"
               .replace("{appName}", appName)
               .replace("{sourceName}", sourceTableName)
               .replace("{targetName}", targetTableName)
               .replace("{colName}", colName);
         },

         /**
          * @method AB.rules.toObjectNameFormat
          * return a properly formatted Object/Table Name
          * @param {string} objectName
          *        The {ABObject}.name of the Object we are conditioning.
          * @return {string}
          */
         toObjectNameFormat: function (objectName) {
            return `AB_${this.nameFilter(objectName)}`;
         },
      };

      // Notify Helpers
      this.notify.builder = (...params) => {
         this.notify("builder", ...params);
      };

      this.notify.developer = (...params) => {
         this.notify("developer", ...params);
      };
   }

   /**
    * @method definitionClean()
    * make sure the provided ABDefinition values are properly formatted
    * @param {ABDefinition} d
    *        The json settings of an ABDefinition object.
    */
   definitionClean(d) {
      if (typeof d.json == "string") {
         try {
            d.json = JSON.parse(d.json);
         } catch (e) {
            console.log(e);
            console.error(` Error on definition id[${d.id}]`);
         }
      }
   }

   init() {
      let allDefinitions = Object.keys(this._definitions).map(
         (k) => this._definitions[k]
      );
      // {array} all our definitions in an Array format.

      // make sure our definitions.json field is an {} and not string
      allDefinitions.forEach((d) => {
         this.definitionClean(d);
      });

      // perform these in order:
      ["object", "query", "datacollection", "process", "application"].forEach(
         (type) => {
            var objTypes = allDefinitions.filter((d) => d.type == type);
            objTypes.forEach((def) => {
               let { keyList, keyFn } = this.objectKeysByDef(def);
               if (keyList) {
                  this[keyList].push(this[keyFn](def.json));
               }
            });
         }
      );

      this.emit("init.objects_ready");
      return Promise.resolve();
   }

   /**
    * @method objectKeysByDef()
    * Analyze the provided ABDefinition json and return which set of list and
    * functions are used to create a new instance of this definition.
    * @param {json} def
    *        the ABDefinition json of the definition we are evaluating
    * @return { keyList, keyFn }
    *        keyList: {string}  which of our internal lists to store this new
    *                 object.
    *        keyFn: {string} which of our methods to call with the def.json
    *               as the param that will create the new object.
    *
    *        ex:  this[keyList].push( this[keyFn](def.json));
    *
    *        if this def is not one of the types we track,
    *        keyList = keyFn = null;
    */
   objectKeysByDef(def) {
      switch (def.type) {
         case "application":
            return { keyList: "_allApplications", keyFn: "applicationNew" };

         case "datacollection":
            return {
               keyList: "_allDatacollections",
               keyFn: "datacollectionNew",
            };

         case "object":
            return { keyList: "_allObjects", keyFn: "objectNew" };

         case "process":
            return { keyList: "_allProcesses", keyFn: "processNew" };

         case "query":
            return { keyList: "_allQueries", keyFn: "queryNew" };

         default:
            // we don't manage any other
            return { keyList: null, keyFn: null };
      }
   }

   //
   // Definitions
   //

   /**
    * definitionByID(id)
    * return an ABDefinition.json value ready for our objects to use.
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @param {bool} isRaw
    *        indicates if we want the full ABDefinition, or the .json param
    *        true : returns full ABDefinition value.
    *        false: returns the .json parameter used by most ABObjects.
    * @return {Promise}
    */
   definitionByID(id, isRaw = false) {
      if (this._definitions[id]) {
         if (isRaw) {
            return this._definitions[id];
         } else {
            return this._definitions[id].json;
         }
      }
      return null;
   }

   /**
    * definitionNew(values)
    * return an ABDefinition object tied to this Tenant.
    * @param {obj} values
    *        The value hash of the ABDefinition object to create.
    * @return {ABDefinition}
    */
   definitionNew(values) {
      return new ABDefinition(values, this);
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   definitionsParse(defs = []) {
      if (!Array.isArray(defs)) {
         defs = [defs];
      }

      // store/replace the incoming definitions
      // 1st: insert ALL our definitions internally
      defs.forEach((d) => {
         this.definitionClean(d);
         this._definitions[d.id] = d;
      });
      // 2nd: Now we can then go through and signal the "updates"
      // and the related objects can find their dependent definitions.
      defs.forEach((d) => {
         this.definitionSync("updated", d.id, d);
      });

      return Promise.resolve();
   }

   /**
    * definitionSync()
    * Synchronize an individual definition into our repository of definitions.
    * @param {string} op
    *        the type of synchronization this is
    *        [ "created", "updated", "destroyed"]
    * @param {uuid} id
    *        the definition.id of the definition we are synchronizing
    * @param {json} def
    *        the ABDefinition attributes we are storing.
    */
   definitionSync(op, id, def) {
      var { keyList, keyFn } = this.objectKeysByDef(def);
      if (keyList) {
         var curr;
         switch (op) {
            case "created":
               this[keyList].push(this[keyFn](def.json));
               this.emit("definition.created", def.json);
               break;

            case "updated":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);

               // remove from list
               this[keyList] = this[keyList].filter((d) => d.id != id);
               // add new one:
               this[keyList].push(this[keyFn](def.json));

               // signal this object needs to be updated:
               // NOTE: if this is one of the objects we are tracking,
               // we don't need to this.emit() the message.
               if (curr) {
                  curr.emit("definition.updated", def.json);
               } else {
                  this.emit("definition.updated", def.json);
               }
               break;

            case "destroyed":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);
               if (curr) {
                  // remove from list
                  this[keyList] = this[keyList].filter((d) => d.id != id);

                  // signal this object needs to be updated:
                  curr.emit("definition.deleted", def.json);

                  this.emit("definition.deleted", def.json);
               }
               break;
         }
      }
   }

   //
   // ABObjects
   //
   /**
    * @method applications()
    * return all the ABApplications that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABApplications.
    *        Must return true to include the entry.
    * @return {array}
    */
   applications(fn = () => true) {
      return (this._allApplications || []).filter(fn);
   }

   /**
    * @method applicationByID()
    * returns a single ABApplication that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABApplication we are searching
    *        for.
    * @return {ABApplication}
    *        the matching ABApplication object if found
    *        {null} if not found.
    */
   applicationByID(ID) {
      return this.applications((a) => a.id == ID)[0];
   }

   /**
    * @method applicationNew()
    * Return a new instance of an ABApplication object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplication object we are
    *        creating.
    * @return {ABApplication}
    */
   applicationNew(values) {
      return new ABApplication(values, this);
   }

   /**
    * @method datacollections()
    * return an array of all the ABDataCollection for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABDataCollection that
    *        this fn returns true for.
    * @return {array}
    *        array of ABDataCollection
    */
   datacollections(filter = () => true) {
      return (this._allDatacollections || []).filter(filter);
   }

   /**
    * @method datacollectionByID()
    * returns a single ABDatacollection that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABDatacollection we are searching
    *        for.
    * @return {ABDatacollection}
    *        the matching ABDatacollection object if found
    *        {null} if not found.
    */
   datacollectionByID(ID) {
      // an undefined or null ID should not match any DC.
      if (!ID) return null;

      return this.datacollections((dc) => {
         return dc.id == ID || dc.name == ID || dc.label == ID;
      })[0];
   }

   /**
    * @method datacollectionNew()
    * create a new instance of ABDataCollection
    * @param {obj} values
    *        the initial values for the DC
    * @return {ABDatacollection}
    */
   datacollectionNew(values) {
      var dc = new ABDataCollection(values, this);
      dc.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allDatacollections = this._allDatacollections.filter(
            (d) => d.id != dc.id
         );
      });
      return dc;
   }

   /**
    * @method fieldNew()
    * return an instance of a new (unsaved) ABField that is tied to a given
    * ABObject.
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    * @param {obj} values  the initial values for this field.
    *                - { key:'{string}'} is required
    * @param {ABObject} object  the parent object this field belongs to.
    * @return {ABField}
    */
   fieldNew(values, object) {
      // NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
      return ABFieldManager.newField(values, object);
   }

   /**
    * @method indexNew()
    * return an instance of a new (unsaved) ABIndex.
    * @return {ABIndex}
    */
   indexNew(values, object) {
      return new ABIndex(values, object);
   }

   /**
    * @method Label()
    * a simple label factory.
    * It is expected to be called like this:
    * @codestart
    *    var L = AB.Label();
    *    var outputText = L("Hello World");
    *    var o2 = L("I'm {0} years old", [5]);
    * @codeend
    * @return {fn}
    */
   Label() {
      return (key, altText, values = []) => {
         var label = key;
         if (altText) {
            if (Array.isArray(altText)) {
               values = altText;
            } else {
               label = altText;
            }
         }

         values.forEach((v, i) => {
            var sub = `{${i}}`;
            label = label.replaceAll(sub, v);
         });

         return label;
      };
   }

   /**
    * @method objects()
    * return an array of all the ABObjects for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABObjects that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObject
    */
   objects(filter = () => true) {
      return (this._allObjects || []).filter(filter);
   }

   /**
    * @method objectByID()
    * return the specific object requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   objectByID(ID) {
      return this.objects((o) => {
         return o.id == ID || o.name == ID || o.label == ID;
      })[0];
   }

   /**
    * @method objectNew()
    * return an instance of a new (unsaved) ABObject that is tied to this
    * ABApplication.
    * NOTE: this new object is not included in our this.objects until a .save()
    * is performed on the object.
    * @return {ABObject}
    */
   objectNew(values) {
      var newObj = null;

      if (values.isExternal == true)
         newObj = new ABObjectExternal(values, this);
      else if (values.isImported == true)
         newObj = new ABObjectImport(values, this);
      else newObj = new ABObject(values, this);

      /*
      // IS THIS CORRECT?
      newObj.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allObjects = this._allObjects.filter((o) => o.id != newObj.id);
      });
      */

      return newObj;
   }

   objectFile() {
      return this.objectByID("4a9d89c9-f4eb-41af-91e4-909eff389f3e");
   }

   objectLanguage() {
      return this.objectByID("d84cd351-d96c-490f-9afb-2a0b880ca0ec");
   }

   objectProcessForm() {
      return this.objectByID("d36ae4c8-edef-48d8-bd9c-79a0edcaa067");
   }

   objectProcessInstance() {
      return this.objectByID("2ba85be0-78db-4eda-ba43-c2c4e3831849");
   }

   objectRole() {
      return this.objectByID("c33692f3-26b7-4af3-a02e-139fb519296d");
   }

   objectScope() {
      return this.objectByID("af10e37c-9b3a-4dc6-a52a-85d52320b659");
   }

   objectToken() {
      return this.objectByID("08826ac7-4b33-4745-a3d7-f7831ca4ff59");
   }

   objectUser() {
      return this.objectByID("228e3d91-5e42-49ec-b37c-59323ae433a1");
   }

   //
   // Processes
   //
   /**
    * @method processes()
    * return all the ABProcess that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABProcess.
    *        Must return true to include the entry.
    * @return {array}
    */
   processes(filter = () => true) {
      return (this._allProcesses || []).filter(filter);
   }

   /**
    * @method processByID()
    * return the specific process requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   processByID(ID) {
      return this.processes((p) => {
         return p.id == ID || p.name == ID || p.label == ID;
      })[0];
   }

   /**
    * @method processNew()
    * Return a new instance of an ABProcess object.
    * @param {json} values
    *        the ABDefinition.json of the ABProcess object we are
    *        creating.
    * @return {ABProcess}
    */
   processNew(values) {
      return new ABProcess(values, this);
   }

   /**
    * @method processElementNew(id)
    * return an instance of a new ABProcessOBJ that is tied to a given
    * ABProcess.
    * @param {string} id
    *        the ABDefinition.id of the element we are creating
    * @param {ABProcess} process
    *        the process this task is a part of.
    * @return {ABProcessTask}
    */
   processElementNew(id, process) {
      var taskDef = this.definitionByID(id);
      if (taskDef) {
         switch (taskDef.type) {
            case ABProcessParticipant.defaults().type:
               return new ABProcessParticipant(taskDef, process, this);
            // break;

            case ABProcessLane.defaults().type:
               return new ABProcessLane(taskDef, process, this);
            // break;

            default:
               // default to a Task
               return ABProcessTaskManager.newTask(taskDef, process, this);
            // break;
         }
      }
      return null;
   }

   /**
    * @method processElementNewForModelDefinition(def)
    *
    * return an instance of a new ABProcess[OBJ] that is tied to the given
    * BPMI:Element definition.
    *
    * @param {BPMI:Element} element the element definition from our BPMI
    *              modler.
    * @return {ABProcess[OBJ]}
    */
   processElementNewForModelDefinition(element, process) {
      var newElement = null;

      switch (element.type) {
         case "bpmn:Participant":
            newElement = new ABProcessParticipant({}, process, this);
            break;

         case "bpmn:Lane":
            newElement = new ABProcessLane({}, process, this);
            break;

         default:
            var defaultDef = ABProcessTaskManager.definitionForElement(element);
            if (defaultDef) {
               newElement = ABProcessTaskManager.newTask(
                  defaultDef,
                  process,
                  this
               );
            }
            break;
      }

      // now make sure this new Obj pulls any relevant info from the
      // diagram element
      if (newElement) {
         newElement.fromElement(element);
      }
      return newElement;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery(s).
    * @param {fn} filter
    *        a filter fn to return a set of ABObjectQuery(s) that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObjectQuery
    */
   queries(filter = () => true) {
      return (this._allQueries || []).filter(filter);
   }
   // queriesAll() {
   //    console.error(
   //       "ABFactory.queriesAll() Depreciated! Use .queries() instead. "
   //    );
   //    return this.queries();
   // }

   /**
    * @method queryByID()
    * return the specific query requested by the provided id.
    * NOTE: this method has been extended to allow .name and .label
    * as possible lookup values.
    * @param {string} ID
    * @return {ABObjectQuery}
    */
   queryByID(ID) {
      return this.queries((q) => {
         return q.id == ID || q.name == ID || q.label == ID;
      })[0];
   }

   /**
    * @method queryNew()
    * return an instance of a new (unsaved) ABObjectQuery that is tied to this
    * ABFactory.
    * @return {ABObjectQuery}
    */
   queryNew(values) {
      return new ABObjectQuery(values, this);
   }

   /**
    * @method rowfilterNew()
    * return an instance of a new RowFilter that is tied to this
    * ABFactory.
    * @return {RowFilter}
    */
   rowfilterNew(App, idBase) {
      if (App) {
         console.error("!! Who is calling this with an App?");
      }
      return new RowFilter(App || this._App, idBase, this);
   }

   /**
    * @method filterComplexNew()
    * return an instance of a new FilterComplex that is tied to this
    * ABFactory.
    * @return {FilterComplex}
    */
   filterComplexNew(idBase, options = {}) {
      return new FilterComplex(idBase, this, options);
   }

   /**
    * @method viewNewDetatched()
    * Return an instance of a View that is NOT attached to an ABApplication.
    * @return {ABViewXXX}
    */
   viewNewDetatched(values) {
      if (!this._mockApp) {
         this._mockApp = this.applicationNew({});
      }
      return this._mockApp.viewNew(values, this._mockApp);
   }

   //
   // Utilities
   //

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(/* ...params */) {
      console.error(
         "ABFactory.notify() is expected to be overwritten by the platform!"
      );
   }

   /**
    * notifyInfo()
    * a common routine to parse the info parameter provided to .notify() into
    * a more detailed set of data.
    * @param {json} info
    * @return {json}
    */
   _notifyInfo(info) {
      var moreInfo = {};

      if (info) {
         Object.keys(info).forEach((k) => {
            switch (k) {
               case "field":
                  moreInfo.objectID = info[k].object.id;
                  moreInfo.objectName = info[k].object.name;
                  moreInfo.fieldID = info[k].id;
                  moreInfo.fieldName = info[k].label || info[k].name;
                  break;

               case "object":
                  moreInfo.objectID = info[k].id;
                  moreInfo.objectName = info[k].name;
                  break;

               case "datacollection":
                  moreInfo.datacollectionID = info[k].id;
                  moreInfo.datacollectionName = info[k].label || info[k].name;
                  var ds = info[k].datasource;
                  if (ds) {
                     moreInfo.datacollectionDSID = ds.id;
                     moreInfo.datacollectionDSName = ds.name;
                  }
                  break;

               case "process":
                  moreInfo.processID = info[k].id;
                  moreInfo.processName = info[k].label || info[k].name;
                  break;

               case "req":
                  moreInfo.req = {
                     jobID: info[k].jobID,
                     tenantID: info[k]._tenantID,
                     user: info[k]._user,
                  };
                  break;

               case "task":
                  if (info[k].process) {
                     moreInfo.processID = info[k].process.id;
                     moreInfo.processName =
                        info[k].process.label || info[k].process.name;
                  }
                  moreInfo.taskID = info[k].id;
                  moreInfo.taskName = info[k].label || info[k].name;
                  break;

               case "view":
                  if (info[k].application) {
                     moreInfo.applicationID = info[k].application.id;
                     moreInfo.applicationName =
                        info[k].application.label || info[k].application.name;
                  }
                  moreInfo.viewID = info[k].id;
                  moreInfo.viewName = info[k].label || info[k].name;
                  moreInfo.viewKey = info[k].key;
                  break;
               default:
                  moreInfo[k] = info[k];
                  break;
            }
         });
      }

      return moreInfo;
   }
}

module.exports = ABFactory;


/***/ }),

/***/ 69594:
/*!*******************************************!*\
  !*** ./AppBuilder/core/ABFieldManager.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldManager
 *
 * An interface for managing the different ABFields available in our AppBuilder.
 *
 */

/*
 * Fields
 * A name => ABField  hash of the different ABFields available.
 */
var Fields = {};

var AllFieldClasses = [
   __webpack_require__(/*! ../platform/dataFields/ABFieldString */ 98134),
   __webpack_require__(/*! ../platform/dataFields/ABFieldLongText */ 74384),
   __webpack_require__(/*! ../platform/dataFields/ABFieldNumber */ 41812),
   __webpack_require__(/*! ../platform/dataFields/ABFieldDate */ 90176),
   __webpack_require__(/*! ../platform/dataFields/ABFieldDateTime */ 21747),
   __webpack_require__(/*! ../platform/dataFields/ABFieldBoolean */ 77280),
   __webpack_require__(/*! ../platform/dataFields/ABFieldList */ 69319),
   __webpack_require__(/*! ../platform/dataFields/ABFieldTree */ 60779),
   __webpack_require__(/*! ../platform/dataFields/ABFieldEmail */ 39137),
   __webpack_require__(/*! ../platform/dataFields/ABFieldFile */ 42597),
   __webpack_require__(/*! ../platform/dataFields/ABFieldImage */ 70780),
   __webpack_require__(/*! ../platform/dataFields/ABFieldUser */ 29333),
   __webpack_require__(/*! ../platform/dataFields/ABFieldConnect */ 66589),
   __webpack_require__(/*! ../platform/dataFields/ABFieldCalculate */ 43088),
   __webpack_require__(/*! ../platform/dataFields/ABFieldTextFormula */ 27238),
   __webpack_require__(/*! ../platform/dataFields/ABFieldFormula */ 58439),
   __webpack_require__(/*! ../platform/dataFields/ABFieldAutoIndex */ 79579),
   __webpack_require__(/*! ../platform/dataFields/ABFieldJson */ 31797),
   __webpack_require__(/*! ../platform/dataFields/ABFieldCombine */ 89142),
   __webpack_require__(/*! ../platform/dataFields/ABFieldSelectivity */ 87038),
];

AllFieldClasses.forEach((FIELD) => {
   Fields[FIELD.defaults().key] = FIELD;
});

module.exports = class ABFieldManager {
   /*
    * @function allFields
    * return all the currently defined ABFields in an array.
    * @return [{ABField},...]
    */
   static allFields() {
      var fields = [];
      for (var f in Fields) {
         fields.push(Fields[f]);
      }
      return fields;
   }

   /**
    * @function fieldByKey()
    * Return a specific ABField that matches the given key
    * @param {string} key
    *        The ABField.key value we are looking for.
    * @return {ABFieldXXX || undefined}
    */
   static fieldByKey(key) {
      return Fields[key];
   }

   /*
    * @function newField
    * return an instance of an ABField based upon the values.key value.
    * @return {ABField}
    */
   static newField(values, object) {
      if (values.key) {
         try {
            return new Fields[values.key](values, object);
         } catch (err) {
            console.log("Error", err);
            console.log("Available fields", Fields);
            console.log("Requested field", values.key);
         }
      } else {
         console.log("-------");
         console.log("values:");
         console.error(values);
         console.log();
         console.error("object:");
         console.error(object);
         console.log("-------");
         throw new Error(
            `ABFieldManager.newField(): Unknown Field Key [${values.name}][${values.key}] for object[${object.name}]`
         );
         //// TODO: what to do here?
      }
   }
};


/***/ }),

/***/ 25739:
/*!****************************************!*\
  !*** ./AppBuilder/core/ABIndexCore.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);

module.exports = class ABIndexCore extends ABMLClass {
   constructor(attributes, object) {
      super(["label"], object.AB);
      this.object = object;

      this.fromValues(attributes);
   }

   fromValues(attributes) {
      /*
      {
        id: uuid(),
        name: 'name',
        fields:[
            {ABDataField.id}
        ],
        unique: {boolean}
      }
      */
      this.id = attributes.id;
      this.type = "index";
      this.name = attributes.name;
      this.unique = JSON.parse(attributes.unique || false);

      // Convert to an array
      if (attributes.fieldIDs && !Array.isArray(attributes.fieldIDs)) {
         attributes.fieldIDs = [attributes.fieldIDs];
      }

      this.fields = (attributes.fieldIDs || [])
         .map((f) => {
            let field = this.object.fieldByID(f);
            if (!field) {
               this.emit(
                  "warning",
                  `Index[${this.name}][${this.id}] is referencing an unknown field[${f}]`,
                  {
                     index: this.id,
                     field: f,
                  }
               );
            }
            return field;
         })
         .filter((fId) => fId);

      if (this.fields.length == 0) {
         this.emit(
            "warning",
            `Index[${this.name}][${this.id}] is not referencing any fields`,
            {
               index: this.id,
               attributeFieldIDs: attributes.fieldIDs || [],
            }
         );
      }

      // let the MLClass process the Translations
      super.fromValues(attributes);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let result = super.toObj();

      result.id = this.id;
      result.type = "index";
      result.name = this.name;
      result.unique = this.unique;

      // Convert to an array
      if (this.fields && !Array.isArray(this.fields)) {
         this.fields = [this.fields];
      }

      result.fieldIDs = (this.fields || [])
         .map((f) => {
            // Convert to the id of field
            return f.id || f;
         })
         .filter((fId) => fId);

      return result;
   }

   get indexName() {
      let tableName = this.object.dbTableName();

      // Maximum 64 characters long
      return `${tableName}_${this.name}`.replace(/ /g, "").substring(0, 64);
   }

   get uniqueName() {
      let indexName = this.indexName.substring(0, 57);

      return `${indexName}_unique`;
   }
};


/***/ }),

/***/ 17243:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABMLClassCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABMLClassCore
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This core ABMLClass will internally track the multilingual fields
 * (this.mlFields) and auto
 */
var ABEmitter = __webpack_require__(/*! ../platform/ABEmitter */ 73686);
module.exports = class ABMLClassCore extends ABEmitter {
   constructor(fieldList, AB) {
      super();
      this.mlFields = fieldList || ["label"];
      // {array}
      // field names of values that are multilingual

      this.AB = AB;
      // {ABFactory}
      // our common source of references for other AB objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * @method fromValues
    * called during the .fromValues() work chain.  Should be called
    * AFTER all the current data is already populated.
    */
   fromValues(attributes) {
      this.translations = attributes.translations;

      // if translations were provided
      if (this.translations) {
         // multilingual fields: label, description
         this.translate();
      } else {
         // maybe this came from a form that has ML values in the attributes, but
         // no .translations[] yet:
         // check for mlFields in attributes and record them here:
         (this.mlFields || []).forEach((field) => {
            if (attributes[field]) {
               this[field] = attributes[field];
            }
         });
      }
   }

   /**
    * @function defaultTranslations()
    * return an initial .translations entry to initialize the
    * translations values of a given translateable object.
    * @param {array} fields  the multilingual fields this obj manages.
    * @param {json}  values  a default set of values for this object.
    * @return {array}  of translation entries.
    */
   defaultTranslations(fields, values) {
      values = values || {};

      var entry = {
         // Question: should this be this.AB.Multilingual.currentLanguage() || "en"
         // currently since the defaults are sent in programattically, we are
         // expecting the labels to be in "en"
         language_code: "en",
      };

      fields.forEach((f) => {
         entry[f] = values[f] || f;
      });

      return [entry];
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return "en";
   }

   /**
    * @method toObj()
    * called during the .toObj() work chain.  Should be called
    * BEFORE the current data is populated.
    */
   toObj() {
      this.unTranslate();

      return {
         translations: this.translations,
      };
   }

   /**
    * @method toDefinition()
    * convert this instance into an ABDefinition object.
    * @return {ABDefinition}
    */
   toDefinition() {
      return this.AB.definitionNew({
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.toObj(),
      });
   }

   /**
    * @method translate
    * Given a set of json data, pull out any multilingual translations
    * and flatten those values to the base object.
    * @param {obj} obj  The instance of the object being translated
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull to
    *                       the obj[field] value.
    */
   translate(obj, json, fields, languageCode = null) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      if (typeof json.translations == "string") {
         json.translations = JSON.parse(json.translations);
      }

      var currLanguage = languageCode || this.languageDefault();

      if (fields && fields.length > 0) {
         // [fix] if no matching translation is in our json.translations
         //       object, then just use the 1st one.
         var first = null; // the first translation entry encountered
         var found = false; // did we find a matching translation?

         json.translations.forEach(function (t) {
            if (!first) first = t;

            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               found = true;

               // copy each field to the root object
               fields.forEach(function (f) {
                  if (t[f] != null) obj[f] = t[f];

                  obj[f] = t[f] || ""; // default to '' if not found.
               });
            }
         });

         // if !found, then use the 1st entry we did find.  prepend desired
         // [language_code] to each of the fields.
         if (!found && first) {
            // copy each field to the root object
            fields.forEach(function (f) {
               if (first[f] != null && first[f] != "")
                  obj[f] = `[${currLanguage}]${first[f]}`;
               else obj[f] = ""; // default to '' if not found.
            });
         }
      }
   }

   /**
    * @method unTranslate
    * Take the multilingual information in the base obj, and push that
    * down into the json.translations data.
    * @param {obj} obj  The instance of the object with the translation
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull from
    *                       the obj[field] value.
    */
   unTranslate(obj, json, fields) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      var currLanguage = this.languageDefault();

      if (fields && fields.length > 0) {
         var foundOne = false;

         json.translations.forEach(function (t) {
            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               // copy each field to the root object
               fields.forEach(function (f) {
                  // verify obj[f] is defined
                  // --> DONT erase the existing translation
                  if (obj[f] != null) {
                     t[f] = obj[f];
                  }
               });

               foundOne = true;
            }
         });

         // if we didn't update an existing translation
         if (!foundOne) {
            // create a translation entry:
            var trans = {};

            // assume current languageCode:
            trans.language_code = currLanguage;

            fields.forEach(function (field) {
               if (obj[field] != null) {
                  trans[field] = obj[field];
               }
            });

            json.translations.push(trans);
         }
      }
   }
};


/***/ }),

/***/ 71692:
/*!****************************************!*\
  !*** ./AppBuilder/core/ABModelCore.js ***!
  \****************************************/
/***/ ((module) => {

//
// ABModelCore
//
// Represents the Data interface for an ABObject data.
//
// to use an ABModel to load a DataTable:
// Method 1:
//  gather all the data externally and send to the DataTable
//    Model.findAll()
//    .then((data)=>{
//      DataTable.parse(data);
//    })
//

module.exports = class ABModelCore {
   constructor(object) {
      // link me to my ABObject
      this.object = object;
      this.AB = object.AB;

      this._where = null;
      this._sort = null;
      this._skip = null;
      this._limit = null;

      this.staleRefreshInProcess = false;
      this.staleRefreshMap = {
         /* id : Promise */
      };
      this.staleRefreshPending = [];
      this.staleRefreshTimerID = null;

      // include this
      this.responseContext = { key: "--", context: {} };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   contextKey(key) {
      this.responseContext.key = key || "--";
   }

   contextValues(values) {
      this.responseContext.context = values || {};
   }

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      console.error(
         "!!! ABModelCore.request() should be overridden by platform."
      );
      return Promise.resolve();
   }

   // /**
   //  * @method create
   //  * update model values on the server.
   //  */
   // create(values) {

   //   this.prepareMultilingualData(values);

   //   var params = {
   //     url: this.object.urlRest(),
   //     params: values
   //   }
   //   return this.request('post', params)
   //     .then((data) => {

   //       this.normalizeData(data);

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a create event
   //       // triggerEvent('create', this.object, data);

   //     })
   //     .catch(reject);

   // }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer} id  the .id of the instance to remove.
    * @return {Promise}
    */
   // delete(id) {

   //   var params = {
   //     url: this.object.urlRestItem(id)
   //   }
   //   return this.request('delete', params)
   //     .then((data) => {

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a delete event
   //       // triggerEvent('delete', this.object, id);

   //     })
   // }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   //   findAll(cond) {

   //     cond = cond || {};

   //     var params = {
   //       url: this.object.urlRest(),
   //       params: cond
   //     }
   //     return this.request('get', params)
   //       .then((data) => {

   //         this.normalizeData(data.data);

   //         resolve(data);
   //       })
   //       .catch((err) => {
   // /// TODO: this should be done in platform/ABModel:
   //         // if (err && err.code) {
   //         //  switch(err.code) {
   //         //    case "ER_PARSE_ERROR":
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Parse Error with provided condition', { error: err, condition:cond })
   //         //      break;

   //         //    default:
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Unknown Error with provided condition', { error: err, condition:cond })
   //         //      break;
   //         //  }

   //         // }
   // console.error(err);
   //       })

   //   }

   urlParamsCreate(values) {
      return {
         url: this.object.urlRest(),
         params: values,
      };
   }

   urlParamsDelete(id) {
      return {
         url: this.object.urlRestItem(id),
      };
   }

   urlParamsFind(cond) {
      return {
         url: this.object.urlRest(),
         params: cond || {},
      };
   }

   urlParamsUpdate(id, values) {
      return {
         url: this.object.urlRestItem(id),
         params: values,
      };
   }

   /**
    * @method count
    * count a data find with the provided condition.
    */
   count(cond) {
      cond = cond || {};

      var params = {
         url: this.object.urlRestCount(),
         params: cond,
      };
      return this.request("get", params)
         .then((numberOfRows) => {
            resolve(numberOfRows);
         })
         .catch((err) => {
            // TODO: this should be done in platform/ABModel

            // OP.Error.log('AppBuilder:ABModel:count(): Parse Error with provided condition', { error: err, condition:cond })

            // reject(err);
            console.error(err);
         });
   }

   /**
    * @method staleRefresh
    * Process a request to refresh the data for a given entry.
    * This method is called from a ABDataview when it receives
    * a 'ab.datacollection.stale' message.
    * This method will try to queue similar reqeusts and then issue 1 large
    * request, rather than numerous individual ones.
    * @param {obj} cond  the condition of the entry we are requesting.
    * @return {Promise}
    */
   staleRefresh(cond) {
      // cond should be { where:{ id: X } } format.
      var PK = this.object.PK();

      var currID = cond[PK]; // just in case we get a { id: X }
      if (cond.where) {
         currID = cond.where[PK];
      }

      return new Promise((resolve, reject) => {
         if (!currID) {
            var Err = new Error(
               "Model.staleRefresh(): could not resolve ." + PK
            );
            Err.cond = cond;
            reject(Err);
            return;
         }

         // convert to PK : Promise object:
         var entry = {
            resolve: resolve,
            reject: reject,
         };
         entry[PK] = currID;

         // queue up refresh condition
         this.staleRefreshPending.push(entry);

         // if ! staleRefreshInProcess
         if (!this.staleRefreshInProcess) {
            // set timeout to another 200ms wait after LAST staleRefresh()
            if (this.staleRefreshTimerID) {
               clearTimeout(this.staleRefreshTimerID);
            }
            this.staleRefreshTimerID = setTimeout(() => {
               this.staleRefreshProcess();
            }, 200);
         }
      });
   }

   /**
    * @method staleRefreshProcess
    * Actually process the current pending requests.
    */
   staleRefreshProcess() {
      this.staleRefreshInProcess = true;
      var currentEntries = this.staleRefreshPending;
      this.staleRefreshPending = [];
      var PK = this.object.PK();

      var responseHash = {
         /* id : [{entry}] */
      };
      var cond = { where: {} };
      cond.where[PK] = [];

      console.log(
         "Model.staleRefreshProcess(): buffered " +
            currentEntries.length +
            " requests"
      );
      currentEntries.forEach((e) => {
         responseHash[e[PK]] = responseHash[e[PK]] || [];
         responseHash[e[PK]].push(e);
      });

      cond.where[PK] = Object.keys(responseHash);

      this.findAll(cond).then((res) => {
         // for each entry we got back
         if (Array.isArray(res.data) && res.data.length) {
            res.data.forEach((data) => {
               // find it's matching request:
               if (responseHash[data[PK]]) {
                  // respond to the pending promise
                  // and remove these entries from responseHash
                  var entries = responseHash[data[PK]];
                  entries.forEach((entry) => {
                     var resolve = entry.resolve;
                     resolve({ data: [data] });
                  });

                  delete responseHash[data[PK]];
               } else {
                  console.error(
                     "Model.staleRefreshProcess(): returned entry was not in our responseHash:",
                     data,
                     responseHash
                  );
               }
            });
         }

         // now if there are any entries left in responseHash,
         // respond with an empty entry:
         var allKeys = Object.keys(responseHash);
         if (allKeys.length > 0) {
            console.warn(
               "Model.staleRefreshProcess(): " +
                  allKeys.length +
                  " entries with no responses. "
            );
         }
         allKeys.forEach((key) => {
            var resolve = responseHash[key].resolve;
            resolve({ data: [] });
            delete responseHash[key];
         });

         // now check to see if there are any more pending requests:
         if (this.staleRefreshPending.length > 0) {
            // process them:
            this.staleRefreshProcess();
         } else {
            // mark we are no longer processing stale requests.
            this.staleRefreshInProcess = false;
         }
      });
   }

   /**
     * @method findConnected
     * return the connected data associated with an instance of this model.
     *
     * to limit the result to only a single connected column:
     *    model.findConnected( 'col1', {data})
     *    then ((data) => {
     *      // data = [{obj1}, {obj2}, ... {objN}]
     *    })
     *
     * To find >1 connected field data:
     *    model.findConnected( ['col1', 'col2'], {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     col1 : [{obj1}, {obj2}, ... {objN}],
     *      //     col2 : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })
     *
     * To find all connected field data:
     *    model.findConnected( {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     connectedColName1 : [{obj1}, {obj2}, ... {objN}],
     *      //     connectedColName2 : [{obj1}, {obj2}, ... {objN}],
     *      //    ...
     *      //     connectedColNameN : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })

     * @param {string/array} fields  [optional] an array of connected fields you want to return.
     * @param {obj} data  the current object instance (data) to lookup
     * @return {Promise}
     */
   findConnected(fields, data) {
      if (typeof data == "undefined") {
         if (!Array.isArray(fields) && typeof fields == "object") {
            data = fields;
            fields = []; // return all fields
         }
      }

      if (typeof fields == "string") {
         fields = [fields]; // convert to an array of values
      }

      return new Promise((resolve, reject) => {
         // sanity checking:
         if (!data.id) {
            // I can't find any connected items, if I can't find this one:
            resolve(null);
            return;
         }

         let cond = {};
         cond[this.object.PK()] = data.id;
         this.findAll({ where: cond, includeRelativeData: true })
            .then((results) => {
               if (
                  !results.data ||
                  !Array.isArray(results.data) ||
                  results.data.length == 0
               ) {
                  resolve([]); // no data to return.
                  return;
               }

               // work with the first object.
               var myObj = results.data[0];

               // if only 1 field requested, then return that
               if (fields.length == 1) {
                  let data =
                     myObj[
                        fields[0].replace(/[^a-z0-9\.]/gi, "") + "__relation"
                     ];
                  if (!data) return resolve([]);

                  if (!Array.isArray(data)) data = [data];

                  resolve(data);
                  return;
               }

               // if no fields requested, return them all:
               if (fields.length == 0) {
                  var allFields = this.object.fields((f) => {
                     return f.settings.linkType;
                  });
                  allFields.forEach((f) => {
                     fields.push(f.columnName);
                  });
               }

               var returnData = {};
               fields.forEach((colName) => {
                  returnData[colName] =
                     myObj[colName.replace(/[^a-z0-9\.]/gi, "") + "__relation"];
               });

               resolve(returnData);
            })
            .catch((err) => {
               console.error("!!! error with findConnected() attempt:", err);
               reject(err);
            });
      });
   }

   // /**
   //  * @method loadInto
   //  * loads the current values into the provided Webix DataTable
   //  * @param {DataTable} DT  A Webix component that can dynamically load data.
   //  */
   // loadInto(DT) {

   //   // if a limit was applied, then this component should be loading dynamically
   //   if (this._limit) {

   //     DT.define('datafetch', this._limit);
   //     DT.define('datathrottle', 250);  // 250ms???

   //     // catch the event where data is requested:
   //     // here we will do our own findAll() so we can persist
   //     // the provided .where condition.

   //     // oh yeah, and make sure to remove any existing event handler when we
   //     // perform a new .loadInto()
   //     DT.___AD = DT.___AD || {};
   //     if (DT.___AD.onDataRequestEvent) {
   //       DT.detachEvent(DT.___AD.onDataRequestEvent);
   //     }
   //     DT.___AD.onDataRequestEvent = DT.attachEvent("onDataRequest", (start, count) => {

   //       var cond = {
   //         where: this._where,
   //         sort: this._sort,
   //         limit: count,
   //         skip: start
   //       }

   //       if (DT.showProgress)
   //         DT.showProgress({ type: "icon" });

   //       this.findAll(cond)
   //         .then((data) => {
   //           data.data.forEach((item) => {
   //             if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //               item.$height = parseInt(item.properties.height);
   //             } else if (parseInt(this._where.height) > 0) {
   //               item.$height = parseInt(this._where.height)
   //             }
   //           });
   //           DT.parse(data);

   //           if (DT.hideProgress)
   //             DT.hideProgress();

   //         })

   //       return false; // <-- prevent the default "onDataRequest"
   //     });

   //     DT.refresh();
   //   }

   //   // else just load it all at once:
   //   var cond = {};
   //   if (this._where) cond.where = this._where;
   //   if (this._sort) cond.sort = this._sort;
   //   if (this._limit != null) cond.limit = this._limit;
   //   if (this._skip != null) cond.skip = this._skip;

   //   if (DT.showProgress)
   //     DT.showProgress({ type: "icon" });

   //   this.findAll(cond)
   //     .then((data) => {
   //       data.data.forEach((item) => {
   //         if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //           item.$height = parseInt(item.properties.height);
   //         } else if (parseInt(this._where.height) > 0) {
   //           item.$height = parseInt(this._where.height)
   //         }
   //       });
   //       DT.parse(data);

   //       if (DT.hideProgress)
   //         DT.hideProgress();

   //     })
   //     .catch((err) => {
   //       console.error('!!!!!', err);
   //     })

   // }

   // /**
   //  * @method limit
   //  * set the limit value for this set of data
   //  * @param {integer} limit  the number or elements to return in this call
   //  * @return {ABModel} this object that is chainable.
   //  */
   // limit(limit) {
   //   this._limit = limit;
   //   return this;
   // }

   // /**
   //  * @method skip
   //  * set the skip value for this set of data
   //  * @param {integer} skip  the number or elements to skip
   //  * @return {ABModel} this object that is chainable.
   //  */
   // skip(skip) {
   //   this._skip = skip;
   //   return this;
   // }

   //   /**
   //    * @method update
   //    * update model values on the server.
   //    */
   //   update(id, values) {

   //     this.prepareMultilingualData(values);

   //     // remove empty properties
   //     for (var key in values) {
   //       if (values[key] == null)
   //         delete values[key];
   //     }

   //     var params = {
   //       url: this.object.urlRestItem(id),
   //       params: values
   //     }
   //     return this.request('put', params)
   //       .then((data) => {

   //         // .data is an empty object ??

   //         this.normalizeData(data);

   //         return data;

   //         // FIX: now with sockets, the triggers are fired from socket updates.
   //         // trigger a update event
   //         // triggerEvent('update', this.object, data);

   //       })
   //       .catch((err)=>{
   // console.error(err);
   //       });

   //   }

   /**
    * @method upsert
    * upsert model values on the server.
    */
   upsert(values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      var params = {
         url: this.object.urlRest(),
         params: values,
      };
      return this.request("put", params)
         .then((data) => {
            // .data is an empty object ??

            this.normalizeData(data);

            return data;

            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a update event
            // triggerEvent('update', this.object, data);
         })
         .catch((err) => {
            console.error(err);
         });
   }

   /**
    * @method where
    * set the where condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   where(cond) {
      this._where = cond;
      return this;
   }

   /**
    * @method where
    * set the sort condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   sort(cond) {
      this._sort = cond;
      return this;
   }

   /**
    * @method refresh
    * refresh model definition on the server.
    */
   refresh() {
      console.error("!!! Depreciated: where is this being called from?");
      return Promise.resolve();

      // var params = {
      //    url: this.object.urlRestRefresh(),
      // };
      // return this.request("put", params);
   }

   normalizeData(data) {
      // convert to array
      if (!(data instanceof Array)) data = [data];

      // find all connected fields
      var connectedFields = this.object.connectFields();

      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();

      // if this object has some date fields, convert the data to date object:
      var dateFields =
         this.object.fields(function (f) {
            return f.key == "date" || f.key == "datetime";
         }) || [];

      // calculate fields
      var calculatedFields = this.object.fields((f) => f.key == "calculate");

      data.forEach((d) => {
         if (d == null) return;

         // various PK name
         if (!d.id && this.object.PK() != "id") d.id = d[this.object.PK()];

         // loop through data's connected fields
         connectedFields.forEach((c) => {
            // get the relation name so we can change the original object
            var relationName = c.relationName();

            // if (d[c.columnName] == null)
            //  d[c.columnName] = '';

            // if there is no data we can exit now
            if (d[relationName] == null) return;

            // if relation data is still a string and isn't empty
            if (
               typeof d[relationName] == "string" &&
               d[relationName].length > 0
            ) {
               // parse the string into an object
               d[relationName] = JSON.parse(d[relationName]);
            }

            // if the data is an array we need to loop through it
            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((r) => {
                  // if translations are present and they are still a string
                  if (r.translations && typeof r.translations == "string") {
                     // parse the string into an object
                     r.translations = JSON.parse(r.translations);
                  }
               });
               // if the data is not an array it is a single item...check that has translations and it is a string
            } else if (
               d[relationName].translations &&
               typeof d[relationName].translations == "string"
            ) {
               // if so parse the string into an object
               d[relationName].translations = JSON.parse(
                  d[relationName].translations
               );
            }

            // set .id to relation columns
            let objectLink = c.datasourceLink;
            if (
               objectLink &&
               objectLink.PK() != "id" &&
               d[relationName] &&
               !d[relationName].id
            ) {
               // is array
               if (d[relationName].forEach) {
                  d[relationName].forEach((subData) => {
                     if (subData[objectLink.PK()])
                        subData.id = subData[objectLink.PK()];
                  });
               } else if (d[relationName][objectLink.PK()]) {
                  d[relationName].id = d[relationName][objectLink.PK()];
               }
            }

            var relatedMlFields = objectLink.multilingualFields();
            if (relatedMlFields.length) {
               objectLink.translate(
                  d[relationName],
                  d[relationName],
                  relatedMlFields
               );
            }

            // Change property name of connected field
            if (!d[c.columnName]) d[c.columnName] = d[relationName];
         });

         if (mlFields.length) {
            this.object.translate(d, d, mlFields);
         }

         // convert the data to date object
         dateFields.forEach((date) => {
            if (d && d[date.columnName] != null) {
               // check to see if data has already been converted to a date object
               if (typeof d[date.columnName] == "string") {
                  if (date.key == "date") {
                     // if we are ignoring the time it means we ignore timezone as well
                     // so lets trim that off when creating the date so it can be a simple date
                     d[date.columnName] = this.AB.toDate(d[date.columnName], {
                        format: "MM/DD/YYYY",
                        ignoreTime: true,
                     });
                  } else {
                     // Convert UTC to Date
                     d[date.columnName] = this.AB.toDate(d[date.columnName]);
                     // d[date.columnName] = new Date(moment(d[date.columnName]));
                  }
               }
            }
         });

         calculatedFields.forEach((calField) => {
            d[calField.columnName] = calField.format(d);
         });
      });
   }
};


/***/ }),

/***/ 96937:
/*!*****************************************!*\
  !*** ./AppBuilder/core/ABObjectCore.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABObjectCore
 *
 * Manage the loading of specific ABObject data into useable objects
 * that can instantiate themselves and provide field and model resources.
 */

var ABModel = __webpack_require__(/*! ../platform/ABModel */ 48912);
var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABObjectCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      /*
{
	id: uuid(),
	connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
	name: 'name',
	labelFormat: 'xxxxx',
	labelSettings: Object,
	isImported: 1/0,
	isExternal: 1/0,
	tableName:'string',  // NOTE: store table name of import object to ignore async
	primaryColumnName: 'string', // NOTE: store column name of PK
	transColumnName: 'string', // NOTE: store column name of translations table
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:	 ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],
	fields:[
		{ABDataField}
   ],
   indexes: [
      {ABIndex}
   ]
}
*/

      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object. These methods are not dependent
   /// on the instance values of the Application.
   ///

   static contextKey() {
      return "object";
   }

   ///
   /// Instance Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
            name: 'name',
            labelFormat: 'xxxxx',
            labelSettings: Object,
            isImported: 1/0,
            isExternal: 1/0,
            tableName:'string',  // NOTE: store table name of import object to ignore async
            primaryColumnName: 'string', // NOTE: store column name of PK
            transColumnName: 'string', // NOTE: store column name of translations table
            urlPath:'string',
            importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
                                        // to get other object:  ABApplication.objectFromRef(obj.importFromObject);
            translations:[
                {}
            ],
            fields:[
                {ABDataField}
            ],
            indexes: [
               {ABIndex}
            ]
        }
        */

      this.id = attributes.id;
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = attributes.type || "object";
      // {string} .type
      // the type of ABDefinition this is.

      this.connName = attributes.connName || undefined; // undefined == 'appBuilder'
      // {string} .connName
      // the sails.config.connections[connName] configuration reference.
      // if not set ({undefined}), then our default "appBuilder" config is used

      this.name = attributes.name || "";
      // {string} .name
      // A name reference for this ABObject. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      this.labelFormat = attributes.labelFormat || "";
      // {string} .labelFormat
      // A string template for how to display an entry for this ABObject in
      // common UI elements like grids, lists, etc...

      this.labelSettings = attributes.labelSettings || {};
      // {Object} .labelSettings

      this.labelSettings.isNoLabelDisplay = parseInt(
         this.labelSettings.isNoLabelDisplay || 0
      );
      // {bool} .isNoLabelDisplay

      this.isImported = parseInt(attributes.isImported || 0);
      // {depreciated}
      // {bool} .isImported
      // previously used to mark ABObjects that were created in other
      // ABApplicaitons.  No longer relevant with Global ABObjects

      this.isExternal = parseInt(attributes.isExternal || 0);
      // {bool} .isExternal
      // Marks this ABObject as referencing a pre-existing table in the DB that
      // we are treating as an ABObject.
      // These objects are not allowed to create/update/destroy the db table
      // nor can we add/remove fields.
      // However we are able to customize the Field definitions to change the
      // column names, hidden attributes, Object label, etc...
      // We can update our Defintion attributes, but not any actual DB changes.

      this.tableName = attributes.tableName || ""; // NOTE: store table name of import object to ignore async
      // {string} .tableName
      // the `{database}.{tableName}` of the db table that this ABObject's data
      // is stored in.
      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.tableName = this.tableName.replace(/[^a-zA-Z0-9_ ]/gi, "");

      this.primaryColumnName = attributes.primaryColumnName || ""; // NOTE: store column name of PK
      // {string} .primaryColumnName
      // is the col_name of which key is the primary key.  By default it is
      // "uuid", but in some external objects this might be something else
      // ("id", "ren_id", etc...).

      this.transColumnName = attributes.transColumnName || ""; // NOTE: store column name of translations table
      // {string} .transColumnName
      // this is a workaround to include hris_ren_data and hris_ren_trans data

      this.urlPath = attributes.urlPath || "";

      // this.importFromObject = attributes.importFromObject || "";

      this.isSystemObject = attributes.isSystemObject;
      // {bool} .isSystemObject
      // We are now storing some of our System Required Data as ABObjects as well.
      // These Objects should not be allowed to be modified by typical AppBuilder
      // designer.  However we can enable a mode for AB Designer to then expand these
      // ABObjects, and eventually we can use the AppBuilder to Create the AppBuilder.
      if (
         typeof this.isSystemObject == "undefined" ||
         this.isSystemObject == "false"
      ) {
         this.isSystemObject = false;
      }

      this.createdInAppID = attributes.createdInAppID;
      // {string} .createdInAppID
      // the .id of the ABApplication that originally created this ABObject.

      // if attributes.objectWorkspace DOES exist, make sure it is fully
      // populated.
      if (typeof attributes.objectWorkspace != "undefined") {
         if (typeof attributes.objectWorkspace.sortFields == "undefined")
            attributes.objectWorkspace.sortFields = [];
         if (typeof attributes.objectWorkspace.filterConditions == "undefined")
            attributes.objectWorkspace.filterConditions = [];
         if (typeof attributes.objectWorkspace.frozenColumnID == "undefined")
            attributes.objectWorkspace.frozenColumnID = "";
         if (typeof attributes.objectWorkspace.hiddenFields == "undefined")
            attributes.objectWorkspace.hiddenFields = [];
      }
      this.objectWorkspace = attributes.objectWorkspace || {
         sortFields: [], // array of columns with their sort configurations
         filterConditions: [], // array of filters to apply to the data table
         frozenColumnID: "", // id of column you want to stop freezing
         hiddenFields: [], // array of [ids] to add hidden:true to
      };
      // {obj} .objectWorkspace
      // When in the ABObject editor in the AppBuilder Designer, different
      // views of the information can be created.  These views are stored here
      // and are avaiable to other users in the Designer.

      // pull in field definitions:
      var fields = [];
      this.fieldIDs = attributes.fieldIDs || [];
      // {array}  [ ABField.id, ... ]
      // this is a collection of ALL the ABFields this object references.
      // This will include ABFields that were directly created for this object
      // and will include ABFields that were imported.

      this.importedFieldIDs = attributes.importedFieldIDs || [];
      // {array} [ ABField.id, ... ]
      // this is a collection of the ABFields in our .fieldIDs that were
      // IMPORTED.

      this.fieldIDs.forEach((id) => {
         if (!id) return;

         var def = this.AB.definitionByID(id);
         if (def) {
            fields.push(this.AB.fieldNew(def, this));
         } else {
            this.emit(
               "warning",
               `O[${this.name}] is referenceing an unknown field id[${id}]`,
               {
                  obj: this.id,
                  field: id,
               }
            );
         }
      });
      this._fields = fields;

      // pull in index definitions:
      this.importIndexes(attributes.indexIDs);

      // let the MLClass now process the translations:
      super.fromValues(attributes);
   }

   /**
    * @method importIndexes
    * instantiate a set of indexes from the given ids.
    * @param {array} indexIDs The different ABDefinition IDs for each index
    *        [ "uuid11", "uuid2", ... "uuidN" ]
    */
   importIndexes(indexIDs) {
      var indexes = [];
      (indexIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            indexes.push(this.AB.indexNew(def, this));
         } else {
            this.emit(
               "warning",
               `O[${this.name}] is referenceing an unknown index id[${id}]`,
               {
                  obj: this.id,
                  index: id,
               }
            );
         }
      });
      this._indexes = indexes;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   // exportFields() {
   //     var currFields = [];
   //     this._fields.forEach((obj) => {
   //         currFields.push(obj.toObj());
   //     });
   //     return currFields;
   // }

   // /**
   //  * @method exportFields
   //  * convert our array of fields into a settings object for saving to disk.
   //  * @return {array}
   //  */
   // exportIndexes() {
   //    var currIndexes = [];
   //    this._indexes.forEach((idx) => {
   //       currIndexes.push(idx.toObj());
   //    });
   //    return currIndexes;
   // }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      // track the field .ids of our fields
      var fieldIDs = this.fields().map((f) => f.id);

      // track the index .ids of our indexes
      var indexIDs = this.indexes().map((f) => f.id);

      return {
         id: this.id,
         type: this.type || "object",
         connName: this.connName,
         name: this.name,
         labelFormat: this.labelFormat,
         labelSettings: this.labelSettings || {},
         isImported: this.isImported,
         isExternal: this.isExternal,
         tableName: this.tableName,
         // NOTE: store table name of import object to ignore async
         primaryColumnName: this.primaryColumnName,
         // NOTE: store column name of PK
         transColumnName: this.transColumnName,
         // NOTE: store column name of translations table
         urlPath: this.urlPath,
         // importFromObject: this.importFromObject,
         objectWorkspace: this.objectWorkspace,
         isSystemObject: this.isSystemObject,

         translations: obj.translations,
         fieldIDs: fieldIDs,
         importedFieldIDs: this.importedFieldIDs,
         indexIDs: indexIDs,
         createdInAppID: this.createdInAppID,
      };
   }

   ///
   /// Objects
   ///

   /**
    * @method objectLinks()
    *
    *  return an array of ABObject that's connected.
    *
    * @param {object} filter
    * @return {array} - An array of ABObject
    */
   objectLinks(/* filter */) {
      var connectFields = this.connectFields();

      return connectFields.map((f) => f.datasourceLink);
   }

   ///
   /// Fields
   ///

   /**
    * @method fields()
    * return an array of all the ABFields for this ABObject.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array[ABFieldxxx]}
    */
   fields(fn = () => true) {
      return this._fields.filter(fn);
   }

   /**
    * @method fieldByID()
    * return the object's field from the given {ABField.id}
    * @param {string} id
    *        the uuid of the field to return.
    * @return {ABFieldxxx}
    */
   fieldByID(id) {
      return this.fields((f) => f?.id == id)[0];
   }

   /**
    * @method connectFields()
    *
    * return an array of the ABFieldConnect that is connect object fields.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   connectFields(fn = () => true) {
      return this.fields((f) => f && f.isConnection).filter(fn);
   }

   /**
    * @method fieldImport
    * register the given ABField.id as an imported field for this ABObject.
    * The ABField definition should be available before making this call.
    * After this call, the ABField is included in the ABObject, but the ABObject
    * has NOT been saved.
    * @param {ABField} fieldID The ABDefinition.id for a field that is imported
    *        into this object.
    */
   fieldImport(id) {
      if (!id) return;

      if (this.importedFieldIDs.indexOf(id) == -1) {
         this.importedFieldIDs.push(id);
      }

      // just to be safe:
      var isThere = this._fields.find((f) => f.id == id);
      if (!isThere) {
         var def = this.AB.definitionByID(id);
         if (def) {
            this._fields.push(this.AB.fieldNew(def, this));
         } else {
            this.emit(
               "warning",
               `O[${this.name}] is importing an unknown field id[${id}]`,
               {
                  obj: this.id,
                  field: id,
               }
            );
         }
      }
   }

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @return {ABField}
    */
   fieldNew(values) {
      return this.AB.fieldNew(values, this);
   }

   /**
    * @method fieldRemove()
    *
    * remove the given ABField from our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldRemove(field) {
      var origLen = this._fields.length;
      this._fields = this.fields(function (o) {
         return o.id != field.id;
      });

      // be sure to remove this from our imported ids if it was
      // listed there.
      this.importedFieldIDs = this.importedFieldIDs.filter(
         (fid) => fid != field.id
      );

      if (this._fields.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method fieldReorder()
    *
    * reorder the fields in our object
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldReorder(sourceId, targetId) {
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == sourceId) {
            itemMoved = this._fields[i];
            this._fields.splice(i, 1);
            oPos = i;
            break;
         }
      }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (var j = 0; j < this._fields.length; j++) {
         if (this._fields[j].columnName == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) {
               j++;
            }
            this._fields.splice(j, 0, itemMoved);
            break;
         }
      }

      return this.save();
   }

   /**
    * @method fieldSave()
    *
    * save the given ABField in our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldSave(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         this._fields.push(field);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method fieldAdd()
    *
    * save the given ABField in our ._fields array and persist the current
    * values if they changed.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldAdd(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._fields.push(field);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method imageFields()
    *
    * return an array of the ABFieldImage fields this object has.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   imageFields(fn = () => true) {
      return this.fields((f) => f && f.key == "image").filter(fn);
   }

   /**
    * @method multilingualFields()
    *
    * return an array of columnnames that are multilingual.
    *
    * @return {array}
    */
   multilingualFields() {
      return this.fields((f) => f && f.isMultilingual).map((f) => f.columnName);
   }

   /**
    * @method indexes()
    *
    * return an array of all the ABIndex for this ABObject.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   indexes(filter = () => true) {
      return this._indexes.filter(filter);
   }

   /**
    * @method indexByID()
    * return the object's index from the given {ABIndex.id}
    * @param {string} id
    *        the id of the ABIndex to return.
    * @return {ABIndex}
    */
   indexByID(id) {
      return this.indexes((f) => f.id == id)[0];
   }

   /**
    * @method indexRemove()
    * remove the given ABIndex from our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexRemove(index) {
      var origLen = this._indexes.length;
      this._indexes = this.indexes(function (idx) {
         return idx.id != index.id;
      });

      // persist our changes if something changed.
      if (origLen != this._indexes.length) {
         return this.save();
      }

      // nothing was removed, so continue on.
      return Promise.resolve();
   }

   /**
    * @method indexSave()
    * save the given ABIndex in our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexSave(index) {
      var isIncluded = this.indexByID(index.id);
      if (!isIncluded) {
         this._indexes.push(index);
         return this.save();
      }

      return Promise.resolve();
   }

   ///
   /// Working with data from server
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObject.
    */
   model() {
      var model = new ABModel(this);

      // default the context of this model's operations to this object
      model.contextKey(ABObjectCore.contextKey());
      model.contextValues({ id: this.id });

      return model;
   }

   ///
   /// URL
   ///

   /**
    * @method urlRest
    * return the url to access the data for this object.
    * @return {string}
    */
   urlRest() {
      return `/app_builder/model/${this.id}`;
   }

   /**
    * @method urlRestBatch
    * return the url to use for batch creates for this object
    * @return {string}
    */
   urlRestBatch() {
      return `/app_builder/batch/model/${this.id}`;
   }

   /**
    * @method urlRestItem
    * return the url to access the data for an instance of this object.
    * @return {string}
    */
   urlRestItem(id) {
      return `/app_builder/model/${this.id}/${id}`;
   }

   /**
    * @method urlRestLog
    * return the url to access the logs for this ABObject.
    * @return {string}
    */
   urlRestLog() {
      return `/app_builder/object/${this.id}/track`;
   }

   /**
    * @method urlRestRefresh
    * return the url to signal a refresh for this object.
    * @return {string}
    */
   urlRestRefresh() {
      return `/app_builder/model/refreshobject/${this.id}`;
   }

   /**
    * @method urlCount
    * return the url to count of data for this object.
    * @return {string}
    */
   urlRestCount() {
      return `/app_builder/model/count/${this.id}`;
   }

   ///
   ///	Object Workspace Settings
   ///
   get workspaceSortFields() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.sortFields;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.sortFields;
      }
   }

   set workspaceSortFields(fields) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.sortFields = fields;
      }
      // old version
      else {
         this.objectWorkspace.sortFields = fields;
      }
   }

   get workspaceFilterConditions() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.filterConditions;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.filterConditions;
      }
   }

   set workspaceFilterConditions(filterConditions) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.filterConditions = filterConditions;
      }
      // old version
      else {
         this.objectWorkspace.filterConditions = filterConditions;
      }
   }

   get workspaceFrozenColumnID() {
      return this.objectWorkspace.frozenColumnID;
   }

   set workspaceFrozenColumnID(id) {
      this.objectWorkspace.frozenColumnID = id;
   }

   get workspaceHiddenFields() {
      return this.objectWorkspace.hiddenFields || [];
   }

   set workspaceHiddenFields(fields) {
      this.objectWorkspace.hiddenFields = fields;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return this.isImported || this.isExternal;
   }

   /**
    * @method defaultValues
    * Collect a hash of key=>value pairs that represent the default values
    * from each of our fields.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   defaultValues() {
      var values = {};
      this.fields().forEach((f) => {
         f.defaultValue(values);
      });

      return values;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(/* data */) {
      // NOTE: the platform needs to define a way to verify the data
      console.warn("Platform.ABObject.isValidData() missing");
      return true;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error("Who is calling this?");

      if (this.application == null) return null;

      return this.application.urlObject(acrossApp) + this.id;
   }

   /**
    * @method urlField
    * return a string pointer to this object's fields
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlField(acrossApp) {
      console.error("Who is calling this?");

      return this.urlPointer(acrossApp) + "/_fields/";
   }

   /**
    * @method PK
    * return a string of the primary column name
    *
    * @return {string}
    */
   PK() {
      return this.primaryColumnName || "uuid";
   }

   remoteCreate(data) {
      console.log(
         "object[" + this.name + "] received a remoteCreate() with data:",
         data
      );
   }

   /**
    * @method clone
    * return a clone of ABObject
    *
    * @return {ABObjectBase}
    */
   clone() {
      // ignore properties who're spend much performance
      // NOTE: do not clone them. Just copy reference
      let ignoreProps = ["application", "_fields"];

      let cloneOne = JSON.parse(JSON.stringify(this));

      ignoreProps.forEach((prop) => {
         cloneOne[prop] = this[prop];
      });

      return cloneOne;
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = "{" + defaultField.id + "}";
         else {
            // if label is empty, then show .id
            if (!labelData.trim()) {
               let labelSettings = this.labelSettings || {};
               if (labelSettings && labelSettings.isNoLabelDisplay) {
                  labelData = L(labelSettings.noLabelText || "[No Label]");
               } else {
                  // show id of row
                  labelData = `${
                     this.AB.rules.isUUID(rowData.id) ? "ID: " : ""
                  }${rowData.id}`;
               }
            }
         }
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.rules.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }
};


/***/ }),

/***/ 40777:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABObjectQueryCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//

var ABObject = __webpack_require__(/*! ../platform/ABObject */ 67826);
var ABModelQuery = __webpack_require__(/*! ../platform/ABModelQuery */ 94371);

module.exports = class ABObjectQueryCore extends ABObject {
   constructor(attributes, AB) {
      super(attributes, AB);
      /*
{
	id: uuid(),
	name: 'name',
	labelFormat: 'xxxxx',
	isImported: 1/0,
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],



	// ABOBjectQuery Specific Changes
	// we store a list of fields by their urls:
	fields:[
		{
			alias: "",
			fieldURL:'#/url/to/field',
		}
	],


	// we store a list of joins:
	joins:{
		alias: "",							// the alias name of table - use in SQL command
		objectURL:"#/...",					// the base object of the join
		links: [
			{
				alias: "",							// the alias name of table - use in SQL command
				fieldID: "uuid",					// the connection field of the object we are joining with.
				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
				links: [
					...
				]
			}
		]

	},


	where: { QBWhere }
}
*/
      this.isQuery = true;
      // {bool}
      // a property to mark the difference between an ABObject and ABObjectQuery.

      // this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * contextKey()
    * returns a unique key that represents a query in
    * our networking job resolutions.
    * @return {string}
    */
   static contextKey() {
      return "query";
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.type = "query";

      // populate connection objects
      // this._objects = {};
      // this.obj2Alias = attributes.obj2Alias || {};

      this.alias2Obj = {}; // this gets built in the .importJoins()
      // { "alias" : object.id }
      // this is a lookup hash of a referenced alias to the Object it
      // references.

      this.objectIDs = [];
      // {array}  of ABObject.id s that are referenced by this query.
      // this is how we limit our searches on objects.
      // this gets built in the .importJoins();

      this.viewName = attributes.viewName || "";
      // {string}
      // this is the SQL tablename of where our Query will store it's
      // view data.

      // import all our ABObjects
      this.importJoins(attributes.joins || {});

      // import fields after joins are imported
      this._fields = null;
      this.importFields(attributes.fields || []);
      // {array} [ { alias, field}, {},... ]
      // an array of field definition structures that mark what fields this
      // query is interested in pulling data from.
      //    .alias : {string} matches the alias of the ABObject that the field
      //             is from
      //    .field : {ABFieldXXX} the link to the actual ABField instance

      // Import our Where condition
      this.where = attributes.where || {}; // .workspaceFilterConditions
      // Fix default where.glue value
      if (
         this.where &&
         !this.where.glue &&
         this.where.rules &&
         this.where.rules.length > 0
      )
         this.where.glue = "and";

      this._objectWorkspaceViews = attributes.objectWorkspaceViews || {};

      this.settings = this.settings || {};

      if (attributes && attributes.settings) {
         // convert from "0" => true/false
         this.settings.grouping = JSON.parse(
            attributes.settings.grouping || false
         );
         this.settings.hidePrefix = JSON.parse(
            attributes.settings.hidePrefix || false
         );
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.viewName = this.viewName;

      result.joins = this.exportJoins();
      result.fields = this.exportFields();
      result.where = this.where; // .workspaceFilterConditions

      result.settings = this.settings;

      return result;
   }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    *					{ }
    */
   importFields(fieldSettings) {
      var newFields = [];
      (fieldSettings || []).forEach((fieldInfo) => {
         if (fieldInfo == null) return;

         // pull object by alias name
         let object = this.objectByAlias(fieldInfo.alias);

         // Pull object from .AB
         if (!object && this.AB) {
            object = this.AB.objectByID(fieldInfo.objectID);

            // keep
            if (object) {
               this._objects = this._objects || {};
               this._objects[fieldInfo.alias] = object;
            }
         }

         if (!object) {
            this.emit(
               "warning",
               `IMPORT FIELDS: could not resolve object[${
                  fieldInfo.objectID
               }] for fieldSetting ${JSON.stringify(fieldInfo)}`,
               {
                  fieldInfo,
               }
            );
            return;
         }

         let field = object.fieldByID(fieldInfo.fieldID);
         if (!field) {
            this.emit(
               "warning",
               `IMPORT FIELDS: Object[${object.id}] could not find field[${
                  fieldInfo.fieldID
               }] for fieldSetting ${JSON.stringify(fieldInfo)}`,
               {
                  object: object.toObj(),
                  fieldInfo,
               }
            );
            return;
         }

         if (!this.canFilterField(field)) {
            this.emit(
               "warning",
               `Field[${field.id}] referenced in fieldSetting[${JSON.stringify(
                  fieldInfo
               )}] did not pass .canFilterField`,
               {
                  field: field.toObj(),
                  fieldInfo,
               }
            );
         }

         // check duplicate
         let isNew =
            newFields.filter(
               (f) =>
                  f.alias == fieldInfo.alias && f.field.id == fieldInfo.fieldID
            ).length < 1;

         if (!isNew) {
            this.emit(
               "warning",
               `Field[${
                  fieldInfo.fieldID
               }] referenced in fieldSetting[${JSON.stringify(
                  fieldInfo
               )}] is a duplicate`,
               {
                  field: field.toObj(),
                  fieldInfo,
               }
            );
         }

         // should be a field of base/join objects
         if (field && this.canFilterField(field) && isNew) {
            // add alias to field
            // create new instance of this field:
            var def = field.toObj();
            let clonedField = new field.constructor(def, field.object);

            clonedField.alias = fieldInfo.alias;

            let alias = fieldInfo.alias;
            if (Array.isArray(this.joins())) {
               // NOTE: query v1
               alias = field.object.name;
            }

            newFields.push({
               alias: alias,
               field: clonedField,
            });
         }
      });
      this._fields = newFields;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   exportFields() {
      var currFields = [];
      this._fields.forEach((fieldInfo) => {
         currFields.push({
            alias: fieldInfo.alias,
            objectID: fieldInfo.field.object.id,
            fieldID: fieldInfo.field.id,
         });
      });
      return currFields;
   }

   /**
    * @method fields()
    *
    * Support the ABObject api by returning a list of fields relevant
    * to this ABObjectQuery.
    *
    * @return {array}
    */
   fields(fn = () => true) {
      if (!fn) fn = () => true;
      return this._fields.map((f) => f.field).filter(fn);
   }

   ///
   /// Joins & Objects
   ///

   /**
    * @method joins()
    *
    * return an object of joins for this Query.
    *
    * @return {Object}
    */
   joins() {
      return this._joins || {};
   }

   /**
    * @method objects()
    *
    * return an array of all the relevant ABObjects for this Query.
    *
    * @return {array}
    */
   objects(fn = () => true) {
      // FOR proper expected operation, this fn must only return object
      // matches for which this ABQuery is managing objects:

      return this.AB.objects((o) => this.objectIDs.indexOf(o.id) > -1).filter(
         fn
      );
   }

   /**
    * @method objectAlias()
    *
    * return alias of of ABObjects.
    *
    * @return {string}
    */
   objectAlias(objectId) {
      let result = null;

      Object.keys(this.alias2Obj || {}).forEach((alias) => {
         if (!result && this.alias2Obj[alias] == objectId) {
            result = alias;
         }
      });

      return result;
   }

   /**
    * @method objectBase
    * return the origin object
    *
    * @return {ABObject}
    */
   objectBase() {
      if (!this._joins.objectID) return null;

      return this.AB.objectByID(this._joins.objectID) || null;
   }

   /**
    * @method objectByAlias()
    * return ABObject search by alias name
    *
    * @param {string} - alias name
    * @return {ABClassObject}
    */
   objectByAlias(alias) {
      var objID = this.alias2Obj[alias];
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method objectByID()
    * return ABObject search by ID
    * @param {string} objID
    *        The requested {ABObject}.id of the object to return.
    * @return {ABObject} | null
    */
   objectByID(objID) {
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method links()
    *
    * return an array of links for this Query.
    *
    * @return {array}
    */
   links(filter = () => true) {
      return (this._links || []).filter(filter);
   }

   /**
    * @method importJoins
    * instantiate a set of joins from the given attributes.
    * Our joins contain a set of ABObject URLs that should already be created in our Application.
    * @param {Object} settings The different field urls for each field
    *					{ }
    */
   importJoins(settings) {
      // copy join settings
      this._joins = this.AB.cloneDeep(settings);

      var uniqueObjectIDs = {};
      // { obj.id : obj.id }
      // a hash of object.ids for all the relevant ABObjects necessary for this
      // ABObjectQuery

      var newLinks = [];
      // {array} of link definitions
      // build the operating values for this._links

      let storeObject = (object, alias) => {
         if (!object) return;

         // var inThere = newObjects.filter(obj => obj.id == object.id && obj.alias == alias ).length > 0;
         // if (!inThere) {
         // newObjects[alias] = object;
         // this.obj2Alias[object.id] = alias;
         this.alias2Obj[alias] = object.id;
         uniqueObjectIDs[object.id] = object.id;
         // newObjects.push({
         // 	alias: alias,
         // 	object: object
         // });
         // }
      };

      let storeLinks = (links) => {
         (links || []).forEach((link) => {
            // var inThere = newLinks.filter(l => l.fieldID == link.fieldID).length > 0;
            // if (!inThere) {
            newLinks.push(link);
            // }
         });
      };

      let processJoin = (baseObject, joins) => {
         if (!baseObject) return;

         (joins || []).forEach((link) => {
            // Convert our saved settings:
            //	{
            //		alias: "",							// the alias name of table - use in SQL command
            //		objectID: "uuid",					// id of the connection object
            //		links: [
            //			{
            //				alias: "",							// the alias name of table - use in SQL command
            //				fieldID: "uuid",					// uhe connection field of the object we are joining with.
            //				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
            //						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
            //				links: [
            //					...
            //				]
            //			}
            //		]
            //	},

            var linkField = baseObject.fieldByID(link.fieldID);
            if (!linkField) {
               this.emit("warning", "could not resolve our linkField", {
                  link,
               });
               return;
            }

            // track our linked object
            var linkObject = this.AB.objectByID(linkField.settings.linkObject);
            if (!linkObject) {
               this.emit(
                  "warning",
                  "could not resolve our linked field -> linkObject",
                  {
                     link,
                  }
               );
               return;
            }

            storeObject(linkObject, link.alias);

            storeLinks(link.links);

            processJoin(linkObject, link.links);
         });
      };

      // if (!this._joins.objectURL)
      // 	// TODO: this is old query version
      // 	return;

      // store the root object
      var rootObject = this.objectBase();
      if (!rootObject) {
         // this._objects = newObjects;
         this.emit("warning", "could not resolve our base object", {
            objectID: this._joins?.objectID,
         });
         return;
      }

      storeObject(rootObject, "BASE_OBJECT");

      storeLinks(settings.links);

      processJoin(rootObject, settings.links);

      // this._objects = newObjects;
      this._links = newLinks;
      this.objectIDs = Object.keys(uniqueObjectIDs);
   }

   /**
    * @method exportJoins
    * save our list of objects into our format for persisting on the server
    * @param {array} settings
    */
   exportJoins() {
      return this.AB.cloneDeep(this._joins || {});
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new ABModelQuery(this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @method canFilterObject
    * evaluate the provided object to see if it can directly be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterObject(object) {
      if (!object) return false;

      // I can filter this object if it is one of the objects in my joins
      return (
         this.objects((obj) => {
            return obj.id == object.id;
         }).length > 0
      );
   }

   /**
    * @method canFilterField
    * evaluate the provided field to see if it can be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterField(field) {
      if (!field) return false;

      // I can filter a field if it's object OR the object it links to can be filtered:
      let object = field.object;
      // Transition:
      // let linkedObject = this.objects(
      //    (obj) => obj.id == field.settings.linkObject
      // )[0];
      var linkedObject = field.datasourceLink;

      return this.canFilterObject(object) || this.canFilterObject(linkedObject);
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.AB.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error(
         "ABQueryCore.urlPointer(): Depreciated: Where is this being called?"
      );
      return this.application.urlQuery(acrossApp) + this.id;
   }

   /**
    * @method isGroup
    *
    * @return {boolean}
    */
   get isGroup() {
      return this.settings.grouping || false;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return true;
   }

   /**
    * @method isDisabled()
    * check this contains removed objects or fields
    *
    * @return {boolean}
    */
   isDisabled() {
      return this.disabled || false;
   }

   get workspaceFilterConditions() {
      let filterConditions = super.workspaceFilterConditions;
      if (
         filterConditions == null ||
         filterConditions.rules == null ||
         !filterConditions.rules.length
      ) {
         filterConditions = this.where;
      }

      return filterConditions;
   }
};


/***/ }),

/***/ 99183:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABProcessCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"

var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 97069);
const _concat = __webpack_require__(/*! lodash/concat */ 57043);

module.exports = class ABProcessCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process";
      this.xmlDefinition = attributes.xmlDefinition || null;

      // this.json = attributes.json || null;
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         var ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         }
      });

      this._connections = attributes.connections || {};

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "xmlDefinition"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      data.elementIDs = [];
      for (var e in this._elements) {
         data.elementIDs.push(this._elements[e].id);
      }

      data.connections = this._connections;

      // data.participantIDs = [];
      // for (var p in this._participants) {
      //     data.participantIDs.push(this._participants[p].id);
      // }

      return data;
   }

   //
   // XML Model
   //

   /**
    * modelDefinition()
    * return the current xml definition for this process
    * @return {string}
    */
   modelDefinition() {
      return this.xmlDefinition;
   }

   /**
    * modelNew()
    * initialze our xml definition to a new state.
    * @return {string}
    */
   modelNew() {
      this.xmlDefinition = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="process-def-${this.id}" targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn2:process id="Process_1" isExecutable="true">
    <bpmn2:startEvent id="StartEvent_1"/>
  </bpmn2:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn2:definitions>`;

      //// TODO: create a default Start Task here??
   }

   /**
    * modelUpdate()
    * update our xml definition from the provided description.
    * @param {string} xml  bpmn2 xml definition from our modeler.
    * @return {string}
    */
   modelUpdate(xml) {
      this.xmlDefinition = xml;
   }

   //
   // Diagram Elements
   //

   /**
    * connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn) {
      if (!fn)
         fn = () => {
            return true;
         };
      var allConnections = Object.keys(this._connections).map((e) => {
         return this._connections[e];
      });
      return allConnections.filter(fn);
   }

   /**
    * connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      return this.connections((t) => {
         return t.id == dID;
      })[0];
   }

   /**
    * connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      return this.connections((c) => {
         return c.to == dID;
      });
   }

   /**
    * connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      return this.connections((c) => {
         return c.from == dID;
      });
   }

   /**
    * connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      delete this._connections[element.id];
   }

   /**
    * connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      var bo = element.businessObject;
      var from = null;
      if (bo.sourceRef) {
         from = bo.sourceRef.id;
      }

      var to = null;
      if (bo.targetRef) {
         to = bo.targetRef.id;
      }

      var connection = {
         id: element.id,
         type: element.type,
         from: from,
         to: to,
      };
      return connection;
   }

   /**
    * connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      var simpleConn = this.connectionSimplyElement(element);
      if (simpleConn.from && simpleConn.to) {
         this._connections[simpleConn.id] = simpleConn;
      } else {
         // this connection is no longer connecting anything thing.
         // it is being removed.
         this.connectionRemove(element);
      }
   }

   /**
    * elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      var allElements = Object.keys(this._elements).map((e) => {
         return this._elements[e];
      });
      return allElements.filter(fn);
   }

   /**
    * elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      this._elements[element.id || element.diagramID] = element;
   }

   /**
    * elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      return this.elements((t) => {
         return t.diagramID == dID;
      })[0];
   }

   /**
    * elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      delete this._elements[def.id || def.diagramID];
   }

   /**
    * isTriggeredBy()
    * scan our tasks and see if we have a "trigger" task that responds to
    * the provided key.
    * @param {string} key the trigger key
    * @return {bool}
    */
   isTriggeredBy(key) {
      return this.taskForTriggerKey(key) != null;
   }

   /**
    * connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      var elements = [];
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      prevConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.from;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      return values.length > 0
         ? values.length > 1
            ? values
            : values[0]
         : null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataFields",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataObjects(currElement) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataObjects",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * taskForTriggerKey()
    * return one or more tasks that respond to the given trigger key
    * @param {string} key a trigger key
    * @return {[ABProcessTask,...]}
    */
   taskForTriggerKey(key) {
      var trigger = this.elements((t) => {
         return t.triggerKey == key;
      })[0];
      if (trigger) {
         return trigger;
      } else {
         return null;
      }
   }

   //
   // Participants
   //

   // /**
   //  * participants()
   //  * return an array of participants that match the given filter (or all tasks
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided participants
   //  *                should be returned.
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participants(fn) {
   //     if (!fn)
   //         fn = () => {
   //             return true;
   //         };
   //     var all = Object.keys(this._participants).map((p) => {
   //         return this._participants[p];
   //     });
   //     return all.filter(fn);
   // }

   // /**
   //  * participantsForDiagramID()
   //  * return the participant(s) that are tied to the given xml diagram ID.
   //  * @param {string} dID the diagram ID
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participantsForDiagramID(dID) {
   //     return this.participants((p) => {
   //         return p.diagramID == dID;
   //     });
   // }
};

var queryPreviousTasks = (
   list,
   method,
   param,
   process,
   responses,
   processedIDs
) => {
   // recursive fn() to step through our graph and compile
   // results.
   if (typeof responses == "undefined") {
      responses = [];
   }
   if (typeof processedIDs == "undefined") {
      processedIDs = [];
   }
   if (list.length == 0) {
      return responses;
   } else {
      // get next task
      var task = list.shift();

      // if we haven't already done task:
      if (processedIDs.indexOf(task.diagramID) == -1) {
         // mark this task as having been processed
         processedIDs.push(task.diagramID);

         // get any field's it provides
         var value = task[method].apply(task, param);
         if (value === null) value = [];
         responses = _concat(responses, value);

         // add any previous tasks to our list
         list = _concat(list, process.connectionPreviousTask(task));
      }

      // process next Task
      return queryPreviousTasks(
         list,
         method,
         param,
         process,
         responses,
         processedIDs
      );
   }
};


/***/ }),

/***/ 15753:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABViewManagerCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewManager
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

var AllViews = [
   __webpack_require__(/*! ../platform/views/ABView */ 10902),
   __webpack_require__(/*! ../platform/views/ABViewCarousel */ 21051),
   __webpack_require__(/*! ../platform/views/ABViewChart */ 67373),
   __webpack_require__(/*! ../platform/views/ABViewChartArea */ 17924),
   __webpack_require__(/*! ../platform/views/ABViewChartBar */ 51939),
   __webpack_require__(/*! ../platform/views/ABViewChartLine */ 71967),
   __webpack_require__(/*! ../platform/views/ABViewChartPie */ 98104),
   __webpack_require__(/*! ../platform/views/ABViewComment */ 1404),
   __webpack_require__(/*! ../platform/views/ABViewConditionalContainer */ 88016),
   __webpack_require__(/*! ../platform/views/ABViewConnectDataFilter */ 19199),
   __webpack_require__(/*! ../platform/views/ABViewContainer */ 32715),
   __webpack_require__(/*! ../platform/views/ABViewCSVExporter */ 4818),
   __webpack_require__(/*! ../platform/views/ABViewCSVImporter */ 92471),
   __webpack_require__(/*! ../platform/views/ABViewDataview */ 64411),
   __webpack_require__(/*! ../platform/views/ABViewDocxBuilder */ 4804),
   __webpack_require__(/*! ../platform/views/ABViewGrid */ 58052),
   __webpack_require__(/*! ../platform/views/ABViewImage */ 38446),
   __webpack_require__(/*! ../platform/views/ABViewLabel */ 76145),
   __webpack_require__(/*! ../platform/views/ABViewLayout */ 6541),
   __webpack_require__(/*! ../platform/views/ABViewList */ 59285),
   __webpack_require__(/*! ../platform/views/ABViewMenu */ 37726),
   __webpack_require__(/*! ../platform/views/ABViewPage */ 26239),
   __webpack_require__(/*! ../platform/views/ABViewPivot */ 71227),
   __webpack_require__(/*! ../platform/views/ABViewTab */ 12235),
   __webpack_require__(/*! ../platform/views/ABViewText */ 9403),

   //
   // Special Editors
   //
   __webpack_require__(/*! ../platform/views/ABViewGantt */ 59136),
   __webpack_require__(/*! ../platform/views/ABViewKanban */ 99258),
   __webpack_require__(/*! ../platform/views/ABViewReportsManager */ 41226),

   //
   // Detail Components
   //
   __webpack_require__(/*! ../platform/views/ABViewDetail */ 80414),
   __webpack_require__(/*! ../platform/views/ABViewDetailCheckbox */ 8990),
   __webpack_require__(/*! ../platform/views/ABViewDetailConnect */ 77855),
   __webpack_require__(/*! ../platform/views/ABViewDetailCustom */ 92885),
   __webpack_require__(/*! ../platform/views/ABViewDetailImage */ 69903),
   // require("../platform/views/ABViewDetailSelectivity"),
   __webpack_require__(/*! ../platform/views/ABViewDetailText */ 82011),
   __webpack_require__(/*! ../platform/views/ABViewDetailTree */ 73216),

   //
   // Form Components
   //
   __webpack_require__(/*! ../platform/views/ABViewForm */ 70704),
   __webpack_require__(/*! ../platform/views/ABViewFormButton */ 15651),
   __webpack_require__(/*! ../platform/views/ABViewFormCheckbox */ 56339),
   __webpack_require__(/*! ../platform/views/ABViewFormConnect */ 46311),
   __webpack_require__(/*! ../platform/views/ABViewFormCustom */ 79662),
   __webpack_require__(/*! ../platform/views/ABViewFormDatepicker */ 16816),
   __webpack_require__(/*! ../platform/views/ABViewFormNumber */ 87856),
   __webpack_require__(/*! ../platform/views/ABViewFormReadonly */ 62941),
   __webpack_require__(/*! ../platform/views/ABViewFormSelectMultiple */ 38386),
   __webpack_require__(/*! ../platform/views/ABViewFormSelectSingle */ 26114),
   __webpack_require__(/*! ../platform/views/ABViewFormTextbox */ 48167),
   __webpack_require__(/*! ../platform/views/ABViewFormTree */ 56222),
];

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
AllViews.forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

module.exports = class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            console.error(
               "!! View[" +
                  values.key +
                  "] not yet defined.  Have an ABView instead:"
            );
            return new Views["view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }
};


/***/ }),

/***/ 50353:
/*!**********************************************!*\
  !*** ./AppBuilder/core/FilterComplexCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 8030);
// const ABObjectQuery = require("../platform/ABObjectQuery");

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field) {
   if (!field) return null;
   if (!field.columnName) return null;
   var columnName = field.columnName;

   var value = null;
   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName];
   } else {
      value = rowData[columnName];
   }

   if (typeof value != "undefined") {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (var k in rowData) {
      var key = k.split(".")[1];
      if (key && key == field.id) {
         value = rowData[k];
      }
   }
   return value;
}

function getConnectFieldValue(rowData, field) {
   let connectedVal = "";

   if (rowData) {
      let relationName = field.relationName();
      if (rowData[relationName]) {
         connectedVal =
            (field.indexField
               ? rowData[relationName][field.indexField.columnName]
               : null) ?? // custom index
            (field.indexField2
               ? rowData[relationName][field.indexField2.columnName]
               : null) ?? // custom index 2
            rowData[relationName].id ??
            rowData[relationName];
      } else {
         let fieldVal = getFieldVal(rowData, field);
         if (fieldVal != null) {
            connectedVal = fieldVal;
         }
      }
   }
   return connectedVal;
}

module.exports = class FilterComplexCore extends ABComponent {
   constructor(idBase, AB) {
      idBase = idBase || "ab_filter_complex";

      if (typeof AB === "undefined") {
         console.error("FilterComplexCore(): being called without an AB!");
      }

      super(null, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.condition = {};
      // var batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         removeHtmlTags: function (text) {
            var div = document.createElement("div");
            div.innerHTML = text;

            return div.textContent || div.innerText || "";
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options) {
      if (options?.showObjectName) {
         this._settings.showObjectName = options.showObjectName;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      var condition = this.condition;
      var _logic = this._logic;

      // If no conditions, then return true
      if (
         condition == null ||
         condition.rules == null ||
         condition.rules.length == 0
      )
         return true;

      if (rowData == null) return false;

      var result = condition.glue === "and" ? true : false;

      condition.rules.forEach((filter) => {
         if (!filter.key || !filter.rule) return;

         var fieldInfo = (this._Fields || []).filter(
            (f) => f.id == filter.key
         )[0];
         if (!fieldInfo) return;

         var condResult;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         var ruleFieldType = fieldInfo.key;
         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }
         let value;

         if (fieldInfo.relationName) {
            value = getConnectFieldValue(rowData, fieldInfo);
         } else {
            value = getFieldVal(rowData, fieldInfo);
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               if (value == null) value = "";

               condResult = this.textValid(value, filter.rule, filter.value);
               break;
            case "date":
            case "datetime":
               condResult = this.dateValid(value, filter.rule, filter.value);
               break;
            case "number":
               condResult = this.numberValid(value, filter.rule, filter.value);
               break;
            case "list":
               condResult = this.listValid(value, filter.rule, filter.value);
               break;
            case "boolean":
               condResult = this.booleanValid(value, filter.rule, filter.value);
               break;
            case "user":
               condResult = this.userValid(value, filter.rule, filter.value);
               break;
            case "connectField":
            case "connectObject":
               condResult = this.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = _logic.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (condition.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   textValid(value, rule, compareValue) {
      var result = false;

      value = value.trim().toLowerCase();
      value = this._logic.removeHtmlTags(value); // remove html tags - rich text editor

      compareValue = compareValue.trim().toLowerCase().replace(/  +/g, " ");

      // support "john smith" => "john" OR/AND "smith"
      var compareArray = compareValue.split(" ");

      switch (rule) {
         case "contains":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value.indexOf(val) > -1;
            });
            break;
         case "not_contains":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value.indexOf(val) < 0;
            });
            break;
         case "equals":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value == val;
            });
            break;
         case "not_equal":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value != val;
            });
            break;
         case "is_empty":
            result = value == "" || value == null;
            break;
         case "is_not_empty":
            result = value != "" && value != null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   dateValid(value, rule, compareValue) {
      var result = false;

      if (!(value instanceof Date)) value = new Date(value);

      if (!(compareValue instanceof Date))
         compareValue = new Date(compareValue);

      switch (rule) {
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   numberValid(value, rule, compareValue) {
      var result = false;

      value = Number(value);
      compareValue = Number(compareValue);

      switch (rule) {
         case "equals":
            result = value == compareValue;
            break;
         case "not_equal":
            result = value != compareValue;
            break;
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   listValid(value, rule, compareValue) {
      var result = false;

      // compareValue = compareValue.toLowerCase();

      if (!Array.isArray(compareValue)) compareValue = [compareValue];

      switch (rule) {
         case "equals":
            if (value) result = compareValue.indexOf(value) > -1;
            break;
         case "not_equal":
            if (value) result = compareValue.indexOf(value) < 0;
            else result = true;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   booleanValid(value, rule, compareValue) {
      var result = false;

      switch (rule) {
         case "equals":
            result = value == compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   userValid(value, rule, compareValue) {
      if (!value) return false;
      var result = false;

      // if (Array.isArray(value)) value = [value];

      switch (rule) {
         case "is_current_user":
            result = value == this.Account.username;
            break;
         case "is_not_current_user":
            result = value != this.Account.username;
            break;
         case "contain_current_user":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == this.Account.username)
                  .length > 0;
            break;
         case "not_contain_current_user":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == this.Account.username)
                  .length < 1;
            break;
         case "equals":
            result = value.indexOf(compareValue) > -1;
            break;
         case "not_equal":
            result = value.indexOf(compareValue) < 0;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   queryFieldValid(rowData, rule, compareValue) {
      var result = false;

      if (!compareValue) return result;

      // queryId:fieldId
      var queryId = compareValue.split(":")[0],
         fieldId = compareValue.split(":")[1];

      // if no query
      var query = this.AB.queries((q) => q.id == queryId)[0];
      if (!query) return result;

      // if no field
      var field = query.fields((f) => f.id == fieldId)[0];
      if (!field) return result;

      let qIdBase = "{idBase}-query-field-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFieldFilter = new this.constructor(qIdBase, this.AB);
      inQueryFieldFilter.Account = this.Account;
      inQueryFieldFilter.fieldsLoad(query.fields());
      inQueryFieldFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query_field":
            result = inQueryFieldFilter.isValid(rowData);
            break;
         case "not_in_query_field":
            result = !inQueryFieldFilter.isValid(rowData);
            break;
      }

      return result;
   }

   inQueryValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue || !this.AB) return result;

      // if no query
      let query = this.AB.queries((q) => q.id == compareValue)[0];
      if (!query) return result;

      let qIdBase = "{idBase}-query-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFilter = new this.constructor(qIdBase, this.AB);
      inQueryFilter.Account = this.Account;
      inQueryFilter.fieldsLoad(query.fields());
      inQueryFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query":
            result = inQueryFilter.isValid(rowData);
            break;
         case "not_in_query":
            result = !inQueryFilter.isValid(rowData);
            break;
      }

      return result;
   }

   dataCollectionValid(value, rule, compareValue) {
      var result = false;

      if (!compareValue) return result;

      let dc = this.AB.datacollections((d) => d.id == compareValue)[0];

      switch (rule) {
         case "in_data_collection":
            if (!dc) return false;

            result = dc.getData((d) => d.id == value.id).length > 0;
            break;
         case "not_in_data_collection":
            if (!dc) return true;

            result = dc.getData((d) => d.id == value.id).length < 1;
            break;
      }

      return result;
   }

   connectFieldValid(rowData, field, rule, compareValue) {
      let relationName = field.relationName();

      let connectedVal = "";

      if (rowData) {
         if (rowData[relationName]) {
            connectedVal = (
               (field.indexField
                  ? rowData[relationName][field.indexField.columnName]
                  : null) ?? // custom index
               (field.indexField2
                  ? rowData[relationName][field.indexField2.columnName]
                  : null) ?? // custom index 2
               rowData[relationName].id ??
               rowData[relationName]
            )
               .toString()
               .toLowerCase();
         } else {
            let fieldVal = getFieldVal(rowData, field);
            if (fieldVal != null) {
               connectedVal = fieldVal;
            }
         }
      }

      let compareValueLowercase = (compareValue || "").toLowerCase();

      switch (rule) {
         case "contains":
            return connectedVal.toString().indexOf(compareValueLowercase) > -1;
         case "not_contains":
            return connectedVal.toString().indexOf(compareValueLowercase) == -1;
         case "equals":
            return connectedVal == compareValueLowercase;
         case "not_equal":
            return connectedVal != compareValueLowercase;
         case "in_query":
         case "not_in_query":
            return this.inQueryValid(rowData[relationName], rule, compareValue);
         case "is_current_user":
         case "is_not_current_user":
         case "contain_current_user":
         case "not_contain_current_user":
            return this.userValid(connectedVal, rule, compareValue);
         case "is_empty":
            return (
               rowData[relationName] == null ||
               rowData[relationName].length < 1 ||
               rowData[relationName] == ""
            );
         case "is_not_empty":
            return (
               rowData[relationName] != null &&
               ((Array.isArray(rowData[relationName]) &&
                  rowData[relationName].length > 0) ||
                  rowData[relationName] != "")
            );
         case "in_data_collection":
         case "not_in_data_collection":
            return this.dataCollectionValid(connectedVal, rule, compareValue);
      }
   }

   thisObjectValid(rowData, rule, compareValue) {
      let result = false;

      switch (rule) {
         // if in_query condition
         case "in_query":
         case "not_in_query":
            if (!this._Object) return result;

            // if > 1 copy of this object in query ==> Error!
            let query = this.AB.queries((q) => q.id == compareValue)[0];
            if (!query) return result;

            var listThisObjects = query.objects((o) => {
               return o.id == this._Object.id;
            });
            if (listThisObjects.length > 1) {
               // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
               // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
               // this object as part of the query.

               console.error(
                  "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
               );
               return true;
            }

            // get this object's alias from the query
            var alias = query.objectAlias(this._Object.id);

            // make sure all my columns in rowData are prefixed by "alias".columnName
            var newRowData = {};
            Object.keys(rowData).forEach((key) => {
               newRowData[`${alias}.${key}`] = rowData[key];
            });

            // then pass this on to the _logic.queryValid();
            return this.inQueryValid(newRowData, rule, compareValue);

         // if in_datacollection condition
         case "in_data_collection":
         case "not_in_data_collection":
            // send rowData, null to datacollectionValid()
            return this.dataCollectionValid(rowData, rule, compareValue);
      }
   }

   processFieldsLoad(processFields = []) {
      if (processFields && !Array.isArray(processFields)) {
         processFields = [processFields];
      }
      this._ProcessFields = processFields;

      this.uiInit();
   }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param array {ABField}
    * @param object {ABObject} [optional]
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter(
         (f) => f && f.fieldIsFilterable && f.fieldIsFilterable()
      );
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         // insert our uuid in addition to the rest of our fields
         let thisObjOption = {
            id: "this_object",
            label: object.label,
            key: "uuid",
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         // NOTE: Could not reference ABObjectQuery because recursive looping reference
         // if (object instanceof ABObjectQuery) {
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   fieldsToQB() {
      /*
      let mapTypes = {
         LongText: "string",
         email: "string",
         datetime: "date",
         connectField: "connectObject"
      };

      var fields = this._Fields.map((f) => {
         // Label
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         // Type
         let type = f.key || f.type;
         if (mapTypes[type]) type = mapTypes[type];

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return { id: f.columnName, value: label, type: type };
      });
      return fields;
      */

      let fields = (this._Fields || []).map((f) => {
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         let type = "text"; // "text", "number", "date"
         let conditions = [];
         switch (f.key) {
            case "boolean":
               conditions = conditions
                  .concat(this.fieldsAddFiltersBoolean(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "connectObject":
               conditions = this.fieldsAddFiltersQuery(f);
               break;
            case "date":
            case "datetime":
               type = "date";
               conditions = conditions
                  .concat(this.fieldsAddFiltersDate(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "calculate":
            case "formula":
            case "number":
               type = "number";
               conditions = conditions
                  .concat(this.fieldsAddFiltersNumber(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "string":
            case "LongText":
            case "email":
            case "AutoIndex":
               conditions = conditions
                  .concat(this.fieldsAddFiltersString(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "list":
               conditions = conditions
                  .concat(this.fieldsAddFiltersList(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "user":
               conditions = conditions
                  .concat(this.fieldsAddFiltersUser(f))
                  .concat(this.fieldsAddFiltersQueryField(f));
               break;
            case "uuid":
               conditions = conditions.concat(
                  this.fieldsAddFiltersThisObject(f)
               );
               break;
            default:
               type = "text";
               break;
         }

         if (this._isRecordRule) {
            conditions = conditions.concat(this.fieldsAddFiltersRecordRule(f));
         }

         let isProcessField =
            (this._ProcessFields || []).filter((processField) => {
               if (!processField) return false;

               if (processField.field) {
                  return processField.field.id == f.id;
               } else if (processField.key) {
                  // uuid
                  let processFieldId = processField.key.split(".").pop();
                  return processFieldId == f.id || processFieldId == f.key;
               }
            }).length > 0;

         if (isProcessField) {
            conditions = conditions.concat(this.fieldsAddFiltersContext(f));
         }

         // let type = f.id; // the default unique identifier for our filter types
         // if (f.id == "this_object") {
         //    // if this happens to be our special "this_object" field, then our
         //    // type needs to be the "uuid" type in the definition:
         //    type = f.type;
         // }

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return {
            id: f.columnName || f.id,
            value: label,
            type: type,
            conditions: conditions,
            // format: () => {},
         };
      });

      // !!! Process Fields of ABProcess
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L636
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L564
      // (this._ProcessFields || [])
      //    // if there is no .field, it is probably an embedded special field
      //    .filter((pField) => pField.field == null)
      //    .forEach((pField) => {
      //       // like: .uuid
      //       let key = pField.key.split(".").pop();
      //       if (key == "uuid" && this._Object) {
      //          fields.unshift({
      //             id: pField.key,
      //             value: this._Object.label,
      //             type: "text",
      //             conditions: this.fieldsAddFiltersContext(),
      //          });
      //       }
      //    });

      return fields;
   }

   fieldsAddFiltersDate(field) {
      let dateConditions = {
         less: this.labels.component.beforeCondition,
         greater: this.labels.component.afterCondition,
         less_or_equal: this.labels.component.onOrBeforeCondition,
         greater_or_equal: this.labels.component.onOrAfterCondition,
         less_current: this.labels.component.beforeCurrentCondition,
         greater_current: this.labels.component.afterCurrentCondition,
         less_or_equal_current:
            this.labels.component.onOrBeforeCurrentCondition,
         greater_or_equal_current:
            this.labels.component.onOrAfterCurrentCondition,
         last_days: this.labels.component.onLastDaysCondition,
         next_days: this.labels.component.onNextDaysCondition,
      };

      let result = [];

      for (let condKey in dateConditions) {
         result.push({
            id: condKey,
            value: dateConditions[condKey],
            batch: "datepicker",
            handler: (a, b) => this.dateValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersString(field) {
      let stringConditions = {
         contains: {
            batch: "text",
            label: this.labels.component.containsCondition,
         },
         not_contains: {
            batch: "text",
            label: this.labels.component.notContainsCondition,
         },
         equals: {
            batch: "text",
            label: this.labels.component.isCondition,
         },
         not_equal: {
            batch: "text",
            label: this.labels.component.isNotCondition,
         },
         is_empty: {
            batch: "none",
            label: this.labels.component.isEmpty,
         },
         is_not_empty: {
            batch: "none",
            label: this.labels.component.isNotEmpty,
         },
      };

      let result = [];

      for (let condKey in stringConditions) {
         result.push({
            id: condKey,
            value: stringConditions[condKey].label,
            batch: stringConditions[condKey].batch,
            handler: (a, b) => this.textValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersNumber(field) {
      let numberConditions = {
         equals: this.labels.component.equalCondition,
         not_equal: this.labels.component.notEqualCondition,
         less: this.labels.component.lessThanCondition,
         greater: this.labels.component.moreThanCondition,
         less_or_equal: this.labels.component.lessThanOrEqualCondition,
         greater_or_equal: this.labels.component.moreThanOrEqualCondition,
      };

      let result = [];

      for (let condKey in numberConditions) {
         result.push({
            id: condKey,
            value: numberConditions[condKey],
            batch: "text",
            handler: (a, b) => this.numberValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersList(field) {
      let listConditions = {
         equals: this.labels.component.equalListCondition,
         not_equal: this.labels.component.notEqualListCondition,
      };

      let result = [];

      for (let condKey in listConditions) {
         result.push({
            id: condKey,
            value: listConditions[condKey],
            batch: "list",
            handler: (a, b) => this.listValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersBoolean(field) {
      let booleanConditions = {
         equals: this.labels.component.equalListCondition,
      };

      let result = [];

      for (let condKey in booleanConditions) {
         result.push({
            id: condKey,
            value: booleanConditions[condKey],
            batch: "boolean",
            handler: (a, b) => this.booleanValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersUser(field) {
      let userConditions = {
         is_current_user: {
            batch: "none",
            label: this.labels.component.isCurrentUserCondition,
         },
         is_not_current_user: {
            batch: "none",
            label: this.labels.component.isNotCurrentUserCondition,
         },
         contain_current_user: {
            batch: "none",
            label: this.labels.component.containsCurrentUserCondition,
         },
         not_contain_current_user: {
            batch: "none",
            label: this.labels.component.notContainsCurrentUserCondition,
         },
         equals: {
            batch: "user",
            label: this.labels.component.equalListCondition,
         },
         not_equal: {
            batch: "user",
            label: this.labels.component.notEqualListCondition,
         },
      };

      let result = [];

      for (let condKey in userConditions) {
         result.push({
            id: condKey,
            value: userConditions[condKey].label,
            batch: userConditions[condKey].batch,
            handler: (a, b) => this.userValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersQuery(field) {
      let connectConditions = {
         in_query: {
            batch: "query",
            label: this.labels.component.inQuery,
            handler: (a, b) => this.inQueryValid(a, "in_query", b),
         },
         not_in_query: {
            batch: "query",
            label: this.labels.component.notInQuery,
            handler: (a, b) => this.inQueryValid(a, "not_in_query", b),
         },
         same_as_user: {
            batch: "user",
            label: this.labels.component.sameAsUser,
            handler: (a, b) => this.userValid(a, "same_as_user", b),
         },
         not_same_as_user: {
            batch: "user",
            label: this.labels.component.notSameAsUser,
            handler: (a, b) => this.userValid(a, "not_same_as_user", b),
         },
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "in_data_collection", b),
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "not_in_data_collection", b),
         },
         // TODO
         // contains: this.labels.component.containsCondition,
         // not_contains: this.labels.component.notContainCondition,
         // equals: this.labels.component.isCondition,
         // not_equal: this.labels.component.isNotCondition
      };

      let result = [];

      for (let condKey in connectConditions) {
         result.push({
            id: condKey,
            value: connectConditions[condKey].label,
            batch: connectConditions[condKey].batch,
            handler: connectConditions[condKey].handler,
         });
      }

      // Add filter options to Custom index
      if (
         field.settings.isCustomFK &&
         // 1:M
         ((field.settings.linkType == "one" &&
            field.settings.linkViaType == "many") ||
            // 1:1 isSource = true
            (field.settings.linkType == "one" &&
               field.settings.linkViaType == "one" &&
               field.settings.isSource))
      ) {
         const stringResults = this.fieldsAddFiltersString(field);
         result = stringResults.concat(result);
      }

      return result;
   }

   fieldsAddFiltersQueryField(field) {
      let queryFieldConditions = {
         in_query_field: this.labels.component.inQueryField,
         not_in_query_field: this.labels.component.notInQueryField,
      };

      let result = [];

      for (let condKey in queryFieldConditions) {
         result.push({
            id: condKey,
            value: queryFieldConditions[condKey],
            batch: "queryField",
            handler: (a, b) => this.queryFieldValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersThisObject(field) {
      let thisObjectConditions = {
         in_query: {
            batch: "query",
            label: this.labels.component.inQuery,
         },
         not_in_query: {
            batch: "query",
            label: this.labels.component.notInQuery,
         },
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
         },
      };

      let result = [];

      for (let condKey in thisObjectConditions) {
         result.push({
            id: condKey,
            value: thisObjectConditions[condKey].label,
            batch: thisObjectConditions[condKey].batch,
            handler: (a, b) => this.thisObjectValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersRecordRule(field) {
      let recordRuleConditions = {
         same_as_field: this.labels.component.sameAsField,
         not_same_as_field: this.labels.component.notSameAsField,
      };

      let result = [];

      for (let condKey in recordRuleConditions) {
         result.push({
            id: condKey,
            value: recordRuleConditions[condKey],
            batch: "recordRule",
            handler: (a, b) => true, // TODO: record rule validation
         });
      }

      return result;
   }

   fieldsAddFiltersContext(field) {
      let contextConditions = {
         context_equals: {
            batch: "context",
            label: this.labels.component.equalsProcessValue,
            handler: (a, b) => a == b,
         },
         context_not_equal: {
            batch: "context",
            label: this.labels.component.notEqualsProcessValueCondition,
            handler: (a, b) => a != b,
         },
         context_in: {
            batch: "context",
            label: this.labels.component.inProcessValueCondition,
            handler: (a, b) => a.indexOf(b) > -1,
         },
         context_not_in: {
            batch: "context",
            label: this.labels.component.notInProcessValueCondition,
            handler: (a, b) => a.indexOf(b) == -1,
         },
      };

      let result = [];

      for (let condKey in contextConditions) {
         result.push({
            id: condKey,
            value: contextConditions[condKey].label,
            batch: contextConditions[condKey].batch,
            handler: contextConditions[condKey].handler,
         });
      }

      return result;
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    *
    * return an array of all the ABObjectQuery.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   queries(filter = () => true) {
      const queryList = this._Queries ?? this.AB?.queries?.() ?? [];

      return queryList.filter((q) => filter(q));
   }

   setValue(settings) {
      this.condition = settings || {};

      this.condition.rules = this.condition.rules || [];
   }

   /**
    * @method getValue
    * return the current condition of the filter.
    * @return {JSON} -
    * {
    * 	glue: '', // 'and', 'or'
    *		rules: [
    *			{
    *				key:	'uuid',
    *				rule:	'rule',
    *				value:	'value'
    *			}
    *		]
    * }
    */
   getValue() {
      // When asked for a value before a condition is set, default the
      // unset glue to "and";
      if (typeof this.condition.glue == "undefined") {
         this.condition.glue = "and";
      }
      return this.condition;
   }

   isComplete() {
      let result = true;

      const noValueRules = [
         "is_current_user",
         "is_not_current_user",
         "contain_current_user",
         "not_contain_current_user",
         "same_as_user",
         "not_same_as_user",
      ];

      const isCompleteRules = (rules = []) => {
         if (result == false) return;

         rules.forEach((r) => {
            if (r?.rules && Array.isArray(r?.rules)) {
               isCompleteRules(r?.rules);
            } else {
               result =
                  result &&
                  r?.key != null &&
                  r?.key != "" &&
                  r?.rule != null &&
                  r?.rule != "" &&
                  ((r?.value != null && r?.value != "") ||
                     noValueRules.indexOf(r?.rule) > -1);
            }
         });
      };

      isCompleteRules(this.condition?.rules);

      return result;
   }
};


/***/ }),

/***/ 61584:
/*!******************************************!*\
  !*** ./AppBuilder/core/RowFilterCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 8030);

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field, returnSingular = true) {
   if (!field) return null;
   if (!field.columnName) return null;
   // if rowData is an array, then pull the first element to get value
   if (rowData && rowData[0]) rowData = rowData[0];

   let columnId = field.id;
   let columnName = field.columnName;

   let value = null;
   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName] || rowData[columnId];
   } else {
      value = rowData[columnName] || rowData[columnId];
   }

   if (value) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (var k in rowData) {
      var key = k.split(".")[1];
      if (key && (key == columnId || key == columnName)) {
         value = rowData[k];
      }
   }

   // if value is an array, filter empty item
   if (value && Array.isArray(value)) {
      value = value.filter((v) => v != null);
      if (returnSingular) value = value[0];
   }

   return value;
}

module.exports = class RowFilterCore extends ABComponent {
   constructor(App, idBase, AB) {
      idBase = idBase || "ab_row_filter";

      super(App, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.config_settings = {};
      // var batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         /**
          * @method getValue
          *
          * @return {JSON} -
          * {
          * 		glue: '', // 'and', 'or'
          *		rules: [
          *			{
          *				key:	'column name',
          *				rule:	'rule',
          *				value:	'value'
          *			}
          *		]
          * }
          */
         getValue: () => {
            return this.config_settings;
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },

         textValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value == null) value = "";

            value = value.toString().trim().toLowerCase();
            value = _logic.removeHtmlTags(value); // remove html tags - rich text editor

            compareValue = compareValue
               .toString()
               .trim()
               .toLowerCase()
               .replace(/  +/g, " ");

            // support "john smith" => "john" OR/AND "smith"
            var compareArray = compareValue.split(" ");

            switch (rule) {
               case "contains":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value.indexOf(val) > -1;
                  });
                  break;
               case "not_contains":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value.indexOf(val) < 0;
                  });
                  break;
               case "equals":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value == val;
                  });
                  break;
               case "not_equal":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value != val;
                  });
                  break;
               case "is_empty":
                  result = value == null || value == "";
                  break;
               case "is_not_empty":
                  result = value != null && value != "";
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         dateValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (!(value instanceof Date)) value = new Date(value);

            if (!(compareValue instanceof Date))
               compareValue = new Date(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         numberValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            value = Number(value);
            compareValue = Number(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         listValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value && value.toLowerCase) value = value.toLowerCase();

            compareValue = compareValue.toLowerCase();

            if (!Array.isArray(compareValue)) compareValue = [compareValue];

            switch (rule) {
               case "equals":
                  if (value) result = compareValue.indexOf(value) > -1;
                  break;
               case "not_equal":
                  if (value) result = compareValue.indexOf(value) < 0;
                  else result = true;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         booleanValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);

            // default value should be false
            if (value == null) value = false;

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         userValid: (rowData, field, rule, compareValue) => {
            var result = false;

            var value = getFieldVal(rowData, field);

            // if (Array.isArray(value)) value = [value];

            switch (rule) {
               case "is_current_user":
                  result = value == this.Account.username;
                  break;
               case "is_not_current_user":
                  result = value != this.Account.username;
                  break;
               case "contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length > 0;
                  break;
               case "not_contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length == 0;
                  break;
               case "equals":
                  result = value.indexOf(compareValue) > -1;
                  break;
               case "not_equal":
                  result = value.indexOf(compareValue) < 0;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         queryValid: (rowData, rule, compareValue) => {
            var result = false;

            if (!this.AB || !compareValue) return result;

            // queryId:fieldId
            var queryId = compareValue.split(":")[0],
               fieldId = compareValue.split(":")[1];

            // if no query
            var query = this.queries((q) => q.id == queryId)[0];
            if (!query) return result;

            // if no field
            var field = query.fields((f) => f.id == fieldId)[0];
            if (!field) return result;

            let qIdBase = "{idBase}-query-field-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFieldFilter = new this.constructor(this.App, qIdBase);
            inQueryFieldFilter.Account = this.Account;
            // inQueryFieldFilter.applicationLoad(this._Application);
            inQueryFieldFilter.fieldsLoad(query.fields());
            inQueryFieldFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query_field":
                  result = inQueryFieldFilter.isValid(rowData);
                  break;
               case "not_in_query_field":
                  result = !inQueryFieldFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         inQueryValid: (rowData, columnName, rule, compareValue) => {
            let result = false;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            if (!compareValue || !this.AB) return result;

            // if no query
            let query = this.queries((q) => q.id == compareValue)[0];
            if (!query) return result;

            let qIdBase = "{idBase}-query-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFilter = new this.constructor(this.App, qIdBase);
            inQueryFilter.Account = this.Account;
            // inQueryFilter.applicationLoad(this._Application);
            inQueryFilter.fieldsLoad(query.fields());
            inQueryFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query":
                  result = inQueryFilter.isValid(rowData);
                  break;
               case "not_in_query":
                  result = !inQueryFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         dataCollectionValid: (rowData, columnName, rule, compareValue) => {
            var result = false;

            if (!compareValue || !this.AB) return result;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            let dc = this.AB.datacollectionByID(compareValue);

            switch (rule) {
               case "in_data_collection":
                  if (!dc) return false;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length > 0;
                  break;
               case "not_in_data_collection":
                  if (!dc) return true;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length < 1;
                  break;
            }

            return result;
         },

         connectFieldValid: function (rowData, field, rule, compareValue) {
            let relationName = field.relationName();
            let columnName = field.columnName;

            let connectedVal = "";

            if (rowData) {
               if (rowData[relationName]) {
                  connectedVal = (
                     (field.indexField
                        ? rowData[relationName][field.indexField.columnName]
                        : false) || // custom index
                     (field.indexField2
                        ? rowData[relationName][field.indexField2.columnName]
                        : false) || // custom index 2
                     rowData[relationName].id ||
                     rowData[relationName]
                  )
                     .toString()
                     .toLowerCase();
               } else {
                  let fieldVal = getFieldVal(rowData, field);
                  if (fieldVal != null) {
                     connectedVal = fieldVal;
                  }
               }
            }

            let compareValueLowercase = (compareValue || "").toLowerCase();

            switch (rule) {
               case "contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) > -1
                  );
               case "not_contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) ==
                     -1
                  );
               case "equals":
                  return connectedVal == compareValueLowercase;
               case "not_equal":
                  return connectedVal != compareValueLowercase;
               case "in_query":
               case "not_in_query":
                  return _logic.inQueryValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
                  return _logic.userValid(rowData, field, rule, compareValue);
               case "is_empty":
                  return (
                     rowData[relationName] == null ||
                     rowData[relationName].length < 1 ||
                     rowData[relationName] == ""
                  );
               case "is_not_empty":
                  return (
                     rowData[relationName] != null &&
                     ((Array.isArray(rowData[relationName]) &&
                        rowData[relationName].length > 0) ||
                        rowData[relationName] != "")
                  );
               case "in_data_collection":
               case "not_in_data_collection":
                  return _logic.dataCollectionValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
            }
         },

         thisObjectValid: (rowData, rule, compareValue) => {
            let result = false;

            switch (rule) {
               // if in_query condition
               case "in_query":
               case "not_in_query":
                  if (!this.AB || !this._Object) return result;

                  // if > 1 copy of this object in query ==> Error!
                  var query = this.queries((q) => q.id == compareValue)[0];
                  if (!query) return result;

                  var listThisObjects = query.objects((o) => {
                     return o.id == this._Object.id;
                  });
                  if (listThisObjects.length > 1) {
                     // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
                     // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
                     // this object as part of the query.

                     console.error(
                        "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
                     );
                     return true;
                  }

                  // get this object's alias from the query
                  var alias = query.objectAlias(this._Object.id);

                  // make sure all my columns in rowData are prefixed by "alias".columnName
                  var newRowData = {};
                  Object.keys(rowData).forEach((key) => {
                     newRowData[`${alias}.${key}`] = rowData[key];
                  });

                  // then pass this on to the _logic.queryValid();
                  return _logic.inQueryValid(
                     newRowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */

               // if in_datacollection condition
               case "in_data_collection":
               case "not_in_data_collection":
                  // send rowData, null to datacollectionValid()
                  return _logic.dataCollectionValid(
                     rowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */
            }
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      this.getValue = _logic.getValue;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options) {
      if (options.showObjectName) {
         this._settings.showObjectName = options.showObjectName;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      var config_settings = this.config_settings;
      var _logic = this._logic;

      // If no conditions, then return true
      if (
         config_settings == null ||
         config_settings.rules == null ||
         config_settings.rules.length == 0
      )
         return true;

      if (rowData == null) return false;

      var result = config_settings.glue === "and" ? true : false;

      config_settings.rules.forEach((filter) => {
         if (!filter.key || !filter.rule) return;

         var fieldInfo = this._Fields.filter((f) => f.id == filter.key)[0];
         if (!fieldInfo) return;

         var condResult;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         var ruleFieldType = fieldInfo.key;
         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               condResult = _logic.textValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "date":
            case "datetime":
               condResult = _logic.dateValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "number":
               condResult = _logic.numberValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "list":
               condResult = _logic.listValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "boolean":
               condResult = _logic.booleanValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "user":
               condResult = _logic.userValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "connectField":
            case "connectObject":
               condResult = _logic.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = _logic.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (config_settings.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   /**
    * @method applicationLoad
    * set application
    *
    * @param application {ABApplication}
    */
   // applicationLoad(application) {
   //    this._Application = application;
   // }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param {array} fields
    *        an array of fields used in this Query
    * @param {ABObject} object [optional]
    *        (optional) ABObject reference if this Filter should support
    *        the "this object" conditions.
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter((f) => f && f.fieldIsFilterable());
      // NOTE: User fields are now Connections, but we want to treat them
      // differently.
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         let thisObjOption = {
            id: "this_object",
            label: object.label,
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery.
    * @param {fn} filter
    * @return {array}
    */
   queries(filter = () => true) {
      let result = [];

      if (this.AB) {
         result = result.concat(this.AB.queries(filter));
      }

      if (this._Queries) {
         result = result.concat(
            (this._Queries || []).filter(
               (q) => filter(q) && result.filter((r) => r.id == q.id).length < 1
            )
         );
      }

      return result;
   }

   setValue(settings) {
      this.config_settings = settings || {};
      this.config_settings.rules = this.config_settings.rules || [];
   }
};


/***/ }),

/***/ 96552:
/*!************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldAutoIndexCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldAutoIndex
 *
 * An ABFieldAutoIndex defines a AutoIndex field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldAutoIndexDefaults = {
   key: "AutoIndex",
   // unique key to reference this specific DataField

   description: "Auto Increment Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Auto Index",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["tinyint", "smallint", "mediumint", "int", "integer"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   prefix: "",
   delimiter: "none",
   displayLength: 4,
   previewText: "0000",
};

module.exports = class ABFieldAutoIndexCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldAutoIndexDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldAutoIndexDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getDelimiterSign(text) {
      const delimiterItem = this.delimiterList().filter((item) => {
         return item.id == text;
      })[0];

      return delimiterItem ? delimiterItem.sign : "";
   }

   static delimiterList() {
      return [
         { id: "none", value: L("None"), sign: "" },
         { id: "comma", value: L("Comma"), sign: ", " },
         { id: "slash", value: L("Slash"), sign: "/" },
         { id: "space", value: L("Space"), sign: " " },
         { id: "dash", value: L("Dash"), sign: "-" },
         { id: "colon", value: L("Colon"), sign: ":" },
      ];
   }

   static setValueToIndex(prefix, delimiter, displayLength, displayNumber) {
      const resultIndex =
         prefix +
         this.getDelimiterSign(delimiter) +
         ("0000000000" + displayNumber).slice(-parseInt(displayLength));

      return resultIndex;
   }

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.displayLength = parseInt(this.settings.displayLength);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }

   format(rowData) {
      if (!rowData[this.columnName]) return "";

      try {
         const resultAutoIndex = this.constructor.setValueToIndex(
            this.settings.prefix,
            this.settings.delimiter,
            this.settings.displayLength,
            rowData[this.columnName]
         );

         return resultAutoIndex;
      } catch (err) {
         return "";
      }
   }
};



/***/ }),

/***/ 43104:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldBooleanCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldBoolean
 *
 * An ABFieldBoolean defines a boolean field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldBooleanDefaults = {
   key: "boolean",
   // unique key to reference this specific DataField

   description: "A single checkbox that can be checked or unchecked.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "check-square-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'check-square-o'  to
   // reference 'fa-check-square-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Checkbox",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["boolean"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["bool", "boolean"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: 0,
};

module.exports = class ABFieldBooleanCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldBooleanDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldBooleanDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      if (this.settings.default != null)
         this.settings.default = parseInt(this.settings.default);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null && this.settings.default != null) {
         values[this.columnName] = this.settings.default;
      }
   }
};


/***/ }),

/***/ 54562:
/*!************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCalculateCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCalculate
 *
 * An ABFieldCalculate defines a calculate field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

/** Private methods */
function AGE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   const today = new Date();
   const oneYear = 31536000000; // (24 * 60 * 60 * 1000) * 365;
   const diffYears = (today - dataDate) / oneYear;

   if (diffYears < 1) return Math.round(diffYears * 10) / 10;
   // float 2 digits
   else return Math.floor(diffYears); // no float digit

   // const today = new Date();
   // const age = today.getFullYear() - dataDate.getFullYear();
   // if (age < 1) {
   // 	const m = today.getMonth() - dataDate.getMonth();

   // 	age = parseFloat("0." + m);

   // 	// if (m < 0 || (m === 0 && today.getDate() < dataDate.getDate())) {
   // 	// 	age--;
   // 	// }
   // }
   // return age;
}

function YEAR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getFullYear();
}

function MONTH(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // Start at 0
   return dataDate.getMonth();
}

function DAY(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getDate();
}

function DATE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one day
   const oneDay = 86400000; // 1000 * 60 * 60 * 24

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneDay);
}

function HOUR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneHour = 3600000; // 1000 * 60 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneHour);
}

function MINUTE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneMinute = 60000; // 1000 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneMinute);
}

function MINUTE_TO_HOUR(mins) {
   const hours = mins / 60;
   const rhours = Math.floor(hours);
   const minutes = (hours - rhours) * 60;
   const rminutes = Math.round(minutes);

   return parseFloat(`${rhours}.${rminutes}`);
}

const ABFieldCalculateDefaults = {
   key: "calculate",
   // unique key to reference this specific DataField

   description: "Perform a calculation based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calculator",
   // font-awesome icon reference.  (without the 'fa-').  so 'calculator'  to
   // reference 'fa-calculator'

   isFilterable: (field) => {
      const unsupportedInFilter = ["MINUTE_TO_HOUR", "DATE", "HOUR", "MINUTE"];
      const unsupported = unsupportedInFilter.filter((item) =>
         field.settings.formula.includes(item)
      );
      return unsupported.length == 0;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Calculate",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   formula: "",
   decimalSign: "none", // "none", "comma", "period", "space"
   decimalPlaces: 0, // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
};

module.exports = class ABFieldCalculateCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldCalculateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCalculateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method convertToJs
    *
    * @param {ABOBject} object
    * @param {string} formula
    * @param {object} rowData
    * @param {integer} place
    * @param {string} alias [Optional]
    */
   static convertToJs(object, formula, rowData, place, alias = null) {
      if (!formula) return "";

      // replace with current date
      formula = formula.replace(/\(CURRENT\)/g, "(new Date())");

      object.fields().forEach((f) => {
         let colName = f.columnName;
         if (colName.indexOf(".") > -1)
            // QUERY: get only column name
            colName = colName.split(".")[1];

         // if template does not contain, then should skip
         if (formula.indexOf("{" + colName + "}") < 0) return;

         const data =
            rowData[`${object.alias ?? alias}.${f.columnName}`] ??
            rowData[f.columnName];

         // number fields
         if (f.key == "number") {
            const numberVal = `(${data || 0})`; // (number) - NOTE : (-5) to support negative number
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               numberVal
            );
         }
         // calculate and formula fields
         else if (f.key == "calculate" || f.key == "formula") {
            let calVal = f.format(rowData) || 0;

            // pull number only
            if (typeof calVal == "string")
               calVal = calVal.replace(/[^-0-9.]/g, "");

            calVal = `(${calVal})`;

            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               calVal
            );
         }
         // date fields
         else if (f.key == "date") {
            const dateVal = `"${data || ""}"`; // "date"
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               dateVal
            );
         }
         // boolean fields
         else if (f.key == "boolean") {
            const booleanVal = `(${data || 0})`; // show 1 or 0 for boolean
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               booleanVal
            );
         }
      });

      // decimal places - toFixed()
      // FIX: floating number calculation
      // https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
      return eval(formula).toFixed(place || 0);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   format(rowData) {
      let place = 0;
      if (this.settings.decimalSign != "none") {
         place = this.settings.decimalPlaces;
      }

      try {
         let result = this.constructor.convertToJs(
            this.object,
            this.settings.formula,
            rowData,
            place,
            this.alias
         );

         switch (this.settings.decimalSign) {
            case "comma":
               result = result.replace(".", ",");
               break;
            case "space":
               result = result.replace(".", " ");
               break;
         }

         return result;
      } catch (err) {
         return "";
      }
   }
};



/***/ }),

/***/ 83551:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCombineCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCombine
 *
 * An ABFieldCombine defines a combined field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldCombinedDefaults = {
   key: "combined",
   // unique key to reference this specific DataField

   description: "Combined Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Combined Field",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   combinedFields: "",
   // {string} "field's uuid1, field's uuid2, field's uuid3, ..."
   // This tells us what fields will be combined.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   delimiter: "plus", // plus, space, dash, period
};

module.exports = class ABFieldCombineCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldCombinedDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCombinedDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   fromValues(values) {
      super.fromValues(values);

      this.settings.delimiter =
         values.settings.delimiter || defaultValues.delimiter;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }

   warnings() {
      this._warnings = [];

      (this.settings.combinedFields.split(",") || []).forEach((id) => {
         var field = this.object.fieldByID(id);
         if (!field) {
            this.emit("warning", "dependent field not found", {
               fieldID: id,
               combinedFields: this.settings.combinedFields,
            });
         }
      });
      // console.error("combinedFields:", this.settings.combinedFields);

      return this._warnings;
   }
};


/***/ }),

/***/ 86932:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldConnectCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldConnect
 *
 * An ABFieldConnect defines a connect to other object field type.
 *
 */

var ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

// function L(key, altText) {
//    // TODO:
//    return altText; // AD.lang.label.getLabel(key) || altText;
// }

const ABFieldConnectDefaults = {
   key: "connectObject",
   // unique key to reference this specific DataField

   description: "Connect two data objects together",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "external-link",
   // font-awesome icon reference.  (without the 'fa-').  so 'external-link'  to
   // reference 'fa-external-link'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      const linkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      return ["one:many", "one:one"].indexOf(linkType) > -1;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Connect to another record",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   linkObject: "", // ABObject.id
   // the .id of the ABObject we are connected to

   linkType: "one", // [one, many]
   // 'one' : this object can have only 1 of our linkObject
   // 'many': this object can have MANY of our linkObject

   linkViaType: "many", // [one, many]
   // 'one' : the linkedObject can only have 1 of me
   // 'many' : the linkedObject can have many of me

   linkColumn: "", // ABField.id
   // the .id of the field in the linkedObject that is our
   // connected field.

   isSource: null, // bit : 1,0
   // isSource indicates that this object is the source of the connection:
   // if linkType==one, and isSource=1, then the value in this object's field
   // 		is the connected object's id
   // if linkType == one, and isSource = 0, then the linkObject has this obj.id
   //  	in it's connected field (linkColumn)

   // the next 3 Fields are concerning how we connect to other ABObjects when
   // we are NOT using the .uuid as the connecting Value. Instead, there is an
   // ABIndex setting we are connecting with.
   isCustomFK: 0,
   // {bool} truthy [0,1, etc...]
   // indicates that this connection is using 1 or more custom foreign keys
   // for the data it is storing in it's relationship.

   indexField: "", // ABField.id
   // {string} {ABField.id}
   // In a Connection defined between A --> B, this field represents the ABField
   // that is used for the data being stored.
   // In 1:1,  1:M  or M:1  relationships, .indexField always refers to the
   //       field we are pulling the Data FROM.
   // In M:N relationships:  this will refer to the A.Field.id that is a custom
   //       key (if any).

   indexField2: "", // ABField.id
   // {string}  {ABField.id}
   // In the M:N relationship: this field refers to the B.Field.id that is a
   //       custom Key for the data we are storing.
};

module.exports = class ABFieldConnectCore extends ABField {
   constructor(values, object, fieldDefaults = ABFieldConnectDefaults) {
      super(values, object, fieldDefaults);

      this.isConnection = true;
      // {bool}
      // is this an ABFieldConnect type of field.
      // this is a simplified helper to identify if an ABField is a type
      // of connect field.  Since this is the only place it is defined,
      // all other field types will be falsy

      // // text to Int:
      // this.settings.isSource = parseInt(this.settings.isSource || 0);
      // this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldConnectDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.isSource = parseInt(this.settings.isSource || 0);
      this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   warnings() {
      this._warnings = [];

      var linkField = this.fieldLink;
      if (!linkField) {
         this.emit(
            "warning",
            `ConnectField[${this.label}][${this.id}] is unable to find linked field[${this.settings.linkColumn}]`,
            {
               linkColumn: this.settings.linkColumn,
            }
         );
      }

      let linkObj = this.datasourceLink;
      if (!linkObj) {
         this.emit(
            "warning",
            `ConnectField[${this.label}][${this.id}] is unable to find linked object[${this.settings.linkObject}]`,
            {
               linkObject: this.settings.linkObject,
            }
         );
      }

      return this._warnings;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(/* values */) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   relationName() {
      // there is object name - {objectName}.{columnName}
      if (this.columnName.indexOf(".") > -1) {
         const names = this.columnName.split(".");
         return `${names[0]}.${this.AB.rules.toFieldRelationFormat(names[1])}`;
      } else {
         return this.AB.rules.toFieldRelationFormat(this.columnName);
      }
   }

   /**
    * @method datasourceLink
    * return the ABObject that this field connection links to
    * @return {ABObject}
    */
   get datasourceLink() {
      const linkObj = this.AB.objectByID(this.settings.linkObject);
      if (!linkObj) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkObject[${this.settings.linkObject}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkObject: this.settings.linkObject,
         });
      }
      return linkObj;
   }

   /**
    * @method fieldLink
    * return the ABField that we are linked to.
    * @return {ABDataField}  or undefined if not found.
    */
   get fieldLink() {
      const objectLink = this.datasourceLink;
      if (!objectLink) return null; // note: already Notified

      const linkColumn = objectLink.fieldByID(this.settings.linkColumn);
      if (!linkColumn) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkColumn[${this.settings.linkColumn}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkColumn: this.settings.linkColumn,
         });
      }
      return linkColumn;
   }

   /**
    * @method pullRelationValues
    * Return the data values for this field entry in the provided data row.
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData;

      // Get linked object
      const linkedObject = this.datasourceLink;

      let data = this.dataValue(row);
      if (data && linkedObject) {
         // convert to JSON
         if (typeof data == "string") {
            try {
               data = JSON.parse(data);
            } catch (e) {
               // must be a UUID
               // so just set that to selectedData:
               selectedData = data;
            }
         }

         selectedData = data;
      }

      return selectedData;
   }

   dataValue(rowData) {
      if (rowData == null) return "";

      const propName = `${this.object.name}.${this.relationName()}`;

      return (
         rowData[this.relationName()] ||
         rowData[propName] ||
         rowData[this.columnName] ||
         ""
      );
   }

   format(rowData) {
      const val = this.pullRelationValues(rowData);
      const linkedObject = this.datasourceLink;

      // array
      if (Array.isArray(val))
         return val
            .map((v) => {
               if (v.text == null) return linkedObject.displayData(v) || "";
               else return v.text || "";
            })
            .join(", ");
      // string
      else if (val) {
         if (val.text == null) return linkedObject.displayData(rowData) || "";
         else if (val.text) return val.text || "";
      }
      // empty string
      else return "";
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkType() {
      return this.settings.linkType;
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkViaType() {
      return this.settings.linkViaType;
   }

   /**
    * @method isSource
    * does this object contain the .id of the remote object (in case of linkType : one )
    * @return {bool}
    */
   isSource() {
      return this.settings.isSource;
   }

   /**
    * @property indexField
    * @return {ABField}
    */
   get indexField() {
      if (!this.settings.isCustomFK || !this.settings.indexField) {
         return null;
      }

      // 1:M
      if (
         this.settings.linkType == "one" &&
         this.settings.linkViaType == "many"
      ) {
         return this.datasourceLink.fields(
            (f) => f.id == this.settings.indexField
         )[0];
      }
      // 1:1
      else if (
         this.settings.linkType == "one" &&
         this.settings.linkViaType == "one"
      ) {
         if (this.settings.isSource) {
            return this.datasourceLink.fields(
               (f) => f.id == this.settings.indexField
            )[0];
         } else {
            return this.object.fields(
               (f) => f.id == this.settings.indexField
            )[0];
         }
      }
      // M:1
      else if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "one"
      ) {
         return this.object.fields((f) => f.id == this.settings.indexField)[0];
      }
      // M:N
      else if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "many"
      ) {
         let indexField = this.object.fields(
            (f) => f.id == this.settings.indexField
         )[0];

         if (indexField == null)
            indexField = this.datasourceLink.fields(
               (f) => f.id == this.settings.indexField
            )[0];

         return indexField;
      }

      return null;
   }

   /**
    * @property indexField2
    * @return {ABField}
    */
   get indexField2() {
      if (!this.settings.isCustomFK || !this.settings.indexField2) {
         return null;
      }

      let indexField;

      // M:N only
      if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "many"
      ) {
         indexField = this.object.fields(
            (f) => f.id == this.settings.indexField2
         )[0];

         if (indexField == null)
            indexField = this.datasourceLink.fields(
               (f) => f.id == this.settings.indexField2
            )[0];
      }

      return indexField;
   }

   /**
    * @method getRelationValue
    * pull values for update connect data
    * @param {Object} rowData
    * @param {Object} options - {
    *                               forUpdate: boolean
    *                           }
    * @return {Object}
    */
   getRelationValue(rowData, options = {}) {
      if (rowData == null) return;
      let colName;
      const indexField = this.indexField;
      const datasourceLink = this.datasourceLink;

      // custom index
      // M:N
      if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "many"
      ) {
         const indexField2 = this.indexField2;

         if (indexField && indexField.object.id == datasourceLink.id) {
            colName = indexField.columnName;
         } else if (indexField2 && indexField2.object.id == datasourceLink.id) {
            colName = indexField2.columnName;
         }
      }
      // 1:M, 1:1 isSource = true
      else if (
         indexField &&
         ((this.settings.linkType == "one" &&
            this.settings.linkViaType == "many") ||
            (this.settings.linkType == "one" &&
               this.settings.linkViaType == "one" &&
               this.settings.isSource))
      ) {
         colName = indexField.columnName;
      }
      // M:1
      else if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "one"
      ) {
         // NOTE: M:1 has special case
         // it uses different value for search and update.
         // UPDATE uses row id
         // SEARCH uses custom index value
         if (options.forUpdate) {
            colName = datasourceLink.PK();
         } else {
            colName = indexField
               ? indexField.columnName
               : this.fieldLink.columnName;
         }
      }
      // NO CUSTOM INDEX
      else if (datasourceLink) {
         colName = datasourceLink.PK();
      }

      let result = rowData[colName] || rowData.id || rowData;

      if (colName == "id") {
         result = parseInt(result);
      }

      return result;
   }
};


/***/ }),

/***/ 98601:
/*!***************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCore
 *
 * ABFieldBase defines the common ABField structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABObject classes.
 *
 */
// const ABEmitter = require("../../platform/ABEmitter");
const ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 97069);

module.exports = class ABFieldCore extends ABMLClass {
   constructor(values, object, fieldDefaults) {
      super(["label"], object.AB);

      // NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      this.defaults = fieldDefaults || {};

      /*
  		{
  			id:'uuid',					// uuid value for this obj
  			key:'fieldKey',				// unique key for this Field
  			icon:'font',				// fa-[icon] reference for an icon for this Field Type
  			label:'',					// pulled from translation
			columnName:'column_name',	// a valid mysql table.column name
			isImported: 1/0,			// flag to mark is import from other object
			settings: {					// unique settings for the type of field
				showIcon:true/false,	// only useful in Object Workspace DataTable
				isImported: 1/0,		// flag to mark is import from other object
				required: 1/0,			// field allows does not allow NULL or it does allow NULL
				width: {int}			// width of display column

				// specific for dataField
			},
			translations:[]
  		}
  		*/

      this.object = object;

      this.fromValues(values);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///
   static get reservedNames() {
      return [
         "id",
         "created_at",
         "updated_at",
         "properties",
         "createdAt",
         "updatedAt",
      ];
   }

   static defaultValues() {
      return {};
   }

   // unique key to reference this specific DataField
   fieldKey() {
      return this.defaults.key;
   }

   /**
    * Sails ORM data types that can be imported to this DataField
    * @return {Array}
    */
   fieldOrmTypes() {
      if (this.defaults.compatibleOrmTypes) {
         if (Array.isArray(this.defaults.compatibleOrmTypes)) {
            return this.defaults.compatibleOrmTypes;
         } else {
            return [this.defaults.compatibleOrmTypes];
         }
      } else {
         return [];
      }
   }

   /**
    * Mysql data types that can be imported to this DataField
    * @return {Array}
    */
   fieldMysqlTypes() {
      if (this.defaults.compatibleMysqlTypes) {
         if (Array.isArray(this.defaults.compatibleMysqlTypes)) {
            return this.defaults.compatibleMysqlTypes;
         } else {
            return [this.defaults.compatibleMysqlTypes];
         }
      } else {
         return [];
      }
   }

   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   fieldIcon() {
      return this.defaults.icon;
   }

   // the multilingual text for the name of this data field.
   fieldMenuName() {
      return this.defaults.menuName;
   }

   // the multilingual text for the name of this data field.
   fieldDescription() {
      return this.defaults.description;
   }

   // the flag to set when checking if field should be filterable
   fieldIsFilterable() {
      if (this.defaults.isFilterable != null) {
         if (typeof this.defaults.isFilterable === "function") {
            return this.defaults.isFilterable(this);
         } else {
            return this.defaults.isFilterable;
         }
      }

      return 1;
   }

   // the flag to set when checking if field should be sortable
   fieldIsSortable() {
      if (this.defaults.isSortable != null) {
         if (typeof this.defaults.isSortable === "function") {
            return this.defaults.isSortable(this);
         } else {
            return this.defaults.isSortable;
         }
      }

      return 1;
   }

   // the flag to set when checking if the field should be used as a label
   fieldUseAsLabel() {
      if (this.defaults.useAsLabel != null) {
         if (typeof this.defaults.useAsLabel === "function") {
            return this.defaults.useAsLabel(this);
         } else {
            return this.defaults.useAsLabel;
         }
      }

      return 1;
   }

   fieldSupportRequire() {
      if (this.defaults.supportRequire) return this.defaults.supportRequire;
      // default
      else return true;
   }

   fieldSupportQuery() {
      if (this.defaults.supportQuery != null) {
         if (typeof this.defaults.supportQuery === "function") {
            return this.defaults.supportQuery(this);
         } else {
            return this.defaults.supportQuery;
         }
      }

      return true;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABField instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      return {
         id: this.id,
         type: this.type || "field",
         key: this.key,
         icon: this.icon,
         isImported: this.isImported,
         columnName: this.columnName,
         settings: this.settings,
         translations: obj.translations,
      };
   }

   defaultCheck(val, defaultVal) {
      let returnVal = defaultVal;
      if (typeof val != "undefined") {
         returnVal = val;
      }
      return returnVal;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      if (!this.id) this.id = values.id; // NOTE: only exists after .save()
      this.type == values.type || "field";
      this.key = values.key || this.fieldKey();
      this.icon = values.icon || this.fieldIcon();

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      this.label = values.label || values.settings.label || "?label?";

      this.columnName = values.columnName || "";

      this.isImported = values.isImported || 0;

      values.settings = values.settings || {};
      this.settings = values.settings;
      this.settings.showIcon = this.defaultCheck(values.settings.showIcon, "1");
      this.settings.required = this.defaultCheck(values.settings.required, "0");
      this.settings.width = this.defaultCheck(values.settings.width, "0");

      // convert from "0" => 0
      this.isImported = parseInt(this.isImported);
      this.settings.showIcon = parseInt(this.settings.showIcon);
      this.settings.required = parseInt(this.settings.required);
      this.settings.unique = parseInt(this.settings.unique || 0);
      this.settings.width = parseInt(this.settings.width);

      // we're responsible for setting up our specific settings:
      const defaultValues = this.constructor.defaultValues() || {};
      for (const dv in defaultValues) {
         this.settings[dv] = this.defaultCheck(
            values.settings[dv],
            defaultValues[dv]
         );
      }

      // const the MLClass now process the Translations
      super.fromValues(values);

      // final validity check: columnName really should have a value:
      this.columnName = this.columnName || this.label;

      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.columnName = this.columnName.replace(/[^a-zA-Z0-9_ ]/gi, "");
   }

   /**
    * @method urlPointer()
    * return a string pointer to decode this object from the root application
    * object.
    * @return {string} pointer reference
    */
   urlPointer() {
      return this.object.urlField() + this.id;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "";
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    */
   isValidData(data, validator) {
      // console.error('!!! Field ['+this.fieldKey()+'] has not implemented .isValidData()!!!');
      if (
         this.settings.required &&
         (data[this.columnName] == null || data[this.columnName] == "") &&
         data[this.columnName] != 0
      ) {
         validator.addError(this.columnName, "This is a required field.");
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return false;
   }

   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = "";
      if (rowData[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData[propName] != null) {
         result = rowData[propName];
      }

      return result;
   }

   /**
    * @method format
    * return display text to detail comonent and define label of object
    *
    * @param {Object} rowData - data
    */
   format(rowData) {
      if (rowData) {
         return this.dataValue(rowData);
      } else return "";
   }

   /**
    * @method toDefinition()
    *
    * convert this instance into an ABDefinition object.
    *
    * @return {ABDefinition}
    */
   toDefinition() {
      const myDef = super.toDefinition();

      // attempt to provide a more descriptive name:
      // [obj]->[fieldName]
      if (myDef.name == "") {
         myDef.name =
            myDef.json.name || myDef.json.label || myDef.json.columnName;
      }
      if (this.object && this.object.name) {
         myDef.name = `${this.object.name}->${myDef.name}`;
      }
      return myDef;
   }
};


/***/ }),

/***/ 96915:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldDateCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldDate
 *
 * An ABFieldDate defines a date field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldDateDefaults = {
   key: "date",
   // unique key to reference this specific DataField

   description: "Pick one from a calendar.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calendar",
   // font-awesome icon reference.  (without the 'fa-').  so 'calendar'  to
   // reference 'fa-calendar'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["date"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["date"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   dateFormat: 2, // 1 (Ignore date), 2, 3, 4, 5
   defaultDate: 1, // 1 (None), 2 (Current Date), 3 (Specific Date)
   defaultDateValue: null, // {Date}
   validateCondition: "none",
   validateRangeUnit: "days",
   validateRangeBefore: 0,
   validateRangeAfter: 0,
   validateStartDate: null,
   validateEndDate: null,
};

module.exports = class ABFieldDateCore extends ABField {
   constructor(values, object, defaultValues = ABFieldDateDefaults) {
      super(values, object, defaultValues);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.dateFormat = parseInt(this.settings.dateFormat);
      this.settings.defaultDate = parseInt(this.settings.defaultDate);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      let dateResult;

      // Set current date as default
      if (this.settings.defaultDate == 2) {
         dateResult = new Date();
      }
      // Set specific date as default
      else if (
         this.settings.defaultDate == 3 &&
         this.settings.defaultDateValue
      ) {
         dateResult = new Date(this.settings.defaultDateValue);
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null) {
         values[this.columnName] = this.AB.toDateFormat(dateResult, {
            format: "YYYY-MM-DD",
         });
         // values[this.columnName] = moment(dateResult).format("YYYY-MM-DD");
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (data[this.columnName]) {
         let value = data[this.columnName];

         if (!(value instanceof Date)) {
            value = this.AB.toDate(value);
            // value = new Date(this.convertToMoment(value));
         }

         // verify we didn't end up with an InValid Date result.
         if (
            Object.prototype.toString.call(value) === "[object Date]" &&
            isFinite(value)
         ) {
            let isValid = true;

            // Custom vaildate is here
            if (this.settings && this.settings.validateCondition) {
               const startDate = this.settings.validateStartDate
                     ? new Date(this.settings.validateStartDate)
                     : null,
                  endDate = this.settings.validateEndDate
                     ? new Date(this.settings.validateEndDate)
                     : null,
                  startDateDisplay = this.getDateDisplay(startDate),
                  endDateDisplay = this.getDateDisplay(endDate);
               const minDate = this.AB.subtractDate(
                  new Date(),
                  this.settings.validateRangeBefore,
                  this.settings.validateRangeUnit
               );
               const maxDate = this.AB.addDate(
                  new Date(),
                  this.settings.validateRangeAfter,
                  this.settings.validateRangeUnit
               );
               switch (this.settings.validateCondition) {
                  case "dateRange":
                     if (minDate < value && value < maxDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              this.getDateDisplay(minDate),
                              this.getDateDisplay(maxDate),
                           ])
                        );
                     }

                     break;
                  case "between":
                     if (startDate < value && value < endDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "notBetween":
                     if (value < startDate && endDate < value) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should not be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() == startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<>":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() != startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should not equal {0}", [startDateDisplay])
                        );
                     break;
                  case ">":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() > startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after {0}", [startDateDisplay])
                        );
                     break;
                  case "<":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() < startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before {0}", [startDateDisplay])
                        );
                     break;
                  case ">=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() >= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after or equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() <= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before or equal {0}", [startDateDisplay])
                        );
                     break;
               }
            }

            if (isValid) {
               // Reformat value to DB
               // NOTE: should we update here?
               data[this.columnName] = this.exportValue(value);
            }
         } else {
            // return a validation error
            validator.addError(this.columnName, "Should be a Date!");
         }
      }
   }

   format(rowData) {
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }

      // pull format from settings.
      const dateObj = this.AB.toDate(d);
      return this.getDateDisplay(dateObj);

      // const momentObj = this.convertToMoment(d);
      // return this.getDateDisplay(new Date(momentObj));
   }

   getFormat() {
      let dateFormatString = "";

      const dateFormat =
         this.settings && this.settings.dateFormat
            ? this.settings.dateFormat
            : "";

      switch (dateFormat) {
         //Ignore Date
         case (1, 2):
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
         //mm/dd/yyyy
         case 3:
            {
               dateFormatString = "%m/%d/%Y";
            }
            break;
         //M D, yyyy
         case 4:
            {
               dateFormatString = "%M %d, %Y";
            }
            break;
         //D M, yyyy
         case 5:
            {
               dateFormatString = "%d %M, %Y";
            }
            break;
         default:
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
      }

      return dateFormatString;
   }

   getDateDisplay(dateData) {
      const dateFormat = this.getFormat();

      return this.dateToString(dateFormat, dateData);
   }

   // convertToMoment(string) {
   //    const result = moment(string);

   //    const supportFormats = [
   //       "DD/MM/YYYY",
   //       "MM/DD/YYYY",
   //       "DD-MM-YYYY",
   //       "MM-DD-YYYY"
   //    ];

   //    supportFormats.forEach((format) => {
   //       if (!result || !result.isValid()) result = moment(string, format);
   //    });

   //    return result;
   // }

   exportValue(value) {
      return value ? this.AB.toDateFormat(value, {
         format: "YYYY-MM-DD",
      }) : "";
      // return this.convertToMoment(value).format("YYYY-MM-DD");
   }

   dateToString(dateFormat, dateData) {
      if (dateData && dateData.toString) return dateData.toString();
      else return "";
   }
};

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
module.exports.RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";


/***/ }),

/***/ 6926:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldDateTimeCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldDateTime
 *
 * An ABFieldDateTime defines a datetime field type.
 *
 */

const ABFieldDateCore = __webpack_require__(/*! ./ABFieldDateCore */ 96915);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldDateDefaults = {
   key: "datetime",
   // unique key to reference this specific DataField

   description: "Pick one from date & time.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "clock-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'clock-o'  to
   // reference 'clock-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date & Time",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["datetime"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["datetime"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   timeFormat: 2, // 1 (Ignore time), 2, 3
   defaultTime: 1, // 1 (None), 2 (Current Time), 3 (Specific Time)
   defaultTimeValue: null, // {Date}
};

module.exports = class ABFieldDateTimeCore extends ABFieldDateCore {
   constructor(values, object) {
      super(values, object, ABFieldDateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      const baseDefault = super.defaultValues();
      return Object.assign(baseDefault, defaultValues);
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.timeFormat = parseInt(this.settings.timeFormat);
      this.settings.defaultTime = parseInt(this.settings.defaultTime);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      super.defaultValue(values);

      let dateResult;

      // From default value of ABFieldDateCore
      if (values[this.columnName]) {
         dateResult = this.AB.toDate(values[this.columnName]);
         // const momentVal = this.convertToMoment(values[this.columnName]);
         // if (momentVal.isValid()) {
         //    dateResult = new Date(momentVal);
         // }
      }

      // Set current time as default
      if (this.settings.defaultTime == 2) {
         const currDate = new Date();

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(currDate.getHours());
         dateResult.setMinutes(currDate.getMinutes());
         dateResult.setSeconds(currDate.getSeconds());
         dateResult.setMilliseconds(currDate.getMilliseconds());
      }
      // Set specific time as default
      else if (
         this.settings.defaultTime == 3 &&
         this.settings.defaultTimeValue
      ) {
         const defaultTime = new Date(this.settings.defaultTimeValue);

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(defaultTime.getHours());
         dateResult.setMinutes(defaultTime.getMinutes());
         dateResult.setSeconds(defaultTime.getSeconds());
         dateResult.setMilliseconds(defaultTime.getMilliseconds());
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null)
         values[this.columnName] = dateResult.toISOString();
   }

   getFormat() {
      const timeFormat = this.getTimeFormat();

      this.settings = this.settings || {};

      if (this.settings.dateFormat == 1) {
         return timeFormat;
      }

      const dateFormat = super.getFormat();

      return `${dateFormat} ${timeFormat}`;
   }

   format(rowData) {
      const datetimeFormat = this.getFormat();
      const d = this.dataValue(rowData);
      const dateObj = this.AB.toDate(d);

      if (d == "" || d == null) {
         return "";
      }

      return webix.Date.dateToStr(datetimeFormat)(dateObj);
   }

   getTimeFormat() {
      this.settings = this.settings || {};
      switch (this.settings.timeFormat) {
         case 2:
            return " %h:%i %A";
         case 3:
            return " %H:%i";
         default:
            return "";
      }
   }

   /**
    * @method exportValue
    * @param {Date} date
    * @return {string}
    */
   exportValue(date) {
      return date?.toISOString?.() ?? "";
   }
};

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
module.exports.RegEx =
   "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";


/***/ }),

/***/ 6945:
/*!********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldEmailCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldEmail
 *
 * An ABFieldEmail defines a boolean field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldEmailDefaults = {
   key: "email",
   // unique key to reference this specific DataField

   description: "Email fields are used to store email addresses.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "envelope",
   // font-awesome icon reference.  (without the 'fa-').  so 'envelope'  to
   // reference 'fa-envelope'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Email",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: "",
   defaultCheckbox: 0,
};

module.exports = class ABFieldEmailCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldEmailDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldEmailDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            values[this.columnName] = this.settings.default;
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      if (data[this.columnName]) {
         const Reg = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

         let value = data[this.columnName];
         value = String(value).toLowerCase();
         if (!Reg.test(value)) {
            validator.addError(this.columnName, "Invalid email");
         }
      }
   }
};


/***/ }),

/***/ 85019:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldFileCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldFile
 *
 * An ABFieldFile defines a File field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldFileDefaults = {
   key: "file",
   // unique key to reference this specific DataField

   description: "Attach a File to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file",
   // font-awesome icon reference.  (without the 'fa-').  so 'file'  to
   // reference 'fa-file'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "File Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   removeExistingData: 0,
   fileSize: 0,
   fileType: "",
};

module.exports = class ABFieldFileCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldFileDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFileDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.fileSize = parseInt(this.settings.fileSize);
      this.settings.limitFileSize = parseInt(this.settings.limitFileSize);
      this.settings.limitFileType = parseInt(this.settings.limitFileType);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method dataValue
    * return the file data stored as part of this field.
    *
    * An ABFieldFile column contains a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * This will return the json object.
    * @param {obj} values a key=>value hash of the current values.
    * @return {obj} { uuid, filename }, or {} if empty.
    */
   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = rowData[this.columnName] || rowData[propName] || {};
      if (typeof result == "string") {
         try {
            result = JSON.parse(result);
         } catch (err) {
            // ignore error
         }
      }

      return result;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    *
    * An ABFieldFile expects a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * For a default value, we return an empty json object: "{}"
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "{}";
   }

   format(rowData) {
      let result = this.dataValue(rowData);
      if (result) {
         if (typeof result == "string") {
            try {
               result = JSON.parse(result);
            } catch (err) {
               // ignore error.
            }
         }

         // return file name
         return result ? result.filename || "" : "";
      } else {
         return "";
      }
   }

   /**
    * @method requestParam
    * return the entry in the given input that relates to this field.
    * @param {obj} allParameters  a key=>value hash of the inputs to parse.
    * @return {obj} or undefined
    */
   requestParam(allParameters) {
      const myParameter = super.requestParam(allParameters);

      // if we have our default empty object, then remove the entry
      // and let the DB insert a null value.
      if (myParameter?.[this.columnName] == "{}") {
         delete myParameter[this.columnName];
      }

      return myParameter;
   }
};


/***/ }),

/***/ 28725:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldFormulaCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldFormula
 *
 * An ABFieldFormula are used to run calculations on connected (child) records
 * and store the total of that calculation in the parent.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldFormulaDefaults = {
   key: "formula",
   // unique key to reference this specific DataField

   description:
      "Perform a calculation by a formula type based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "circle-o-notch",
   // font-awesome icon reference.  (without the 'fa-').  so 'circle-o-notch'  to
   // reference 'fa-circle-o-notch'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportQuery: (field) => {
      const fieldLink = field.fieldLink;
      if (fieldLink == null) return false;

      // Not support calculate field in query
      return fieldLink.key !== "calculate";
   },

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   field: "", // id of ABField : NOTE - store our connect field to support when there are multi - linked columns
   objectLink: "", // id of ABObject
   fieldLink: "", // id of ABField
   type: "sum", // "sum", "average", "max", "min", "count"
   where: "",
};

module.exports = class ABFieldFormulaCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldFormulaDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   /**
    * @method format
    * both calculate and format the data input based of user settings
    * for this field.
    * @param {obj} rowData
    *        a key=>value hash of the current values.
    * @param {boolean} reCalculate
    *        a boolean that signals if we should force recalculation of values
    */
   format(rowData, reCalculate = false) {
      const fieldLink = this.fieldLink;

      const reformat = (numData) => {
         // ABFieldCalculate does not need to .format again
         if (!fieldLink || fieldLink.key == "calculate") {
            return numData;
         } else {
            const rowDataFormat = {};
            rowDataFormat[fieldLink.columnName] = numData;
            return fieldLink.format(rowDataFormat);
         }
      };

      // if data exists, then will not calculate on client side
      // unless we pass reCalculate=true to force the recalculation
      if (rowData[this.columnName] != null && !reCalculate) {
         // reformat data
         return reformat(rowData[this.columnName]);
      }

      if (!fieldLink) return 0;

      const fieldBase = this.fieldBase();
      if (!fieldBase) return 0;

      let data =
         rowData[fieldBase.relationName()] ||
         rowData[fieldBase.columnName] ||
         [];
      if (!Array.isArray(data)) data = [data];

      // Filter
      if (
         data &&
         data.length &&
         this.settings &&
         this.settings.where &&
         this.settings.where.rules &&
         this.settings.where.rules.length
      ) {
         this.filterHelper.setValue(this.settings.where);
         data = data.filter((item) => this.filterHelper.isValid(item));
      }

      let numberList = [];

      // pull number from data
      switch (fieldLink.key) {
         case "calculate":
            data.forEach((d) => {
               numberList.push(parseFloat(fieldLink.format(d) || 0));
            });
            break;
         case "number":
            numberList = data.map((d) => d[fieldLink.columnName] || 0);
            break;
      }

      let result = 0;

      // get the decimal size of the numbers being calculated
      const decimalSize = fieldLink.getDecimalSize();

      // calculate
      switch (this.settings.type) {
         case "sum":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               result = sum / multiplier;
            }
            break;

         case "average":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               // and divide by length to get the average
               result = sum / multiplier / numberList.length;
            }
            break;

         case "max":
            result = Math.max(...numberList) || 0;
            break;
         case "min":
            result = Math.min(...numberList) || 0;
            break;
         case "count":
            result = numberList.length;
            break;
      }

      rowData[this.columnName] = result;

      // ABFieldCalculate does not need to .format again
      if (fieldLink.key == "calculate") {
         return result;
      } else {
         return reformat(result);
      }
   }

   fieldBase() {
      return this.object.fields((f) => f.id == this.settings.field)[0];
   }

   get fieldLink() {
      const obj = this.object.AB.objects(
         (obj) => obj.id == this.settings.object
      )[0];
      if (!obj) return null;

      const field = obj.fields((f) => f.id == this.settings.fieldLink)[0];
      if (!field) return null;

      return field;
   }

   get filterHelper() {
      if (this._rowFilter == null) {
         this._rowFilter = this.AB.filterComplexNew(`${this.id}_filterComplex`);

         if (this.fieldLink && this.fieldLink.object) {
            this._rowFilter.fieldsLoad(this.fieldLink.object.fields());
            this._rowFilter.setValue(this.settings.where);
         }
      }

      return this._rowFilter;
   }
};


/***/ }),

/***/ 84342:
/*!********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldImageCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldImageCore
 *
 * An ABFieldImage defines a Image field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

const ABFieldImageDefaults = {
   key: "image",
   // unique key to reference this specific DataField

   description: "Attach an image to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file-image-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'file-image-o'  to
   // reference 'fa-file-image-o'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Image Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   useWidth: 0,
   imageWidth: "",
   useHeight: 0,
   imageHeight: "",
   removeExistingData: 0,
   useDefaultImage: false,
   defaultImageUrl: "",
};

module.exports = class ABFieldImageCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldImageDefaults);

      // NOTE: our Labels are ready here:
      if (
         ABFieldImageDefaults.menuName == "*Image Attachment" &&
         this.AB.Label
      ) {
         const L = this.AB.Label();
         ABFieldImageDefaults.menuName = L(
            "ab.dataField.image.menuName",
            "*Image Attachment"
         );
         ABFieldImageDefaults.description = L(
            "ab.dataField.image.description",
            "*Attach an image to this object."
         );
      }

      /*
    	{
			settings: {
				'useWidth':0,
				'imageWidth':'',
				'useHeight': 0,
				'imageHeight': '',
				'removeExistingData': 0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldImageDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.useWidth = parseInt(this.settings.useWidth);
      this.settings.useHeight = parseInt(this.settings.useHeight);
      this.settings.imageWidth = parseInt(this.settings.imageWidth);
      this.settings.imageHeight = parseInt(this.settings.imageHeight);
      this.settings.useDefaultImage = parseInt(this.settings.useDefaultImage);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
};


/***/ }),

/***/ 76611:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldJsonCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldJson
 *
 * An ABFieldJson defines a JSON field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

const ABFieldJsonDefaults = {
   key: "json",
   // unique key to reference this specific DataField

   description: "JSON value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "JSON",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["json"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["json"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {};

module.exports = class ABFieldJsonCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldJsonDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldJsonDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // in the case of a JSON data type, we should NOT insert a ""
      //
      // values[this.columnName] = "";
   }
};


/***/ }),

/***/ 73291:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldListCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldListCore
 *
 * An ABFieldList defines a select list field type.
 *
 */

// const ABFieldSelectivity = require("../../platform/dataFields/ABFieldSelectivity");
const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldListDefaults = {
   key: "list",
   // unique key to reference this specific DataField

   description:
      "Select list allows you to select predefined options below from a dropdown.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "th-list",
   // font-awesome icon reference.  (without the 'fa-').  so 'th-list'  to
   // reference 'fa-th-list'

   isFilterable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Select list",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "char",
      "varchar",
      "tinytext" /* "text", "mediumtext" */,
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   hasColors: (field) => {
      if (field.settings.hasColors) {
         return true;
      } else {
         return false;
      }
   },
};

const defaultValues = {
   isMultiple: 0,
   // {bool}
   // can multiple values be selected?

   hasColors: 0,
   // {bool}
   // are we to display our values in colors?

   options: [],
   // {array}
   // The options defined for this list:
   // [ { id, text, hex, translations },...]
   //    .id {string} a unique id for this value
   //    .text {string} the displayed text of this value
   //    .hex {string} a color hex definition for this value
   //    .translations {obj} the multilingual definitions for this value.

   default: "none",
   multipleDefault: [],
};

module.exports = class ABFieldListCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldListDefaults);

      this.pendingDeletions = [];
      // {array}
      // a list of pending option deletions that need to be processed
      // when this is saved.
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldListDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }

      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.hasColors = parseInt(this.settings.hasColors);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      obj.settings.options.forEach((opt) => {
         this.unTranslate(opt, opt, ["text"]);
      });

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Multiple select list
      if (this.settings.isMultiple == true) {
         let defaultVals = [];
         this.settings.multipleDefault.forEach((def) => {
            this.settings.options.forEach((opt) => {
               if (opt.id == def.text) {
                  defaultVals.push(opt);
               }
            });
         });
         values[this.columnName] = defaultVals || [];
      }
      // Single select list
      else if (this.settings.default && this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   /**
    * @method options
    * Return an array of [{ id, text }] options defined by this field.
    * @return {array}
    */
   options() {
      return this.settings.options.map((opt) => {
         return {
            id: opt.id,
            text: opt.text,
            hex: opt.hex ? opt.hex : "",
            translations: opt.translations ? opt.translations : "",
         };
      });
   }

   format(rowData, options = {}) {
      let val = this.dataValue(rowData) || [];

      if (typeof val == "string") {
         try {
            val = JSON.parse(val);
         } catch (e) {
            // continue regardless of error
         }
      }

      // Convert to array
      if (!Array.isArray(val)) val = [val];

      const displayOpts = this.settings.options
         .filter((opt) => val.filter((v) => (v.id || v) == opt.id).length > 0)
         .map((opt) => {
            let text = opt.text;
            const languageCode = options.languageCode || "en";

            // Pull text of option with specify language code
            const optTran = (opt.translations || []).filter(
               (o) => o.language_code == languageCode
            )[0];
            if (optTran) text = optTran.text;

            return text;
         });

      return displayOpts.join(", ");
   }
};


/***/ }),

/***/ 37143:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldLongTextCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldLongText
 *
 * An ABFieldLongText defines a LongText field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

const MAX_CHAR_LENGTH = 5000;

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldLongTextDefaults = {
   key: "LongText", // unique key to reference this specific DataField

   description: "Multiple lines of text",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "align-right",
   // font-awesome icon reference.  (without the 'fa-').  so 'align-right'  to
   // reference 'fa-align-right'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Long text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["longtext", "mediumtext", "text"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldLongText can be.
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

module.exports = class ABFieldLongText extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldLongTextDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldLongTextDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";

      // we're responsible for setting up our specific settings:
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         if (this.object)
            this.object.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual)
         if (this.object)
            this.object.unTranslate(obj.settings, obj.settings, ["default"]);
         else obj.settings.default = this.settings.default;

      return obj;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null) {
         if (typeof this.settings.default == "string") {
            values[this.columnName] = this.settings.default;
         } else {
            values[this.columnName] = "";
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (
         data &&
         data[this.columnName] &&
         data[this.columnName].length > MAX_CHAR_LENGTH
      ) {
         validator.addError(
            this.columnName,
            `should NOT be longer than ${MAX_CHAR_LENGTH} characters`
         );
      }
   }
};


/***/ }),

/***/ 49671:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldNumberCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldNumber
 *
 * An ABFieldNumber defines a Number field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

const ABFieldNumberDefaults = {
   key: "number",
   // unique key to reference this specific DataField

   description: "A Float or Integer Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "hashtag",
   // font-awesome icon reference.  (without the 'fa-').  so 'hashtag'  to
   // reference 'fa-hashtag'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Number",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   // 'allowRequired': 0,
   default: "",
   typeFormat: "none",
   typeDecimals: "none",
   typeDecimalPlaces: 0,
   typeRounding: "none",
   typeThousands: "none",
   validation: 0,
   validateMinimum: "",
   validateMaximum: "",
};

let L = null; //AB.Label();

module.exports = class ABFieldNumberCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldNumberDefaults);

      /*
    	{
			settings: {
				'allowRequired':0,
				'default':null,
				'typeFormat': 'none',
				'typeDecimals': 'none',
				'typeDecimalPlaces': 'none',
				'typeRounding' : 'none',
				'typeThousands': 'none',
				'validation':0,
				'validateMinimum':null,
				'validateMaximum':null
			}
    	}
    	*/
      if (!L) {
         L = this.AB.Label();
      }
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldNumberDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static formatList(iL) {
      if (iL && !L) L = iL;
      return [
         { id: "none", value: L("None") },
         {
            id: "dollar",
            value: L("$"),
            sign: "$",
            position: "prefix",
         },
         {
            id: "yen",
            value: L("¥"),
            sign: "¥",
            position: "prefix",
         },
         {
            id: "pound",
            value: L("£"),
            sign: "£",
            position: "prefix",
         },
         {
            id: "euroBefore",
            value: L("€ (before)"),
            sign: "€",
            position: "prefix",
         },
         {
            id: "euroAfter",
            value: L("€ (after)"),
            sign: "€",
            position: "postfix",
         },
         {
            id: "percent",
            value: L("%"),
            sign: "%",
            position: "postfix",
         },
      ];
   }

   static delimiterList() {
      return [
         { id: "none", value: L("None") },
         {
            id: "comma",
            value: L("Comma"),
            sign: ",",
         },
         {
            id: "period",
            value: L("Period"),
            sign: ".",
         },
         {
            id: "space",
            value: L("Space"),
            sign: " ",
         },
      ];
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      // this.settings.allowRequired = parseInt(this.settings.allowRequired);
      this.settings.validation = parseInt(this.settings.validation);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      // const L = this.AB.Label();

      if (data[this.columnName] != null && data[this.columnName] != "") {
         let value = data[this.columnName];

         // if this is an integer:
         if (this.settings.typeDecimals == "none") {
            value = parseInt(value);
         } else {
            const places = parseInt(this.settings.typeDecimalPlaces) || 2;
            value = parseFloat(parseFloat(value).toFixed(places));
         }

         const isNumeric = (n) => {
            return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
         };
         if (!isNumeric(value)) {
            validator.addError(this.columnName, L("invalid number"));
         }

         // validate Minimum
         if (
            this.settings.validation == true &&
            this.settings.validateMinimum != null &&
            this.settings.validateMinimum > value
         ) {
            const errMessage = L("should be greater than {0}", [
               this.settings.validateMinimum,
            ]);

            validator.addError(this.columnName, errMessage);
         }

         // validate Maximum
         if (
            this.settings.validation == true &&
            this.settings.validateMaximum != null &&
            this.settings.validateMaximum < value
         ) {
            const errMessage = L("should be less than {0}", [
               this.settings.validateMaximum,
            ]);

            validator.addError(this.columnName, errMessage);
         }
      }
   }

   format(rowData) {
      if (
         rowData[this.columnName] == null ||
         (rowData[this.columnName] != 0 && rowData[this.columnName] == "")
      )
         return "";

      let data = rowData[this.columnName] || 0;

      if (typeof data == "string") {
         data = data.replace(/,/g, "");
      }

      // Validate number
      if (isNaN(parseFloat(data))) data = 0;

      const formatSign = this.constructor
         .formatList()
         .filter((item) => item.id == this.settings.typeFormat)[0];
      const decimalPlaces =
         this.settings.typeDecimalPlaces != "none"
            ? parseInt(this.settings.typeDecimalPlaces)
            : 0;

      let thousandsSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeThousands)[0];
      let decimalSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeDecimals)[0];
      let prefix = "";
      let postfix = "";

      if (formatSign && formatSign.sign) {
         switch (formatSign.position) {
            case "prefix":
               prefix = formatSign.sign;
               break;
            case "postfix":
               postfix = formatSign.sign;
               break;
         }
      }

      decimalSign = decimalSign.sign || "";
      thousandsSign = thousandsSign.sign || "";

      // round number
      if (this.settings.typeRounding == "roundDown") {
         const digit = Math.pow(10, decimalPlaces);
         data = Math.floor(data * digit) / digit;
      }

      const number = this.formatNumber(data, {
         groupDelimiter: thousandsSign,
         groupSize: 3,
         decimalDelimiter: decimalSign,
         decimalSize: decimalPlaces,
      });

      return `${prefix} ${number} ${postfix}`;
   }

   formatNumber(data, options = {}) {
      if (data === "" || data == null) return data;

      data = parseFloat(data);
      const negativeSign = data < 0 ? "-" : "";
      data = Math.abs(data);

      const dataStr = data.toString();
      const integerStr = dataStr.split(".")[0];
      const decimalStr = dataStr.split(".")[1];

      let integerValue = "";

      // Thousands digit sign
      if (options.groupDelimiter) {
         const step = 3;
         let i = integerStr.length;

         do {
            i -= step;
            const chunk =
               i > 0
                  ? integerStr.substr(i, step)
                  : integerStr.substr(0, step + i);
            integerValue = `${chunk}${
               integerValue ? options.groupDelimiter + integerValue : ""
            }`;
         } while (i > 0);
      } else {
         integerValue = integerStr;
      }

      let result = "";

      // Decimal
      if (options.decimalDelimiter && options.decimalSize) {
         result = `${negativeSign}${integerValue}${
            decimalStr
               ? options.decimalDelimiter +
                 decimalStr.toString().substr(0, options.decimalSize)
               : ""
         }`;
      }
      // Integer
      else {
         result = `${negativeSign}${integerValue}`;
      }

      return result;
   }

   getDecimalSize() {
      if (this.settings.typeDecimalPlaces != "none") {
         return parseInt(this.settings.typeDecimalPlaces);
      } else {
         return 0;
      }
   }
};


/***/ }),

/***/ 36756:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldStringCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldString
 *
 * An ABFieldString defines a string field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

const MAX_CHAR_LENGTH = 255;

const ABFieldStringDefaults = {
   key: "string",
   // unique key to reference this specific DataField

   description: "short string value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Single line text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldString can be.
};

const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

module.exports = class ABFieldStringCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldStringDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
        */
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldStringDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // we're responsible for setting up our specific settings:
      this.settings.default = values.settings.default || defaultValues.default;
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         this.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual) {
         this.unTranslate(obj.settings, obj.settings, ["default"]);
      } else obj.settings.default = this.settings.default;

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      const L = this.AB.Label();

      if (
         data &&
         data[this.columnName] &&
         data[this.columnName].length > MAX_CHAR_LENGTH
      ) {
         validator.addError(
            this.columnName,
            L("should NOT be longer than {0} characters", [MAX_CHAR_LENGTH])
         );
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }
};


/***/ }),

/***/ 18585:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldTextFormulaCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldTextFormula
 *
 * An ABFieldTextFormula defines a TextFormula field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 14403);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldTextFormulaDefaults = {
   key: "TextFormula",
   // unique key to reference this specific DataField

   description: "Text Formula",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "question",
   // font-awesome icon reference.  (without the 'fa-').  so 'question'  to
   // reference 'fa-question'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Text Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   textFormula: "",
   // {string} "some text or text with formula ..."
   // This tells us what the formula we need to do with text included text string.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   // 'imageWidth':'',
   // 'useHeight': 0,
   // 'imageHeight': ''
};

/** Private methods */

/**
 * @method setValueToFormula
 *
 * @param {ABOBject} object
 * @param {string} formulaString
 * @param {object} rowData
 */

function setValueToFormula(object, formulaString, rowData) {
   if (!formulaString) return;

   const fieldRegExp = /{[^{}]+}/gm;
   const matches_field_array = formulaString.match(fieldRegExp);
   matches_field_array.forEach((element) => {
      const columnName = element.replace(/{|}|"/g, "");
      object.fields().forEach((field) => {
         if (field.columnName == columnName) {
            if (field.key == "AutoIndex") {
               //Check AutoIndex Field
               const autoIndexVal = field.format(rowData) || 0;
               formulaString = formulaString.replace(element, autoIndexVal);
            } else if (field.key == "calculate") {
               //Calculate Field
               const calVal = `(${field.format(rowData) || 0})`;
               formulaString = formulaString.replace(element, eval(calVal));
            } else if (field.key == "date") {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName]
                     ? field.exportValue(rowData[columnName])
                     : ""
               );
            } else {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName] ? field.format(rowData) : ""
               );
            }
         }
      });
   });

   return formulaString;
}

/**
 * @method setBuildinValueToFormula
 *
 * @param {ABFactory} AB
 * @param {string} formulaString
 */

function setBuildinValueToFormula(AB, formulaString) {
   const buildInRegExp = /\w+\(.*?\)/gm;
   const matches_buildin_array = formulaString.match(buildInRegExp);
   if (matches_buildin_array) {
      const buildinList = getBuildInFunction();
      matches_buildin_array.forEach((element) => {
         const formula_array = element.split(/\(|\)/);
         const isBracketInBracket =
            formula_array.length > 2 && formula_array[2] != "";
         const functionName = formula_array[0];
         const parameters_array = formula_array[1].split(",");
         let isMatch = false;
         for (let i = 0; i < buildinList.length; i++) {
            let resultParameters = element;
            if (functionName == buildinList[i].id) {
               if (parameters_array.length == buildinList[i].parameter_size) {
                  switch (functionName) {
                     case "left":
                        resultParameters = getLeft(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "right":
                        resultParameters = getRight(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "mid":
                        resultParameters = getMid(
                           parameters_array[0],
                           parameters_array[1],
                           parameters_array[2]
                        );
                        break;
                     case "trim":
                        resultParameters = getTrim(parameters_array[0]);
                        break;
                     case "trimLeft":
                        resultParameters = getTrimLeft(parameters_array[0]);
                        break;
                     case "trimRight":
                        resultParameters = getTrimRight(parameters_array[0]);
                        break;
                     case "length":
                        resultParameters = getLength(parameters_array[0]);
                        break;
                     case "regexReplace":
                        resultParameters = getRegExpReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "extractRegex":
                        resultParameters = getExtractRegex(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     case "replace":
                        resultParameters = getReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "lower":
                        resultParameters = getLower(parameters_array[0]);
                        break;
                     case "upper":
                        resultParameters = getUpper(parameters_array[0]);
                        break;
                     case "capitalize":
                        resultParameters = getCapitalize(parameters_array[0]);
                        break;
                     case "random":
                        resultParameters = getRandom(parameters_array[0]);
                        break;
                     case "numberToWords":
                        resultParameters = getNumberToWords(
                           parameters_array[0]
                        );
                        break;
                     case "getDateDayOfWeekName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateDayOfWeekName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "getDateMonthOfYearName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateMonthOfYearName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "formatDate":
                        resultParameters = getFormatDate(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     default:
                        break;
                  }
                  isMatch = true;
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
                  return;
               } else {
                  resultParameters = functionName + "(Bad Parameter)";
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
               }
            }
         }
      });
   }
   return formulaString;
}

function getBuildInFunction() {
   const functionList = [
      {
         id: "left",
         value: "left({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "right",
         value: "right({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "mid",
         value: "mid({COLUMN_NAME}, 1, 1)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "trim",
         value: "trim({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimLeft",
         value: "trimLeft({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimRight",
         value: "trimRight({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "length",
         value: "length({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "regexReplace",
         value: "regexReplace({COLUMN_NAME}, [*], REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "extractRegex",
         value: "extractRegex({COLUMN_NAME}, [*])",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "replace",
         value: "replace({COLUMN_NAME}, SEARCH_VALUE, REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "lower",
         value: "lower({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "upper",
         value: "upper({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "capitalize",
         value: "capitalize({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      { id: "random", value: "random(1)", type: "build-in", parameter_size: 1 },
      {
         id: "numberToWords",
         value: "numberToWords({NUMBER_COLUMN} or 012...)",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateDayOfWeekName",
         value: "getDateDayOfWeekName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateMonthOfYearName",
         value: "getDateMonthOfYearName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "formatDate",
         value: "formatDate({DATE_COLUMN}, OUTPUT_FORMAT)",
         type: "build-in",
         parameter_size: 2,
      },
   ];
   return functionList;
}

function getLeft(string, endPosition) {
   return string.substring(0, parseInt(endPosition));
}

function getRight(string, endposition) {
   const reverseStr = reverseString(string).substring(0, parseInt(endposition));
   return reverseString(reverseStr);
}

function reverseString(string) {
   return string.split(" ").reverse().join(" ");
}

function getMid(string, startPosition, length) {
   if (string.length < startPosition) return "mid(Bad Parameter)";
   return string.substring(
      parseInt(startPosition),
      parseInt(startPosition) + parseInt(length)
   );
}

function getTrim(string) {
   return string.trim();
}

function getTrimLeft(string) {
   return string.trimLeft();
}

function getTrimRight(string) {
   return string.trimRight();
}

function getLength(string) {
   return string.length;
}

function getRegExpReplace(string, regexp, replaceString) {
   return string.replace(regexp, replaceString);
}

function getExtractRegex(string, regexp) {
   const extractResult = string.match(regexp);
   if (Array.isArray(extractResult)) {
      return extractResult[0];
   }
   return extractResult;
}

function getReplace(string, searchValue, replaceValue) {
   return string.replace(searchValue, replaceValue);
}

function getLower(string) {
   return string.toLowerCase();
}

function getUpper(string) {
   return string.toUpperCase();
}

function getCapitalize(string) {
   return string
      .toLowerCase()
      .split(" ")
      .map((s) => s.charAt(0).toUpperCase() + s.substring(1))
      .join(" ");
}

function getRandom(max) {
   return Math.floor(Math.random() * (max + 1));
}

function getNumberToWords(number) {
   const string = number.trim(",").toString();

   let units,
      tens,
      scales,
      start,
      end,
      chunks,
      chunksLen,
      chunk,
      ints,
      i,
      word,
      words;

   const and = "";

   /* Is number zero? */
   if (parseInt(string) === 0) {
      return "zero";
   }

   /* Array of units as words */
   units = [
      "",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "ten",
      "eleven",
      "twelve",
      "thirteen",
      "fourteen",
      "fifteen",
      "sixteen",
      "seventeen",
      "eighteen",
      "nineteen",
   ];

   /* Array of tens as words */
   tens = [
      "",
      "",
      "twenty",
      "thirty",
      "forty",
      "fifty",
      "sixty",
      "seventy",
      "eighty",
      "ninety",
   ];

   /* Array of scales as words */
   scales = [
      "",
      "thousand",
      "million",
      "billion",
      "trillion",
      "quadrillion",
      "quintillion",
      "sextillion",
      "septillion",
      "octillion",
      "nonillion",
      "decillion",
      "undecillion",
      "duodecillion",
      "tredecillion",
      "quatttuor-decillion",
      "quindecillion",
      "sexdecillion",
      "septen-decillion",
      "octodecillion",
      "novemdecillion",
      "vigintillion",
      "centillion",
   ];

   /* Split user arguemnt into 3 digit chunks from right to left */
   start = string.length;
   chunks = [];
   while (start > 0) {
      end = start;
      chunks.push(string.slice((start = Math.max(0, start - 3)), end));
   }

   /* Check if function has enough scale words to be able to stringify the user argument */
   chunksLen = chunks.length;
   if (chunksLen > scales.length) {
      return "";
   }

   /* Stringify each integer in each chunk */
   words = [];
   for (i = 0; i < chunksLen; i++) {
      chunk = parseInt(chunks[i]);

      if (chunk) {
         /* Split chunk into array of individual integers */
         ints = chunks[i].split("").reverse().map(parseFloat);

         /* If tens integer is 1, i.e. 10, then add 10 to units integer */
         if (ints[1] === 1) {
            ints[0] += 10;
         }

         /* Add scale word if chunk is not zero and array item exists */
         if ((word = scales[i])) {
            words.push(word);
         }

         /* Add unit word if array item exists */
         if ((word = units[ints[0]])) {
            words.push(word);
         }

         /* Add tens word if array item exists */
         if ((word = tens[ints[1]])) {
            words.push(word);
         }

         /* Add 'and' string after units or tens integer if: */
         if (ints[0] || ints[1]) {
            /* Chunk has a hundreds integer or chunk is the first of multiple chunks */
            if (ints[2] || (!i && chunksLen)) {
               words.push(and);
            }
         }

         /* Add hundreds word if array item exists */
         if ((word = units[ints[2]])) {
            words.push(word + " hundred");
         }
      }
   }

   return words.reverse().join(" ");
}

function getDateDayOfWeekName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("dddd");

   return AB.toDateFormat(date, {
      format: "dddd",
      localeCode: AB.Account.language(),
   });
}

function getDateMonthOfYearName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("MMMM");

   return AB.toDateFormat(date, {
      format: "MMMM",
      localeCode: AB.Account.language(),
   });
}

function getFormatDate(date, format) {
   const dt = new Date(date);
   return dt.toString(format);
}

module.exports = class ABFieldTextFormulaCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldTextFormulaDefaults);

      /*
    	{
			settings: {
				textDefault: 'string',
				supportMultilingual: true/false
			}
    	}
    	*/

      // // text to Int:
      // this.settings.supportMultilingual = parseInt(this.settings.supportMultilingual);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTextFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getBuildInFunction() {
      return getBuildInFunction();
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default value
         // values[this.columnName] = this.settings.DEFAULT_VALUE;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      validator = super.isValid();

      // validator.addError(this.columnName, L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      // return this.settings.supportMultilingual == 1;
      return false;
   }

   format(rowData) {
      try {
         if (!this.settings.textFormula) return "";

         let resultFormula = this.settings.textFormula;

         //Set Field value first
         resultFormula = setValueToFormula(this.object, resultFormula, rowData);

         //then Check Build-in Function
         resultFormula = setBuildinValueToFormula(this.AB, resultFormula);

         return resultFormula;
      } catch (err) {
         return "";
      }
   }
};

//// NOTE: if you need a unique [edit_type] by your returned config.editor above:
// webix.editors = {
//   "[edit_type]": {
//     focus: function () {...}
//     getValue: function () {...},
//     setValue: function (value) {...},
//     render: function () {...}
//   }
// };

//// NOTE: if you need a unique [sort_type] by your returned config.sort above:
// webix.DataStore.prototype.sorting.as.[sort_type] = function(a,b){
//     return a > b ? 1 : -1;
// }


/***/ }),

/***/ 98630:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldTreeCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldTreeCore
 *
 * An ABFieldTree defines a select list field type.
 *
 */

const ABFieldSelectivity = __webpack_require__(/*! ../../platform/dataFields/ABFieldSelectivity */ 87038);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldTreeDefaults = {
   key: "tree",
   // unique key to reference this specific DataField

   description:
      "Data tree allows you to build a hierarchical set of selectable data. (ex: Categories and sub-categories)",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "sitemap",
   // font-awesome icon reference.  (without the 'fa-').  so 'sitemap'  to
   // reference 'fa-sitemap'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Data Tree",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   options: [],
};

module.exports = class ABFieldTreeCore extends ABFieldSelectivity {
   constructor(values, object) {
      super(values, object, ABFieldTreeDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTreeDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      if (obj.settings.options && obj.settings.options.length > 0) {
         obj.settings.options.forEach((opt) => {
            this.unTranslate(opt, opt, ["text"]);
         });
      }

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
};


/***/ }),

/***/ 18665:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldUserCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldUser
 *
 * An ABFieldUser defines a user field type.
 *
 */

const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 66589);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldUserDefaults = {
   key: "user",
   // unique key to reference this specific DataField

   description: "Add users to a record.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "user-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'user-o'  to
   // reference 'fa-user-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "User",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   USERNAME_FIELD_ID: "5760560b-c078-47ca-98bf-e18ac492a561",
   // {string} .uuid
   // the ABField.id of the SiteUser.username field.  This is what other
   // objects will link to in their ABFieldUser connections.
};

const defaultValues = {
   editable: 1,
   isMultiple: 0,
   isCurrentUser: 0,
   isShowProfileImage: 0,
   isShowUsername: 1,
};

module.exports = class ABFieldUserCore extends ABFieldConnect {
   constructor(values, object) {
      super(values, object, ABFieldUserDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldUserDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.editable = parseInt(this.settings.editable);
      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.isCurrentUser = parseInt(this.settings.isCurrentUser);
      this.settings.isShowProfileImage = parseInt(
         this.settings.isShowProfileImage
      );
      this.settings.isShowUsername = parseInt(this.settings.isShowUsername);
   }

   ///
   /// Working with Actual Object Values:
   ///

   format(rowData) {
      let val = this.dataValue(rowData) || [];

      if (val && !Array.isArray(val)) val = [val];
      if (!val) val = [];

      return val.map((v) => v.username || v).join(", ");
   }
};


/***/ }),

/***/ 62418:
/*!******************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessLaneCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessLane
 * manages the lanes in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */
const ABProcessParticipant = __webpack_require__(/*! ../../platform/process/ABProcessParticipant */ 67692);

const ABProcessLaneDefaults = {
   type: "process.lane",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key"
   // {string} .icon
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

module.exports = class ABProcessLaneCore extends ABProcessParticipant {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessLaneDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.type = attributes.type || ABProcessLaneDefaults.type;
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   // toObj() {
   //     // default label value
   //     if (!this.label && this.name && this.name != "") {
   //         this.label = this.name;
   //     }

   //     // untranslate this object:
   //     var data = super.toObj();

   //     var fieldsToSave = [
   //         "id",
   //         "name",
   //         "type",
   //         "processID",
   //         "diagramID",
   //         "where"
   //     ];
   //     fieldsToSave.forEach((f) => {
   //         data[f] = this[f];
   //     });

   //     return data;
   // }
};


/***/ }),

/***/ 52957:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessParticipantCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system, and provide a way to lookup a SiteUser.
 */
const ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 97069);

const ABProcessParticipantDefaults = {
   type: "process.participant",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key" // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

module.exports = class ABProcessParticipantCore extends ABMLClass {
   constructor(attributes, process, AB) {
      super(["label"], AB);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }

      this.fromValues(attributes);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessParticipantDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // These Values are needed By ABDefinition:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || ABProcessParticipantDefaults.type;
      this.key = attributes.key || ABProcessParticipantDefaults.type;

      // Process Values:
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneIDs = attributes.laneIDs || [];
      this.stashed = false;
      if (attributes.stashed && attributes.stashed != "") {
         this.stashed = attributes.stashed;
      }

      this.useRole = 0;
      if (typeof attributes.useRole != "undefined") {
         this.useRole = parseInt(attributes.useRole);
      }

      this.role = 0;
      if (typeof attributes.role != "undefined") {
         this.role = attributes.role;
      }

      this.useAccount = 0;
      if (typeof attributes.useAccount != "undefined") {
         this.useAccount = parseInt(attributes.useAccount);
      }

      this.account = 0;
      if (typeof attributes.account != "undefined") {
         this.account = attributes.account;
      }

      this.useField = 0;
      if (typeof attributes.useField != "undefined") {
         this.useField = parseInt(attributes.useField);
      }

      this.fields = [];
      if (typeof attributes.fields != "undefined") {
         this.fields = attributes.fields;
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneIDs",
         "where",
         "useRole",
         "role",
         "useAccount",
         "account",
         "useField",
         "fields",
         "stashed",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }
};


/***/ }),

/***/ 52719:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessTaskManager.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABProcessTaskManager
 *
 * An interface for managing the different ABProcessTasks in AppBuilder.
 *
 */

/*
 * Tasks
 * A name => ABProcessElement hash of the different ABProcessElements available.
 */
var Tasks = {};

/*
 * DEFINITIONTYPES
 * a hash of BPMN:Element.type to Default values
 * for each of our Process Objects.
 *
 * NOTE: For Tasks, the key should be target.type,
 * for Triggers or End elements, the key should be
 * the target.eventDefinitionType
 */
var DEFINITIONTYPES = {};

var AllProcessElements = [
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessEnd */ 88556),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessGatewayExclusive */ 19036),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskEmail */ 18872),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskService */ 95187),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing */ 92845),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPClose */ 80346),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose */ 33618),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingJEArchive */ 79841),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceCalculate */ 26088),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceInsertRecord */ 87757),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceQuery */ 85811),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl */ 34430),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskSubProcess */ 86298),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUser */ 68063),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUserApproval */ 56031),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUserExternal */ 82448),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTrigger */ 46732),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTriggerLifecycle */ 12513),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTriggerTimer */ 12038),
];

AllProcessElements.forEach((ELEMENT) => {
   Tasks[ELEMENT.defaults().key] = ELEMENT;

   switch (ELEMENT.defaults().category) {
      case "start":
      case "end":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.eventDefinitionType] =
            ELEMENT.defaults();
         break;

      case "gateway":
      case "task":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.type] =
            ELEMENT.defaults();
         break;
   }
});

module.exports = {
   /*
    * @function allTasks
    * return all the currently defined ABProcessTasks in an array.
    * @return [{ABProcessTask},...]
    */
   allTasks: function () {
      var tasks = [];
      for (var t in Tasks) {
         tasks.push(Tasks[t]);
      }
      return tasks;
   },

   /*
    * @function newTask
    * return an instance of an ABProcessTask based upon the values.type value.
    * @return {ABProcessTask}
    */
   newTask: function (values, process, AB) {
      if (values.key) {
         return new Tasks[values.key](values, process, AB);
      } else {
         //// TODO: what to do here?
      }
   },

   DiagramReplaceDefinitionsForType: function (type) {
      var definitions = AllProcessElements.filter((e) => {
         return e.defaults().category == type;
      }).map((e) => {
         return e.DiagramReplace();
      });
      return definitions;
   },

   StartEvents: function () {
      return this.DiagramReplaceDefinitionsForType("start");
   },

   Gateways: function () {
      return this.DiagramReplaceDefinitionsForType("gateway");
   },

   Tasks: function () {
      return this.DiagramReplaceDefinitionsForType("task");
   },

   EndEvents: function () {
      return this.DiagramReplaceDefinitionsForType("end");
   },

   definitionForElement: function (element) {
      // pull the key from the embedded .eventDefinition
      // if there is one
      var key = null;
      if (element.businessObject.eventDefinitions) {
         var def = element.businessObject.eventDefinitions[0];
         if (def) {
            key = def.$type;
         }
      }

      // if not, then just use the base .type
      if (!key) {
         key = element.type;
      }

      return DEFINITIONTYPES[key];
   },
};


/***/ }),

/***/ 19929:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessElementCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ABMLClass = __webpack_require__(/*! ../../../platform/ABMLClass */ 97069);

module.exports = class ABProcessTaskCore extends ABMLClass {
   constructor(attributes, process, AB, defaultValues) {
      super(["label"], AB);

      this.defaults = defaultValues || { key: "core", icon: "core" };
      // {obj} .defaults
      // a value hash of default values for an ABProcessTask
      // NOTE: needs to be set before .fromValues()

      this.fromValues(attributes);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }
      // {ABProcess} .process
      // The parent ABProcess this process element is a part of.

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
      this.state = null;
   }

   ///
   /// Static Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // ABDefinition Related fields:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process.task.unknown";

      // ABProcess related fields:
      this.key = attributes.key || this.defaults.key || "?key?";
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneDiagramID = attributes.laneDiagramID || "?laneID?";
      // laneDiagramID : connects to the parent object that defines any
      //      default User information for the Task.  In our case, it
      //      might be a {ABProcessParticipant} object, or a {ABProcessLane}
      //      object.  by default, a diagram's Participant obj doesn't define
      //      any lanes, and therefore can provide that info.  Once a lane
      //      is added, however, an object is assigned to it, and the
      //      Lane will provide that info.

      // initialize any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            if (typeof attributes[s] == "undefined") this[s] = null;
            else this[s] = attributes[s];
         });
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneDiagramID",
         "key",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      // save any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            data[s] = this[s];
         });
      }

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * errorConfig()
    * Respond with an error when expected configuration parameters do not
    * pull data.
    * @param {obj} instance
    *        the instance data of this task
    * @param {string} msg
    *        the display message for this error.
    * @param {array[string]} fields
    *        an array of parameter keys that should be included in the error
    *        for additional information.
    * @return {Promise.reject(error)}
    */
   errorConfig(instance, msg, fields = []) {
      this.log(instance, msg);
      var error = new Error(`${this.type}: ${msg}`);
      var info = { task: this };
      if (!Array.isArray(fields)) fields = [fields];
      fields.forEach((field) => {
         info[field] = this[field];
      });
      this.AB.notify.builder(error, info);
      return Promise.reject(error);
   }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context
    *        the context data of the process instance
    * @param {obj} defaults
    *        any values to include from our child classes
    * @param {obj} val
    *        any values to override the default state
    */
   initState(context, defaults, val) {
      defaults = defaults || {};
      if (!val) {
         val = defaults;
         defaults = {};

         // in this case, then auto initi blank instanceValues:
         if (this.defaults && this.defaults.instanceValues) {
            this.defaults.instanceValues.forEach((v) => {
               defaults[v] = null;
            });
         }
      }

      context.taskState = context.taskState || {};

      // don't overwrite your settings if they already exist:
      if (!context.taskState[this.diagramID]) {
         context.taskState[this.diagramID] = {
            initialized: true,
            status: "initialized",
         };
         for (var d in defaults) {
            context.taskState[this.diagramID][d] = defaults[d];
         }
         for (var v in val) {
            context.taskState[this.diagramID][v] = val[v];
         }
      }
   }

   /**
    * log()
    * enter a log in the current process instance
    * @param {obj} instance  the current ABProcessInstance
    * @param {...} ...allArgs the remaining parameters sent to the log
    */
   log(instance, ...allArgs) {
      var text = `${this.diagramID} : ${
         this.name ? this.name : this.key
      } : ${allArgs.join(" ")}`;
      instance.log.push(text);
   }

   /**
    * myLane()
    * return the ABProcessParticipant | ABProcessLane element we are
    * in.
    * @return {ABProcessParticipant|ABProcessLane}
    */
   myLane() {
      return this.process.elementForDiagramID(this.laneDiagramID);
   }

   /**
    * myState()
    * return the current state values for this ABProcessTask
    * @param {obj} instance  the current ABProcessInstance
    * @return {obj}
    */
   myState(instance) {
      return instance.context.taskState[this.diagramID];
   }

   /**
    * nextTasks()
    * follow the current instance diagram and return the next task(s)
    * after this task.
    * @param {obj} instance  the current ABProcessInstance
    * @return {array}  [ABProcessTask, ...] or {null} if an error
    */
   nextTasks(instance) {
      var nextTasks = [];

      var myDiagramObj = instance.hashDiagramObjects[this.diagramID];
      if (!myDiagramObj) {
         var error = new Error(
            `Configuration Error: Did not find my definition for dID[${this.diagramID}]`
         );
         this.onError(instance, error);
         return null;
      }

      // myDiagramObj :
      // {
      //     "bpmn2:outgoing": [{"_text": "SequenceFlow_00fbxm3"} ...],
      //     "_attributes": {id: "StartEvent_1"},
      //     "_type": "start"
      // }

      // find my possible exits:
      var exitFlows = myDiagramObj["bpmn2:outgoing"];
      if (!exitFlows) {
         var error = new Error(
            `Configuration Error: Did not find any outgoing flows for dID[${this.diagramID}]`
         );
         this.AB.notify.builder(error, { task: this });
         this.onError(instance, error);
         return null;
      }

      if (!Array.isArray(exitFlows)) {
         exitFlows = [exitFlows];
      }

      var tasksFromFlow = (flow) => {
         // follow a flow and grab each of it's exit tasks
         // place them into nextTasks[];

         var flowObj = instance.hashDiagramObjects[flow["_text"]];
         if (!flowObj) return;

         var targetIDs = flowObj["_attributes"]["targetRef"];
         if (!targetIDs) return;

         if (!Array.isArray(targetIDs)) {
            targetIDs = [targetIDs];
         }

         targetIDs.forEach((tid) => {
            var targetTask = this.process.elementForDiagramID(tid);
            if (targetTask) {
               if (nextTasks) {
                  nextTasks.push(targetTask);
               }
            } else {
               var error = new Error(
                  `Configuration Error: No ProcessTask instance for diagramID[${tid}]`
               );
               this.AB.notify.builder(error, { task: this });
               this.onError(instance, error);
               nextTasks = null;
            }
         });
      };

      exitFlows.forEach((f) => {
         tasksFromFlow(f);
      });

      return nextTasks;
   }

   /**
    * onError()
    * perform the following actions (log it) on an error.
    * @param {obj} instance  the current ABProcessInstance
    * @param {Error} error
    */
   onError(instance, error) {
      if (error) {
         var text = `${error.toString()}`;
         this.log(instance, text);
      }
      var myState = this.myState(instance);
      myState.status = "error";
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return null;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      return null;
   }

   /**
    * hashProcessDataValues()
    * return a hash of live Process Data Values
    * @param {obj} instance
    * @return {array} | null
    */
   hashProcessDataValues(instance) {
      var listDataFields = this.process.processDataFields(this);
      var currentProcessValues = {};
      listDataFields.forEach((f) => {
         currentProcessValues[f.key] = this.process.processData(this, [
            instance,
            f.key,
         ]);
      });
      return currentProcessValues;
   }

   /**
    * reset()
    * prepare this task to run again if it was already completed.
    *
    * This might happen in a process where a loop is formed and tasks
    * are repeated until a certain outcome.
    *
    * @param {obj} instance  the current ABProcessInstance
    */
   reset(instance) {
      // a task wants to run me.  Possibly again.
      var myState = this.myState(instance);

      // if I haven't setup my state (why?) then just
      // do that again:
      if (!myState) {
         this.initState(instance.context);
      } else {
         // if I have already "completed" and we are being
         // asked to run again (it's possible)
         if (myState.status == "completed" || myState.status == "error") {
            // remove my current state
            delete instance.context.taskState[this.diagramID];

            // store a new state in the context
            this.initState(instance.context);

            // remember our previous state
            var newState = this.myState(instance);
            newState._prevState = myState;
            this.log(instance, " Reset() called. Running again. ");
         }
      }
   }

   /**
    * stateCompleted()
    * mark this task has having completed.
    * @param {obj} instance  the current ABProcessInstance
    */
   stateCompleted(instance) {
      var myState = this.myState(instance);
      myState.status = "completed";
   }

   /**
    * stateUpdate()
    * update my state values with the given values data
    * @param {obj} instance  the current ABProcessInstance
    * @param {obj} values    the new state values
    */
   stateUpdate(instance, values) {
      values = values || {};
      var myState = this.myState(instance);
      for (var v in values) {
         myState[v] = values[v];
      }
   }

   /**
    * wantToDoSomething()
    * determine if this task still has something to do.
    * @param {obj} instance  the instance data of the process we are working on
    * @return {bool} true if there is still pending actions
    */
   wantToDoSomething(instance) {
      var state = this.myState(instance);
      if (state) {
         return state.status != "completed" && state.status != "error";
      } else {
         // my state wasn't defined?
         console.warn(
            "ABProcessTaskCore:wantToDoSomething(): called without having initialized our state first.",
            instance
         );
         // initialize our state and try again
         this.initState(instance.context);
         return this.wantToDoSomething(instance);
      }
   }

   get startElements() {
      let startElems =
         this.process.elements(
            (elem) => elem && elem.defaults && elem.defaults.category == "start"
         ) || [];
      return startElems;
   }

   get previousElements() {
      return this.process.connectionPreviousTask(this);
   }

   get objectOfStartElement() {
      const startElem = this.startElements[0];
      if (!startElem) return null;

      return this.AB.objectByID(startElem.objectID);
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElements[0];
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }
};


/***/ }),

/***/ 15197:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessEndCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessTaskEndDefaults = {
   category: "end",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "stop", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "End",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTaskEndCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.end";
      super(attributes, process, AB, ABProcessTaskEndDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEndDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Terminate End Event",
         actionName: "replace-with-terminate-end",
         className: "bpmn-icon-end-event-terminate",
         target: {
            type: "bpmn:EndEvent",
            eventDefinitionType: "bpmn:TerminateEventDefinition",
         },
      };
   }

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         triggered: false,
      };

      super.initState(context, myDefaults, val);
   }

   /**
    * nextTasks()
    * return the next tasks to be run after this task is complete.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve([])
    */
   nextTasks(instance) {
      // I'm an End Event.  There are no nextTasks()
      return [];
   }
};


/***/ }),

/***/ 32889:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessGatewayExclusiveCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessGatewayExclusiveDefaults = {
   category: "gateway",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GatewayExclusive",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["conditions"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessGatewayExclusiveCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.gateway.exclusive";
      super(attributes, process, AB, ABProcessGatewayExclusiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessGatewayExclusiveDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Exclusive Gateway",
         actionName: "replace-with-exclusive-gateway",
         className: "bpmn-icon-gateway-xor",
         target: {
            type: "bpmn:ExclusiveGateway",
         },
      };
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        ABProcessGatewayExclusiveDefaults.fields.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessGatewayExclusiveDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 52399:
/*!*****************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskEmailCore.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessTaskEmailDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "to",
      "from",
      "subject",
      "message",
      "toCustom",
      "fromCustom",
      "toUsers",
      "fromUsers",
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "email", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Email",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTaskEmailCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.email";
      super(attributes, process, AB, ABProcessTaskEmailDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEmailDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Send Task",
         actionName: "replace-with-send-task",
         className: "bpmn-icon-send",
         target: {
            type: "bpmn:SendTask",
         },
      };
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         this[f] = attributes[f];
      });
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         to: [],
         from: [],
         subject: this.subject,
         message: this.message,
      };

      super.initState(context, myDefaults, val);
   }
};


/***/ }),

/***/ 7912:
/*!********************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var AccountingBatchProcessingDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingBatchProcessing",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectBatch",
      "processBatchValue",
      "fieldBatchEntries",
      "fieldBatchFinancialPeriod",
      "objectJE",
      "fieldJEAccount",
      "fieldJERC",
      "fieldJEStatus",
      "fieldJEStatusComplete",
      "objectBR",
      "fieldBRFinancialPeriod",
      "fieldBRAccount",
      "fieldBRRC",
      "fieldBREntries",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingBatchProcessingCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.batchProcessing";
      super(attributes, process, AB, AccountingBatchProcessingDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingBatchProcessingDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 20939:
/*!************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var AccountingFPCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPValue",
      "objectFP",
      "objectGL",
      "objectAcc",
      "fieldFPStart",
      "fieldFPOpen",
      "fieldFPStatus",
      "fieldFPActive",
      "fieldGLStarting",
      "fieldGLRunning",
      "fieldGLAccount",
      "fieldGLRc",
      "fieldGLDebit",
      "fieldGLCredit",
      "fieldAccType",
      "fieldAccAsset",
      "fieldAccExpense",
      "fieldAccLiabilities",
      "fieldAccEquity",
      "fieldAccIncome",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingFPCloseCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpClose";
      super(attributes, process, AB, AccountingFPCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 31166:
/*!****************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var AccountingFPYearCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPYearClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPYearValue",
      "objectFPYear",
      "objectFPMonth",
      "objectGL",
      "objectAccount",
      "valueFundBalances",
      "valueNetIncome",
      "fieldFPYearStart",
      "fieldFPYearEnd",
      "fieldFPYearStatus",
      "fieldFPYearActive",
      "fieldFPMonthStart",
      "fieldFPMonthEnd",
      "fieldGLStartBalance",
      "fieldGLRunningBalance",
      "fieldGLrc",
      "fieldAccNumber",
      "fieldAccType",
      "fieldAccTypeIncome",
      "fieldAccTypeExpense",
      "fieldAccTypeEquity",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingFPYearCloseCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpYearClose";
      super(attributes, process, AB, AccountingFPYearCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPYearCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 69814:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

let AccountingJEArchiveDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "archive", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingJEArchive",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processBatchValue",
      "objectBatch",
      "objectBalance",
      "objectJE",
      "objectJEArchive",

      "fieldBatchFiscalMonth",
      "fieldJeAccount",
      "fieldJeRC",
      "fieldJeArchiveBalance",
      "fieldBrFiscalMonth",
      "fieldBrAccount",
      "fieldBrRC",
      "fieldsMatch",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingJEArchiveCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.jeArchive";
      super(attributes, process, AB, AccountingJEArchiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingJEArchiveDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 50689:
/*!****************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceCalculateCore.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

let CalculateDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "calculator", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Calculate",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["formulaText"]
};

module.exports = class CalculateTaskCore extends ABProcessElement {
   constructor(attributes, process, application) {
      attributes.type = attributes.type || "process.task.service.calculate";
      super(attributes, process, application, CalculateDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return CalculateDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return {
         key: `${this.id}.value`,
         label: `${this.label}->Value`
      };
   }
};


/***/ }),

/***/ 69376:
/*!*******************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceCore.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessTaskServiceCore
 *
 * This defines the base Service Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a ServiceTask performs a dedicated operation on the server.
 *  - performing a query, looking up data, etc...
 *
 */
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessTaskServiceDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskService",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskServiceCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service";
      super(attributes, process, AB, ABProcessTaskServiceDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Service Task",
         actionName: "replace-with-service-task",
         className: "bpmn-icon-service",
         target: {
            type: "bpmn:ServiceTask",
         },
      };
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 98856:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

const ABProcessTaskGetResetPasswordUrlDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GetResetPasswordUrl",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["email"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskGetResetPasswordUrlCore extends (
   ABProcessElement
) {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.getResetPasswordUrl";
      super(attributes, process, AB, ABProcessTaskGetResetPasswordUrlDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskGetResetPasswordUrlDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return {
         key: `${this.id}.url`,
         label: `${this.label}->URL`,
      };
   }
};


/***/ }),

/***/ 24858:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceInsertRecordCore.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

let InsertRecordDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "InsertRecord",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectID",
      "fieldValues",
      "isRepeat",
      "repeatMode",
      "repeatColumn",
   ],
};

module.exports = class InsertRecordCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.insertRecord";
      super(attributes, process, AB, InsertRecordDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return InsertRecordDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.isRepeat = JSON.parse(attributes.isRepeat || false);
   }

   get startElement() {
      let startElem = this.process.elements(
         (elem) => elem && elem.defaults && elem.defaults.category == "start"
      )[0];
      return startElem;
   }

   get previousElement() {
      return this.process.connectionPreviousTask(this)[0];
   }

   get objectOfStartElement() {
      let startElem = this.startElement;
      if (!startElem) return null;

      let startElemObj = this.AB.objectByID(startElem.objectID);
      return startElemObj;
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElement;
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }

   get fieldRepeat() {
      let obj = this.objectOfStartElement;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.repeatColumn)[0];
   }

   /*
     fromValues(attributes) {
         /*
         {
             id: uuid(),
             name: 'name',
             type: 'xxxxx',
             json: "{json}"
         }
         * /
         super.fromValues(attributes);
 
         AccountingBatchProcessingDefaults.settings.forEach((f) => {
             this[f] = attributes[f];
         });
     }
     */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
     toObj() {
         var data = super.toObj();
 
         AccountingBatchProcessingDefaults.settings.forEach((f) => {
             data[f] = this[f];
         });
 
         return data;
     }
     */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
     initState(context, val) {
         var myDefaults = {
             instanceVariable1: null,
             instanceVariable2: null
         };
 
         super.initState(context, myDefaults, val);
     }
     */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
     processDataFields() {
         // in this Task, we can return the Response to the UserForm
         return [
             {
                 key: `${this.id}.[someInstanceVariableHere]`,
                 label: `${this.label}->Response`
             }
         ];
     }
     */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
     processData(instance, key) {
         var parts = key.split(".");
         if (parts[0] == this.id) {
             var myState = this.myState(instance);
             return myState[parts[1]];
         }
         return null;
     }
     */
};


/***/ }),

/***/ 35002:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceQueryCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

const ABQLManager = __webpack_require__(/*! ../../../platform/ql/ABQLManager.js */ 46370);

var ABProcessTaskServiceQueryDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskServiceQuery",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["qlObj"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskServiceQueryCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.query";
      super(attributes, process, AB, ABProcessTaskServiceQueryDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceQueryDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Before we make instances of qlObj:
      this._datasources = [];

      // comvert our qlObj into an ABQLxxx instance.
      if (this.qlObj) {
         this.qlObj = ABQLManager.fromAttributes(this.qlObj, this, this.AB);
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      // convert qlObj into obj format:
      if (this.qlObj) {
         data.qlObj = this.qlObj.toObj();
      }

      return data;
   }

   registerDatasource(obj) {
      this._datasources.push(obj);
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // in this Task, we can return the Response to the UserForm
      var fields = null;
      if (this._datasources.length > 0) {
         fields = [];
         this._datasources.forEach((s) => {
            var param = s.processDataField(this.id, this.label);
            if (param) {
               fields.push(param);
            }
         });
      }
      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      var parts = key.split(".");
      if (parts[0] == this.id) {
         var myState = this.myState(instance);
         return myState[parts[1]];
      }
      return null;
   }
};


/***/ }),

/***/ 36146:
/*!**********************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskSubProcessCore.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

let SubProcessDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "object-group", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "SubProcess",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "isEnable",
      "parameterId",
      "connectionAttrs",
      "elementIDs",
      "loopType",
   ],
};

module.exports = class SubProcessCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.subProcess";
      super(attributes, process, AB, SubProcessDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return SubProcessDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "Sub Process",
         actionName: "replace-with-subprocess",
         className: "bpmn-icon-subprocess-expanded",
         target: {
            type: "bpmn:SubProcess",
            isExpanded: true,
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Convert string to boolean
      this.isEnable = this.isEnable == null ? true : JSON.parse(this.isEnable);

      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         let ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         }
      });

      this._connections = attributes.connectionAttrs || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let data = super.toObj();

      data.elementIDs = [];
      for (let e in this._elements) {
         data.elementIDs.push(this._elements[e].id);
      }

      data.connectionAttrs = this._connections;

      return data;
   }

   /**
    * @method processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      if (this.parameterId == null) return [];

      let dataFieldOpt = (this.process.processDataFields(this) || []).filter(
         (opt) => opt.key == this.parameterId
      )[0];
      if (dataFieldOpt == null) return [];

      let result = [];

      // Connect field type
      if (
         dataFieldOpt.field &&
         dataFieldOpt.field.key == "connectObject" &&
         dataFieldOpt.field.datasourceLink &&
         dataFieldOpt.field.datasourceLink.fields
      ) {
         result.push({
            key: `${this.id}.uuid.subProcess`,
            label: `${this.label}->Repeat Data.ID`,
            object: dataFieldOpt.field.datasourceLink,
         });

         dataFieldOpt.field.datasourceLink.fields().forEach((f) => {
            result.push({
               key: `${this.id}.${f.id}.subProcess`,
               label: `${this.label}->Repeat Data.${f.label}`,
               field: f,
               object: f.object,
            });
         });
      }
      // Other field types
      else {
         result.push({
            key: dataFieldOpt.field
               ? `${this.id}.${dataFieldOpt.field.id}.subProcess`
               : `${this.id}.subProcess`,
            label: `${this.label}->Repeat Data`,
            field: dataFieldOpt.field,
            object: dataFieldOpt.object,
         });
      }

      let previousFields = this.process.processDataFields.call(
         this,
         currElement
      );
      if (previousFields && previousFields.length > 0) {
         result = result.concat(previousFields);
      }

      return result;
   }

   /**
    * @method processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      let instance = params[0];
      let key = params[1];
      let data;

      if (instance && key && key.startsWith && key.startsWith(this.id)) {
         let fieldId = key.split(".")[2];
         let myState = this.myState(instance);
         let stateData = myState ? myState.data : null;
         data = stateData;

         if (stateData && fieldId) {
            let dataFieldOpt = (
               this.process.processDataFields(this) || []
            ).filter((opt) => opt.key == this.parameterId)[0];

            if (
               dataFieldOpt &&
               dataFieldOpt.field &&
               dataFieldOpt.field.key == "connectObject"
            ) {
               if (!Array.isArray(stateData)) stateData = [stateData];

               // Extract data
               data = stateData.map((item) => {
                  if (fieldId == "uuid" || fieldId == "id") {
                     return item.uuid || item.id;
                  } else if (dataFieldOpt.field.datasourceLink) {
                     let returnField = dataFieldOpt.field.datasourceLink.fields(
                        (f) => f.id == fieldId
                     )[0];
                     if (returnField) return item[returnField.columnName];
                     else return item;
                  }
               });
            }
         }
      }

      if (data == null)
         data = this.process.processData.call(this, currElement, params);

      if (data == null) data = this.process.processData(this, params);

      return data;
   }

   //
   // Diagram Elements
   //

   /**
    * @method connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn) {
      return this.process.connections.call(this, fn);
   }

   /**
    * @method connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      if (!dID) return;

      return this.process.connectionForDiagramID.call(this, dID);
   }

   /**
    * @method connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      if (!dID) return;

      return this.process.connectionsIncoming.call(this, dID);
   }

   /**
    * @method connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      if (!dID) return;

      return this.process.connectionsOutgoing.call(this, dID);
   }

   /**
    * @method connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      if (!element) return;

      this.process.connectionRemove.call(this, element);
   }

   /**
    * @method connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      if (!element) return;

      return this.process.connectionSimplyElement.call(this, element);
   }

   /**
    * @method connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      if (!element) return;

      this.process.connectionUpsert.call(this, element);
   }

   /**
    * @method connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      if (!currElement) return;

      return this.process.connectionPreviousTask.call(this, currElement);
   }

   /**
    * @method elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      return this.process.elements.call(this, fn);
   }

   /**
    * @method elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      if (!element) return;

      this.process.elementAdd.call(this, element);
   }

   /**
    * @method elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      if (!dID) return null;

      return this.process.elementForDiagramID.call(this, dID);
   }

   /**
    * @method elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      if (!def) return;

      this.process.elementRemove.call(this, def);
   }
};


/***/ }),

/***/ 42501:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserApprovalCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

const ABFieldList = __webpack_require__(/*! ../../../platform/dataFields/ABFieldList.js */ 69319);

var ABProcessTaskApprovalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Approval",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "formBuilder"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskUserApprovalCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user.approval";
      super(attributes, process, AB, ABProcessTaskApprovalDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskApprovalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      function fixBoolean(obj) {
         if (obj) {
            Object.keys(obj).forEach((k) => {
               if (obj[k] == "false") {
                  obj[k] = false;
               } else if (obj[k] == "true") {
                  obj[k] = true;
               } else if (typeof obj[k] == "object") {
                  fixBoolean(obj[k]);
               }
            });
         }
      }
      fixBoolean(this.formBuilder);
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   /*     
    toObj() {
        var data = super.toObj();

        ABProcessTaskApprovalDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
*/
   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {};
        ABProcessTaskApprovalDefaults.instanceValues.forEach((v) => {
            myDefaults[v] = null;
        });

        super.initState(context, myDefaults, val);
    }
*/

   /*
    * preProcessFormIOComponents()
    * we need to parse the form.io components to ensure the proper columnName
    * and labels are being used. We also will translate the columnNames at this
    * point in the code
    */
   preProcessFormIOComponents() {
      var fields = this.process.processDataFields(this);
      if (fields && this.formBuilder && this.formBuilder.components) {
         this.formBuilder.components.forEach((c) => {
            if (c.abFieldID) {
               fields.filter((entry) => {
                  if (entry.field && entry.field.id == c.abFieldID) {
                     c.label = entry.field.label;
                     c.key = entry.key;
                     if (
                        c.data &&
                        c.data.values &&
                        entry.field.settings.options
                     ) {
                        var vals = [];
                        entry.field.settings.options.forEach((opt) => {
                           vals.push({
                              label: opt.text,
                              value: opt.id,
                           });
                        });
                        c.data.values = vals;
                     }
                  }
               });
            } else if (c.components && c.components.length) {
               c.key = c.path;
               c.components.forEach((o) => {
                  if (o.abFieldID) {
                     // these are plucked conneted values
                     // gather up all their fields to be used
                     var pluck = fields.filter((f) => {
                        return f.key == c.path;
                     })[0];
                     if (!pluck) return;
                     pluck.object.fields().filter((entry) => {
                        if (entry && entry.id == o.abFieldID) {
                           o.label = entry.label;
                           o.key = entry.columnName;
                           if (
                              o.data &&
                              o.data.values &&
                              entry.settings.options
                           ) {
                              var vals = [];
                              entry.settings.options.forEach((opt) => {
                                 vals.push({
                                    label: opt.text,
                                    value: opt.id
                                 });
                              });
                              o.data.values = vals;
                           }
                        }
                     });
                  }
               });
            }
         });
      }
      return this.formBuilder;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // we need to get the button events defined by the form.io formBuilder
      var options = [];
      this.formBuilder.components.forEach((comp) => {
         if (comp.type == "button" && comp.action == "event" && comp.event) {
            options.push({
               id: comp.event,
               text: comp.label,
            });
         }
      });
      // in this Task, we can return the Response to the UserForm
      // The Response can be in the form of a List Field, with one or more
      // return options.

      var myID = this.diagramID;

      // create an ABFieldList object:
      // make sure the options follow what is currently defined for our
      // responses:
      var myObj = this.AB.objectNew({});
      var listField = new ABFieldList(
         {
            id: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            columnName: `${myID}.userFormResponse`,
            settings: {
               options: options,
            },
         },
         myObj
      );

      return [
         {
            key: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            field: listField,
            object: null,
         },
      ];
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      if (key) {
         var parts = key.split(".");
         if (parts[0] == this.diagramID) {
            var myState = this.myState(instance);
            return myState[parts[1]];
         }
      }
      return null;
   }
};


/***/ }),

/***/ 96493:
/*!****************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserCore.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessTaskUserCore
 *
 * This defines the base User Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a UserTask expects a human user to perform an action.  These
 * actions are in the possible forms:
 *  - confirm offline action
 *  - approve data
 *  - fill out a form
 *
 */

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessTaskUserDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "user", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskUser",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskUserCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user";
      super(attributes, process, AB, ABProcessTaskUserDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "User Task",
         actionName: "replace-with-user-task",
         className: "bpmn-icon-user",
         target: {
            type: "bpmn:UserTask",
         },
      };
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         roles: [],
         ui: null,
      };

      super.initState(context, myDefaults, val);
   }
};


/***/ }),

/***/ 39483:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserExternalCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

const ABProcessTaskUserExternalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "External",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "url"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

const settings = {
   who: "0",
   toUsers: null,
   url: "",
};

module.exports = class ABProcessTaskUserExternalCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      for (const key in settings)
         attributes[key] = attributes[key] ?? settings[key];
      super(
         Object.assign(
            {
               type: "process.task.service.external",
            },
            attributes
         ),
         process,
         AB,
         ABProcessTaskUserExternalDefaults
      );

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserExternalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return [
         {
            key: `${this.id}.userFormResponse`,
            label: `${this.label}->Response`,
         },
      ];
   }
};


/***/ }),

/***/ 41600:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 21073);

var ABProcessTriggerDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Trigger",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTriggerCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTriggerDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTriggerDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Signal Start Event",
         actionName: "replace-with-signal-start",
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "bpmn:SignalEventDefinition",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.triggerKey = attributes.triggerKey || "triggerKey.??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.triggerKey = this.triggerKey;

      return data;
   }
};


/***/ }),

/***/ 55364:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerLifecycleCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTrigger = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 46732);

var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "objectID",
      "lifecycleKey" /* , "triggerKey" is tracked in ABProcessTrigger */,
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TriggerLifecycle",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTriggerLifecycle extends ABProcessTrigger {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTaskTriggerLifecycleDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Object Lifecycle Trigger",
         actionName: "replace-with-signal-lifecycle-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalLifecycle",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.objectID = attributes.objectID || "objID.??";
      this.lifecycleKey = attributes.lifecycleKey || "lifecycle.key??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.objectID = this.objectID;
      data.lifecycleKey = this.lifecycleKey;
      return data;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      var fields = null;
      if (this.objectID) {
         fields = [];
         var object = this.AB.objectByID(this.objectID);
         if (object) {
            var myID = this.diagramID;
            object.fields().forEach((field) => {
               fields.push({
                  key: `${myID}.${field.id}`,
                  label: `${this.label}->${object.label}->${field.label}`,
                  field,
                  object,
               });
            });
            fields.push({
               key: `${myID}.uuid`,
               label: `${this.label}->${object.label}`,
               field: null,
               object,
            });
         } else {
            // OK, so we have an this.objectID defined, but we can't find it.
            // that's something we need to alert:
            var error = new Error(
               `ABProcessTriggerLifecycleCore.processDataFields():TaskID[${this.id}]: could not find referenced object by ID [${this.objectID}]`
            );
            this.AB.error(error);
         }
      }
      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      var parts = key.split(".");
      if (parts[0] == this.diagramID) {
         var myState = this.myState(instance);
         if (myState["data"]) {
            var object = this.AB.objectByID(this.objectID);
            var field = object.fields((f) => {
               return f.id == parts[1];
            })[0];
            if (field) {
               if (parts[2]) {
                  return field[parts[2]].call(field, myState["data"]);
               } else {
                  // instance.context.data[field.column_name];
                  // if field is "calculate" or "TextFormula" data is not stored
                  // in data base and we need to run format method
                  if (["calculate", "TextFormula"].indexOf(field.key) != -1) {
                     return field.format(myState["data"]);
                  } else if (field.key == "connectObject") {
                     return (
                        myState["data"][field.columnName] ||
                        myState["data"][field.relationName()]
                     );
                  } else {
                     return myState["data"][field.columnName];
                  }
               }
            } else if (parts[1] == "uuid") {
               return myState["data"]["uuid"];
            } else {
               // parts[1] should be a field.id
               var object = this.AB.objectByID(this.objectID);
               var field = object.fields((f) => {
                  return f.id == parts[1];
               })[0];
               if (field) {
                  if (parts[2]) {
                     return field[parts[2]].call(field, myState["data"]);
                  } else {
                     // instance.context.data[field.column_name];
                     return myState["data"][field.columnName];
                  }
               }
            }
         }
      }
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      var objects = null;
      if (this.objectID) {
         objects = [this.AB.objectByID(this.objectID)];
      }
      return objects;
   }
};


/***/ }),

/***/ 97535:
/*!********************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerTimerCore.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTrigger = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 46732);

var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "repeatEvery",
      "repeatTime",
      "repeatDaily",
      "repeatWeekly",
      "repeatMonthly",
      "isEnabled"
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "clock-o", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TimerStartEvent",
   // key: {string}
   // unique key to reference this specific Task

   repeatEvery: "daily",
   repeatTime: "01:00",
   repeatDaily: "day",
   repeatWeekly: "FRI",
   repeatMonthly: "last",
   isEnabled: true
};

module.exports = class ABProcessTriggerTimer extends ABProcessTrigger {
   constructor(attributes, process, application) {
      attributes.type = attributes.type || "trigger";
      super(
         attributes,
         process,
         application,
         ABProcessTaskTriggerLifecycleDefaults
      );
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Timer Start Event",
         actionName: "replace-with-signal-timer-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-timer",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalTriggerTimer"
         }
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.repeatEvery =
         attributes.repeatEvery ||
         ABProcessTaskTriggerLifecycleDefaults.repeatEvery;

      this.repeatDaily =
         attributes.repeatDaily ||
         ABProcessTaskTriggerLifecycleDefaults.repeatDaily;

      this.repeatWeekly =
         attributes.repeatWeekly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatWeekly;

      this.repeatMonthly =
         attributes.repeatMonthly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatMonthly;

      // Convert UTC to local time
      if (attributes.repeatTime) {
         let timeVals = attributes.repeatTime.split(":");
         let currDate = new Date();
         currDate.setUTCHours(timeVals[0]);
         currDate.setUTCMinutes(timeVals[1]);
         this.repeatTime = `${currDate.getHours()}:${currDate.getMinutes()}`;
      } else {
         this.repeatTime = ABProcessTaskTriggerLifecycleDefaults.repeatTime;
      }

      this.isEnabled = JSON.parse(
         attributes.isEnabled || ABProcessTaskTriggerLifecycleDefaults.isEnabled
      );
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.repeatEvery = this.repeatEvery;
      data.repeatDaily = this.repeatDaily;
      data.repeatWeekly = this.repeatWeekly;
      data.repeatMonthly = this.repeatMonthly;

      // Convert local time to UTC
      data.repeatTime = this.repeatTime;
      if (data.repeatTime && data.repeatTime instanceof Date) {
         data.repeatTime = `${data.repeatTime.getUTCHours()}:${data.repeatTime.getMinutes()}`;
      }

      data.isEnabled = this.isEnabled;

      return data;
   }

   getCronExpression() {
      let timeVals = this.repeatTime.split(":");
      let second = "*";
      let minute = timeVals[1];
      let hour = timeVals[0];
      let day;
      let month;
      let dayWeek;
      let year = "*";

      switch (this.repeatEvery) {
         case "daily":
            day = "*";
            month = "*";
            dayWeek = this.repeatDaily == "weekday" ? "1-5" : "*";
            break;
         case "weekly":
            day = "*";
            month = "*";
            dayWeek = this.repeatWeekly;
            break;
         case "monthly":
            day = this.repeatMonthly;
            month = "*";
            dayWeek = "*";
            break;
      }

      return `${second} ${minute} ${hour} ${day} ${month} ${dayWeek} ${year}`;
   }
};



/***/ }),

/***/ 52983:
/*!****************************************!*\
  !*** ./AppBuilder/core/ql/ABQLCore.js ***!
  \****************************************/
/***/ ((module) => {

/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */

class ABQLCore {
   constructor(attributes, parameterDefinitions, prevOP, task, AB) {
      // manage the incoming Parameter Definitions
      if (!Array.isArray(parameterDefinitions)) {
         parameterDefinitions = [parameterDefinitions];
      }
      this.parameterDefinitions = parameterDefinitions;

      this.object = prevOP ? prevOP.object : null;
      // {ABObject}
      // The current {ABObject} the current Query Language Operation is associated
      // with.

      // if the previous Operation defined an .objectOut then our .object is THAT
      // one.
      if (prevOP && prevOP.objectOut) {
         this.object = prevOP.objectOut;
      }

      this.prevOP = prevOP;
      this.task = task;
      // {ABProcessTaskxxx}
      // This is running under a specific ABProcessTaskServiceQuery.  When
      // searching for data from the Process, we must go through this.task
      // to do so.

      this.AB = AB;

      this.next = null;

      this.fromAttributes(attributes);
   }

   ///
   /// Instance Methods
   ///

   initObject(attributes) {}

   fromAttributes(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */

      // super.fromValues(attributes);

      // this.entryComplete = attributes.entryComplete || false;
      this.params = attributes.params || {};
      // {hash}
      // The configuration values entered by the AppBuilder UI for this
      // operation.

      this.objectID = attributes.objectID || null;
      // be sure to do a hard lookup if an objectID was saved:
      if (this.objectID) {
         this.object = this.objectLookup(this.objectID);
      }

      this.initObject(attributes);

      if (this.objectID && !this.object) {
         // at least dump a warning here:
         this.AB.notify.developer(
            new Error(
               `ABQLCore.fromAttributes(): unable to initialize ABObject [${this.objectID}]`
            ),
            {
               attributes,
               objectID: this.objectID,
            }
         );
      }

      if (attributes.next) {
         var nextOP = null;
         (this.NextQLOps || this.constructor.NextQLOps).forEach((OP) => {
            if (OP.key == attributes.next.key) {
               nextOP = OP;
            }
         });
         if (nextOP) {
            // exact match, so add next:
            var qlOP = new nextOP(attributes.next, this, this.task, this.AB);
            this.next = qlOP;
         }
      }
   }

   /**
    * @method objectLookup()
    * return a matching {ABObject} that is represented by the given id.
    * NOTE: we will try to match on: our initial .objectID first, then
    * the given objID.
    * NOTE: this will match an object.id as well as object.label
    * @param {string} objID
    */
   objectLookup(objID) {
      return this.AB.objects((o) => {
         var quotedLabel = `"${o.label}"`;
         return (
            // o.id == this.objectID ||
            o.id == objID || quotedLabel.indexOf(objID) == 0
         );
      })[0];
   }

   /**
    * @method availableProcessDataFieldsHash()
    * return a { "field.key" => {processFieldDef} } hash of the currently
    * available fields in the process.
    * @return {obj}
    */
   availableProcessDataFieldsHash() {
      var availableProcessDataFields =
         this.task.process.processDataFields(this.task) || [];
      var hashFieldIDs = {};
      availableProcessDataFields.forEach((f) => {
         if (f.field) {
            hashFieldIDs[f.field.id] = f;
         } else {
            hashFieldIDs[f.key] = f;
         }
      });
      return hashFieldIDs;
   }

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {}

   /**
    * @method toObj()
    * properly compile the current state of this ABQL instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      var obj = {
         key: this.constructor.key,
         // entryComplete: this.entryComplete,
         params: this.params,
         // currQuery: this.currQuery,
         // queryValid: this.queryValid,
         objectID: this.object ? this.object.id : null,
      };

      if (this.next) {
         obj.next = this.next.toObj();
      }

      return obj;
   }
}

module.exports = ABQLCore;


/***/ }),

/***/ 85111:
/*!********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLFindCore.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLFindCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);
const NextQLOps = __webpack_require__(/*! ./ABQLSet.js */ 88409);
// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLFind task is complete.  In this case the {ABQLSet} operations come
// next.  {ABQLSet} operations work on a Set|{Array} or data results.

var ParameterDefinitions = [
   {
      type: "objectConditions",
      name: "cond",
   },
];

class ABQLFindCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLFindCore.key = "find";
ABQLFindCore.label = "find";
ABQLFindCore.NextQLOps = NextQLOps;

module.exports = ABQLFindCore;


/***/ }),

/***/ 98162:
/*!***********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLManagerCore.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLManagerCore
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */

const QLObject = __webpack_require__(/*! ../../platform/ql/ABQLRootObject.js */ 54157);
var QLOps = [QLObject];

var ABQLManagerCore = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current ABFactory we are operating under.
    * @return {ABQL} | null
    */
   fromAttributes: function (attributes, task, AB) {
      if (!attributes) {
         return null;
      }
      var matchingOPs = [];
      ABQLManagerCore.QLOps.forEach((Op) => {
         if (Op.key == attributes.key) {
            matchingOPs.push(Op);
         }
      });
      if (matchingOPs.length == 1) {
         // let this Operation initialize and return the last OP
         // in the chain
         var qlOP = new matchingOPs[0](attributes, task, AB);
         return qlOP;
      } else {
         return null;
      }
   },

   /**
    * @array QLOps
    * An array of the root QL Operations.
    */
   QLOps: QLOps,
};
module.exports = ABQLManagerCore;


/***/ }),

/***/ 37505:
/*!**************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRootObjectCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRootObjectCore
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);

// Define the Operations that can be performed off of a RootObject.
// Each Root Object might have a different set of Operations, so we
// define them here.
const QLFind = __webpack_require__(/*! ../../platform/ql/ABQLFind.js */ 63408);
var NextQLOps = [QLFind];

var ParameterDefinitions = [
   {
      type: "objectName",
      name: "name",
   },
];

class ABQLObjectCore extends ABQL {
   constructor(attributes, task, AB) {
      // NOTE: keep this so we can insert the prevOp == null
      super(attributes, ParameterDefinitions, null, task, AB);
   }

   ///
   /// Instance Methods
   ///
   initObject(attributes) {
      if (!this.object && this.params) {
         var objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type == "objectName";
         });
         if (objNameDef) {
            this.objectID = this.params[objNameDef.name];
            this.object = this.objectLookup(this.objectID);
         }
      }
   }

   toObj() {
      var obj = super.toObj();

      // if we don't have an objectID, but we have an objectName parameter
      // definition then save that as our objectID
      if (!obj.objectID && this.params) {
         var objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type == "objectName";
         });
         if (objNameDef) {
            obj.objectID = this.params[objNameDef.name];
         }
      }
      return obj;
   }
}
ABQLObjectCore.key = "object";
ABQLObjectCore.label = "object";
ABQLObjectCore.NextQLOps = NextQLOps;

module.exports = ABQLObjectCore;


/***/ }),

/***/ 26569:
/*!***************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRow.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRow
 *
 * Defines all the QL operations that can be performed on a Row of data. This is a
 * Single row/instance of an object.
 *
 */

const QLUpdate = __webpack_require__(/*! ../../platform/ql/ABQLRowUpdate.js */ 465);
const QLSave = __webpack_require__(/*! ../../platform/ql/ABQLRowSave */ 47027);
const QLPluck = __webpack_require__(/*! ../../platform/ql/ABQLRowPluck */ 25851);

module.exports = [QLUpdate, QLSave, QLPluck];


/***/ }),

/***/ 29215:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRowPluckCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLRowPluckCore
 *
 * An ABQLRowPluckCore can process a value of data and puck out a specified
 * field to then make an object of values that only contain that field.
 *
 */

const ABQLValue = __webpack_require__(/*! ./ABQLValue.js */ 74842);
// const ABQLSet = require("./ABQLSet.js");
const ABQLSetPluck = __webpack_require__(/*! ../../platform/ql/ABQLSetPluck.js */ 5926);

class ABQLRowPluckCore extends ABQLSetPluck {
   // Dynamic NextQLOps
   get NextQLOps() {
      let nextQLOps = [];
      let field = this.field;
      if (field == null) {
         field = this.object.fieldByID(this.fieldID);
      }

      // Update .NextQLOps WARN: update to static it affects to every ABQLRowPluck instances.
      if (field) {
         // M:1 M:N connect field, then set ABQLSet to next steps
         if (field.key == "connectObject") {
            if (field.settings.linkType == "many") {
               // NOTE: Could not require("./ABQLSet.js") on the top. It returns an empty object. Why ><
               const ABQLSet = __webpack_require__(/*! ./ABQLSet.js */ 88409);
               nextQLOps = ABQLSet;
            } else {
               // return ABQLRow.js
               nextQLOps = this.prevOP.constructor.NextQLOps;
            }
         }
         // Normal field
         else {
            nextQLOps = ABQLValue;
         }
      } else if (this.fieldID == "_PK") {
         nextQLOps = ABQLValue;
      }

      return nextQLOps;
   }
}

ABQLRowPluckCore.key = "row_pluck";
ABQLRowPluckCore.label = "pluck";
ABQLRowPluckCore.NextQLOps = []; // Static NextQLOps

module.exports = ABQLRowPluckCore;


/***/ }),

/***/ 60354:
/*!*************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRowUpdateCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowUpdateCore
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);
// const ABQLRow = require("./ABQLRow.js");

var ParameterDefinitions = [
   {
      type: "objectValues",
      name: "values",
   },
];

class ABQLRowUpdateCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   }

   ///
   /// Instance Methods
   ///
}

ABQLRowUpdateCore.key = "update";
ABQLRowUpdateCore.label = "update record";
ABQLRowUpdateCore.NextQLOps = [];
// NOTE: .NextQLOps => see the #Hack in the constructor

module.exports = ABQLRowUpdateCore;


/***/ }),

/***/ 88409:
/*!***************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSet.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSet
 *
 * Here we define the group of operations that can be performed on a SET of data.
 * A SET is an array of objects/row data.
 *
 */

module.exports = [
   __webpack_require__(/*! ../../platform/ql/ABQLSetFirst.js */ 88593),
   __webpack_require__(/*! ../../platform/ql/ABQLSetPluck.js */ 5926),
   __webpack_require__(/*! ../../platform/ql/ABQLSetSave.js */ 67478)
];


/***/ }),

/***/ 80219:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetFirstCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetFirstCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);
const ABQLRow = __webpack_require__(/*! ./ABQLRow.js */ 26569);
// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLSetFirst task is complete.  In this case the {ABQLRow} operations come
// next.  {ABQLRow} operations work on a single row of data.

class ABQLSetFirstCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, [], prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLSetFirstCore.key = "first";
ABQLSetFirstCore.label = "first";
ABQLSetFirstCore.NextQLOps = ABQLRow;

module.exports = ABQLSetFirstCore;


/***/ }),

/***/ 60512:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetPluckCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetPluckCore
 *
 * An ABQLSetPluck can process a set (array) of data and puck out a specified
 * field to then make an array of values that only contain that field.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);
// const ABQLSet = require("./ABQLSet.js");

var ParameterDefinitions = [
   {
      type: "objectFields",
      name: "field",
   },
];

class ABQLSetPluckCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      // we need to gather our .field and .objectOut before we
      // allow our base class to continue forward:

      this.fieldID = attributes.fieldID;
      this.field = this.object?.fieldByID(this.fieldID);

      if (attributes.objectOutID) {
         this.objectOut = this.objectLookup(attributes.objectOutID);
      }

      super.fromAttributes(attributes);
   }

   toObj() {
      var obj = super.toObj();

      if (this.fieldID) {
         obj.fieldID = this.fieldID;
         if (this.objectOut) {
            obj.objectOutID = this.objectOut.id;
         }
      } else {
         obj.fieldID = this.params.field || null;
         var field = this.object.fieldByID(obj.fieldID);

         if (field?.isConnection) {
            obj.objectOutID = field.datasourceLink.id;
         }
      }
      return obj;
   }
}

ABQLSetPluckCore.key = "set_pluck";
ABQLSetPluckCore.label = "pluck";
ABQLSetPluckCore.NextQLOps = [];

module.exports = ABQLSetPluckCore;


/***/ }),

/***/ 74178:
/*!***********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetSaveCore.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetSaveCore
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15430);

var ParameterDefinitions = [
   {
      type: "taskParam",
      name: "task_param"
   }
];

class ABQLSetSaveCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // TODO: register with the task that we can provide data.
      if (this.taskParam) {
         task.registerDatasource(this);
         this.registered = true;
      }
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      super.fromAttributes(attributes);
      this.taskParam = attributes.taskParam || this.params.task_param;
   }

   toObj() {
      var obj = super.toObj();

      obj.taskParam = this.taskParam || this.params.task_param;

      return obj;
   }

   processDataField(id, label) {
      // we have to report back on:
      // key:  id.taskParam
      // label: label->taskParam
      // object: ABObject
      // field: ABField
      // set : {bool}

      var field = null;
      // {ABField}
      // if the value being stored is NOT a connectObject, then it is
      // a particular field in the previous object.

      // if we are saving a specific field of an Object, pass that
      // ABField along:
      if (
         this.prevOP?.field?.key != "connectObject"
      ) {
         field = this.prevOP.field;
      }

      return {
         key: `${id}.${this.taskParam || this.params.task_param}`,
         label: `${label}->${this.taskParam || this.params.task_param}`,
         field: field,
         object: this.object,
         set: true
      };
   }
}

ABQLSetSaveCore.key = "set_save";
ABQLSetSaveCore.label = "save";
ABQLSetSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

module.exports = ABQLSetSaveCore;


/***/ }),

/***/ 74842:
/*!*****************************************!*\
  !*** ./AppBuilder/core/ql/ABQLValue.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLValue
 *
 * Here we define the group of operations that can be performed on a VALUE.
 * A VALUE is an object or array.
 *
 */

module.exports = [__webpack_require__(/*! ../../platform/ql/ABQLValueSave.js */ 23111)];


/***/ }),

/***/ 6321:
/*!*************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLValueSaveCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLRowValueCore
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLSetSave = __webpack_require__(/*! ../../platform/ql/ABQLSetSave.js */ 67478);

class ABQLValueSaveCore extends ABQLSetSave {
   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      super.fromAttributes(attributes);

      this.constructor.NextQLOps =
         this.prevOP.NextQLOps || this.prevOP.constructor.NextQLOps;
   }
}

ABQLValueSaveCore.key = "value_save";
ABQLValueSaveCore.label = "save";
ABQLValueSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

module.exports = ABQLValueSaveCore;



/***/ }),

/***/ 50792:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCSVExporterCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewCSVExporterDefaults = {
   key: "csvExporter", // unique key identifier for this ABViewForm
   icon: "download", // icon reference: (without 'fa-' )
   labelKey: "CSV Exporter", // {string} the multilingual label key for the class label
};

const ABViewCSVExporterPropertyComponentDefaults = {
   dataviewID: null,
   where: null,
   buttonLabel: "Export CSV",
   filename: "exportCSV",
   hasHeader: true,
   width: 150,
};

module.exports = class ABViewCSVExporterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewCSVExporterDefaults
      );
   }

   static common() {
      return ABViewCSVExporterDefaults;
   }

   static defaultValues() {
      return ABViewCSVExporterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert to boolean
      if (typeof values.settings.hasHeader == "string")
         this.settings.hasHeader = JSON.parse(values.settings.hasHeader);

      if (this.settings.hasHeader == null)
         this.settings.hasHeader =
            ABViewCSVExporterPropertyComponentDefaults.hasHeader;

      // convert from "0" => 0
      this.settings.width = parseInt(
         values.settings.width ||
            ABViewCSVExporterPropertyComponentDefaults.width
      );
   }
};


/***/ }),

/***/ 17876:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCSVImporterCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 26204);

const ABViewCSVImporterDefaults = {
   key: "csvImporter",
   // {string}
   // unique key identifier for this ABViewForm

   icon: "upload",
   // {string}
   // font-awesome icon reference: (without 'fa-' )

   labelKey: "CSV Importer",
   // {string}
   // the multilingual label key for the class label
   // NOTE: will be used as L(labelKey)
};

const ABViewCSVImporterPropertyComponentDefaults = {
   dataviewID: null,
   // {uuid}
   // The ABDataCollection.uuid that we are using to store the data.
   // NOTE: we actually use the DC to get the ABObject it is connected to.

   availableFieldIds: [],
   //{array}
   // A list of ABField.ids that are allowed to be imported using this widget.

   buttonLabel: "Upload CSV",
   // {string}
   // The Label(key) to display on the initial button

   width: 0,
   // {integer}
   // Width of the Popup.

   recordRules: [],
   // {array}  [ {RecordRule}, ... ]
   // A list of ABViewRuleListFormRecordRules that should be performed upon
   // each row of data imported.
   // The Array should look like:
   // [{
   //    action: {string},
   //    when: [
   //       {
   //          fieldId: {UUID},
   //          comparer: {string},
   //          value: {string}
   //       }
   //    ],
   //    values: [
   //       {
   //          fieldId: {UUID},
   //          value: {object}
   //       }
   //    ]
   // }]
};

module.exports = class ABViewCSVImporterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewCSVImporterDefaults
      );
   }

   /**
    * @method common()
    * Provides the default settings for an instance of an ABViewCSVImporter
    * @return {json}
    */
   static common() {
      return ABViewCSVImporterDefaults;
   }

   /**
    * @method defaultValues()
    * Provides the default settings for an instance of an ABViewCSVImporter
    * Component that is displayed on the UI.
    * @return {json}
    */
   static defaultValues() {
      return ABViewCSVImporterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewCSVImporterPropertyComponentDefaults.width
      );
   }

   get RecordRule() {
      let object = this.datacollection?.datasource;
      if (!object) return;

      if (this._recordRule == null) {
         this._recordRule = new ABRecordRule();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   doRecordRulesPre(rowDatas) {
      if (rowDatas && !Array.isArray(rowDatas)) {
         rowDatas = [rowDatas];
      }

      rowDatas.forEach((row) => {
         this.RecordRule?.processPre({ data: row.data || row, form: this });
      });
   }

   doRecordRules(rowDatas) {
      if (rowDatas && !Array.isArray(rowDatas)) {
         rowDatas = [rowDatas];
      }

      if (!this.RecordRule) return Promise.resolve();

      let tasks = [];

      rowDatas.forEach((row) => {
         tasks.push(
            this.RecordRule.process({ data: row.data || row, form: this })
         );
      });

      return Promise.all(tasks);
   }
};


/***/ }),

/***/ 96483:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCarouselCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewCarouselPropertyComponentDefaults = {
   dataviewID: null, // uuid of ABDatacollection
   field: null, // uuid

   width: 460,
   height: 275,
   showLabel: true,
   hideItem: false,
   hideButton: false,
   navigationType: "corner", // "corner" || "side"
   filterByCursor: false,

   detailsPage: null, // uuid
   detailsTab: null, // uuid
   editPage: null, // uuid
   editTab: null, // uuid
};

const ABViewDefaults = {
   key: "carousel", // {string} unique key for this view
   icon: "clone", // {string} fa-[icon] reference for this view
   labelKey: "Carousel", // {string} the multilingual label key for the class label
};

module.exports = class ABViewCarouselCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewCarouselPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      if (typeof this.settings.width != "undefined") {
         this.settings.width = parseInt(this.settings.width);
      } else {
         this.settings.width = ABViewCarouselPropertyComponentDefaults.width;
      }
      if (typeof this.settings.height != "undefined") {
         this.settings.height = parseInt(this.settings.height);
      } else {
         this.settings.height = ABViewCarouselPropertyComponentDefaults.height;
      }
      try {
         this.settings.showLabel = JSON.parse(this.settings.showLabel);
      } catch (e) {
         this.settings.showLabel =
            ABViewCarouselPropertyComponentDefaults.showLabel;
      }
      try {
         this.settings.hideItem = JSON.parse(this.settings.hideItem);
      } catch (e) {
         this.settings.hideItem =
            ABViewCarouselPropertyComponentDefaults.hideItem;
      }
      try {
         this.settings.hideButton = JSON.parse(this.settings.hideButton);
      } catch (e) {
         this.settings.hideButton =
            ABViewCarouselPropertyComponentDefaults.hideButton;
      }
      this.settings.navigationType =
         this.settings.navigationType ||
         ABViewCarouselPropertyComponentDefaults.navigationType;
      try {
         this.settings.filterByCursor = JSON.parse(
            this.settings.filterByCursor
         );
      } catch (e) {
         this.settings.filterByCursor =
            ABViewCarouselPropertyComponentDefaults.filterByCursor;
      }
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   get imageField() {
      let dc = this.datacollection;
      if (!dc) return null;

      let obj = dc.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.field)[0];
   }
};


/***/ }),

/***/ 46202:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartAreaCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartComponent = __webpack_require__(/*! ../../platform/views/ABViewChartComponent */ 68320);

const ABViewChartAreaPropertyComponentDefaults = {
   areaType: "area",
   isLegend: true,
   // chartWidth: 600,
   chartHeight: 0,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "area", // {string} unique key for this view
   icon: "area-chart", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.chart.area", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartAreaCore extends ABViewChartComponent {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartAreaPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.isLegend = JSON.parse(
         this.settings.isLegend ||
            ABViewChartAreaPropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartAreaPropertyComponentDefaults.chartWidth);
      this.settings.chartHeight = parseInt(
         this.settings.chartHeight ||
            ABViewChartAreaPropertyComponentDefaults.chartHeight
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ||
            ABViewChartAreaPropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ||
            ABViewChartAreaPropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ||
            ABViewChartAreaPropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["areaLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 53253:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartBarCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartComponent = __webpack_require__(/*! ../../platform/views/ABViewChartComponent */ 68320);

const ABViewChartBarPropertyComponentDefaults = {
   barType: "bar",
   barPreset: "column",
   isLegend: true,
   // chartWidth: 600,
   height: 200,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "bar", // {string} unique key for this view
   icon: "bar-chart", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.chart.bar", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartBarCore extends ABViewChartComponent {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartBarPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.isLegend = JSON.parse(
         this.settings.isLegend ||
            ABViewChartBarPropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartBarPropertyComponentDefaults.chartWidth);
      this.settings.height = parseInt(
         this.settings.height || ABViewChartBarPropertyComponentDefaults.height
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ||
            ABViewChartBarPropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ||
            ABViewChartBarPropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ||
            ABViewChartBarPropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["barLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 31311:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);

const ABViewChartPropertyComponentDefaults = {
   dataviewID: null,
   columnValue: null,
   columnLabel: null,
   columnValue2: null,
   isPercentage: true,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   multipleSeries: false,
};

const ABViewChartDefaults = {
   key: "chart", // {string} unique key for this view
   icon: "bar-chart", // {string} fa-[icon] reference for this view
   labelKey: "Chart", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewChartDefaults);
   }

   static common() {
      return ABViewChartDefaults;
   }

   static defaultValues() {
      return ABViewChartPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.isPercentage = JSON.parse(
         this.settings.isPercentage ||
            ABViewChartPropertyComponentDefaults.isPercentage
      );

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewChartPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewChartPropertyComponentDefaults.showLabel
      );
      this.settings.multipleSeries = JSON.parse(
         this.settings.multipleSeries != null
            ? this.settings.multipleSeries
            : ABViewChartPropertyComponentDefaults.multipleSeries
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth ||
            ABViewChartPropertyComponentDefaults.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height || ABViewChartPropertyComponentDefaults.height
      );

      this.translate(this, this, ["chartLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["label", "pie", "bar", "line", "area"],
         allComponents = this.application.viewAll(); // ABViewManager.allViews();

      var ret = allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
      return ret;
   }

   labelField() {
      var dc = this.datacollection;
      if (!dc) return null;

      var obj = dc.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnLabel)[0];
   }

   valueField() {
      var dc = this.datacollection;
      if (!dc) return null;

      var obj = dc.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnValue)[0];
   }

   valueField2() {
      var dc = this.datacollection;
      if (!dc) return null;

      var obj = dc.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnValue2)[0];
   }
};


/***/ }),

/***/ 59875:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartLineCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartComponent = __webpack_require__(/*! ../../platform/views/ABViewChartComponent */ 68320);

const ABViewChartLinePropertyComponentDefaults = {
   lineType: "line",
   linePreset: "plot",
   isLegend: true,
   // chartWidth: 600,
   chartHeight: 200,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "line", // {string} unique key for this view
   icon: "line-chart", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.chart.line", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartLineCore extends ABViewChartComponent {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartLinePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.isLegend = JSON.parse(
         this.settings.isLegend ||
            ABViewChartLinePropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartLinePropertyComponentDefaults.chartWidth);
      this.settings.chartHeight = parseInt(
         this.settings.chartHeight ||
            ABViewChartLinePropertyComponentDefaults.chartHeight
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ||
            ABViewChartLinePropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ||
            ABViewChartLinePropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ||
            ABViewChartLinePropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["lineLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 12118:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartPieCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartComponent = __webpack_require__(/*! ../../platform/views/ABViewChartComponent */ 68320);

const ABViewChartPiePropertyComponentDefaults = {
   pieType: "pie",
   isLegend: true,
   // chartWidth: 600,
   height: 200,
   innerFontSize: 12,
   labelFontSize: 12,
};

const ABViewDefaults = {
   key: "pie", // {string} unique key for this view
   icon: "pie-chart", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.chart.pie", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartPieCore extends ABViewChartComponent {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartPiePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.isLegend = JSON.parse(
         this.settings.isLegend ||
            ABViewChartPiePropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartPiePropertyComponentDefaults.chartWidth);
      this.settings.height = parseInt(
         this.settings.height || ABViewChartPiePropertyComponentDefaults.height
      );

      this.settings.innerFontSize = parseInt(
         this.settings.innerFontSize ||
            ABViewChartPiePropertyComponentDefaults.innerFontSize
      );
      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ||
            ABViewChartPiePropertyComponentDefaults.labelFontSize
      );

      this.translate(this, this, ["pieLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 42194:
/*!****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCommentCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewCommentPropertyComponentDefaults = {
   dataviewID: null,
   columnUser: null,
   columnComment: null,
   columnDate: null,
   height: 300,
   label: "", // label is required and you can add more if the component needs them
   // format:0  	// 0 - normal, 1 - title, 2 - description
};

const ABViewDefaults = {
   key: "comment", // {string} unique key for this view
   icon: "comments", // {string} fa-[icon] reference for this view
   labelKey: "Comment", // {string} the multilingual label key for the class label
};

module.exports = class ABViewCommentCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewCommentPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      // this.settings.format = parseInt(this.settings.format);
      // if this is being instantiated on a read from the Property UI,
      this.settings.height = parseInt(this.settings.height || 0);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   getUserField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnUser)[0];
   }

   getCommentField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnComment)[0];
   }

   getDateField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.settings.columnDate)[0];
   }

   getUserData() {
      var userObject = this.getUsers();
      var userList = [];

      if (!userObject) return;

      userObject.forEach((item, index) => {
         var imageURL = "";
         if (item.image) {
            imageURL = "/opsportal/image/UserProfile/" + item.image;
         }
         var user = { id: index + 1, value: item.value, image: imageURL };
         userList.push(user);
      });
      return userList;
   }

   model() {
      let dv = this.datacollection;
      if (!dv) return null; // TODO: refactor in v2

      // get ABObject
      let obj = dv.datasource;
      if (obj == null) return null; // TODO: refactor in v2

      // get ABModel
      let model = dv.model; // already notified
      if (!model) return null;

      return model;
   }
};


/***/ }),

/***/ 10962:
/*!*****************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewConditionalContainerCore.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);

const ABViewPropertyDefaults = {
   dataviewID: null,
   filterConditions: {},
};

const ABViewDefaults = {
   key: "conditionalcontainer", // unique key identifier for this ABView
   icon: "shield", // icon reference: (without 'fa-' )
   labelKey: "Conditional Container", // {string} the multilingual label key for the class label
};

module.exports = class ABViewConditionalContainerCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      var L = this.AB.Multilingual.label;

      // the conditional container always has 'If' and 'Else' panels
      if (this.views((v) => v instanceof ABViewContainer).length < 2) {
         // 'If' panel
         var ifPanel = application.viewNew(
            {
               key: ABViewContainer.common().key,
               label: L("If", "If"),
               settings: {
                  removable: false,
               },
            },
            application,
            this
         );
         this._views.push(ifPanel);

         // 'Else' panel
         var elsePanel = application.viewNew(
            {
               key: ABViewContainer.common().key,
               label: L("Else", "Else"),
               settings: {
                  removable: false,
               },
            },
            application,
            this
         );
         this._views.push(elsePanel);
      }
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyDefaults;
   }
};


/***/ }),

/***/ 3578:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewConnectDataFilterCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewConnectDataFilterPropertyComponentDefaults = {
   dataviewID: null, // uuid of ABDatacollection
   field: null, // uuid
};

const ABViewDefaults = {
   key: "connect-data-filter", // {string} unique key for this view
   icon: "filter", // {string} fa-[icon] reference for this view
   labelKey: "Connected Data Filter", // {string} the multilingual label key for the class label
};

module.exports = class ABViewConnectDataFilterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues ?? ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewConnectDataFilterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

};


/***/ }),

/***/ 45132:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewContainerCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewContainerCore
 *
 * An ABViewContainerCore defines a UI display component.
 *
 * A container might have multiple columns of display info.
 *
 */

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 10902);

// function L(key, altText) {
// 	return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "viewcontainer", // {string} unique key for this view
   icon: "braille", // {string} fa-[icon] reference for this view
   labelKey: "Container", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columns: 1,
   gravity: 1,
};

module.exports = class ABViewContainerCore extends ABView {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columns = parseInt(
         this.settings.columns || ABPropertyComponentDefaults.columns
      );

      if (typeof this.settings.gravity != "undefined") {
         this.settings.gravity.map(function (gravity) {
            return parseInt(gravity);
         });
      }

      if (this.settings.removable != null) {
         this.settings.removable = JSON.parse(this.settings.removable); // convert to boolean
      } else {
         this.settings.removable = true;
      }

      if (this.settings.movable != null) {
         this.settings.movable = JSON.parse(this.settings.movable); // convert to boolean
      } else {
         this.settings.movable = true;
      }
   }

   viewsSortByPosition() {
      // Sort views from y, x positions
      return this.views().sort((a, b) => {
         if (a.position.y == b.position.y) return a.position.x - b.position.x;
         else return a.position.y - b.position.y;
      });
   }

   // saveReorder() {
   //    return this.application.viewReorder(this);
   // }
};


/***/ }),

/***/ 45974:
/*!*********************************************!*\
  !*** ./AppBuilder/core/views/ABViewCore.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */

var ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 97069);

const ABViewDefaults = {
   key: "view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

module.exports = class ABViewCore extends ABMLClass {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.fromValues(values);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      console.error("!!! where is this being called???");
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      ); // ABViewManager.newView({ key: this.common().key }, application, parent);
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // // NOTE: ensure we have a uuid() set:
      // if (!this.id) {
      //    this.id = this.application.uuid();
      // }

      // this.application.unTranslate(this, this, ["label"]);

      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || "view",
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || "view";
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label = this.parent.label + "." + this.defaults.key;
         }
      }

      var views = [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.AB.notify.builder(
               new Error(
                  `Application[${this.application.name}][${this.application.id}].View[${this.name}][${this.id}] references unknown View[${id}]`
               ),
               {
                  context:"ABViewCore:fromValues():values.viewIDs for each",
                  id
               }
            );
         }
      });
      this._views = views;

      // convert from "0" => 0
      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    *
    * return an flatten array of all the ABViews parents
    *
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      var accessibleRoles = Object.keys(this.accessLevels) || [];
      (roles || []).forEach((r) => {
         if (accessibleRoles.indexOf(r.uuid || r) > -1) {
            foundRole = true;
         }
      });

      return foundRole;
   }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   getUserAccess() {
      // by default everyone has no access
      var accessLevel = 0;

      if (this.application.isAccessManaged) {
         // check to see if the current users is the access manager
         var isAccessManager = false;
         // first check if manager is defined by their role
         if (parseInt(this.application.accessManagers.useRole) == 1) {
            // if so check if any of the user's role match the managers
            this.AB.Account.roles().forEach((role) => {
               if (
                  this.application.accessManagers.role.indexOf(
                     role.id || role.uuid
                  ) > -1
               ) {
                  // if so set the access level to full access
                  isAccessManager = true;
                  accessLevel = 2;
               }
            });
         }
         // if the user isn't already set as the manager and the manager is defined by their account
         if (
            !isAccessManager &&
            parseInt(this.application.accessManagers.useAccount) == 1
         ) {
            // check if the user's account matches the managers
            if (
               this.application.accessManagers.account.indexOf(
                  this.AB.Account.uuid() + ""
               ) > -1
            ) {
               // if so set the access level to full access
               isAccessManager = true;
               accessLevel = 2;
            }
         }

         // if the user is not the manager check if the page has access levels defined for roles
         if (
            this.accessLevels &&
            Object.keys(this.accessLevels).length > 0 &&
            !isAccessManager
         ) {
            // check to see if the user's roles matches one of the roles defined
            this.AB.Account.roles().forEach((role) => {
               var currentRole = this.accessLevels[role.id || role.uuid];
               if (currentRole && parseInt(currentRole) > accessLevel)
                  // if the access level is higher than a previous role set to the new level
                  accessLevel = parseInt(currentRole);
            });
         }
      } else {
         accessLevel = 2;
      }

      return accessLevel;
   }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlView() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   /**
    * @method urlView
    * return a string pointer to this object's views.
    * @return {string}
    */
   urlView() {
      return this.urlPointer() + "/_views/";
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            ["form", "grid", "line", "area", "bar", "gantt", "kanban"].indexOf(
               this.key
            ) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (["page", "viewcontainer"].indexOf(this.key) == -1) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `View[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   updateAccessLevels(roleId, accessLevel) {
      if (parseInt(accessLevel) == 0) {
         if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
      } else {
         this.accessLevels[roleId] = accessLevel;
      }

      return this.save(false, false);
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         result = result.concat(this._views.filter(filter));

         this._views.forEach((v) => {
            var subViews = v.views(filter, deep);
            if (subViews && subViews.length > 0) {
               result = result.concat(subViews);
            }
         });
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewNew()
    *
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewDestroy(view) {
      console.error("DEPRECIATED: where is this called?");
      return this.viewRemove(view);
   }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages = this.application._pages.filter(
                              (p2) => p2.id != lookUpIds[p.id]
                           );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
};


/***/ }),

/***/ 37446:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDataviewCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetail = __webpack_require__(/*! ../../platform/views/ABViewDetail */ 80414);

const ABViewDataviewPropertyComponentDefaults = {
   xCount: 1, // {int} the number of columns per row (need at least one)
   detailsPage: "",
   detailsTab: "",
   editPage: "",
   editTab: "",
};

const ABViewDataviewDefaults = {
   key: "dataview", // {string} unique key for this view
   icon: "th", // {string} fa-[icon] reference for this view
   labelKey: "Data view", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDataviewCore extends ABViewDetail {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDataviewDefaults
      );
   }

   static common() {
      return ABViewDataviewDefaults;
   }

   static defaultValues() {
      return ABViewDataviewPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.xCount = parseInt(
         this.settings.xCount || ABViewDataviewPropertyComponentDefaults.xCount
      );
      this.settings.detailsPage =
         this.settings.detailsPage ||
         ABViewDataviewPropertyComponentDefaults.detailsPage;
      this.settings.editPage =
         this.settings.editPage ||
         ABViewDataviewPropertyComponentDefaults.editPage;
      this.settings.detailsTab =
         this.settings.detailsTab ||
         ABViewDataviewPropertyComponentDefaults.detailsTab;
      this.settings.editTab =
         this.settings.editTab ||
         ABViewDataviewPropertyComponentDefaults.editTab;
   }
};


/***/ }),

/***/ 24044:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCheckboxCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailCheckboxPropertyComponentDefaults = {};

const ABViewDetailCheckboxDefaults = {
   key: "detailcheckbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.checkbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailCheckboxCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDetailCheckboxDefaults
      );
   }

   static common() {
      return ABViewDetailCheckboxDefaults;
   }

   static defaultValues() {
      return ABViewDetailCheckboxPropertyComponentDefaults;
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 79809:
/*!************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailComponentCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

module.exports = class ABViewDetailComponentCore extends ABViewWidget {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   detailComponent() {
      var detailView = null;

      var curr = this;
      while (
         !curr.isRoot() &&
         curr.parent &&
         curr.key != "detail" &&
         curr.key != "dataview"
      ) {
         curr = curr.parent;
      }

      if (curr.key == "detail" || curr.key == "dataview") {
         detailView = curr;
      }

      return detailView;
   }

   field() {
      let detailComponent = this.detailComponent();
      if (detailComponent == null) return null;

      let datacollection = detailComponent.datacollection;
      if (datacollection == null) return null;

      let object = datacollection.datasource;
      if (object == null) return null;

      let field = object.fields((v) => v.id == this.settings.fieldId)[0];

      // set .alias to support queries that contains alias name
      // [aliasName].[columnName]
      if (field && this.settings.alias) {
         field.alias = this.settings.alias;
      }

      return field;
   }

   getCurrentData() {
      var detailCom = this.detailComponent();
      if (!detailCom) return null;

      var dv = detailCom.datacollection;
      if (!dv) return null;

      var field = this.field();
      if (!field) return null;

      var currData = dv.getCursor();
      if (currData) return currData[field.columnName];
      else return null;
   }
};


/***/ }),

/***/ 16497:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailConnectCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// const ABViewDetailSelectivity = require("../../platform/views/ABViewDetailSelectivity");
const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailPropertyComponentDefaults = {
   formView: "", // id of form to add new data
};

const ABViewDefaults = {
   key: "detailconnect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.connect", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailConnectCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 12407:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);

const ABViewDetailDefaults = {
   key: "detail", // {string} unique key for this view
   icon: "file-text-o", // {string} fa-[icon] reference for this view
   labelKey: "Detail", // {string} the multilingual label key for the class label
};

const ABViewDetailPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 0,
};

module.exports = class ABViewDetailCore extends ABViewContainer {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDetailDefaults);
   }

   static common() {
      return ABViewDetailDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewDetailPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewDetailPropertyComponentDefaults.showLabel
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth ||
            ABViewDetailPropertyComponentDefaults.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height || ABViewDetailPropertyComponentDefaults.height
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["label", "text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }
};


/***/ }),

/***/ 78276:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCustomCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailCustomPropertyComponentDefaults = {};

const ABViewDetailCustomDefaults = {
   key: "detailcustom", // {string} unique key for this view
   icon: "dot-circle-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.custom", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailCustomCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDetailCustomDefaults
      );
   }

   static common() {
      return ABViewDetailCustomDefaults;
   }

   static defaultValues() {
      return ABViewDetailCustomPropertyComponentDefaults;
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 81597:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailImageCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailImagePropertyComponentDefaults = {
   height: 80,
   width: 120,
};

const ABViewDetailImageDefaults = {
   key: "detailimage", // {string} unique key for this view
   icon: "image", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.image", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailImageCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDetailImageDefaults
      );
   }

   static common() {
      return ABViewDetailImageDefaults;
   }

   static defaultValues() {
      return ABViewDetailImagePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height ||
            ABViewDetailImagePropertyComponentDefaults.height
      );
      this.settings.width = parseInt(
         this.settings.width || ABViewDetailImagePropertyComponentDefaults.width
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 89207:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailTextCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailTextPropertyComponentDefaults = {
   height: 0,
};

const ABViewDetailTextDefaults = {
   key: "detailtext", // {string} unique key for this view
   icon: "etsy", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.text", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailTextCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDetailTextDefaults
      );
   }

   static common() {
      return ABViewDetailTextDefaults;
   }

   static defaultValues() {
      return ABViewDetailTextPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height ||
            ABViewDetailTextPropertyComponentDefaults.height
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 7716:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailTreeCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponent = __webpack_require__(/*! ../../platform/views/ABViewDetailComponent */ 66711);

const ABViewDetailPropertyComponentDefaults = {};

const ABViewDetailTreeDefaults = {
   key: "detailtree", // {string} unique key for this view
   icon: "sitemap", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.tree", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailTextCore extends ABViewDetailComponent {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDetailTreeDefaults
      );
   }

   static common() {
      return ABViewDetailTreeDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 24107:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDocxBuilderCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewDocxBuilderPropertyComponentDefaults = {
   buttonlabel: "Download DOCX",
   dataviewID: null,
   width: 0,
   filename: "", // uuid
   filelabel: "output.docx",
   language: "en", // en
   toolbarBackground: "ab-background-default",
   buttonPosition: "left",
};

const ABViewDefaults = {
   key: "docxBuilder", // {string} unique key for this view
   icon: "file-word-o", // {string} fa-[icon] reference for this view
   labelKey: "DOCX Builder", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDocxBuilderCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewDocxBuilderPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["filelabel", "buttonlabel"]);

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewDocxBuilderPropertyComponentDefaults.width
      );

      this.translate(this, this, ["filelabel", "buttonlabel"]);
   }

   uploadUrl() {
      // TODO: Convert this to use ABFactory.urlFileUpload() or a ABFieldFile
      // to get the URL:
      console.warn(
         new Error(
            "TODO: convert ABViewDocxBuilderCore.uploadUrl() to use common url code."
         )
      );
      // let actionKey =
      //    "opstool.AB_" + this.application.name.replace("_", "") + ".view";

      // return (
      //    "/" +
      //    ["opsportal", "file", this.application.name, actionKey, "1"].join("/")
      // );
      return `/file/upload/DOCX${this.id}/VIEW${this.id}/1`;
   }

   downloadUrl() {
      return `/file/${this.settings.filename}`;
   }

   get languageCode() {
      return (
         this.settings.language ||
         ABViewDocxBuilderPropertyComponentDefaults.language
      );
   }

   get datacollections() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) return [];

      let dvList = dataviewID.split(",") || [];

      return this.AB.datacollections((dv) => dvList.indexOf(dv.id) > -1) || [];
   }
};


/***/ }),

/***/ 32609:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormButtonCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 10902);

const ABViewFormButtonPropertyComponentDefaults = {
   includeSave: true,
   saveLabel: "",
   includeCancel: false,
   cancelLabel: "",
   includeReset: false,
   resetLabel: "",
   afterCancel: null,
   alignment: "right",
   isDefault: false, // mark default button of form widget
};

const ABViewFormButtonDefaults = {
   key: "button",
   // {string} unique key for this view

   icon: "square",
   // {string} fa-[icon] reference for this view

   labelKey: "ab.components.button",
   // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormButtonCore extends ABView {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormButtonDefaults
      );
   }

   static common() {
      return ABViewFormButtonDefaults;
   }

   static defaultValues() {
      return ABViewFormButtonPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   toObj() {
      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      let result = super.toObj();

      return result;
   }

   fromValues(values) {
      super.fromValues(values);

      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      this.settings.includeSave = JSON.parse(
         this.settings.includeSave ||
            ABViewFormButtonPropertyComponentDefaults.includeSave
      );
      this.settings.includeCancel = JSON.parse(
         this.settings.includeCancel ||
            ABViewFormButtonPropertyComponentDefaults.includeCancel
      );
      this.settings.includeReset = JSON.parse(
         this.settings.includeReset ||
            ABViewFormButtonPropertyComponentDefaults.includeReset
      );

      this.settings.isDefault = JSON.parse(
         this.settings.isDefault ||
            ABViewFormButtonPropertyComponentDefaults.isDefault
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 18489:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCheckboxCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormCheckboxPropertyComponentDefaults = {};

const ABViewFormCheckboxDefaults = {
   key: "checkbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.checkbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormCheckboxCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCheckboxDefaults
      );
   }

   static common() {
      return ABViewFormCheckboxDefaults;
   }

   static defaultValues() {
      return ABViewFormCheckboxPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 43960:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormComponentCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 10902);

const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

module.exports = class ABViewFormComponentCore extends ABView {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
};


/***/ }),

/***/ 24703:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormConnectCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormConnectPropertyComponentDefaults = {
   formView: "", // id of form to add new data
   filterConditions: {
      // array of filters to apply to the data table
      glue: "and",
      rules: [],
   },
   sortFields: [],
   // objectWorkspace: {
   //    filterConditions: {
   //       // array of filters to apply to the data table
   //       glue: "and",
   //       rules: [],
   //    },
   // },
   popupWidth: 700,
   popupHeight: 450,
};

const ABViewFormConnectDefaults = {
   key: "connect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "Connect", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormConnectCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormConnectDefaults
      );
   }

   static common() {
      return ABViewFormConnectDefaults;
   }

   static defaultValues() {
      return ABViewFormConnectPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.filterConditions =
         this.settings.filterConditions ||
         ABViewFormConnectPropertyComponentDefaults.filterConditions;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 36980:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);
const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 26204);
const ABSubmitRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 51567);

const ABViewFormDefaults = {
   key: "form", // unique key identifier for this ABViewForm
   icon: "list-alt", // icon reference: (without 'fa-' )
   labelKey: "Form", // {string} the multilingual label key for the class label
};

const ABViewFormPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   clearOnLoad: false,
   clearOnSave: false,
   displayRules: [],
   editForm: "none", // The url pointer of ABViewForm

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		values: [
   //			{
   //				fieldId: {UUID},
   //				value: {object}
   //			}
   //		]
   //	}]
   recordRules: [],

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		value: {string}
   //	}]
   submitRules: [],
};

module.exports = class ABViewFormCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewFormDefaults);
   }

   static common() {
      return ABViewFormDefaults;
   }

   static defaultValues() {
      return ABViewFormPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewFormPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewFormPropertyComponentDefaults.showLabel
      );
      this.settings.clearOnLoad = JSON.parse(
         this.settings.clearOnLoad != null
            ? this.settings.clearOnLoad
            : ABViewFormPropertyComponentDefaults.clearOnLoad
      );
      this.settings.clearOnSave = JSON.parse(
         this.settings.clearOnSave != null
            ? this.settings.clearOnSave
            : ABViewFormPropertyComponentDefaults.clearOnSave
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth == null
            ? ABViewFormPropertyComponentDefaults.labelWidth
            : this.settings.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height == null
            ? ABViewFormPropertyComponentDefaults.height
            : this.settings.height
      );
   }

   // Use this function in kanban
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["label", "layout", "button", "text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   /**
    * @method fieldComponents()
    *
    * return an array of all the ABViewFormField children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViewFormField that this fn
    *						returns true for.
    * @return {array} 	array of ABViewFormField
    */
   fieldComponents(filter) {
      const flattenComponents = (views) => {
         let components = [];

         views.forEach((v) => {
            if (v == null) return;

            components.push(v);

            if (v._views?.length) {
               components = components.concat(flattenComponents(v._views));
            }
         });

         return components;
      };

      if (this._views?.length) {
         const allComponents = flattenComponents(this._views);

         if (filter == null) {
            filter = (comp) => comp instanceof ABViewFormComponent;
         }

         return allComponents.filter(filter);
      } else {
         return [];
      }
   }

   addFieldToForm(field, yPosition) {
      if (field == null) return;

      var fieldComponent = field.formComponent();
      if (fieldComponent == null) return;

      var newView = fieldComponent.newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings || {};
      newView.settings.fieldId = field.id;
      // TODO : Default settings

      if (yPosition != null) newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      return newView;
   }

   get RecordRule() {
      let object = this.datacollection.datasource;

      if (this._recordRule == null) {
         this._recordRule = new ABRecordRule();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   doRecordRulesPre(rowData) {
      return this.RecordRule.processPre({ data: rowData, form: this });
   }

   doRecordRules(rowData) {
      // validate for record rules
      if (rowData) {
         let object = this.datacollection.datasource;
         let ruleValidator = object.isValidData(rowData);
         let isUpdatedDataValid = ruleValidator.pass();
         if (!isUpdatedDataValid) {
            console.error("Updated data is invalid.", { rowData: rowData });
            return Promise.reject(new Error("Updated data is invalid."));
         }
      }

      return this.RecordRule.process({ data: rowData, form: this });
   }

   doSubmitRules(rowData) {
      var object = this.datacollection.datasource;

      var SubmitRules = new ABSubmitRule();
      SubmitRules.formLoad(this);
      SubmitRules.fromSettings(this.settings.submitRules);
      SubmitRules.objectLoad(object);

      return SubmitRules.process({ data: rowData, form: this });
   }
};


/***/ }),

/***/ 21984:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCustomCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormCustomPropertyComponentDefaults = {};

const ABViewFormCustomDefaults = {
   key: "fieldcustom",
   // {string} unique key for this view
   icon: "object-group",
   // {string} fa-[icon] reference for this view
   labelKey: "ab.components.custom",
   // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormCustom extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCustomDefaults
      );
   }

   static common() {
      return ABViewFormCustomDefaults;
   }

   static defaultValues() {
      return ABViewFormCustomPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 86237:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormDatepickerCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormDatepickerPropertyComponentDefaults = {
   timepicker: false,
};

const ABViewFormDatepickerDefaults = {
   key: "datepicker", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.datepicker", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormDatepickerCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormDatepickerDefaults
      );
   }

   static common() {
      return ABViewFormDatepickerDefaults;
   }

   static defaultValues() {
      return ABViewFormDatepickerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 84909:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormNumberCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormNumberPropertyComponentDefaults = {
   isStepper: 0,
};

const ABViewFormNumberDefaults = {
   key: "numberbox", // {string} unique key for this view
   icon: "hashtag", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.number", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormNumberCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormNumberDefaults
      );
   }

   static common() {
      return ABViewFormNumberDefaults;
   }

   static defaultValues() {
      return ABViewFormNumberPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewFormText instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "formLabel"]);

      var obj = super.toObj();
      obj.views = []; // no subviews
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      this.settings.isStepper =
         this.settings.isStepper ||
         ABViewFormNumberPropertyComponentDefaults.isStepper;

      // convert from "0" => 0
      this.settings.isStepper = parseInt(this.settings.isStepper);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 83569:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormReadonlyCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustom = __webpack_require__(/*! ../../platform/views/ABViewFormCustom */ 79662);

const ABViewFormReadonlyPropertyComponentDefaults = {};

const ABViewFormReadonlyDefaults = {
   key: "fieldreadonly", // {string} unique key for this view
   icon: "calculator", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.readonly", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormReadonly extends ABViewFormCustom {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormReadonlyDefaults
      );
   }

   static common() {
      return ABViewFormReadonlyDefaults;
   }

   static defaultValues() {
      return ABViewFormReadonlyPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 71172:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormSelectMultipleCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormSelectMultiplePropertyComponentDefaults = {
   type: "multicombo", // 'richselect' or 'radio'
};

const ABSelectMultipleDefaults = {
   key: "selectmultiple", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.selectmultiple", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormSelectMultipleCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABSelectMultipleDefaults
      );
   }

   static common() {
      return ABSelectMultipleDefaults;
   }

   static defaultValues() {
      return ABViewFormSelectMultiplePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 54098:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormSelectSingleCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormSelectSinglePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABSelectSingleDefaults = {
   key: "selectsingle", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.selectsingle", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormSelectSingleCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABSelectSingleDefaults
      );
   }

   static common() {
      return ABSelectSingleDefaults;
   }

   static defaultValues() {
      return ABViewFormSelectSinglePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 87209:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormTextboxCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponent = __webpack_require__(/*! ../../platform/views/ABViewFormComponent */ 93787);

const ABViewFormTextboxPropertyComponentDefaults = {
   type: "single", // 'single', 'multiple' or 'rich'
};

const ABViewFormTextboxDefaults = {
   key: "textbox", // {string} unique key for this view
   icon: "i-cursor", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.textbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormTextboxCore extends ABViewFormComponent {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormTextboxDefaults
      );
   }

   static common() {
      return ABViewFormTextboxDefaults;
   }

   static defaultValues() {
      return ABViewFormTextboxPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 80926:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormTreeCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustom = __webpack_require__(/*! ../../platform/views/ABViewFormCustom */ 79662);

const ABViewFormTreePropertyComponentDefaults = {};

const ABTreeDefaults = {
   key: "formtree", // {string} unique key for this view
   icon: "sitemap", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.tree", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormTreeCore extends ABViewFormCustom {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABTreeDefaults);
   }

   static common() {
      return ABTreeDefaults;
   }

   static defaultValues() {
      return ABViewFormTreePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 66959:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewGanttCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewGanttPropertyComponentDefaults = {
   dataviewID: "",
   // {string}
   // {ABDatacollection.id} of the datacollection that contains the data for
   // the Gantt chart.

   titleFieldID: "",
   // {string}
   // {ABFieldXXX.id} of the field that contains the value of the title
   // ABFieldString, ABFieldLongText

   startDateFieldID: "",
   // {string}
   // {ABFieldDate.id} of the field that contains the start date

   endDateFieldID: "",
   // {string}
   // {ABFieldDate.id} of the field that contains the end date

   durationFieldID: "",
   // {string}
   // {ABFieldNumber.id} of the field that contains the duration

   progressFieldID: "",
   // {string}
   // {ABFieldNumber.id} of the field that marks the progress

   notesFieldID: "",
   // {string}
   // {ABFieldXXX.id} of the field that contains the value of the title
   // ABFieldString, ABFieldLongText
};

const ABViewDefaults = {
   key: "gantt", // {string} unique key for this view
   icon: "tasks", // {string} fa-[icon] reference for this view
   labelKey: "Gantt", // {string} the multilingual label key for the class label
};

module.exports = class ABViewGanttCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewGanttPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      Object.keys(ABViewGanttPropertyComponentDefaults).forEach((k) => {
         this.settings[k] =
            this.settings[k] || ABViewGanttPropertyComponentDefaults[k];
      });
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 12268:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewGridCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewGridPropertyComponentDefaults = {
   label: "",
   // {string}
   // label is required and you can add more if the component needs them

   // format:0  	// 0 - normal, 1 - title, 2 - description
   dataviewID: "",
   // {uuid}
   // uuid of ABDataCollection that drives the data for our Grid

   padding: 17,
   // {int}
   // the default padding surrounding the component

   showToolbar: 1,
   // {bool}
   // do we show our toolbar?

   isEditable: 0,
   // {bool}
   // do we allow editing in the grid?

   massUpdate: 0,
   // {bool}
   // do we allow the Mass Update capability? (row checkboxes and the
   // MassUpdate popup)

   allowDelete: 0,
   // {bool}
   // do we allow deleting multiple rows at a time? Mass Delete.

   // isFilterable:0,

   isSortable: 1,
   // {bool}
   // do we allow the sort options.

   isExportable: 0,
   // {bool}
   // do we enable the webix export from grid capabilities?

   // linkedObject:'',
   // linkedField:'',
   // linkedPage:'',
   // linkedPageView:'',
   // linkedEditPage:'',
   // linkedEditPageForm:'',

   detailsPage: "",
   // {ABViewPage.id}
   // the ABViewPage that has the details component.

   detailsTab: "",
   // {ABViewTab.id}
   // the ABViewTab component, that has the details component.
   // NOTE: if your details is embedded on a TAB, we need both the
   // .detailsPage & .detailsTab to successfully show the item.

   editPage: "",
   // {ABViewPage.id}
   // the ABViewPage that has the edit component.

   editTab: "",
   // {ABViewTab.id}
   // the ABViewTab component, that has the edit component.
   // NOTE: if your editor is embedded on a TAB, we need both the
   // .editPage & .editTab to successfully show the form.

   trackView: 0,
   // {bool}
   // Do we offer the ability to track changes to this object/row?

   frozenColumnID: "",
   // {ABField.id}
   // id of column you want to stop freezing the left hand side at.

   hiddenFields: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add hidden:true to

   summaryColumns: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add the SUM footer to

   countColumns: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add the Count footer to

   // TODO: get rid of objectWorkspace!
   objectWorkspace: {
      // sortFields:[], // array of columns with their sort configurations
      // filterConditions:[], // array of filters to apply to the data table
      frozenColumnID: "", // id of column you want to stop freezing
      hiddenFields: [], // array of [ids] to add hidden:true to
      summaryColumns: [],
      countColumns: [],
   },
   gridFilter: {
      filterOption: 1,
      userFilterPosition: "toolbar",
      isGlobalToolbar: 1,
   },
   // summaryFields: [], // array of [field ids] to add the summary column in footer
   // countFields: [], // array of [field ids] to add the summary column in footer

   height: 0,
   // {int}
   // The Height of our Grid.
   // See ../views/ABViewDataview.js

   hideHeader: 0,
   labelAsField: 0,
   hideButtons: 0,
   groupBy: "", // id of field

   // TODO: add to ABDesigner.interface design:
   columnConfig: [],
   // {array} [ {columnHeader}, {columnHeader} ... ]
   // An array of column headers for the grid to display. These should
   // be generated at Design time, and can allow the designer to ORDER the
   // columns, assign column widths, fillspace, etc...
   //    {columnHeader}
   //    The minimum amount of information a Grid needs for it's customization
   //    .id {string} ABField.columnName
   //    .fieldId {string} ABField.id
   //    .width {int}
   //    .fillspace {bool}
   //    .minwidth
   //
   //    When displaying column headers, we will ask the
   //    CurrentObject.columnHeaders(), and then modify them with our settings
   //    here.

   saveLocal: 1,
   // {bool}
   // Allow saving of local changes to our grid display. This will enable
   // a user to modify the Grid display locally.
};

const ABViewDefaults = {
   key: "grid", // {string} unique key for this view
   icon: "table", // {string} fa-[icon] reference for this view
   labelKey: "Grid", // {string} the multilingual label key for the class label
};

/**
 * @function settingsDefault()
 * Verifies a given field is set and if not, defaults to what we havein our
 * ABViewGridPropertyComponentDefaults.
 * NOTE: use this fn() for values that are NOT TRUTHY ... so not for numeric
 * 1 or 0.
 * @param {hash} base
 *        The current settings value hash.
 * @param {string} field
 *        The parameter we are checking.
 */
function settingsDefault(base, field) {
   if (typeof base[field] == "undefined") {
      base[field] = ABViewGridPropertyComponentDefaults[field];
      return;
   }
   base[field] = base[field] || ABViewGridPropertyComponentDefaults[field];
}

/**
 * @function settingsDefaultJSON()
 * Verifies a given field is set and if not, defaults to what we havein our
 * ABViewGridPropertyComponentDefaults.
 * NOTE: use this fn() for values that ARE TRUTHY ... so for numeric 1 or 0
 * @param {hash} base
 *        The current settings value hash.
 * @param {string} field
 *        The parameter we are checking.
 */
function settingsDefaultJSON(base, field) {
   try {
      base[field] = JSON.parse(base[field]);
   } catch (e) {
      base[field] = ABViewGridPropertyComponentDefaults[field];
   }
}

module.exports = class ABViewGridCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewGridPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      settingsDefault(this.settings, "dataviewID");

      // Convert to boolean
      // these values are sometimes 0 (number) at this point so the JSON.parse
      // with the || (or) statement was always falling to the default so I am
      // trying to parse the value...if it fails we use the default value
      settingsDefaultJSON(this.settings, "padding");
      settingsDefaultJSON(this.settings, "showToolbar");
      settingsDefaultJSON(this.settings, "isEditable");
      settingsDefaultJSON(this.settings, "massUpdate");
      settingsDefaultJSON(this.settings, "allowDelete");
      // this.settings.isFilterable = JSON.parse(this.settings.isFilterable || ABViewGridPropertyComponentDefaults.isFilterable);
      settingsDefaultJSON(this.settings, "isSortable");
      settingsDefaultJSON(this.settings, "isExportable");
      settingsDefaultJSON(this.settings, "hideHeader");
      settingsDefaultJSON(this.settings, "labelAsField");
      settingsDefaultJSON(this.settings, "hideButtons");
      settingsDefaultJSON(this.settings, "columnConfig");
      settingsDefaultJSON(this.settings, "saveLocal");

      this.settings.gridFilter =
         this.settings.gridFilter ||
         ABViewGridPropertyComponentDefaults.gridFilter;

      try {
         this.settings.gridFilter.filterOption = JSON.parse(
            this.settings.gridFilter.filterOption
         );
      } catch (e) {
         this.settings.gridFilter.filterOption =
            ABViewGridPropertyComponentDefaults.gridFilter.filterOption;
      }

      try {
         this.settings.gridFilter.isGlobalToolbar = JSON.parse(
            this.settings.gridFilter.isGlobalToolbar
         );
      } catch (e) {
         this.settings.gridFilter.isGlobalToolbar =
            ABViewGridPropertyComponentDefaults.gridFilter.isGlobalToolbar;
      }

      // this.settings.linkedObject = this.settings.linkedObject || ABViewGridPropertyComponentDefaults.linkedObject;
      // this.settings.linkedField = this.settings.linkedField || ABViewGridPropertyComponentDefaults.linkedField;
      // this.settings.linkedPage = this.settings.linkedPage || ABViewGridPropertyComponentDefaults.linkedPage;
      // this.settings.linkedPageView = this.settings.linkedPageView || ABViewGridPropertyComponentDefaults.linkedPageView;
      // this.settings.linkedEditPage = this.settings.linkedEditPage || ABViewGridPropertyComponentDefaults.linkedEditPage;
      // this.settings.linkedEditPageForm = this.settings.linkedEditPageForm || ABViewGridPropertyComponentDefaults.linkedEditPageForm;

      settingsDefault(this.settings, "detailsPage");
      settingsDefault(this.settings, "editPage");
      settingsDefault(this.settings, "detailsTab");
      settingsDefault(this.settings, "editTab");
      settingsDefaultJSON(this.settings, "trackView");

      // TODO: remove objectworkspace!
      // this.settings.objectWorkspace =
      //    this.settings.objectWorkspace ||
      //    ABViewGridPropertyComponentDefaults.objectWorkspace;

      // if (typeof this.settings.objectWorkspace != "undefined") {
      //    if (typeof this.settings.objectWorkspace.sortFields == "undefined")
      //       this.settings.objectWorkspace.sortFields = [];
      //    if (
      //       typeof this.settings.objectWorkspace.filterConditions == "undefined"
      //    )
      //       this.settings.objectWorkspace.filterConditions = [];
      //    if (typeof this.settings.objectWorkspace.frozenColumnID == "undefined")
      //       this.settings.objectWorkspace.frozenColumnID = "";
      //    if (typeof this.settings.objectWorkspace.hiddenFields == "undefined")
      //       this.settings.objectWorkspace.hiddenFields = [];
      //    if (typeof this.settings.objectWorkspace.summaryColumns == "undefined")
      //       this.settings.objectWorkspace.summaryColumns = [];
      //    if (typeof this.settings.objectWorkspace.countColumns == "undefined")
      //       this.settings.objectWorkspace.countColumns = [];
      // }

      var owFields = [
         "sortFields",
         "filterConditions",
         "frozenColumnID",
         "hiddenFields",
         "summaryColumns",
         "countColumns",
      ];
      // Transition: if we have an .objectWorkspace, copy those values in here:
      if (this.settings.objectWorkspace) {
         owFields.forEach((f) => {
            this.settings[f] = this.settings.objectWorkspace[f];
         });
      }

      // make sure they have actual default values now.
      owFields.forEach((f) => {
         settingsDefault(this.settings, f);
      });

      // we are not allowed to have sub views:
      this._views = [];
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   removeField(field, cb) {
      let shouldSave = false;

      // check to see if there is a frozenColumnID and if it matches the
      // deleted field
      if (this.settings?.frozenColumnID == field.columnName) {
         // remove the column name from the frozen column id
         this.settings.frozenColumnID = "";
         // flag the object to be saved later
         shouldSave = true;
      }

      // check to see if there are hidden fields
      if (this.settings.hiddenFields?.length) {
         // find if the deleted field is in the array
         let index = this.settings.hiddenFields.indexOf(field.columnName);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.hiddenFields.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }

      // check to see if there are hidden fields
      if (this.settings.summaryColumns?.length) {
         // find if the deleted field is in the array
         let index = this.settings.summaryColumns.indexOf(field.id);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.summaryColumns.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }

      // check to see if there are hidden fields
      if (this.settings.countColumns?.length) {
         // find if the deleted field is in the array
         let index = this.settings.countColumns.indexOf(field.id);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.countColumns.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }
      // if settings were changed call the callback

      cb(null, shouldSave);
   }

   copyUpdateProperyList() {
      return ["detailsPage", "detailsTab", "editPage", "editTab"];
   }
};


/***/ }),

/***/ 27950:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewImageCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewImagePropertyComponentDefaults = {
   filename: "",
   width: 200,
   height: 100,
};

const ABViewDefaults = {
   key: "image", // {string} unique key for this view
   icon: "picture-o", // {string} fa-[icon] reference for this view
   labelKey: "Image", // {string} the multilingual label key for the class label
};

module.exports = class ABViewImageCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewImagePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewImagePropertyComponentDefaults.width
      );
      this.settings.height = parseInt(
         this.settings.height || ABViewImagePropertyComponentDefaults.height
      );
   }
};


/***/ }),

/***/ 77907:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewKanbanCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewKanbanPropertyComponentDefaults = {
   dataviewID: null,
   // {uuid}
   // The ABDataCollection.uuid that we are using to store the data.
   // NOTE: we actually use the DC to get the ABObject it is connected to.

   editFields: [],
   // {array}
   // An array of {ABField.id} that determines which fields should show up
   // in the editor.

   verticalGroupingField: "",
   // {ABField.id}
   // the .id of the ABField instance that determines the Vertical Grouping
   // of the Kanban.

   horizontalGroupingField: "",
   // {ABField.id}
   // the .id of the ABField instance that determines the horizontal Grouping
   // of the Kanban.

   ownerField: "",
   // {ABFieldUser.id}
   // the .id of the ABFieldUser instance that determines the owner of the
   // entries.

   template: "",
   // {json}
   // The {ABViewText} definition used to display the template for this KanBan.
   //
   // A display template used for displaying the information in each Card. The
   // template is a basic string with special placeholders:  {field.id}
   // Given a row of data, the current object will scan the template for any
   // placeholders matching one of it's fields, and then update it with the
   // current value.
};

const ABViewDefaults = {
   key: "kanban",
   // {string}
   // unique key identifier for this ABViewForm

   icon: "columns",
   // {string}
   // font-awesome icon reference: (without 'fa-' )

   labelKey: "Kanban",
   // {string}
   // the multilingual label key
   // NOTE: will be used as L(labelKey)
};

module.exports = class ABViewKanbanCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   fromValues(values) {
      super.fromValues(values);

      // set a default .template value
      if (!this.settings.template) {
         this.settings.template = { id: `${this.id}_template`, key: "text" };
         this.settings.template.text = this.settings.textTemplate;
      }

      this.TextTemplate = this.AB.viewNewDetatched(this.settings.template);
   }

   toObj() {
      var obj = super.toObj();
      obj.settings.template = this.TextTemplate.toObj();
      return obj;
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewKanbanPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 55759:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewLabelCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewLabelPropertyComponentDefaults = {
   label: "",
   format: 0, // 0 - normal, 1 - title, 2 - description
   alignment: "left",
};

const ABViewDefaults = {
   key: "label", // {string} unique key for this view
   icon: "font", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.label", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLabelCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewLabelPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "text"]);

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values); // <-- this performs the translations

      // if this is being instantiated on a read from the Property UI,
      // .text is coming in under .settings.label
      this.text = values.text || values.settings.text || "*text";

      this.settings.format =
         this.settings.format || ABViewLabelPropertyComponentDefaults.format;
      this.settings.alignment =
         this.settings.alignment ||
         ABViewLabelPropertyComponentDefaults.alignment;

      // we are not allowed to have sub views:
      this._views = [];

      // convert from "0" => 0
      this.settings.format = parseInt(this.settings.format);

      this.translate(this, this, ["label", "text"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   //// Allow external interface to manipulate our settings:

   /**
    * @method formatNormal
    * display text in the normal format.
    */
   formatNormal() {
      this.settings.format = 0;
   }

   /**
    * @method formatTitle
    * display text as a Title.
    */
   formatTitle() {
      this.settings.format = 1;
   }

   /**
    * @method formatDescription
    * display text as a description.
    */
   formatDescription() {
      this.settings.format = 2;
   }
};


/***/ }),

/***/ 96897:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewLayoutCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);
const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const PropertyComponentDefaults = {
   label: "",
   numColumns: 1, // The number of columns for this layout
};

const ABViewDefaults = {
   key: "layout", // {string} unique key for this view
   icon: "columns", // {string} fa-[icon] reference for this view
   labelKey: "Layout", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLayoutCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return PropertyComponentDefaults;
   }

   /**
    * @method addColumn
    * method to actually add a new ABView as one of our columns.
    * This is called by the static .addView() method.
    */
   addColumn() {
      this._views.push(
         this.application.viewNew(
            {
               key: ABViewContainer.common().key,
            },
            this.application,
            this
         )
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      if (isEdited) {
         // if the layout component is being edited in the editor (isEdited == true)
         // then we return [];
         return [];
      } else {
         // the layout view doesn't care what components are offered, it get's
         // the list from it's parent view.
         // ## NOTE: layout views should not be root views.
         if (this.parent) {
            return this.parent.componentList(false);
         } else {
            return [];
         }
      }
   }
};


/***/ }),

/***/ 76589:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewListCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewListPropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
};

const ABViewDefaults = {
   key: "list", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "List", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLabelCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewListPropertyComponentDefaults;
   }

   field() {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      return object.fields((f) => f.id == this.settings.field)[0];
   }
};


/***/ }),

/***/ 42579:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewMenuCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewMenuPropertyComponentDefaults = {
   orientation: "x",
   buttonStyle: "ab-menu-default",
   menuAlignment: "ab-menu-left",
   menuInToolbar: 1,
   menuPadding: 10,
   menuTheme: "bg_gray",
   menuPosition: "left",
   menuTextLeft: "",
   menuTextRight: "",
   menuTextCenter: "",
   // [
   // 		{
   //			pageId: uuid,
   //			tabId: uuid,
   //			type: string, // "page", "tab"
   //			isChecked: bool,
   //			aliasname: string,
   //			translations: []
   //		}
   // ]
   pages: [],
   order: [],
};

const ABMenuDefaults = {
   key: "menu", // {string} unique key for this view
   icon: "th-large", // {string} fa-[icon] reference for this view
   labelKey: "Menu", // {string} the multilingual label key for the class label
};

module.exports = class ABViewMenuCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABMenuDefaults);
   }

   static common() {
      return ABMenuDefaults;
   }

   static defaultValues() {
      return ABViewMenuPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewMenu instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, [
         "menuTextLeft",
         "menuTextCenter",
         "menuTextRight",
      ]);
      if (this.settings.pages) {
         this.settings.pages.forEach((page) => {
            this.unTranslate(page, page, ["aliasname"]);
         });
      }

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.translate(this, this, [
         "menuTextLeft",
         "menuTextCenter",
         "menuTextRight",
      ]);

      this.settings.pages =
         this.settings.pages || ABViewMenuPropertyComponentDefaults.pages;

      for (var i = 0; i < this.settings.pages.length; i++) {
         var page = this.settings.pages[i];
         if (page instanceof Object) {
            page.isChecked = JSON.parse(page.isChecked || false);

            this.translate(page, page, ["aliasname"]);
         }
         // Compatible with old data
         else if (typeof page == "string") {
            this.settings.pages[i] = {
               pageId: page,
               isChecked: true,
            };
         }
      }
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   ClearPagesInView(view) {
      // clear menu items
      if (view && view.count() > 1) {
         view.find({}).forEach((item) => {
            view.remove(item.id);
         });
      }
   }

   AddPagesToView(view, pages) {
      if (!view || !pages) return;

      (pages || []).forEach((displayPage) => {
         if (displayPage.isChecked) {
            let existsPage = this.application.pages(
               (p) => p.id == displayPage.pageId,
               true
            )[0];
            if (!existsPage) return;

            var pageAccessLevel = existsPage.getUserAccess();
            if (pageAccessLevel == 0) return;

            if (displayPage.tabId) {
               let existsTab = this.application.views(
                  (v) => v.id == displayPage.tabId,
                  true
               )[0];
               if (!existsTab) return;

               var tabAccessLevel = existsTab.getUserAccess();
               if (tabAccessLevel == 0) return;
            }

            let label = this.getAliasname(displayPage);
            // create a temporaty store for the menu item
            var menuItem;
            // check if page has a parent or not
            if (displayPage.parent && displayPage.parent != "0") {
               // if page has a parent attempt to grab its submenu
               menuItem = view.getSubMenu(displayPage.parent);
            } else {
               // if the page doesn't have parent use the current menu
               menuItem = view;
            }
            // if the menu item doesn't have a menu selected find it
            if (menuItem == null) {
               // get the menu item
               var curMenu = view.getMenuItem(displayPage.parent);
               // create a submenu placeholder
               curMenu.submenu = [];
               // update the menu with the new submenu included
               view.refresh(displayPage.parent);
               // get the submenu we just created
               menuItem = view.getSubMenu(displayPage.parent);
            }
            if (menuItem.exists(displayPage.tabId || displayPage.pageId))
               return;
            // add a new item to the menu/submenu
            menuItem.add(
               {
                  id: displayPage.tabId || displayPage.pageId,
                  value: label,
                  type: displayPage.type,
                  pageId: displayPage.pageId,
                  icon: displayPage.icon
                     ? "fa fa-fw fa-" + displayPage.icon
                     : "",
               },
               displayPage.position ? parseInt(displayPage.position) : 0
            );
         }
      });
   }

   /**
    * @method getAliasname
    * @param pageInfo - an object in settings
    * {
    * 	pageId: uuid,
    * 	tabId: uuid,
    * 	type: string, - "page" or "tab"
    * 	isChecked: bool,
    * 	aliasname: string,
    *	translations: []
    *}
    *
    * @return {string}
    */
   getAliasname(pageInfo) {
      var lang = this.AB.Multilingual.currentLanguage();
      var translation = pageInfo.translations.filter((t) => {
         return t.language_code == lang;
      });

      var label = "";

      if (translation.length) {
         if (translation[0].aliasname) {
            label = translation[0].aliasname;
         } else if (translation[0].label) {
            label = translation[0].label;
         }
      }

      // Just in case there isn't one stored in the translations yet
      if (!label && pageInfo.aliasname) {
         label = pageInfo.aliasname;
      }

      // if alias is empty, then find label of page or tab
      if (
         !label ||
         // remove [en] or [th] etc.
         !label.replace(/\[.{2,}\]/g, "")
      ) {
         // first check to see if we are actually on a page
         // if not recursivly look up for the nearest parent page
         var pageId;
         if (pageInfo.pageId) {
            pageId = pageInfo.pageId;
         } else {
            pageId = this.getParentPageId(pageInfo);
         }
         // find label of the actual page
         var page = this.application.pages((p) => p.id == pageId, true)[0];
         if (page) {
            // find label of the tab view
            if (pageInfo.type == "tab" || pageInfo.key == "viewcontainer") {
               var tabView = page.views(
                  (v) => v.id == pageInfo.tabId || v.id == pageInfo.id,
                  true
               )[0];
               if (tabView) {
                  label = tabView.label;
               }
            } else {
               label = page.label;
            }
         }
      }

      return label;
   }

   getParentPageId(currentView) {
      if (currentView.key != "page") {
         return this.getParentPageId(currentView.parent);
      } else {
         return currentView.id;
      }
   }

   copy(lookUpIds, parent) {
      return super.copy(lookUpIds, parent).then((result) => {
         // update ids of page's settings
         (result.settings.pages || []).forEach((p, i) => {
            let page = result.settings.pages[i];

            // Compatible with old data
            if (typeof page == "string") {
               result.settings.pages[i] = lookUpIds[page];
            } else {
               page.pageId = lookUpIds[page.pageId];
               page.tabId = lookUpIds[page.tabId];
            }
         });

         return result.save().then(() => {
            return result;
         });
      });
   }
};


/***/ }),

/***/ 72094:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewPageCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewPage
 *
 * An ABView that represents a "Page" in the system.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);
// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-' )
};

const ABPropertyComponentDefaults = {
   type: "page", // 'page', 'popup' or 'reportPage'
   popupWidth: 700,
   popupHeight: 450,
   pageWidth: null,
   fixedPageWidth: 0,
   pageBackground: "ab-background-default",
};

module.exports = class ABViewPageCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABViewPage, but has
      // different implications ... so we default an ABViewPage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   static getPageActionKey(view) {
      return [
         "opstools",
         "AB_" + String(view.application.name).replace(/[^a-z0-9]/gi, ""),
         String(view.name)
            .replace(/[^a-z0-9]/gi, "")
            .toLowerCase(),
         "view",
      ].join(".");
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewPage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;

      obj.myAppID = this.myAppID;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.AB.error(
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      this.settings.columns = this.settings.columns || 1;
      this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABViewPage
            // be sure to remove any of it's ABViewPages as well
            // This cleans out any dangling ABDefinitions and cleans up the
            // OpsPortal Permissions:

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });

      // return new Promise((resolve, reject) => {
      //    // verify we have been .save() before:
      //    if (this.id) {
      //       this.application
      //          .viewDestroy(this)
      //          .then(() => {
      //             // remove the page in list
      //             var parent = this.parent || this.application;
      //             var remainingPages = parent.pages((p) => {
      //                return p.id != this.id;
      //             });
      //             parent._pages = remainingPages;

      //             resolve();
      //          })
      //          .catch(reject);
      //    } else {
      //       resolve(); // nothing to do really
      //    }
      // });
   }

   /**
    * @method save()
    * persist this instance of ABViewPage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABViewPages for this ABViewPage.
    *
    * @param {fn} filter		a filter fn to return a set of ABViewPages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         if (this._pages && this._pages.length > 0) {
            result = this._pages.filter(filter);

            if (result.length < 1) {
               this._pages.forEach((p) => {
                  var subPages = p.pages(filter, deep);
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
               });
            }
         }
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABViewPage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABViewPage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABViewPage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      values.key = ABViewDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABViewPage from our ._pages array and persist the current
    * values.
    *
    * @param {ABViewPage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method urlView()
    * return the url pointer for views in this application.
    * @return {string}
    */
   urlPage() {
      return this.urlPointer() + "/_pages/";
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlPage() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABViewDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABViewPage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABViewPage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
};


/***/ }),

/***/ 57766:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewPivotCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewPivotPropertyComponentDefaults = {
   dataviewID: null,
   removeMissed: 0,
   totalColumn: 0,
   separateLabel: 0,
   min: 0,
   max: 0,
   height: 0,
};

const ABViewDefaults = {
   key: "pivot", // {string} unique key for this view
   icon: "cube", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.pivot", // {string} the multilingual label key for the class label
};

module.exports = class ABViewPivotCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPivotPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // Convert to boolean
      this.settings.removeMissed = JSON.parse(
         this.settings.removeMissed ||
            ABViewPivotPropertyComponentDefaults.removeMissed
      );
      this.settings.totalColumn = JSON.parse(
         this.settings.totalColumn ||
            ABViewPivotPropertyComponentDefaults.totalColumn
      );
      this.settings.separateLabel = JSON.parse(
         this.settings.separateLabel ||
            ABViewPivotPropertyComponentDefaults.separateLabel
      );
      this.settings.min = JSON.parse(
         this.settings.allowDelete || ABViewPivotPropertyComponentDefaults.min
      );
      this.settings.max = JSON.parse(
         this.settings.max || ABViewPivotPropertyComponentDefaults.max
      );

      if (this.settings.structure && typeof this.settings.structure == "string")
         this.settings.structure = JSON.parse(this.settings.structure);

      // "0" -> 0
      this.settings.height = parseInt(
         this.settings.height || ABViewPivotPropertyComponentDefaults.height
      );
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.views = [];
      obj.settings = obj.settings || {};

      if (this.settings.structure)
         obj.settings.structure = JSON.stringify(this.settings.structure);

      return obj;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 35154:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewReportsManagerCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewReportManagerPropertyComponentDefaults = {
   moduleList: [],
   queryList: []
};

const ABViewDefaults = {
   key: "reportsManager", // {string} unique key for this view
   icon: "wpforms", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.reportsManager" // {string} the multilingual label key for the class label
};

module.exports = class ABViewReportsManagerCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewReportManagerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.moduleList =
         this.settings.moduleList ||
         ABViewReportManagerPropertyComponentDefaults.moduleList;

      this.settings.queryList =
         this.settings.queryList ||
         ABViewReportManagerPropertyComponentDefaults.queryList;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.settings = obj.settings || {};

      return obj;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};



/***/ }),

/***/ 56463:
/*!************************************************!*\
  !*** ./AppBuilder/core/views/ABViewTabCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);
const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);

const ABViewTabPropertyComponentDefaults = {
   height: 0,
   minWidth: 0,
   stackTabs: 0, // use sidebar view instead of tabview
   darkTheme: 0, // set dark theme css or not
   sidebarWidth: 200, // width of sidebar menu when stacking tabs
   sidebarPos: "left", // the default position of sidebar
   iconOnTop: 0, // do you want to put the icon above the text label?
};

const ABViewTabDefaults = {
   key: "tab", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "Tab", // {string} the multilingual label key for the class label
};

module.exports = class ABViewTabCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewTabDefaults);
   }

   static common() {
      return ABViewTabDefaults;
   }

   static defaultValues() {
      return ABViewTabPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(this.settings.height);
      this.settings.minWidth = parseInt(this.settings.minWidth || 0);
      this.settings.stackTabs = parseInt(this.settings.stackTabs);
      this.settings.darkTheme = parseInt(this.settings.darkTheme);
      this.settings.sidebarWidth = parseInt(this.settings.sidebarWidth);
      this.settings.sidebarPos = this.settings.sidebarPos;
      this.settings.iconOnTop = parseInt(this.settings.iconOnTop);
   }

   addTab(tabName, tabIcon) {
      return this.application
         .viewNew(
            {
               key: ABViewContainer.common().key,
               label: tabName,
               tabicon: tabIcon,
            },
            this.application,
            this
         )
         .save();
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 55239:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewTextCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 11895);

const ABViewTextPropertyComponentDefaults = {
   text: "",
   // {string}
   // A multilingual text template that is used to display a given set of
   // values.

   height: 0,
   // {integer}
   // The default height of this widget.

   dataviewID: null,
   // {uuid}
   // The {ABDataCollection.id} of the datacollection this ABViewText is
   // pulling data from.
   // In most usage situations this ABView is tied to the data in an
   // ABDataCollection.  However, it is possible for an ABObject to be
   // directly assigned to the ABView, and that will be used instead.
};

const ABViewDefaults = {
   key: "text",
   // {string}
   // unique key for this view

   icon: "font",
   // {string}
   // fa-[icon] reference for this view

   labelKey: "Text",
   // {string}
   // the multilingual label key for the class label
};

module.exports = class ABViewTextCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      this._object = null;
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewTextPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.unTranslate(this, this, ["text"]);

      var obj = super.toObj();
      obj.views = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings = this.settings || {};

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height || ABViewTextPropertyComponentDefaults.height
      );

      // if this is being instantiated on a read from the Property UI,
      this.text = values.text || ABViewTextPropertyComponentDefaults.text;

      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.translate(this, this, ["text"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return ABDatacollection of this form
    *
    * @return {ABDatacollection}
    */
   get datacollection() {
      if (this.parent?.key == "dataview") {
         return this.AB.datacollectionByID(this.parent.settings.dataviewID);
      } else {
         return this.AB.datacollectionByID(this.settings.dataviewID);
      }
   }

   fieldKey(field) {
      let label = field.label || "";
      label = label.replace(/\(/g, "\\(");
      label = label.replace(/\)/g, "\\)");
      return label;
   }

   displayText(val, componentID) {
      var result = this.text;

      let clearTemplateValue = (result) => {
         return result.replace(/{(.*?)}/g, "");
      };

      var dv = this.datacollection;
      // if (!dv) return clearTemplateValue(result);

      var object = dv?.datasource ?? this._object;
      if (!object) return clearTemplateValue(result);

      const rowData = val || dv.getCursor() || {};

      object.fields().forEach((f) => {
         // add \\ in front of the regular expression special charactors
         // let label = f.label || "";
         // label = label.replace(/\(/g, "\\(");
         // label = label.replace(/\)/g, "\\)");
         let label = this.fieldKey(f);

         var template = new RegExp("{" + label + "}", "g");

         // IDEA: I'd like to keep all the image url logic INSIDE the ABFieldImage
         // object.  Is there some way we can simply call: f.imageTemplate(rowData)
         // and parse the results for the url to display here?

         var data = f.format(rowData);
         if (f.key == "image") {
            var fData = data;
            data = f.urlImage(fData);

            // Question: should we change f.urlImage() to return the defaultImageUrl
            // if fData is "" and .useDefaultImage = true?

            if (
               !fData &&
               f.settings.defaultImageUrl &&
               f.settings.useDefaultImage
            ) {
               data = f.urlImage(f.settings.defaultImageUrl);

               ////
               //// James:  Revisit this and make sure we are handling things ok now.
               // result = result.replace(
               //    "img",
               //    'img onload=\'AD.comm.hub.publish("component.adjust", {"containerID": "' +
               //       componentID +
               //       "\"});' "
               // );
               // } else if (
               //    fData != "" &&
               //    result.indexOf("onload") == -1 &&
               //    componentID
               // ) {
               // result = result.replace(
               //    "img",
               //    'img onload=\'AD.comm.hub.publish("component.adjust", {"containerID": "' +
               //       componentID +
               //       "\"});' "
               // );
            } else {
               ////
               //// James: It looks like this routine assumes the this.text template will
               //// only have 1 <img> tag in it.  Is that necessarilly true?
               ////
               //// If NOT, then we need to rethink this next line:

               result = result.replace(
                  "img",
                  "img onerror='this.parentNode.removeChild(this);' "
               );
            }
         }

         result = result.replace(template, data);
      });

      // Support {uuid} tag in tempalte
      result = result.replace(/{PK}/g, rowData[object.PK()]);

      return result;
   }

   objectLoad(object) {
      this._object = object;
   }
};


/***/ }),

/***/ 29436:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewWidgetCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 10902);

const ABViewDefaults = {
   key: "viewwidget", // {string} unique key for this view
   icon: "circle-o-notch ", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.widget", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columnSpan: 1,
   rowSpan: 1,
};

module.exports = class ABViewWidgetCore extends ABView {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columnSpan = parseInt(
         this.settings.columnSpan || ABPropertyComponentDefaults.columnSpan
      );
      this.settings.rowSpan = parseInt(
         this.settings.rowSpan || ABPropertyComponentDefaults.rowSpan
      );
   }
};


/***/ }),

/***/ 51827:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABApplication.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _ = __webpack_require__(/*! lodash */ 96486);

// prettier-ignore
const ABApplicationCore = __webpack_require__(/*! ../core/ABApplicationCore.js */ 69885);

const ABViewPage = __webpack_require__(/*! ./views/ABViewPage */ 26239);
const ABViewManager = __webpack_require__(/*! ./ABViewManager */ 44312);

module.exports = class ABClassApplication extends ABApplicationCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // now listen for any updates to our managed objects
      this._handler_page_updated = (definition) => {
         var currPage = this._pages.find((p) => p.id === definition.id);
         if (currPage) {
            this._pages = this._pages.filter((p) => p.id != currPage.id);
            this._pages.push(currPage.refreshInstance());
         }
      };
      this._pages.forEach((p) => {
         p.on("definition.updated", this._handler_page_updated);
      });
   }

   static applications(/*fn = () => true*/) {
      console.error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      return null;
   }
   static applicationForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   static definitionForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.definitionForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   areaKey() {
      return this.AB.kebabCase(`ab-${this.name}`);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABApplication.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.applicationByID(this.id);

      // remove my listeners
      this._pages.forEach((p) => {
         p.removeListener("definition.updated", this._handler_page_updated);
      });

      return newObj;
   }

   ///
   /// Definition
   ///

   /**
    * @method _listInsert()
    * save the given entity into our desired list:
    * @param {varid} entity
    * @param {string} key
    *        the key of the list we are managing
    * @return {Promise}
    */
   async _listInsert(entity, key) {
      var isIncluded = this[key].indexOf(entity.id) != -1;
      if (!isIncluded) {
         this[key].push(entity.id);
         await this.save();
      }
   }

   async _listRemove(entity, key) {
      var begLen = this[key].length;
      this[key] = this[key].filter((id) => {
         return id != entity.id;
      });
      // if there was a change then save this.
      if (begLen != this[key].length) {
         await this.save();
      }
   }

   /**
    * @method datacollectionInsert()
    * persist the current ABDataCollection in our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionInsert(dc) {
      return this._listInsert(dc, "datacollectionIDs");
   }

   /**
    * @method datacollectionRemove()
    * remove the given ABDataCollection from our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionRemove(dc) {
      return this._listRemove(dc, "datacollectionIDs");
   }

   /**
    * @method objectInsert()
    * persist the current ABObject in our list of .objectIDs.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectInsert(object) {
      return this._listInsert(object, "objectIDs");
   }

   /**
    * @method objectRemove()
    * remove the current ABObject from our list of .objectIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectRemove(object) {
      return this._listRemove(object, "objectIDs");
   }

   /**
    * @method processInsert()
    * persist the current ABProcess in our list of .processIDs.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processInsert(process) {
      this._processes.push(process);
      return this._listInsert(process, "processIDs");
   }

   /**
    * @method processRemove()
    * remove the current ABProcess from our list of .processIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processRemove(process) {
      this._processes = this._processes.filter((p) => p.id != process.id);
      return this._listRemove(process, "processIDs");
   }

   /**
    * @method queryInsert()
    * persist the current ABObjectQuery in our list of .queryIDs.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryInsert(query) {
      return this._listInsert(query, "queryIDs");
   }

   /**
    * @method queryRemove()
    * remove the current ABObjectQuery from our list of .queryIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryRemove(query) {
      return this._listRemove(query, "queryIDs");
   }

   /**
    * @method exportIDs()
    * export any relevant .ids for the necessary operation of this application.
    * @param {array} ids
    *         the array of ids to insert any relevant .ids into
    */
   exportIDs(ids) {
      // make sure we don't get into an infinite loop:
      if (ids.indexOf(this.id) > -1) return;

      ids.push(this.id);

      // start with Objects:
      this.objectsIncluded().forEach((o) => {
         o.exportIDs(ids);
      });

      // Queries
      this.queriesIncluded().forEach((q) => {
         q.exportIDs(ids);
      });

      // Datacollections
      // NOTE: currently the server doesn't make instances of DataCollections
      // so we manually parse the related info here:
      this.datacollectionIDs.forEach((dID) => {
         if (ids.indexOf(dID) > -1) return;

         var def = this.AB.definitionByID(dID);
         if (def) {
            ids.push(dID);
            if (def.settings.datasourceID) {
               var object = this.AB.objectByID(def.settings.datasourceID);
               if (object) {
                  object.exportIDs(ids);
               }
            }
         }
      });

      // Processes
      this.processes().forEach((p) => {
         p.exportIDs(ids);
      });

      // Pages
      // NOTE: currently the server doesn't make instances of ABViews
      // so we manually parse the object data here:
      var parseView = (view) => {
         if (ids.indexOf(view.id) > -1) return;
         ids.push(view.id);
         (view.pageIDs || []).forEach((pid) => {
            var pdef = this.AB.definitionByID(pid);
            if (pdef) {
               parseView(pdef);
            }
         });

         (view.viewIDs || []).forEach((vid) => {
            var vdef = this.AB.definitionByID(vid);
            if (vdef) {
               parseView(vdef);
            }
         });
      };

      var pageIDs = this._pages.map((p) => p.id);
      (pageIDs || []).forEach((pid) => {
         var pdef = this.AB.definitionByID(pid);
         if (pdef) {
            parseView(pdef);
         }
      });

      // return only unique entries:
      ids = this.AB.uniq(ids);
   }

   /**
    * @method pageNew()
    * return a new instance of an ABViewPage
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPage}
    */
   pageNew(values) {
      return new ABViewPage(values, this);
   }

   /**
    * @method pageInsert()
    * Insert a new ABViewPage into this Application.
    * @param {ABViewPage} page
    *        The instance of the page to save.
    * @return {Promise}
    */
   async pageInsert(page) {
      // var isIncluded = this.pageByID(page.id);
      var isIncluded = this._pages.filter((p) => p.id == page.id)[0];
      if (!isIncluded) {
         this._pages.push(page);
         // Save our own Info:
         return this.save();
      }
   }

   /**
    * @method pageRemove()
    * remove the current ABViewPage from our list of pages.
    * @param {ABViewPage} page
    * @return {Promise}
    */
   async pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
   }

   save() {
      // if someone just changed the name of our ABApplication, reflect that
      // in our Def.Name
      if (this.name != this.label) {
         this.name = this.label;
      }
      return super.save();
   }

   warningsEval() {
      this._warnings = [];

      //
      // check for valid object references:
      //
      var checks = {
         objectIDs: "object",
         queryIDs: "query",
         datacollectionIDs: "datacollection",
      };

      Object.keys(checks).forEach((k) => {
         this[k].forEach((id) => {
            var def = this.AB.definitionByID(id);
            if (!def) {
               this.emit(
                  "warning",
                  `Application is referencing a missing ${checks[k]}`,
                  {
                     appID: this.id,
                     id,
                  }
               );
            }
         });
      });

      //
      // Make sure there is some way to access this Application:
      //
      if (this.roleAccess.length == 0 && !this.isAccessManaged) {
         this.emit(
            "warning",
            "Application has no Role assigned, and is unaccessible."
         );
      }

      // do our Role references exist?
      var allRoles = this.AB.Account.rolesAll().map((r) => r.id);
      this.roleAccess.forEach((r) => {
         if (allRoles.indexOf(r) == -1) {
            this.emit(
               "warning",
               `Specified Role Access [${r}] does not exist in this system`,
               { role: r }
            );
         }
      });
   }

   warningsAll() {
      var warnings = [].concat(this._warnings);
      [
         "objectsIncluded",
         "queriesIncluded",
         "datacollectionsIncluded",
         "processes",
         "pages",
         "views",
      ].forEach((k) => {
         this[k]().forEach((o) => {
            warnings = warnings.concat(o.warningsAll());
         });
      });

      return warnings;
   }

   /**
    * @method mobileAppNew()
    *
    * return an instance of a new (unsaved) ABMobileApp that is tied to this
    * ABApplication.
    *
    * @return {ABMobileApp}
    */
   // mobileAppNew(values) {
   //    return new ABMobileApp(values, this);
   // }
};


/***/ }),

/***/ 8030:
/*!********************************************!*\
  !*** ./AppBuilder/platform/ABComponent.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABEmitter = __webpack_require__(/*! ./ABEmitter */ 73686);

const CustomComponentManager = __webpack_require__(/*! ../../webix_custom_components/customComponentManager */ 12864);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABComponent extends ABEmitter {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, AB) {
      super();

      // Transition Code:
      // make sure we have an this.AB
      if (App && App.AB) {
         this.AB = App.AB;
      }

      // passed in AB will override
      if (AB) {
         this.AB = AB;
         // {ABFactory} AB
      }

      if (!App) {
         if (AB._App) {
            App = AB._App;
         } else {
            App = {
               uuid: AB.Webix.uid(),

               /*
                * AB
                * the {ABFactory} for our interface.
                */
               AB: AB,

               /*
                * actions:
                * a hash of exposed application methods that are shared among our
                * components, so one component can invoke an action that updates
                * another component.
                */
               actions: {},

               /*
                * config
                * webix configuration settings for our current browser
                */
               config: AB.UISettings.config(),

               /*
                * custom
                * a collection of custom components for this App Instance.
                */
               custom: null,

               /*
                * Icons
                * this will provide you with the list of avaialbe font awesome 4.7.0 icons to use in interface building
                */
               icons: AB.UISettings.icons,

               Label: L,

               /*
                * labels
                * a collection of labels that are common for the Application.
                */
               labels: {
                  add: L("Add"),
                  create: L("Create"),
                  delete: L("Delete"),
                  edit: L("Edit"),
                  export: L("Export"),
                  formName: L("Name"),
                  import: L("Import"),
                  rename: L("Rename"),
                  ok: L("Ok"),

                  cancel: L("Cancel"),
                  save: L("Save"),

                  yes: L("Yes"),
                  no: L("No"),

                  none: L("None"),
                  close: L("Close"),

                  default: L("Default"),
                  defaultPlaceholder: L("Enter default value"),

                  disable: L("Disable"),

                  required: L("Required"),
                  unique: L("Unique"),

                  invalidMessage: {
                     required: L("This field is required"),
                  },

                  createErrorMessage: L("System could not create <b>{0}</b>."),
                  createSuccessMessage: L("<b>{0}</b> is created."),

                  updateErrorMessage: L("System could not update <b>{0}</b>."),
                  updateSucessMessage: L("<b>{0}</b> is updated."),

                  deleteErrorMessage: L("System could not delete <b>{0}</b>."),
                  deleteSuccessMessage: L("<b>{0}</b> is deleted."),

                  renameErrorMessage: L("System could not rename <b>{0}</b>."),
                  renameSuccessMessage: L("<b>{0}</b> is renamed."),

                  // Data Field  common Property labels:
                  dataFieldHeaderLabel: L("Section Title"),
                  dataFieldHeaderLabelPlaceholder: L("Section Name"),

                  dataFieldLabel: L("Label"),
                  dataFieldLabelPlaceholder: L("Label"),

                  dataFieldColumnName: L("Field Name"),
                  dataFieldColumnNamePlaceholder: L("Database field name"),

                  dataFieldShowIcon: L("show icon?"),

                  componentDropZone: L("add widgets here"),
               },

               /*
                * unique()
                * A function that returns a globally unique Key.
                * @param {string} key   The key to modify and return.
                * @return {string}
                */
               unique: function (key) {
                  return `${key}${this.uuid}`;
               },
            };
            AB._App = App;
         }
      }

      if (!App.custom) {
         if (!AB.custom) {
            var componentManager = new CustomComponentManager();
            componentManager.initComponents(App);
         } else {
            App.custom = AB.custom;
         }
      }

      this.App = App;

      this.idBase = idBase || "?idbase?";
   }

   actions(_actions) {
      console.error("!!! REFACTOR out .actions()");
      if (_actions) {
         for (var a in _actions) {
            this.App.actions[a] = _actions[a];
         }
      }
   }

   Label() {
      return (...params) => {
         // console.error("!! App.label() depreciated.");
         return this.AB.Multilingual.label(...params);
      };
   }

   unique(key) {
      return this.App.unique(`${this.idBase}_${key}`);
   }
};


/***/ }),

/***/ 11579:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ABDataCollection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObjectQuery = __webpack_require__(/*! ./ABObjectQuery */ 88447);
const ABDataCollectionCore = __webpack_require__(/*! ../core/ABDataCollectionCore */ 6980);

module.exports = class ABDataCollection extends ABDataCollectionCore {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.setMaxListeners(0);
   }

   /**
    * @method save()
    *
    * persist this instance of ABDataCollection with it's parent
    *
    *
    * @return {Promise}
    *			.resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      this.AB.emit("ab.datacollection.update", {
         datacollectionId: this.id,
      });
      return this;
   }

   isValid() {
      var validator = this.AB.Validation.validator();
      var L = this.AB.Label();

      // label/name must be unique:
      var isNameUnique =
         this.AB.datacollections((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Name must be unique ("{0}" already in use)', [this.name])
         );
      }

      return validator;
   }

   ///
   /// Cursor
   ///

   /**
    * currentUserUsername
    * must return the proper value for the current user that would match a "user" field
    * in an object.
    * This is platform dependent, so must be implemented by a child object.
    * @return {string}
    */
   currentUserUsername() {
      return this.AB.Account.username();
   }

   ///
   /// Data
   ///

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      // this.initialized = true;  // <<---- DO NOT SET THIS HERE

      super.init();

      //// Now connect our platform hub to our Object Triggers:

      // events
      this.AB.on("ab.datacollection.create", (data) => {
         // debugger;
         this.emit("ab.datacollection.create", data);
      });

      this.AB.on("ab.datacollection.update", (data) => {
         // debugger;
         this.emit("ab.datacollection.update", data);
      });

      // We are subscribing to notifications from the server that an item may
      // be stale and needs updating
      // We will improve this later and verify that it needs updating before
      // attempting the update on the client side
      this.AB.on("ab.datacollection.stale", (data) => {
         // debugger;
         this.emit("ab.datacollection.stale", data);
      });

      this.AB.on("ab.datacollection.delete", (data) => {
         // debugger;
         this.emit("ab.datacollection.delete", data);
      });

      this.bindParentDc();
   }

   bindParentDc() {
      // if we pass the master datacollection and the field it is linked to
      // we want to bind it witht hat field as second param so dataFeed is
      // used on the slave datacollection
      let dataCollectionLink = this.datacollectionLink;
      let fieldLink = this.fieldLink;
      if (!this.settings.loadAll && dataCollectionLink && fieldLink) {
         let dc = this.__dataCollection;
         // the second param is the field id we bind the data to the master with
         dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
         // defining dataFeed allows us to query the database when the table is scrolled
         dc.define("dataFeed", (value, params) => {
            // copy current wheres
            var wheres = this.AB.cloneDeep(
               this.settings.objectWorkspace.filterConditions
            );
            // add bind items data as a filter to wheres
            if (value) {
               // don't include an empty where condition in our .rules
               // start by replacing it with null
               if (!wheres.rules) {
                  wheres = null;
               }

               wheres = {
                  glue: "and",
                  rules: [
                     wheres,
                     {
                        alias: fieldLink.alias, // ABObjectQuery
                        key: Object.keys(params)[0],
                        rule: fieldLink.alias ? "contains" : "equals", // NOTE: If object is query, then use "contains" because ABOBjectQuery return JSON
                        value: fieldLink.getRelationValue(
                           dataCollectionLink.__dataCollection.getItem(value)
                        ),
                     },
                  ],
               };

               // remove any null in the .rules
               wheres.rules = wheres.rules.filter((r) => r);
            }

            // this is the same item that was already bound...don't reload data
            if (
               JSON.stringify(this.__reloadWheres) == JSON.stringify(wheres) ||
               (wheres.rules && wheres.rules.length == 0)
            ) {
               return;
            } else {
               // now that we have the modified wheres the dataCollections wheres
               // need to be modified for subsequent loads on scroll so lets set them
               this.reloadWheres(wheres);
               // reload data
               this.reloadData(0, 20);
            }
         });
      }
   }

   loadData(start, limit = 20) {
      return super.loadData(start, limit).catch((err) => {
         // hideProgressOfComponents() is a platform specific action.
         this.hideProgressOfComponents();

         // propagate the error here:
         if (err) {
            throw err;
         }
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      // Web Platform:

      // data check:
      if (data.data && !Array.isArray(data.data)) {
         data.data = [data.data];
      }

      // standardize the heights

      /*
       // In v2: we move the row height calculation into the Interface designer.
       //

      // calculate default value of $height of rows
      let obj = this.datasource;
      let defaultHeight = 0;
      let minHeight = 0;
      let imageFields = obj.fields((f) => f.key == "image");
      let hiddenFields = obj.objectWorkspace.hiddenFields;
      imageFields.forEach(function (f) {
         if (hiddenFields.indexOf(f.columnName) == -1) {
            if (
               parseInt(f.settings.useHeight) == 1 &&
               parseInt(f.settings.imageHeight) > minHeight
            ) {
               minHeight = parseInt(f.settings.imageHeight) + 20;
            } else {
               minHeight = 100;
            }
         }
      });
      if (minHeight > 0) {
         defaultHeight = minHeight;
      }

      (data.data || []).forEach((d) => {
         // define $height of rows to render in webix elements
         if (
            d.properties != null &&
            d.properties.height != "undefined" &&
            parseInt(d.properties.height) > 0
         ) {
            d.$height = parseInt(d.properties.height);
         } else if (defaultHeight > 0) {
            d.$height = defaultHeight;
         }
      });
      */

      return super.processIncomingData(data).then(() => {
         // Web Platform:
         // when that is done:
         this.hideProgressOfComponents();
      });
   }

   ///
   /// Components
   ///

   /**
    * @method attachFlexlayout
    *
    *
    * @param {Object} component - a webix flexlayout element instance
    */
   attachFlexlayout(component) {
      var dc = this.__dataCollection;

      // prevent attach many times
      if (this.__flexComponentIds.indexOf(component.config.id) > -1) {
         return;
      } else {
         // keep component id to an array
         this.__flexComponentIds.push(component.config.id);
      }
   }

   /**
    * @method bind
    *
    *
    * @param {Object} component - a webix element instance
    */
   bind(component) {
      var dc = this.__dataCollection;

      // prevent bind many times
      if (
         this.__bindComponentIds.indexOf(component.config.id) > -1 &&
         $$(component.config.id).data &&
         $$(component.config.id).data.find &&
         $$(component.config.id).data.find({}).length > 0
      )
         return;
      // keep component id to an array
      else this.__bindComponentIds.push(component.config.id);

      if (
         component.config.view == "datatable" ||
         component.config.view == "dataview" ||
         component.config.view == "treetable" ||
         component.config.view == "kanban"
      ) {
         if (dc) {
            var items = dc.count();
            if (
               items == 0 &&
               (this._dataStatus == this.dataStatusFlag.notInitial ||
                  this._dataStatus == this.dataStatusFlag.initializing) &&
               component.showProgress
            ) {
               component.showProgress({ type: "icon" });
            }

            component.define("datafetch", 20);
            component.define("datathrottle", 500);

            // initial data of treetable
            if (component.config.view == "treetable") {
               if (
                  this.datasource &&
                  this.datasource.isGroup &&
                  this.__treeCollection
               ) {
                  component.define("data", this.__treeCollection);
                  component.refresh();
               } else {
                  // NOTE: tree data does not support dynamic loading when scrolling
                  // https://forum.webix.com/discussion/3078/dynamic-loading-in-treetable
                  component.define("data", []);
                  component.parse(dc.find({}));
               }
            } else {
               component.data.sync(dc);
            }

            // Implement .onDataRequest for paging loading
            if (!this.settings.loadAll) {
               component.___AD = component.___AD || {};
               // if (component.___AD.onDataRequestEvent) component.detachEvent(component.___AD.onDataRequestEvent);
               if (!component.___AD.onDataRequestEvent) {
                  component.___AD.onDataRequestEvent = component.attachEvent(
                     "onDataRequest",
                     (start, count) => {
                        if (component.showProgress)
                           component.showProgress({ type: "icon" });

                        // load more data to the data collection
                        dc.loadNext(count, start);

                        return false; // <-- prevent the default "onDataRequest"
                     }
                  );
               }

               // // NOTE : treetable should use .parse or TreeCollection
               // // https://forum.webix.com/discussion/1694/tree-and-treetable-using-data-from-datacollection
               // if (
               //    component.config.view == "treetable" &&
               //    !this.datasource.isGroup
               // ) {
               //    component.___AD = component.___AD || {};
               //    if (!component.___AD.onDcLoadData) {
               //       component.___AD.onDcLoadData = () => {
               //          component.parse(dc.find({}));
               //       };

               //       this.on("loadData", component.___AD.onDcLoadData);
               //    }
               // }
            }
         } else {
            component.data.unsync();
         }
      } else if (component.bind) {
         if (dc) {
            // Do I need to check if there is any data in the collection before binding?
            component.bind(dc);
         } else {
            component.unbind();
         }

         if (component.refresh) component.refresh();
      }
   }

   unbind(component) {
      if (!component) return;

      component.detachEvent("onDataRequest");
      if (component.___AD) {
         if (component.___AD.onDataRequestEvent)
            delete component.___AD.onDataRequestEvent;

         if (component.___AD.onDcLoadData) {
            if (this.off) this.off("loadData", component.___AD.onDcLoadData);
            delete component.___AD.onDcLoadData;
         }
      }

      if (component.data && component.data.unsync) {
         component.data.unsync();
         component.define("data", []);
      }

      if (component.unbind) component.unbind();

      if (component.refresh) component.refresh();

      // remove from array
      this.__bindComponentIds = (this.__bindComponentIds || []).filter(
         (id) => id != component.config.id
      );
   }

   hideProgressOfComponents() {
      this.__bindComponentIds.forEach((comId) => {
         if ($$(comId) && $$(comId).hideProgress) $$(comId).hideProgress();
      });
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(data) {
      // get a webix data collection
      let dc = new webix.DataCollection({
         data: data || [],
      });

      this._extendCollection(dc);

      return dc;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      // get a webix data collection
      let treeStore = new webix.TreeCollection();

      this._extendCollection(treeStore);

      return treeStore;
   }

   _extendCollection(dataStore) {
      // Apply this data collection to support multi-selection
      // https://docs.webix.com/api__refs__selectionmodel.html
      webix.extend(dataStore, webix.SelectionModel);

      dataStore.___AD = dataStore.___AD || {};

      // Implement .onDataRequest for paging loading
      if (!this.settings.loadAll) {
         if (!dataStore.___AD.onDataRequestEvent) {
            dataStore.___AD.onDataRequestEvent = dataStore.attachEvent(
               "onDataRequest",
               (start, count) => {
                  if (start < 0) start = 0;

                  // load more data to the data collection
                  this.loadData(start, count);

                  return false; // <-- prevent the default "onDataRequest"
               }
            );
         }

         if (!dataStore.___AD.onAfterLoadEvent) {
            dataStore.___AD.onAfterLoadEvent = dataStore.attachEvent(
               "onAfterLoad",
               () => {
                  this.emit("loadData", {});
               }
            );
         }
      }

      // override unused functions of selection model
      dataStore.addCss = function () {};
      dataStore.removeCss = function () {};
      dataStore.render = function () {};

      if (!dataStore.___AD.onAfterLoad) {
         dataStore.___AD.onAfterLoad = dataStore.attachEvent(
            "onAfterLoad",
            () => {
               this.hideProgressOfComponents();
            }
         );
      }
   }

   parseTreeCollection(data = {}) {
      if (
         !(this.__datasource instanceof ABObjectQuery) ||
         !this.__datasource.isGroup ||
         !this.__treeCollection
      )
         return;

      let addRowToTree = (join = {}, parentAlias = null) => {
         let alias = join.alias;

         (data.data || []).forEach((row) => {
            let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
            if (!dataId) return;

            // find parent nodes
            let parentItemIds = [];
            let parentId =
               row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
            if (parentId) {
               parentItemIds = this.__treeCollection
                  .find(
                     (item) =>
                        item._alias == parentAlias && item._dataId == parentId
                  )
                  .map((item) => item.id);
            }

            // check exists
            let exists = this.__treeCollection.find((item) => {
               return (
                  item._alias == alias &&
                  item._dataId == dataId &&
                  (parentItemIds.length == 0 ||
                     parentItemIds.indexOf(item.$parent) > -1)
               );
            }, true);
            if (exists) return;

            let treeNode = {};
            treeNode._alias = alias;
            treeNode._dataId = dataId;
            treeNode._itemId = row.id; // Keep row id for set cursor to data collection

            Object.keys(row).forEach((propName) => {
               // Pull value from alias
               if (propName.indexOf(`${alias}.`) == 0) {
                  treeNode[propName] = row[propName];
               }
            });

            if (row.translations) treeNode.translations = row.translations;

            // child nodes
            if (parentItemIds.length > 0)
               parentItemIds.forEach((parentItemId) => {
                  this.__treeCollection.add(treeNode, null, parentItemId);
               });
            // root node
            else this.__treeCollection.add(treeNode, null);
         });

         // Sub-joins
         (join.links || []).forEach((link) => {
            addRowToTree(link, alias);
         });
      };

      // Show loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         //// Webix Command here:
         let boundComp = $$(comId);
         if (boundComp && boundComp.showProgress)
            boundComp.showProgress({ type: "icon" });

         if (boundComp.data && boundComp.data.unsync) boundComp.data.unsync();
      });

      addRowToTree(this.__datasource.joins());

      // Hide loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         let boundComp = $$(comId);
         if (boundComp && boundComp.hideProgress) boundComp.hideProgress();
         boundComp.define("data", this.__treeCollection);
      });
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      const allWarnings = [].concat(this._warnings);

      if (!this.datasource) {
         allWarnings.push({
            message: `Datacollection[${this.label}][${this.id}] doesn't have a datasource.`,
            data: {},
         });
      } else if (this.linkDatacollectionID) {
         const linkDC = this.AB.datacollectionById(this.linkDatacollectionID);

         if (linkDC)
            allWarnings.push({
               message: `Datacollection[${this.label}][${this.id}] can't resolve linkDatacollectionID[${this.linkDatacollectionID}]`,
               data: {},
            });
      }

      return allWarnings;
   }

   warningsEval() {
      // our .fromValues() has already registered any missing fields.
      // those should get reported from warnings()
   }

   get userScopes() {
      return this.AB.Account.scopes();
   }
};


/***/ }),

/***/ 65741:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/ABDefinition.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ABDefinitionCore = __webpack_require__(/*! ../core/ABDefinitionCore */ 40052);

module.exports = class ABDefinition extends ABDefinitionCore {
   // constructor(attributes, AB) {
   //    super(attributes, AB);
   // }
};


/***/ }),

/***/ 73686:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABEmitter.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABEmitter
 *
 * This is the platform dependent implementation of an Emitter object.
 *
 */

var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);

module.exports = class ABEmitter extends EventEmitter {
   constructor() {
      super(/*{ maxListeners: 0 }*/);
   }
};


/***/ }),

/***/ 5437:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ABIndex.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABIndexCore = __webpack_require__(/*! ../core/ABIndexCore */ 25739);

module.exports = class ABIndex extends ABIndexCore {
   // constructor(attributes, object) {
   //    super(attributes, object);
   // }

   /**
    * @method save()
    * persist this instance of ABIndex with it's parent ABObject
    * @return {Promise}
    */
   save() {
      return super
         .save()
         .then(() => this.object.indexSave(this))
         .then(() => this.migrateCreate());
   }

   /**
    * @method destroy()
    * destroy the current instance of ABIndex
    * also remove it from our parent ABObject
    * @return {Promise}
    */
   destroy() {
      return new Promise((resolve, reject) => {
         if (this.id) {
            this.migrateDrop()
               .then(() => {
                  return super.destroy();
               })
               .then(() => this.object.indexRemove(this))
               .then(resolve)
               .catch(reject);
         } else {
            resolve();
         }
      });
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
         // data: this.toObj(),
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
      });
   }
};


/***/ }),

/***/ 97069:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABMLClass.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABMLClass
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This platform ABMLClass will define 2 methods that allow for the translation
 * untranslation of this data.
 */
var ABMLClassCore = __webpack_require__(/*! ../core/ABMLClassCore */ 17243);

module.exports = class ABMLClass extends ABMLClassCore {
   constructor(fieldList, AB) {
      super(fieldList, AB);

      this._warnings = [];
      // {array}
      // an array of warning messages for this object.

      this.on("warning", (message, data) => {
         this._warnings.push({ message, data });
      });
   }

   // fromValues(attributes) {
   //    super.fromValues(attributes);
   // }

   warnings() {
      return this._warnings;
   }

   warningsEval() {
      this._warnings = [];
      // if (
      //    ["datacollection", "object", "query", "process"].indexOf(this.type) >
      //    -1
      // ) {
      //    console.warn(
      //       `ABML Object [${this.type}][${this.label}] has not overwritten .warningsEval()`
      //    );
      // }

      // many of our warnings are generated during the .fromValues() method
      // when we initialize our Objects.  So, cause this process to repeat.
      this.fromValues(this.toObj());
   }

   warningsAll() {
      // console.warn(
      //    `ABML Object [${this.label}] has not overwritten .warningsAll()`
      // );
      return this.warnings();
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return this.AB.Account.language() || "en";
   }

   /**
    * @method destroy()
    * remove this definition.
    * @return {Promise}
    */
   async destroy() {
      var def = this.toDefinition();
      if (def.id) {
         return def.destroy().catch((err) => {
            if (err.toString().indexOf("No record found") > -1) {
               // this is weird, but not breaking:
               console.log(
                  `ABMLClass.destroy(): could not find record for id[${def.id}]`
               );
               console.log(def);
               return;
            }
            throw err;
         });
      }
      return Promise.resolve();
   }

   /**
    * @method save()
    * persist this definition of our {ABxxx} Object
    * @return {Promise}
    */
   async save() {
      var def = this.toDefinition();
      // if not name, try to use our label as the name
      def.name = def.name || this.name || this.label || "name";
      var data = await def.save();
      if (!this.id) {
         this.id = data.id;
      }
   }
};


/***/ }),

/***/ 48912:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ABModel.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABModelCore = __webpack_require__(/*! ../core/ABModelCore */ 71692);

//
// ABModel
//
// Represents the Data interface for an ABObject data.
//
// 2 ways to use an ABModel to load a DataTable:
// 	Method 1:
// 	gather all the data externally and send to the DataTable
//		Model.findAll()
//		.then((data)=>{
//			DataTable.parse(data);
//		})
//
// 	Method 2:
// 	Set the Model object with a condition / skip / limit, then
// 	use it to load the DataTable:
//		Model.where({})
//		.skip(XX)
//		.limit(XX)
//		.loadInto(DataTable);

function errorPopup(error) {
   // Show the pop up
   if (error && error.data && error.data.error == "READONLY") {
      webix.alert({
         title: "Your action is blocked",
         ok: "Ok",
         text: error.data.message || "",
         type: "alert-warning",
      });
   }
}

/*
 * @function no_socket_trigger()
 * a common routine to trigger an update.
 * In the case where our AB.Network.type() isn't a socket implementation
 * we need to manually trigger the expected socket events ourselves.
 * This fn() attempts to simulate the socket responses in such a case.
 * @param {ABModel} model
 *        The ABModel currently processing the network transaction.
 * @param {string} key
 *        The socket update trigger we are simulating.
 * @param {json} data
 *        The relevant response from our network transaction.
 */
function no_socket_trigger(model, key, data) {
   // If we do not have socket updates available, then trigger an
   // update event with this data.
   if (model.AB.Network.type() != "socket") {
      model.AB.emit(key, {
         objectId: model.object.id,
         data,
      });
   }
}

module.exports = class ABModel extends ABModelCore {
   constructor(object) {
      super(object);

      this.handler_create = (...params) => {
         this.handler_common("ab.datacollection.create", ...params);
      };

      this.handler_delete = (...params) => {
         this.handler_common("ab.datacollection.update", ...params);
      };

      this.handler_findAll = (...params) => {
         this.handler_common(null, ...params);
      };

      this.handler_logs = (context, err, data) => {
         if (err) {
            context.reject?.(err);
            return;
         }
         context.resolve?.(data);
      };

      this.handler_update = (...params) => {
         this.handler_common("ab.datacollection.update", ...params);
      };

      this.handler_common = (key, context, err, data) => {
         // key: {string} the relevant socket event key
         //      can be null if not relevant.
         // context : {obj} any provided context data provided on the
         //           this.AB.Network.get() call.
         // err: {Error} any returned error message from api
         // data: {obj} returned data from the model-get api in format:
         //       {data: [], total_count: 1, pos: 0, offset: 0, limit: 0}
         if (err) {
            context.reject?.(err);
            return;
         }
         if (key) {
            // on "update" & "create" we want to normalizeData()
            if (key.indexOf("delete") == -1) {
               this.normalizeData(data);
            }
         } else {
            // on a findAll we normalize data.data
            this.normalizeData(data.data);
         }

         context.resolve?.(data);

         if (key) {
            no_socket_trigger(this, key, data);
         }
      };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      return this.AB.Network[method](params);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      values.batch.map((vals) => {
         return this.prepareMultilingualData(vals.data);
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err, data) => {
            if (err) {
               reject(err);
               return;
            }
            this.normalizeData(data);
            resolve(data);
            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a create event
            // triggerEvent('create', this.object, data);
         });

         this.AB.Network.post(
            {
               url: this.object.urlRestBatch(),
               params: values,
            },
            {
               key: jobID,
               context: {},
            }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // FIX: now with sockets, the triggers are fired from socket updates.
            //    // trigger a create event
            //    // triggerEvent('create', this.object, data);
            // })
            .catch(reject);
      });
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      this.prepareMultilingualData(values);

      // add default values record if no value is passed for column
      this.object.fields().forEach((f) => {
         if (values[f.columnName] === undefined) {
            f.defaultValue(values);
         }
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_create);
         this.AB.Network.post(
            {
               url: this.object.urlRest(),
               params: values,
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_delete);
         this.AB.Network["delete"](
            {
               url: this.object.urlRestItem(id),
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   findAll(cond) {
      cond = cond || {};

      // 		// prepare our condition:
      // 		var newCond = {};

      // 		// if the provided cond looks like our { where:{}, skip:xx, limit:xx } format,
      // 		// just use this one.
      // 		if (cond.where) {
      // 			newCond = cond;
      // 		} else {

      // 			// else, assume the provided condition is the .where clause.
      // 			newCond.where = cond;
      // 		}

      // /// if this is our depreciated format:
      // if (newCond.where.where) {
      // 	OP.Error.log('Depreciated Embedded .where condition.');
      // }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_findAll);
         this.AB.Network.get(
            {
               url: this.object.urlRest(),
               params: cond,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         )
            // .then((data) => {
            //    this.normalizeData(data.data);

            //    resolve(data);
            // })
            .catch((err) => {
               if (err && err.code) {
                  switch (err.code) {
                     case "ER_PARSE_ERROR":
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Parse Error with provided condition",
                           condition: cond,
                        });
                        break;

                     default:
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Unknown Error with provided condition",
                           condition: cond,
                        });
                        break;
                  }
               }
               reject(err);
            });
      });
   }

   /**
    * @method loadInto
    * loads the current values into the provided Webix DataTable
    * @param {DataTable} DT  A Webix component that can dynamically load data.
    */
   loadInto(DT) {
      // if a limit was applied, then this component should be loading dynamically
      if (this._limit) {
         DT.define("datafetch", this._limit);
         DT.define("datathrottle", 250); // 250ms???

         // catch the event where data is requested:
         // here we will do our own findAll() so we can persist
         // the provided .where condition.

         // oh yeah, and make sure to remove any existing event handler when we
         // perform a new .loadInto()
         DT.___AD = DT.___AD || {};
         if (DT.___AD.onDataRequestEvent) {
            DT.detachEvent(DT.___AD.onDataRequestEvent);
         }
         DT.___AD.onDataRequestEvent = DT.attachEvent(
            "onDataRequest",
            (start, count) => {
               var cond = {
                  where: this._where,
                  sort: this._sort,
                  limit: count,
                  skip: start,
               };

               if (DT.showProgress) DT.showProgress({ type: "icon" });

               this.findAll(cond).then((data) => {
                  /*
                   // In V2: we move the row height processing into 
                   // the interface designer 

                  data.data.forEach((item) => {
                     if (
                        item.properties != null &&
                        item.properties.height != "undefined" &&
                        parseInt(item.properties.height) > 0
                     ) {
                        item.$height = parseInt(item.properties.height);
                     } else if (parseInt(this._where.height) > 0) {
                        item.$height = parseInt(this._where.height);
                     }
                  });
                  */
                  DT.parse(data);

                  if (DT.hideProgress) DT.hideProgress();
               });

               return false; // <-- prevent the default "onDataRequest"
            }
         );

         DT.refresh();
      }

      // else just load it all at once:
      var cond = {};
      if (this._where) cond.where = this._where;
      if (this._sort) cond.sort = this._sort;
      if (this._limit != null) cond.limit = this._limit;
      if (this._skip != null) cond.skip = this._skip;

      if (DT.showProgress) DT.showProgress({ type: "icon" });

      this.findAll(cond)
         .then((data) => {
            // v2: we no longer process item $height
            /*
            data.data.forEach((item) => {
               if (
                  item.properties != null &&
                  item.properties.height != "undefined" &&
                  parseInt(item.properties.height) > 0
               ) {
                  item.$height = parseInt(item.properties.height);
               } else if (parseInt(this._where.height) > 0) {
                  item.$height = parseInt(this._where.height);
               }
            });
            */

            DT.parse(data);

            if (DT.hideProgress) DT.hideProgress();
         })
         .catch((err) => {
            console.error("!!!!!", err);
         });
   }

   /**
    * @method logs()
    * return the log history related to this model's ABObject.
    * @param {hash} options
    *        a key=>value hash of optional search criteria
    *        .rowId {string} the uuid of the individual entry we are querying
    *        .levelName {string} the type of entry ["insert", "update", "delete"]
    *        .username {string} the entries associated with the given user
    *        .startDate {date} entries that happened ON or AFTER this date
    *        .endDate {date} entries that happened ON or BEFORE this date
    *        .start {integer} paging control: how many entries to skip
    *        .limit {integer} paging control: only return this # entries
    * @return {Promise}
    */
   logs(options) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_logs);
         this.AB.Network.get(
            {
               url: this.object.urlRestLog(),
               params: options,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            if (err && err.code) {
               this.AB.notify.developer(err, {
                  context: "AppBuilder:ABModel:logs(): Error",
                  options,
               });
            }
            reject(err);
         });
      });
   }

   /**
    * @method limit
    * set the limit value for this set of data
    * @param {integer} limit  the number or elements to return in this call
    * @return {ABModel} this object that is chainable.
    */
   limit(limit) {
      this._limit = limit;
      return this;
   }

   /**
    * @method skip
    * set the skip value for this set of data
    * @param {integer} skip  the number or elements to skip
    * @return {ABModel} this object that is chainable.
    */
   skip(skip) {
      this._skip = skip;
      return this;
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_update);
         this.AB.Network.put(
            {
               url: this.object.urlRestItem(id),
               params: values,
            },
            { key: jobID, context: { resolve, reject } }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // If we do not have socket updates available, then trigger an
            //    // update event with this data.
            //    if (this.AB.Network.type() != "socket") {
            //       this.AB.emit("ab.datacollection.update", {
            //          objectId: this.object.id,
            //          data,
            //       });
            //    }
            // })
            .catch((err) => {
               errorPopup(err);
               reject(err);
            });
      });
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err /*, data */) => {
            if (err) {
               reject(err);
               return;
            }
            // this.normalizeData(data);
            resolve(true);
            // what about checking for socket updates?
         });
         this.AB.Network.put(
            {
               url: this.object.urlRestBatch(),
               params: {
                  rowIds,
                  values,
               },
            },
            { key: jobID, context: {} }
         )
            // .then(() => {
            //    resolve(true);
            // })
            .catch(reject);
      });
   }
};


/***/ }),

/***/ 94371:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/ABModelQuery.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABModelQuery
//
// Represents the Data interface for an ABObjectQuery data.

const ABModel = __webpack_require__(/*! ./ABModel */ 48912);

module.exports = class ABModelQuery extends ABModel {
   ///
   /// Instance Methods
   ///

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchCreate() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.create() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.delete() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.update() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchUpdate() should not be called."
      );
      return Promise.reject(error);
   }
};


/***/ }),

/***/ 67826:
/*!*****************************************!*\
  !*** ./AppBuilder/platform/ABObject.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObjectCore = __webpack_require__(/*! ../core/ABObjectCore */ 96937);
const ABObjectWorkspaceViewCollection = __webpack_require__(/*! ./workspaceViews/ABObjectWorkspaceViewCollection */ 23847);

let L = (...params) => AB.Multilingual.label(...params);

// NOTE: this has been moved to NetworkRestSocket:
//
// // Start listening for server events for object updates and call triggerEvent as the callback
// if (typeof io != "undefined") {
//    io.socket.on("ab.object.update", function (msg) {
//       AB.emit("ab.object.update", {
//          objectId: msg.objectId,
//          data: msg.data,
//       });
//    });
// } else {
//    console.error("TODO: ABObject: configure Socket.io");
// }

// io.socket.on("ab.object.delete", function (msg) {
// });

module.exports = class ABObject extends ABObjectCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      this.workspaceViews = new ABObjectWorkspaceViewCollection(
         attributes,
         this,
         AB
      );

      // listen for our ABFields."definition.updated"
      this.fields().forEach((f) => {
         f.on("definition.updated", (field) => {
            // create a new Field with the updated def
            var def = this.AB.definitionByID(field.id);
            if (!def) return;

            var newField = this.AB.fieldNew(def, this);

            // we want to keep the same fieldID order:
            var newFields = [];
            this.fields().forEach((f) => {
               if (f.id === field.id) {
                  newFields.push(newField);
                  return;
               }
               newFields.push(f);
            });

            this._fields = newFields;
         });
      });

      // listen
      // this.AB.on("ab.object.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our migrateXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this._handler_object_migrate = (context, err, response) => {
         // NOTE:
         var pending = this._pendingNetworkRequests?.[context.uuid];
         if (err) {
            pending?.reject(err);
            return;
         }
         pending?.resolve(response);
      };
      this.AB.Network.on("object.migrate", this._handler_object_migrate);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABObject.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.objectByID(this.id);

      // prevent doing this multiple times:
      if (this._pendingNetworkRequests) {
         // remove object.migrate listener
         this.AB.Network.removeListener(
            "object.migrate",
            this._handler_object_migrate
         );

         // transfer the pending network requests
         newObj._pendingNetworkRequests = this._pendingNetworkRequests;
         this._pendingNetworkRequests = null;
      }

      return newObj;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			labelFormat: 'xxxxx',
			isImported: 1/0,
			isExternal: 1/0,
			urlPath:'string',
			importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
										// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
			translations:[
				{}
			],
			fields:[
				{ABDataField}
			]
		}
		*/

      super.fromValues(attributes);

      if (this.workspaceViews) this.workspaceViews.fromObj(attributes);
   }

   //// TODO: Refactor isValid() to ignore op and not error if duplicateName is own .id

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.objects((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Object name must be unique ("{0}" already in use)', [this.name])
         );
      }

      // Check the common validations:
      // TODO:
      // if (!inputValidator.validate(values.label)) {
      // 	_logic.buttonSaveEnable();
      // 	return false;
      // }

      return validator;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(data) {
      var validator = this.AB.Validation.validator();
      this.fields().forEach((f) => {
         // check if value was passed, if so validate it
         if (data.hasOwnProperty(f.columnName)) f.isValidData(data, validator);
      });

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @param {obj} values  the initial values for this field.
    *						{ key:'{string}'} is required
    * @return {ABField}
    */
   // fieldNew ( values ) {
   // 	// NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
   // 	return ABFieldManager.newField( values, this );
   // }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   async destroy() {
      /*
        return new Promise((resolve, reject) => {
            // Remove the import object, then its model will not be destroyed
            if (this.isImported) {
                this.application
                    .objectDestroy(this)
                    .catch(reject)
                    .then(() => {
                        resolve();
                    });

                return;
            }

            // OK, some of our Fields have special follow up actions that need to be
            // considered when they no longer exist, so before we simply drop this
            // object/table, drop each of our fields and give them a chance to clean up
            // what needs cleaning up.

            // ==> More work, but safer.
            var fieldDrops = [];
            this.fields().forEach((f) => {
                fieldDrops.push(f.destroy());
            });

            Promise.all(fieldDrops)
                .then(() => {
                    return new Promise((next, err) => {
                        // now drop our table
                        // NOTE: our .migrateXXX() routines expect the object to currently exist
                        // in the DB before we perform the DB operations.  So we need to
                        // .migrateDrop()  before we actually .objectDestroy() this.
                        this.migrateDrop()
                            .then(() => {
                                // finally remove us from the application storage
                                return this.application.objectDestroy(this);
                            })
                            .then(next)
                            .catch(err);
                    });
                })

                // flag .disable to queries who contains this removed object
                .then(() => {
                    return new Promise((next, err) => {
                        this.application
                            .queries(
                                (q) =>
                                    q.objects((o) => o.id == this.id).length > 0
                            )
                            .forEach((q) => {
                                q._objects = q.objects((o) => o.id != this.id);

                                q.disabled = true;
                            });

                        next();
                    });
                })
                .then(resolve)
                .catch(reject);
        });
 */

      var removeFromApplications = () => {
         var allRemoves = [];
         this.AB.applications().forEach((app) => {
            allRemoves.push(app.objectRemove(this));
         });
         return Promise.all(allRemoves);
      };

      var disableRelatedQueries = () => {
         return new Promise((next /*, err */) => {
            this.AB.queries(
               (q) => q.objects((o) => o.id == this.id).length > 0
            ).forEach((q) => {
               // q._objects = q.objects((o) => o.id != this.id);

               q.disabled = true;
            });

            next();
         });
      };

      try {
         // 1) remove us from all Application:
         await removeFromApplications();

         // 2) disable any connected Queries
         await disableRelatedQueries();

         // if an imported Object (FederatedTable, Existing Table, etc...)
         // then skip this step
         if (this.isImported) {
            return Promise.resolve();
         }

         // time to remove my table:
         // NOTE: our .migrateXXX() routines expect the object to currently exist
         // in the DB before we perform the DB operations.  So we need to
         // .migrateDrop()  before we actually .destroy() this.
         await this.migrateDrop();

         // now remove my definition

         // start with my fields:
         var fieldDrops = [];

         // Only ABObjects should attempt any fieldDrops.
         // ABObjectQueries can safely skip this step:
         if (this.type == "object") {
            var allFields = this.fields();
            this._fields = []; // clear our field counter so we don't retrigger
            // this.save() on each field.destroy();

            allFields.forEach((f) => {
               fieldDrops.push(f.destroy());
            });
         }
         await Promise.all(fieldDrops);

         await super.destroy();
         this.emit("destroyed");
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.destroy(): error destroying object.",
         });
      }

      // return Promise.resolve()
      //    .then(() => {
      //       // 1) remove us from all Application:
      //       return removeFromApplications();
      //    })
      //    .then(() => {
      //       // 2) disable any connected Queries
      //       return disableRelatedQueries();
      //    })
      //    .then(() => {
      //       // if an imported Object (FederatedTable, Existing Table, etc...)
      //       // then skip this step
      //       if (this.isImported) {
      //          return Promise.resolve();
      //       }

      //       // time to remove my table:
      //       // NOTE: our .migrateXXX() routines expect the object to currently exist
      //       // in the DB before we perform the DB operations.  So we need to
      //       // .migrateDrop()  before we actually .destroy() this.
      //       return this.migrateDrop();
      //    })
      //    .then(() => {
      //       // now remove my definition

      //       // start with my fields:
      //       var fieldDrops = [];

      //       // Only ABObjects should attempt any fieldDrops.
      //       // ABObjectQueries can safely skip this step:
      //       if (this.type == "object") {
      //          var allFields = this.fields();
      //          this._fields = []; // clear our field counter so we don't retrigger
      //          // this.save() on each field.destroy();

      //          allFields.forEach((f) => {
      //             fieldDrops.push(f.destroy());
      //          });
      //       }

      //       return Promise.all(fieldDrops)
      //          .then(() => {
      //             // now me.
      //             return super.destroy();
      //          })
      //          .then(() => {
      //             this.emit("destroyed");
      //          });
      //    });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      var isAdd = false;

      // if this is our initial save()
      if (!this.id) {
         this.label = this.label || this.name;
         isAdd = true;
      }

      try {
         await super.save();
         if (isAdd) {
            await this.migrateCreate();
         }
         return this;
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.save()",
            obj: this.toObj(),
         });
         throw err;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.objectWorkspaceViews = this.workspaceViews.toObj();

      return result;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network.post(
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   migrateDrop() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network["delete"](
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth /*, oldWidth */) {
      var fieldID = null;
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == columnName) {
            fieldID = this._fields[i].id;
            break;
            // this._fields[i].settings.width = newWidth;
         }
      }

      // Johnny: This is better but still not right.  the ABObject should not be
      // storing sizes for field widths.  That is a function of the UI and which
      // Grid is being displayed.  THAT GRID should be storing a column width
      // locally.
      // TODO: once we have v2 in place.

      var fieldSettings = this.AB.localSettings(fieldID);
      fieldSettings = fieldSettings || {};
      fieldSettings.width = newWidth;

      return this.AB.localSettings(fieldID, fieldSettings);
      // return this.save();
   }

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      summaryColumns = summaryColumns || [];
      countColumns = countColumns || [];

      var headers = [];
      // var columnNameLookup = {};

      // get the header for each of our fields:
      this.fields().forEach((f) => {
         var header = f.columnHeader({
            isObjectWorkspace: isObjectWorkspace,
            editable: isEditable,
         });

         if (isEditable) {
            header.validationRules = f.settings.validationRules;
         }

         header.alias = f.alias || undefined; // query type
         header.fieldID = f.id;
         // header.fieldURL = f.urlPointer();

         // if the field specifies a width
         if (f.settings.width != 0) {
            header.width = f.settings.width;
         }

         // if the User has already updated a local width for this
         var fieldSettings = this.AB.localSettings(f.id);
         if (fieldSettings && fieldSettings.width) {
            if (!header.width || fieldSettings.width > header.width) {
               // set column width to the customized width
               header.width = fieldSettings.width;
            }
         }

         if (!header.width) {
            // set column width to adjust:true by default;
            header.adjust = true;
         }

         // add the summary footer
         if (summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula") {
               header.footer = { content: "totalColumn", field: f };
            } else {
               header.footer = { content: "summColumn" };
            }
         }
         // add the count footer
         else if (countColumns.indexOf(f.id) > -1)
            header.footer = { content: "countColumn" };

         headers.push(header);
         // columnNameLookup[header.id] = f.columnName; // name => id
      });

      // update our headers with any settings applied in the Object Workspace
      /*
      // In v2: this is handled by the ABDesigner
      //
      if (isObjectWorkspace) {
         let hiddenFieldList = [];

         if (hiddenFieldNames && hiddenFieldNames.length > 0)
            hiddenFieldList = hiddenFieldNames;
         // else if (this.workspaceHiddenFields)
         //    hiddenFieldList = this.workspaceHiddenFields;

         if (hiddenFieldList.length > 0) {
            hiddenFieldList.forEach((hfID) => {
               headers.forEach((h) => {
                  if (columnNameLookup[h.id] == hfID) {
                     h.hidden = true;
                  }
               });
            });
         }
      }
      */

      return headers;
   }

   // after a component has rendered, tell each of our fields to perform
   // any custom display operations
   // @param {Webix.DataStore} data a webix datastore of all the rows effected
   //        by the render.
   customDisplays(data, App, DataTable, rowIds, isEditable) {
      if (!data || !data.getFirstId) return;

      // var fields = this.fields(f => this.workspaceHiddenFields.indexOf(f.columnName) < 0);
      let fields = [];
      DataTable.eachColumn((columnName) => {
         let field = this.fields((f) => f.columnName == columnName)[0];
         if (field) fields.push(field);
      });

      if (rowIds != null) {
         rowIds.forEach((id) => {
            let row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  let node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
         });
      } else {
         let id = data.getFirstId();
         while (id) {
            var row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  var node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
            id = data.getNextId(id);
         }
      }
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = `{${defaultField.id}}`;
         else
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`; // show id of row
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   currentView() {
      return this.workspaceViews.getCurrentView();
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = [].concat(this._warnings);
      this.fields().forEach((f) => {
         allWarnings = allWarnings.concat(f.warnings());
      });

      if (this.fields().length == 0) {
         allWarnings.push({ message: "I got no fields.", data: {} });
      }

      this.indexes().forEach((i) => {
         allWarnings = allWarnings.concat(i.warnings());
      });

      return allWarnings;
   }

   // warningsEval() {
   //    // our .fromValues() has already registered any missing fields.
   //    // those should get reported from warnings()
   // }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
};


/***/ }),

/***/ 54509:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ABObjectExternal.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObject = __webpack_require__(/*! ./ABObject */ 67826);

/**
 * ABObjectExternal
 * These are ABObjects that ... (might need to be refactored out?)
 * NOTE: on the web client, these should function just like ABObjects
 */
module.exports = class ABObjectExternal extends ABObject {};


/***/ }),

/***/ 41557:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ABObjectImport.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObject = __webpack_require__(/*! ./ABObject */ 67826);

/**
 * ABObjectImport
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
module.exports = class ABObjectImport extends ABObject {};


/***/ }),

/***/ 88447:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABObjectQuery.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//

const ABObjectQueryCore = __webpack_require__(/*! ../core/ABObjectQueryCore */ 40777);

var ABFactory = null;
if (typeof io != "undefined") {
   io.socket.on("ab.query.update", function (msg) {
      if (ABFactory) {
         ABFactory.emit("ab.query.update", {
            queryId: msg.queryId,
            data: msg.data,
         });
      } else {
         console.error(
            "ABObjectQuery:: received io.socket msg before ABFactory is defined"
         );
         console.error("TODO: move this to ABFactory!");
      }
   });
} else {
   console.error("TODO: install socket.io client for sails updates.");
}

// io.socket.on("ab.query.delete", function (msg) {
// });

module.exports = class ABObjectQuery extends ABObjectQueryCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      if (!ABFactory) {
         ABFactory = AB;
      }
      // listen
      this.AB.on("ab.query.update", (data) => {
         if (this.id == data.queryId) this.fromValues(data.data);
      });

      // .fromValues() should already have been called in super()
      // so now add in our conditionScan()
      // NOTE: this can be folded into the Core once filterComplex
      // is fully implemented and not on Platform only.

      // now scan our conditions to make sure they are
      // 1) reference fields that exist in our Query
      // 2) completely filled out conditions.
      this.conditionScan(this.where);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObjectQuery
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   // destroy() {
   //    return super.destroy().then(() => {
   //       console.error("Move .queryRemove() to Appbuilder Designer.");
   //       // return this.AB.queryRemove(this);
   //    });
   // }

   /**
    * @method save()
    *
    * persist this instance of ABObjectQuery with it's parent ABApplication
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   // async save() {
   //    try {
   //       await super.save();
   //       return this;
   //    } catch (err) {
   //       this.AB.notify.developer(err, {
   //          context: "ABObjectQuery.save()",
   //          query: this.toObj(),
   //       });
   //       throw err;
   //    }
   // }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    *             { }
    * @param {bool} shouldAliasColumn
    *        should we add the object alias to the columnNames?
    *        this is primarily used on the web client
    */
   importFields(fieldSettings) {
      super.importFields(fieldSettings);

      this._fields.forEach((fieldEntry) => {
         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         fieldEntry.field.columnName = `${fieldEntry.alias}.${fieldEntry.field.columnName}`;
      });
   }

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth, oldWidth) {
      let field = this.fields((f) => f.columnName == columnName)[0];
      if (field) {
         field.settings.width = newWidth;

         return this.save();
      } else {
         return Promise.resolve();
      }
   }

   ///
   /// Working with Client Components:
   ///

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      var headers = super.columnHeaders(
         isObjectWorkspace,
         isEditable,
         summaryColumns,
         countColumns,
         hiddenFieldNames
      );

      headers.forEach((h) => {
         // pull object by alias
         let object = this.objectByAlias(h.alias);
         if (!object) return;

         let field = object.fieldByID(h.fieldID);
         if (!field) return;

         // NOTE: query v1
         let alias = "";
         if (Array.isArray(this.joins())) {
            alias = field.object.name;
         } else {
            alias = h.alias;
         }

         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         h.id = `${alias}.${field.columnName}`;

         // label
         if (this.settings && this.settings.hidePrefix) {
            h.header = `${field.label || ""}`;
         } else {
            h.header = `${field.object.label || ""}.${field.label || ""}`;
         }

         // icon
         if (field.settings && field.settings.showIcon) {
            h.header = `<span class="webix_icon fa fa-${field.fieldIcon()}"></span>${
               h.header
            }`;
         }

         // If this query supports grouping, then add folder icon to display in grid
         if (this.isGroup) {
            let originTemplate = h.template;

            h.template = (item, common) => {
               if (item[h.id])
                  return (
                     common.icon(item, common) +
                     (originTemplate
                        ? originTemplate(item, common, item[h.id])
                        : item[h.id])
                  );
               else return "";
            };
         }

         h.adjust = true;
         h.minWidth = 220;
      });

      return headers;
   }

   /**
    * @method conditionScan()
    * Scan the provided condition object and determine if there are any
    * configuration issues.
    * @param {obj} rule
    *        the QueryBuilder rule that we are scanning.
    * @param {array} listWarnings
    *        An array of warnings that we should add our notices to.
    */
   conditionScan(rule) {
      if (!rule) {
         return;
      }

      if (rule.glue) {
         (rule.rules || []).forEach((r) => {
            this.conditionScan(r);
         });
         return;
      }

      // 1) we need to have any key as one of our fields.
      let field = this.fieldByID(rule.key);
      if (!field && rule.key != "this_object") {
         this.emit(
            "warning",
            "condition does not reference one of our fields",
            {
               rule,
            }
         );
      }

      // 2) completely filled out conditions.
      if (!this._conditionCheck) {
         this._conditionCheck = this.AB.filterComplexNew(
            `${this.id}_conditionCheck`
         );
         // {FilterComplex} ._conditionCheck
         // has our .isConditionComplete() method.
      }
      if (!this._conditionCheck.isConditionComplete(rule)) {
         this.emit("warning", "incomplete condition definition", {
            rule,
         });
      }
   }

   /**
    * @method warningsAll()
    * Compile any warnings from this Query, or any of it's fields.
    * @return {array}
    *         An array of warning objects.
    *         .message {string} message to display
    *         .data {obj} associated debug info for this warning.
    */
   // warningsAll() {
   //    // report both OUR warnings, and any warnings from any of our fields
   //    // NOTE: this will get
   //    var allWarnings = super.warningsAll();

   //    return allWarnings;
   // }
};


/***/ }),

/***/ 68836:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABProcess.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessCore = __webpack_require__(/*! ../core/ABProcessCore */ 99183);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcess extends ABProcessCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      this.AB.on("ab.abprocess.update", (data) => {
         if (this.id == data.objectId) this.fromValues(data.data);
      });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // remove all my Elements
      var allElements = this.elements();
      var allDestroy = [];
      allElements.forEach((e) => {
         allDestroy.push(e.destroy());
      });

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  // allow normal processing to contine now:
                  resolve();
               })
               .then(() => {
                  // in the background
                  // remove this reference from ALL Applications that link
                  // to me:
                  console.error(
                     "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
                  );
                  var appsWithProcess = this.AB.applications().find((a) => {
                     return a.hasProcess(this);
                  });
                  if (appsWithProcess.length > 0) {
                     appsWithProcess.forEach((a) => {
                        a.processRemove(this);
                     });
                  }
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // if this is an update:
      // if (this.id) {
      // 	return ABDefinition.update(this.id, this.toDefinition());
      // } else {

      // 	return ABDefinition.create(this.toDefinition());
      // }

      // make sure all our tasks have save()ed.
      var allSaves = [];
      var allTasks = this.elements();
      allTasks.forEach((t) => {
         allSaves.push(t.save());
      });
      return Promise.all(allSaves).then(() => {
         // now we can save our Process definition
         return this.toDefinition()
            .save()
            .then((data) => {
               // if I didn't have an .id then this was a create()
               // and I need to update my data with the generated .id

               if (!this.id) {
                  this.id = data.id;
               }

               // Also, our embedded elements now all have .ids
               // where they might not have before.  So now
               // rebuild our this._elements hash with all id
               var _new = {};
               Object.keys(this._elements).forEach((k) => {
                  _new[this._elements[k].id] = this._elements[k];
               });
               this._elements = _new;
            });
      });
   }

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.processes((o) => {
            return o.name.toLowerCase() == this.name.toLowerCase();
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L(`Process name must be unique ("{0}" already in use)`, [this.name])
         );
      }

      return validator;
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcess[OBJ]}
    */
   elementNewForModelDefinition(element) {
      var task = this.AB.processElementNewForModelDefinition(element, this);
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }
};


/***/ }),

/***/ 44312:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABViewManager.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewManagerCore = __webpack_require__(/*! ../core/ABViewManagerCore */ 15753);

module.exports = class ABViewManager extends ABViewManagerCore {};


/***/ }),

/***/ 26580:
/*!********************************************!*\
  !*** ./AppBuilder/platform/CSVImporter.js ***!
  \********************************************/
/***/ ((module) => {

var L = null;
// multilingual Label fn()

module.exports = class CSVImporter {
   constructor(Label) {
      // {ABMultilingual.label()} function.
      //
      if (!L) {
         L = Label;

         // if this was a v1: App param:
         if (Label.Label) {
            L = Label.Label;
         }
      }
   }

   /**
    * @method getSeparateItems()
    * Return the options of how the CSV values are separated.
    * @return {array}  [ {id, value} ... ]
    */
   getSeparateItems() {
      return [
         { id: ",", value: L("Comma (,)") },
         { id: "\t", value: L("Tab (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)") },
         { id: ";", value: L("Semicolon (;)") },
         { id: "s", value: L("Space ( )") },
      ];
   }

   /**
    * @method validateFile
    * Validate file extension
    * @param {*} fileInfo
    *        https://docs.webix.com/api__ui.uploader_onbeforefileadd_event.html
    * @return {boolean}
    */
   validateFile(fileInfo) {
      if (!fileInfo || !fileInfo.file || !fileInfo.file.type) return false;

      // validate file type
      let extensionType = fileInfo.file.type.toLowerCase();
      if (
         extensionType == "text/csv" ||
         extensionType == "application/vnd.ms-excel"
      ) {
         return true;
      } else {
         return false;
      }
   }

   /**
    * @method getDataRows
    * Pull data rows from the CSV file
    *
    * @param {Object} fileInfo - https://docs.webix.com/api__ui.uploader_onbeforefileadd_event.html
    * @param {string} separatedBy
    *
    * @return {Promise} -[
    * 						["Value 1.1", "Value 1.2", "Value 1.3"],
    * 						["Value 2.1", "Value 2.2", "Value 2.3"],
    * 					]
    */
   getDataRows(fileInfo, separatedBy) {
      if (!this.validateFile(fileInfo)) return Promise.reject();

      return new Promise((resolve, reject) => {
         // read CSV file
         let reader = new window.FileReader();
         reader.onload = (e) => {
            let result = [];

            // split lines
            let dataRows = reader.result
               .split(/\r\n|\n|\r/) // CRLF = \r\n; LF = \n; CR = \r;
               .filter((row) => row && row.length > 0);

            // split columns
            (dataRows || []).forEach((row) => {
               let dataCols = [];
               if (separatedBy == ",") {
                  // NOTE: if the file contains ,, .match() can not reconize this empty string
                  row = row.replace(/,,/g, ", ,");

                  // https://stackoverflow.com/questions/11456850/split-a-string-by-commas-but-ignore-commas-within-double-quotes-using-javascript#answer-11457952
                  dataCols = row.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);
               } else {
                  dataCols = row.split(separatedBy);
               }

               result.push(dataCols.map((dCol) => this.reformat(dCol)));
            });

            resolve(result);
         };
         reader.readAsText(fileInfo.file);
      });
   }

   /**
    * @method getGuessDataType
    * return our best guess of what type of data for the requested column.
    * @param {array} dataRows
    *        The data we are evaluating:
    *        [
    *           ["Value 1.1", "Value 1.2", "Value 1.3"],
    *           ["Value 2.1", "Value 2.2", "Value 2.3"],
    * 		 ]
    * @param colIndex {Number}
    * @return {string}
    */
   getGuessDataType(dataRows, colIndex) {
      var data,
         // {various} the data pulled from the requested row/column
         repeatNum = 10;
      // {integer} how many rows do we want to scan trying to find a value

      // Loop to find a value
      for (var i = 1; i <= repeatNum; i++) {
         var line = dataRows[i];
         if (!line) break;

         data = line[colIndex];

         if (data != null && data.length > 0) break;
      }

      if (data == null || data == "") {
         return "string";
      } else if (
         data == 0 ||
         data == 1 ||
         data == true ||
         data == false ||
         data == "checked" ||
         data == "unchecked"
      ) {
         return "boolean";
      } else if (!isNaN(data)) {
         return "number";
      } else if (Date.parse(data)) {
         return "date";
      } else {
         // determine which type of string this might be:
         if (data.length > 100) return "LongText";
         else return "string";
      }
   }

   /**
    * @method reformat
    * @param {string} str
    */
   reformat(str) {
      if (!str) return "";

      return str.trim().replace(/"/g, "").replace(/'/g, "");
   }
};


/***/ }),

/***/ 21021:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/FilterComplex.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const FilterComplexCore = __webpack_require__(/*! ../core/FilterComplexCore */ 50353);

let L = (...params) => AB.Multilingual.label(...params);

/**
 * @function _toInternal()
 * translate our external QB conditions into our internal format that
 * makes the cond.rule unique by adding the field.id to the rule.
 * @param {obj} cond - {
 *                         rules: [
 *                            {
 *                               alias: string || undefined,
 *                               key: uuid,
 *                               rule: string,
 *                               value: object,
 *                            }
 *                         ]
 *                      }
 *        the QB condition format we use exernally in our AB system.
 */
function _toInternal(cond, fields = []) {
   if (!cond) return;
   if (cond.key) {
      // Convert to format
      // {
      //    glue: "and",
      //    rules: [
      //       {
      //          field: "test_col",
      //          condition: { type: "greater", filter: 100 },
      //       },
      //    ],
      // }
      const field = fields.filter(
         (f) => f.id == cond.key || f.columnName == cond.key
      )[0];
      cond.field = field?.columnName ?? field?.id;

      cond.condition = {
         type: cond.rule,
         filter: cond.value,
      };

      if (Array.isArray(cond.value)) cond.includes = cond.value;
      else cond.includes = (cond.value ?? "").split(",");

      if (field?.key == "date" || field?.key == "datetime") {
         cond.condition.filter = cond.condition.filter
            ? AB.toDate(cond.condition.filter)
            : null;

         cond.includes = cond.includes.map((v) => AB.toDate(v));
      }

      delete cond.key;
      delete cond.rule;
      delete cond.value;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toInternal(r, fields);
      });
   }
}

/**
 * @function _toExternal()
 * translate our internal QB conditions into our external format that
 * where the cond.rule no longer has the field.id.
 * @param {obj} cond - {
 *                         glue: "and",
 *                         rules: [
 *                            {
 *                               field: "test_col",
 *                               condition: { type: "greater", filter: 100 },
 *                            },
 *                         ],
 *                      }
 *        the QB condition format we use internally
 */
function _toExternal(cond, fields = []) {
   if (!cond) return;
   if (cond.field) {
      let field = fields.filter((f) => f.columnName == cond.field)[0];
      // cond.alias = alias || undefined;
      cond.key = field?.id ?? cond.field;
      cond.condition = cond.condition ?? {};
      cond.rule = cond.condition.type;

      // Convert multi-values to a string
      let values = cond.includes ?? [];
      if (cond.condition.filter && values.indexOf(cond.condition.filter) < 0)
         values.push(cond.condition.filter);

      cond.value = values
         .map((v) => {
            // Convert date format
            if (field && (field.key == "date" || field.key == "datetime")) {
               return field.exportValue(v);
            } else if (v instanceof Date) {
               return v.toISOString();
            } else {
               return v;
            }
         })
         .join(",");

      delete cond.field;
      delete cond.type;
      delete cond.includes;
      delete cond.condition;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toExternal(r, fields);
      });
   }
}

module.exports = class FilterComplex extends FilterComplexCore {
   constructor(idBase, AB, options = {}) {
      idBase = idBase ?? "ab_filterComplex";

      super(idBase, AB);

      this._options = options ?? {};

      this._initComplete = false;
      // {bool}
      // trying to prevent multiple .init() from being called due to
      // various ways of initializing the component.

      this.observing = false;
      // {bool}
      // try to prevent multiple observers generating >1 "changed"
      // event.

      let labels = (this.labels = {
         common: (AB._App ?? {}).labels,
         component: {
            and: L("And"),
            or: L("Or"),

            thisObject: L("This Object"),
            inQuery: L("In Query"),
            notInQuery: L("Not In Query"),
            inQueryField: L("By Query Field"),
            notInQueryField: L("Not By Query Field"),

            inQueryFieldQueryPlaceholder: L("Choose a Query"),
            inQueryFieldFieldPlaceholder: L("Choose a Field"),

            sameAsUser: L("Same As User"),
            notSameAsUser: L("Not Same As User"),

            sameAsField: L("Same As Field"),
            notSameAsField: L("Not Field"),

            inDataCollection: L("In Data Collection"),
            notInDataCollection: L("Not In Data Collection"),

            containsCondition: L("contains"),
            notContainsCondition: L("doesn't contain"),
            isCondition: L("is"),
            isNotCondition: L("is not"),
            isEmpty: L("is empty"),
            isNotEmpty: L("is not empty"),

            beforeCondition: L("is before"),
            afterCondition: L("is after"),
            onOrBeforeCondition: L("is on or before"),
            onOrAfterCondition: L("is on or after"),
            beforeCurrentCondition: L("is before current date"),
            afterCurrentCondition: L("is after current date"),
            onOrBeforeCurrentCondition: L("is on or before current date"),
            onOrAfterCurrentCondition: L("is on or after current date"),
            onLastDaysCondition: L("last ... days"),
            onNextDaysCondition: L("next ... days"),

            equalCondition: L(":"),
            notEqualCondition: L("≠"),
            lessThanCondition: L("<"),
            moreThanCondition: L(">"),
            lessThanOrEqualCondition: L("≤"),
            moreThanOrEqualCondition: L("≥"),

            equalListCondition: L("equals"),
            notEqualListCondition: L("does not equal"),

            checkedCondition: L("is checked"),
            notCheckedCondition: L("is not checked"),

            isCurrentUserCondition: L("is current user"),
            isNotCurrentUserCondition: L("is not current user"),
            containsCurrentUserCondition: L("contains current user"),
            notContainsCurrentUserCondition: L("does not contain current user"),

            ContextDefaultOption: L("choose option"),
            EqualsProcessValue: L("equals process value"),
            NotEqualsProcessValueCondition: L("not equals process value"),
            InProcessValueCondition: L("in process value"),
            notInProcessValueCondition: L("not in process value"),
         },
      });

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         popup: this.unique(`${idBase}_popup`),
         querybuilder: this.unique(`${idBase}_querybuilder`),
         save: this.unique(`${idBase}_save`),
      });

      // Set current username
      this.Account.username = this.AB.Account.username();

      this._recordRuleFieldOptions = [];

      // webix UI definition:
      this.ui = {
         rows: [
            {
               view: "layout",
               type: "clean",
               borderless: true,
               rows: [
                  {
                     id: ids.querybuilder,
                     view: "query",
                     data: () => [],
                     // data: async (field) => await this.pullOptions(field),
                     fields: [],
                  },
               ],
            },
            {
               id: ids.save,
               view: "button",
               css: "webix_primary",
               value: L("Save"),
               hidden: this._options.isSaveHidden ?? false,
               click: () => {
                  if (this.myPopup) this.myPopup.hide();
                  this.emit("save", this.getValue());
               },
            },
         ],
      };
   }

   // setting up UI
   init(options) {
      if (this._initComplete) return;

      super.init(options);

      this._isRecordRule = options?.isRecordRule ?? false;
      this._recordRuleFieldOptions = options?.fieldOptions ?? [];

      const el = $$(this.ids.querybuilder);
      if (el) {
         if (!this.observing) {
            this.__blockOnChange = true;
            el.getState().$observe("value", (v) => {
               if (this.__blockOnChange) return false;

               this.emit("changed", this.getValue());
            });
            this.__blockOnChange = false;

            // HACK!! The process of setting the $observe() is actually
            // calling the cb() when set.  This is clearing our .condition
            // if we call init() after we have setValues(). which can happen
            // when using the popUp() method.
            let _cond = this.condition;
            this.condition = _cond;
            this.observing = true;
         }
         this._initComplete = true;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      let helper = () => true;

      let $query = $$(this.ids.querybuilder);
      if ($query) {
         helper = $query.getFilterFunction();
         return helper(rowData);
      } else {
         return super.isValid(rowData);
      }
   }

   /**
    * @method isConditionComplete()
    * Check a given condition entry and indicate if it is fully
    * filled out.
    * @param {obj} cond
    *        The Condition object we are checking.  If a Macro
    *        condition if provided: { glue:"and", rules:[] } then
    *        this method will return True/False if All rules are
    *        complete.
    *        If an individual rule is provided, then it evaluates
    *        the completness of that rule. { key, rule, value }
    * @return {bool}
    */
   isConditionComplete(cond) {
      if (!cond) return false;

      let isComplete = true;
      // start optimistically.

      if (cond.glue) {
         (cond.rules ?? []).forEach((r) => {
            isComplete = isComplete && this.isConditionComplete(r);
         });
      } else {
         // every condition needs a .key & .rule
         if (!cond.key || cond.key == "") {
            isComplete = false;
         }

         if (!cond.rule || cond.rule == "") {
            isComplete = false;
         }

         if (isComplete) {
            switch (cond.rule) {
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
               case "same_as_user":
               case "not_same_as_user":
               case "less_current":
               case "greater_current":
               case "less_or_equal_current":
               case "greater_or_equal_current":
               case "is_empty":
               case "is_not_empty":
                  // There are only a few rules that don't need a
                  // value
                  break;

               default:
                  // The rest do need a .value
                  if (!cond.value || cond.value == "") {
                     isComplete = false;
                  }
                  break;
            }
         }
      }

      return isComplete;
   }

   setValue(settings) {
      super.setValue(settings);
      this.condition = settings;

      const el = $$(this.ids.querybuilder);
      if (el) {
         if (!settings) {
            // Clear settings value of webix.query
            el.define("value", {
               glue: "and",
               rules: [],
            });
            return;
         }

         let qbSettings = this.AB.cloneDeep(settings);

         // Settings should match a condition built upon our QB format:
         // {
         //    glue:"and",
         //    rules:[
         //       {
         //          key:"uuid",
         //          rule:"",
         //          value:""
         //       }
         //    ]
         // }
         // externally our key should be the field.id and the rules should be
         // the "contains", "not_contains", "equal" ... keywords.
         // However, internally, we convert these rules into .ids that are
         // unique for each field (see uiInit()).  So when we bring in settings
         // we need to translate them into our internal format:

         _toInternal(qbSettings, this._Fields);

         this.__blockOnChange = true;
         el.define("value", qbSettings);
         this.__blockOnChange = false;
      }
   }

   getValue() {
      if ($$(this.ids.querybuilder)) {
         let settings = this.AB.cloneDeep(
            $$(this.ids.querybuilder).getState().value ?? {}
         );

         // what we pull out of the QB will have .rules in our internal format:
         // {field.id}_{rule}  (see uiInit() )
         // But we need to store them in our generic QB format for use outside
         // our FilterComplex widget.
         _toExternal(settings, this._Fields);
         this.condition = settings;
      }

      return super.getValue();
   }

   fieldsLoad(fields = [], object = null) {
      super.fieldsLoad(fields, object);
      this.uiInit();
   }

   toShortHand() {
      return "Add Filters";
   }

   uiInit() {
      this.uiQueryCustomValue();

      let el = $$(this.ids.querybuilder);
      if (el) {
         // Clear fields
         while (el.config.fields.length > 0) {
            el.config.fields.pop();
         }
         // Set fields
         (this.fieldsToQB() ?? []).forEach((f) => {
            el.config.fields.push(f);
         });
      }
   }

   // HACK: have to overwrite Webix Query's function to support our custom input requirement.
   // HooWoo
   uiQueryCustomValue() {
      const $el = $$(this.ids.querybuilder);
      if (!$el) return;

      // window.query.views.filter.prototype.CreateFilter = (
      $el.$app.require("jet-views", "filter").prototype.CreateFilter = (
         field,
         type,
         format,
         conditions,
         place
      ) => {
         let inputs = this.uiValue(field);

         let ui = {
            id: place.config.id,
            view: "filter",
            localId: "filter",
            conditions: conditions,
            field: field,
            mode: type,
            template: function (o) {
               let str = o[field];
               let parser =
                  format ?? (type == "date" ? webix.i18n.dateFormatStr : null);
               if (parser) str = parser(str);
               return str;
            },
            inputs: inputs,
            margin: 6,
         };

         let filter = webix.ui(ui, place);

         // let data = [];
         // const $query = $$(this.ids.querybuilder);
         // if ($query) {
         //    data = $query.app.getService("backend").data(field);
         // }
         // filter.parse(data);

         return filter;
      };
   }

   uiValue(fieldColumnName) {
      let result;

      // Special case: this_object
      if (fieldColumnName == "this_object") {
         return []
            .concat(this.uiQueryValue("this_object"))
            .concat(this.uiDataCollectionValue("this_object"))
            .concat(this.uiCustomValue("this_object"))
            .concat(this.uiContextValue("this_object", "uuid"));
      }

      let field = (this._Fields ?? []).filter(
         (f) => f.columnName == fieldColumnName
      )[0];

      switch (field?.key) {
         case "boolean":
            result = this.uiBooleanValue(field);
            break;
         case "connectObject":
            result = []
               .concat(this.uiQueryValue(field))
               .concat(this.uiUserValue(field))
               .concat(this.uiDataCollectionValue(field))
               .concat(this.uiContextValue(field))
               .concat(this.uiNoneValue());
            break;
         case "date":
         case "datetime":
            result = ["datepicker", "daterangepicker"];
            break;
         case "list":
            result = this.uiListValue(field);
            break;
         case "user":
            result = []
               .concat(this.uiNoneValue())
               .concat(this.uiUserValue(field));
            break;
         // case "number":
         //    result = ["text"];
         //    break;
         case "string":
         case "LongText":
         case "email":
            result = this.uiNoneValue();
            break;
      }

      // Add filter options to Custom index
      const LinkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      if (
         field?.settings?.isCustomFK &&
         // 1:M
         (LinkType == "one:many" ||
            // 1:1 isSource = true
            (LinkType == "one:one" && field?.settings?.isSource))
      ) {
         result = (result ?? []).concat(this.uiTextValue(field));
      } else if (field?.key != "connectObject") {
         result = (result ?? [])
            .concat(this.uiTextValue(field))
            .concat(this.uiQueryFieldValue(field))
            .concat(this.uiContextValue(field));
      }
      // Special case: from Process builder
      // .processFieldsLoad()
      else if (fieldColumnName.indexOf("uuid") > -1) {
         result = this.uiContextValue(null, fieldColumnName);
      }

      if (this._isRecordRule) {
         result = (result ?? []).concat(this.uiRecordRuleValue(field));
      }

      result = (result ?? []).concat(this.uiCustomValue(field));

      return result;
   }

   uiNoneValue() {
      return [
         {
            batch: "none",
            borderless: true,
            view: "template",
            template: "",
         },
      ];
   }

   uiBooleanValue(field) {
      return [
         {
            batch: "boolean",
            view: "checkbox",
         },
      ];
   }

   uiTextValue(field) {
      return [
         {
            batch: "text",
            view: "text",
            on: {
               onAfterRender: function () {
                  // HACK: focus on webix.text and webix.textarea
                  // Why!! If the parent layout has zIndex lower than 101,
                  // then is not able to focus to webix.text and webix.textarea
                  let $layout =
                     this.queryView(function (a) {
                        return !a.getParentView();
                     }, "parent") ?? this;
                  $layout.$view.style.zIndex = 202;
               },
            },
         },
      ];
   }

   uiQueryValue(field) {
      let options = [];

      let isQueryField =
         this._QueryFields?.filter((f) => f.id == field.id).length > 0;

      // populate the list of Queries for this_object:
      if (field == "this_object" && this._Object) {
         options = this.queries((q) => q.canFilterObject(this._Object));
      }
      // populate the list of Queries for a query field
      else if (isQueryField) {
         options = this.queries(
            (q) =>
               (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
               q.canFilterObject(field.datasourceLink)
         );
      }

      options?.forEach((q) => {
         options.push({
            id: q.id,
            value: q.label,
         });
      });

      return [
         {
            batch: "query",
            view: "combo",
            options: options ?? [],
         },
      ];
   }

   uiListValue(field) {
      return [
         {
            batch: "list",
            view: "combo",
            options: field?.settings?.options?.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            }),
         },
      ];
   }

   uiUserValue(field) {
      return [
         {
            batch: "user",
            view: "combo",
            options: this.AB.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            }),
         },
      ];
   }

   uiDataCollectionValue(field) {
      let linkObjectId;
      if (field == "this_object" && this._Object) {
         linkObjectId = this._Object.id;
      } else {
         linkObjectId = field?.settings?.linkObject;
      }

      return [
         {
            batch: "datacollection",
            view: "combo",
            options: linkObjectId
               ? this.AB.datacollections(
                    (dc) => dc?.datasource?.id == linkObjectId
                 ).map((dc) => {
                    return {
                       id: dc.id,
                       value: dc.label,
                    };
                 })
               : [],
         },
      ];
   }

   uiQueryFieldValue(field) {
      return [
         {
            batch: "queryField",
            view: "combo",
            placeholder: this.labels.component.inQueryFieldQueryPlaceholder,
            options: this.queries(
               (q) => this._Object == null || q.id != this._Object.id
            ).map((q) => {
               return {
                  id: q.id,
                  value: q.label,
               };
            }),
         },
      ];
   }

   uiRecordRuleValue(field) {
      return [
         {
            batch: "recordRule",
            view: "select",
            options: this._recordRuleFieldOptions ?? [],
         },
      ];
   }

   uiContextValue(field, processFieldKey = null) {
      let processField = (this._ProcessFields ?? []).filter((pField) => {
         if (!pField) return false;

         if (pField.field) {
            return pField.field.id == field.id;
         } else if (pField.key) {
            // uuid
            let processFieldId = pField.key.split(".").pop();
            return (
               processFieldId == field.id ||
               processFieldId == field.key ||
               processFieldId == processFieldKey ||
               pField.key == processFieldKey
            );
         }
      })[0];

      if (!processField) return [];

      return [
         {
            batch: "context",
            view: "select",
            options: [
               {
                  id: "empty",
                  value: this.labels.component.ContextDefaultOption,
               },
               {
                  id: processField.key,
                  value: L("context({0})", [processField.label]),
               },
            ],
         },
      ];
   }

   uiCustomValue(field) {
      if (!field) return [];

      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id ?? field] ?? {};
      return options.values ?? [];
   }

   popUp(...options) {
      if (!this.myPopup) {
         let ui = {
            id: this.ids.popup,
            view: "popup",
            height: 400,
            width: 800,
            body: this.ui,
         };

         this.myPopup = webix.ui(ui);
         this.init();
      }

      if (this._Fields) {
         this.fieldsLoad(this._Fields, this._Object);
      }

      // NOTE: do this, before the .setValue() operation, as we need to have
      // our fields and filters defined BEFORE a setValue() is performed.
      // this.uiInit();

      if (this.condition) {
         this.setValue(this.condition);
      }

      this.myPopup.show(...options);
   }

   /**
    * @method addCustomOption
    *
    * @param {string|uuid} fieldId
    * @param {Object} options - {
    *                               conditions: [],
    *                               values: []
    *                           }
    */
   addCustomOption(fieldId, options = {}) {
      this._customOptions = this._customOptions ?? {};
      this._customOptions[fieldId] = options;
   }
};


/***/ }),

/***/ 41688:
/*!******************************************!*\
  !*** ./AppBuilder/platform/RowFilter.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RowFilterCore = __webpack_require__(/*! ../core/RowFilterCore */ 61584);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class RowFilter extends RowFilterCore {
   constructor(App, idBase, AB) {
      super(App, idBase, AB);

      console.error("TODO: Switch RowFilter => FilterComplex");

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         component: this.unique(`${idBase}_rowFilter`),
         filterForm: this.unique(`${idBase}_rowFilter_form`),
         addNewFilter: this.unique(`${idBase}_rowFilter_addNewFilter`),

         glue: this.unique(`${idBase}_rowFilter_glue`),
         field: this.unique(`${idBase}_rowFilter_field`),
         rule: this.unique(`${idBase}_rowFilter_rule`),
         inputValue: this.unique(`${idBase}_rowFilter_inputValue`),

         queryCombo: this.unique(`${idBase}_rowFilter_queryCombo`),
         queryFieldCombo: this.unique(`${idBase}_rowFilter_queryFieldCombo`),
         queryFieldComboQuery: this.unique(
            `${idBase}_rowFilter_queryFieldComboQuery`
         ),
         queryFieldComboField: this.unique(
            `${idBase}_rowFilter_queryFieldComboField`
         ),
         fieldMatch: this.unique(`${idBase}_rowFilter_fieldMatchCombo`),

         dataCollection: this.unique(`${idBase}_rowFilter_dataCollection`),

         listOptions: this.unique(`${idBase}_rowFilter_listOptions`),

         datePicker: this.unique(`${idBase}_rowFilter_datePicker`),
      });

      // Set current username
      // this.Account.username = this.AB.Account.username();

      var batchName; // we need to revert to this default when switching away from a in/by query field

      // Default options list to push to all fields
      this.queryFieldOptions = [
         {
            value: L("By Query Field"),
            id: "in_query_field",
         },
         {
            value: L("Not In Query"),
            id: "not_in_query_field",
         },
      ];

      this.recordRuleOptions = [];
      this.recordRuleFieldOptions = [];

      let _logic = this._logic || {};

      /**
       * @method getFieldList
       * return field list to render options
       */
      _logic.getFieldList = () => {
         return (this._Fields || []).map((f) => {
            let label = f.label;

            // include object's name to options
            if (this._settings.showObjectName && f.object) {
               label = f.object.label + "." + f.label;
            }

            return {
               id: f.id,
               value: label,
               alias: f.alias || undefined, // ABObjectQuery
            };
         });
      };

      _logic.getFilterUI = () => {
         let instance = this;
         let config_settings = this.config_settings || {};

         return {
            id: "f" + webix.uid(),
            isolate: true,
            cols: [
               {
                  // Add / Or
                  view: "combo",
                  id: ids.glue,
                  width: 80,
                  value: config_settings.glue || "and",
                  options: [
                     {
                        value: L("And"),
                        id: "and",
                     },
                     {
                        value: L("Or"),
                        id: "or",
                     },
                  ],
                  on: {
                     onChange: function (newVal, oldVal) {
                        _logic.selectCombineCondition(newVal);
                     },
                  },
               },
               {
                  // Field list
                  view: "combo",
                  id: ids.field,
                  suggest: {
                     on: {
                        onBeforeShow: function () {
                           this.define("width", 400);
                           this.resize();
                        },
                     },
                     data: _logic.getFieldList(),
                  },
                  on: {
                     onChange: function (columnId) {
                        var $viewCond = this.getParentView();
                        _logic.selectField(columnId, $viewCond);
                     },
                  },
               },
               // Comparer
               {
                  id: ids.rule,
                  width: 220,
                  cells: [
                     {},
                     // Query
                     {
                        batch: "query",
                        view: "combo",
                        value: "in_query",
                        options: [
                           {
                              value: L("In Query"),
                              id: "in_query",
                           },
                           {
                              value: L("Not In Query"),
                              id: "not_in_query",
                           },
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                           {
                              value: L("is empty"),
                              id: "is_empty",
                           },
                           {
                              value: L("is not empty"),
                              id: "is_not_empty",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                           {
                              value: L("In Data Collection"),
                              id: "in_data_collection",
                           },
                           {
                              value: L("Not In Data Collection"),
                              id: "not_in_data_collection",
                           },
                        ].concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },

                     // Date
                     {
                        batch: "date",
                        view: "combo",
                        value: "less",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("is before"),
                              id: "less",
                           },
                           {
                              value: L("is after"),
                              id: "greater",
                           },
                           {
                              value: L("is on or before"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("is on or after"),
                              id: "greater_or_equal",
                           },
                           {
                              value: L("is before current date"),
                              id: "less_current",
                           },
                           {
                              value: L("is after current date"),
                              id: "greater_current",
                           },
                           {
                              value: L("is on or before current date"),
                              id: "less_or_equal_current",
                           },
                           {
                              value: L("is on or after current date"),
                              id: "greater_or_equal_current",
                           },
                           {
                              value: L("last ... days"),
                              id: "last_days",
                           },
                           {
                              value: L("next ... days"),
                              id: "next_days",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L(":"),
                              id: "equals",
                           },
                           {
                              value: L("≠"),
                              id: "not_equal",
                           },
                           {
                              value: L("<"),
                              id: "less",
                           },
                           {
                              value: L(">"),
                              id: "greater",
                           },
                           {
                              value: L("≤"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("≥"),
                              id: "greater_or_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        value: "is_current_user",
                        options: [
                           {
                              value: L("is current user"),
                              id: "is_current_user",
                           },
                           {
                              value: L("is not current user"),
                              id: "is_not_current_user",
                           },
                           {
                              value: L("contains current user"),
                              id: "contain_current_user",
                           },
                           {
                              value: L("does not contain current user"),
                              id: "not_contain_current_user",
                           },
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               // Value
               {
                  id: ids.inputValue,
                  isolate: true,
                  cells: [
                     {
                        batch: "empty",
                     },

                     // Query
                     {
                        id: ids.queryCombo,

                        batch: "query",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Query Field
                     {
                        id: ids.queryFieldCombo,
                        batch: "queryField",
                        rows: [
                           {
                              id: ids.queryFieldComboQuery,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Query"),
                              on: {
                                 onChange: function (value) {
                                    var $viewComparer = this.getParentView();
                                    var $viewCond = $viewComparer
                                       .getParentView()
                                       .getParentView();
                                    _logic.onChangeQueryFieldCombo(
                                       value,
                                       $viewCond
                                    );

                                    _logic.onChange();
                                 },
                              },
                           },
                           {
                              id: ids.queryFieldComboField,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Field"),
                              on: {
                                 onChange: _logic.onChange,
                              },
                           },
                        ],
                     },

                     // Field match
                     {
                        id: ids.fieldMatch,
                        batch: "fieldMatch",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Data collection
                     {
                        id: ids.dataCollection,
                        batch: "dataCollection",
                        view: "richselect",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Date
                     {
                        // inputView.format = field.getDateFormat();
                        batch: "date",
                        id: ids.datePicker,
                        view: "datepicker",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "text",
                        validate: webix.rules.isNumber,
                        on: {
                           onTimedKeyPress: function () {
                              if (this.validate()) _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        id: ids.listOptions,
                        view: "combo",
                        options: [],
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "checkbox",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        options: this.AB.Account.userList().map((u) => {
                           return {
                              id: u.username,
                              value: u.username,
                           };
                        }),
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewForm = this.getFormView();

                     var indexView = $viewForm.index(this.getParentView());

                     _logic.addNewFilter(indexView + 1);
                  },
               },
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewCond = this.getParentView();

                     _logic.removeNewFilter($viewCond);
                  },
               },
            ],
         };
      };

      _logic.getAddButtonUI = () => {
         return {
            view: "button",
            id: ids.addNewFilter,
            css: "webix_primary",
            type: "form",
            label: L("Add a filter"),
            click: () => {
               _logic.addNewFilter();
            },
         };
      };

      _logic.addNewFilter = (index, fieldId) => {
         var viewId;
         var ui = _logic.getFilterUI();

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            viewId = $viewForm.addView(ui, index);

            _logic.toggleAddNewButton();

            // select a option of field
            if (fieldId) _logic.selectField(fieldId, $$(viewId), true);
         }

         return viewId;
      };

      _logic.removeNewFilter = function ($viewCond) {
         var $viewForm = $$(ids.filterForm);

         $viewForm.removeView($viewCond);

         _logic.toggleAddNewButton();

         _logic.onChange();
      };

      _logic.toggleAddNewButton = function () {
         if (!$$(ids.filterForm)) return;

         // Show "Add new filter" button
         if ($$(ids.filterForm).getChildViews().length < 1) {
            $$(ids.filterForm).hide();
            $$(ids.addNewFilter).show();
         }
         // Hide "Add new filter" button
         else {
            $$(ids.filterForm).show();
            $$(ids.addNewFilter).hide();
         }
      };

      _logic.selectCombineCondition = (val, ignoreNotify) => {
         // define combine value to configuration
         this.config_settings.glue = val;

         // update value of every combine conditions
         var $viewConds = $$(ids.filterForm).getChildViews();
         $viewConds.forEach((v) => {
            if (v.$$ && v.$$(ids.glue)) v.$$(ids.glue).setValue(val);
         });

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.selectField = (columnId, $viewCond, ignoreNotify) => {
         if (!this._Fields) return;

         var field = this._Fields.filter((f) => f.id == columnId)[0];
         if (!field) return;

         // switch view
         batchName = field.key;
         if (field.id == "this_object") batchName = "query";
         // Special this object query
         else if (batchName == "LongText" || batchName == "combined")
            batchName = "string";
         else if (field.key == "formula") batchName = "number";
         var isQueryField =
            this._QueryFields.filter((f) => {
               return f.id == field.id;
            }).length > 0;
         if (isQueryField) {
            // we chose a connectField which is now a Query type
            batchName = "query";
         }
         $viewCond.$$(ids.rule).showBatch(batchName);
         $viewCond.$$(ids.inputValue).showBatch(batchName);

         let options = [];
         let Queries = [];

         // populate the list of Queries for this_object:
         if (field.id == "this_object" && this._Object) {
            Queries = this.queries((q) => q.canFilterObject(this._Object));
         }
         // populate the list of Queries for a query field
         else if (isQueryField) {
            Queries = this.queries((q) => {
               return (
                  (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
                  q.canFilterObject(field.datasourceLink)
               );
            });
         }

         Queries.forEach((q) => {
            options.push({
               id: q.id,
               value: q.label,
            });
         });
         $viewCond
            .$$(ids.inputValue)
            .$$(ids.queryCombo)
            .define("options", options);
         $viewCond.$$(ids.inputValue).$$(ids.queryCombo).refresh();

         // populate options of list
         if (field.key == "list") {
            let listOptions = field.settings.options.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.listOptions)
               .define("options", listOptions);
            $viewCond.$$(ids.inputValue).$$(ids.listOptions).refresh();
         }
         // set format of datepicker
         else if (field.key == "date") {
            $viewCond
               .$$(ids.inputValue)
               .$$(ids.datePicker)
               .define("format", field.getFormat());
            $viewCond.$$(ids.inputValue).$$(ids.datePicker).refresh();
         }

         var rule = null,
            ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.getList) {
            let defaultOpt = ($viewComparer.getList().config.data || [])[0];
            if (defaultOpt) {
               $viewComparer.setValue(defaultOpt.id);
            }

            // rule = $viewComparer.getValue();
            // if (rule == "in_query_field" || rule == "not_in_query_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("queryField");
            // } else if (rule == "same_as_field" || rule == "not_same_as_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("fieldMatch");
            // }
         }

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.onChangeRule = (rule, $viewCond, notify = false) => {
         switch (rule) {
            case "contains":
            case "not_contains":
            case "equals":
            case "not_equal":
               // For "connect_fields" search by CUSTOM index value
               if (batchName == "query") {
                  $viewCond.$$(ids.inputValue).showBatch("string");
               }
               // If want to call notify or call .onChange(), then pass notify is true.
               // _logic.onChange();
               break;

            case "is_current_user":
            case "is_not_current_user":
            case "contain_current_user":
            case "not_contain_current_user":
            case "same_as_user":
            case "not_same_as_user":
            case "less_current":
            case "greater_current":
            case "less_or_equal_current":
            case "greater_or_equal_current":
            case "is_empty":
            case "is_not_empty":
               // clear and disable the value field
               $viewCond.$$(ids.inputValue).showBatch("empty");
               _logic.onChange();
               break;

            case "last_days":
            case "next_days":
               // Show the number input
               $viewCond.$$(ids.inputValue).showBatch("number");
               break;

            case "in_query_field":
            case "not_in_query_field":
               // populate the list of Queries for this_object:
               var options = [];

               // Get all application's queries
               this.queries(
                  (q) => this._Object == null || q.id != this._Object.id
               ).forEach((q) => {
                  options.push({
                     id: q.id,
                     value: q.label,
                  });
               });

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .define("options", options);
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("queryField");
               break;

            case "same_as_field":
            case "not_same_as_field":
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.fieldMatch)
                  .define("options", this.recordRuleFieldOptions);
               $viewCond.$$(ids.inputValue).$$(ids.fieldMatch).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("fieldMatch");
               break;

            case "in_data_collection":
            case "not_in_data_collection": {
               let dcOptions = [];

               // pull data collection list

               // get id of the link object
               let linkObjectId,
                  columnId = $viewCond.$$(ids.field).getValue();
               if (columnId == "this_object" && this._Object) {
                  linkObjectId = this._Object.id;
               } else {
                  let field = this._Fields.filter((f) => f.id == columnId)[0];
                  if (field) linkObjectId = field.settings.linkObject;
               }

               if (this._Application && linkObjectId) {
                  this._Application
                     .datacollections(
                        (dc) =>
                           dc.datasource && dc.datasource.id == linkObjectId
                     )
                     .forEach((dc) => {
                        dcOptions.push({
                           id: dc.id,
                           value: dc.label,
                        });
                     });
               }

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.dataCollection)
                  .define("options", dcOptions);
               $viewCond.$$(ids.inputValue).$$(ids.dataCollection).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("dataCollection");
               break;
            }

            default:
               // Show the default value inputs
               $viewCond.$$(ids.inputValue).showBatch(batchName);

               if (notify) _logic.onChange();

               break;
         }
      };

      _logic.onChangeQueryFieldCombo = (value, $viewCond) => {
         // populate the list of Queries for this_object:
         let options = [];
         // Get all queries fields
         let Query = this.queries((q) => {
            return q.id == value;
         })[0];
         if (Query) {
            Query.fields((f) => {
               return !f.isConnection;
            }).forEach((q) => {
               options.push({
                  id: q.id,
                  value: q.object.label + "." + q.label,
               });
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.queryFieldComboField)
               .define("options", options);
            $viewCond.$$(ids.inputValue).$$(ids.queryFieldComboField).refresh();
         }

         // _logic.onChange();
      };

      _logic.onChange = () => {
         if (!this.__blockOnChange) {
            // refresh config settings before notify
            _logic.getValue();

            console.warn("convert RowFilter.callback.onChange() to .emit()");
            _logic.callbacks.onChange();
            this.emit("change");
         }

         return false;
      };

      _logic.blockOnChange = () => {
         this.__blockOnChange = true;
      };

      _logic.unblockOnChange = () => {
         this.__blockOnChange = false;
      };

      /**
       * @method getValue
       *
       * @return {JSON} -
       * {
       * 		glue: '', // 'and', 'or'
       *		rules: [
       *			{
       *				key:	'column name',
       *				rule:	'rule',
       *				value:	'value'
       *			}
       *		]
       * }
       */
      _logic.getValue = () => {
         let config_settings = {
            glue: "and",
            rules: [],
         };

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            $viewForm.getChildViews().forEach(($viewCond, index) => {
               if (index == 0) {
                  config_settings.glue = $viewCond.$$(ids.glue).getValue();
               }

               var $fieldElem = $viewCond.$$(ids.field);
               if (!$fieldElem) return;

               /* field id */
               var fieldId = $fieldElem.getValue();
               if (!fieldId) return;

               /* alias */
               var alias;
               var selectedOpt = $viewCond
                  .$$(ids.field)
                  .getPopup()
                  .config.body.data.filter((opt) => opt.id == fieldId)[0];
               if (selectedOpt) alias = selectedOpt.alias || undefined;

               /* rule */
               var rule = null,
                  ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
                  $viewComparer = $viewCond
                     .$$(ids.rule)
                     .queryView({ id: ruleViewId });
               if ($viewComparer && $viewComparer.getValue)
                  rule = $viewComparer.getValue();

               /* value */
               var value = null,
                  valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
                  $viewConditionValue = $viewCond
                     .$$(ids.inputValue)
                     .queryView({ id: valueViewId });
               if ($viewConditionValue && $viewConditionValue.getValue) {
                  value = $viewConditionValue.getValue();
               } else if (
                  $viewConditionValue &&
                  $viewConditionValue.getChildViews()
               ) {
                  var vals = [];
                  $viewConditionValue.getChildViews().forEach((element) => {
                     vals.push($$(element).getValue());
                  });
                  value = vals.join(":");
               }

               // Convert date format
               if (value instanceof Date) {
                  let dateField = this._Fields.filter(
                     (f) => f.id == fieldId
                  )[0];
                  if (dateField) {
                     value = dateField.exportValue(value);
                  } else {
                     value = value.toISOString();
                  }
               }

               config_settings.rules.push({
                  alias: alias || undefined,
                  key: fieldId,
                  rule: rule,
                  value: value,
               });
            });
         }

         this.config_settings = config_settings;

         return this.config_settings;
      };

      // webix UI definition:
      this.ui = {
         id: ids.component,
         rows: [
            {
               view: "form",
               id: ids.filterForm,
               hidden: true,
               elements: [],
            },
            _logic.getAddButtonUI(),
         ],
      };
   }

   // setting up UI
   init(options = {}) {
      super.init(options);

      // register our callbacks:
      for (var c in this._logic.callbacks) {
         this._logic.callbacks[c] = options[c] || this._logic.callbacks[c];
      }

      if (options.showObjectName)
         this._settings.showObjectName = options.showObjectName;

      if (options.isRecordRule) {
         this.recordRuleOptions = [
            {
               value: L("Same As Field"),
               id: "same_as_field",
            },
            {
               value: L("Not Field"),
               id: "not_same_as_field",
            },
         ];
         this.recordRuleFieldOptions = options.fieldOptions;
      }
   }

   setValue(settings) {
      settings = settings || {};

      super.setValue(settings);

      let ids = this.ids;
      let logic = this._logic;

      // block .onChange event
      logic.blockOnChange();

      let config_settings = this.AB.cloneDeep(settings);
      config_settings.rules = config_settings.rules || [];

      // Redraw form with no elements
      var $viewForm = $$(ids.filterForm);
      if ($viewForm) webix.ui([], $viewForm);

      // Add "new filter" button
      if (config_settings.rules.length == 0) {
         logic.toggleAddNewButton();
      }

      config_settings.rules.forEach((f) => {
         var viewId = logic.addNewFilter(),
            $viewCond = $$(viewId);

         if ($viewCond == null) return;

         var field = this._Fields.filter((col) => col.id == f.key)[0];

         // "and" "or"
         $viewCond.$$(ids.glue).define("value", config_settings.glue);
         $viewCond.$$(ids.glue).refresh();

         // Select Field
         $viewCond.$$(ids.field).define("value", f.key);
         $viewCond.$$(ids.field).refresh();
         logic.selectField(f.key, $viewCond, true);

         // Comparer
         var ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.setValue) {
            $viewComparer.define("value", f.rule);
            $viewComparer.refresh();
         }

         // if (f.rule == "in_query_field" || f.rule == "not_in_query_field" || f.rule == "same_as_field" || f.rule == "not_same_as_field") {
         $viewCond.blockEvent();
         logic.onChangeRule(f.rule, $viewCond);
         $viewCond.unblockEvent();
         // }

         // Input
         var valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
            $viewConditionValue = $viewCond
               .$$(ids.inputValue)
               .queryView({ id: valueViewId });
         if ($viewConditionValue && $viewConditionValue.setValue) {
            // convert to Date object
            if (
               field &&
               field.key == "date" &&
               f.value &&
               (f.rule == "less" ||
                  f.rule == "greater" ||
                  f.rule == "less_or_equal" ||
                  f.rule == "greater_or_equal")
            ) {
               $viewConditionValue.define("value", new Date(f.value));
            } else {
               $viewConditionValue.define("value", f.value);
            }

            $viewConditionValue.refresh();
         } else if (
            $viewConditionValue &&
            $viewConditionValue.getChildViews()
         ) {
            let vals = (f.value || "").split(":");
            let index = 0;
            $viewConditionValue.getChildViews().forEach((element) => {
               $$(element).blockEvent();
               $$(element).setValue(vals[index]);
               if (index == 0) {
                  logic.onChangeQueryFieldCombo(vals[index], $viewCond);
               }
               $$(element).unblockEvent();
               // $$(element).refresh();
               index++;
            });
         }

         if (field && field.key == "user") {
            $viewCond.blockEvent();
            logic.onChangeRule(f.rule, $viewCond);
            $viewCond.blockEvent();
         }
      });

      // unblock .onChange event
      logic.unblockOnChange();
   }

   /**
    * @method isComplete()
    * returns a truthy value representing whether or not our current condition
    * expression is fully completed.  Then externally checks can be made to
    * verify if the data is complete.
    * @return {bool}
    */
   isComplete() {
      if (!this._completeConditions) {
         this._completeConditions = this.AB.filterComplexNew(
            `${this.ids.component}_iscomplete`
         );
      }

      return this._completeConditions.isConditionComplete(this.getValue());
   }
};


/***/ }),

/***/ 82021:
/*!*******************************************!*\
  !*** ./AppBuilder/platform/RowUpdater.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RowUpdater)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ui/ClassUI */ 32735);
// const ABComponent = require("./ABComponent");

const ABViewForm = __webpack_require__(/*! ../platform/views/ABViewForm */ 70704);

var L = null;

class RowUpdater extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB) {
      super(idBase, {
         form: `${idBase}_rowUpdaterForm`,
         addNew: `${idBase}_rowUpdaterAddNew`,
         field: `${idBase}_rowUpdaterField`,
      });

      this.idBase = idBase;

      this._Object = null;
      // {ABObject}
      // The ABObject we are building a form for.

      this._mockFormWidget = null;
      // {ABViewForm}
      // When building our form components to display, they need a
      // ABViewForm to be associated with.

      this.AB = AB;

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   /**
    * @method uiItem()
    * Return the webix description of a new field/value row.
    * @return {json}
    */
   uiItem() {
      var self = this;
      return {
         rows: [
            {
               view: "layout",
               isolate: true,
               cols: [
                  {
                     // Label
                     view: "label",
                     width: 40,
                     label: L("Set")
                  },
                  {
                     // Field list
                     view: "combo",
                     id: this.ids.field,
                     options: this.getFieldList(true),
                     on: {
                        onChange: function(columnId) {
                           let $viewItem = this.getParentView();
                           self.selectField(columnId, $viewItem);
                        }
                     }
                  },
                  {
                     // Label
                     view: "label",
                     width: 40,
                     label: L("To")
                  },
                  {
                     view: "segmented",
                     value: "custom",
                     height: 40,
                     maxWidth: 160,
                     options: [
                        { id: "custom", value: L("Custom") },
                        { id: "process", value: L("Process") }
                     ],
                     hidden:
                        this._extendedOptions == null ||
                        !this._extendedOptions.length,
                     on: {
                        onChange: function(val) {
                           let $viewItem = this.getParentView();

                           self.toggleCustomProcessOption(
                              $viewItem,
                              val == "process"
                           );
                        }
                     }
                  },
                  // Field value
                  {},
                  // Extended value
                  {
                     hidden: true
                  },
                  {
                     // "Remove" button
                     view: "button",
                     css: "webix_danger",
                     icon: "fa fa-trash",
                     type: "icon",
                     autowidth: true,

                     click: function() {
                        let $viewCond = this.getParentView().getParentView();

                        self.removeItem($viewCond);
                     }
                  },
               ]
            },
         ],
      };
   }

   /**
    * @method ui()
    * return the webix description of our Entry form.
    * @return {json}
    */
   ui() {
      // webix UI definition:
      return {
         rows: [
            {
               view: "form",
               id: this.ids.form,
               hidden: true,
               borderless: true,
               elements: [],
            },
            {
               view: "button",
               id: this.ids.addNew,
               icon: "fa fa-plus",
               type: "iconButton",
               label: L("Add field to edit"),
               click: () => {
                  this.addItem();
               },
            },
         ],
      };
   }

   init(AB) {
      const $form = $$(this.ids.form);
      if ($form) AB.Webix.extend($form, AB.Webix.ProgressBar);

      return Promise.resolve();
   }

   /**
    * @method addItem()
    * Add another field/value entry item to our form.
    * @param {integer} index
    *        which position in the list of form elements do we want to
    *        insert the new row.
    * @return {string} the webix .id of the new row we just added.
    */
   addItem(index) {
      let $form = $$(this.ids.form);

      let remainFields = this.getFieldList(true);
      if (remainFields.length < 1) return;

      let ui = this.uiItem();

      let viewId = $form.addView(ui, index);

      this.toggleForm();

      return viewId;
   }

   /**
    * @method getFieldList()
    * Return an array of options in a webix.list format that represents the
    * possible fields that can be selected on the current ABObject.
    * @param {bool} excludeSelected
    *        should we exclude from the list the fields that are ALREADY
    *        displayed on the form?
    * @return {array} [ { id, value }, ... ]
    *         id: ABField.id
    *         value: ABField.label
    */
   getFieldList(excludeSelected) {
      let options = (this._Object.fields() || []).map((f) => {
         return {
            id: f.id,
            value: f.label,
         };
      });

      if (excludeSelected) {
         let $form = $$(this.ids.form);

         $form.getChildViews().forEach(($viewCond) => {
            // Ignore "Add new" button
            if (!$viewCond || !$viewCond.$$) return;

            let $fieldElem = $viewCond.$$(this.ids.field);
            if (!$fieldElem) return;

            let fieldId = $fieldElem.getValue();
            if (!fieldId) return;

            options = options.filter((opt) => opt.id != fieldId);
         });
      }
      return options;
   }

   /**
    * @method getValue
    * Return an array of field:value results that have been entered on this
    * form.
    * @return {Array}
    *         [
    *            {
    *               fieldId: {UUID}
    *               isProcessValue: {Boolean} - If it is true, then value is from Process parameter
    *               value: {Object}
    *            },
    *            ...
    *         ]
    */
   getValue() {
      let result = [];

      let $form = $$(this.ids.form);
      if ($form) {
         $form.getChildViews().forEach(($viewContainer) => {
            let $viewItem = $viewContainer.getChildViews()[0];

            // Ignore "Add new" button
            if (!$viewItem || !$viewItem.$$) return;

            let $fieldElem = $viewItem.$$(this.ids.field);
            if (!$fieldElem) return;

            let fieldId = $fieldElem.getValue();
            if (!fieldId) return;

            let $customValueElem = $viewItem.getChildViews()[4];
            let $processValueElem = $viewItem.getChildViews()[5];
            if (!$customValueElem && !$processValueElem) return;

            let fieldInfo = this._Object.fieldByID(fieldId);

            let val = {
               fieldId: fieldId,
            };

            // Custom value
            if ($customValueElem && $customValueElem.isVisible()) {
               if (fieldInfo.key == "connectObject") {
                  val.value = fieldInfo.getValue(
                     $customValueElem.getChildViews()[0]
                  );
               } else if (
                  fieldInfo.key == "date" ||
                  fieldInfo.key == "datetime"
               ) {
                  let currDateCheckbox = $customValueElem.getChildViews()[0];
                  if (currDateCheckbox.getValue() == true) {
                     val.value = "ab-current-date";
                  } else {
                     let datePicker = $customValueElem.getChildViews()[1];
                     val.value = fieldInfo.getValue(datePicker);
                  }
               } else {
                  // Get value from data field manager
                  val.value = fieldInfo.getValue($customValueElem);
               }
            }
            // Process value
            else if ($processValueElem && $processValueElem.isVisible()) {
               val.isProcessValue = true;
               val.value = $processValueElem.getValue();
            }

            // Add to output
            result.push(val);
         });
      }

      return result;
   }

   /**
    * @method objectLoad
    * Load the Object we are currently working with.
    * @param {ABObject} object
    */
   objectLoad(object) {
      this._Object = object;

      this._mockApp = this.AB.applicationNew({});
      this._mockFormWidget = new ABViewForm(
         {
            settings: {
               showLabel: false,
               labelWidth: 0,
            },
         },
         this._mockApp // just need any ABApplication here
      );
      this._mockFormWidget.objectLoad(object);

      this.setValue(null); // clear
   }

   /**
    * @method removeItem
    * Remove the current form row.
    * @param {webix.view} $viewCond
    *        This is the webix.view that contains the whole value row
    *        we are removing.
    */
   removeItem($viewCond) {
      let $form = $$(this.ids.form);
      $form.removeView($viewCond);
      this.toggleForm();
   }

   /**
    * @method selectField
    * Update the value display when a field is selected. Changing to a
    * different field will change the types of values that can be entered.
    * @param {string} columnId
    *        The field.uuid of the object that was selected.
    * @param {webix.view} $viewItem
    *        The webix.view that contains the value expression of the field
    *        that was selected.
    */
   async selectField(columnId, $viewItem) {
      let field = this._Object.fieldByID(columnId);
      if (!field) {
         this.AB.notify.builder(
            new Error(`could not find field for id[${columnId}]`),
            {
               context: "RowUpdater.selectField() could not find a field",
               fieldID: columnId,
            }
         );
         return;
      }
      let fieldComponent = field.formComponent(),
         formFieldWidget = fieldComponent.newInstance(
            this._mockApp,
            this._mockFormWidget
         ),
         formFieldComponent = formFieldWidget.component(
            this.AB._App,
            this.idBase
         ),
         inputView = formFieldComponent.ui;

      // WORKAROUND: add '[Current User]' option to the user data field
      switch (field.key) {
         case "connectObject":
            {
               this.busy();
               const getOptTask = field.getOptions();
               const $combo = inputView.rows[0];
               $combo.suggest.body.data = (await getOptTask) ?? [];
               this.ready();
            }
            break;
         case "user":
            inputView.options = inputView.options || [];
            inputView.options.unshift({
               id: "ab-current-user",
               value: L("[Current User]"),
            });
            break;
         case "date":
         case "datetime":
            inputView = {
               view: "layout",
               rows: [
                  {
                     view: "checkbox",
                     labelWidth: 0,
                     labelRight: L("Current Date/Time"),
                     on: {
                        onChange: function (newVal) {
                           let layout = this.getParentView();
                           if (!layout) return;

                           let datePicker = layout.getChildViews()[1];
                           if (!datePicker) return;

                           newVal ? datePicker.hide() : datePicker.show();
                        },
                     },
                  },
                  inputView,
               ],
            };
            break;
      }

      let childViews = $viewItem.getChildViews();

      // Change component to display value
      $viewItem.removeView(childViews[4]);
      $viewItem.addView(inputView, 4);

      formFieldComponent.init();

      // Show custom display of data field
      if (field.customDisplay)
         field.customDisplay({}, this.AB._App, childViews[4].$view);

      // Add extended value options
      $viewItem.removeView(childViews[5]);
      if (this._extendedOptions && this._extendedOptions.length) {
         $viewItem.addView(
            {
               view: "richselect",
               options: this._extendedOptions,
               hidden: true
            },
            5
         );
      } else {
         $viewItem.addView(
            {
               hidden: true
            },
            5
         );
      }

      this.toggleCustomProcessOption(
         $viewItem,
         childViews[3].getValue() == "process"
      );

      // _logic.refreshFieldList();
      // $$(this).adjust();
      $$($viewItem).adjust();
      $viewItem.getFormView().adjust();
   }

   /**
    * @method setValue
    * Given the previous settings, redraw the form with the field/value
    * entries.
    * @param {array} settings
    *        [
    *           {
    *              fieldId: {UUID}
    *              value: {Object|String}
    *           }, ...
    *        ]
    */
   setValue(settings) {
      let $form = $$(this.ids.form);
      if (!$form) return;

      // Redraw form with no elements
      webix.ui([], $form);

      settings = settings || [];
      if (settings.length < 1) return;

      settings.forEach((item) => {
         let $viewContainer = $$(this.addItem());
         let $viewItem = $viewContainer.getChildViews()[0];

         $viewItem.$$(this.ids.field).setValue(item.fieldId);
         let $valueTypeButton = $viewItem.queryView(
            { view: "segmented" },
            "self"
         );
         $valueTypeButton.setValue(
            item.isProcessValue ? "process" : "custom"
         );

         let $customValueElem = $viewItem.getChildViews()[4];
         let $processValueElem = $viewItem.getChildViews()[5];
         if (!$customValueElem && !$processValueElem) return;

         let fieldInfo = this._Object.fieldByID(item.fieldId);
         if (!fieldInfo) return;

         // Set custom value
         let rowData = {};
         rowData[fieldInfo.columnName] = item.value;
         fieldInfo.setValue($customValueElem, rowData);

         // Set process value
         $processValueElem.setValue(item.value);
      });

      this.toggleForm();
   }

   /**
    * @method toggleForm
    * decide if the form with the field/value elements should be displayed.
    */
   toggleForm() {
      let $form = $$(this.ids.form);
      if ($form) {
         let childViews = $form.getChildViews();
         if (childViews && childViews.length) {
            $form.show();
         } else {
            $form.hide();
         }
         $form.adjust();
      }
   }

   setExtendedOptions(options) {
      this._extendedOptions = options;
   }

   toggleCustomProcessOption($viewItem, showProcessOption) {
      let $customOption = $viewItem.getChildViews()[4];
      let $processOption = $viewItem.getChildViews()[5];

      if (showProcessOption) {
         $customOption.hide();
         $processOption.show();
      } else {
         $customOption.show();
         $processOption.hide();
      }
   }

   busy() {
      $$(this.ids.addNew).disable();
      $$(this.ids.form)?.showProgress({ type: "icon" });
   }

   ready() {
      $$(this.ids.addNew).enable();
      $$(this.ids.form)?.hideProgress();
   }
}


/***/ }),

/***/ 14403:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABField.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABField
 *
 * An ABField defines a single unique Field/Column in a ABObject.
 *
 */

const ABFieldCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCore */ 98601);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABField extends ABFieldCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);

      this.AB.on("ab.abdefinition.update", (def) => {
         if (def.id == this.id) {
            this.emit("definition.updated", this);
         }
      });

      //  	// NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      //  	this.defaults = fieldDefaults;

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'fieldKey',				// unique key for this Field
      // 		icon:'font',				// fa-[icon] reference for an icon for this Field Type
      // 		label:'',					// pulled from translation
      // 		columnName:'column_name',	// a valid mysql table.column name
      //		settings: {					// unique settings for the type of field
      // 			showIcon:true/false,	// only useful in Object Workspace DataTable
      // 			isImported: 1/0,		// flag to mark is import from other object
      // 			required: 1/0,			// field allows does not allow NULL or it does allow NULL
      // 			width: {int}			// width of display column

      // 		// specific for dataField
      // 		},
      // 		translations:[]
      // 	}

      // 	this.fromValues(values);

      // this.object = object;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   static clearEditor(ids) {
      this._CurrentField = null;

      const defaultValues = {
         label: "",
         columnName: "",
         showIcon: 1,
         required: 0,
         unique: 0,
         validationRules: "",
      };

      for (const f in defaultValues) {
         const component = $$(ids[f]);
         if (component) component.setValue(defaultValues[f]);
      }

      // reset the validation rules UI
      const filterViews = $$(ids.filterComplex).queryView(
         {
            view: "form",
            css: "abValidationForm",
         },
         "all"
      );
      if (filterViews.length) {
         filterViews.forEach((v) => {
            $$(ids.filterComplex).removeView(v);
         });
      }

      $$(ids.addValidation).hide();

      // hide warning message of null data
      $$(ids.numberOfNull).hide();
   }

   /**
    * @function editorPopulate
    *
    * populate the form with the given ABField instance provided.
    *
    * @param {object} ids
    * @param {ABField} field
    */
   static editorPopulate(ids, field) {
      this._CurrentField = field;

      $$(ids.label).setValue(field.label);
      $$(ids.columnName).setValue(field.columnName);
      $$(ids.showIcon).setValue(field.settings.showIcon);
      $$(ids.required).setValue(field.settings.required);
      $$(ids.unique).setValue(field.settings.unique);

      if (this._CurrentField) {
         $$(ids.addValidation).show();
      }

      if (field.settings && field.settings.validationRules) {
         let rules = field.settings.validationRules;
         if (typeof rules == "string") {
            try {
               rules = JSON.parse(rules);
            } catch (e) {
               // continue regardless of error
            }
         }
         (rules || []).forEach((settings) => {
            field.addValidation(ids, settings);
         });
      }
   }

   /**
    * @function definitionEditor
    *
    * Many DataFields share some base information for their usage
    * in the AppBuilder.  The UI Editors have a common header
    * and footer format, and this function allows child DataFields
    * to not have to define those over and over.
    *
    * The common layout header contains:
    *		[Menu Label]
    *		[textBox: labelName]
    *		[text:    description]
    *
    * The defined DataField UI will be added at the end of this.
    *
    * This routine actually updated the live DataField definition
    * with the common header info.
    *
    * @param {DataField} field  The DataField object to work with.
    */
   static definitionEditor(App, ids, _logic, Field) {
      /// TODO: maybe just pass in onChange instead of _logic
      /// if not onChange, then use our default:

      // setup our default labelOnChange functionality:
      let labelOnChange = function (newVal, oldVal) {
         oldVal = oldVal || "";

         if (
            newVal != oldVal &&
            oldVal == $$(ids.columnName).getValue() &&
            $$(ids.columnName).isEnabled()
         ) {
            $$(ids.columnName).setValue(newVal);
         }
      };

      // if they provided a labelOnChange() override, use that:
      if (_logic.labelOnChange) {
         labelOnChange = _logic.labelOnChange;
      }

      let requiredOnChange = function (newVal, oldVal, ids) {
         console.warn(
            "Field has not implemented .requiredOnChange() is that okay?"
         );
      };

      const addValidation = (ids) => {
         return this._CurrentField.addValidation(ids);
      };

      // if the provided a requriedOnChange() override, use that:
      if (_logic.requiredOnChange) {
         requiredOnChange = _logic.requiredOnChange;
      }

      const getNumberOfNullValue = async (isRequired) => {
         if (
            isRequired &&
            this._CurrentField &&
            this._CurrentField.id &&
            this._CurrentField.settings.required != isRequired
         ) {
            // TODO: disable save button

            // get count number
            const data = await this._CurrentField.object.model().count({
               where: {
                  glue: "and",
                  rules: [
                     {
                        key: this._CurrentField.id,
                        rule: "is_null",
                     },
                  ],
               },
            });

            if (data.count > 0) {
               const messageTemplate = L(
                  "** There are {0} rows that will be updated to default value",
                  [data.count]
               );

               $$(ids.numberOfNull).setValue(messageTemplate);
               $$(ids.numberOfNull).show();
            } else {
               $$(ids.numberOfNull).hide();
            }

            // TODO: enable save button
         } else {
            $$(ids.numberOfNull).hide();
         }
      };

      const _ui = {
         // id: ids.component,
         rows: [
            // {
            // 	view: "label",
            // 	label: "<span class='webix_icon fa fa-{0}'></span>{1}".replace('{0}', Field.icon).replace('{1}', Field.menuName)
            // },
            {
               view: "text",
               id: ids.label,
               name: "label",
               label: L("Label"),
               placeholder: L("Label"),
               labelWidth: this.AB.UISettings.config().labelWidthLarge,
               css: "ab-new-label-name",
               on: {
                  onChange: function (newVal, oldVal) {
                     labelOnChange(newVal, oldVal);
                  },
               },
            },
            {
               view: "text",
               id: ids.columnName,
               name: "columnName",
               disallowEdit: true,
               label: L("Field Name"),
               labelWidth: this.AB.UISettings.config().labelWidthLarge,
               placeholder: L("Database field name"),
            },
            {
               view: "label",
               id: ids.fieldDescription,
               label: L("Description"),
               align: "right",
            },
            {
               view: "checkbox",
               id: ids.showIcon,
               name: "showIcon",
               labelRight: App.labels.dataFieldShowIcon, // 'Show icon',
               labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
               value: true,
            },
            {
               view: "checkbox",
               id: ids.required,
               name: "required",
               hidden: !Field.supportRequire,
               labelRight: App.labels.required,
               // disallowEdit: true,
               labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
               on: {
                  onChange: async (newVal, oldVal) => {
                     requiredOnChange(newVal, oldVal, ids);

                     // If check require on edit field, then show warning message
                     await getNumberOfNullValue(newVal);
                  },
               },
            },
            // warning message: number of null value rows
            {
               view: "label",
               id: ids.numberOfNull,
               css: { color: "#f00" },
               label: "",
               hidden: true,
            },

            {
               view: "checkbox",
               id: ids.unique,
               name: "unique",
               hidden: !Field.supportUnique,
               labelRight: App.labels.unique,
               disallowEdit: true,
               labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
            },
            {
               id: ids.filterComplex,
               rows: [],
            },
            {
               id: ids.addValidation,
               view: "button",
               label: L("Add Field Validation"),
               css: "webix_primary",
               click: () => {
                  addValidation(ids);
               },
            },
            // have a hidden field to contain the validationRules
            // value we will parse out later
            {
               id: ids.validationRules,
               view: "text",
               hidden: true,
               name: "validationRules",
            },
         ],
      };

      return _ui;
   }

   static editorValues(settings) {
      const obj = {
         label: settings.label,
         columnName: settings.columnName,
         settings: settings,
      };

      delete settings.label;
      delete settings.columnName;

      return obj;
   }

   addValidation(ids, settings) {
      const App = this.object.application.App;
      const Filter = this.AB.filterComplexNew(
         `${this.id}_field_validation_rules`
      );
      $$(ids.filterComplex).addView({
         view: "form",
         css: "abValidationForm",
         cols: [
            {
               rows: [
                  {
                     view: "text",
                     name: "invalidMessage",
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     value:
                        settings && settings.invalidMessage
                           ? settings.invalidMessage
                           : "",
                     label: L("Invalid Message"),
                  },
                  Filter.ui,
               ],
            },
            {
               view: "button",
               css: "webix_danger",
               icon: "fa fa-trash",
               type: "icon",
               autowidth: true,
               click: function () {
                  const $viewCond = this.getParentView();
                  $$(ids.filterComplex).removeView($viewCond);
               },
            },
         ],
      });
      $$(Filter.ids.save).hide();
      // Filter.applicationLoad(this.object.application);
      Filter.fieldsLoad(this.object.fields());
      if (settings && settings.rules) Filter.setValue(settings.rules);
   }

   /*
    * @method isValid
    * check the current values to make sure they are valid.
    * Here we check the default values provided by ABField.
    *
    * @return null or [{OP.Validation.validator()}] objects.
    */
   isValid() {
      const validator = this.AB.Validation.validator();

      // .columnName must be unique among fileds on the same object
      const isNameUnique =
         this.object.fields((f) => {
            return (
               f.id != this.id &&
               f.columnName.toLowerCase() == this.columnName.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "columnName",
            L(
               "Field columnName must be unique ({0} already used in this Application)",
               [this.columnName]
            )
         );
      }

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save() before:
      if (!this.id) return;

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      await this.migrateDrop();

      // the server still references an ABField in relationship to it's
      // ABObject, so we need to destroy the Field 1st, then remove it
      // from it's object.
      await super.destroy();

      await this.object.fieldRemove(this);
   }

   /**
    * @method save()
    *
    * persist this instance of ABField with it's parent ABObject
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      let isAdd = false;
      // if this is our initial save()
      if (!this.id) {
         isAdd = true;
      }

      // Whenever we update our settings, make sure any
      // existing rows that have NULL values for this field
      // are updated to have our current .default value.
      if (!isAdd && this.settings.required && this.settings.default) {
         const model = this.object.model();

         // pull rows that has null value
         const result = await model.findAll({
            where: {
               glue: "and",
               rules: [
                  {
                     key: this.id,
                     rule: "is_null",
                  },
               ],
            },
         });

         const tasks = [];

         // updating ...
         result.data.forEach((d) => {
            if (!d[this.columnName]) d[this.columnName] = this.settings.default;

            tasks.push(model.update(d.id, d));
         });

         await Promise.all(tasks);
      }

      // New ABDefinition method of saving:
      // when this is done, we now have an .id
      await super.save();

      // incase this was an ADD operation, make sure the
      // parent Obj now includes this object:
      // NOTE: must be done after the .save() so we have an .id
      await this.object.fieldAdd(this);

      // perform any server side migrations for this Field:

      // but not connectObject fields:
      // ABFieldConnect.migrateXXX() gets called from the UI popupNewDataField
      // in order to handle the timings of the 2 fields that need to be created
      if (!this.isConnection) {
         const fnMigrate = isAdd ? this.migrateCreate() : this.migrateUpdate();
         await fnMigrate;
      }

      return this;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateUpdate() {
      return this.AB.Network.put({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @function columnHeader
    * Return the column header for a webix grid component for this specific
    * data field.
    * @param {Object} options
    * {
    *    isObjectWorkspace: {bool},  is this being used in the Object workspace.
    *    width: {int},
    *    height: {int},
    *    editable: {bool}
    * }
    * @return {obj}  configuration obj
    */
   columnHeader(options) {
      options = options || {};

      const config = {
         id: this.columnName, // this.id,
         header: this.label,
      };

      if (options.isObjectWorkspace && this.settings.showIcon) {
         config.header = `<span class="webix_icon fa fa-${this.fieldIcon()}"></span>${
            config.header
         }`;
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.  If this isn't
    * a standard value display (think image, Map, graph, etc...) then use this
    * method to create the display in the table/grid cell.
    * @param {object} row
    *        is the {name=>value} hash of the current row of data.
    * @param {App} App
    *        the shared ui App object useful more making globally
    *			 unique id references.
    * @param {HtmlDOM} node
    *        the HTML Dom object for this field's display.
    * @param {object} options
    *        option of additional settings
    */
   customDisplay(row, App, node, options) {}

   /*
    * @function customEdit
    *
    *
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      return true;
   }

   /**
    * @method getValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   getValue(item, rowData) {
      return item.getValue();
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    */
   setValue(item, rowData, defaultValue) {
      if (!item) return;

      let val;

      if (
         (rowData == null || rowData[this.columnName] == null) &&
         defaultValue != null
      ) {
         val = defaultValue;
      } else if (rowData && rowData[this.columnName] != null) {
         val = rowData[this.columnName];
      } else {
         val = rowData;
      }

      item.setValue(val);
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent(formKey) {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.

      return {
         // .common() is used to create the display in the list
         common: () => {
            return {
               key: formKey,

               // // but since this is a common place holder: use the
               // // multilingual label here:
               // labelKey: 'ab.abfield.labelPlaceholder',
               // icon:  'square'
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            // NOTE: in case you were wondering, the base ABField
            // 		 will just return a label with 'ABFieldPlaceholder'
            // 		 as the text.  Any sub class of ABField should overwrite
            // 		 this and return an actual Form Component.

            // store object id and field id to field component
            const values = this.formComponent().common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);
            // ABFieldPlaceholder.formatTitle();
            // ABFieldPlaceholder.text = "ABFieldPlaceholder";

            return ABFieldPlaceholder;
         },
      };
   }

   /**
    * @method detailComponent
    */
   detailComponent() {
      return {
         common: () => {
            return {
               icon: "square",
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            // store object id and field id to field component
            const values = this.detailComponent().common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);

            return ABFieldPlaceholder;
         },
      };
   }
};


/***/ }),

/***/ 79579:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldAutoIndex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldAutoIndexCore = __webpack_require__(/*! ../../core/dataFields/ABFieldAutoIndexCore */ 96552);

module.exports = class ABFieldAutoIndex extends ABFieldAutoIndexCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldAutoIndex
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 77280:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldBoolean.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldBooleanCore = __webpack_require__(/*! ../../core/dataFields/ABFieldBooleanCore */ 43104);

module.exports = class ABFieldBoolean extends ABFieldBooleanCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = "template";
      config.css = "center";
      config.template = (row, common, value, config) => {
         // Group header
         if (row.$group) return row[this.columnName];

         // editable
         if (options.editable) {
            return (
               '<div class="ab-boolean-display">' +
               common.checkbox(row, common, value, config) +
               "</div>"
            );
         }

         // readonly
         else {
            if (value)
               return "<div class='webix_icon fa fa-check-square-o'></div>";
            else return "<div class='webix_icon fa fa-square-o'></div>";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("checkbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcheckbox",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 43088:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldCalculate.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldCalculateCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCalculateCore */ 54562);

module.exports = class ABFieldCalculate extends ABFieldCalculateCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCalculate
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 89142:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldCombine.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldCombineCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCombineCore */ 83551);

module.exports = class ABFieldCombine extends ABFieldCombineCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCombine
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 66589:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldConnect.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldConnectCore = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 86932);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldConnect extends ABFieldConnectCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save()d before:
      if (!this.id) return Promise.resolve();

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      // this.migrateDrop()
      //    // .then(() => {
      //    //    // NOTE : prevent recursive remove connected fields
      //    //    // - remove this field from JSON
      //    //    this.object._fields = this.object.fields((f) => {
      //    //       return f.id != this.id;
      //    //    });
      //    // })
      //    .then(() => {
      //       // Save JSON of the object
      //       return this.object.fieldRemove(this);
      //    })
      await super.destroy();

      // Now we need to remove our linked Object->field

      const linkObject = this.datasourceLink;
      if (!linkObject) return Promise.resolve(); // already notified

      const linkField = this.fieldLink;
      if (!linkField) return Promise.resolve(); // already notified

      // destroy linked field
      return linkField.destroy();
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method pullRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData = [];

      const data = super.pullRelationValues(row);
      const linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         } else if (typeof data == "string") {
            selectedData = { text: data };
         }
      }

      return selectedData;
   }

   columnHeader(options) {
      options = options || {};
      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      if (options.filters == null) {
         options.filters = {};
      }

      var multiselect = this.settings.linkType == "many";

      config.editor = multiselect ? "multiselect" : "combo";
      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };
      config.template = (row) => {
         var selectedData = this.pullRelationValues(row);
         var values = [];
         values.push('<div class="badgeContainer">');
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               values.push(
                  `<div class='webix_multicombo_value'><span>${val.value}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
               );
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData.value) {
            let clear = "";
            if (options.editable) {
               clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
            }
            values.push(
               `<div class='webix_multicombo_value'>${clear}<span class="ellip">${selectedData.value}</span></div>`
            );
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };

      config.suggest = {
         on: {
            onBeforeShow: function () {
               field.openOptions(this);
            },
         },

         // Support partial matches
         filter: ({ value }, search) =>
            (value ?? "").toLowerCase().includes((search ?? "").toLowerCase()),
      };

      if (multiselect) {
         config.suggest.view = "checksuggest";
         config.suggest.button = true;
      }

      return config;
   }

   openOptions($suggest) {
      // PREVENT repeatedly pull data:
      // If the options list was populated, then skip
      const $list = $suggest.getList();
      if (($list?.find({}) ?? []).length) return;

      // Listen create/update events of the linked object, then clear data list to re-populate
      ["create", "update"].forEach((key) => {
         if (this[`_dc_${key}_event`]) return;

         this[`_dc_${key}_event`] = this.AB.on(
            `ab.datacollection.${key}`,
            (res) => {
               if (this.datasourceLink.id == res.objectId) $list.clearAll();
            }
         );
      });

      this.getAndPopulateOptions($suggest);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */

   //// NOTE: why do we pass in row, App, and node?  is this something we do in our external components?
   ////       are these values present when this Object is instanciated? Can't we just pass these into the
   ////       object constructor and have it internally track these things?
   customEdit(row, App, node) {
      // var selectedData = this.pullRelationValues(row);
      // this._selectedData = selectedData;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("connect");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailconnect",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method getOptions
    * show options list in selectivity
    *
    * @return {Promise}
    */
   getOptions(where, term, sort) {
      return new Promise((resolve, reject) => {
         let haveResolved = false;
         // {bool}
         // have we already passed back a result?

         const respond = (options) => {
            // filter the raw lookup with the provided search term
            options = options.filter((item) => {
               if (item.text.toLowerCase().includes(term.toLowerCase())) {
                  return true;
               }
            });

            if (!haveResolved) {
               haveResolved = true;
               resolve(options);
            } else {
               // if we have already resolved() then .emit() that we have
               // updated "option.data".
               this.emit("option.data", options);
            }
         };

         // Prepare Where clause

         where = where || {};
         sort = sort || [];

         if (!where.glue) where.glue = "and";

         if (!where.rules) where.rules = [];

         term = term || "";

         // check if linked object value is not define, should return a empty array
         if (!this.settings.linkObject) return [];

         // if options was cached
         // if (this._options != null) return resolve(this._options);

         const linkedObj = this.datasourceLink;

         // System could not found the linked object - It may be deleted ?
         if (linkedObj == null) throw new Error("No linked object");

         const linkedCol = this.fieldLink;

         // System could not found the linked field - It may be deleted ?
         if (linkedCol == null) throw new Error("No linked column");

         // Get linked object model
         const linkedModel = linkedObj.model();

         // M:1 - get data that's only empty relation value
         if (
            this.settings.linkType == "many" &&
            this.settings.linkViaType == "one"
         ) {
            // Mar 8, 2022 I (James) removed this because we need these options
            // to appear so we can put a checkbox next to them with the new UI
            // where.rules.push({
            //    key: linkedCol.id,
            //    rule: "is_null",
            // });
            // where[linkedCol.columnName] = null;
         }
         // 1:1
         else if (
            this.settings.linkType == "one" &&
            this.settings.linkViaType == "one"
         ) {
            // 1:1 - get data is not match link id that we have
            if (this.settings.isSource == true) {
               // NOTE: make sure "haveNoRelation" shows up as an operator
               // the value ":0" doesn't matter, we just need 'haveNoRelation' as an operator.
               // newRule[linkedCol.id] = { 'haveNoRelation': 0 };
               where.rules.push({
                  key: linkedCol.id,
                  rule: "have_no_relation",
               });
            }
            // 1:1 - get data that's only empty relation value by query null value from link table
            else {
               where.rules.push({
                  key: linkedCol.id,
                  rule: "is_null",
               });
               // newRule[linkedCol.id] = 'null';
               // where[linkedCol.id] = null;
            }
         }

         const storageID = `${this.id}-${JSON.stringify(where)}`;

         Promise.resolve()
            // TODO: debug the cached data + response so the droplist can display
            // updated data.
            .then(async () => {
               // Get Local Storage

               // We store the .findAll() results locally and return that for a
               // quick response:
               const storedOptions = await this.AB.Storage.get(storageID);
               if (storedOptions) {
                  // immediately respond with our stored options.
                  this._options = storedOptions;
                  return respond(this._options);
               }
            })
            .then(async () => {
               try {
                  // Pull linked object data
                  const result = await linkedModel.findAll({
                     where: where,
                     sort: sort,
                     populate: false,
                  });

                  // cache linked object data
                  this._options = result.data || result || [];

                  // populate display text
                  (this._options || []).forEach((opt) => {
                     opt.text = linkedObj.displayData(opt);
                     opt.value = opt.text;
                  });

                  this.AB.Storage.set(storageID, this._options);
                  return respond(this._options);
               } catch (err) {
                  this.AB.notify.developer(err, {
                     context:
                        "ABFieldConnect:getOptions(): unable to retrieve options from server",
                     field: this.toObj(),
                     where,
                  });

                  haveResolved = true;
                  throw err;
               }
            });
      });
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               vals.push(itemObj.id);
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         if (!value) {
            return [];
         } else {
            let returnVals = [];
            let vals = value.split(",");
            vals.forEach((val) => {
               returnVals.push(this.getItemFromVal(val));
            });
            return returnVals;
         }
      } else {
         let item = this.getItemFromVal(value);
         return item;
      }
   }

   getAndPopulateOptions(editor, options, field, form) {
      const theEditor = editor;

      // if we are filtering based off another selectivity's value we
      // need to do it on fetch each time because the value can change
      // copy the filters so we don't add to them every time there is a change
      const combineFilters = options?.filters
         ? Object.assign({}, options.filters)
         : { glue: "and", rules: [] };

      if (options?.filterByConnectValues) {
         const parseFilterByConnectValues = (conditions, values, depth = 0) => {
            const valuesByDepth = values.filter((e) => e.depth === depth);

            return [
               ...conditions.rules.map((e) => {
                  if (e.glue)
                     return {
                        glue: e.glue,
                        rules: parseFilterByConnectValues(e, values, depth + 1),
                     };

                  const value = valuesByDepth.filter(
                     (ef) => ef.key === e.key && ef.value === e.value
                  )[0];

                  if (!value) return e;

                  const $parentField = value?.filterValue?.config.id
                     ? $$(value.filterValue.config.id)
                     : null;

                  if (!$parentField)
                     throw Error(
                        "Some parent field's view components don't exist"
                     );

                  const parentValue = value?.filterValue
                     ? $parentField.getValue() ?? ""
                     : "";

                  let newVal = "";

                  if (parentValue) {
                     if (value.filterColumn) {
                        if (
                           field.object
                              .fieldByID(value.filterValue.config.dataFieldId)
                              .getItemFromVal(parentValue)
                        ) {
                           newVal = field.object
                              .fieldByID(value.filterValue.config.dataFieldId)
                              .getItemFromVal(parentValue)[value.filterColumn];
                        } else {
                           newVal = parentValue;
                        }
                     } else {
                        newVal = parentValue;
                     }
                  }

                  return {
                     key: e.key,
                     rule: "equals",
                     value: newVal,
                  };
               }),
            ];
         };

         combineFilters.rules = parseFilterByConnectValues(
            combineFilters,
            options.filterByConnectValues
         );
      }

      const handlerOptionData = (data) => {
         this.populateOptions(theEditor, data, field, form, true);
      };

      // try to make sure we don't continually add up listeners.
      this.removeListener("option.data", handlerOptionData).once(
         "option.data",
         handlerOptionData
      );

      this.getOptions(combineFilters, "").then((data) => {
         this.populateOptions(theEditor, data, field, form, false);
      });
   }

   populateOptions(theEditor, data, field, form, addCy) {
      theEditor.blockEvent();
      theEditor.getList().clearAll();
      theEditor.getList().define("data", data);
      if (addCy) {
         this.populateOptionsDataCy(theEditor, field, form);
      }
      if (theEditor.getValue && theEditor.getValue()) {
         theEditor.setValue(theEditor.getValue());
         // } else if (this._selectedData && this._selectedData.length) {
         //    theEditor.setValue(this.editFormat(this._selectedData));
      }
      theEditor.unblockEvent();
   }

   populateOptionsDataCy(theEditor, field, form) {
      // Add data-cy attributes
      if (theEditor?.getList) {
         if (!theEditor.getPopup) return;
         var popup = theEditor.getPopup();
         if (!popup) return;
         theEditor.getList().data.each((option) => {
            if (!option) return;
            var node = popup.$view.querySelector(
               "[webix_l_id='" + option.id + "']"
            );
            if (!node) return;
            node.setAttribute(
               "data-cy",
               `${field.key} options ${option.id} ${field.id} ${form.id}`
            );
         });
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this._options || [];
      if (options.length > 0) {
         for (let i = 0; i < options.length; i++) {
            if (
               this.indexField &&
               options[i][this.indexField.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else if (
               this.indexField2 &&
               options[i][this.indexField2.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else {
               if (options[i].id == val) {
                  item = options[i];
                  break;
               }
            }
         }
         return item;
      } else {
         return "";
      }
   }

   getValue(item) {
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         let vals = [];
         if (item.getValue()) {
            let val = item.getValue().split(",");
            val.forEach((record) => {
               vals.push(item.getList().getItem(record));
            });
         }
         return vals;
      } else {
         if (item.getValue()) {
            return item.getList().getItem(item.getValue());
         } else {
            return "";
         }
      }
   }

   setValue(item, rowData) {
      if (!item) return;
      // if (AB.isEmpty(rowData)) return; removed because sometimes we will
      // want to set this to empty
      let val = this.pullRelationValues(rowData);
      // put in current values as options so we can display them before
      // the rest of the options are fetched when field is clicked
      if (item.getList && item.getList().count() == 0) {
         if (this.settings.linkType != "one" && !Array.isArray(val)) {
            val = [val];
         }
         item.getList().define("data", val);
      }
      item.define("value", val);
   }

   /**
    * @method pullRecordRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRecordRelationValues(record) {
      var selectedData = [];

      var data = record;
      var linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         }
      }

      return selectedData;
   }
};


/***/ }),

/***/ 90176:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldDate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldDateCore = __webpack_require__(/*! ../../core/dataFields/ABFieldDateCore */ 96915);

module.exports = class ABFieldDate extends ABFieldDateCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // if (this.settings.includeTime)
      // config.editor = "datetime";
      // else
      config.editor = "date";

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   dateToString(dateFormat, dateData) {
      return webix.Date.dateToStr(dateFormat)(dateData);
   }

   // Overwrite core.format to use webix locales.
   format(rowData) {
      if (!window.webixLocale) return super.format(rowData);
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }
      const dateObj = this.AB.toDate(d);

      const dateFormat = this.settings.dateFormat;
      // @const {int} dateFormat AB Date Format
      // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy

      // Return longdate if option 4 or 5
      if (dateFormat >= 4) {
         return webix.i18n.longDateFormatStr(dateObj);
      } else {
         return webix.i18n.dateFormatStr(dateObj);
      }
   }
};


/***/ }),

/***/ 21747:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldDateTime.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldDateTimeCore = __webpack_require__(/*! ../../core/dataFields/ABFieldDateTimeCore */ 6926);

module.exports = class ABFieldDateTime extends ABFieldDateTimeCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // Ignore date
      if (this.settings.dateFormat == 1) {
         config.editor = "time";
      } else {
         config.editor = "datetime";
      }

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   // Overwrite core.format to use webix locales.
   format(rowData) {
      if (!window.webixLocale) return super.format(rowData);
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }
      const dateObj = this.AB.toDate(d);

      const dateFormat = this.settings.dateFormat;
      // @const {int} dateFormat AB Date Format
      // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy
      const timeToStr = webix.Date.dateToStr(this.getTimeFormat());

      if (dateFormat >= 4) {
         return `${webix.i18n.longDateFormatStr(dateObj)} ${timeToStr(
            dateObj
         )}`;
      } else {
         return `${webix.i18n.dateFormatStr(dateObj)} ${timeToStr(dateObj)}`;
      }
   }
};


/***/ }),

/***/ 39137:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldEmail.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldEmailCore = __webpack_require__(/*! ../../core/dataFields/ABFieldEmailCore */ 6945);

module.exports = class ABFieldEmail extends ABFieldEmailCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 42597:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldFile.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldFileCore = __webpack_require__(/*! ../../core/dataFields/ABFieldFileCore */ 85019);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldFile extends ABFieldFileCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related file.
    */
   async destroy() {
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (!this.id) {
            resolve();
            return;
         }

         // Ask the user what to do about the existing file:
         webix.confirm({
            title: L("Keep Files?"),
            message: L("Do you want to keep the files referenced by {0}?", [
               this.label,
            ]),
            callback: async (result) => {
               // update this setting so the server can respond correctly in
               // ABFieldFile.migrateDrop()
               this.settings.removeExistingData = result ? 0 : 1;

               try {
                  await this.save();

                  // TODO: a reminder that you still got alot on the server to do!
                  webix.alert({
                     title: "!! TODO !!",
                     text:
                        "Tell a Developer to actually pay attention to this!",
                  });

                  // now the default .destroy()
                  await super.destroy();

                  resolve();
               } catch (err) {
                  reject(err);
               }
            },
         });
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFile
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = false;

      const editable = options.editable;

      // populate our default template:
      config.template = (obj) => {
         if (obj.$group) return this.dataValue(obj);

         const fileDiv = [
            '<div class="ab-file-data-field" style="float: left;">',
            '<div class="webix_view ab-file-holder">',
            '<div class="webix_template">',
            this.fileTemplate(obj, editable),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return fileDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }
      options = options || {};

      let typesList = [];
      let maximumSize = 0;

      if (this.settings.limitFileType && this.settings.fileType) {
         typesList = this.settings.fileType.split(",");
      }

      if (this.settings.limitFileSize && this.settings.fileSize) {
         maximumSize = this.settings.fileSize;
      }

      // 		// safety check:
      // 		// webix seems to crash if you specify a .container that doesn't exists:
      // 		// Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-file-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         // 			// use a webix component for displaying the content.
         // 			// do this so I can use the progress spinner

         const webixContainer = webix.ui({
            view: "template",
            container: parentContainer,

            template: this.fileTemplate(row, options.editable),

            borderless: true,
            width: 160,
            height: 60,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         // 			////
         // 			//// Prepare the Uploader
         // 			////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";

            return;
         }

         const url = this.urlUpload(true);

         const uploader = webix.ui({
            view: "uploader",
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: function (item) {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = typesList;
                  if (acceptableTypes && acceptableTypes != "") {
                     const type = item.type.toLowerCase();
                     if (acceptableTypes.indexOf(type) == -1) {
                        webix.message(
                           L("Only [{0}] files are supported", [
                              acceptableTypes.join(", "),
                           ])
                        );
                        return false;
                     }
                  }

                  //verify file size
                  //Convert to MegaBytes
                  if (maximumSize > 0) {
                     const acceptableSizes = maximumSize * 1000000;
                     if (item.size > acceptableSizes) {
                        webix.message(
                           L("Maximum file size is {0}MB", [maximumSize])
                        );
                        return false;
                     }
                  }

                  // start progress indicator
                  webixContainer.showProgress({
                     type: "icon",
                     delay: 2000,
                  });
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  // this.showFile(idBase, response.data.uuid);

                  const values = {};
                  values[this.columnName] = {};
                  values[this.columnName].uuid = response.data.uuid;
                  values[this.columnName].filename = item.name;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldFile.onFileUpload(): Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error loading file"), {
                     message: "Error loading file",
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // open file upload dialog when's click
         node.addEventListener("click", (e) => {
            if (e.target.className.indexOf("delete-image") > -1) {
               this.deleteFile = true;
            }
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      if (this.deleteFile == true) {
         // remove the property because it is only needed to prevent the file dialog from showing
         delete this.deleteFile;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: "",
            message: L("Are you sure you want to remove this file?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};
                  values[this.columnName] = "";

                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           message: "Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }
                  // update value in the form component
                  else {
                     this.setValue($$(node), values);
                  }
               }
            },
         });
      } else {
         const rowData = this.dataValue(row);
         if (!rowData || !rowData.uuid) {
            const uploaderId = node.dataset["uploaderId"],
               uploader = $$(uploaderId);

            if (uploader && uploader.fileDialog)
               uploader.fileDialog({ rowid: row.id });
         }
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcustom",
         };
      };

      return detailComponentSetting;
   }

   //File Template

   fileTemplate(obj, editable) {
      let iconDisplay = "";
      let fileDisplay = "display:none;";
      let fileURL = "";

      let value = "";
      let name = "";

      const rowData = this.dataValue(obj);
      if (rowData) {
         value = rowData.uuid;
         name = rowData.filename;
      }

      if (value && name) {
         iconDisplay = "display:none;";
         fileDisplay = "";
         fileURL = "/file/" + value;
      }

      const html = [
         `<div class="file-data-field-icon" style="text-align: center; height: inherit; display: table-cell; vertical-align: middle; border: 2px dotted #CCC; background: #FFF; border-radius: 10px; font-size: 11px; line-height: 13px; padding: 0 10px; ${iconDisplay}"><i class="fa fa-file fa-2x" style="opacity: 0.6; font-size: 32px; margin-top: 3px; margin-bottom: 5px;"></i>${
            editable ? `<br/>${L("Drag and drop or click here")}` : ""
         }</div>`,
         `<div class="file-data-field-name" style=" width:100%; height:100%; position:relative; "><a target="_blank" href="${fileURL}">${
            name || ""
         }</a>${
            editable
               ? `<a style="${fileDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
               : ""
         }</div>`,
      ].join("");

      return html;
   }

   getValue(item, rowData) {
      const file = item.$view.querySelector(".file-data-field-name");
      const fileLink = file.querySelector("a");

      return {
         uuid: file.getAttribute("file-uuid"),
         filename: fileLink.innerHTML,
      };
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const fileicon = domNode.querySelector(".file-data-field-icon");
      if (fileicon) fileicon.style.display = val && val.uuid ? "none" : "block";

      const file = domNode.querySelector(".file-data-field-name");
      if (file) {
         const fileDeleteIcon = file.querySelector(".ab-delete-photo");
         if (fileDeleteIcon)
            fileDeleteIcon.style.display = val && val.uuid ? "block" : "none";

         file.style.display = val && val.uuid ? "block" : "none";
         if (val && val.uuid) file.setAttribute("file-uuid", val.uuid);
         else file.removeAttribute("file-uuid");

         const fileLink = file.querySelector("a");
         const fileURL = "/file/" + (val ? val.uuid : "");
         fileLink.href = fileURL;
         fileLink.innerHTML = val ? val.filename : "";
      }
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = true) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }
};


/***/ }),

/***/ 58439:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldFormula.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldFormulaCore = __webpack_require__(/*! ../../core/dataFields/ABFieldFormulaCore */ 28725);

module.exports = class ABFieldFormula extends ABFieldFormulaCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 70780:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldImage.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldImageCore = __webpack_require__(/*! ../../core/dataFields/ABFieldImageCore */ 84342);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldImage extends ABFieldImageCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related images.
    */
   async destroy() {
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (this.id) {
            // Ask the user what to do about the existing images:
            webix.confirm({
               title: L("Keep Images?"),
               message: L("Do you want to keep the images referenced by {0}?", [
                  this.label,
               ]),
               callback: async (result) => {
                  // update this setting so the server can respond correctly in
                  // ABFieldImage.migrateDrop()
                  this.settings.removeExistingData = result ? 0 : 1;

                  try {
                     await this.save();

                     // TODO: a reminder that you still got alot on the server to do!
                     webix.alert({
                        title: "!! TODO !!",
                        text:
                           "ABFieldImage.destroy(): Tell a Developer to actually pay attention to this!",
                     });

                     await super.destroy();

                     resolve();
                  } catch (err) {
                     reject(err);
                  }
               },
            });
         } else {
            resolve(); // nothing to do really
         }
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj, formId) {
      // if formId is passed the field is in a form view not a grid and
      // we won't have the obj and each time this
      // field is in a form it will conflict with the last one rendered
      if (formId) {
         return `${this.columnName.replace(/ /g, "_")}-${formId}-image`;
      } else {
         return `${this.columnName.replace(/ /g, "_")}-${obj.id}-image`;
      }
   }

   // return the grid column header definition for this instance of ABFieldImage
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;

      config.editor = false; // 'text';  // '[edit_type]'   for your unique situation
      // config.sort   = 'string' // '[sort_type]'   for your unique situation

      let containerHeight = "100%";
      let imageHeight = "100%";
      let width = "100%";
      let imageSrcHeight = "100%";
      if (field.settings.useWidth) {
         config.width = field.settings.imageWidth || 100;
         const heightVal =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight + 20
               : 80;
         containerHeight = `${heightVal}px`;
         width = `${field.settings.imageWidth || 100}px`;
         imageHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 80;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 60;
         imageSrcHeight = `${imageSrcHeight}px`;
      } else if (options.width) {
         config.width = options.width || 100;
         width = `${options.width || 100}px`;
         imageHeight = options.width;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = options.width;
         imageSrcHeight = `${imageSrcHeight}px`;
      }
      if (
         field.settings.useHeight &&
         field.settings.imageHeight &&
         field.settings.imageHeight != "NaN"
      ) {
         config.height = field.settings.imageHeight || 0;
         containerHeight = parseInt(config.height) + 20;
         containerHeight = `${containerHeight}px`;
         imageHeight = parseInt(config.height);
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = parseInt(config.height);
         imageSrcHeight = `${imageSrcHeight}px`;
      }

      const editable = options.editable;

      // populate our default template:
      // debugger;
      config.template = (obj) => {
         if (obj.$group) return obj[this.columnName];

         const widthStyle = `width: ${width}; height: ${containerHeight}`;

         const imageStyle = `width: ${width}; height: ${imageHeight}`;

         const imgDiv = [
            `<div class="ab-image-data-field" style="float: left; ${widthStyle}">`,
            `<div class="webix_view ab-image-holder" style="${imageStyle}">`,
            '<div class="webix_template">',
            this.imageTemplate(obj, {
               editable: editable,
               height: imageSrcHeight,
               width: width,
            }),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return imgDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    * @param {object} options - {
    * 		editable {Bool}   where or not this field is currently editable
    * 		formId {string}   the id of the presenting form if any
    * }
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }
      const L = App.Label;

      options = options || {};

      const idBase = App.unique(this.idCustomContainer(row, options.formId));

      // safety check:
      // webix seems to crash if you specify a .container that doesn't exists:
      // Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         let imgHeight = 0;
         if (this.settings.useHeight) {
            imgHeight = parseInt(this.settings.imageHeight) || imgHeight;
         }

         let imgWidth = 0;
         if (this.settings.useWidth) {
            imgWidth = parseInt(this.settings.imageWidth) || imgWidth;
         }

         if (options.height) imgHeight = options.height;

         if (options.width) imgWidth = options.width;
         //// TODO: actually pay attention to the height and width when
         //// displaying the images.

         // use a webix component for displaying the content.
         // do this so I can use the progress spinner
         const webixContainer = webix.ui({
            view: "template",
            css: "ab-image-holder",
            // id: ids.container,
            container: parentContainer,

            template: this.imageTemplate(row, {
               editable: options.editable,
               height: imgHeight ? imgHeight + "px" : 0,
               width: imgWidth ? imgWidth + "px" : 0,
            }),

            borderless: true,
            height: imgHeight,
            width: imgWidth,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         ////
         //// Prepare the Uploader
         ////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";

            return;
         }

         const url = this.urlUpload();

         const uploader = webix.ui({
            view: "uploader",
            // id:ids.uploader,
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            // formData:{
            // 	appKey:application.name,
            // 	permission:actionKey,
            // 	isWebix:true,
            // 	imageParam:'upload'
            // },
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: function (item) {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = ["jpg", "jpeg", "bmp", "png", "gif"];
                  const type = item.type.toLowerCase();
                  if (acceptableTypes.indexOf(type) == -1) {
                     webix.message(
                        L("Only [{0}] images are supported", [
                           acceptableTypes.join(", "),
                        ])
                     );
                     return false;
                  }

                  // start progress indicator
                  webixContainer.showProgress({
                     type: "icon",
                     delay: 2000,
                  });
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  this.showImage(response.data.uuid, node);

                  // TODO: delete previous image from our OPsPortal service?

                  const values = {};
                  values[this.columnName] = response.data.uuid;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if (
                           $$(node) &&
                           $$(node).getItem &&
                           $$(node).getItem(row.id)
                        ) {
                           $$(node).updateItem(row.id, values);
                        } else {
                           // if you scroll the table the connection to the datatable is lost so we need to find it again
                           const dataTable = document.querySelector(
                              ".webix_dtable"
                           );
                           if ($$(dataTable) && $$(dataTable).getItem(row.id))
                              $$(dataTable).updateItem(row.id, values);
                        }
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldImage.onFileUpload(): model.update(): error updating our entry",
                           field: this,
                           row,
                           values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error uploading image"), {
                     context: "ABFieldImage. uploader. onFileUploadError():",
                     field: this,
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // if we are working in a datagrid we need to add a click event to
         // check if the user is clicking on the delete button
         if (node.className == "webix_cell") {
            node.addEventListener("click", (e) => {
               if (e.target.className.indexOf("delete-image") > -1) {
                  this.deleteImage = true;
               }
            });
         }
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, id, evt) {
      if (
         (evt && evt.target.className.indexOf("delete-image") > -1) ||
         this.deleteImage
      ) {
         delete this.deleteImage;
         if (!row.removeDefaultImage) {
            row.removeDefaultImage = [];
         }
         row.removeDefaultImage[this.columnName] = true;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: L("Are you sure you want to remove this image?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};
                  values[this.columnName] = ""; // removing the reference to the image here

                  try {
                     await this.object.model().update(row.id, values);

                     // update the client side data object as well so other data changes won't cause this save to be reverted
                     if ($$(node) && $$(node).updateItem)
                        $$(node).updateItem(row.id, values);

                     // update value in the form component
                     this.setValue($$(node), values);
                  } catch (err) {
                     node.classList.add("webix_invalid");
                     node.classList.add("webix_invalid_cell");

                     this.AB.notify.developer(err, {
                        context:
                           "ABFieldImage: customEdit(): Error updating our entry",
                        field: this,
                        row: row,
                        values: values,
                     });
                  }
               }
            },
         });
      } else {
         const uploaderId = node.dataset["uploaderId"],
            uploader = $$(uploaderId);

         if (uploader && uploader.fileDialog)
            uploader.fileDialog({ rowid: row.id });
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailimage",
         };
      };

      return detailComponentSetting;
   }

   imageTemplate(obj, options) {
      options = options || {};
      options.height = options.height || "100%";
      options.width = options.width || "100%";

      // deault view is icon:
      let iconDisplay = "";
      let imageDisplay = "display:none;";
      let imageURL = "";

      let value = "";
      let isRemoveDefaultImage = false;
      if (obj[this.columnName]) {
         value = obj[this.columnName];
      }
      if (obj.removeDefaultImage) {
         if (obj.removeDefaultImage[this.columnName]) {
            isRemoveDefaultImage = obj.removeDefaultImage[this.columnName];
         }
      }

      if (value) {
         iconDisplay = "display:none;";
         imageDisplay = "";
         imageURL = `background-image:url('${this.urlImage(value)}');`;
      } else {
         if (this.settings.useDefaultImage && !isRemoveDefaultImage) {
            iconDisplay = "display:none;";
            imageDisplay = "";
            imageURL = `background-image:url('${this.urlImage(
               this.settings.defaultImageUrl
            )}');`;
         }
      }

      let html = [
         `<div class="image-data-field-icon" style="${iconDisplay}">#drag#</div>` +
            `<div class="image-data-field-image" style="${imageDisplay} width:${options.width}; height:${options.height}; ${imageURL}">#remove#</div>`,
      ].join("");

      html = html.replace(
         "#drag#",
         options.editable
            ? `<div>${L("Drag and drop or click here")}</div>`
            : ""
      );
      html = html.replace(
         "#remove#",
         options.editable
            ? `<a style="${imageDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
            : ""
      );

      return html;
   }

   showImage(uuid, node) {
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.querySelector(".image-data-field-icon").style.display =
            "none";
         const image = parentContainer.querySelector(".image-data-field-image");
         image.style.display = "";
         image.style.backgroundImage = `url('${this.urlImage(uuid)}')`;
         image.setAttribute("image-uuid", uuid);
      }
   }

   getValue(item, rowData) {
      const image = item.$view.querySelector(".image-data-field-image");
      return image.getAttribute("image-uuid");
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const imageIcon = domNode.querySelector(".image-data-field-icon");
      if (imageIcon) imageIcon.style.display = val ? "none" : "";

      const image = domNode.querySelector(".image-data-field-image");
      if (image) {
         const imageDeleteIcon = image.querySelector(".ab-delete-photo");
         if (imageDeleteIcon)
            imageDeleteIcon.style.display = val ? "block" : "none";

         image.style.display = val ? "block" : "none";

         if (val) {
            image.style.backgroundImage = `url('${this.urlImage(val)}')`;
            image.setAttribute("image-uuid", val);
         } else {
            image.removeAttribute("image-uuid");
         }
      }
   }

   /**
    * @method toBase64
    *
    * @param {Object} rowData
    *
    * @return {Promise} - {
    * 		data: string,
    * 		width: number,
    * 		height: number
    * }
    */
   toBase64(rowData) {
      const promise = new Promise((resolve, reject) => {
         if (!rowData[this.columnName]) return resolve(null);

         const img = new Image();
         img.crossOrigin = "Anonymous";
         img.onerror = function (err) {
            reject(err);
         };
         img.onload = function () {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const dataURL = canvas.toDataURL();
            const imageData = {
               data: dataURL,
               width: img.width,
               height: img.height,
            };
            resolve(imageData);
         };

         img.src = this.urlImage(rowData[this.columnName]);
      });
      return promise;
   }

   /**
    * @method urlImage()
    * return the url to use to reference the image by it's id.
    * @param {string} id
    *        the file.uuid reference of this image.
    * @return {string}
    */
   urlImage(id) {
      return `/file/${id}`;
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = true) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }
};


/***/ }),

/***/ 31797:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldJson.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldJsonCore = __webpack_require__(/*! ../../core/dataFields/ABFieldJsonCore */ 76611);

module.exports = class ABFieldJson extends ABFieldJsonCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldJson
   columnHeader(options) {
      const config = super.columnHeader(options);

      // config.editor = null; // read only for now
      config.editor = "text";
      config.css = "textCell";

      // when called by ABViewFormCustom, will need a .template() fn.
      // currently we don't need to return anything so ...
      config.template = () => "";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // read-only for now
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 69319:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldList.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldListCore = __webpack_require__(/*! ../../core/dataFields/ABFieldListCore */ 73291);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldList extends ABFieldListCore {
   constructor(values, object) {
      super(values, object);

      // this._Selectivity = new ABFieldSelectivity(values, object);
   }

   ///
   /// Instance Methods
   ///

   save() {
      return super.save().then(() => {
         // Now we want to clear out any entries that had values == to item removed from our list:
         if (this.pendingDeletions.length) {
            const model = this.object.model();

            if (this.settings.isMultiple == true) {
               // find all the entries that have one of the deleted values:
               // use Promise to prevent issues with data being loaded before it is deleted on client side
               return new Promise((resolve, reject) => {
                  let numDone = 0;
                  let numToDo = 0;

                  model
                     .findAll({})
                     .then((list) => {
                        list = list.data || list;

                        // for each list item
                        list.forEach((item) => {
                           if (Array.isArray(item[this.columnName])) {
                              // get fields not in pendingDeletions
                              let remainingFields = item[
                                 this.columnName
                              ].filter((i) => {
                                 return (
                                    this.pendingDeletions.indexOf(i.id) == -1
                                 );
                              });

                              if (
                                 remainingFields.length !=
                                 item[this.columnName].length
                              ) {
                                 numToDo++;

                                 // update value to new field list
                                 if (remainingFields.length == 0) {
                                    remainingFields = "";
                                 }
                                 const value = {};
                                 value[this.columnName] = remainingFields;
                                 model.update(item.id, value).then(() => {
                                    // if ($$(node) && $$(node).updateItem)
                                    //    $$(node).updateItem(value.id, value);
                                    numDone++;
                                    if (numDone >= numToDo) {
                                       resolve();
                                    }
                                 });
                              }
                           }
                        });
                        if (numToDo == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            } else {
               // find all the entries that have one of the deleted values:
               const where = {};
               where[this.columnName] = this.pendingDeletions;
               return new Promise((resolve, reject) => {
                  let numDone = 0;

                  model
                     .findAll(where)
                     .then((list) => {
                        // make sure we just work with the { data:[] } that was returned
                        list = list.data || list;

                        // for each one, set the value to ''
                        // NOTE: jQuery ajax routines filter out null values, so we can't
                        // set them to null. :(
                        // const numDone = 0;
                        const value = {};
                        value[this.columnName] = "";

                        list.forEach((item) => {
                           model.update(item.id, value).then(() => {
                              numDone++;
                              if (numDone >= list.length) {
                                 resolve();
                              }
                           });
                        });
                        if (list.length == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            }
         }
      });
   }

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldList
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      var formClass = "";
      var placeHolder = "";
      if (options.editable) {
         formClass = " form-entry";
         placeHolder = `<span style='color: #CCC; padding: 0 5px;'>${L(
            "Select item"
         )}</span>`;
      }
      var isRemovable = options.editable && !this.settings.required;

      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };

      config.template = (rowData) => {
         let selectedData = rowData[this.columnName];
         if (selectedData == null) return "";
         if (this.settings.isMultiple) {
            selectedData = _getSelectedOptions(this, rowData);
         }
         var values = [];
         values.push('<div class="badgeContainer">');
         let hasCustomColor = "";
         let optionHex = "";
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               if (this.settings.hasColors && val.hex) {
                  hasCustomColor = "hascustomcolor";
                  optionHex = `background: ${val.hex};`;
               }
               if (val.text) {
                  values.push(
                     `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'><span>${val.text}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
                  );
               }
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData) {
            let selectedObj = selectedData;
            if (typeof selectedData == "string") {
               selectedObj = this.getItemFromVal(selectedData);
            }
            if (!selectedObj) return "";
            if (this.settings.hasColors && selectedObj.hex) {
               hasCustomColor = "hascustomcolor";
               optionHex = `background: ${selectedObj.hex};`;
            }
            if (selectedObj.text) {
               let clear = "";
               if (options.editable && !this.settings.required) {
                  clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
               }
               values.push(
                  `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'>${clear}<span class="ellip">${selectedObj.text}</span></div>`
               );
            }
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };
      config.editor = this.settings.isMultiple ? "multiselect" : "combo";
      config.suggest = {
         button: true,
         data: this.settings.options.map(function (opt) {
            return {
               id: opt.id,
               value: opt.text,
               hex: opt.hex,
            };
         }),
      };
      if (this.settings.isMultiple) {
         config.suggest.view = "checksuggest";
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      if (!node.querySelector) return;

      var clearButton = node.querySelector(
         ".selectivity-single-selected-item-remove"
      );
      if (clearButton) {
         clearButton.addEventListener("click", (e) => {
            e.stopPropagation();
            var values = {};
            values[this.columnName] = "";
            this.object
               .model()
               .update(row.id, values)
               .then(() => {
                  // update the client side data object as well so other data changes won't cause this save to be reverted
                  $$(node)?.updateItem?.(row.id, values);
               })
               .catch((err) => {
                  node.classList.add("webix_invalid");
                  node.classList.add("webix_invalid_cell");

                  this.AB.notify.developer(err, {
                     message: "Error updating our entry.",
                     row: row,
                     values: "",
                     field: this.toObj(),
                  });
               });
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customEdit(row, App, node) {
   //    return super.customEdit(row, App, node);
   // }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "selectmultiple" : "selectsingle",
            settings: {
               options: this.settings.options.map(function (opt) {
                  return {
                     id: opt.id,
                     value: opt.text,
                     hex: opt.hex,
                  };
               }),
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "detailtext" : "detailtext",
         };
      };

      return detailComponentSetting;
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               vals.push(itemObj.id);
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      if (this.settings.isMultiple) {
         let returnVals = [];
         let vals = value.split(",");
         vals.forEach((val) => {
            returnVals.push(this.getItemFromVal(val));
         });
         return returnVals;
      } else {
         return value;
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this.options();
      if (options.length > 1) {
         options.forEach((option) => {
            if (option.id == val) {
               item = option;
               return false;
            }
         });
         return item;
      } else {
         return "";
      }
   }

   getValue(item, rowData) {
      return this.editParse(item.getValue());
   }

   getSelectedOptions(field, rowData = {}) {
      let result = [];
      if (rowData[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData) {
         if (Array.isArray(rowData)) {
            result = rowData;
         } else {
            result.push(rowData);
         }
      }
      if (result.length) {
         if (typeof result == "string") result = JSON.parse(result);

         // Pull text with current language
         if (this.settings) {
            result = (this.settings.options || []).filter((opt) => {
               return (
                  (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                     .length > 0
               );
            });
         }
      }

      return result;
   }

   setValue(item, rowData) {
      if (!item) return;

      if (this.settings.isMultiple) {
         // do we need anything here?
      } else {
         super.setValue(item, rowData);
      }
   }
};

// == Private methods ==
function _getSelectedOptions(field, rowData = {}) {
   let result = [];
   if (rowData[field.columnName] != null) {
      result = rowData[field.columnName];

      if (typeof result == "string") result = JSON.parse(result);

      // Pull text with current language
      if (field.settings) {
         result = (field.settings.options || []).filter((opt) => {
            return (
               (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                  .length > 0
            );
         });
      }
   }

   return result;
}


/***/ }),

/***/ 74384:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldLongText.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldLongTextCore = __webpack_require__(/*! ../../core/dataFields/ABFieldLongTextCore */ 37143);

module.exports = class ABFieldLongText extends ABFieldLongTextCore {
   constructor(values, object) {
      super(values, object);

      /*
		{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
		}
		*/
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldLongText
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text"; // '[edit_type]'   for your unique situation
      // config.sort = 'string' // '[sort_type]'   for your unique situation
      config.template = (obj, common, value, col, ind) => {
         return (value || "").toString().replace(/[<]/g, "&lt;");
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "multiple",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
};


/***/ }),

/***/ 41812:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldNumber.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldNumberCore = __webpack_require__(/*! ../../core/dataFields/ABFieldNumberCore */ 49671);

let INIT_EDITOR = false;
// {bool} INIT_EDITOR
// Transition code between previous Framework and current.
// we now need to wait until webix is declared or accessible globally.

module.exports = class ABFieldNumber extends ABFieldNumberCore {
   constructor(values, object) {
      if (!INIT_EDITOR) {
         // NOTE: if you need a unique [edit_type] by your returned config.editor above:
         webix.editors.number = webix.extend(
            {
               // TODO : Validate number only
            },
            webix.editors.text
         );
         INIT_EDITOR = true;
      }
      super(values, object);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   // return the grid column header definition for this instance of ABFieldNumber
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "number"; // [edit_type] simple inline editing.

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      return config;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("numberbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 87038:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldSelectivity.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldSelectivity
 *
 * An ABFieldSelectivity defines a single unique Field/Column in a ABObject.
 *
 */

const ABField = __webpack_require__(/*! ./ABField */ 14403);

const defaultSettings = {
   allowClear: true,
   removeOnly: false,
   readOnly: false,
   showDropdown: true,
   placeholder: "",
   multiple: false,
};

const ABFieldSelectivityDefaults = {
   key: "selectivity",
};

module.exports = class ABFieldSelectivity extends ABField {
   constructor(values, object, fieldDefaults = ABFieldSelectivityDefaults) {
      super(values, object, fieldDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return {
         key: "selectivity",
         icon: "bars",
         menuName: "",
         description: "",
      };
   }

   selectivityRender(domNode, settings, App, row) {
      if (domNode == null) return;

      const cypress = settings.dataCy || "";
      domNode.setAttribute("data-cy", cypress);

      // setting up our specific settings:
      settings = settings || {};
      for (const dv in defaultSettings) {
         if (settings[dv] === null) {
            settings[dv] = null;
         } else {
            settings[dv] = settings[dv] || defaultSettings[dv];
         }
      }

      if (
         settings.multiple &&
         settings.items &&
         settings.data &&
         settings.data.length
      ) {
         settings.data.forEach(function (d) {
            settings.items.map(function (i) {
               if (i.id == d.id) d.hex = i.hex;
            });
         });
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      } else if (settings["data"] == null || settings["data"] == "") {
         settings["data"] = this.prepareData([], settings.multiple);
      } else {
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      }

      // store the field id so we can look it up on click events later
      settings["field"] = this.id;

      // Prevent render selectivity duplicate
      if (domNode.selectivity != null) {
         // Refresh selectivity settings
         domNode.selectivity.setOptions(settings);

         return;
      }

      settings.element = domNode;

      // Render selectivity
      let selectivityInput;
      if (settings.multiple) {
         if (settings.isUsers) {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: #eee !important; color: #666 !important; box-shadow: inset 0px 1px 1px #333;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
								<i class="fa fa-user" style="color: #666; opacity: 0.6;"></i> 
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
								${!settings.isLabelHidden ? options.text : ""}
								${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove" style="color: #333;"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         } else {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: ${options.hex} !important;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
                        ${
                           settings.editPage
                              ? ` <a class="selectivity-multiple-selected-item-edit"><i class="fa fa-edit"></i></a>`
                              : ""
                        }
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
                        ${!settings.isLabelHidden ? options.text : ""}
                        ${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         }
         selectivityInput = new Selectivity.Inputs.Multiple(settings);

         domNode.selectivity = selectivityInput;
         this.selectivitySetBadge(domNode, App, row);
      } else {
         settings.templates = {
            singleSelectedItem: function (options) {
               return `<span class="selectivity-single-selected-item" data-item-id="${
                  options.uuid
               }" data-field-id="${settings.field}">
							${
                        settings.editPage
                           ? '<a class="selectivity-single-selected-item-edit"><i class="fa fa-edit"></i></a>'
                           : ""
                     }
                     ${
                        settings.additionalText
                           ? settings.additionalText(options)
                           : ""
                     }
                     ${!settings.isLabelHidden ? options.text : ""}
                     ${
                        options.removable
                           ? '<a class="selectivity-single-selected-item-remove"><i class="fa fa-remove"></i></a>'
                           : ""
                     }
						</span>`;
            },
         };

         selectivityInput = new Selectivity.Inputs.Single(settings);
         domNode.selectivity = selectivityInput;
      }

      if (settings.editPage) {
         const trigerEditPageEvent = () => {
            const instance = this;
            const editMenus = document.querySelectorAll(
               ".selectivity-single-selected-item-edit, .selectivity-multiple-selected-item-edit"
            );
            for (let i = 0; i < editMenus.length; i++) {
               const eMenu = editMenus[i];
               if (eMenu && !eMenu.__hasClickEvent) {
                  eMenu.addEventListener(
                     "click",
                     function (e) {
                        e.stopPropagation();
                        e.preventDefault();

                        const parentElm = this.parentElement;
                        if (!parentElm) return;

                        const rowId = parentElm.getAttribute("data-item-id");
                        if (!rowId) return;

                        const fieldId = parentElm.getAttribute("data-field-id");
                        if (!fieldId) return;

                        const thisField = instance.object.fieldByID(fieldId);
                        if (!thisField) return;

                        thisField.emit("editPage", rowId);
                     },
                     true
                  );
                  eMenu.__hasClickEvent = true;
               }
            }
         };

         setTimeout(() => {
            trigerEditPageEvent();

            domNode.addEventListener("change", () => {
               trigerEditPageEvent();
            });
         }, 500);
      }

      // WORKAROUND : remove caret icon of selectivity
      if (settings.readOnly) {
         const caretElems = domNode.getElementsByClassName("selectivity-caret");
         for (let i = 0; i < caretElems.length; i++) {
            const caretElm = caretElems[i];
            if (caretElm) {
               caretElm.parentNode.removeChild(caretElm);
            }
         }
      }

      // remember our settings values
      this.selectivitySettings = settings;
   }

   selectivityGet(domNode) {
      if (domNode && domNode.selectivity) {
         if (this.selectivitySettings && this.selectivitySettings.multiple) {
            // on a multiple select, return an array of results, or empty array
            return domNode.selectivity.getData() || [];
         } else {
            // if a single select, return the object or null
            return domNode.selectivity.getData() || null;
         }
      } else {
         if (this.selectivitySettings && this.selectivitySettings.multiple)
            return [];
         else return null;
      }
   }

   selectivitySet(domNode, data) {
      if (!domNode || !domNode.selectivity) return;

      data = this.prepareData(data, domNode.selectivity.options.multiple);

      if (
         (Array.isArray(data) && data[0]) || // Check Array
         (data && data.id)
      )
         // Check a object
         domNode.selectivity.setData(data);
      else domNode.selectivity.clear();
   }

   selectivityDestroy(domNode) {
      if (domNode && domNode.selectivity) {
         domNode.selectivity.destroy();

         delete domNode.selectivity;
      }
   }

   prepareData(data, multiple = true) {
      if (!data && multiple) {
         return [];
      } else if (multiple && data && Array.isArray(data) && data.length == 0) {
         return [];
      } else if (!multiple && data && Array.isArray(data) && data.length == 0) {
         return null;
      } else if (!data && !multiple) {
         return null;
      }

      if (typeof data == "string" && data.length > 0) {
         try {
            data = JSON.parse(data);
         } catch (e) {
            // not JSON parsable, so convert to
            data = { id: data, text: data };
         }
      }

      // if single select, then it should be object
      if (!multiple && Array.isArray(data)) {
         data = data[0];
      } else if (multiple && !Array.isArray(data)) {
         data = [data];
      }

      // check to see if id is present on each item
      if (multiple) {
         data.forEach((d) => {
            if (!d.id && d.uuid) {
               d.id = d.uuid;
            }
         });
      } else {
         if (!data.id && data.uuid) data.id = data.uuid;
      }

      if (data == null && multiple) {
         data = [];
      }

      return data;
   }

   selectivitySetBadge(domNode) {
      if (!domNode.clientHeight) return;
      const innerHeight = domNode.clientHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         let values = [];
         if (domNode && domNode.selectivity)
            values = domNode.selectivity.getValue() || [];

         count = values.length;
         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               // v2: this just updated the $height property for this row
               // we don't do that anymore:
               // anchor.addEventListener("click", function () {
               //    App.actions.onRowResizeAuto(row.id, innerHeight);
               // });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }
};


/***/ }),

/***/ 98134:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldString.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldStringCore = __webpack_require__(/*! ../../core/dataFields/ABFieldStringCore */ 36756);

module.exports = class ABFieldString extends ABFieldStringCore {
   // constructor(values, object) {
   //    super(values, object);

   // {
   //   settings: {
   // 	  default: 'string',
   // 	  supportMultilingual: 1/0
   //   }
   // }

   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldString
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";
      config.css = "textCell";
      // config.sort   = 'string'
      config.template = (obj, common, value /* , col, ind */) => {
         // if this isn't part of a group header display the default format
         if (!obj.$group) {
            return (value || "").toString().replace(/[<]/g, "&lt;");
         } else {
            return "";
         }
      };

      return config;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (data && data[this.columnName]) {
         const max_length = this.constructor.defaults().MAX_CHAR_LENGTH;

         if (data[this.columnName].length > max_length) {
            const L = this.AB.Label();
            validator.addError(
               this.columnName,
               L("should NOT be longer than {0} characters", [max_length])
            );
         }
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
};


/***/ }),

/***/ 27238:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldTextFormula.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldTextFormulaCore = __webpack_require__(/*! ../../core/dataFields/ABFieldTextFormulaCore */ 18585);

module.exports = class ABFieldTextFormula extends ABFieldTextFormulaCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldTextFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(/* row, App, node, options */) {}

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return null;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 60779:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldTreeCore = __webpack_require__(/*! ../../core/dataFields/ABFieldTreeCore */ 98630);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldTree extends ABFieldTreeCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj) {
      return "#columnName#-#id#-tree"
         .replace("#id#", obj.id)
         .replace("#columnName#", this.columnName.replace(/ /g, "_"));
   }

   // return the grid column header definition for this instance of ABFieldTree
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;

      let formClass = "";
      let placeHolder = "";
      if (options.isForm) {
         formClass = " form-entry";
         placeHolder =
            "<span style='color: #CCC; padding: 0 5px;'>" +
            L("Select items") +
            "</span>";
      }

      const width = options.width;

      config.template = (obj) => {
         if (obj.$group) return obj[field.columnName];

         const branches = [];
         let selectOptions = this.AB.cloneDeep(field.settings.options);
         selectOptions = new webix.TreeCollection({
            data: selectOptions,
         });

         let values = obj;
         if (obj[field.columnName] != null) {
            values = obj[field.columnName];
         }

         selectOptions.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  selectOptions.data.each(function (par) {
                     if (selectOptions.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values'>";
         if (branches.length == 0) {
            nodeHTML += placeHolder;
         } else {
            branches.forEach(function (item) {
               nodeHTML +=
                  '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
                  myHex +
                  ' !important;">' +
                  item +
                  "</span>";
            });
         }
         nodeHTML += "</div>";

         // field.setBadge(node, App, row);

         if (width) {
            return (
               '<div style="margin-left: ' +
               width +
               'px;" class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         } else {
            return (
               '<div class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      const field = this;

      if (options.isForm) {
         if (!row || row.length == 0) {
            node.innerHTML =
               "<div class='list-data-values form-entry'><span style='color: #CCC; padding: 0 5px;'>" +
               L("Select items") +
               "</span></div>";
            return;
         }

         const branches = [];
         options = this.AB.cloneDeep(field.settings.options);
         options = new webix.TreeCollection({
            data: options,
         });

         let values = row;
         if (row[field.columnName] != null) {
            values = row[field.columnName];
         }

         options.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  options.data.each(function (par) {
                     if (options.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values form-entry'>";
         branches.forEach(function (item) {
            nodeHTML +=
               '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
               myHex +
               ' !important;">' +
               item +
               "</span>";
         });
         nodeHTML += "</div>";

         node.innerHTML = nodeHTML;
      }

      field.setBadge(node, App, row);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, component) {
      const idBase = App.unique(this.idCustomContainer(row));
      const idPopup = `${idBase}-popup`;
      const idTree = `${idBase}-tree`;
      const view = $$(node);
      const field = this;
      const parentComponent = component;
      let values = {};
      let firstRender = true;

      function getValues(field, row) {
         let values = {};
         if (
            typeof field != "undefined" &&
            typeof field.columnName != "undefined" &&
            typeof row[field.columnName] != "undefined"
         ) {
            values = row[field.columnName];
         }
         return values;
      }

      function populateTree(field, vals) {
         values = getValues(field, vals);

         $$(idTree).blockEvent(); // prevents endless loop

         const options = field.AB.cloneDeep(field.settings.options);
         $$(idTree).clearAll();
         $$(idTree).parse(options);
         $$(idTree).refresh();
         $$(idTree).uncheckAll();
         $$(idTree).openAll();

         if (values != null && values.length) {
            values.forEach(function (id) {
               if ($$(idTree).exists(id)) {
                  $$(idTree).checkItem(id);
                  const dom = $$(idTree).getItemNode(id);
                  dom.classList.add("selected");
               }
            });
         }
         $$(idTree).unblockEvent();
      }

      if ($$(idPopup)) {
         $$(idPopup).show();
         populateTree(this, row);
      } else {
         webix
            .ui({
               id: idPopup,
               view: "popup",
               width: 500,
               height: 400,
               on: {
                  onShow: () => {
                     if (firstRender == true) populateTree(this, row);

                     firstRender = false;
                  },
               },
               body: {
                  id: idTree,
                  view: "tree",
                  css: "ab-data-tree",
                  template: function (obj, common) {
                     return (
                        "<label>" +
                        common.checkbox(obj, common) +
                        "&nbsp;" +
                        obj.text +
                        "</label>"
                     );
                  },
                  on: {
                     onItemCheck: async function (id, value, event) {
                        const dom = this.getItemNode(id);
                        const tree = this;
                        if (value == true) {
                           dom.classList.add("selected");
                        } else {
                           dom.classList.remove("selected");
                        }
                        // works for the same-level children only
                        // except root items
                        if (this.getParentId(id)) {
                           tree.blockEvent(); // prevents endless loop

                           let rootid = id;
                           while (this.getParentId(rootid)) {
                              rootid = this.getParentId(rootid);
                              if (rootid != id) tree.uncheckItem(rootid);
                           }

                           this.data.eachSubItem(rootid, function (item) {
                              if (item.id != id) tree.uncheckItem(item.id);
                           });

                           tree.unblockEvent();
                        } else {
                           tree.blockEvent(); // prevents endless loop
                           this.data.eachSubItem(id, function (obj) {
                              if (obj.id != id) tree.uncheckItem(obj.id);
                           });
                           tree.unblockEvent();
                        }
                        const values = {};
                        values[field.columnName] = $$(idTree).getChecked();

                        if (row.id) {
                           // pass null because it could not put empty array in REST api
                           if (values[field.columnName].length == 0)
                              values[field.columnName] = "";

                           try {
                              await field.object.model().update(row.id, values);

                              // update the client side data object as well so other data changes won't cause this save to be reverted
                              if (view && view.updateItem) {
                                 view.updateItem(row.id, values);
                              }
                           } catch (err) {
                              node.classList.add("webix_invalid");
                              node.classList.add("webix_invalid_cell");

                              this.AB.notify.developer(err, {
                                 message: "Error updating our entry.",
                                 row: row,
                                 values: values,
                              });
                           }
                        } else {
                           const rowData = {};
                           rowData[field.columnName] = $$(idTree).getChecked();

                           field.setValue($$(parentComponent.ui.id), rowData);
                        }
                     },
                  },
               },
            })
            .show(node, {
               x: -7,
            });
      }
      return false;
   }

   setBadge(domNode, row) {
      const field = this;
      domNode = domNode.querySelector(".list-data-values");
      const innerHeight = domNode.scrollHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         if (row[field.columnName] && row[field.columnName].length)
            count = row[field.columnName].length;
         else count = 0;

         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               anchor.addEventListener("click", function (event) {
                  // v2: this was just saving the new height to the
                  // field properties. We don't do that anymore:
                  // App.actions.onRowResizeAuto(row.id, innerHeight);
                  event.stopPropagation();
               });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("formtree");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtree",
         };
      };

      return detailComponentSetting;
   }

   getValue(item, rowData) {
      let values = {};
      values = item.getValues();
      return values;
   }

   setValue(item, rowData) {
      if (!item) return false;

      const val = rowData[this.columnName] || [];

      item.setValues(val);
      // get dom
      const dom = item.$view.querySelector(".list-data-values");

      if (!dom) return false;

      // set value to selectivity
      this.customDisplay(val, this.App, dom, {
         editable: true,
         isForm: true,
      });

      setTimeout(function () {
         let height = 33;
         if (dom.scrollHeight > 33) {
            height = dom.scrollHeight;
         }
         item.config.height = height + 5;
         item.resize();
      }, 200);
   }
};


/***/ }),

/***/ 29333:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldUser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldConnectCore = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 86932);
const ABFieldUserCore = __webpack_require__(/*! ../../core/dataFields/ABFieldUserCore */ 18665);

module.exports = class ABFieldUser extends ABFieldUserCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   ///
   /// Working with Actual Object Values:
   ///

   async save() {
      // Add new
      if (this.id == null) {
         const SiteUser = this.AB.objectUser();
         const Defaults = ABFieldUserCore.defaults();

         this.settings.linkObject = SiteUser.id;
         this.settings.isCustomFK = 1;

         if (this.settings.isMultiple) {
            this.settings.indexField2 = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "many";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         } else {
            this.settings.indexField = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "one";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         }

         // TODO: .fieldCustomNew() for saving "local" changes.
         // NOTE: The Object adding this Field sees it's data as a ABFieldUser
         //       connection.
         //       However, the SiteUser will see the data as a ABFieldConnect
         //       connection
         const linkCol = SiteUser.fieldNew({
            key: ABFieldConnectCore.defaults().key,
            columnName: `${this.object.name}_${this.label}`,
            label: this.object.label,
            settings: {
               showIcon: this.settings.showIcon,
               linkObject: this.object.id,
               linkType: this.settings.linkViaType,
               linkViaType: this.settings.linkType,
               isCustomFK: this.settings.isCustomFK,
               indexField: this.settings.indexField,
               indexField2: this.settings.indexField2,
               isSource: 0,
            },
         });

         // // Create definitions of the connected fields
         // // NOTE: skip directly to the ABMLClass.save() to avoid the
         // // migrations caused during the ABField.save() operations.
         // await ABFieldUserCore.prototype.save.call(this);

         // linkCol.settings.linkColumn = this.id;
         // await ABFieldUserCore.prototype.save.call(linkCol);

         // // Update the id value of linked field to connect together
         // this.settings.linkColumn = linkCol.id;
         // await ABFieldUserCore.prototype.save.call(this);

         let newDef = await this.toDefinition().save();
         this.id = newDef.id;

         linkCol.settings.linkColumn = this.id;
         let newLinkDef = await linkCol.toDefinition().save();
         linkCol.id = newLinkDef.id;

         this.settings.linkColumn = linkCol.id;
         await this.toDefinition().save();

         // Add fields to Objects
         await this.object.fieldAdd(this);

         await SiteUser.fieldAdd(linkCol);

         // Create column to DB
         await this.migrateCreate();

         await linkCol.migrateCreate();

         return this;
      } else {
         return super.save();
      }
   }

   // return the grid column header definition for this instance of ABFieldUser

   columnHeader(options) {
      // debugger;
      options = this.setDisplayOptions(options);
      return super.columnHeader(options);
   }

   /**
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customDisplay(row, App, node, options = {}) {
   //    debugger;
   //    options = this.setDisplayOptions(options);
   //
   //    return super.customDisplay(row, App, node, options);
   // }

   setDisplayOptions(options) {
      options = options || {};
      options.editable =
         this.settings.editable != null ? this.settings.editable : true;

      options.isLabelHidden =
         this.settings.isShowUsername != null
            ? !this.settings.isShowUsername
            : false;

      options.additionalText = (opt) => {
         if (!this.settings.isShowProfileImage) return "";

         if (opt.image_id)
            return `<img src='/opsportal/image/UserProfile/${opt.image_id}' style='border-radius:100%; object-fit: cover; margin: 0 5px 0 -10px;' width='28' height='28' />`;
         else return '<i style="opacity: 0.6;" class="fa fa-user"></i> ';
      };

      return options;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (this.settings.isCurrentUser) {
         if (this.settings.isMultiple) {
            values[this.columnName] = [
               {
                  id: this.AB.Account.username(),
                  text: this.AB.Account.username(),
               },
            ];
         } else {
            values[this.columnName] = this.AB.Account.username();
         }
      }
   }

   // getValue() {
   //    var elem = $$(ids.component);
   //
   //    return field.getValue(elem, rowData);
   // }

   setValue(item, rowData) {
      let val = rowData[this.columnName];
      // Select "[Current user]" to update
      if (val == "ab-current-user") val = this.AB.Account.username();

      rowData[this.columnName] = val;

      super.setValue(item, rowData);
   }

   getUsers() {
      return this.AB.Account.userList().map((u) => {
         const result = {
            id: u.username,
            image: u.image_id,
         };

         if (this.settings.isMultiple) {
            result.text = u.username;
         } else {
            result.value = u.username;
         }

         return result;
      });
   }
};


/***/ }),

/***/ 30144:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/process/ABProcessLane.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessLane
 * manages a lane in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */
var ABProcessLaneCore = __webpack_require__(/*! ../../core/process/ABProcessLaneCore */ 62418);

module.exports = class ABProcessLane extends ABProcessLaneCore {
   // constructor(attributes, process, application) {
   //    super(attributes, process, application);
   // }

   ////
   //// Modeler Instance Methods
   ////

   transferParticipantWhereToMe(id) {
      var myParticipant = this.process.elementForDiagramID(id);
      if (myParticipant) {
         // if I haven't already set my where clause, and my Participant
         // has one, then take it:
         if (!this.stashed && myParticipant.stashed) {
            var copyParams = [
               "stashed",
               "useRole",
               "role",
               "useAccount",
               "account",
            ];
            copyParams.forEach((p) => {
               var swap = this[p];
               this[p] = myParticipant[p];
               myParticipant[p] = swap; // ?? do this ??
            });
         }
      }
   }

   /**
    * fromElement()
    * initialize this Lane's values from the given BPMN:Lane
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;

      // on creation, if I have child objects, then move the .where definition
      // from my parent Participant to ME
      if (element.children && element.children.length > 0) {
         if (element.parent && element.parent.type == "bpmn:Participant") {
            this.transferParticipantWhereToMe(element.parent.id);
         }
      } else {
         // this info might just reside in the .parent.children[]
         if (
            element.parent &&
            element.parent.children &&
            element.parent.children.length > 0
         ) {
            element.parent.children.forEach((child) => {
               if (child.type != "bpmn:Lane") {
                  // if child has lanes
                  if (
                     child.businessObject.lanes &&
                     child.businessObject.lanes.length > 0
                  ) {
                     // if lane is me
                     var myLane = child.businessObject.lanes.find((l) => {
                        return l.id == this.diagramID;
                     });
                     if (myLane) {
                        this.transferParticipantWhereToMe(element.parent.id);

                        // tell child I'm it's lane:
                        var objChild = this.process.elementForDiagramID(
                           child.id
                        );
                        if (objChild) {
                           objChild.setLane(this);
                        }
                     }
                  }
               }
            });
         }
      }

      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Lane with information that was relevant
    * from the provided BPMN:Lane
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // if I picked up a new task, inform it I am it's lane:
   }
};


/***/ }),

/***/ 67692:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/process/ABProcessParticipant.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system (when there are no lanes defined)
 * and provide a way to lookup a SiteUser.
 */
var ABProcessParticipantCore = __webpack_require__(/*! ../../core/process/ABProcessParticipantCore */ 52957);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessParticipant extends ABProcessParticipantCore {
   // constructor(attributes, process, AB) {
   //    super(attributes, process, AB);
   // }

   ////
   //// Modeler Instance Methods
   ////

   /**
    * fromElement()
    * initialize this Participant's values from the given BPMN:Participant
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Participant with information that was relevant
    * from the provided BPMN:Participant
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      if (defElement.children) {
         var laneIDs = [];
         defElement.children.forEach((c) => {
            if (c.type == "bpmn:Lane") {
               laneIDs.push(c.id);
            }
         });
         this.laneIDs = laneIDs;
      }
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this objec.
    * @return {json}
    */
   diagramProperties() {
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
   }

   // static propertyIDs(id) {
   //    return {
   //       form: `${id}_form`,
   //       name: `${id}_name`,
   //       role: `${id}_role`,
   //       useRole: `${id}_useRoles`,
   //       useAccount: `${id}_useAccounts`,
   //       account: `${id}_account`,
   //    };
   // }
   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      console.error("TODO: refactor to ABDesigner");

      var ids = ABProcessParticipant.propertyIDs(id);

      var ui = {
         id: id,
         rows: [
            { view: "label", label: `${this.type} :` },
            {
               view: "form",
               id: ids.form,
               // width: 300,
               elements: [
                  {
                     id: ids.name,
                     view: "text",
                     label: L("Name"),
                     name: "name",
                     value: this.name,
                  },
                  // { template: "Select Users", type: "section" },
                  // {
                  //     id: id + "_userView",
                  //     cols: [
                  //         {
                  //             view: "checkbox",
                  //             id: ids.useRole,
                  //             labelRight: "by Role",
                  //             value: this.useRole || 0
                  //         },
                  //         {
                  //             id: ids.role,
                  //             view: "select",
                  //             label: "Role",
                  //             value: this.role,
                  //             options: __Roles,
                  //             labelAlign: "left"
                  //         }
                  //     ]
                  // }
                  // {
                  //     margin: 5,
                  //     cols: [
                  //         {
                  //             view: "button",
                  //             value: "Login",
                  //             css: "webix_primary"
                  //         },
                  //         { view: "button", value: "Cancel" }
                  //     ]
                  // }
               ],
            },
         ],
      };

      // If we don't have any sub lanes, then offer the select user options:
      if (this.laneIDs && this.laneIDs.length == 0) {
         var userUI = ABProcessParticipant.selectUsersUi(id, this);
         ui.rows[1].elements.push(userUI);
      }

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * selectUsersUi()
    * A resuable fn to return the webix ui for a reusable Select User picker.
    * @param {ABFactory} AB
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * @param {json} values
    *        the current values represented for this user selection.
    */
   static selectUsersUi(AB, id, values) {
      console.warn("!!! Where is this used???");

      var L = (...params) => {
         return this.AB.Multilingual.label(...params);
      };

      var ids = ABProcessParticipant.propertyIDs(id);
      var __Roles = this.AB.Account.rolesAll();
      var __Users = this.AB.Account.userList();

      __Roles.unshift({ id: "--", value: L("select a role") });
      __Users.unshift({ id: "--", value: L("select a user") });

      return {
         view: "fieldset",
         label: L("Select Users"),
         body: {
            rows: [
               {
                  cols: [
                     {
                        view: "checkbox",
                        id: ids.useRole,
                        labelRight: L("by Role"),
                        labelWidth: 0,
                        width: 120,
                        value: values.useRole ? values.useRole : 0,
                        click: function (id /*, event */) {
                           if ($$(id).getValue()) {
                              $$(ids.role).enable();
                           } else {
                              $$(ids.role).disable();
                           }
                        },
                     },
                     {
                        id: ids.role,
                        view: "select",
                        value: values.role ? values.role : "",
                        disabled: values.useRole ? false : true,
                        options: __Roles,
                        labelAlign: "left",
                     },
                  ],
               },
               {
                  cols: [
                     {
                        view: "checkbox",
                        id: ids.useAccount,
                        labelRight: L("by Account"),
                        labelWidth: 0,
                        width: 120,
                        value: values.useAccount ? values.useAccount : 0,
                        click: function (id /*, event */) {
                           if ($$(id).getValue()) {
                              $$(ids.account).enable();
                           } else {
                              $$(ids.account).disable();
                           }
                        },
                     },
                     {
                        id: ids.account,
                        view: "multicombo",
                        value: values.account ? values.account : 0,
                        disabled: values.useAccount ? false : true,
                        suggest: __Users,
                        labelAlign: "left",
                        placeholder: L("Click or type to add user..."),
                        stringResult: false /* returns data as an array of [id] */,
                     },
                  ],
               },
            ],
         },
      };
   }

   /**
    * selectManagersUi()
    * A resuable fn to return the webix ui for a reusable Select Managers picker.
    * This UI is used in the ABDesigner New Application form.
    * @param {ABFactory} AB
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * @param {jsonobj} obj
    *        the default values for these fields.
    */

   /*
    * Moving this to ABDesigner/src/rootPages/Designer/forms/process
    */
   // static selectManagersUi(AB, id, obj) {
   //    var L = (...params) => {
   //       return AB.Multilingual.label(...params);
   //    };

   //    var ids = ABProcessParticipant.propertyIDs(id);
   //    var __Roles = AB.Account.rolesAll().map((r) => {
   //       return { id: r.id, value: r.name };
   //    });
   //    var __Users = AB.Account.userList().map((u) => {
   //       return { id: u.uuid, value: u.username };
   //    });

   //    return {
   //       type: "form",
   //       css: "no-margin",
   //       rows: [
   //          {
   //             cols: [
   //                {
   //                   view: "checkbox",
   //                   id: ids.useRole,
   //                   labelRight: L("by Role"),
   //                   labelWidth: 0,
   //                   width: 120,
   //                   value: obj.useRole == "1" ? 1 : 0,
   //                   click: function (id /*, event */) {
   //                      if ($$(id).getValue()) {
   //                         $$(ids.role).enable();
   //                      } else {
   //                         $$(ids.role).disable();
   //                      }
   //                   },
   //                },
   //                {
   //                   id: ids.role,
   //                   view: "multicombo",
   //                   value: obj.role ? obj.role : 0,
   //                   disabled: obj.useRole == "1" ? false : true,
   //                   suggest: __Roles,
   //                   placeholder: L("Click or type to add role..."),
   //                   labelAlign: "left",
   //                   stringResult: false /* returns data as an array of [id] */,
   //                },
   //             ],
   //          },
   //          {
   //             cols: [
   //                {
   //                   view: "checkbox",
   //                   id: ids.useAccount,
   //                   labelRight: L("by Account"),
   //                   labelWidth: 0,
   //                   width: 120,
   //                   value: obj.useAccount == "1" ? 1 : 0,
   //                   click: function (id /*, event */) {
   //                      if ($$(id).getValue()) {
   //                         $$(ids.account).enable();
   //                      } else {
   //                         $$(ids.account).disable();
   //                      }
   //                   },
   //                },
   //                {
   //                   id: ids.account,
   //                   view: "multicombo",
   //                   value: obj.account ? obj.account : 0,
   //                   disabled: obj.useAccount == "1" ? false : true,
   //                   suggest: __Users,
   //                   labelAlign: "left",
   //                   placeholder: L("Click or type to add user..."),
   //                   stringResult: false /* returns data as an array of [id] */,
   //                },
   //             ],
   //          },
   //       ],
   //    };
   // }

   /**
    * stashUsersUi()
    * A resuable fn to return the values from our static selectUsersUI().
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   /*
    * Moving this to ABDesigner/src/rootPages/Designer/forms/process
    */
   // static stashUsersUi(id) {
   //    var obj = {};
   //    var ids = ABProcessParticipant.propertyIDs(id);

   //    if ($$(ids.useRole)) {
   //       obj.useRole = $$(ids.useRole).getValue();
   //    }

   //    if ($$(ids.role) && obj.useRole) {
   //       obj.role = $$(ids.role).getValue();
   //       if (obj.role === "--") obj.role = null;
   //    } else {
   //       obj.role = null;
   //    }

   //    if ($$(ids.useAccount)) {
   //       obj.useAccount = $$(ids.useAccount).getValue();
   //    }

   //    if ($$(ids.account) && obj.useAccount) {
   //       obj.account = $$(ids.account).getValue(/*{ options: true }*/);
   //       if (obj.account === "--") obj.account = null;
   //    } else {
   //       obj.account = null;
   //    }

   //    return obj;
   // }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = ABProcessParticipant.propertyIDs(id);
      this.name = $$(ids.name).getValue();
      if (this.laneIDs.length == 0) {
         var userDef = ABProcessParticipant.stashUsersUi(id);
         Object.keys(userDef).forEach((k) => {
            this[k] = userDef[k];
         });
      }
      this.stashed = true;
   }
};


/***/ }),

/***/ 21073:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessElement.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElementCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessElementCore.js */ 19929);

module.exports = class ABProcessElement extends ABProcessElementCore {
   // constructor(attributes, process, AB, defaultValues) {
   //    super(attributes, process, AB, defaultValues);

   //    // listen
   // }

   /**
    * @method destroy()
    * remove this task definition.
    * @return {Promise}
    */
   destroy() {
      ////
      //// TODO: once our core conversion is complete, this .save() can be
      //// moved to ABProcessTaskCore, and our ABDefinition.save() can take
      //// care of the proper method to save depending on the current Platform.
      ////
      // return this.toDefinition()
      //     .destroy()

      return super.destroy().then(() => {
         return this.process.elementRemove(this);
      });
   }

   isValid() {
      /*
        var validator = OP.Validation.validator();

        // label/name must be unique:
        var isNameUnique =
            this.AB.processes((o) => {
                return o.name.toLowerCase() == this.name.toLowerCase();
            }).length == 0;
        if (!isNameUnique) {
            validator.addError(
                "name",
                L(
                    "ab.validation.object.name.unique",
                    `Process name must be unique ("${this.name}"" already used in this Application)`
                )
            );
        }

        return validator;
        */

      // var isValid =
      //     this.AB.processes((o) => {
      //         return o.name.toLowerCase() == this.name.toLowerCase();
      //     }).length == 0;
      // return isValid;

      return true;
   }

   ////
   //// Modeler Instance Methods
   ////

   findLane(curr, cb) {
      if (!curr) {
         cb(null, null);
         return;
      }

      // if current object has a LANE definition, use that one:
      if (curr.lanes && curr.lanes.length > 0) {
         cb(null, curr.lanes[0]);
      } else if (curr.$type == "bpmn:Participant") {
         // if the current is a Participant, take that one
         cb(null, curr);
      } else {
         // else move upwards and check again:
         curr = curr.$parent;
         this.findLane(curr, cb);
      }
   }

   setLane(Lane) {
      this.laneDiagramID = Lane.diagramID;
   }

   /**
    * fromElement()
    * initialize this Task's values from the given BPMN:Element
    * @param {BPMNElement}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Task_08j07ni",
                "width": 100,
                "height": 80,
                "type": "bpmn:SendTask",
                "x": 20,
                "y": -2130,
                "order": {
                    "level": 5
                },
                "businessObject": {
                    "$type": "bpmn:SendTask",
                    "id": "Task_08j07ni",
                    "name": "ffff",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": 20,
                            "y": -2130,
                            "width": 100,
                            "height": 80
                        },
                        "id": "SendTask_0iidv6o_di"
                    }

                    // Some elements (like EndEvents) have:
                    .eventDefinitions: [
                        {
                            $type: "actual bpmn:ElementType",
                            ...
                        }
                    ]
                },
                "incoming":[],
                "outgoing":[]
            }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // our lane may have changed:
      var currObj = defElement.businessObject;
      this.findLane(currObj, (err, obj) => {
         if (obj) {
            this.laneDiagramID = obj.id;
         } else {
            // if my parent shape is a Participant, then use that:
            if (
               defElement.parent &&
               defElement.parent.type == "bpmn:Participant"
            ) {
               this.laneDiagramID = defElement.parent.id;
            } else {
               this.laneDiagramID = null;
            }
         }
      });
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ui = {
         id: id,
         view: "label",
         label: "this task has not implement properties yet...",
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {}

   /**
    * property()
    * return the specific property value if it exists.
    * @return {mixed} | undefined
    */
   property(id) {
      if ($$(id)) {
         return $$(id).getValue();
      }
   }

   /**
    * switchTo()
    * replace this object with an instance of one of our child classes:
    * @param {ABProcessTask*} child
    *        an instance of the new Process Task we are replaced with.
    * @param {string} propertiesID
    *        the webix ui.id container for the properties panel.
    */
   switchTo(child, propertiesID) {
      // remove myself from our containing process's elements
      this.process.elementRemove(this);

      // add the new Process WITH the same id
      this.process.elementAdd(child);

      // show the child properties:
      child.propertiesShow(propertiesID);

      this.emit("switchTo", child);
   }
};


/***/ }),

/***/ 88556:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessEnd.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessEndCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessEndCore.js */ 15197);

module.exports = class ABProcessEnd extends ABProcessEndCore {
   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }
};


/***/ }),

/***/ 19036:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessGatewayExclusive.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessGatewayExclusiveCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessGatewayExclusiveCore.js */ 32889);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessGatewayExclusive extends (
   ABProcessGatewayExclusiveCore
) {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id, App) {
      var ids = this.propertyIDs(id);

      var ui = {
         id: id,
         view: "form",
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
         ],
      };

      // here is how we can find out what possible process data
      // fields are available to this task:
      //   returns an [{ key:'{uuid}', label:"" field:{ABDataField} }, {}, ...]
      var listDataFields = this.process.processDataFields(this);
      var abFields = (listDataFields || []).map((f) => {
         return f.field;
      });

      var myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );

      this.__dfLookup = {};
      this.conditions = this.conditions || {};
      myOutgoingConnections.forEach((conn) => {
         var condition = this.conditions[conn.id] || {};

         var connectedElement = this.process.elementForDiagramID(conn.to);

         var DF = this.AB.filterComplexNew(`${id}_${conn.id}_filter`);
         // DF.applicationLoad(this.application);
         DF.fieldsLoad(abFields);
         this.__dfLookup[conn.id] = DF;

         var connUI = {
            view: "fieldset",
            label: L("to {0}", [
               connectedElement
                  ? connectedElement.name
                  : L("unlabeled Task({0})", [conn.id]),
            ]),
            body: {
               rows: [
                  {
                     id: `${id}_${conn.id}_label`,
                     view: "text",
                     label: L("Label"),
                     value: condition.label || "",
                  },
                  DF.ui,
               ],
            },
         };

         ui.elements.push(connUI);
      });

      // DF.setValue(CurrentQuery.where);

      webix.ui(ui, $$(id));

      $$(id).show();

      // update the filters after they have been .show()n
      myOutgoingConnections.forEach((conn) => {
         var condition = this.conditions[conn.id] || {};
         var DF = this.__dfLookup[conn.id];
         if (condition.filterValue) {
            DF.setValue(condition.filterValue);
         }
      });
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.conditions = {};

      var myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      myOutgoingConnections.forEach((conn) => {
         this.conditions[conn.id] = {};
         this.conditions[conn.id].label = this.property(
            `${id}_${conn.id}_label`
         );
         if (this.__dfLookup && this.__dfLookup[conn.id]) {
            var DF = this.__dfLookup[conn.id];
            this.conditions[conn.id].filterValue = DF.getValue();
         }
      });
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      // the first entry is for the gateway element itself
      var properties = [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];

      // now add any additional updates for each of our connections:
      var myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      myOutgoingConnections.forEach((conn) => {
         properties.push({
            id: conn.id,
            def: {
               name: this.conditions[conn.id].label,
            },
         });
      });
      return properties;
   }
};


/***/ }),

/***/ 18872:
/*!*****************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskEmail.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskEmailCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskEmailCore.js */ 52399);
const ABProcessParticipant = __webpack_require__(/*! ../ABProcessParticipant.js */ 67692);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTaskEmail extends ABProcessTaskEmailCore {
   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   // initState(context, val) {
   //     var myDefaults = {
   //         to: "0",
   //         from: "0",
   //         subject: "",
   //         message: "",
   //         fromUsers: {},
   //         toUsers: {},
   //         toCustom: "",
   //         fromCustom: ""
   //     };

   //     super.initState(context, myDefaults, val);
   // }

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         to: `${id}_to`,
         from: `${id}_from`,
         subject: `${id}_subject`,
         fromUser: `${id}_from_user`,
         toUser: `${id}_to_user`,
         message: `${id}_message`,
         toCustom: `${id}_to_custom`,
         fromCustom: `${id}_from_custom`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var toUserUI = ABProcessParticipant.selectUsersUi(
         id + "_to_",
         this.toUsers || {}
      );
      var fromUserUI = ABProcessParticipant.selectUsersUi(
         id + "_from_",
         this.fromUsers || {}
      );

      var ui = {
         id: id,
         view: "form",
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.to,
               view: "select",
               label: L("To"),
               name: "to",
               value: this.to,
               options: [
                  {
                     id: 0,
                     value: L("Next Participant"),
                  },
                  {
                     id: 1,
                     value: L("Select Role or User"),
                  },
                  {
                     id: 2,
                     value: L("Custom"),
                  },
               ],
               on: {
                  onChange: (val) => {
                     if (parseInt(val) == 1) {
                        $$(ids.toUser).show();
                        $$(ids.toCustom).hide();
                     } else if (parseInt(val) == 2) {
                        $$(ids.toUser).hide();
                        $$(ids.toCustom).show();
                     } else {
                        $$(ids.toUser).hide();
                        $$(ids.toCustom).hide();
                     }
                  },
               },
            },
            {
               id: ids.toUser,
               rows: [toUserUI],
               paddingY: 10,
               hidden: parseInt(this.to) == 1 ? false : true,
            },
            {
               id: ids.toCustom,
               view: "text",
               label: L("Email"),
               placeholder: L("Type email address here..."),
               name: "toCustom",
               value: this.toCustom,
               hidden: parseInt(this.to) == 2 ? false : true,
            },
            {
               id: ids.from,
               view: "select",
               label: L("From"),
               name: "from",
               value: this.from,
               options: [
                  {
                     id: 0,
                     value: L("Current Participant"),
                  },
                  {
                     id: 1,
                     value: L("Select Role or User"),
                  },
                  {
                     id: 2,
                     value: L("Custom"),
                  },
               ],
               on: {
                  onChange: (val) => {
                     if (parseInt(val) == 1) {
                        $$(ids.fromUser).show();
                        $$(ids.fromCustom).hide();
                     } else if (parseInt(val) == 2) {
                        $$(ids.fromUser).hide();
                        $$(ids.fromCustom).show();
                     } else {
                        $$(ids.fromUser).hide();
                        $$(ids.fromCustom).hide();
                     }
                  },
               },
            },
            {
               id: ids.fromUser,
               rows: [fromUserUI],
               paddingY: 10,
               hidden: parseInt(this.from) == 1 ? false : true,
            },
            {
               id: ids.fromCustom,
               view: "text",
               label: L("Email"),
               placeholder: L("Type email address here..."),
               name: "fromCustom",
               value: this.fromCustom,
               hidden: parseInt(this.from) == 2 ? false : true,
            },
            {
               id: ids.subject,
               view: "text",
               label: L("Subject"),
               name: "subject",
               value: this.subject,
            },
            {
               view: "spacer",
               height: 10,
            },
            {
               id: ids.message,
               view: "tinymce-editor",
               label: L("Message"),
               name: "message",
               value: this.message,
               borderless: true,
               minHeight: 500,
               config: {
                  plugins: [
                     "advlist autolink lists link image charmap print preview anchor",
                     "searchreplace visualblocks code fullscreen",
                     "insertdatetime media table contextmenu paste imagetools wordcount",
                  ],
                  toolbar:
                     "insertfile undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image",
                  init_instance_callback: (editor) => {
                     editor.on("KeyUp", (event) => {
                        // _logic.onChange();
                     });

                     editor.on("Change", function (event) {
                        // _logic.onChange();
                     });
                  },
               },
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.to = this.property(ids.to);
      this.from = this.property(ids.from);
      this.subject = this.property(ids.subject);
      this.message = this.property(ids.message);
      this.toCustom = this.property(ids.toCustom);
      this.fromCustom = this.property(ids.fromCustom);
      this.toUsers = ABProcessParticipant.stashUsersUi(id + "_to_");
      this.fromUsers = ABProcessParticipant.stashUsersUi(id + "_from_");
   }
};


/***/ }),

/***/ 95187:
/*!*******************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskService.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskServiceCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCore.js */ 69376);

module.exports = class ABProcessTaskService extends ABProcessTaskServiceCore {};


/***/ }),

/***/ 92845:
/*!********************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingBatchProcessingCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js */ 7912);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingBatchProcessing extends (
   AccountingBatchProcessingCore
) {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         fieldBatchEntries: `${id}_fieldBatchEntries`,
         fieldBatchFinancialPeriod: `${id}_fieldBatchFinancialPeriod`,
         objectJE: `${id}_objectJE`,
         fieldJEAccount: `${id}_fieldJEAccount`,
         fieldJERC: `${id}_fieldJERC`,
         fieldJEStatus: `${id}_fieldJEStatus`,
         fieldJEStatusComplete: `${id}_fieldJEStatusComplete`,
         objectBR: `${id}_objectBR`,
         fieldBRFinancialPeriod: `${id}_fieldBRFinancialPeriod`,
         fieldBRAccount: `${id}_fieldBRAccount`,
         fieldBRRC: `${id}_fieldBRRC`,
         fieldBREntries: `${id}_fieldBREntries`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      //
      // set up field settings:
      //

      var blankField = {
         id: 0,
         value: L("Select a Field"),
      };
      // blankField : generic Select a field entry

      function defaultFields(objID) {
         // create a new options array of Field Choices for the given obj.id

         var fields = [blankField];
         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      }

      function updateFields(fieldPickers, fieldValues, defaultValue) {
         // update the list of field select choices with the new field choices

         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               // if (defaultValue) {
               //    picker.define("value", defaultValue);
               // } else {
               //    picker.define("value", fieldValues[0].value);
               // }
               picker.refresh();
               picker.show();
            }
         });
      }

      var batchFields = defaultFields(this.objectBatch);
      // batchFields : the default list of fields for the Batch Object

      var fieldPickersBatch = [
         ids.fieldBatchEntries,
         ids.fieldBatchFinancialPeriod,
      ];
      // fieldPickersBatch : the list of field selects to update for the Batch
      //      object.

      var jeFields = defaultFields(this.objectJE);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersJE = [
         ids.fieldJEAccount,
         ids.fieldJERC,
         ids.fieldJEStatus,
      ];
      // fieldPickersJE : the list of field selects to update for the Journal Entry
      //      object.

      function compileStatusValues(statusField) {
         var values = [{ id: 0, value: L("Select the Complete Value") }];
         if (statusField && statusField.options) {
            statusField.options().forEach((o) => {
               values.push({ id: o.id, value: o.text });
            });
         }
         return values;
      }

      function updatePickerStatusComplete(values) {
         var wbxComplete = $$(ids.fieldJEStatusComplete);
         if (wbxComplete) {
            // update fieldJEStatusComplete options
            wbxComplete.define("options", values);
            wbxComplete.refresh();
            // show fieldJEStatusComplete
            wbxComplete.show();
         }
      }

      function onStatusComplete(newVal) {
         // pull the ABField object from newValue
         var jeEntryID = $$(ids.objectJE).getValue();
         var jeEntry = objectList.find((o) => o.id == jeEntryID);
         if (jeEntry && jeEntry.object) {
            var statusField = jeEntry.object.fieldByID(newVal);
            if (statusField && statusField.options) {
               // get the options as an []
               jeFieldStatusValues = compileStatusValues(statusField);

               updatePickerStatusComplete(jeFieldStatusValues);
            }
         }
      }

      var jeFieldStatusValues = compileStatusValues();
      // jeFieldStatusValues : the list of status options from the fieldJEStatus
      //      selected entry.

      var brFields = defaultFields(this.objectBR);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersBR = [
         ids.fieldBRFinancialPeriod,
         ids.fieldBRAccount,
         ids.fieldBRRC,
         ids.fieldBREntries,
      ];
      // fieldPickersBR : the list of field selects to update for the Balance Record
      //      object.

      var ui = {
         id: id,
         view: "form",
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        batchFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBatch, batchFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBatchEntries,
               view: "select",
               label: L("Batch->JE[]"),
               value: this.fieldBatchEntries,
               name: "fieldBatchEntries",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.fieldBatchFinancialPeriod,
               view: "select",
               label: L("Batch->FinancialPeriod"),
               value: this.fieldBatchFinancialPeriod,
               name: "fieldBatchFinancialPeriod",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("Journal Entry Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        jeFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersJE, jeFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEAccount,
               view: "select",
               label: L("JE->Account"),
               value: this.fieldJEAccount,
               name: "fieldJEAccount",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJERC,
               view: "select",
               label: L("JE->RC"),
               value: this.fieldJERC,
               name: "fieldJERC",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJEStatus,
               view: "select",
               label: L("JE->Status"),
               value: this.fieldJEStatus,
               name: "fieldJEStatus",
               options: jeFields,
               hidden: true,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        onStatusComplete(newVal);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEStatusComplete,
               view: "select",
               label: L("JE->Status->Complete"),
               value: this.fieldJEStatusComplete,
               name: "fieldJEStatusComplete",
               options: jeFieldStatusValues,
               hidden: true,
            },
            {
               id: ids.objectBR,
               view: "select",
               label: L("Balance Record"),
               value: this.objectBR,
               name: "objectBR",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        brFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBR, brFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBRFinancialPeriod,
               view: "select",
               label: L("BR->FP"),
               value: this.fieldBRFinancialPeriod,
               name: "fieldBRFinancialPeriod",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRAccount,
               view: "select",
               label: L("BR->Account"),
               value: this.fieldBRAccount,
               name: "fieldBRAccount",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRRC,
               view: "select",
               label: L("BR->RC"),
               value: this.fieldBRRC,
               name: "fieldBRRC",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBREntries,
               view: "select",
               label: L("BR->Entries"),
               value: this.fieldBREntries,
               name: "fieldBREntries",
               options: brFields,
               hidden: true,
            },
         ],
      };

      webix.ui(ui, $$(id));

      // if there are already default values for our Objects,
      // unhide the field selectors:
      if (this.objectBatch && this.objectBatch != 0) {
         updateFields(fieldPickersBatch, batchFields);
      }

      if (this.objectJE && this.objectJE != 0) {
         updateFields(fieldPickersJE, jeFields);
      }

      if (this.fieldJEStatus) {
         onStatusComplete(this.fieldJEStatus);
      }

      if (this.objectBR && this.objectBR != 0) {
         updateFields(fieldPickersBR, brFields);
      }

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 80346:
/*!************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPClose.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingFPCloseCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js */ 20939);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingFPClose extends AccountingFPCloseCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPValue: `${id}_processFPValue`,
         objectFP: `${id}_objectFP`,
         objectGL: `${id}_objectGL`,
         objectAcc: `${id}_objectAcc`,
         fieldFPStart: `${id}_fieldFPStart`,
         fieldFPOpen: `${id}_fieldFPOpen`,
         fieldFPStatus: `${id}_fieldFPStatus`,
         fieldFPActive: `${id}_fieldFPActive`,
         fieldGLStarting: `${id}_fieldGLStarting`,
         fieldGLRunning: `${id}_fieldGLRunning`,
         fieldGLAccount: `${id}_fieldGLAccount`,
         fieldGLRc: `${id}_fieldGLRc`,
         fieldGLDebit: `${id}fieldGLDebit`,
         fieldGLCredit: `${id}_fieldGLCredit`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccAsset: `${id}_fieldAccAsset`,
         fieldAccExpense: `${id}_fieldAccExpense`,
         fieldAccLiabilities: `${id}_fieldAccLiabilities`,
         fieldAccEquity: `${id}_fieldAccEquity`,
         fieldAccIncome: `${id}_fieldAccIncome`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      };

      let getStatusFieldOptions = (statusFieldId) => {
         let result = [];
         let fpObject = this.AB.objectByID(this.objectFP);
         if (!fpObject) return result;

         let fpStatusField = fpObject.fieldByID(statusFieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateFPFields = (fpFields) => {
         [ids.fieldFPStart, ids.fieldFPOpen, ids.fieldFPStatus].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", fpFields);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateFPStatusFields = (fpStatusOptions) => {
         $$(ids.fieldFPActive).define("options", fpStatusOptions);
         $$(ids.fieldFPActive).refresh();
      };

      let updateGLFields = (glFields) => {
         [
            ids.fieldGLRunning,
            ids.fieldGLAccount,
            ids.fieldGLRc,
            ids.fieldGLDebit,
            ids.fieldGLCredit,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", glFields);
            $$(fieldGLElem).refresh();
         });
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccAsset,
            ids.fieldAccExpense,
            ids.fieldAccLiabilities,
            ids.fieldAccEquity,
            ids.fieldAccIncome,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let fpFields = getFieldOptions(this.objectFP);
      let glFields = getFieldOptions(this.objectGL);
      let accFields = getFieldOptions(this.objectAcc);
      let fpStatusFields = getStatusFieldOptions(this.fieldFPStatus);
      let accTypeOptions = getListOptions(this.objectAcc, this.fieldAccType);

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPValue,
               view: "select",
               label: L("Process Fiscal Period Value"),
               value: this.processFPValue,
               name: "processFPValue",
               options: processValues,
            },
            {
               id: ids.objectFP,
               view: "select",
               label: L("FP Object"),
               value: this.objectFP,
               name: "objectFP",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        fpFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFPFields(fpFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("GL Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        glFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateGLFields(glFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAcc,
               view: "select",
               label: L("Account Object"),
               value: this.objectAcc,
               name: "objectAcc",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        accFields = getFieldOptions(newVal);
                        updateAccFields(accFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPStart,
               view: "select",
               label: L("FP -> Start"),
               value: this.fieldFPStart,
               name: "fieldFPStart",
               options: fpFields,
            },
            {
               id: ids.fieldFPOpen,
               view: "select",
               label: L("FP -> Open"),
               value: this.fieldFPOpen,
               name: "fieldFPOpen",
               options: fpFields,
            },
            {
               id: ids.fieldFPStatus,
               view: "select",
               label: L("FP -> Status"),
               value: this.fieldFPStatus,
               name: "fieldFPStatus",
               options: fpFields,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        fpStatusFields = getStatusFieldOptions(newVal);
                        updateFPStatusFields(fpStatusFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPActive,
               view: "select",
               label: L("FP -> Active"),
               value: this.fieldFPActive,
               name: "fieldFPActive",
               options: fpStatusFields,
            },
            {
               id: ids.fieldGLStarting,
               view: "select",
               label: L("GL -> Starting BL"),
               value: this.fieldGLStarting,
               name: "fieldGLStarting",
               options: glFields,
            },
            {
               id: ids.fieldGLRunning,
               view: "select",
               label: L("GL -> Running BL"),
               value: this.fieldGLRunning,
               name: "fieldGLRunning",
               options: glFields,
            },
            {
               id: ids.fieldGLAccount,
               view: "select",
               label: L("GL -> Account"),
               value: this.fieldGLAccount,
               name: "fieldGLAccount",
               options: glFields,
            },
            {
               id: ids.fieldGLRc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLRc,
               name: "fieldGLRc",
               options: glFields,
            },
            {
               id: ids.fieldGLDebit,
               view: "select",
               label: L("GL -> Debit"),
               value: this.fieldGLDebit,
               name: "fieldGLDebit",
               options: glFields,
            },
            {
               id: ids.fieldGLCredit,
               view: "select",
               label: L("GL -> Credit"),
               value: this.fieldGLCredit,
               name: "fieldGLCredit",
               options: glFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAcc || $$(ids.objectAcc).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccAsset,
               view: "select",
               label: L("Acc -> Asset"),
               value: this.fieldAccAsset,
               name: "fieldAccAsset",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccExpense,
               name: "fieldAccExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccLiabilities,
               view: "select",
               label: L("Acc -> Liabilities"),
               value: this.fieldAccLiabilities,
               name: "fieldAccLiabilities",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccEquity,
               name: "fieldAccEquity",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccIncome,
               name: "fieldAccIncome",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 33618:
/*!****************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingFPYearCloseCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js */ 31166);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingFPYearClose extends AccountingFPYearCloseCore {
   ////
   //// Process Instance Methods
   ////
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPYearValue: `${id}_processFPYearValue`,
         objectFPYear: `${id}_objectFPYear`,
         objectFPMonth: `${id}_objectFPMonth`,
         objectGL: `${id}_objectGL`,
         objectAccount: `${id}_objectAccount`,
         valueFundBalances: `${id}_valueFundBalances`,
         valueNetIncome: `${id}_valueNetIncome`,
         fieldFPYearStart: `${id}_fieldFPYearStart`,
         fieldFPYearEnd: `${id}_fieldFPYearEnd`,
         fieldFPYearStatus: `${id}_fieldFPYearStatus`,
         fieldFPYearActive: `${id}_fieldFPYearActive`,
         fieldFPMonthStart: `${id}_fieldFPMonthStart`,
         fieldFPMonthEnd: `${id}_fieldFPMonthEnd`,
         fieldGLStartBalance: `${id}_fieldGLStartBalance`,
         fieldGLRunningBalance: `${id}_fieldGLRunningBalance`,
         fieldGLrc: `${id}_fieldGLrc`,
         fieldAccNumber: `${id}_fieldAccNumber`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccTypeIncome: `${id}_fieldAccTypeIncome`,
         fieldAccTypeExpense: `${id}_fieldAccTypeExpense`,
         fieldAccTypeEquity: `${id}_fieldAccTypeEquity`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID, fieldKey) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object
                  .fields((f) => f.key == fieldKey)
                  .forEach((f) => {
                     fields.push({ id: f.id, value: f.label, field: f });
                  });
            }
         }
         return fields;
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateAccNumberFields = (accNumberFields) => {
         $$(ids.fieldAccNumber).define("options", accNumberFields);
         $$(ids.fieldAccNumber).refresh();
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccTypeIncome,
            ids.fieldAccTypeExpense,
            ids.fieldAccTypeEquity,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearDateOptions = (fpYearDateOptions) => {
         [ids.fieldFPYearStart, ids.fieldFPYearEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpYearDateOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearStatusOptions = (fpYearStatusFields) => {
         $$(ids.fieldFPYearStatus).define("options", fpYearStatusFields);
         $$(ids.fieldFPYearStatus).refresh();
      };

      let updateFPYearActiveOptions = (fpYearStatusOptions) => {
         $$(ids.fieldFPYearActive).define("options", fpYearStatusOptions);
         $$(ids.fieldFPYearActive).refresh();
      };

      let updateFPMonthDateFields = (fpMonthDateOpts) => {
         [ids.fieldFPMonthStart, ids.fieldFPMonthEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpMonthDateOpts);
            $$(fieldGLElem).refresh();
         });
      };

      let updateGlNumberFields = (glNumberOptions) => {
         [ids.fieldGLStartBalance, ids.fieldGLRunningBalance].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", glNumberOptions);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateGlConnectFields = (glRcOptions) => {
         $$(ids.fieldGLrc).define("options", glRcOptions);
         $$(ids.fieldGLrc).refresh();
      };

      let fpYearDateFields = getFieldOptions(this.objectFPYear, "date");
      let fpYearStatusFields = getFieldOptions(this.objectFPYear, "list");
      let fpYearStatusOptions = getListOptions(
         this.objectFPYear,
         this.fieldFPYearStatus
      );
      let fpMonthDateFields = getFieldOptions(this.objectFPMonth, "date");
      let glNumberFields = getFieldOptions(this.objectGL, "number");
      let glRcFields = getFieldOptions(this.objectGL, "connectObject");
      let accNumberFields = getFieldOptions(this.objectAccount, "number");
      let accTypeFields = getFieldOptions(this.objectAccount, "list");
      let accTypeOptions = getListOptions(
         this.objectAccount,
         this.fieldAccType
      );

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPYearValue,
               view: "select",
               label: L("Process Fiscal Period Year Value"),
               value: this.processFPYearValue,
               name: "processFPYearValue",
               options: processValues,
            },
            {
               id: ids.objectFPYear,
               view: "select",
               label: L("FP Year Object"),
               value: this.objectFPYear,
               name: "objectFPYear",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearDateFields = getFieldOptions(newVal, "date");
                        updateFPYearDateOptions(fpYearDateFields);

                        accTypeFields = getFieldOptions(newVal, "list");
                        updateFPYearStatusOptions(accTypeFields);
                     }
                  },
               },
            },
            {
               id: ids.objectFPMonth,
               view: "select",
               label: L("FP Month Object"),
               value: this.objectFPMonth,
               name: "objectFPMonth",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpMonthDateFields = getFieldOptions(newVal, "date");
                        updateFPMonthDateFields(fpMonthDateFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("Balance Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        glNumberFields = getFieldOptions(newVal, "number");
                        updateGlNumberFields(glNumberFields);

                        glRcFields = getFieldOptions(newVal, "connectObject");
                        updateGlConnectFields(glRcFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAccount,
               view: "select",
               label: L("Account Object"),
               value: this.objectAccount,
               name: "objectAccount",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeFields = getFieldOptions(newVal, "list");
                        updateAccFields(accTypeFields);

                        accNumberFields = getFieldOptions(newVal, "number");
                        updateAccNumberFields(accNumberFields);
                     }
                  },
               },
            },
            {
               id: ids.valueFundBalances,
               view: "text",
               label: L("Fund Balances Code"),
               value: this.valueFundBalances,
               name: "valueFundBalances",
            },
            {
               id: ids.valueNetIncome,
               view: "text",
               label: L("Net Income Code"),
               value: this.valueNetIncome,
               name: "valueNetIncome",
            },
            {
               id: ids.fieldFPYearStart,
               view: "select",
               label: L("FP Year -> Start"),
               value: this.fieldFPYearStart,
               name: "fieldFPYearStart",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearEnd,
               view: "select",
               label: L("FP Year -> End"),
               value: this.fieldFPYearEnd,
               name: "fieldFPYearEnd",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearStatus,
               view: "select",
               label: L("FP Year -> Status"),
               value: this.fieldFPYearStatus,
               name: "fieldFPYearStatus",
               options: fpYearStatusFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearStatusOptions = getListOptions(
                           this.objectFPYear || $$(ids.objectFPYear).getValue(),
                           newVal
                        );
                        updateFPYearActiveOptions(fpYearStatusOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPYearActive,
               view: "select",
               label: L("FP Year -> Active"),
               value: this.fieldFPYearActive,
               name: "fieldFPYearActive",
               options: fpYearStatusOptions,
            },
            {
               id: ids.fieldFPMonthStart,
               view: "select",
               label: L("FP Month -> Start"),
               value: this.fieldFPMonthStart,
               name: "fieldFPMonthStart",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldFPMonthEnd,
               view: "select",
               label: L("FP Month -> End"),
               value: this.fieldFPMonthEnd,
               name: "fieldFPMonthEnd",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldGLStartBalance,
               view: "select",
               label: L("GL -> Start Balance"),
               value: this.fieldGLStartBalance,
               name: "fieldGLStartBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLRunningBalance,
               view: "select",
               label: L("GL -> Running Balance"),
               value: this.fieldGLRunningBalance,
               name: "fieldGLRunningBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLrc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLrc,
               name: "fieldGLrc",
               options: glRcFields,
            },
            {
               id: ids.fieldAccNumber,
               view: "select",
               label: L("Acc -> Account Number"),
               value: this.fieldAccNumber,
               name: "fieldAccNumber",
               options: accNumberFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accTypeFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAccount ||
                              $$(ids.objectAccount).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccTypeIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccTypeIncome,
               name: "fieldAccTypeIncome",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccTypeExpense,
               name: "fieldAccTypeExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccTypeEquity,
               name: "fieldAccTypeEquity",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 79841:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingJEArchive.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingJEArchiveCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js */ 69814);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingJEArchive extends AccountingJEArchiveCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         objectBalance: `${id}_objectBalance`,
         objectJE: `${id}_objectJE`,
         objectJEArchive: `${id}_objectJEArchive`,

         fieldBatchFiscalMonth: `${id}_fieldBatchFiscalMonth`,
         fieldJeAccount: `${id}_fieldJeAccount`,
         fieldJeRC: `${id}_fieldJeRC`,
         fieldJeArchiveBalance: `${id}_fieldJeArchiveBalance`,
         fieldBrFiscalMonth: `${id}_fieldBrFiscalMonth`,
         fieldBrAccount: `${id}_fieldBrAccount`,
         fieldBrRC: `${id}_fieldBrRC`,

         fieldsMatch: `${id}_fieldsMatch`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      let processValues = [{ id: 0, value: L("Select a Process Value") }];
      let processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      let objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });

      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getConnectFieldOptions = (objectId) => {
         let object = this.AB.objectByID(objectId);
         if (!object) return [];

         let options = object
            .fields((f) => f.isConnection)
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });

         options.unshift({
            id: 0,
            value: L("Select a Field"),
         });

         return options;
      };

      let updateFields = (fieldPickers, fieldValues) => {
         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               picker.refresh();
               picker.show();
            }
         });
      };

      let refreshBatchFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldBatchFiscalMonth], options);
      };

      let refreshBRFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields(
            [ids.fieldBrAccount, ids.fieldBrFiscalMonth, ids.fieldBrRC],
            options
         );
      };

      let refreshJeFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeAccount, ids.fieldJeRC], options);
      };

      let refreshJeArchiveFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeArchiveBalance], options);
      };

      let refreshFieldsMatch = () => {
         let $fieldsMatch = $$(ids.fieldsMatch);
         if (!$fieldsMatch) return;

         // clear form
         webix.ui([], $fieldsMatch);

         let JEObj = this.AB.objectByID(this.objectJE);
         if (!JEObj) return;

         let JEArchiveObj = this.AB.objectByID(this.objectJEArchive);
         if (!JEArchiveObj) return;

         // create JE acrhive field options to the form
         JEArchiveObj.fields().forEach((f) => {
            let jeFields = [];

            if (f.isConnection) {
               jeFields = JEObj.fields((fJe) => {
                  return (
                     fJe.isConnection &&
                     fJe.settings &&
                     f.settings &&
                     fJe.settings.linkObject == f.settings.linkObject &&
                     fJe.settings.linkType == f.settings.linkType &&
                     fJe.settings.linkViaType == f.settings.linkViaType &&
                     fJe.settings.isCustomFK == f.settings.isCustomFK
                  );
               });
            } else {
               jeFields = JEObj.fields((fJe) => fJe.key == f.key);
            }

            jeFields = jeFields.map((fJe) => {
               return {
                  id: fJe.id,
                  value: fJe.label,
               };
            });

            $fieldsMatch.addView({
               view: "select",
               name: f.id,
               label: f.label,
               options: jeFields,
            });
         });

         $fieldsMatch.setValues(this.fieldsMatch || {});
      };

      let fieldBatchList = getConnectFieldOptions(this.objectBatch);
      let fieldBalanceList = getConnectFieldOptions(this.objectBalance);
      let fieldJeList = getConnectFieldOptions(this.objectJE);
      let fieldJeArchiveList = getConnectFieldOptions(this.objectJEArchive);

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 180,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBatch = newVal;
                     refreshBatchFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBatchFiscalMonth,
               view: "select",
               label: L("Batch -> Fiscal Month"),
               value: this.fieldBatchFiscalMonth,
               name: "fieldBatchFiscalMonth",
               options: fieldBatchList,
            },
            {
               id: ids.objectBalance,
               view: "select",
               label: L("BR Object"),
               value: this.objectBalance,
               name: "objectBalance",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBalance = newVal;
                     refreshBRFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBrFiscalMonth,
               view: "select",
               label: L("BR -> Fiscal Month"),
               value: this.fieldBrFiscalMonth,
               name: "fieldBrFiscalMonth",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrAccount,
               view: "select",
               label: L("BR -> Account"),
               value: this.fieldBrAccount,
               name: "fieldBrAccount",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrRC,
               view: "select",
               label: L("BR -> RC"),
               value: this.fieldBrRC,
               name: "fieldBrRC",
               options: fieldBalanceList,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("JE Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJE = newVal;
                     refreshJeFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeAccount,
               view: "select",
               label: L("JE -> Account"),
               value: this.fieldJeAccount,
               name: "fieldJeAccount",
               options: fieldJeList,
            },
            {
               id: ids.fieldJeRC,
               view: "select",
               label: L("JE -> RC"),
               value: this.fieldJeRC,
               name: "fieldJeRC",
               options: fieldJeList,
            },
            {
               id: ids.objectJEArchive,
               view: "select",
               label: L("JE Archive Object"),
               value: this.objectJEArchive,
               name: "objectJEArchive",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJEArchive = newVal;
                     refreshJeArchiveFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeArchiveBalance,
               view: "select",
               label: L("JE Archive -> BR"),
               value: this.fieldJeArchiveBalance,
               name: "fieldJeArchiveBalance",
               options: fieldJeArchiveList,
            },
            {
               view: "fieldset",
               label: "Fields Matching",
               body: {
                  id: ids.fieldsMatch,
                  view: "form",
                  borderless: true,
                  elements: [],
               },
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();

      refreshFieldsMatch();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         if (s === "fieldsMatch") {
            this[s] = $$(ids.fieldsMatch).getValues();
         } else {
            this[s] = this.property(ids[s]);
         }
      });
   }
};


/***/ }),

/***/ 26088:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceCalculate.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CalculateTaskCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCalculateCore.js */ 50689);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class CalculateTask extends CalculateTaskCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         formulaText: `${id}_formulaText`,

         variablePopup: `${id}_variablePopup`,
         operatorPopup: `${id}_operatorPopup`,
      };
   }

   /**
    * @method propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      let list = (this.process.processDataFields(this) || []).map((item) => {
         return {
            id: item.key,
            value: item.label,
         };
      });

      let labelWidth = 120;
      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: labelWidth,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.formulaText,
               view: "texthighlight",
               height: 200,
               label: L("Formula"),
               type: "textarea",
               value: this.formulaText || "",
               highlight: (text) => {
                  list.forEach(function (item) {
                     text = text.replace(
                        new RegExp(`{${item.value}}`, "g"),
                        `<span style='background: #90adb5; color:#000000;'>{${item.value}}</span>`
                     );
                  });
                  return text;
               },
            },
            {
               cols: [
                  {
                     width: labelWidth,
                     fillspace: true,
                  },
                  {
                     view: "button",
                     css: "webix_primary",
                     type: "icon",
                     icon: "fa fa-at",
                     label: L("Parameters"),
                     click: function () {
                        // show popup
                        $$(ids.variablePopup).show(this.$view);
                     },
                  },
                  {
                     view: "button",
                     css: "webix_primary",
                     type: "icon",
                     icon: "fa fa-hashtag",
                     label: L("Operators"),
                     click: function () {
                        // show popup
                        $$(ids.operatorPopup).show(this.$view);
                     },
                  },
               ],
            },
         ],
      };

      webix.ui(ui, $$(id));

      if ($$(ids.variablePopup) == null) {
         webix.ui({
            id: ids.variablePopup,
            view: "popup",
            hidden: true,
            body: {
               view: "list",
               template: (item) => {
                  return item.value;
               },
               data: list,
               on: {
                  onItemClick: function (id, e, node) {
                     var component = this.getItem(id);

                     insertFormula(`{${component.value}}`);

                     $$(ids.variablePopup).hide();
                  },
               },
            },
         });
      }

      if ($$(ids.operatorPopup) == null) {
         webix.ui({
            id: ids.operatorPopup,
            view: "popup",
            hidden: true,
            width: 180,
            body: {
               view: "list",
               template: (item) => {
                  var template = "";

                  if (item.icon) {
                     template += `<i class="fa fa-${item.icon}" aria-hidden="true"></i> `;
                  }

                  if (item.label) {
                     template += item.label;
                  }

                  return template;
               },
               data: [
                  {
                     label: L("+ Adds"),
                     symbol: "+",
                  },
                  {
                     label: L("- Subtracts"),
                     symbol: "-",
                  },
                  {
                     label: L("* Multiples"),
                     symbol: "*",
                  },
                  {
                     label: L("/ Divides"),
                     symbol: "/",
                  },
                  {
                     label: L("( Open Bracket"),
                     symbol: "(",
                  },
                  {
                     label: L(") Closed Bracket"),
                     symbol: ")",
                  },
               ],
               on: {
                  onItemClick: function (id, e, node) {
                     var component = this.getItem(id);

                     insertFormula(component.symbol);

                     $$(ids.operatorPopup).hide();
                  },
               },
            },
         });
      }

      let insertFormula = (message) => {
         let formula = $$(ids.formulaText).getValue();

         $$(ids.formulaText).setValue(`${formula}${message} `);
      };

      $$(id).show();
   }

   /**
    * @method propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);

      this.name = this.property(ids.name);
      this.formulaText = this.property(ids.formulaText);
   }
};


/***/ }),

/***/ 34430:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskServiceGetResetPasswordUrlCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js */ 98856);

module.exports = class ABProcessTaskServiceGetResetPasswordUrl extends (
   ABProcessTaskServiceGetResetPasswordUrlCore
) {};


/***/ }),

/***/ 87757:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceInsertRecord.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const InsertRecordTaskCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceInsertRecordCore.js */ 24858);

module.exports = class InsertRecordTask extends InsertRecordTaskCore {};


/***/ }),

/***/ 85811:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceQuery.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskServiceQueryCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceQueryCore.js */ 35002);

const ABQLManager = __webpack_require__(/*! ../../ql/ABQLManager.js */ 46370);

module.exports = class ABProcessTaskServiceQuery extends (
   ABProcessTaskServiceQueryCore
) {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);
   }

   ABQLManager() {
      return ABQLManager;
   }
};


/***/ }),

/***/ 86298:
/*!**********************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskSubProcess.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SubProcessCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskSubProcessCore.js */ 36146);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class SubProcess extends SubProcessCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         isEnable: `${id}_isEnable`,
         parameterId: `${id}_parameterId`,
      };
   }

   /**
    * @method propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      // Pull query tasks option list
      let parameterOptions = (this.process.processDataFields(this) || []).map(
         (item) => {
            return {
               id: item.key,
               value: item.label,
            };
         }
      );

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 120,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.isEnable,
               view: "switch",
               label: L("Enable"),
               value: this.isEnable,
            },
            {
               id: ids.parameterId,
               view: "richselect",
               label: L("Repeat for"),
               options: parameterOptions,
               value: this.parameterId,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * @method propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.isEnable = this.property(ids.isEnable);
      this.parameterId = this.property(ids.parameterId);
   }

   /**
    * @method diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties(bpmnModeler) {
      let props = super.diagramProperties();
      props = props || [{}];
      props[0].def = props[0].def || {};

      if (this.parameterId != null) {
         props[0].def = props[0].def || {};
         props[0].def.loopCharacteristics = bpmnModeler
            .get("moddle")
            .create("bpmn:MultiInstanceLoopCharacteristics");
         props[0].def.loopCharacteristics.isSequential = true;
      }

      return props;
   }

   /**
    * @method onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      let loopCharacteristics =
         defElement.loopCharacteristics ||
         defElement.businessObject.loopCharacteristics ||
         {};

      switch (loopCharacteristics.$type) {
         case "bpmn:MultiInstanceLoopCharacteristics":
            this.loopType = loopCharacteristics.isSequential
               ? "sequential"
               : "parallel";
            break;
         case "bpmn:StandardLoopCharacteristics":
            this.loopType = "looping";
            break;
      }
   }

   /**
    * @method destroy()
    * destroy this sub process and inside tasks
    *
    * @return {Promise}
    */
   destroy() {
      // reuse .destroy function of ABProcess 
      // to clear tasks within this sub process
      return this.process.destroy.call(this);
   }

   /**
    * @method save()
    * persist this sub process
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // reuse .save function of ABProcess 
      // to update tasks within this sub process
      return this.process.save.call(this);
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcessParticipant|ABProcessLane|ABProcessElement}
    * 
    */
   elementNewForModelDefinition(element) {
      let task = this.application.processElementNewForModelDefinition(
         element,
         this
      );

      // Add a new task to this sub process
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }
};


/***/ }),

/***/ 68063:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskUserCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserCore.js */ 96493);

module.exports = class ABProcessTaskUser extends ABProcessTaskUserCore {};


/***/ }),

/***/ 56031:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUserApproval.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskUserApprovalCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserApprovalCore.js */ 42501);

module.exports = class ABProcessTaskUserApproval extends (
   ABProcessTaskUserApprovalCore
) {};


/***/ }),

/***/ 82448:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUserExternal.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskUserExternalCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserExternalCore.js */ 39483);

module.exports = class ABProcessTaskUserExternal extends (
   ABProcessTaskUserExternalCore
) {};


/***/ }),

/***/ 46732:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTrigger.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTriggerCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerCore.js */ 41600);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTrigger extends ABProcessTriggerCore {
   propertyIDs(id) {
      return {
         name: `${id}_name`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var ui = {
         id: id,
         rows: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
   }
};


/***/ }),

/***/ 12513:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTriggerLifecycle.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTriggerLifecycleCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerLifecycleCore.js */ 55364);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTriggerLifecycle extends (
   ABProcessTriggerLifecycleCore
) {
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         objList: `${id}_objlist`,
         lifecycleList: `${id}_lifecycleList`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var allObjects = this.application.objectsIncluded();
      var listObj = [];
      allObjects.forEach((obj) => {
         listObj.push({ id: obj.id, value: obj.label });
      });

      var ui = {
         view: "form",
         id: id,
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.objList,
               view: "select",
               label: L("Object"),
               value: this.objectID,
               options: listObj,
            },
            {
               id: ids.lifecycleList,
               view: "select",
               label: L("lifecycle"),
               value: this.lifecycleKey,
               options: [
                  { id: "added", value: L("after Add") },
                  { id: "updated", value: L("after Update") },
                  { id: "deleted", value: L("after Delete") },
               ],
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.objectID = this.property(ids.objList);
      this.lifecycleKey = this.property(ids.lifecycleList);
      this.triggerKey = `${this.objectID}.${this.lifecycleKey}`;
   }
};


/***/ }),

/***/ 12038:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTriggerTimer.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTriggerTimerCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerTimerCore.js */ 97535);

const START_URL = "/process/timer/#id#/start";
const STOP_URL = "/process/timer/#id#/stop";

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTriggerTimer extends ABProcessTriggerTimerCore {
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         repeatEvery: `${id}_repeatEvery`,
         repeatTime: `${id}_repeatTime`,
         repeatOnPanel: `${id}_repeatOnPanel`,
         repeatDaily: `${id}_repeatDaily`,
         repeatWeekly: `${id}_repeatWeekly`,
         repeatMonthly: `${id}_repeatMonthly`,
         isEnabled: `${id}_isEnabled`,
      };
   }

   /**
    * @function propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);
      let defaultValues = ABProcessTriggerTimer.defaults();

      let dayOptions = [];
      for (let day = 1; day <= 31; day++) {
         dayOptions.push({
            id: day,
            value: day,
         });
      }
      // dayOptions.push({
      //    id: "L",
      //    value: "Last"
      // });

      const LABEL_WIDTH = 120;
      let ui = {
         view: "form",
         id: id,
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               labelWidth: LABEL_WIDTH,
               name: "name",
               value: this.name,
            },
            {
               id: ids.repeatEvery,
               view: "richselect",
               name: "repeatEvery",
               label: L("Repeat every"),
               labelWidth: LABEL_WIDTH,
               value: this.repeatEvery || defaultValues.repeatEvery,
               options: [
                  { id: "daily", value: L("Daily") },
                  {
                     id: "weekly",
                     value: L("Weekly"),
                  },
                  {
                     id: "monthly",
                     value: L("Monthly"),
                  },
               ],
               on: {
                  onChange: (repeatEvery) => {
                     $$(ids.repeatOnPanel).showBatch(repeatEvery);
                  },
               },
            },
            {
               id: ids.repeatTime,
               view: "datepicker",
               name: "repeatTime",
               label: L("Time"),
               labelWidth: LABEL_WIDTH,
               value: this.repeatTime || defaultValues.repeatTime,
               timepicker: true,
               type: "time",
               multiselect: false,
            },
            {
               view: "multiview",
               id: ids.repeatOnPanel,
               cells: [
                  {
                     view: "radio",
                     id: ids.repeatDaily,
                     label: " ",
                     labelWidth: LABEL_WIDTH,
                     batch: "daily",
                     vertical: true,
                     value: this.repeatDaily || defaultValues.repeatDaily,
                     options: [
                        { id: "day", value: L("Day") },
                        { id: "weekday", value: L("Weekday") },
                     ],
                  },
                  {
                     view: "multiselect",
                     id: ids.repeatWeekly,
                     labelWidth: LABEL_WIDTH,
                     label: L("Every week on:"),
                     batch: "weekly",
                     value: this.repeatWeekly || defaultValues.repeatWeekly,
                     options: [
                        {
                           id: "SUN",
                           value: L("Sunday"),
                        },
                        {
                           id: "MON",
                           value: L("Monday"),
                        },
                        {
                           id: "TUE",
                           value: L("Tuesday"),
                        },
                        {
                           id: "WED",
                           value: L("Wednesday"),
                        },
                        {
                           id: "THU",
                           value: L("Thursday"),
                        },
                        {
                           id: "FRI",
                           value: L("Friday"),
                        },
                        {
                           id: "SAT",
                           value: L("Saturday"),
                        },
                     ],
                  },
                  {
                     view: "layout",
                     batch: "monthly",
                     rows: [
                        {
                           id: ids.repeatMonthly,
                           view: "richselect",
                           labelWidth: LABEL_WIDTH,
                           label: L("Monthly on day"),
                           options: dayOptions,
                           value:
                              this.repeatMonthly || defaultValues.repeatMonthly,
                        },
                     ],
                  },
               ],
            },
            {
               id: ids.isEnabled,
               view: "switch",
               label: L("Enable"),
               labelWidth: LABEL_WIDTH,
               value: this.isEnabled,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
      $$(ids.repeatOnPanel).showBatch(
         this.repeatEvery || defaultValues.repeatEvery
      );
   }

   /**
    * @function propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = $$(ids.name).getValue();
      this.repeatEvery = $$(ids.repeatEvery).getValue();
      this.repeatTime = $$(ids.repeatTime).getValue();
      this.repeatDaily = $$(ids.repeatDaily).getValue();
      this.repeatWeekly = $$(ids.repeatWeekly).getValue();
      this.repeatMonthly = $$(ids.repeatMonthly).getValue();
      this.isEnabled = $$(ids.isEnabled).getValue();
      this.triggerKey =
         this.triggerKey == null || this.triggerKey == "triggerKey.??"
            ? `timer.${this.id || this.AB.uuid()}`
            : this.triggerKey;
   }

   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    */
   save() {
      return (
         Promise.resolve()
            .then(() => super.save())
            // Restart the timer
            .then((result) => {
               return this.AB.Network.put({
                  url: (this.isEnabled ? START_URL : STOP_URL).replace(
                     "#id#",
                     this.id
                  ),
               });
            })
      );
   }
};


/***/ }),

/***/ 15430:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ql/ABQL.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */
const ABQLCore = __webpack_require__(/*! ../../core/ql/ABQLCore.js */ 52983);
const RowUpdater = __webpack_require__(/*! ../RowUpdater.js */ 82021);

const L = (...params) => AB.Multilingual.label(...params);

class ABQL extends ABQLCore {
   // constructor(attributes, parameterDefinitions, prevOP, task, application) {
   //     super(attributes, parameterDefinitions, prevOP, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      // var allColumns = row.getChildViews();
      // allColumns.shift(); // remove selector
      this.parameterDefinitions.forEach((pDef) => {
         // var col = allColumns.shift();
         var myID = this.uiID(id);
         this.ids = this.toIDs(myID);
         this.params = this.params || {};

         switch (pDef.type) {
            case "objectName":
               this.params[pDef.name] = $$(this.ids.objectname).getValue();
               break;

            case "objectConditions":
            case "objectValues":
               var uiCondition = $$(this.ids.condition);
               if (uiCondition) {
                  var condition = uiCondition.getValue();
                  if (condition && condition != "") {
                     this.params[pDef.name] = JSON.parse(condition);
                  }
               }
               break;
         }
      });
   }

   /*
    * @method toIDs()
    * generate a set of unique webix ids to use for our UI.
    * @param {string} myID
    *        the unique id generated by .uiID()
    */
   toIDs(myID) {
      return {
         condition: `${myID}_condition`,
         objectname: `${myID}_objname`,
         popup: `${myID}_popup`,
         select: `${myID}_select`,
         shorthand: `${myID}_shorthand`,
      };
   }

   /**
    * @method uiAddParamForDef()
    * Add an operation parameter for each parameterDefinition we have defined.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParamForDef(pDef, id, ui) {
      // params are added to a .col[] definition.
      // if our ui isn't down to the current .col element, then drill down
      if (!ui.cols) {
         if (ui.rows) {
            for (var i = 0; i < ui.rows.length; i++) {
               if (ui.rows[i].cols) {
                  this.uiAddParamForDef(pDef, id, ui.rows[i]);
                  break;
               }
            }
         } else {
            throw new Error("provided ui is not able to add a parameter!");
         }
         return;
      }

      var paramUI = this.uiParamUI(pDef, id);

      if (paramUI) {
         // if we only have 1 param
         if (this.parameterDefinitions.length == 1) {
            ui.cols.push(paramUI);
         } else {
            // if we haven't already added a parameter
            if (ui.cols.length < 3) {
               // create a row stack of parameters:
               ui.cols.push({
                  rows: [paramUI],
               });
            } else {
               // add to the current stack of parameters
               ui.cols[2].rows.push(paramUI);
            }
         }
      }
   }

   /**
    * @method uiAddNext()
    * Add the next row selector for this operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddNext(id, ui) {
      var uiRow = this.uiNextRow(id);

      // if we have a next operation defined, then add on the ui definitions
      // for that operation:
      if (this.next) {
         this.next.uiAddParams(id, uiRow);
         ui.rows.push(uiRow);
         this.next.uiAddNext(id, ui);
      } else {
         // otherwise we just leave the selector:
         ui.rows.push(uiRow);
      }
   }

   /**
    * @method uiAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParams(id, ui) {
      this.parameterDefinitions.forEach((pDef) => {
         this.uiAddParamForDef(pDef, id, ui);
      });
   }

   /*
    * @method uiID()
    * generate a unique webix id for this operation.
    * @param {string} id
    *        the webix id of the base property.query holder
    */
   uiID(id) {
      if (this.prevOP) {
         return `${this.prevOP.uiID(id)}_${this.constructor.key}`;
      } else {
         return `${id}_${this.constructor.key}`;
      }
   }

   /*
    * uiXXX Operations:
    * are UI building operations that are performed BEFORE the webix UI
    * is generated.  They work by filling out a {ui} object definition
    * that webix will eventually create into the DOM.
    *
    * viewXXX Operations:
    * are UI building operations that are performed AFTER the webix UI
    * is generated. They work by adding in child views to an existing
    * DOM.
    */

   /**
    * @method uiNextRow()
    * return the webix UI definition for the next of UI chaining.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiNextRow(id) {
      var options = this.constructor.NextQLOps.map((op) => {
         return { id: op.key, value: op.label };
      });
      options.unshift({ id: 0, value: L("choose next operation") });

      var myID = this.uiID(id);
      var ids = this.toIDs(myID);

      var uiRow = {
         cols: [
            { view: "spacer", width: this.constructor.uiIndentNext || 10 },
            {
               id: ids.select,
               view: "select",
               value: this.next ? this.next.constructor.key : 0,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     function resetValue() {
                        var select = $$(ids.select);
                        select.blockEvent();
                        select.setValue(oldValue);
                        select.unblockEvent();
                     }
                     if (newValue == oldValue) {
                        return;
                     }
                     var newOP = this.constructor.NextQLOps.find((op) => {
                        return op.key == newValue;
                     });
                     if (!newOP) {
                        resetValue();
                        return;
                     }

                     var thisRow = $$(ids.select).getParentView();
                     var thisQuery = thisRow.getParentView();

                     var addOP = () => {
                        if (newOP) {
                           var nextOP = new newOP({}, this, this.task, this.AB);
                           this.next = nextOP;
                           nextOP.viewAddParams(id, thisRow);
                           nextOP.viewAddNext(id, thisQuery);
                        }
                     };

                     // if there are rows after this one, then warn
                     // about changing
                     var allRows = thisQuery.getChildViews();
                     if (allRows.length - 1 > allRows.indexOf(thisRow)) {
                        webix.confirm({
                           title: "continue?",
                           text:
                              "changing this rule will reset any following rules.",
                           ok: "yes",
                           cancel: "no",
                           callback: (result) => {
                              if (result) {
                                 // remove the current additional Rows:
                                 var ir = allRows.length - 1;
                                 while (
                                    allRows[ir].config.id != thisRow.config.id
                                 ) {
                                    thisQuery.removeView(allRows[ir]);
                                    ir--;
                                 }

                                 // now remove the parameters
                                 var allCols = thisRow.getChildViews();
                                 var ic = allCols.length;
                                 while (ic > 1) {
                                    thisRow.removeView(allCols[ic - 1]);
                                    ic--;
                                 }

                                 addOP();
                              } else {
                                 resetValue();
                              }
                           },
                        });
                     } else {
                        addOP();
                     }
                  },
               },
            },
         ],
      };

      return uiRow;
   }

   /**
    * @method uiParamUI()
    * return the webix UI definition for the parameter entry of this current
    * operation.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiParamUI(pDef, id) {
      var myID = this.uiID(id);
      this.ids = this.toIDs(myID);
      var paramUI = null;

      // now add the parameter
      switch (pDef.type) {
         case "objectName":
            // an objectName parameter returns a select list of available
            // objects in this ABFactory.
            var options = this.AB.objects().map((o) => {
               return { id: o.id, value: o.label };
            });
            paramUI = {
               id: this.ids.objectname,
               view: "select",
               value: this.objectID,
               options: options,
               on: {
                  onChange: (newValue /*, oldValue */) => {
                     this.params = this.params || {};
                     if (newValue != this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef);
                     }
                  },
               },
            };
            break;

         case "objectConditions":
            // objectConditions: returns a filter text summary, that when
            // clicked, pops up a Filter Entry Popup.
            // the actual value is stored in a hidden field.

            // we will create a new FilterComplex() object to use for our
            // filtering.
            // Our goal is to create a special filter entry for each avaiable
            // process data value that is available.
            // A filter entry needs to look like:
            // {
            //     id: `{string}`,      // A unique id selector for this filter
            //     name: `{string}`,    // the operation name displayed
            //     type, {obj}          // an object defining the editor to show
            //     fn: ()=>{}           // a function used for filtering elements
            // }
            //
            // In our filters, we are assigning filters to EACH field by the
            // field.id.  So the type definition needs to look like:
            // {
            //     "uniqueID of the field (field.id)" : {webixUI definition}
            // }

            var Filter = this.AB.filterComplexNew(id);
            var hashFieldIDs = this.availableProcessDataFieldsHash();
            if (this.object) {
               Filter.fieldsLoad(this.object.fields(), this.object);
               // NOTE: this will create default filters based upon the
               // object fields() and their types

               // Now we need to add in the Process Data Fields:
               // for each Process Data Field that matches our same object
               var foundFields = Object.keys(hashFieldIDs)
                  .map((f) => {
                     return hashFieldIDs[f];
                  })
                  .filter((k) => {
                     return k.object && k.object.id == this.object.id;
                  });

               Filter.processFieldsLoad(foundFields);
               /*
               (foundFields || []).forEach((processField) => {
                  var type = {};
                  if (processField.field) {
                     type[processField.field.id] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  } else {
                     // if there is no .field, it is probably an embedded special field
                     // like: .uuid
                     var key = processField.key.split(".").pop();
                     type[key] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  }

                  // add an "equals" and "not equals" filter for each:
                  Filter.filterAdd([
                     {
                        id: `context_equals`,
                        name: `equals`,
                        type,
                        fn: (a, b) => {
                           return a == b;
                        }
                     },
                     {
                        id: `context_not_equal`,
                        name: `not equals`,
                        type,
                        fn: (a, b) => {
                           return a != b;
                        }
                     }
                  ]);
                  
               }); */
            }

            // every time the Filter "saves" it's data, it emits this event:
            // take the given condition and store it in our hidden element.
            Filter.on("save", (condition) => {
               // @param {obj} condition an object describing the filter
               // condition.

               this.params = this.params || {};
               this.params[pDef.name] = condition;

               let shortHand = $$(this.ids.shorthand);
               // console.log(Filter.toShortHand());
               shortHand.define({
                  label: Filter.toShortHand(),
               });
               shortHand.refresh();

               // NOTE: the hidden element is a text field, so convert the
               // {condition object} => a string
               let elCondition = $$(this.ids.condition);
               elCondition.define({
                  value: JSON.stringify(this.params[pDef.name]),
               });
               elCondition.refresh();
            });

            // create the initial condition value from our inputs.
            var initialCond = "";
            if (this.params && this.params[pDef.name]) {
               Filter.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            }

            // what we show on the panel, is a text representation
            // of the current condition.
            var displayLabel = Filter.toShortHand();
            paramUI = {
               rows: [
                  {
                     id: this.ids.shorthand,
                     view: "label",
                     label: displayLabel,
                     on: {
                        onItemClick: function () {
                           Filter.popUp();
                        },
                     },
                  },
                  // have a hidden field to contain the condition
                  // value we will parse out later
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true,
                  },
               ],
            };
            break;

         case "objectValues":
            // objectValues : shows a condenced textual representation of the
            // field => value changes.  Clicking on the text will show a popup
            // that allows you to add/remove additional field updates for
            // the current object.

            var initialValue = "";
            var Updater = new RowUpdater(null, myID);
            if (this.object) {
               Updater.objectLoad(this.object);
            }

            // Set processed data key to value options
            Updater.setExtendedOptions(
               (this.task.process.processDataFields(this.task) || []).map(
                  (item) => {
                     return {
                        id: item.key,
                        value: item.label
                     };
                  }
               )
            );

            // NOTE: .setValue() must be called once the RowUpdater is already
            // displayed.  See the end of popUp() below:
            if (this.params && this.params[pDef.name]) {
               Updater.setValue(this.params[pDef.name]);
               initialValue = JSON.stringify(this.params[pDef.name]);
            }

            var popUp = () => {
               // show the RowUpdater in a popup:
               var ui = {
                  id: this.ids.popup,
                  view: "popup",
                  position: "center",
                  minWidth: 700,
                  modal: true,
                  resize: true,
                  body: {
                     rows: [
                        {
                           height: 30,
                           borderless: true,
                           cols: [
                              { fillspace: true },
                              {
                                 view: "button",
                                 value: "X",
                                 width: 30,
                                 click: () => {
                                    $$(this.ids.popup).hide();
                                 }
                              }
                           ]
                        },
                        Updater.ui,
                        {
                           view: "button",
                           value: L("Save"),
                           css: "webix_primary",
                           click: () => {
                              this.params = this.params || {};
                              this.params[pDef.name] = Updater.getValue();
                              var sh = $$(this.ids.shorthand);
                              sh.define({
                                 label: JSON.stringify(this.params[pDef.name]),
                              });
                              sh.refresh();

                              var cond = $$(this.ids.condition);
                              cond.define({
                                 value: JSON.stringify(this.params[pDef.name]),
                              });
                              cond.refresh();

                              $$(this.ids.popup).hide();
                           },
                        },
                     ],
                  },
               };

               // create and show the popup
               this._myPopup = webix.ui(ui);
               this._myPopup.show();

               // NOTE: on a RowUpdater, the values need to be set
               // AFTER it is displayed:
               if (this.params && this.params[pDef.name]) {
                  Updater.setValue(this.params[pDef.name]);
               }
            };
            paramUI = {
               rows: [
                  // the textual shorthand for these values
                  {
                     id: this.ids.shorthand,
                     view: "label",
                     label: initialValue,
                     on: {
                        onItemClick: function () {
                           popUp();
                        },
                     },
                  },
                  // the hidden field that contains the results
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialValue,
                     hidden: true,
                  },
               ],
            };
            break;
      }

      return paramUI;
   }

   /**
    * @method viewAddNext()
    * Add the next selector row After this Operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} topView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the top container that is adding a new
    *        row for each operation.
    */
   viewAddNext(id, topView) {
      var uiRow = this.uiNextRow(id);
      topView.addView(uiRow);
   }

   /**
    * @method viewAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} rowView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the ROW that the parameters are added to
    */
   viewAddParams(id, rowView) {
      var params = [];
      this.parameterDefinitions.forEach((pDef) => {
         // get the definition from .uiParamUI()
         params.push(this.uiParamUI(pDef, id));
      });
      var toInsert = null;
      // stack parameters in a row if there are more than 1
      if (params.length > 1) {
         toInsert = {
            rows: params,
         };
      } else {
         toInsert = params.pop();
      }
      if (toInsert) {
         rowView.addView(toInsert);
      }
   }

   ////
   //// QueryString Parser routines:
   ////

   /*
     * parseQuery()
     * check the given query string input and see if this object is the
     * starting object.
     * @param {string} query
     *			 the entered query string operation.
     * @return {bool}
     * /
    static parseQuery(query) {
        // we want to see if the beginning of this query matches our
        // option_begin string.
        var begQuery = query;
        if (query.length > this.option_begin.length) {
            begQuery = query.slice(0, this.option_begin.length);
        }
        if (this.option_begin.indexOf(begQuery) == 0) {
            return true;
        }
        return false;
    }



    /// ABApplication data methods

    tabComplete() {
        if (this._suggestions) {
            // if our begin tag is  present in _suggestions
            if (
                this._suggestions.indexOf(this.constructor.option_begin) != -1
            ) {
                // this is probably finishing out our command:
                this.currQuery = this._suggestions;
            } else {
                // we are suggesting a parameter value:
                this.currQuery = `${this.constructor.option_begin}${this._suggestions}`;
            }

            // now make sure we do another refresh to get another
            // suggestion.
            this.fromQuery(this.currQuery);
        }
    }

    paramsToString() {
        var strs = [];
        this.parameterDefinitions.forEach((pDef) => {
            strs.push(this.params[pDef.name]);
            // switch (pDef.type) {
            //     case "objectName":
            //         strs.push(this.params[pDef.name]);
            //         break;
            // }
        });

        return strs.join(",");
    }

    /**
     * @method toObj()
     *
     * properly compile the current state of this ABView instance
     * into the values needed for saving to the DB.
     *
     * @return {json}
     * /
    toQuery() {
        if (this.entryComplete) {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.constructor.option_begin
            }${this.params ? this.paramsToString() : ""})`;
        } else {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.currQuery ? this.currQuery : ""
            }`;
        }
    }

    fromQuery(queryString) {
        var results = this.constructor.regEx.exec(queryString);
        if (results) {
            this.entryComplete = true;
            this.queryValid = true;
            this.params = {};

            if (this.paramsValid(results[1])) {
                // now progress on to any next operations:
                var newQuery = queryString.replace(this.constructor.regEx, "");
                var matchingOPs = [];
                this.constructor.NextQLOps.forEach((OP) => {
                    if (OP.parseQuery(newQuery)) {
                        matchingOPs.push(OP);
                    }
                });
                if (matchingOPs.length == 1) {
                    // exact match, so add next:
                    var qlOP = new matchingOPs[0](
                        {},
                        this,
                        this.task,
                        this.application
                    );
                    qlOP.fromQuery(newQuery);
                    this.next = qlOP;
                }

                // if there were no matching OPs, then they typed an error:
                if (matchingOPs.length == 0) {
                    this.queryValid = false;
                }
            } else {
                // I don't recoginze these params!
                this.queryValid = false;
                this._suggestions = " ! Invalid Params !";
            }
        } else {
            this.currQuery = queryString;
            this.queryValid = true; // assume true then set to false later
            this._suggestions = null;

            // calculate the processing of our command + params:
            // if we have finished our begining
            if (this.currQuery.indexOf(this.constructor.option_begin) == 0) {
                var param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            } else {
                // else they need to finish the beginning
                this._suggestions = this.constructor.option_begin;
            }

            // if we didn't have any suggestions, then what they typed
            // doesn't match, so remove the last character:
            if (!this._suggestions) {
                this.currQuery = this.currQuery.slice(0, -1);
                this.queryValid = false;
                this._suggestions = null;

                // try to regenerate the suggestions again:
                var param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            }
        }
    }

    firstOP() {
        if (!this.prevOP) {
            return this;
        } else {
            return this.prevOP.firstOP();
        }
    }

    lastOP() {
        if (!this.entryComplete) {
            return this;
        } else {
            // now figure out which of our nextOps are being used.
            if (this.next) {
                return this.next.lastOP();
            } else {
                // we haven't specified a next OP, so we are still up.
                return this;
            }
        }
    }

    paramPull(paramDef, queryString) {
        var result = { param: queryString, balance: 0 };
        if (queryString.length > 0) {
            switch (paramDef.type) {
                case "objectName":
                    // define a lexer for objectNames
                    var lexerObjectName = moo.compile({
                        comma: { match: "," },
                        name: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectName.reset(queryString);
                    var name = "";
                    var foundObj = null;
                    var token = lexerObjectName.next();

                    if (token) {
                        // if this is the 2nd time through, might
                        // begin with a ','
                        while (token.type == "comma") {
                            token = lexerObjectName.next();
                        }

                        // pull the parameter from the current queryString
                        if (["name", "currKey"].indexOf(token.type) != -1) {
                            name = token.value;
                        }
                        result.param = name;
                    }

                    break;

                case "objectConditions":
                case "objectValues":
                    // define a lexer for objectConditions
                    // the goal of this lexer is to achieve json balance
                    // ( equal # of { & }) while reaching an end condition:
                    var lexerObjectCond = moo.compile({
                        comma: { match: "," },
                        colon: { match: ":" },
                        lbrace: { match: "{" },
                        rbrace: { match: "}" },
                        rparen: { match: ")" },
                        keyval: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectCond.reset(queryString);
                    var balance = 0;
                    var foundObj = null;
                    var token = lexerObjectCond.next();
                    var stop = false;
                    var param = "";
                    while (token && !stop) {
                        if (token.type == "lbrace") {
                            balance++;
                        }
                        if (token.type == "rbrace") {
                            balance--;
                        }

                        // check for stop condition:
                        // when balance is achieved and we find a ","
                        if (balance == 0) {
                            if (token.type == "comma") {
                                stop = true;
                            }
                        }

                        if (!stop) {
                            param += token.value;
                            token = lexerObjectCond.next();
                        }
                    }
                    result.param = param;
                    result.balance = balance;
                    break;
            }
        }

        return result;
    }

    suggestionComplete() {
        var params = [];
        this.parameterDefinitions.forEach((pDef) => {
            params.push(this.params[pDef.name]);
        });
        return `${this.constructor.option_begin}${params.join(",")})`;
    }

    /**
     * @method paramsFromQuery()
     * take the given queryString value and see if it matches our
     * possible parameter values.
     * we update ._suggestions based upon the current param state.
     * @param {string} queryString
     * /
    paramsFromQuery(queryString) {
        var keepGoing = true;
        var current = queryString;

        // for each of our parameters,
        this.parameterDefinitions.forEach((pDef) => {
            if (!keepGoing) return;

            // pull the current param
            var pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");

            // if this param is NOT valid
            if (!this.paramIsValid(pDef, pullResult)) {
                // don't keep going after this
                keepGoing = false;

                // offer suggestions for this param
                switch (pDef.type) {
                    case "objectName":
                        // return suggestions for our parameters
                        var suggestions = [];
                        var objects = this.application.objects((o) => {
                            var quotedLabel = `"${o.label}"`;
                            return (
                                pullResult.param.length == 0 ||
                                quotedLabel.indexOf(pullResult.param) == 0
                            );
                        });
                        objects.forEach((o) => {
                            suggestions.push(`"${o.label}"`);
                        });
                        this._suggestions = suggestions.join("\n");
                        break;

                    case "objectConditions":
                    case "objectValues":
                        var paramComplete = false;
                        var paramObj = null;
                        try {
                            paramObj = JSON.parse(pullResult.param);
                            paramComplete = true;
                        } catch (e) {}

                        if (paramComplete) {
                            this.paramObj = paramObj;
                            this.params[pDef.name] = pullResult.param;
                            // this.entryComplete = true;
                            this._suggestions = this.suggestionComplete();
                        } else {
                            // define a lexer to help us parse through the provided cond string
                            var lexer = moo.states({
                                start: {
                                    lbrace: { match: "{", push: "key" }
                                },
                                key: {
                                    colon: { match: ":", push: "value" },
                                    rparen: { match: ")", pop: true },
                                    key: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                        // value: (s) => s.slice(1, -1)
                                    },
                                    WS: /[ \t]+/,
                                    currKey: moo.error
                                },
                                value: {
                                    // lbrace: { match: "{", push: "complexValue" },
                                    rbrace: { match: "}", pop: true },
                                    valueContext: {
                                        match: /"\$context\((?:\\["\\]|[^\n"\\])*?\)"/
                                    },
                                    value: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                    },
                                    comma: { match: ",", pop: true },
                                    currVal: moo.error
                                }
                            });

                            // now follow our state, to figure out if we are entering a
                            // key, or a value, and then figure out how to offer suggestions
                            // based upon what they are entering now:
                            var state = "start";
                            lexer.reset(pullResult.param);
                            var token = lexer.next();
                            var lastToken = null;
                            var lastKey = null;
                            while (token) {
                                switch (state) {
                                    case "start":
                                        if (token.type == "lbrace") {
                                            state = "key";
                                        }
                                        break;
                                    case "key":
                                        if (token.type == "colon") {
                                            state = "value";
                                        }
                                        if (token.type == "key") {
                                            lastKey = token.value;
                                        }
                                        break;

                                    case "value":
                                        if (token.type == "comma") {
                                            state = "key";
                                        }
                                        break;
                                }
                                lastToken = token;
                                token = lexer.next();
                            }

                            // by this point, we have ended on a state, and can figure out
                            // what to suggest:
                            switch (state) {
                                case "start":
                                    // if we ended here, then we didn't even have our first {
                                    this._suggestions = "{cond}";
                                    break;

                                case "key":
                                    // we are entering a Key, so suggest the available fields
                                    // from this object
                                    var currKey = "";
                                    var types = ["key", "currKey"];
                                    if (types.indexOf(lastToken.type) != -1) {
                                        currKey = lastToken.value;
                                    }
                                    this._suggestions = this.fieldList(currKey);

                                    // if we end up with ._suggestions == currKey
                                    // then the key is complete, and we need to now enter ":"
                                    if (this._suggestions == currKey) {
                                        this._suggestions = ":";
                                    }
                                    break;

                                case "value":
                                    // entering a value, decide what to suggest based on what
                                    // the current key/field we are on:
                                    var currValue = "";
                                    var types = [
                                        "value",
                                        "valueContext",
                                        "currVal"
                                    ];
                                    if (types.indexOf(lastToken.type) != -1) {
                                        currValue = lastToken.value;
                                    }
                                    this._suggestions = this.valueList(
                                        lastKey,
                                        currValue
                                    );
                                    break;
                            }
                        }

                        break;
                }
            }
        });

        if (keepGoing) {
            // none of our params were invalid, so just suggest to complete our
            this._suggestions = this.suggestionComplete();
        }
    }

    paramIsValid(paramDef, pullResult) {
        var isValid = true;
        this.params = this.params || {};
        switch (paramDef.type) {
            case "objectName":
                // verify it is valid
                var param = pullResult.param;
                var foundObj = null;
                if (param) {
                    // see if we find a Matching Object
                    foundObj = this.application.objects((o) => {
                        var quotedLabel = `"${o.label}"`;
                        return (
                            param.length == 0 || quotedLabel.indexOf(param) == 0
                        );
                    })[0];
                    if (foundObj) {
                        this.params[paramDef.name] = param;
                        // it is NOT valid unless it is an exact match:
                        if (`"${foundObj.label}"` != param) {
                            isValid = false;
                        }
                    }
                }
                isValid = isValid && param.length > 0 && foundObj;
                break;

            case "objectConditions":
            case "objectValues":
                if (pullResult.balance == 0) {
                    this.params[paramDef.name] = pullResult.param;
                }
                isValid =
                    isValid &&
                    pullResult.balance == 0 &&
                    pullResult.param.length > 0;
                break;
        }

        return isValid;
    }
    /**
     * @method paramsValid()
     * parse through the given text and see if our defined parameters
     * can be properly represented.
     * @param {string} queryString
     *        the current value of the text that is the parameter(s) to our
     *        function.
     * @return {bool}
     *         true : if every parameter parses
     *         false: otherwise
     * /
    paramsValid(queryString) {
        // queryString represents the full text parameters. Might be > 1 params

        var current = queryString;
        var isValid = true; // so optimistic.

        // for each of our defined parameters
        this.parameterDefinitions.forEach((pDef) => {
            var pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");
            isValid = isValid && this.paramIsValid(pDef, pullResult);
        });

        return isValid;
    }

    suggestions() {
        if (this.entryComplete) {
            // return suggestions for next operations.
            var suggestions = [];

            this.constructor.NextQLOps.forEach((OP) => {
                suggestions.push(OP.option);
            });
            return suggestions.join("\n");
        } else {
            return this._suggestions;
        }
    }
    */
}

module.exports = ABQL;


/***/ }),

/***/ 63408:
/*!********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLFind
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */
const ABQLFindCore = __webpack_require__(/*! ../../core/ql/ABQLFindCore.js */ 85111);

class ABQLFind extends ABQLFindCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}
ABQLFind.uiIndentNext = 10;

module.exports = ABQLFind;


/***/ }),

/***/ 46370:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLManager.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLManager
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */

const ABQLManagerCore = __webpack_require__(/*! ../../core/ql/ABQLManagerCore.js */ 98162);

var ABQLManager = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current {ABFactory} active for this interface.
    * @return {ABQL} | null
    */
   fromAttributes: ABQLManagerCore.fromAttributes,

   /**
    * @method ids()
    * return a set of unique webix ids for the ui portions of this object.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @return {object}
    */
   ids: function (id) {
      return {
         root: `${id}_root`,
         select: `${id}_root_select`,
         options: `${id}_root_options`,
      };
   },

   /**
    * @method builder
    * return a UI component like object that will display the QL builder.
    * The component will support:
    *		.ui(id) : returns a webix ui definition for the current builder
    *		.init(id) : performs any special actions to prepare the webix ui
    * @param {object} rootOP
    *		  the root ABQLxxxx operation
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} active for this display.
    * @return {object}
    */
   builder: function (rootOP, task, AB) {
      // var rootOP = this.fromAttributes(attributes, task, AB);
      let L = (...params) => AB.Multilingual.label(...params);

      return {
         ui: function (id) {
            var options = [{ id: 0, value: L("choose Root") }];
            ABQLManagerCore.QLOps.forEach((op) => {
               options.push({ id: op.key, value: op.label });
            });

            var ids = ABQLManager.ids(id);
            var ui = {
               rows: [
                  {
                     view: "label",
                     label: L("Query:"),
                  },
                  {
                     id: ids.root,
                     cols: [
                        {
                           id: ids.select,
                           view: "select",
                           value: rootOP ? rootOP.constructor.key : 0,
                           options: options,
                           on: {
                              onChange: (newValue, oldValue) => {
                                 function resetValue() {
                                    var select = $$(ids.select);
                                    select.blockEvent();
                                    select.setValue(oldValue);
                                    select.unblockEvent();
                                 }
                                 if (newValue == oldValue) {
                                    return;
                                 }
                                 var newOP = ABQLManagerCore.QLOps.find(
                                    (op) => {
                                       return op.key == newValue;
                                    }
                                 );
                                 if (!newOP) {
                                    resetValue();
                                    return;
                                 }
                                 function addOP() {
                                    if (newOP) {
                                       rootOP = new newOP({}, task, AB);
                                       rootOP.viewAddParams(id, $$(ids.root));
                                       rootOP.viewAddNext(
                                          id,
                                          $$(ids.root).getParentView()
                                       );
                                    }
                                 }
                                 var topEntry = $$(ids.root).getParentView();
                                 var allRows = topEntry.getChildViews();
                                 if (allRows.length > 2) {
                                    webix.confirm({
                                       title: "continue?",
                                       text:
                                          "changing this rule will reset any following rules.",
                                       ok: "yes",
                                       cancel: "no",
                                       callback: (result) => {
                                          if (result) {
                                             // remove the current additional Rows:
                                             var thisView = $$(ids.root);
                                             var ir = allRows.length - 1;
                                             while (
                                                allRows[ir].config.id !=
                                                thisView.config.id
                                             ) {
                                                topEntry.removeView(
                                                   allRows[ir]
                                                );
                                                ir--;
                                             }

                                             // now remove the parameters
                                             var allCols = thisView.getChildViews();
                                             var ic = allCols.length;
                                             while (ic > 1) {
                                                thisView.removeView(
                                                   allCols[ic - 1]
                                                );
                                                ic--;
                                             }

                                             addOP();
                                          } else {
                                             resetValue();
                                          }
                                       },
                                    });
                                 } else {
                                    addOP();
                                 } // if allRows.length > 2
                              }, // onChange
                           },
                        },
                     ],
                  },
               ],
            };

            if (rootOP) {
               rootOP.uiAddParams(id, ui);
               rootOP.uiAddNext(id, ui);
            }

            return ui;
         },
         init: function (id) {},
      };
   },

   /**
    * @method parse
    * step through the current properties panel and decode the QL objects
    * and their parameters.
    * Return the .toOBJ() attributes definition as a result.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} object that is currently active.
    * @return {object}
    */
   parse: function (id, task, AB) {
      var ids = ABQLManager.ids(id);
      var root = $$(ids.root);

      if (!root) {
         console.warn("ABQLManager.parse(): unable to find root element");
         return;
      }

      // get all the input rows
      var rows = root.getParentView().getChildViews();
      rows.shift(); // remove the query label row:

      function parseCurrent(rows, options, prevOP) {
         if (rows.length == 0) {
            return null;
         }
         var row = rows.shift();

         // get which operation was selected
         // find the operation selector (skip any indents)
         var views = row.getChildViews();
         var selector = views.shift();
         while (!selector.getValue) {
            selector = views.shift();
         }
         var value = selector.getValue();

         // figure out the QLOP object
         var OP = options.find((o) => {
            return o.key == value;
         });
         if (OP) {
            var currOP = null;
            if (prevOP) {
               currOP = new OP({}, prevOP, task, AB);
            } else {
               currOP = new OP({}, task, AB);
            }

            // now get currOP to initialize from it's parameters:
            currOP.parseRow(row, id);

            // carry forward any .object info if not already established
            // by the .parseRow():
            if (!currOP.object && prevOP) {
               currOP.object = prevOP.object;
               currOP.objectID = currOP.object ? currOP.object.id : null;
            }

            var nextRow = parseCurrent(
               rows,
               currOP.constructor.NextQLOps,
               currOP
            );
            currOP.next = nextRow;
            return currOP;
         }
         return null;
      }
      var operation = parseCurrent(rows, ABQLManagerCore.QLOps, null);
      return operation;
   },
};
module.exports = ABQLManager;


/***/ }),

/***/ 54157:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRootObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRootObject
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */

const ABQLRootObjectCore = __webpack_require__(/*! ../../core/ql/ABQLRootObjectCore.js */ 37505);

class ABQLObject extends ABQLRootObjectCore {
   // constructor(attributes, task, application) {
   //     // NOTE: keep this so we can insert the prevOp == null
   //     super(attributes, ParameterDefinitions, null, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name == "name") {
         this.objectID = this.params[pDef.name];
         this.object = this.objectLookup(this.objectID);

         // ?? is this correct?
         // if we already have created a .next operation, and we have
         // just changed our .object, pass that information forward.
         if (this.next) {
            this.next.object = this.object;
         }
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      // for an Object operation, we need to set our .objectID after
      // the values are parsed.

      if (this.params.name) {
         this.objectID = this.params.name;
         this.object = this.objectLookup(this.params.name);
      }
   }
}
ABQLObject.uiIndentNext = 10;

module.exports = ABQLObject;


/***/ }),

/***/ 25851:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowPluck.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABQLRowPluckCore = __webpack_require__(/*! ../../core/ql/ABQLRowPluckCore.js */ 29215);

class ABQLRowPluck extends ABQLRowPluckCore {
   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef, id) {
      super.paramChanged(pDef);
      if (pDef.name == "field") {
         // Re-generate next select options
         this.uiNextRowSelectorRefresh(id);
      }
   }
}
ABQLRowPluck.uiIndentNext = 20;

module.exports = ABQLRowPluck;


/***/ }),

/***/ 47027:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowSave.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowSave
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLSetSaveCore = __webpack_require__(/*! ../../core/ql/ABQLSetSaveCore.js */ 74178);

class ABQLRowSave extends ABQLSetSaveCore {}
ABQLRowSave.uiIndentNext = 20;

module.exports = ABQLRowSave;


/***/ }),

/***/ 465:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowUpdate.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowUpdate
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */

const ABQLRowUpdateCore = __webpack_require__(/*! ../../core/ql/ABQLRowUpdateCore.js */ 60354);

class ABQLRowUpdate extends ABQLRowUpdateCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   //     // #Hack! : when an Operation provides the same .NextQlOps that it
   //     // was defined in, we can't require it again ==> circular dependency.
   //     // so we manually set it here from the operation that created us:
   //     this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   // }
   ///
   /// Instance Methods
   ///
}
ABQLRowUpdate.uiIndentNext = 20;

module.exports = ABQLRowUpdate;


/***/ }),

/***/ 88593:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetFirst.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetFirst
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQLSetFirstCore = __webpack_require__(/*! ../../core/ql/ABQLSetFirstCore.js */ 80219);

class ABQLSetFirst extends ABQLSetFirstCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}
ABQLSetFirst.uiIndentNext = 20;

module.exports = ABQLSetFirst;


/***/ }),

/***/ 5926:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetPluck.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetPluck
 *
 * An ABQLSetPluck can process a set (array) of data and puck out a specified
 * field from each row to then make an array of values that only contain that 
 * field.
 * 
 * Example: 
array = [
 {
	name: "Neo",
	email: "neo@thematrix.com",
	relationships: [ { morpheous}, {trinity} ]
 },
 {
	name: "trinity",
	email: "trinity@thematrix.com",
	relationships: [ {neo}, {morpheous} ]
 },
 {
	name: "morpheous",
	email: "morpheous@thematrix.com",
	relationships: [ {neo}, {trinity}]
 }

]

pluck("email") :
	[
		"neo@thematrix.com",
		"trinity@thematrix.com",
		"morpheous@thematrix.com"
	]

pluck("relationships"):
	[
		{neo},
		{trinity},
		{morpheous}
	]
 *
 */

const ABQLSetPluckCore = __webpack_require__(/*! ../../core/ql/ABQLSetPluckCore.js */ 60512);

class ABQLSetPluck extends ABQLSetPluckCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name == "field") {
         // debugger;
         this.fieldID = this.params[pDef.name];
         // v2 method:
         // this.field = this.object.fieldByID(this.fieldID);
         this.field = this.object.fieldByID(this.fieldID);

         // v2 method:
         // if (this.field && this.field.isConnected) {
         if (this.field && this.field.key == "connectObject") {
            this.objectOut = this.field.datasourceLink;

            // ?? is this correct?
            // if we already have created a .next operation, and we have
            // just changed our .object, pass that information forward.
            if (this.next) {
               this.next.object = this.objectOut;
            }
         }
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * NOTE: in this process our .object and .objectOut isn't as simple
    * as the other QL node types.  We'll have to interpolate our values
    * from the given fieldID in our property panel.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      this.fieldID = this.params.field;

      // we now have to build backwards from the current fieldID to set our
      // relevant .object and .objectOut
      this.AB.objects((o) => {
         if (!this.field) {
            // var field = o.fieldByID(this.fieldID);
            var field = o.fieldByID(this.fieldID);
            if (field) {
               this.field = field;
            }
         }
      });

      if (this.field) {
         this.object = this.field.object;
         // v2 method:
         // if (this.field.isConnected) {
         if (this.field && this.field.key == "connectObject") {
            this.objectOut = this.field.datasourceLink;
         }
      }
   }
}
ABQLSetPluck.uiIndentNext = 10;

module.exports = ABQLSetPluck;


/***/ }),

/***/ 67478:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetSave.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetSave
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLSetSaveCore = __webpack_require__(/*! ../../core/ql/ABQLSetSaveCore.js */ 74178);

class ABQLSetSave extends ABQLSetSaveCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name == "task_param") {
         this.taskParam = this.params[pDef.name];
      }
   }

   parseRow(row, id) {
      super.parseRow(row, id);

      if (!this.registered) {
         this.task.registerDatasource(this);
         this.registered = true;
      }
   }
}
ABQLSetSave.uiIndentNext = 10;

module.exports = ABQLSetSave;


/***/ }),

/***/ 23111:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLValueSave.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLValueSave
 *
 * An ABQLValueSave can store the current Data field set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLValueSaveCore = __webpack_require__(/*! ../../core/ql/ABQLValueSaveCore.js */ 6321);

class ABQLValueSave extends ABQLValueSaveCore {}
ABQLValueSave.uiIndentNext = 30;

module.exports = ABQLValueSave;


/***/ }),

/***/ 10902:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/views/ABView.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCore = __webpack_require__(/*! ../../core/views/ABViewCore.js */ 45974);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABView extends ABViewCore {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   // /*
   //  * @method isValid
   //  * check the current values to make sure they are valid.
   //  * Here we check the default values provided by ABView.
   //  *
   //  * @return {ABFactory.Validation.validator()}
   //  */
   // isValid() {
   //    var validator = this.AB.Validation.validator();

   //    // // labels must be unique among views on the same parent
   //    var parent = this.parent;
   //    // if (!parent) { parent = this.application; }

   //    // if we have a parent component:
   //    if (parent) {
   //       var isNameUnique =
   //          parent.views((v) => {
   //             return (
   //                v.id != this.id &&
   //                v.label.toLowerCase() == this.label.toLowerCase()
   //             );
   //          }).length == 0;
   //       if (!isNameUnique) {
   //          validator.addError(
   //             "label",
   //             L("View label must be unique among peers.")
   //          );
   //       }
   //    }
   //    return validator;
   // }

   // /**
   //  * @method editorComponent
   //  * return the Editor for this UI component.
   //  * the editor should display either a "block" view or "preview" of
   //  * the current layout of the view.
   //  * @param {string} mode what mode are we in ['block', 'preview']
   //  * @return {Component}
   //  */
   // editorComponent(App, mode) {
   //    var idBase = "ABViewEditorComponent";
   //    var ids = {
   //       component: App.unique(idBase + "_component"),
   //       view: App.unique(idBase + "_view"),
   //    };

   //    var _ui = {
   //       rows: [
   //          {
   //             id: ids.component,
   //             view: App.custom.savablelayout.view,
   //             type: "space",
   //             rows: [],
   //          },
   //       ],
   //    };

   //    var _init = (options) => {
   //       var Layout = $$(ids.component);

   //       var allComponents = [];

   //       App.eventIds = App.eventIds || {};

   //       // prevent .attachEvent multiple times
   //       if (App.eventIds["onAfterPortletMove"])
   //          webix.detachEvent("onAfterPortletMove");

   //       // listen a event of the porlet when layout is changed
   //       App.eventIds["onAfterPortletMove"] = webix.attachEvent(
   //          "onAfterPortletMove",
   //          (source, parent, active, target, mode) => {
   //             _logic.onAfterPortletMove();
   //          }
   //       );

   //       // attach all the .UI views:
   //       this.views().forEach((child) => {
   //          var component = child.component(App);

   //          var porletUI = {
   //             viewId: child.id, // set id to .viewId, the layout template
   //             view: "portlet",
   //             css: "ab-interface-component",
   //             // borderless: true,
   //             layoutType: "head", // Drag on icon
   //             body: {
   //                rows: [
   //                   {
   //                      view: "template",
   //                      height: 30,
   //                      css: "ab-porlet-header",
   //                      template: _logic.template(child),
   //                      onClick: {
   //                         "ab-component-edit": (e, id, trg) => {
   //                            _logic.viewEdit(e, child.id, trg);
   //                         },
   //                         "ab-component-remove": (e, id, trg) => {
   //                            _logic.viewDelete(e, child.id, trg);
   //                         },
   //                      },
   //                   },
   //                   mode == "preview"
   //                      ? component.ui
   //                      : {
   //                           // empty element
   //                           view: "spacer",
   //                           hidden: true,
   //                        },
   //                ],
   //             },
   //          };

   //          // get element in template
   //          var elem = Layout.queryView({ viewId: child.id });

   //          // If webix element is not exists in html, then destroy it.
   //          // NOTE : webix does not know html is missing when we redraw layout at .setState
   //          if (elem && !document.body.contains(elem.$view)) elem.destructor();

   //          if (elem) {
   //             // replace component to layout
   //             webix.ui(porletUI, elem);
   //          }
   //          // add component to rows
   //          else {
   //             Layout.addView(porletUI);
   //          }

   //          allComponents.push(component);
   //       });

   //       // in preview mode, have each child render a preview
   //       // of their content:
   //       if (mode == "preview") {
   //          // perform any init setups for the content:
   //          allComponents.forEach((component) => {
   //             component.init();
   //          });
   //       }
   //    };

   //    var _logic = {
   //       /**
   //        * @method template()
   //        * render the list template for the View
   //        * @param {obj} obj the current View instance
   //        * @param {obj} common  Webix provided object with common UI tools
   //        */
   //       template: function (child) {
   //          return (
   //             "<div>" +
   //             `<i class="fa fa-${child.icon} webix_icon_btn"></i> ` +
   //             ` ${child.label}` +
   //             '<div class="ab-component-tools">' +
   //             '<i class="fa fa-trash ab-component-remove"></i>' +
   //             '<i class="fa fa-edit ab-component-edit"></i>' +
   //             "</div>" +
   //             "</div>"
   //          );
   //       },

   //       /**
   //        * @method viewDelete()
   //        * Called when the [delete] icon for a child View is clicked.
   //        * @param {obj} e the onClick event object
   //        * @param {integer} id the id of the element to delete
   //        * @param {obj} trg  Webix provided object
   //        */
   //       viewDelete: (e, id, trg) => {
   //          var deletedView = this.views((v) => v.id == id)[0];

   //          if (!deletedView) return false;

   //          this.AB.Dialog.Confirm({
   //             title: L("Delete component"),
   //             text: L("Do you want to delete <b>{0}</b>?", [
   //                deletedView.label,
   //             ]),
   //             callback: function (result) {
   //                if (result) {
   //                   var Layout = $$(ids.component);

   //                   // remove UI of this component in template
   //                   var deletedElem = Layout.queryView({ viewId: id });
   //                   if (deletedElem)
   //                      $$(ids.component).destroyView(deletedElem);

   //                   // update/refresh template to ABView
   //                   _logic.refreshTemplate();

   //                   deletedView
   //                      .destroy()
   //                      .then(() => {
   //                         // signal the current view has been deleted.
   //                         deletedView.emit("destroyed", deletedView);

   //                         // if we don't have any views, then place a "drop here" placeholder
   //                         if ($$(ids.component).getChildViews().length == 0) {
   //                            webix.extend($$(ids.component), webix.OverlayBox);
   //                            $$(ids.component).showOverlay(
   //                               "<div class='drop-zone'><div>" +
   //                                  App.labels.componentDropZone +
   //                                  "</div></div>"
   //                            );
   //                         }
   //                      })
   //                      .catch((err) => {
   //                         this.AB.error(
   //                            "Error trying to delete selected View:",
   //                            { error: err, view: deletedView }
   //                         );
   //                      });
   //                }
   //             },
   //          });
   //          e.preventDefault();
   //       },

   //       /**
   //        * @method viewEdit()
   //        * Called when the [edit] icon for a child View is clicked.
   //        * @param {obj} e the onClick event object
   //        * @param {integer} id the id of the element to edit
   //        * @param {obj} trg  Webix provided object
   //        */
   //       viewEdit: (e, id, trg) => {
   //          var view = this.views((v) => v.id == id)[0];

   //          if (!view) return false;

   //          // yeah, if the empty placeholder fires an [edit] event,
   //          // then ignore it.
   //          if (view.id == "del_me") return false;

   //          // NOTE: let webix finish this onClick event, before
   //          // calling .populateInterfaceWorkspace() which will replace
   //          // the interface elements with the edited view.  (apparently
   //          // that causes errors.)
   //          setTimeout(() => {
   //             App.actions.populateInterfaceWorkspace(view);
   //          }, 50);

   //          e.preventDefault();

   //          return false;
   //       },

   //       onAfterPortletMove: () => {
   //          _logic.refreshTemplate();

   //          // save template layout to ABPageView
   //          this.save();

   //          // // Reorder
   //          // var viewId = active.config.id;
   //          // var targetId = target.config.id;

   //          // var toPosition = this._views.findIndex((v) => v.id == targetId);

   //          // this.viewReorder(viewId, toPosition);
   //       },

   //       refreshTemplate: () => {
   //          // get portlet template UI to ABView
   //          this.template = $$(ids.component).getState();
   //       },
   //    };

   //    return {
   //       ui: _ui,
   //       init: _init,
   //    };
   // }

   // static propertyEditorComponent(App) {
   //    var ABViewPropertyComponent = new ABPropertyComponent({
   //       editObject: this, // ABView

   //       fieldDefaults: this.common(), // ABViewDefaults,

   //       elements: (App, field) => {
   //          var ids = {
   //             imageWidth: "",
   //             imageHeight: "",
   //          };
   //          ids = field.idsUnique(ids, App);

   //          return [];
   //       },

   //       // defaultValues: the keys must match a .name of your elements to set it's default value.
   //       defaultValues: ABViewPropertyComponentDefaults,

   //       // rules: basic form validation rules for webix form entry.
   //       // the keys must match a .name of your .elements for it to apply
   //       rules: {
   //          // 'textDefault':webix.rules.isNotEmpty,
   //          // 'supportMultilingual':webix.rules.isNotEmpty
   //       },

   //       // include additional behavior on default component operations here:
   //       // The base routines will be processed first, then these.  Any results
   //       // from the base routine, will be passed on to these:
   //       //   @param {obj} ids  the list of ids used to generate the UI.  your
   //       //           provided .elements will have matching .name keys
   //       //           to access them here.
   //       //  @param {obj} values the current set of values provided for this instance
   //       //             of ABField:
   //       //           {
   //       //           id:'',      // if already .saved()
   //       //             label:'',
   //       //             columnName:'',
   //       //           settings:{
   //       //             showIcon:'',
   //       //
   //       //             your element key=>values here
   //       //           }
   //       //           }
   //       //
   //       //     .clear(ids)  : reset the display to an empty state
   //       //     .isValid(ids, isValid): perform validation on the current editor values
   //       //     .populate(ids, ABField) : populate the form with your current settings
   //       //     .show(ids)   : display the form in the editor
   //       //     .values(ids, values) : return the current values from the form
   //       logic: {},

   //       // perform any additional setup actions here.
   //       // @param {obj} ids  the hash of id values for all the current form elements.
   //       //          it should have your elements + the default Header elements:
   //       //           .label, .columnName, .fieldDescription, .showIcon
   //       init: function (ids) {
   //          // want to hide the description? :
   //          // $$(ids.fieldDescription).hide();
   //       },
   //    });

   //    return ABViewPropertyComponent.component(App);
   // }

   // static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
   //    return [
   //       // Component Label
   //       {
   //          view: "text",
   //          // id: ids.label,
   //          name: "label",
   //          label: App.labels.dataFieldHeaderLabel,
   //          placeholder: App.labels.dataFieldHeaderLabelPlaceholder,
   //          labelWidth: this.AB.UISettings.config().labelWidthLarge,
   //          css: "ab-new-label-name",
   //          //        on: {
   //          //          onChange: function (newVal, oldVal) {
   //          // console.warn('ABView.onChange()!!!');
   //          //          }
   //          //        }
   //       },
   //    ];
   // }

   // static propertyEditorPopulate(App, ids, view) {
   //    if (!view) return;
   //    $$(ids.label).setValue(view.label);
   // }

   // static propertyEditorValues(ids, view) {
   //    if (!view) return;
   //    view.label = $$(ids.label).getValue();
   // }

   // static propertyEditorSave(ids, view, includeSubViews = false) {
   //    this.propertyEditorValues(ids, view);

   //    return new Promise((resolve, reject) => {
   //       view
   //          .save(includeSubViews)
   //          .then(function () {
   //             // signal the current view has been updated.
   //             view.emit("properties.updated", view);

   //             resolve();
   //          })
   //          .catch(function (err) {
   //             this.AB.error("unable to save view:", {
   //                error: err,
   //                view: view,
   //             });
   //             reject(err);
   //          });
   //    });
   // }

   // /**
   //  * @method propertyDatacollections()
   //  * a convience method to return a list of available Datacollections
   //  * @param {bool} isGlobal
   //  *        true : return a list of ALL available DataCollections
   //  *        false: (default) only return a list of included DCs
   //  * @return {array}
   //  *        [ { id:dc.id, value:dc.label } ]
   //  *        this format is used by the webix select lists to choose your
   //  *        datasources.
   //  */
   // propertyDatacollections(
   //    filter = () => true,
   //    isGlobal = false,
   //    defaultOption = null
   // ) {
   //    if (defaultOption == null) {
   //       defaultOption = {
   //          id: "",
   //          value: L("Select a DataCollection"),
   //       };
   //    }

   //    var list = [];
   //    if (isGlobal) {
   //       list = this.AB.datacollections(filter);
   //    } else {
   //       list = this.application.datacollectionsIncluded(filter);
   //    }
   //    list = list.map((dc) => {
   //       return {
   //          id: dc.id,
   //          value: dc.label,
   //       };
   //    });
   //    list.unshift(defaultOption);
   //    return list;
   // }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = "ABView_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      // an ABView is a collection of rows:
      var _ui = {
         id: ids.component,
         view: "layout",
         type: "space",
         rows: [],
      };

      // if this form is empty, then force a minimal row height
      // so the component isn't completely hidden on the screen.
      // (important in the editor so we don't loose the ability to edit the
      // component)
      if (_ui.rows.length == 0) {
         _ui.height = 30;
      }

      // make sure each of our child views get .init() called
      var _init = (options) => {};

      return {
         ui: _ui,
         init: _init,
      };
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // if (this.parent) {
      //  return this.parent.componentList(false);
      // } else {

      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         "view",
         "page",
         "formpanel",
         "viewcontainer",
         // not allowed Detail's widgets
         "detailcheckbox",
         "detailcustom",
         "detailconnect",
         "detailimage",
         "detailselectivity",
         "detailtext",
         "detailtree",
         // not allowed Form's widgets
         "button",
         "checkbox",
         "connect",
         "datepicker",
         "fieldcustom",
         "textbox",
         "numberbox",
         "selectsingle",
         "selectmultiple",
         "formtree",
         "fieldreadonly",
         // not allowed Chart's Widgets
         "pie",
         "bar",
         "line",
         "area",
         // not allowed Report page
         "report",
         "reportPage",
         "reportPanel",
      ];

      var allComponents = this.application.viewAll(); // ABViewManager.allViews();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;

      // }
   }

   changePage(pageId) {
      this.emit("changePage", pageId);
   }

   // removeField(field, cb) {
   //    // if this view has matching field then destroy()
   //    if (this.settings.fieldId == field.id) {
   //       this.destroy()
   //          .then(() => {
   //             // signal the current view has been deleted.
   //             this.emit("destroyed", this);
   //             cb(null, true);
   //          })
   //          .catch((err) => {
   //             this.AB.error("Error trying to delete selected View:", {
   //                error: err,
   //                view: this,
   //             });
   //             cb(err);
   //          });
   //    } else {
   //       // if not check for subViews then call removeField on them

   //       var shouldSave = false;

   //       var finish = () => {
   //          if (shouldSave) {
   //             this.save()
   //                .then(() => {
   //                   cb();
   //                })
   //                .catch(cb);
   //          } else {
   //             cb();
   //          }
   //       };

   //       // for each sub view, view.removeField(field);
   //       var listViews = this.views();
   //       var done = 0;
   //       listViews.forEach((v) => {
   //          v.removeField(field, (err, updateMade) => {
   //             if (err) {
   //                cb(err);
   //             } else {
   //                if (updateMade) {
   //                   shouldSave = true;
   //                }

   //                done++;
   //                if (done >= listViews.length) {
   //                   finish();
   //                }
   //             }
   //          });
   //       });

   //       if (listViews.length == 0) {
   //          finish();
   //       }
   //    }
   // }
};


/***/ }),

/***/ 4818:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCSVExporter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCSVExporterCore = __webpack_require__(/*! ../../core/views/ABViewCSVExporterCore */ 50792);

const ABViewCSVExporterPropertyComponentDefaults =
   ABViewCSVExporterCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

let PropertyFilter = null;

module.exports = class ABViewCSVExporter extends ABViewCSVExporterCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewCsvExporterEditorComponent";
      let component = this.component(App, idBase);

      return component;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      let idBase = "ABViewCSVExporter";

      let commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      _logic.showFilterPopup = ($view) => {
         this.filter_popup.show($view, null, { pos: "top" });
      };

      _logic.onFilterChange = () => {
         let view = _logic.currentEditObject();
         let filterValues = PropertyFilter.getValue() || {};

         let allComplete = true;
         (filterValues.rules || []).forEach((f) => {
            // if all 3 fields are present, we are good.
            if (f.key && f.rule && f.value) {
               allComplete = allComplete && true;
            } else {
               // else, we found an entry that wasn't complete:
               allComplete = false;
            }
         });

         // only perform the update if a complete row is specified:
         if (allComplete) {
            // we want to call .save() but give webix a chance to properly update it's
            // select boxes before this call causes them to be removed:
            setTimeout(() => {
               this.propertyEditorSave(ids, view);
            }, 10);
         }
      };

      // create filter popups
      this.initPopupEditors(App, ids, _logic);

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         let currView = _logic.currentEditObject();

         // this.propertyUpdateRules(ids, currView);

         // refresh UI
         currView.emit("properties.updated", currView);

         // save
         currView.settings.dataviewID = dcId;
         this.propertyEditorValues(ids, currView);
         currView.save();
      };

      return commonUI.concat([
         {
            view: "fieldset",
            label: L("Data:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               rows: [
                  {
                     name: "datacollection",
                     view: "richselect",
                     label: L("Data Source"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     skipAutoSave: true,
                     on: {
                        onChange: _logic.selectSource,
                     },
                  },
                  {
                     name: "hasHeader",
                     view: "checkbox",
                     label: L("Header on first line"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  },
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Filter Option:"),
                           css: "ab-text-bold",
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "filterMenuButton",
                           css: "webix_primary",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.showFilterPopup(this.$view);
                           },
                        },
                     ],
                  },
               ],
            },
         },
         {
            view: "fieldset",
            label: L("Customize Display:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "buttonLabel",
                     view: "text",
                     label: L("Label"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
                  {
                     name: "filename",
                     view: "text",
                     label: L("File name"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
                  {
                     view: "counter",
                     name: "width",
                     label: L("Width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Pull data views to options
      let dcOptions = view.AB.datacollections().map((dc) => {
         return {
            id: dc.id,
            value: dc.label,
         };
      });

      let $DcSelector = $$(ids.datacollection);
      $DcSelector.define("options", dcOptions);
      $DcSelector.define("value", view.settings.dataviewID || null);
      $DcSelector.refresh();

      $$(ids.hasHeader).setValue(
         view.settings.hasHeader ||
            ABViewCSVExporterPropertyComponentDefaults.hasHeader
      );
      $$(ids.buttonLabel).setValue(
         view.settings.buttonLabel ||
            ABViewCSVExporterPropertyComponentDefaults.buttonLabel
      );
      $$(ids.filename).setValue(
         view.settings.filename ||
            ABViewCSVExporterPropertyComponentDefaults.filename
      );
      $$(ids.width).setValue(
         view.settings.width || ABViewCSVExporterPropertyComponentDefaults.width
      );

      // Populate data to popups
      // PropertyFilter.applicationLoad(view.application);
      let dc = view.datacollection;
      let obj = dc ? dc.datasource : null;
      if (obj) {
         PropertyFilter.fieldsLoad(obj.fields());
      } else {
         PropertyFilter.fieldsLoad([]);
      }
      PropertyFilter.setValue(view.settings.where);

      this.propertyBadgeNumber(ids, view);

      //   // when a change is made in the properties the popups need to reflect the change
      //   this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
      //   if (!this.updateEventIds[view.id]) {
      //      this.updateEventIds[view.id] = true;

      //      view.addListener("properties.updated", () => {
      //         this.populateBadgeNumber(ids, view);
      //      });
      //   }
   }

   static initPopupEditors(App, ids, _logic) {
      var idBase = "ABViewCSVExporterPropertyEditor";

      PropertyFilter = this.AB.filterComplexNew(`${idBase}_filter`);
      PropertyFilter.init();
      // when we make a change in the popups we want to make sure we save the new workspace to the properties to do so just fire an onChange event
      PropertyFilter.on("change", (val) => {
         _logic.onFilterChange(val);
      });

      this.filter_popup = webix.ui({
         view: "popup",
         width: 800,
         hidden: true,
         body: PropertyFilter.ui,
      });
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.hasHeader = $$(ids.hasHeader).getValue();
      view.settings.where = PropertyFilter.getValue();

      view.settings.buttonLabel =
         $$(ids.buttonLabel).getValue() ||
         ABViewCSVExporterPropertyComponentDefaults.buttonLabel;

      view.settings.filename =
         $$(ids.filename).getValue() ||
         ABViewCSVExporterPropertyComponentDefaults.filename;

      view.settings.width =
         $$(ids.width).getValue() ||
         ABViewCSVExporterPropertyComponentDefaults.width;

      this.propertyBadgeNumber(ids, view);
   }

   static propertyBadgeNumber(ids, view) {
      if (view.settings.where && view.settings.where.rules) {
         $$(ids.filterMenuButton).define(
            "badge",
            view.settings.where.rules.length
         );
         $$(ids.filterMenuButton).refresh();
      } else {
         $$(ids.filterMenuButton).define("badge", null);
         $$(ids.filterMenuButton).refresh();
      }
   }

   component(App, idBase) {
      idBase = idBase || "ABCSVExporter_" + this.id;
      let ids = {
         button: App.unique(`${idBase}_button`),
         buttonFilter: App.unique(`${idBase}_button_filter`),
         popupFilter: App.unique(`${idBase}_popup_filter`),
      };

      let ClientFilter = this.AB.filterComplexNew(`${idBase}_filter`);

      let _ui = {
         view: "layout",
         type: "clean",
         borderless: true,
         cols: [
            {
               id: ids.buttonFilter,
               view: "button",
               css: "webix_transparent",
               type: "icon",
               icon: "fa fa-filter",
               borderless: true,
               width: 50,
               label: "",
               click: () => {
                  _logic.showFilterPopup();
               },
            },
            {
               id: ids.button,
               view: "button",
               css: "webix_primary",
               type: "icon",
               icon: "fa fa-download",
               borderless: true,
               width:
                  this.settings.width ||
                  ABViewCSVExporterPropertyComponentDefaults.width,
               label:
                  this.settings.buttonLabel ||
                  ABViewCSVExporterPropertyComponentDefaults.buttonLabel,
               click: () => {
                  _logic.downloadCsvFile();
               },
            },
            { fillspace: true },
         ],
      };

      // make sure each of our child views get .init() called
      let _init = (options) => {
         let dc = this.datacollection;
         if (dc) {
            let obj = dc.datasource;

            // ClientFilter.applicationLoad(obj ? obj.application : null);
            ClientFilter.fieldsLoad(obj ? obj.fields() : [], obj);
         }

         ClientFilter.init();
         ClientFilter.on("change", (val) => {
            _logic.onFilterChange(val);
         });

         // webix.ui({
         //    view: "popup",
         //    id: ids.popupFilter,
         //    width: 800,
         //    hidden: true,
         //    body: ClientFilter.ui,
         // });
      };

      let _logic = (this._logic = {
         downloadCsvFile: () => {
            let url = `/appbuilder/csv-export/${this.id}`;
            let where = ClientFilter.getValue();

            if (where && (where.rules || []).length) {
               let qsWhere = JSON.stringify(where);
               qsWhere = encodeURIComponent(qsWhere);
               url = `${url}?where=${qsWhere}`;
            }

            window.open(url);
         },
         showFilterPopup: () => {
            let $buttonFilter = $$(ids.buttonFilter);
            ClientFilter.popUp($buttonFilter ? $buttonFilter.$view : null);
         },
         onFilterChange: () => {
            let $buttonFilter = $$(ids.buttonFilter);
            if (!$buttonFilter) return;

            let where = ClientFilter.getValue();
            $buttonFilter.define("badge", (where.rules || []).length || null);
            $buttonFilter.refresh();
         },
      });

      return {
         ui: _ui,
         init: _init,
      };
   }
};


/***/ }),

/***/ 92471:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCSVImporter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCSVImporterCore = __webpack_require__(/*! ../../core/views/ABViewCSVImporterCore */ 17876);
// import ClassUI from "../../../ui/ClassUI";
const ClassUI = (__webpack_require__(/*! ../../../ui/ClassUI */ 32735)["default"]);

const CSVImporter = __webpack_require__(/*! ../CSVImporter */ 26580);
const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 26204);

const ABViewCSVImporterPropertyComponentDefaults =
   ABViewCSVImporterCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);
// multilingual Label fn()

let PopupRecordRule = null;

class ABViewCSVImporterComponent extends ClassUI {
   constructor(viewCSVImporter, idBase) {
      idBase = idBase || `ABCSVImporter_${viewCSVImporter.id}`;

      super(idBase, {
         button: "",
         popup: "",

         form: "",
         uploader: "",
         uploadFileList: "",
         separatedBy: "",
         headerOnFirstLine: "",
         columnList: "",

         search: "",
         datatable: "",

         statusMessage: "",
         progressBar: "",

         importButton: "",
         rules: "",
      });

      this.viewCSVImporter = viewCSVImporter;
      // {ABViewCSVImporter}
      // The ABView that has created this CSVImporter.

      this.settings = this.viewCSVImporter.settings;
      // {json}
      // a local copy of the settings for our ABView

      this.csvImporter = new CSVImporter(L);
      // {CSVImporter}
      // An instance of the object that imports the CSV data.

      this._dataRows = null;

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this._csvFileInfo = null;

      this.validationError = false;
   }

   ui() {
      return {
         cols: [
            {
               view: "button",
               css: "webix_primary",
               type: "icon",
               icon: "fa fa-upload",
               label: L(
                  this.settings.buttonLabel ||
                     ABViewCSVImporterPropertyComponentDefaults.buttonLabel
               ),
               width:
                  this.settings.width ||
                  ABViewCSVImporterPropertyComponentDefaults.width,
               click: () => {
                  this.showPopup();
               },
            },
            {
               fillspace: true,
            },
         ],
      };
   }

   uiConfig() {
      var ids = this.ids;

      return {
         view: "form",
         type: "clean",
         id: ids.form,
         borderless: true,
         minWidth: 400,
         gravity: 1,
         elements: [
            {
               rows: [
                  {
                     id: ids.uploader,
                     view: "uploader",
                     name: "csvFile",
                     css: "webix_primary",
                     value: L("Choose a CSV file"),
                     accept: "text/csv",
                     multiple: false,
                     autosend: false,
                     link: ids.uploadFileList,
                     on: {
                        onBeforeFileAdd: (fileInfo) => {
                           this._csvFileInfo = fileInfo;
                           return this.loadCsvFile();
                        },
                     },
                  },
                  {
                     id: ids.uploadFileList,
                     name: "uploadedFile",
                     view: "list",
                     type: "uploader",
                     autoheight: true,
                     borderless: true,
                     onClick: {
                        webix_remove_upload: (e, id /*, trg */) => {
                           this.removeCsvFile(id);
                        },
                     },
                  },
                  {
                     padding: 10,
                     rows: [
                        {
                           id: ids.separatedBy,
                           view: "richselect",
                           name: "separatedBy",
                           label: L("Separated by"),
                           labelWidth: 140,
                           options: this.csvImporter.getSeparateItems(),
                           value: ",",
                           on: {
                              onChange: () => {
                                 this.loadCsvFile();
                              },
                           },
                        },
                        {
                           id: ids.headerOnFirstLine,
                           view: "checkbox",
                           name: "headerOnFirstLine",
                           label: L("Header on first line"),
                           labelWidth: 140,
                           disabled: true,
                           value: true,
                           on: {
                              onChange: (/*newVal, oldVal*/) => {
                                 this.populateColumnList();
                              },
                           },
                        },
                     ],
                  },
                  {
                     type: "space",
                     rows: [
                        {
                           view: "scrollview",
                           minHeight: 300,
                           body: {
                              padding: 10,
                              id: ids.columnList,
                              rows: [],
                           },
                        },
                     ],
                  },
               ],
            },
         ],
      };
   }

   uiRecordsView() {
      var ids = this.ids;
      return {
         gravity: 2,
         rows: [
            {
               view: "toolbar",
               css: "bg_gray",
               cols: [
                  { width: 5 },
                  {
                     id: ids.search,
                     view: "search",
                     value: "",
                     label: "",
                     placeholder: L("Search records..."),
                     keyPressTimeout: 200,
                     on: {
                        onTimedKeyPress: () => {
                           let text = $$(ids.search).getValue();
                           this.search(text);
                        },
                     },
                  },
                  { width: 2 },
               ],
            },
            {
               id: ids.datatable,
               view: "datatable",
               resizeColumn: true,
               editable: true,
               editaction: "dblclick",
               css: "ab-csv-importer",
               borderless: false,
               tooltip: (obj) => {
                  var tooltip = obj._errorMsg
                     ? obj._errorMsg
                     : "No validation errors";
                  return tooltip;
               },
               minWidth: 650,
               columns: [],
               on: {
                  onValidationError: function (id, obj, details) {
                     // console.log(`item ${id} invalid`);
                     var errors = "";
                     Object.keys(details).forEach((key) => {
                        this.$view.complexValidations[key].forEach((err) => {
                           errors += err.invalidMessage + "</br>";
                        });
                     });
                     var $dt = $$(ids.datatable);
                     $dt.blockEvent();
                     $dt.updateItem(id, {
                        _status: "invalid",
                        _errorMsg: errors,
                     });
                     $dt.unblockEvent();
                     this.validationError = true;
                  },
                  onValidationSuccess: function (id, obj, details) {
                     // console.log(`item ${id} valid`);
                     var $dt = $$(ids.datatable);
                     $dt.blockEvent();
                     $dt.updateItem(id, {
                        _status: "valid",
                        _errorMsg: "",
                     });
                     $dt.unblockEvent();
                     this.validationError = false;
                  },
                  onCheck: () => {
                     var selected = $$(ids.datatable).find({ _included: true });
                     $$(ids.importButton).setValue(this.labelImport(selected));
                     if (this.overLimitAlert(selected)) {
                        $$(ids.importButton).disable();
                     } else {
                        $$(ids.importButton).enable();
                     }
                  },
               },
            },
            {
               id: ids.progressBar,
               height: 6,
            },
            {
               view: "button",
               name: "import",
               id: ids.importButton,
               value: L("Import"),
               css: "webix_primary",
               disabled: true,
               click: () => {
                  this.import();
               },
            },
         ],
      };
   }

   uiPopup() {
      var ids = this.ids;

      return {
         id: ids.popup,
         view: "window",
         hidden: true,
         position: "center",
         modal: true,
         resize: true,
         head: {
            view: "toolbar",
            css: "webix_dark",
            cols: [
               {},
               {
                  view: "label",
                  label: L("CSV Importer"),
                  autowidth: true,
               },
               {},
               {
                  view: "button",
                  width: 35,
                  css: "webix_transparent",
                  type: "icon",
                  icon: "nomargin fa fa-times",
                  click: () => {
                     this.hide();
                  },
               },
            ],
         },
         body: {
            type: "form",
            rows: [
               {
                  type: "line",
                  cols: [
                     this.uiConfig(),
                     { width: 20 },
                     this.uiRecordsView(),
                     { width: 1 },
                  ],
               },
               {
                  id: ids.statusMessage,
                  view: "label",
                  align: "right",
                  hidden: true,
               },
               {
                  hidden: true,
                  margin: 5,
                  cols: [
                     { fillspace: true },
                     {
                        view: "button",
                        name: "cancel",
                        value: L("Cancel"),
                        css: "ab-cancel-button",
                        autowidth: true,
                        click: () => {
                           this.hide();
                        },
                     },
                     /*,
                        {
                           view: "button",
                           name: "import",
                           id: ids.importButton,
                           value: labels.component.import,
                           css: "webix_primary",
                           disabled: true,
                           autowidth: true,
                           type: "form",
                           click: () => {
                              _logic.import();
                           }
                        }*/
                  ],
               },
            ],
         },
      };
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }

   objectLoad(object) {
      this.CurrentObjectID = object?.id;
   }

   init(AB) {
      this.AB = AB;
      var ids = this.ids;

      // Populate values to rules

      let selectedDv = this.viewCSVImporter.datacollection;

      if (selectedDv) {
         this.CurrentObjectID = selectedDv.datasource.id;
      }

      webix.ui(this.uiPopup());

      if ($$(ids.form)) webix.extend($$(ids.form), webix.ProgressBar);
      if ($$(ids.progressBar))
         webix.extend($$(ids.progressBar), webix.ProgressBar);
   }

   showPopup() {
      $$(this.ids.popup)?.show();

      this.formClear();

      // open file dialog to upload
      $$(this.ids.uploader).fileDialog();
   }

   hide() {
      $$(this.ids.popup)?.hide();
   }

   formClear() {
      var ids = this.ids;
      this._dataRows = null;
      this._csvFileInfo = null;

      $$(ids.form).clearValidation();
      $$(ids.form).clear();
      $$(ids.separatedBy).setValue(",");

      webix.ui([], $$(ids.columnList));

      $$(ids.headerOnFirstLine).disable();
      $$(ids.importButton).disable();

      $$(ids.search).setValue("");
      $$(ids.uploadFileList).clearAll();
      $$(ids.datatable).clearAll();

      $$(ids.statusMessage).setValue("");
      $$(ids.statusMessage).hide();
   }

   search(searchText) {
      let $datatable = $$(this.ids.datatable);
      if (!$datatable) return;

      searchText = (searchText || "").toLowerCase();

      let matchFields = this.getMatchFields();

      $datatable.filter((row) => {
         let exists = false;

         (matchFields || []).forEach((f) => {
            if (exists) return;

            exists =
               (row[`${f.columnIndex}`] || "")
                  .toString()
                  .toLowerCase()
                  .indexOf(searchText) > -1;
         });

         return exists;
      });
   }

   statusTemplate(item) {
      let template = "";

      if (!item) return template;

      switch (item._status) {
         case "in-progress":
            template = "<span class='fa fa-refresh'></span>";
            break;
         case "invalid":
            template = "<span class='fa fa-exclamation-triangle'></span>";
            break;
         case "valid":
            template = "<span class='fa fa-check'></span>";
            break;
         case "done":
            template = "<span class='fa fa-check'></span>";
            break;
         case "fail":
            template = "<span class='fa fa-remove'></span>";
            break;
      }

      return template;
   }

   async loadCsvFile() {
      if (!this._csvFileInfo) return false;

      if (!this.csvImporter.validateFile(this._csvFileInfo)) {
         webix.alert({
            title: L("This file extension is not allowed"),
            text: L("Please only upload CSV files"),
            ok: L("Ok"),
         });

         return false;
      }

      var ids = this.ids;

      // show loading cursor
      $$(ids.form)?.showProgress?.({ type: "icon" });

      // read CSV file
      let separatedBy = $$(ids.separatedBy).getValue();
      this._dataRows = await this.csvImporter.getDataRows(
         this._csvFileInfo,
         separatedBy
      );

      $$(ids.headerOnFirstLine).enable();
      $$(ids.importButton).enable();
      let length = this._dataRows.length;
      if ($$(ids.headerOnFirstLine).getValue()) {
         length = this._dataRows.length - 1;
      }
      $$(ids.importButton).setValue(this.labelImport(length));

      this.populateColumnList();

      $$(ids.form)?.hideProgress?.();

      return true;
   }

   removeCsvFile(fileId) {
      $$(this.ids.uploadFileList).remove(fileId);
      this.formClear();
      return true;
   }

   populateColumnList() {
      var ids = this.ids;
      var self = this;

      // clear list
      webix.ui([], $$(ids.columnList));

      if (this._dataRows == null) return;

      // check first line of CSV
      let firstLine = this._dataRows[0];
      if (firstLine == null) return;

      let csvColumnList = [];
      let fieldList = [];
      if (this.CurrentObject) {
         fieldList =
            this.CurrentObject.fields((f) => {
               // available fields
               if (
                  this.settings.availableFieldIds?.length &&
                  this.settings.availableFieldIds.indexOf(f.id) < 0
               ) {
                  return false;
               }

               // filter editable fields
               let formComp = f.formComponent();
               if (!formComp) return true;

               let formConfig = formComp.common();
               if (!formConfig) return true;

               return formConfig.key != "fieldreadonly";
            }) || [];
      }
      // check first line be header columns
      if ($$(ids.headerOnFirstLine).getValue()) {
         csvColumnList = firstLine.map((colName, index) => {
            return {
               id: index + 1, // webix .options list disallow value 0
               value: colName,
               key: this.csvImporter.getGuessDataType(this._dataRows, index),
            };
         });
      } else {
         for (let i = 0; i < firstLine.length; i++) {
            csvColumnList.push({
               id: i + 1, // webix .options list disallow value 0
               value: L("Column {0}", [i + 1]),
               key: this.csvImporter.getGuessDataType(this._dataRows, i),
            });
         }
      }

      // Add unselect item
      csvColumnList.unshift({
         id: "none",
         value: L("None"),
      });

      // populate columns to UI
      let uiColumns = [];
      let selectedCsvCols = [];
      fieldList.forEach((f) => {
         let selectVal = "none";

         // match up by data type
         let matchCol = csvColumnList.filter(
            (c) => c.key == f.key && selectedCsvCols.indexOf(c.id) < 0
         )[0];
         if (matchCol) {
            selectVal = matchCol.id;

            // cache
            selectedCsvCols.push(selectVal);
         }

         let columnOptUI = {
            view: "richselect",
            gravity: 2,
            options: csvColumnList,
            fieldId: f.id,
            abName: "columnIndex",
            value: selectVal,
            on: {
               onChange: function () {
                  self.toggleLinkFields(this);
                  self.loadDataToGrid();
               },
            },
         };

         // Add date format options
         if (f.key == "date") {
            let dateSeparatorOptions = ["/", "-", ".", ",", " "];
            let dayFormatOptions = [
               { value: L("1 to 31"), id: "D" },
               { value: L("01 to 31"), id: "DD" },
            ];
            let monthFormatOptions = [
               { value: L("1 to 12"), id: "M" },
               { value: L("01 to 12"), id: "MM" },
            ];
            let yearFormatOptions = [
               { value: L("00 to 99"), id: "YY" },
               { value: L("2000 to 2099"), id: "YYYY" },
            ];
            let dateOrderOptions = [
               {
                  value: L("D-M-Y"),
                  id: 1,
               },
               {
                  value: L("M-D-Y"),
                  id: 2,
               },
               {
                  value: L("Y-M-D"),
                  id: 3,
               },
               {
                  value: L("Y-D-M"),
                  id: 4,
               },
            ];

            columnOptUI = {
               gravity: 2,
               rows: [
                  columnOptUI,
                  {
                     view: "richselect",
                     label: L("Separator"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "separator",
                     abName: "columnDateFormat",
                     options: dateSeparatorOptions,
                     value: "/",
                  },
                  {
                     view: "richselect",
                     label: L("Day"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "day",
                     abName: "columnDateFormat",
                     options: dayFormatOptions,
                     value: "D",
                  },
                  {
                     view: "richselect",
                     label: L("Month"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "month",
                     abName: "columnDateFormat",
                     options: monthFormatOptions,
                     value: "M",
                  },
                  {
                     view: "richselect",
                     label: L("Year"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "year",
                     abName: "columnDateFormat",
                     options: yearFormatOptions,
                     value: "YY",
                  },
                  {
                     view: "richselect",
                     label: L("Order"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "order",
                     abName: "columnDateFormat",
                     options: dateOrderOptions,
                     value: 1,
                  },
               ],
            };
         }

         // Add connected field options
         if (f.isConnection) {
            let linkFieldOptions = [];

            if (f.datasourceLink) {
               linkFieldOptions = f.datasourceLink
                  .fields((fld) => !fld.isConnection)
                  .map((fld) => {
                     return {
                        id: fld.id,
                        value: fld.label,
                     };
                  });
            }

            columnOptUI = {
               gravity: 2,
               rows: [
                  columnOptUI,
                  {
                     view: "richselect",
                     label: "=",
                     labelWidth: 20,
                     abName: "columnLinkData",
                     hidden: true,
                     options: linkFieldOptions,
                     value: linkFieldOptions[0] ? linkFieldOptions[0].id : null,
                  },
               ],
            };
         }

         uiColumns.push({
            view: "layout",
            borderless: true,
            cols: [
               {
                  view: "template",
                  gravity: 1,
                  borderless: true,
                  css: { "padding-top": 10 },
                  template: `<span class="fa fa-${f.icon}"></span> ${f.label}`,
               },
               columnOptUI,
            ],
         });
      });
      webix.ui(uiColumns, $$(ids.columnList));

      this.loadDataToGrid();
   }

   toggleLinkFields($columnOption) {
      if (!$columnOption) return;

      let $optionPanel = $columnOption.getParentView();
      let $linkFieldOption = $optionPanel.queryView(
         { abName: "columnLinkData" },
         "all"
      )[0];
      if (!$linkFieldOption) return;

      if ($columnOption.getValue() == "none") {
         $linkFieldOption.hide();
      } else {
         $linkFieldOption.show();
      }
   }

   overLimitAlert(data) {
      var limit = 1000;
      if (data.length > limit) {
         // we only allow 1000 record imports
         webix.alert({
            title: L("Too many records"),
            ok: L("Ok"),
            text: L(
               "Due to browser limitations we only allow imports of {0} records. Please upload a new CSV or deselect records to import.",
               [limit]
            ),
         });
         return true;
      }
      return false;
   }

   loadDataToGrid() {
      var ids = this.ids;
      let $datatable = $$(ids.datatable);
      if (!$datatable) return;

      $datatable.clearAll();

      // show loading cursor
      $datatable?.showProgress?.({ type: "icon" });

      /** Prepare Columns */
      let matchFields = this.getMatchFields();

      let columns = [];

      // add "status" column
      columns.push({
         id: "_status",
         header: "",
         template: this.statusTemplate,
         width: 30,
      });

      // add "checkbox" column
      columns.push({
         id: "_included",
         header: { content: "masterCheckbox" },
         template: "{common.checkbox()}",
         width: 30,
      });

      var fieldValidations = [];
      var rulePops = [];
      // populate columns
      (matchFields || []).forEach((f) => {
         var validationRules = f.field.settings.validationRules;
         // parse the rules because they were stored as a string
         // check if rules are still a string...if so lets parse them
         if (validationRules && typeof validationRules === "string") {
            validationRules = JSON.parse(validationRules);
         }

         if (validationRules && validationRules.length) {
            var validationUI = [];
            // there could be more than one so lets loop through and build the UI
            validationRules.forEach((rule) => {
               var Filter = this.AB.filterComplexNew(
                  `${f.field.id}_${webix.uid()}`
               );
               // add the new ui to an array so we can add them all at the same time
               validationUI.push(Filter.ui);
               // store the filter's info so we can assign values and settings after the ui is rendered
               fieldValidations.push({
                  filter: Filter,
                  view: Filter.ids.querybuilder,
                  columnName: f.field.id,
                  validationRules: rule.rules,
                  invalidMessage: rule.invalidMessage,
                  columnIndex: f.columnIndex,
               });
            });
            // create a unique view id for popup
            var popUpId = ids.rules + "_" + f.field.id + "_" + webix.uid();
            // store the popup ids so we can remove the later
            rulePops.push(popUpId);
            // add the popup to the UI but don't show it
            webix.ui({
               view: "popup",
               css: "ab-rules-popup",
               id: popUpId,
               body: {
                  rows: validationUI,
               },
            });
         }

         var editor = "text";
         switch (f.field.key) {
            case "number":
               editor = "number";
               break;
            default:
            // code block
         }
         columns.push({
            id: f.columnIndex,
            header: f.field.label,
            editor: editor,
            template: function (obj, common, value /*, col, ind */) {
               return value.replace(/[<]/g, "&lt;");
            },
            minWidth: 150,
            fillspace: true,
         });
      });

      if (fieldValidations.length) {
         // we need to store the rules for use later so lets build a container array
         var complexValidations = [];
         fieldValidations.forEach((f) => {
            // init each ui to have the properties (app and fields) of the object we are editing
            // f.filter.applicationLoad(App);
            f.filter.fieldsLoad(this.CurrentObject.fields());
            // now we can set the value because the fields are properly initialized
            f.filter.setValue(f.validationRules);
            // if there are validation rules present we need to store them in a lookup hash
            // so multiple rules can be stored on a single field
            if (!Array.isArray(complexValidations[f.columnName]))
               complexValidations[f.columnName] = [];

            // now we can push the rules into the hash
            complexValidations[f.columnName].push({
               filters: $$(f.view).getFilterHelper(),
               values: $$(ids.datatable).getSelectedItem(),
               invalidMessage: f.invalidMessage,
               columnIndex: f.columnIndex,
            });
         });
         var rules = {};
         var dataTable = $$(ids.datatable);
         // store the rules in a data param to be used later
         dataTable.$view.complexValidations = complexValidations;
         // use the lookup to build the validation rules
         Object.keys(complexValidations).forEach(function (key) {
            rules[key] = function (value, data) {
               // default valid is true
               var isValid = true;
               dataTable.$view.complexValidations[key].forEach((filter) => {
                  let rowValue = {};
                  // use helper funtion to check if valid
                  // map the column names to the index numbers of data
                  // reformat data to display
                  (matchFields || []).forEach((f) => {
                     let record = data[f.columnIndex];
                     if (
                        f.field.key == "date" &&
                        record.includes("Invalid date")
                     ) {
                        isValid = false;
                     }
                     rowValue[f.field.id] = record;
                  });
                  var ruleValid = filter.filters(rowValue);
                  // if invalid we need to tell the field
                  if (ruleValid == false) {
                     isValid = false;
                     // webix.message({
                     //    type: "error",
                     //    text: invalidMessage
                     // });
                  }
               });
               return isValid;
            };
         });
         // define validation rules
         dataTable.define("rules", rules);
         // store the array of view ids on the webix object so we can get it later
         dataTable.config.rulePops = rulePops;
         dataTable.refresh();
      } else {
         var dataTable = $$(ids.datatable);
         // check if the previous datatable had rule popups and remove them
         if (dataTable.config.rulePops) {
            dataTable.config.rulePops.forEach((popup) => {
               if ($$(popup)) $$(popup).destructor();
            });
         }
         // remove any validation rules from the previous table
         dataTable.define("rules", {});
         dataTable.refresh();
      }

      /** Prepare Data */
      let parsedData = [];

      (this._dataRows || []).forEach((row, index) => {
         let rowValue = {
            id: index + 1,
         };

         // reformat data to display
         (matchFields || []).forEach((f) => {
            let data = row[f.columnIndex - 1];

            if (f.field.key == "date") {
               // let dateFormat = moment(data, f.format).format(
               //    "YYYY-MM-DD"
               // );
               // debugger;
               let dateFormat = this.AB.toDate(data, { format: f.format });
               dateFormat = this.AB.toDateFormat(dateFormat, {
                  format: "YYYY-MM-DD",
               });
               if (dateFormat == "Invalid date") {
                  dateFormat = dateFormat + " - " + data;
               }
               rowValue[f.columnIndex] = dateFormat;
            } else {
               rowValue[f.columnIndex] = data; // array to object
            }
         });

         // insert "true" value of checkbox
         rowValue["_included"] = true;

         parsedData.push(rowValue);
      });

      // skip the first line
      let isSkipFirstLine = $$(ids.headerOnFirstLine).getValue();
      if (isSkipFirstLine && parsedData.length > 1) {
         parsedData = parsedData.slice(1);
      }

      $$(ids.importButton).setValue(this.labelImport(parsedData));

      $datatable.refreshColumns(columns);

      $datatable.parse(parsedData);

      if (this.overLimitAlert(parsedData)) {
         $$(ids.importButton).disable();
      } else {
         $$(ids.importButton).enable();
      }

      // hide loading cursor
      $datatable?.hideProgress?.();
   }

   refreshRemainingTimeText(startUpdateTime, total, index) {
      const ids = this.ids;

      // Calculate remaining time
      let spentTime = new Date() - startUpdateTime; // milliseconds that has passed since last completed record since start

      let averageRenderTime = spentTime / index; // average milliseconds per single render at this point

      let remainTime = averageRenderTime * (total - index);

      let result = "";

      // Convert milliseconds to a readable string
      let days = (remainTime / 86400000).toFixed(0);
      let hours = (remainTime / 3600000).toFixed(0);
      let minutes = (remainTime / 60000).toFixed(0);
      let seconds = (remainTime / 1000).toFixed(0);

      if (seconds < 1) result = "";
      else if (seconds < 60)
         result = L("Approximately {0} second(s) remaining", [seconds]);
      // result = `Approximately ${seconds} second${
      //    seconds > 1 ? "s" : ""
      // }`;
      else if (minutes == 1)
         result = L("Approximately 1 minute {0} seconds remaining", [
            seconds - 60,
         ]);
      // result = `Approximately 1 minute ${seconds - 60} seconds`;
      else if (minutes < 60)
         result = L("Approximately {0} minutes remaining", [minutes]);
      else if (hours < 24)
         result = L("Approximately {0} hour(s) remaining", [hours]);
      else result = L("Approximately {0} day(s) remaining", [days]);

      if (result) {
         $$(ids.importButton)?.setValue(result);
      } else {
         const selected = $$(ids.datatable)?.find({ _included: true });
         $$(ids.importButton)?.setValue(this.labelImport(selected));
      }
   }

   /**
    * @method getMatchFields
    *
    * @return {Object} - [
    *                      {
    *                         columnIndex: {number},
    *                         field: {ABField},
    *                         searchField: {ABField} [optional]
    *                      },
    *                      ...
    *                    ]
    */
   getMatchFields() {
      let result = [];
      var ids = this.ids;

      // get richselect components
      let $selectorViews = $$(ids.columnList)
         .queryView({ abName: "columnIndex" }, "all")
         .filter((selector) => selector.getValue() != "none");

      ($selectorViews || []).forEach(($selector) => {
         if (!this.CurrentObject) return;

         // webix .options list disallow value 0
         let colIndex = $selector.getValue();

         let field = this.CurrentObject.fieldByID($selector.config.fieldId);
         if (!field) return;

         let fieldData = {
            columnIndex: colIndex,
            field: field,
         };

         if (field.key == "date") {
            let $optionPanel = $selector.getParentView();
            let $dateFormatSelectors = $optionPanel.queryView(
               { abName: "columnDateFormat" },
               "all"
            );

            // define the column to compare data to search .id
            if ($dateFormatSelectors) {
               $dateFormatSelectors.forEach((selector) => {
                  fieldData[selector.config.name] = selector.getValue();
               });

               // convert all dates into mysql date format YYYY-DD-MM
               var format;
               switch (fieldData.order) {
                  case "1":
                     format =
                        fieldData.day +
                        fieldData.separator +
                        fieldData.month +
                        fieldData.separator +
                        fieldData.year;
                     break;
                  case "2":
                     format =
                        fieldData.month +
                        fieldData.separator +
                        fieldData.day +
                        fieldData.separator +
                        fieldData.year;
                     break;
                  case "3":
                     format =
                        fieldData.year +
                        fieldData.separator +
                        fieldData.month +
                        fieldData.separator +
                        fieldData.day;
                     break;
                  case "4":
                     format =
                        fieldData.year +
                        fieldData.separator +
                        fieldData.day +
                        fieldData.separator +
                        fieldData.month;
               }
               fieldData.format = format;
            }
         }

         if (field.isConnection) {
            let $optionPanel = $selector.getParentView();
            let $linkDataSelector = $optionPanel.queryView(
               { abName: "columnLinkData" },
               "all"
            )[0];

            // define the column to compare data to search .id
            if ($linkDataSelector) {
               let searchField = field.datasourceLink.fieldByID(
                  $linkDataSelector.getValue()
               );
               fieldData.searchField = searchField;
            }
         }

         result.push(fieldData);
      });

      return result;
   }

   labelImport(selected) {
      var length = selected;
      if (Array.isArray(selected)) length = selected.length;

      return L("Import {0} Records", [length]);
   }

   /**
    * @method import
    *
    * @return {Promise}
    */
   import() {
      // get ABDatacollection
      let dv = this.viewCSVImporter.datacollection;
      // if (dv == null) return Promise.resolve();

      // // get ABObject
      // let obj = dv.datasource;

      // Make sure we are connected to an Object
      let obj = this.CurrentObject;
      if (obj == null) return Promise.resolve();

      // get ABModel
      // let model = dv.model;
      // if (model == null) return Promise.resolve();

      var ids = this.ids;
      $$(ids.importButton).disable();

      // Show loading cursor
      $$(ids.form).showProgress({ type: "icon" });
      $$(ids.progressBar).showProgress({
         type: "top",
         position: 0.0001,
      });

      // get richselect components
      let matchFields = this.getMatchFields();

      // Get object's model
      let objModel = this.CurrentObject.model();

      let selectedRows = $$(ids.datatable).find({ _included: true });

      let _currProgress = 0;
      let increaseProgressing = () => {
         _currProgress += 1;
         $$(ids.progressBar).showProgress({
            type: "bottom",
            position: _currProgress / selectedRows.length,
         });
      };

      let itemFailed = (itemId, errMessage) => {
         let $datatable = $$(ids.datatable);
         if ($datatable) {
            // set "fail" status
            $datatable.addRowCss(itemId, "row-fail");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "fail",
               _errorMsg: errMessage,
            });
            $datatable.unblockEvent();
         }
         increaseProgressing();

         console.error(errMessage);
      };

      let itemInvalid = (itemId, errors = []) => {
         let $datatable = $$(ids.datatable);
         if ($datatable) {
            // combine all error messages to display in tooltip
            let errorMsg = [];
            // mark which column are invalid
            errors.forEach((err) => {
               if (!err || !err.name) return;
               let fieldInfo = matchFields.filter(
                  (f) => f.field && f.field.columnName == err.name
               )[0];
               errorMsg.push(err.name + ": " + err.message);
               // we also need to define an error message
               // webix.message({
               //    type: "error",
               //    text: err.name + ": " + err.message
               // });
            });
            // set "fail" status
            $$(ids.datatable).blockEvent();
            $$(ids.datatable).updateItem(itemId, {
               _status: "invalid",
               _errorMsg: errorMsg.join("</br>"),
            });
            $$(ids.datatable).unblockEvent();
            $datatable.addRowCss(itemId, "webix_invalid");
         }
         // increaseProgressing();
      };

      let itemPass = (itemId) => {
         let $datatable = $$(ids.datatable);
         if ($datatable) {
            // set "done" status
            $datatable.removeRowCss(itemId, "row-fail");
            $datatable.addRowCss(itemId, "row-pass");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "done",
               _errorMsg: "",
            });
            $datatable.unblockEvent();
         }
         increaseProgressing();
      };

      let itemValid = (itemId) => {
         let $datatable = $$(ids.datatable);
         if ($datatable) {
            // mark all columns valid (just in case they were invalid before)
            // matchFields.forEach((f) => {
            //    $datatable.removeCellCss(
            //       itemId,
            //       f.columnIndex,
            //       "webix_invalid_cell"
            //    );
            // });
            // highlight the row
            $datatable.removeRowCss(itemId, "webix_invalid");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "",
               _errorMsg: "",
            });
            $datatable.unblockEvent();
            // $datatable.addRowCss(itemId, "row-pass");
         }
      };

      let uiCleanUp = () => {
         // To Do anyUI updates
         // console.log("ui clean up now");
         $$(ids.importButton).enable();

         // Hide loading cursor
         $$(ids.form).hideProgress();
         $$(ids.progressBar).hideProgress();
         $$(ids.statusMessage).setValue("");
         $$(ids.statusMessage).hide();

         var selected = $$(ids.datatable).find({ _included: true });
         $$(ids.importButton).setValue(this.labelImport(selected));

         this.emit("done");
      };

      // Set parent's data collection cursor
      let dcLink = dv?.datacollectionLink;
      let objectLink;
      let linkConnectFields = [];
      let linkValues;
      if (dcLink && dcLink.getCursor()) {
         objectLink = dcLink.datasource;

         linkConnectFields = this.CurrentObject.fields(
            (f) => f.isConnection && f.settings.linkObject == objectLink.id
         );

         linkValues = dcLink.getCursor();
      }

      let allValid = true;
      let validRows = [];
      // Pre Check Validations of whole CSV import
      // update row to green if valid
      // update row to red if !valid
      (selectedRows || []).forEach((data, index) => {
         let newRowData = {};

         // Set parent's data collection cursor
         if (objectLink && linkConnectFields.length && linkValues) {
            linkConnectFields.forEach((f) => {
               let linkColName = f.indexField
                  ? f.indexField.columnName
                  : objectLink.PK();
               newRowData[f.columnName] = {};
               newRowData[f.columnName][linkColName] =
                  linkValues[linkColName] || linkValues.id;
            });
         }

         matchFields.forEach((f) => {
            if (!f.field || !f.field.key) return;

            switch (f.field.key) {
               // case "connectObject":
               //    // skip
               //    break;
               case "number":
                  if (typeof data[f.columnIndex] != "number") {
                     newRowData[f.field.columnName] = (
                        data[f.columnIndex] || ""
                     ).replace(/[^-0-9.]/gi, "");
                  } else {
                     newRowData[f.field.columnName] = data[f.columnIndex];
                  }
                  break;
               default:
                  newRowData[f.field.columnName] = data[f.columnIndex];
                  break;
            }
         });

         let isValid = false;
         let errorMsg = "";

         // first check legacy and server side validation
         let validator = this.CurrentObject.isValidData(newRowData);
         isValid = validator.pass();
         errorMsg = validator.errors;

         if (isValid) {
            // now check complex field validation rules
            isValid = $$(ids.datatable).validate(data.id);
         } else {
            allValid = false;
            itemInvalid(data.id, errorMsg);
         }
         if (isValid) {
            itemValid(data.id);
            validRows.push({ id: data.id, data: newRowData });
         } else {
            allValid = false;
         }
         // $$(ids.datatable).unblockEvent();
      });

      if (!allValid) {
         // To Do anyUI updates
         // $$(ids.importButton).enable();
         //
         // // Hide loading cursor
         // $$(ids.form).hideProgress();
         // $$(ids.progressBar).hideProgress();
         // $$(ids.statusMessage).setValue("");
         // $$(ids.statusMessage).hide();
         //
         // // _logic.hide();
         //
         // if (_logic.callbacks && _logic.callbacks.onDone)
         //    _logic.callbacks.onDone();
         uiCleanUp();

         webix.alert({
            title: L("Invalid Data"),
            ok: L("Ok"),
            text: L(
               "The highlighted row has invalid data. Please edit in the window or update the CSV and try again."
            ),
         });

         return Promise.resolve();
      }

      // if pass, then continue to process each row
      // ?? : can we process in Parallel?
      // ?? : implement hash Lookups for connected Fields
      var hashLookups = {};
      // {obj}  /*  { connectField.id : { 'searchWord' : "uuid"}}
      // use this hash to reduce the # of lookups needed to fill in our
      // connected entries

      let connectedFields = matchFields.filter(
         (f) => f && f.field && f.field.isConnection && f.searchField
      );

      let startUpdateTime;
      var numDone = 0;
      return Promise.resolve()
         .then(() => {
            // forEach connectedFields in csv

            var allLookups = [];

            (connectedFields || []).forEach((f) => {
               let connectField = f.field;
               let searchField = f.searchField;
               // let searchWord = newRowData[f.columnIndex];

               let connectObject = connectField.datasourceLink;
               if (!connectObject) return;

               let connectModel = connectObject.model();
               if (!connectModel) return;

               let linkIdKey = connectField.indexField
                  ? connectField.indexField.columnName
                  : connectField.object.PK();

               // prepare default hash entry:
               hashLookups[connectField.id] = {};

               // load all values of connectedField entries

               allLookups.push(
                  connectModel
                     .findAll({
                        where: {}, // !!!
                        populate: false,
                     })
                     .then((list) => {
                        if (list.data) {
                           list = list.data;
                        }
                        (list || []).forEach((row) => {
                           // store in hash[field.id] = { 'searchKey' : "uuid" }

                           hashLookups[connectField.id][
                              row[searchField.columnName]
                           ] = row[linkIdKey];
                        });
                     })
                     .catch((errMessage) => {
                        console.error(errMessage);
                     })
               );
            });

            return Promise.all(allLookups);
         })
         .then(() => {
            // forEach validRow
            validRows.forEach((data) => {
               let newRowData = data.data;

               // update the datagrid row to in-progress
               $$(ids.datatable).blockEvent();
               $$(ids.datatable).updateItem(data.id, {
                  _status: "in-progress",
                  _errorMsg: "",
               });
               $$(ids.datatable).unblockEvent();

               // forEach ConnectedField
               (connectedFields || []).forEach((f) => {
                  // find newRowData[field.columnName] = { field.PK : hash[field.id][searchWord] }
                  let connectField = f.field;
                  let linkIdKey = connectField.indexField
                     ? connectField.indexField.columnName
                     : connectField.object.PK();
                  var uuid =
                     hashLookups[connectField.id][
                        newRowData[connectField.columnName]
                     ];

                  if (!uuid) {
                     itemInvalid(data.id, [{ name: connectField.columnName }]);
                     allValid = false;
                  }

                  newRowData[connectField.columnName] = {};
                  newRowData[connectField.columnName][linkIdKey] = uuid;
               });
            });
         })
         .then(() => {
            if (!allValid) {
               webix.alert({
                  title: L("Invalid Data"),
                  ok: L("Ok"),
                  text: L(
                     "The highlighted row has invalid data. Please edit in the window or update the CSV and try again."
                  ),
               });
               uiCleanUp();

               return Promise.resolve();
            }
            // NOTE: Parallel exectuion of all these:
            var allSaves = [];

            const createRecord = (objModel, newRowsData, element, total) => {
               return new Promise((resolve, reject) => {
                  element.doRecordRulesPre(newRowsData);

                  objModel
                     .batchCreate({ batch: newRowsData })
                     .then((result) => {
                        var recordRules = [];

                        // Show errors of each row
                        Object.keys(result.errors).forEach((rowIndex) => {
                           let error = result.errors[rowIndex];
                           if (error) {
                              itemFailed(
                                 rowIndex,
                                 error.message || error.sqlMessage || error
                              );
                           }
                        });

                        Object.keys(result.data).forEach((rowIndex) => {
                           let rowData = result.data[rowIndex];
                           recordRules.push(
                              new Promise((next, err) => {
                                 // Process Record Rule
                                 element
                                    .doRecordRules(rowData)
                                    .then(() => {
                                       itemPass(rowIndex);
                                       next();
                                    })
                                    .catch((errMessage) => {
                                       itemFailed(rowIndex, errMessage);
                                       err("that didn't work");
                                    });
                              })
                           );
                        });
                        Promise.all(recordRules)
                           .then(() => {
                              newRowsData.forEach((row) => {
                                 // itemPass(row.id);
                                 numDone++;
                                 if (numDone % 50 == 0) {
                                    this.refreshRemainingTimeText(
                                       startUpdateTime,
                                       validRows.length,
                                       numDone
                                    );
                                 }
                              });
                              if (numDone == total) {
                                 uiCleanUp();
                                 $$(ids.importButton).disable();
                              }
                              resolve();
                           })
                           .catch((err) => {
                              // newRowsData.forEach((row) => {
                              //    itemFailed(row.id, err);
                              // });
                              reject(err);
                           });
                     })
                     .catch((errMessage) => {
                        console.error(errMessage);
                        reject(errMessage);
                     });
               });
            };

            validRows.forEach((data) => {
               let newRowData = data.data;
               allSaves.push({ id: data.id, data: newRowData });
            });

            // we are going to store these promises in an array of
            // arrays with 50 in each sub array
            var throttledSaves = [];
            var index = 0;
            var total = allSaves.length;
            while (allSaves.length) {
               throttledSaves[index] = allSaves.splice(0, 50);
               index++;
            }

            // execute the array of array of 100 promises one at at time
            function performThrottledSaves(
               currentRecords,
               remainingRecords,
               importer,
               total
            ) {
               // execute the next 100
               // const requests = currentRecords.map((data) => {
               //    return createRecord(
               //       objModel,
               //       data.record,
               //       data.data,
               //       importer
               //    );
               // });
               const requests = createRecord(
                  objModel,
                  currentRecords,
                  importer,
                  total
               );
               requests
                  .then(() => {
                     // when done get the next 10
                     var nextRecords = remainingRecords.shift();
                     // if there are any remaining in the group call performThrottledSaves
                     if (nextRecords && nextRecords.length) {
                        return performThrottledSaves(
                           nextRecords,
                           remainingRecords,
                           importer,
                           total
                        );
                     } else {
                        // uiCleanUp();
                        return Promise.resolve();
                     }
                  })
                  .catch((err) => {
                     // Handle errors here
                     return Promise.reject(err);
                  });
            }

            // now we are going to processes these new containers one at a time
            // $$(ids.datatable).blockEvent();
            // this is when the real work starts so lets begin our countdown timer now
            startUpdateTime = new Date();
            // get the first group of Promises out of the collection
            var next = throttledSaves.shift();
            // execute our Promise iterator
            return performThrottledSaves(
               next,
               throttledSaves,
               this.viewCSVImporter,
               total
            );
         })
         .catch((err) => {
            // resolve Error UI
            webix.alert({
               title: L("Error Creating Records"),
               ok: L("Ok"),
               text: L("One or more records failed upon creation."),
            });
            // $$(ids.datatable).unblockEvent();
            uiCleanUp();
            console.error(err);
         });
   }
}

module.exports = class ABViewCSVImporter extends ABViewCSVImporterCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewCsvImporterEditorComponent";
      let component = this.component(App, idBase);

      return component;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      let commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      let idBase = "ABViewCSVImporter";
      let L = App.Label;

      PopupRecordRule = new ABRecordRule();
      PopupRecordRule.component(App, idBase + "_recordrule"); // prepare the UI component.

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         let currView = _logic.currentEditObject();

         this.propertyUpdateRules(ids, currView);

         // refresh UI
         currView.emit("properties.updated", currView);

         currView.settings.dataviewID = dcId;

         this.propertyAvailableFields(ids, currView, { selectAll: true });

         // save
         currView.save();
      };

      _logic.listTemplate = (field, common) => {
         let currView = _logic.currentEditObject();

         let fieldComponent = field.formComponent();
         if (fieldComponent == null)
            return `<i class='fa fa-times'></i>  ${field.label} <div class='ab-component-form-fields-component-info'> Disable </div>`;

         let componentKey = fieldComponent.common().key;
         let formComponent = currView.application.viewAll(
            (v) => v.common().key == componentKey
         )[0];

         return `${common.markCheckbox(field)} ${
            field.label
         } <div class='ab-component-form-fields-component-info'> <i class='fa fa-${
            formComponent ? formComponent.common().icon : "fw"
         }'></i> ${
            formComponent ? L(formComponent.common().labelKey, "Label") : ""
         } </div>`;
      };

      _logic.check = (e, fieldId) => {
         // update UI list
         let item = $$(ids.fields).getItem(fieldId);
         item.selected = item.selected ? 0 : 1;
         $$(ids.fields).updateItem(fieldId, item);

         let currView = _logic.currentEditObject();
         this.propertyEditorValues(ids, currView);
         currView.save();
      };

      _logic.recordRuleShow = () => {
         let currView = _logic.currentEditObject();

         PopupRecordRule.formLoad(currView);
         PopupRecordRule.fromSettings(currView.settings.recordRules);
         PopupRecordRule.show();

         // Workaround
         PopupRecordRule.qbFixAfterShow();
      };

      _logic.recordRuleSave = (settings) => {
         let currView = _logic.currentEditObject();
         currView.settings.recordRules = settings;

         // trigger a save()
         this.propertyEditorSave(ids, currView);

         // update badge number of rules
         this.populateBadgeNumber(ids, currView);
      };

      PopupRecordRule.init({
         onSave: _logic.recordRuleSave,
      });

      return commonUI.concat([
         {
            view: "fieldset",
            label: L("ab.component.label.dataSource", "*Data:"),
            labelWidth: App.config.labelWidthLarge,
            body: {
               name: "datacollection",
               view: "richselect",
               label: L("ab.components.form.dataSource", "*Data Source"),
               labelWidth: App.config.labelWidthLarge,
               skipAutoSave: true,
               on: {
                  onChange: _logic.selectSource,
               },
            },
         },
         {
            view: "fieldset",
            label: L(
               "ab.component.csvImporter.availableFields",
               "*Available Fields:"
            ),
            labelWidth: App.config.labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "fields",
                     view: "list",
                     select: false,
                     minHeight: 250,
                     template: _logic.listTemplate,
                     type: {
                        markCheckbox: function (item) {
                           return (
                              "<span class='check webix_icon fa fa-" +
                              (item.selected ? "check-" : "") +
                              "square-o'></span>"
                           );
                        },
                     },
                     onClick: {
                        check: _logic.check,
                     },
                  },
               ],
            },
         },
         {
            view: "fieldset",
            label: L("ab.components.form.rules", "*Rules:"),
            labelWidth: App.config.labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: L(
                              "ab.components.form.recordRules",
                              "*Record Rules:"
                           ),
                           width: App.config.labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "buttonRecordRules",
                           css: "webix_primary",
                           label: L("ab.components.form.settings", "*Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.recordRuleShow();
                           },
                        },
                     ],
                  },
               ],
            },
         },
         {
            view: "fieldset",
            label: L(
               "ab.component.label.customizeDisplay",
               "*Customize Display:"
            ),
            labelWidth: App.config.labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "buttonLabel",
                     view: "text",
                     label: L("ab.components.csvImporter.label", "*Label"),
                     labelWidth: App.config.labelWidthXLarge,
                  },
                  {
                     view: "counter",
                     name: "width",
                     label: L("ab.components.csvImporter.width", "*Width:"),
                     labelWidth: App.config.labelWidthXLarge,
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Pull data views to options
      let dcOptions = view.propertyDatacollections();

      let $DcSelector = $$(ids.datacollection);
      $DcSelector.define("options", dcOptions);
      $DcSelector.define("value", view.settings.dataviewID || null);
      $DcSelector.refresh();

      $$(ids.buttonLabel).setValue(view.settings.buttonLabel);
      $$(ids.width).setValue(view.settings.width);

      // compatible to previous version
      let availableFldOptions = {};
      if (view.settings.availableFieldIds == null) {
         availableFldOptions.selectAll = true;
      }

      this.propertyAvailableFields(ids, view, availableFldOptions);
      this.propertyUpdateRules(ids, view);
      this.populateBadgeNumber(ids, view);

      // when a change is made in the properties the popups need to reflect the change
      this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
      if (!this.updateEventIds[view.id]) {
         this.updateEventIds[view.id] = true;

         view.addListener("properties.updated", () => {
            this.populateBadgeNumber(ids, view);
         });
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.buttonLabel = $$(ids.buttonLabel).getValue();
      view.settings.width = $$(ids.width).getValue();

      view.settings.availableFieldIds = [];
      let fields = $$(ids.fields).find({ selected: true });
      (fields || []).forEach((f) => {
         view.settings.availableFieldIds.push(f.id);
      });
   }

   static propertyAvailableFields(ids, view, options = {}) {
      let datacollection = view.AB.datacollections(
         (dc) => dc.id == view.settings.dataviewID
      )[0];
      let object = datacollection ? datacollection.datasource : null;

      view.settings = view.settings || {};
      let availableFields = view.settings.availableFieldIds || [];

      // Pull field list
      let fieldOptions = [];
      if (object != null) {
         fieldOptions = object.fields().map((f) => {
            f.selected = options.selectAll
               ? true
               : availableFields.filter((fieldId) => f.id == fieldId).length >
                 0;

            return f;
         });
      }

      $$(ids.fields).clearAll();
      $$(ids.fields).parse(fieldOptions);
   }

   static propertyUpdateRules(ids, view) {
      if (!view) return;

      // Populate values to rules
      let selectedDv = view.datacollection;
      if (selectedDv) {
         PopupRecordRule.objectLoad(selectedDv.datasource);
      }

      // PopupDisplayRule.formLoad(view);
      PopupRecordRule.formLoad(view);
   }

   static populateBadgeNumber(ids, view) {
      if (!view) return;

      if (view.settings.recordRules) {
         $$(ids.buttonRecordRules).define(
            "badge",
            view.settings.recordRules.length || null
         );
         $$(ids.buttonRecordRules).refresh();
      } else {
         $$(ids.buttonRecordRules).define("badge", null);
         $$(ids.buttonRecordRules).refresh();
      }
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(v1App = false, idBase) {
      var component = new ABViewCSVImporterComponent(this, idBase);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               return newComponent.init(this.AB, accessLevel);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }
};


/***/ }),

/***/ 21051:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCarousel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCarousel)
/* harmony export */ });
/* harmony import */ var _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyFilterData */ 84204);
/* harmony import */ var _viewProperties_ABViewPropertyLinkPage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 95782);

const ABViewCarouselCore = __webpack_require__(/*! ../../core/views/ABViewCarouselCore */ 96483);

// const ABViewPropertyFilterData = require("./viewProperties/ABViewPropertyFilterData");
// const ABViewPropertyLinkPage = require("./viewProperties/ABViewPropertyLinkPage");




const ABFieldImage = __webpack_require__(/*! ../dataFields/ABFieldImage */ 70780);

let L = (...params) => AB.Multilingual.label(...params);

let PopupCarouselFilterMenu = null;

class ABViewCarousel extends ABViewCarouselCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // filter property
      this.filterHelper.fromSettings(this.settings.filter);
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewCarouselEditorComponent";

      var CarouselComponent = this.component(App, idBase);

      return CarouselComponent;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var idBase = "ABViewCarouselPropertyEditor";

      let commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      PopupCarouselFilterMenu = _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_0__["default"].propertyComponent(
         App,
         idBase
      );
      this.linkPageComponent = _viewProperties_ABViewPropertyLinkPage__WEBPACK_IMPORTED_MODULE_1__["default"].propertyComponent(
         App,
         idBase
      );

      let filter_property_popup = webix.ui({
         view: "window",
         modal: true,
         position: "center",
         resize: true,
         width: 700,
         height: 450,
         css: "ab-main-container",
         head: {
            view: "toolbar",
            cols: [
               {
                  view: "label",
                  label: L("Filter Menu"),
               },
            ],
         },
         body: PopupCarouselFilterMenu.ui,
      });

      _logic.filterMenuShow = () => {
         var currView = _logic.currentEditObject();

         PopupCarouselFilterMenu.setSettings(currView.settings.filter);

         // show filter popup
         filter_property_popup.show();
      };

      _logic.filterSave = () => {
         var currView = _logic.currentEditObject();

         // hide filter popup
         filter_property_popup.hide();

         // refresh settings
         this.propertyEditorValues(ids, currView);

         // trigger a save()
         this.propertyEditorSave(ids, currView);
      };

      _logic.filterCancel = () => {
         // hide filter popup
         filter_property_popup.hide();
      };

      PopupCarouselFilterMenu.init({
         onSave: _logic.filterSave,
         onCancel: _logic.filterCancel,
      });

      return commonUI.concat([
         {
            view: "fieldset",
            label: L("Data:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "select",
                     name: "datacollection",
                     label: L("Object:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [],
                     on: {
                        onChange: function (newv, oldv) {
                           if (newv != oldv) {
                              $$(ids.detailsPage).setValue("");
                              $$(ids.editPage).setValue("");

                              let imageFields = [];

                              let dataCollection = _logic
                                 .currentEditObject()
                                 .AB.datacollectionByID(newv);
                              if (dataCollection) {
                                 let datasource = dataCollection.datasource;
                                 if (datasource) {
                                    imageFields =
                                       datasource
                                          .fields(
                                             (f) => f instanceof ABFieldImage
                                          )
                                          .map((f) => {
                                             return {
                                                id: f.id,
                                                value: f.label,
                                             };
                                          }) || [];
                                 }
                              }
                              if (imageFields.length > 0) {
                                 imageFields.unshift({
                                    id: "",
                                    value: L("Select a field"),
                                 });
                              } else {
                                 imageFields.unshift({
                                    id: "",
                                    value: L("no image fields."),
                                 });
                              }

                              $$(ids.field).define("options", imageFields);
                              $$(ids.field).refresh();
                           }
                        },
                     },
                  },

                  {
                     view: "select",
                     name: "field",
                     label: L("Image Field:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [],
                  },

                  {
                     view: "checkbox",
                     name: "filterByCursor",
                     labelWidth: 0,
                     labelRight: L("Filter images by cursor")
                  },
               ],
            },
         },

         this.linkPageComponent.ui,
         // {
         // 	view: "fieldset",
         // 	label: L('ab.component.label.linkedPages', '*Linked Pages:'),
         // 	labelWidth: this.AB.UISettings.config().labelWidthLarge,
         // 	body: {
         // 		type: "clean",
         // 		padding: 10,
         // 		rows: [
         // 			{
         // 				view: "select",
         // 				name: "detailsPage",
         // 				label: L('ab.component.label.detailsPage', '*Details Page:'),
         // 				labelWidth: this.AB.UISettings.config().labelWidthLarge,
         // 				options: []
         // 			},
         // 			{
         // 				view: "select",
         // 				name: "editPage",
         // 				label: L('ab.component.label.editForm', '*Edit Form:'),
         // 				labelWidth: this.AB.UISettings.config().labelWidthLarge,
         // 				options: []
         // 			}
         // 		]
         // 	}
         // },
         {
            view: "fieldset",
            label: L("Customize Display:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "select",
                     name: "navigationType",
                     label: L("Navigation Type"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [
                        { id: "corner", value: L("Corner") },
                        { id: "side", value: L("Side") },
                     ],
                  },

                  {
                     view: "checkbox",
                     name: "showLabel",
                     labelRight: L("Show label of image"),
                     labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
                  },

                  {
                     view: "checkbox",
                     name: "hideItem",
                     labelRight: L("Hide item list"),
                     labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
                  },

                  {
                     view: "checkbox",
                     name: "hideButton",
                     labelRight: L("Hide navigation buttons"),
                     labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
                  },

                  {
                     view: "counter",
                     name: "width",
                     label: L("Width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  },

                  {
                     view: "counter",
                     name: "height",
                     label: L("Height:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  },

                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Filter Option:"),
                           css: "ab-text-bold",
                           width: this.AB.UISettings.config().labelWidthXLarge,
                        },
                        {
                           view: "button",
                           id: ids.gridFilterMenuButton,
                           css: "webix_primary",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.filterMenuShow(this.$view);
                           },
                        },
                     ],
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      if (!view) return;

      // Set the objects you can choose from in the list
      // Pull data collections to options
      var objectOptions = view.propertyDatacollections();
      $$(ids.datacollection).define("options", objectOptions);
      $$(ids.datacollection).refresh();

      $$(ids.datacollection).setValue(view.settings.dataviewID);
      $$(ids.field).setValue(view.settings.field);
      $$(ids.filterByCursor).setValue(view.settings.filterByCursor);

      $$(ids.width).setValue(view.settings.width);
      $$(ids.height).setValue(view.settings.height);
      $$(ids.showLabel).setValue(view.settings.showLabel);
      $$(ids.hideItem).setValue(view.settings.hideItem);
      $$(ids.hideButton).setValue(view.settings.hideButton);
      $$(ids.navigationType).setValue(view.settings.navigationType);

      // Populate values to QueryBuilder
      var selectedDv = view.datacollection;
      if (selectedDv) {
         PopupCarouselFilterMenu.objectLoad(selectedDv.datasource);
      }

      // Populate values to link page properties
      this.linkPageComponent.viewLoad(view);
      this.linkPageComponent.setSettings(view.settings);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.field = $$(ids.field).getValue();
      view.settings.filterByCursor = $$(ids.filterByCursor).getValue() || false;

      view.settings.width = $$(ids.width).getValue();
      view.settings.height = $$(ids.height).getValue();
      view.settings.showLabel = $$(ids.showLabel).getValue();
      view.settings.hideItem = $$(ids.hideItem).getValue();
      view.settings.hideButton = $$(ids.hideButton).getValue();
      view.settings.navigationType = $$(ids.navigationType).getValue();

      // filter
      view.settings.filter = PopupCarouselFilterMenu.getSettings();

      // link pages
      let linkSettings = this.linkPageComponent.getSettings();
      for (let key in linkSettings) {
         view.settings[key] = linkSettings[key];
      }
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = this.idBase;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var dv = this.datacollection;
      if (dv) {
         this.filterHelper.objectLoad(dv.datasource);
         this.filterHelper.fromSettings(this.settings.filter);
      }

      let filterUI = this.filterHelper.component(App, idBase);
      let linkPage = this.linkPageHelper.component(App, idBase);

      let spacer = {};
      if (this.settings.width == 0) {
         spacer = {
            width: 1,
         };
      }

      let _ui = {
         borderless: true,
         cols: [
            spacer, // spacer
            {
               borderless: true,
               rows: [
                  filterUI.ui, // filter UI
                  {
                     id: ids.component,
                     view: "carousel",
                     cols: [],
                     width: this.settings.width,
                     height: this.settings.height,
                     navigation: {
                        items: !this.settings.hideItem,
                        buttons: !this.settings.hideButton,
                        type: this.settings.navigationType,
                     },
                     on: {
                        onShow: function () {
                           let activeIndex = $$(ids.component).getActiveIndex();
                           _logic.switchImage(activeIndex);
                        },
                     },
                  },
               ],
            },
            spacer, // spacer
         ],
      };

      // make sure each of our child views get .init() called
      let _init = (options) => {
         let dv = this.datacollection;
         if (!dv) return;

         let object = dv.datasource;
         if (!object) return;

         dv.on("loadData", () => {
            _logic.onShow();
         });
         dv.on("update", () => {
            dv.reloadData();
         });
         dv.on("delete", () => {
            dv.reloadData();
         });
         dv.on("create", () => {
            dv.reloadData();
         });
         dv.on("initializingData", () => {
            _logic.busy();
         });
         dv.on("initializedData", () => {
            _logic.ready();
         });

         if (this.settings.filterByCursor) {
            dv.on("changeCursor", () => {
               _logic.onShow();
            });
         }

         // filter helper
         this.filterHelper.objectLoad(object);
         this.filterHelper.viewLoad(this);

         filterUI.init({
            onFilterData: (fnFilter) => {
               _logic.onShow(fnFilter); // be notified when there is a change in the filter
            },
         });

         // link page helper
         linkPage.init({
            view: this,
            datacollection: dv,
         });

         // set data-cy
         const carousel = $$(ids.component).$view;
         carousel.setAttribute('data-cy', `${this.key} ${this.id}`);
         carousel
             .querySelector('.webix_nav_button_prev')
             ?.firstElementChild
             ?.setAttribute('data-cy', `${this.key} button previous ${this.id}`);
         carousel
             .querySelector('.webix_nav_button_next')
             ?.firstElementChild
             ?.setAttribute('data-cy', `${this.key} button next ${this.id}`);

      };

      let _logic = {
         myTemplate: (row) => {
            if (row && row.src) {
               let template =
                  `<div class="ab-carousel-image-container">` +
                  `<img src="${row.src}" class="content" ondragstart="return false" />` +
                  (this.settings.showLabel
                     ? `<div class="ab-carousel-image-title">${
                          row.label || ""
                       }</div>`
                     : "") +
                  `<div class="ab-carousel-image-icon">` +
                  (this.settings.detailsPage || this.settings.detailsTab
                     ? `<span ab-row-id="${row.id}" class="ab-carousel-detail webix_icon fa fa-eye"></span>`
                     : "") +
                  (this.settings.editPage || this.settings.editTab
                     ? `<span ab-row-id="${row.id}" class="ab-carousel-edit webix_icon fa fa-pencil"></span>`
                     : "") +
                  `<span class="webix_icon ab-carousel-fullscreen fa fa-arrows-alt"></span>` +
                  `<span style="display: none;" class="webix_icon ab-carousel-exit-fullscreen fa fa-times"></span>` +
                  `</div>` +
                  `</div>`;

               return template;
            } // empty image
            else return "";
         },

         busy: () => {
            let Carousel = $$(ids.component);

            Carousel.disable();

            if (Carousel.showProgress) Carousel.showProgress({ type: "icon" });
         },

         ready: () => {
            let Carousel = $$(ids.component);

            Carousel.enable();

            if (Carousel.hideProgress) Carousel.hideProgress();
         },

         switchImage: async (current_position) => {
            let dv = this.datacollection;
            if (!dv) return;

            // Check want to load more images
            if (
               current_position >= this._imageCount - 1 && // check last image
               dv.totalCount > this._rowCount
            ) {
               // loading cursor
               _logic.busy();

               try {
                  await dv.loadData(this._rowCount || 0);
               } catch (err) {
                  App.AB.notify.developer(err, {
                     message: "Error when load data from a Data collection",
                  });
               }

               _logic.ready();
            }
         },

         onShow: (fnFilter) => {
            let dv = this.datacollection;
            if (!dv) return;

            let obj = dv.datasource;
            if (!obj) return;

            let field = this.imageField;
            if (!field) return;

            if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
               // load data when a widget is showing
               dv.loadData();

               // it will call .onShow again after dc loads completely
               return;
            }

            fnFilter = fnFilter || filterUI.getFilter();

            let rows = dv.getData(fnFilter);

            // Filter images by cursor
            if (this.settings.filterByCursor) {
               let cursor = dv.getCursor();
               if (cursor) {
                  rows = rows.filter(
                     (r) =>
                        (r[obj.PK()] || r.id || r) ==
                        (cursor[obj.PK()] || cursor.id || cursor)
                  );
               }
            }

            let images = [];

            rows.forEach((r) => {
               let imgFile = r[field.columnName];
               if (imgFile) {
                  let imgData = {
                     id: r.id,
                     src: `/file/${imgFile}`,
                  };

                  // label of row data
                  if (this.settings.showLabel) {
                     imgData.label = obj.displayData(r);
                  }

                  images.push({
                     css: "image",
                     borderless: true,
                     template: _logic.myTemplate,
                     data: imgData,
                  });
               }
            });

            // insert the default image to first item
            if (field.settings.defaultImageUrl) {
               images.unshift({
                  css: "image",
                  template: _logic.myTemplate,
                  data: {
                     id: this.AB.uuid(),
                     src: `/file/${field.settings.defaultImageUrl}`,
                     label: L("Default image"),
                  },
               });
            }

            // empty image
            if (images.length < 1) {
               images.push({
                  rows: [
                     {
                        view: "label",
                        align: "center",
                        height: this.settings.height,
                        label:
                           "<div style='display: block; font-size: 180px; background-color: #666; color: transparent; text-shadow: 0px 1px 1px rgba(255,255,255,0.5); -webkit-background-clip: text; -moz-background-clip: text; background-clip: text;' class='fa fa-picture-o'></div>",
                     },
                     {
                        view: "label",
                        align: "center",
                        label: L("No image"),
                     },
                  ],
               });
            }

            // store total of rows
            this._rowCount = rows.length;

            // store total of images
            this._imageCount = images.length;

            var Carousel = $$(ids.component);

            // re-render
            webix.ui(images, Carousel);

            // add loading cursor
            if (Carousel) webix.extend(Carousel, webix.ProgressBar);

            // link pages events
            let editPage = this.settings.editPage;
            let detailsPage = this.settings.detailsPage;

            // if (detailsPage || editPage) {
            $$(ids.component).$view.onclick = (e) => {
               if (e.target.className) {
                  if (e.target.className.indexOf("ab-carousel-edit") > -1) {
                     webix.html.removeCss(
                        $$(ids.component).getNode(),
                        "fullscreen"
                     );
                     webix.fullscreen.exit();
                     let rowId = e.target.getAttribute("ab-row-id");
                     linkPage.changePage(editPage, rowId);
                  } else if (
                     e.target.className.indexOf("ab-carousel-detail") > -1
                  ) {
                     webix.html.removeCss(
                        $$(ids.component).getNode(),
                        "fullscreen"
                     );
                     webix.fullscreen.exit();
                     let rowId = e.target.getAttribute("ab-row-id");
                     linkPage.changePage(detailsPage, rowId);
                  } else if (
                     e.target.className.indexOf("ab-carousel-fullscreen") > -1
                  ) {
                     $$(ids.component).define("css", "fullscreen");
                     webix.fullscreen.set(ids.component, {
                        head: {
                           view: "toolbar",
                           css: "webix_dark",
                           elements: [
                              {},
                              {
                                 view: "icon",
                                 icon: "fa fa-times",
                                 click: function () {
                                    webix.html.removeCss(
                                       $$(ids.component).getNode(),
                                       "fullscreen"
                                    );
                                    webix.fullscreen.exit();
                                 },
                              },
                           ],
                        },
                     });
                  }
               }
            };
            // }
         },

         showFilterPopup: ($view) => {
            filterUI.showPopup($view);
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _logic.onShow,
      };
   }

   get idBase() {
      return `ABViewCarousel_${this.id}`;
   }

   get filterHelper() {
      if (this.__filterHelper == null)
         this.__filterHelper = new _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_0__["default"](this.AB, this.idBase);

      return this.__filterHelper;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new _viewProperties_ABViewPropertyLinkPage__WEBPACK_IMPORTED_MODULE_1__["default"]();

      return this.__linkPageHelper;
   }
};


/***/ }),

/***/ 67373:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChart.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartCore = __webpack_require__(/*! ../../core/views/ABViewChartCore */ 31311);

const ABViewChartPropertyComponentDefaults = ABViewChartCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewChart extends ABViewChartCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var comp = super.editorComponent(App, mode);

      // Define height of cell
      comp.ui.rows[0].cellHeight = 400;

      return comp;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );
      this._App = App; // #Hack!!

      _logic.enableMultipleSeries = (isEnable) => {
         var currView = _logic.currentEditObject();

         if (isEnable) {
            this.populateFieldOptions2(ids, currView);
         } else {
            $$(ids.columnValue2).define("options", []);
            $$(ids.columnValue2).refresh();
            $$(ids.columnValue2).disable();
         }
      };
      return commonUI.concat([
         {
            name: "multipleSeries",
            view: "checkbox",
            label: L("Multiple Series"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            on: {
               onChange: _logic.enableMultipleSeries,
            },
         },
         {
            name: "dataview",
            view: "richselect",
            label: L("Chart Data"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "columnLabel",
            view: "richselect",
            label: L("Label Column"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "columnValue",
            view: "richselect",
            label: L("Value Column"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "columnValue2",
            view: "richselect",
            label: L("Value Column 2"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "isPercentage",
            view: "checkbox",
            labelRight: L("Percentage"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            name: "showLabel",
            view: "checkbox",
            label: L("Display Label"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "labelPosition",
            view: "richselect",
            label: L("Label Position"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "left",
                  value: L("Left"),
               },
               {
                  id: "top",
                  value: L("Top"),
               },
            ],
         },
         {
            name: "labelWidth",
            view: "counter",
            label: L("Label Width"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      this.populateDataview(ids, view);
      this.populateFieldOptions(ids, view);

      $$(ids.multipleSeries).setValue(
         view.settings.multipleSeries ||
            ABViewChartPropertyComponentDefaults.multipleSeries
      );
      $$(ids.dataview).setValue(
         view.settings.dataviewID ||
            ABViewChartPropertyComponentDefaults.dataviewID
      );
      $$(ids.columnValue).setValue(
         view.settings.columnValue ||
            ABViewChartPropertyComponentDefaults.columnValue
      );
      $$(ids.columnLabel).setValue(
         view.settings.columnLabel ||
            ABViewChartPropertyComponentDefaults.columnLabel
      );
      $$(ids.isPercentage).setValue(
         view.settings.isPercentage != null
            ? view.settings.isPercentage
            : ABViewChartPropertyComponentDefaults.isPercentage
      );

      $$(ids.showLabel).setValue(
         view.settings.showLabel ||
            ABViewChartPropertyComponentDefaults.showLabel
      );
      $$(ids.labelPosition).setValue(
         view.settings.labelPosition ||
            ABViewChartPropertyComponentDefaults.labelPosition
      );
      $$(ids.labelWidth).setValue(
         view.settings.labelWidth ||
            ABViewChartPropertyComponentDefaults.labelWidth
      );
      $$(ids.height).setValue(
         view.settings.height || ABViewChartPropertyComponentDefaults.height
      );

      if (view.settings.multipleSeries) {
         this.populateFieldOptions2(ids, view);
         $$(ids.columnValue2).setValue(
            view.settings.columnValue2 ||
               ABViewChartPropertyComponentDefaults.columnValue2
         );
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.multipleSeries = $$(ids.multipleSeries).getValue();
      view.settings.dataviewID = $$(ids.dataview).getValue();
      view.settings.columnValue = $$(ids.columnValue).getValue();
      view.settings.columnLabel = $$(ids.columnLabel).getValue();
      view.settings.isPercentage = $$(ids.isPercentage).getValue();

      view.settings.showLabel = $$(ids.showLabel).getValue();
      view.settings.labelPosition = $$(ids.labelPosition).getValue();
      view.settings.labelWidth = $$(ids.labelWidth).getValue();
      view.settings.height = $$(ids.height).getValue();

      this.populateFieldOptions(ids, view);

      if (view.settings.multipleSeries) {
         view.settings.columnValue2 = $$(ids.columnValue2).getValue();
         this.populateFieldOptions2(ids, view);
      }

      // UPDATE charts when parent properties are changed
      view.views().forEach((v) => {
         v.parent.refreshData();
      });
   }

   static populateDataview(ids, view) {
      // Set the objects you can choose from in the list
      var objectOptions = view.propertyDatacollections();

      $$(ids.dataview).define("options", objectOptions);
      $$(ids.dataview).refresh();
   }

   static populateFieldOptions(ids, view) {
      // clear options
      $$(ids.columnLabel).define("options", []);
      $$(ids.columnLabel).refresh();

      $$(ids.columnValue).define("options", []);
      $$(ids.columnValue).refresh();

      var dc = view.datacollection;
      if (dc == null) return;

      var obj = dc.datasource;
      if (obj == null) return;

      var allFields = obj.fields();
      var numFields = obj.fields(
         (f) => f.key == "number" || f.key == "formula" || f.key == "calculate"
      );

      var convertOption = (opt) => {
         return {
            id: opt.id,
            value: opt.columnName,
            key: opt.key,
         };
      };

      var columnLabelOptions = allFields.map(convertOption);
      var columnValueOptions = numFields.map(convertOption);

      var defaultOption = {
         id: "",
         value: L("Select a column"),
         key: "",
      };
      columnLabelOptions.unshift(defaultOption);
      columnValueOptions.unshift(defaultOption);

      $$(ids.columnLabel).define("options", columnLabelOptions);
      $$(ids.columnLabel).refresh();
      $$(ids.columnLabel).enable();

      $$(ids.columnValue).define("options", columnValueOptions);
      $$(ids.columnValue).refresh();
      $$(ids.columnValue).enable();
   }

   static populateFieldOptions2(ids, view) {
      // clear options
      $$(ids.columnValue2).define("options", []);
      $$(ids.columnValue2).refresh();
      $$(ids.columnValue2).enable();

      var dc = view.datacollection;
      if (dc == null) return;

      var obj = dc.datasource;
      if (obj == null) return;

      var numFields = obj.fields((f) => f.key == "number");

      var convertOption = (opt) => {
         return {
            id: opt.id,
            value: opt.columnName,
            key: opt.key,
         };
      };

      var columnValueOptions = numFields.map(convertOption);

      var defaultOption = {
         id: "",
         value: L("Select a column"),
         key: "",
      };
      columnValueOptions.unshift(defaultOption);

      $$(ids.columnValue2).define("options", columnValueOptions);
      $$(ids.columnValue2).refresh();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = "ABViewChart_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      // get webix.dashboard
      var container = super.component(App);

      var _ui = {
         type: "form",
         borderless: true,
         // height: this.settings.height || ABViewChartPropertyComponentDefaults.height,
         rows: [
            {
               // view: "scrollview",
               body: container.ui,
            },
         ],
      };

      // make sure each of our child views get .init() called
      var _init = (options, accessLevel) => {
         container.init(options, accessLevel);

         var currentComponent = $$(ids.component);
         if (currentComponent) {
            webix.extend(currentComponent, webix.ProgressBar);
         }

         let dc = this.datacollection;
         if (dc) {
            if (dc.datacollectionLink) {
               this.eventAdd({
                  emitter: dc.datacollectionLink,
                  eventName: "changeCursor",
                  listener: () => this.refreshData(),
               });
            }

            this.eventAdd({
               emitter: dc,
               eventName: "changeCursor",
               listener: () => this.refreshData(),
            });

            this.eventAdd({
               emitter: dc,
               eventName: "create",
               listener: () => this.refreshData(),
            });

            this.eventAdd({
               emitter: dc,
               eventName: "update",
               listener: () => this.refreshData(),
            });

            this.eventAdd({
               emitter: dc,
               eventName: "delete",
               listener: () => this.refreshData(),
            });

            this.eventAdd({
               emitter: dc,
               eventName: "initializedData",
               listener: () => this.refreshData(),
            });
         }
      };

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: container.onShow,
      };
   }

   getReportData() {
      if (!this.dcChart) {
         this.dcChart = new webix.DataCollection();
      }

      return this.dcChart;
   }

   refreshData() {
      var dc = this.datacollection;
      if (dc == null) return this.dcChart;

      var labelCol = this.labelField();
      var valueCol = this.valueField();
      var valueCol2 = this.valueField2();

      if (!labelCol || !valueCol) return this.dcChart;

      // var labelColName = labelCol.columnName;
      var numberColName = valueCol.columnName;

      var numberColName2 = "";
      if (this.settings.multipleSeries && valueCol2) {
         numberColName2 = valueCol2.columnName;
      }

      var colorList = [
         "#ee4339",
         "#ee9336",
         "#eed236",
         "#d3ee36",
         "#a7ee70",
         "#58dccd",
         "#36abee",
         "#476cee",
         "#a244ea",
         "#e33fc7",
      ];

      var dInfo = dc.getData();

      var result = [];
      var sumData = {};
      var sumNumber = 0;
      var sumNumber2 = 0;
      var countNumber = dInfo.length;
      var obj;

      switch (valueCol.key) {
         case "formula":
            {
               obj = valueCol.object;
               var objLink = this.AB.objectByID(valueCol.settings.object);
               var fieldBase = obj.fieldByID(valueCol.settings.field);
               var fieldLink = objLink.fieldByID(valueCol.settings.fieldLink);
            }
            break;

         case "calculate":
            {
               obj = valueCol.object;
               var place = valueCol.settings.decimalPlaces;
            }
            break;

         default:
            break;
      }

      dInfo.forEach((item) => {
         var labelKey = labelCol.format(item) || item.id;
         var numberVal = parseFloat(item[numberColName] || 0);
         if (this.settings.multipleSeries) {
            var numberVal2 = parseFloat(item[numberColName2]) || 0;
         }

         switch (valueCol.key) {
            //Formula Datatype
            case "formula":
               {
                  var data = item[fieldBase.relationName()];
                  if (!Array.isArray(data)) {
                     data = [data];
                  }
                  var numberList = [];

                  // pull number from data
                  switch (fieldLink.key) {
                     case "calculate":
                        data.forEach((d) => {
                           numberList.push(
                              parseFloat(fieldLink.format(d) || 0)
                           );
                        });
                        break;
                     case "number":
                        numberList = data.map(
                           (d) => d[fieldLink.columnName] || 0
                        );
                        break;
                  }

                  var result = 0;

                  // calculate
                  switch (valueCol.settings.type) {
                     case "sum":
                        numberList.forEach((num) => (result += num));
                        break;
                     case "average":
                        if (numberList.length > 0) {
                           numberList.forEach((num) => (result += num)); // sum
                           result = result / numberList.length;
                        }
                        break;
                     case "max":
                        numberList.forEach((num) => {
                           if (result < num) result = num;
                        });
                        break;
                     case "min":
                        numberList.forEach((num) => {
                           if (result > num) result = num;
                        });
                        break;
                     case "count":
                        result = numberList.length;
                        break;
                  }
                  numberVal = result;
               }
               break;

            //Calcualte Datatype
            case "calculate":
               {
                  var formula = valueCol.settings.formula;
                  // replace with current date
                  formula = formula.replace(/\(CURRENT\)/g, "(new Date())");

                  obj.fields().forEach((f) => {
                     var colName = f.columnName;
                     if (colName.indexOf(".") > -1)
                        // QUERY: get only column name
                        colName = colName.split(".")[1];

                     // if template does not contain, then should skip
                     if (formula.indexOf(`{${colName}}`) < 0) return;

                     // number fields
                     if (f.key == "number") {
                        let numberVal = `(${item[f.columnName] || 0})`; // (number) - NOTE : (-5) to support negative number
                        formula = formula.replace(
                           new RegExp(`{${colName}}`, "g"),
                           numberVal
                        );
                     }
                     // calculate and formula fields
                     else if (f.key == "calculate" || f.key == "formula") {
                        let calVal = `(${f.format(item) || 0})`;
                        formula = formula.replace(
                           new RegExp(`{${colName}}`, "g"),
                           calVal
                        );
                     }
                     // date fields
                     else if (f.key == "date") {
                        let dateVal = `"${
                           item[f.columnName] ? item[f.columnName] : ""
                        }"`; // "date"
                        formula = formula.replace(
                           new RegExp(`{${colName}}`, "g"),
                           dateVal
                        );
                     }
                     // boolean fields
                     else if (f.key == "boolean") {
                        let booleanVal = `(${item[f.columnName] || 0})`; // show 1 or 0 for boolean
                        formula = formula.replace(
                           new RegExp(`{${colName}}`, "g"),
                           booleanVal
                        );
                     }
                  });

                  // decimal places - toFixed()
                  // FIX: floating number calculation
                  // https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
                  numberVal = parseFloat(eval(formula).toFixed(place || 0));
               }
               break;

            default:
               break;
         }
         if (sumData[labelKey] == null) {
            var label = labelKey;

            // Get label of the connect field
            if (labelCol.isConnection) {
               var relateValues = labelCol.pullRelationValues(item);
               if (relateValues != null) {
                  if (Array.isArray(relateValues))
                     label = relateValues
                        .map((val) => val.text || "")
                        .join(", ");
                  else label = relateValues.text;
               }
            }

            if (this.settings.multipleSeries) {
               sumData[labelKey] = {
                  label: label || item.id,
                  value: 0,
                  value2: 0,
               };
            } else {
               sumData[labelKey] = {
                  label: label || item.id,
                  value: 0,
               };
            }
         }

         sumData[labelKey].value += numberVal;
         sumNumber += numberVal;

         if (this.settings.multipleSeries) {
            sumData[labelKey].value2 += numberVal2;
            sumNumber2 += numberVal2;
         }
      });

      var index = 0;

      for (var key in sumData) {
         var val = sumData[key].value;
         if (val <= 0) continue;

         // Display to percent values
         if (this.settings.isPercentage) {
            val = (val / sumNumber) * 100;
            val = Math.round(val * 100) / 100; // round decimal 2 digits
            val = val + " %";
         }

         if (this.settings.multipleSeries) {
            var val2 = sumData[key].value2;
            if (val2 <= 0) continue;

            // Display to percent values
            if (this.settings.isPercentage) {
               val2 = (val2 / sumNumber2) * 100;
               val2 = Math.round(val2 * 100) / 100; // round decimal 2 digits
               val2 = val2 + " %";
            }

            result.push({
               label: sumData[key].label,
               value: val,
               value2: val2,
               color: colorList[index % colorList.length],
               count: countNumber,
            });
         } else {
            result.push({
               label: sumData[key].label,
               value: val,
               color: colorList[index % colorList.length],
               count: countNumber,
            });
         }

         index += 1;
      }

      let dcChart = this.getReportData();
      dcChart.clearAll();
      dcChart.parse(result);

      this.emit("refreshData", this.dcChart);
   }
};


/***/ }),

/***/ 17924:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartArea.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartAreaCore = __webpack_require__(/*! ../../core/views/ABViewChartAreaCore */ 46202);

const ABViewChartAreaPropertyComponentDefaults = ABViewChartAreaCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewChartArea extends ABViewChartAreaCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewChartAreaEditorComponent";
      let ids = {
         component: App.unique(`${idBase}_component`),
      };
      let baseEditor = super.editorComponent(App, mode, {
         componentId: ids.component,
      });

      return baseEditor;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "areaType",
            view: "richselect",
            label: L("Chart Type"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "area",
                  value: L("Area"),
               },
               {
                  id: "stackedArea",
                  value: L("Stacked Area"),
               },
            ],
         },
         // {
         // 	name: 'chartWidth',
         // 	view: 'counter',
         // 	min: 1,
         // 	label: L('ab.component.chart.area.chartWidth', '*Width')
         // },
         {
            name: "chartHeight",
            view: "counter",
            min: 1,
            label: L("Height"),
         },
         {
            name: "stepValue",
            view: "counter",
            min: 1,
            label: L("Step"),
         },
         {
            name: "maxValue",
            view: "counter",
            min: 1,
            label: L("Max Value"),
         },
         {
            name: "labelFontSize",
            view: "counter",
            min: 1,
            label: L("Label Font Size"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            name: "isLegend",
            view: "checkbox",
            labelRight: L("Show Legend"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Make sure you set the values for this property editor in Webix
      // $$(ids.chartWidth).setValue(view.settings.chartWidth != null ? view.settings.chartWidth : ABViewChartAreaPropertyComponentDefaults.chartWidth);
      $$(ids.chartHeight).setValue(
         view.settings.chartHeight != null
            ? view.settings.chartHeight
            : ABViewChartAreaPropertyComponentDefaults.chartHeight
      );
      $$(ids.labelFontSize).setValue(
         view.settings.labelFontSize != null
            ? view.settings.labelFontSize
            : ABViewChartAreaPropertyComponentDefaults.labelFontSize
      );
      $$(ids.stepValue).setValue(
         view.settings.stepValue != null
            ? view.settings.stepValue
            : ABViewChartAreaPropertyComponentDefaults.stepValue
      );
      $$(ids.maxValue).setValue(
         view.settings.maxValue != null
            ? view.settings.maxValue
            : ABViewChartAreaPropertyComponentDefaults.maxValue
      );
      $$(ids.areaType).setValue(
         view.settings.areaType != null
            ? view.settings.areaType
            : ABViewChartAreaPropertyComponentDefaults.areaType
      );
      $$(ids.isLegend).setValue(
         view.settings.isLegend != null
            ? view.settings.isLegend
            : ABViewChartAreaPropertyComponentDefaults.isLegend
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // Retrive the values of your properties from Webix and store them in the view
      view.settings.areaType = $$(ids.areaType).getValue();
      view.settings.isLegend = $$(ids.isLegend).getValue();
      // view.settings.chartWidth = $$(ids.chartWidth).getValue();
      view.settings.chartHeight = $$(ids.chartHeight).getValue();
      view.settings.labelFontSize = $$(ids.labelFontSize).getValue();
      view.settings.stepValue = $$(ids.stepValue).getValue();
      view.settings.maxValue = $$(ids.maxValue).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseComp = super.component(App);

      // get a UI component for each of our child views
      var viewComponents = [];
      this.views().forEach((v) => {
         viewComponents.push(v.component(App));
      });

      var idBase = "ABViewChartArea_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _ui = {
         id: ids.component,
         view: "chart",
         type:
            this.settings.areaType != null
               ? this.settings.areaType
               : ABViewChartAreaPropertyComponentDefaults.areaType,
         yAxis: {
            start: 0,
            step:
               this.settings.stepValue != null
                  ? this.settings.stepValue
                  : ABViewChartAreaPropertyComponentDefaults.stepValue, //"#stepValue#",
            end:
               this.settings.maxValue != null
                  ? this.settings.maxValue
                  : ABViewChartAreaPropertyComponentDefaults.maxValue, //"#maxValue#"
         },
         xAxis: {
            template:
               this.settings.isLegend == true
                  ? "<div style='font-size:" +
                    this.settings.labelFontSize +
                    "px;'>#label#</div>"
                  : "",
         },
         legend:
            this.settings.isLegend == true
               ? {
                    template:
                       "<div style='font-size:" +
                       this.settings.labelFontSize +
                       "px;'>#label#</div>",
                    values: [], // TODO : bug in webix 5.1.7
                 }
               : null,
         series: [
            {
               alpha: 0.7,
               value: "#value#",
               color: "#ee4339",
            },
            {
               alpha: 0.4,
               value: "#value2#",
               color: "#a7ee70",
            },
         ],
         // height: this.settings.chartHeight != null ? this.settings.chartHeight : ABViewChartAreaPropertyComponentDefaults.chartHeight,
         // width: this.settings.chartWidth != null ? this.settings.chartWidth : ABViewChartAreaPropertyComponentDefaults.chartWidth,
         // data: reportData
      };

      if (this.settings.chartHeight) _ui.height = this.settings.chartHeight;

      // make sure each of our child views get .init() called
      let _init = (options) => {
         baseComp.init({
            componentId: ids.component,
         });
      };
      let _logic = baseComp.logic;
      let _onShow = baseComp.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 51939:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartBar.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartBarCore = __webpack_require__(/*! ../../core/views/ABViewChartBarCore */ 53253);

const ABViewChartBarPropertyComponentDefaults = ABViewChartBarCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewChartBar extends ABViewChartBarCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewChartBarEditorComponent";
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      let baseEditor = super.editorComponent(App, mode, {
         componentId: ids.component,
      });

      return baseEditor;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "barType",
            view: "richselect",
            label: L("Chart Type"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "bar",
                  value: L("Vertical"),
               },
               {
                  id: "barH",
                  value: L("Horizontal"),
               },
            ],
         },
         {
            name: "barPreset",
            view: "richselect",
            label: L("Chart Preset"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "column",
                  value: L("Column"),
               },
               {
                  id: "stick",
                  value: L("Stick"),
               },
               {
                  id: "alpha",
                  value: L("Alpha"),
               },
            ],
         },
         // {
         // 	name: 'chartWidth',
         // 	view: 'counter',
         // 	min: 1,
         // 	label: L('ab.component.chart.bar.chartWidth', '*Width')
         // },
         {
            name: "height",
            view: "counter",
            min: 1,
            label: L("Height"),
         },
         {
            name: "stepValue",
            view: "counter",
            min: 1,
            label: L("Step"),
         },
         {
            name: "maxValue",
            view: "counter",
            min: 1,
            label: L("Max Value"),
         },
         {
            name: "labelFontSize",
            view: "counter",
            min: 1,
            label: L("Label Font Size"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            name: "isLegend",
            view: "checkbox",
            labelRight: L("Show Legend"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Make sure you set the values for this property editor in Webix
      // $$(ids.chartWidth).setValue(view.settings.chartWidth != null ? view.settings.chartWidth : ABViewChartBarPropertyComponentDefaults.chartWidth);
      $$(ids.height).setValue(
         view.settings.height != null
            ? view.settings.height
            : ABViewChartBarPropertyComponentDefaults.height
      );
      $$(ids.labelFontSize).setValue(
         view.settings.labelFontSize != null
            ? view.settings.labelFontSize
            : ABViewChartBarPropertyComponentDefaults.labelFontSize
      );
      $$(ids.stepValue).setValue(
         view.settings.stepValue != null
            ? view.settings.stepValue
            : ABViewChartBarPropertyComponentDefaults.stepValue
      );
      $$(ids.maxValue).setValue(
         view.settings.maxValue != null
            ? view.settings.maxValue
            : ABViewChartBarPropertyComponentDefaults.maxValue
      );
      $$(ids.barType).setValue(
         view.settings.barType != null
            ? view.settings.barType
            : ABViewChartBarPropertyComponentDefaults.barType
      );
      $$(ids.barPreset).setValue(
         view.settings.barPreset != null
            ? view.settings.barPreset
            : ABViewChartBarPropertyComponentDefaults.barPreset
      );
      $$(ids.isLegend).setValue(
         view.settings.isLegend != null
            ? view.settings.isLegend
            : ABViewChartBarPropertyComponentDefaults.isLegend
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // Retrive the values of your properties from Webix and store them in the view
      view.settings.barType = $$(ids.barType).getValue();
      view.settings.barPreset = $$(ids.barPreset).getValue();
      view.settings.isLegend = $$(ids.isLegend).getValue();
      // view.settings.chartWidth = $$(ids.chartWidth).getValue();
      view.settings.height = $$(ids.height).getValue();
      view.settings.labelFontSize = $$(ids.labelFontSize).getValue();
      view.settings.stepValue = $$(ids.stepValue).getValue();
      view.settings.maxValue = $$(ids.maxValue).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseComp = super.component(App);

      // get a UI component for each of our child views
      var viewComponents = [];
      this.views().forEach((v) => {
         viewComponents.push(v.component(App));
      });

      var idBase = "ABViewChartBar_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };
      var _ui;

      if (this.settings.barType == "bar" || this.settings.barType == null) {
         _ui = {
            id: ids.component,
            view: "chart",
            type:
               this.settings.barType != null
                  ? this.settings.barType
                  : ABViewChartBarPropertyComponentDefaults.barType,
            preset:
               this.settings.barPreset != null
                  ? this.settings.barPreset
                  : ABViewChartBarPropertyComponentDefaults.barPreset,
            value: "#value#",
            color: "#color#",
            yAxis: {
               start: 0,
               step:
                  this.settings.stepValue != null
                     ? this.settings.stepValue
                     : ABViewChartBarPropertyComponentDefaults.stepValue, //"#stepValue#",
               end:
                  this.settings.maxValue != null
                     ? this.settings.maxValue
                     : ABViewChartBarPropertyComponentDefaults.maxValue, //"#maxValue#"
            },
            xAxis: {
               template:
                  this.settings.isLegend == true
                     ? "<div style='font-size:" +
                       this.settings.labelFontSize +
                       "px;'>#label#</div>"
                     : "",
            },
            legend:
               this.settings.isLegend == true
                  ? "<div style='font-size:" +
                    this.settings.labelFontSize +
                    "px;'>#label#</div>"
                  : "",
            height:
               this.settings.height != null
                  ? this.settings.height
                  : ABViewChartBarPropertyComponentDefaults.height,
            // width: this.settings.chartWidth != null ? this.settings.chartWidth : ABViewChartBarPropertyComponentDefaults.chartWidth,
            // data: reportData
         };
      } else {
         _ui = {
            id: ids.component,
            view: "chart",
            type:
               this.settings.barType != null
                  ? this.settings.barType
                  : ABViewChartBarPropertyComponentDefaults.barType,
            preset:
               this.settings.barPreset != null
                  ? this.settings.barPreset
                  : ABViewChartBarPropertyComponentDefaults.barPreset,
            value: "#value#",
            color: "#color#",
            yAxis: {
               template:
                  this.settings.isLegend == true
                     ? "<div style='font-size:" +
                       this.settings.labelFontSize +
                       "px;'>#label#</div>"
                     : "",
            },
            xAxis: {
               start: 0,
               step: "#stepValue#",
               end: "#maxValue#",
            },
            legend:
               this.settings.isLegend == true
                  ? {
                       template:
                          "<div style='font-size:" +
                          this.settings.labelFontSize +
                          "px;'>#label#</div>",
                       values: [], // TODO : bug in webix 5.1.7
                    }
                  : null,
            height:
               this.settings.height != null
                  ? this.settings.height
                  : ABViewChartBarPropertyComponentDefaults.height,
            // width: this.settings.chartWidth != null ? this.settings.chartWidth : ABViewChartBarPropertyComponentDefaults.chartWidth,
            // data: reportData
         };
      }

      let _init = () => {
         baseComp.init({
            componentId: ids.component,
         });
      };
      let _logic = baseComp.logic;
      let _onShow = baseComp.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 68320:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartComponent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ./ABViewWidget */ 11895);

module.exports = class ABViewChartComponent extends ABViewWidget {
   editorComponent(App, mode, options) {
      let component = this.component(App);
      let _ui = component.ui;
      _ui.id = options.componentId;

      let _init = () => {
         component.init({
            componentId: _ui.id,
         });
      };
      let _logic = component.logic;
      let _onShow = component.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
         onShow: _onShow,
      };
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      // make sure each of our child views get .init() called
      var _init = (options) => {
         this._componentId = options.componentId;

         this.eventAdd({
            emitter: this.parent,
            eventName: "refreshData",
            listener: (reportData) => {
               // If this widget does not show, then will not refresh data
               if (this._isShow) _logic.refreshData(reportData);
            },
         });
      };

      var _logic = {
         setValue: (componentId, val) => {
            if ($$(componentId)) $$(componentId).setValues({ display: val });
         },

         onShow: () => {
            // if (!this._isShow) {

            // Mark this widget is showing
            this._isShow = true;

            let reportData = this.parent.getReportData();
            _logic.refreshData(reportData);
            // }
         },

         refreshData: (reportData) => {
            let comp = $$(this._componentId);
            if (comp && comp.data) comp.data.sync(reportData);
         },
      };

      return {
         // ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _logic.onShow,
      };
   }
};


/***/ }),

/***/ 71967:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartLine.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartLineCore = __webpack_require__(/*! ../../core/views/ABViewChartLineCore */ 59875);

const ABViewChartLinePropertyComponentDefaults = ABViewChartLineCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewChartLine extends ABViewChartLineCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewChartLineEditorComponent";
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      let baseEditor = super.editorComponent(App, mode, {
         componentId: ids.component,
      });

      return baseEditor;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "lineType",
            view: "richselect",
            label: L("Chart Type"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "line",
                  value: L("Line"),
               },
               {
                  id: "spline",
                  value: L("Spline"),
               },
            ],
         },
         {
            name: "linePreset",
            view: "richselect",
            label: L("Chart Preset"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "plot",
                  value: L("Plot"),
               },
               {
                  id: "diamond",
                  value: L("Diamond"),
               },
               {
                  id: "simple",
                  value: L("Simple"),
               },
            ],
         },
         // {
         // 	name: 'chartWidth',
         // 	view: 'counter',
         // 	min: 1,
         // 	label: L('ab.component.chart.line.chartWidth', '*Width')
         // },
         {
            name: "chartHeight",
            view: "counter",
            min: 1,
            label: L("Height"),
         },
         {
            name: "stepValue",
            view: "counter",
            min: 1,
            label: L("Step"),
         },
         {
            name: "maxValue",
            view: "counter",
            min: 1,
            label: L("Max Value"),
         },
         {
            name: "labelFontSize",
            view: "counter",
            min: 1,
            label: L("Label Font Size"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            name: "isLegend",
            view: "checkbox",
            labelRight: L("Show Legend"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Make sure you set the values for this property editor in Webix
      // $$(ids.chartWidth).setValue(view.settings.chartWidth != null ? view.settings.chartWidth : ABViewChartLinePropertyComponentDefaults.chartWidth);
      $$(ids.chartHeight).setValue(
         view.settings.chartHeight != null
            ? view.settings.chartHeight
            : ABViewChartLinePropertyComponentDefaults.chartHeight
      );
      $$(ids.labelFontSize).setValue(
         view.settings.labelFontSize != null
            ? view.settings.labelFontSize
            : ABViewChartLinePropertyComponentDefaults.labelFontSize
      );
      $$(ids.stepValue).setValue(
         view.settings.stepValue != null
            ? view.settings.stepValue
            : ABViewChartLinePropertyComponentDefaults.stepValue
      );
      $$(ids.maxValue).setValue(
         view.settings.maxValue != null
            ? view.settings.maxValue
            : ABViewChartLinePropertyComponentDefaults.maxValue
      );
      $$(ids.lineType).setValue(
         view.settings.lineType != null
            ? view.settings.lineType
            : ABViewChartLinePropertyComponentDefaults.lineType
      );
      $$(ids.linePreset).setValue(
         view.settings.linePreset != null
            ? view.settings.linePreset
            : ABViewChartLinePropertyComponentDefaults.linePreset
      );
      $$(ids.isLegend).setValue(
         view.settings.isLegend != null
            ? view.settings.isLegend
            : ABViewChartLinePropertyComponentDefaults.isLegend
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // Retrive the values of your properties from Webix and store them in the view
      view.settings.lineType = $$(ids.lineType).getValue();
      view.settings.linePreset = $$(ids.linePreset).getValue();
      view.settings.isLegend = $$(ids.isLegend).getValue();
      // view.settings.chartWidth = $$(ids.chartWidth).getValue();
      view.settings.chartHeight = $$(ids.chartHeight).getValue();
      view.settings.labelFontSize = $$(ids.labelFontSize).getValue();
      view.settings.stepValue = $$(ids.stepValue).getValue();
      view.settings.maxValue = $$(ids.maxValue).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseComp = super.component(App);

      // get a UI component for each of our child views
      var viewComponents = [];
      this.views().forEach((v) => {
         viewComponents.push(v.component(App));
      });

      var idBase = "ABViewChartLine_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _ui = {
         id: ids.component,
         view: "chart",
         type:
            this.settings.lineType != null
               ? this.settings.lineType
               : ABViewChartLinePropertyComponentDefaults.lineType,
         preset:
            this.settings.linePreset != null
               ? this.settings.linePreset
               : ABViewChartLinePropertyComponentDefaults.linePreset,
         value: "#value#",
         color: "#color#",
         yAxis: {
            start: 0,
            step:
               this.settings.stepValue != null
                  ? this.settings.stepValue
                  : ABViewChartLinePropertyComponentDefaults.stepValue, //"#stepValue#",
            end:
               this.settings.maxValue != null
                  ? this.settings.maxValue
                  : ABViewChartLinePropertyComponentDefaults.maxValue, //"#maxValue#"
         },
         xAxis: {
            template:
               this.settings.isLegend == true
                  ? "<div style='font-size:" +
                    this.settings.labelFontSize +
                    "px;'>#label#</div>"
                  : "",
         },
         legend:
            this.settings.isLegend == true
               ? {
                    template:
                       "<div style='font-size:" +
                       this.settings.labelFontSize +
                       "px;'>#label#</div>",
                    values: [], // TODO : bug in webix 5.1.7
                 }
               : null,
         height:
            this.settings.chartHeight != null
               ? this.settings.chartHeight
               : ABViewChartLinePropertyComponentDefaults.chartHeight,
         // width: this.settings.chartWidth != null ? this.settings.chartWidth : ABViewChartLinePropertyComponentDefaults.chartWidth,
         // data: reportData
      };

      let _init = () => {
         baseComp.init({
            componentId: ids.component,
         });
      };
      let _logic = baseComp.logic;
      let _onShow = baseComp.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 98104:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartPie.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartPieCore = __webpack_require__(/*! ../../core/views/ABViewChartPieCore */ 12118);

const ABViewChartPiePropertyComponentDefaults = ABViewChartPieCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewChartPie extends ABViewChartPieCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewChartPieEditorComponent";
      // let ids = {
      //    component: App.unique(idBase + "_component")
      // };

      // let baseEditor = super.editorComponent(App, mode, {
      //    componentId: ids.component
      // });

      // return baseEditor;

      return this.component(App, idBase);
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "pieType",
            view: "richselect",
            label: L("Chart Type"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "pie",
                  value: L("Standard"),
               },
               {
                  id: "pie3D",
                  value: L("Pie3D"),
               },
               {
                  id: "donut",
                  value: L("Donut"),
               },
            ],
         },
         // {
         // 	name: 'chartWidth',
         // 	view: 'counter',
         // 	min: 1,
         // 	label: L('ab.component.chart.pie.chartWidth', '*Width')
         // },
         {
            name: "height",
            view: "counter",
            min: 1,
            label: L("Height"),
         },
         {
            name: "innerFontSize",
            view: "counter",
            min: 1,
            label: L("Inner Font Size"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            name: "labelFontSize",
            view: "counter",
            min: 1,
            label: L("Label Font Size"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            name: "isLegend",
            view: "checkbox",
            labelRight: L("Show Legend"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Make sure you set the values for this property editor in Webix
      // $$(ids.chartWidth).setValue(view.settings.chartWidth != null ? view.settings.chartWidth : ABViewChartPiePropertyComponentDefaults.chartWidth);
      $$(ids.height).setValue(
         view.settings.height != null
            ? view.settings.height
            : ABViewChartPiePropertyComponentDefaults.height
      );
      $$(ids.innerFontSize).setValue(
         view.settings.innerFontSize != null
            ? view.settings.innerFontSize
            : ABViewChartPiePropertyComponentDefaults.innerFontSize
      );
      $$(ids.labelFontSize).setValue(
         view.settings.labelFontSize != null
            ? view.settings.labelFontSize
            : ABViewChartPiePropertyComponentDefaults.labelFontSize
      );
      $$(ids.pieType).setValue(
         view.settings.pieType != null
            ? view.settings.pieType
            : ABViewChartPiePropertyComponentDefaults.pieType
      );
      $$(ids.isLegend).setValue(
         view.settings.isLegend != null
            ? view.settings.isLegend
            : ABViewChartPiePropertyComponentDefaults.isLegend
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // Retrive the values of your properties from Webix and store them in the view
      view.settings.pieType = $$(ids.pieType).getValue();
      view.settings.isLegend = $$(ids.isLegend).getValue();
      // view.settings.chartWidth = $$(ids.chartWidth).getValue();
      view.settings.height = $$(ids.height).getValue();
      view.settings.innerFontSize = $$(ids.innerFontSize).getValue();
      view.settings.labelFontSize = $$(ids.labelFontSize).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App, idBase) {
      let baseComp = super.component(App);

      // get a UI component for each of our child views
      var viewComponents = [];
      this.views().forEach((v) => {
         viewComponents.push(v.component(App));
      });

      idBase = idBase || "ABViewChartPie_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      let legend = null;
      if (this.settings.isLegend == true) {
         legend = {
            width: this.parent.settings.labelWidth,
            template:
               this.settings.isLegend == true
                  ? `<div style='font-size: ${this.settings.labelFontSize}px;'>#label#</div>`
                  : "",
         };
      }

      var _ui = {
         id: ids.component,
         view: "chart",
         type:
            this.settings.pieType != null
               ? this.settings.pieType
               : ABViewChartPiePropertyComponentDefaults.pieType,
         value: "#value#",
         color: "#color#",
         legend: legend,
         pieInnerText: `<div style='font-size: ${this.settings.innerFontSize}px;'>#value#</div>`,
         shadow: 1,
         height:
            this.settings.height != null
               ? this.settings.height
               : ABViewChartPiePropertyComponentDefaults.height,
         // width: this.settings.chartWidth != null ? this.settings.chartWidth : ABViewChartPiePropertyComponentDefaults.chartWidth,
         // data: reportData
      };

      let _init = () => {
         baseComp.init({
            componentId: ids.component,
         });
      };
      let _logic = baseComp.logic;
      let _onShow = baseComp.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 1404:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewComment.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCommentCore = __webpack_require__(/*! ../../core/views/ABViewCommentCore */ 42194);

const ABViewCommentPropertyComponentDefaults = ABViewCommentCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewComment extends ABViewCommentCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewCommentEditorComponent";
      var CommentView = this.component(App, idBase);

      return {
         ui: CommentView.ui,
         init: CommentView.init,
         logic: CommentView.logic,
         onShow: CommentView.onShow,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         var currView = _logic.currentEditObject();

         // Update field options in property
         this.propertyUpdateUserFieldOptions(ids, currView, dcId);
         this.propertyUpdateCommentFieldOptions(ids, currView, dcId);
         this.propertyUpdateDateFieldOptions(ids, currView, dcId);
      };

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "dataSource",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            on: {
               onChange: _logic.selectSource,
            },
         },
         {
            name: "columnUser",
            view: "richselect",
            label: L("Select a user field"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "columnComment",
            view: "richselect",
            label: L("Select a comment field"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "columnDate",
            view: "richselect",
            label: L("Select a date field"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var datacollectionId = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;

      this.propertyUpdateDatacollectionOptions(ids, view, datacollectionId);
      this.propertyUpdateUserFieldOptions(ids, view, datacollectionId);
      this.propertyUpdateCommentFieldOptions(ids, view, datacollectionId);
      this.propertyUpdateDateFieldOptions(ids, view, datacollectionId);

      $$(ids.dataSource).setValue(
         view.settings.dataviewID ||
            ABViewCommentPropertyComponentDefaults.dataviewID
      );
      $$(ids.columnUser).setValue(
         view.settings.columnUser ||
            ABViewCommentPropertyComponentDefaults.columnUser
      );
      $$(ids.columnComment).setValue(
         view.settings.columnComment ||
            ABViewCommentPropertyComponentDefaults.columnComment
      );
      $$(ids.columnDate).setValue(
         view.settings.columnDate ||
            ABViewCommentPropertyComponentDefaults.columnDate
      );
      $$(ids.height).setValue(
         view.settings.height || ABViewCommentPropertyComponentDefaults.height
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.dataSource).getValue();
      view.settings.columnUser = $$(ids.columnUser).getValue();
      view.settings.columnComment = $$(ids.columnComment).getValue();
      view.settings.columnDate = $$(ids.columnDate).getValue();
      view.settings.height = $$(ids.height).getValue();

      // Retrive the values of your properties from Webix and store them in the view
   }

   static propertyUpdateDatacollectionOptions(ids, view, dcId) {
      // Pull data collections to options
      var dcOptions = view.propertyDatacollections();
      $$(ids.dataSource).define("options", dcOptions);
      $$(ids.dataSource).define("value", dcId);
      $$(ids.dataSource).refresh();
   }

   static propertyUpdateUserFieldOptions(ids, view, dcId) {
      var datacollection = view.AB.datacollectionByID(dcId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object
            .fields((f) => f.key == "user")
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });
      }
      // Add a default option
      var defaultOption = { id: null, value: "[Select]" };
      fieldOptions.unshift(defaultOption);

      $$(ids.columnUser).define("options", fieldOptions);
      $$(ids.columnUser).refresh();
   }

   static propertyUpdateCommentFieldOptions(ids, view, dcId) {
      var datacollection = view.AB.datacollectionByID(dcId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object
            .fields((f) => f.key == "string" || f.key == "LongText")
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });
      }
      // Add a default option
      var defaultOption = { id: null, value: "[Select]" };
      fieldOptions.unshift(defaultOption);

      $$(ids.columnComment).define("options", fieldOptions);
      $$(ids.columnComment).refresh();
   }

   static propertyUpdateDateFieldOptions(ids, view, dcId) {
      var datacollection = view.AB.datacollectionByID(dcId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object
            .fields((f) => f.key == "date")
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });
      }
      // Add a default option
      var defaultOption = { id: null, value: "[Select]" };
      fieldOptions.unshift(defaultOption);

      $$(ids.columnDate).define("options", fieldOptions);
      $$(ids.columnDate).refresh();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = "ABViewComment_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      let base = super.component(App);

      var userList = this.getUserData();
      var userId = this.getCurrentUserId();

      var _ui = {
         id: ids.component,
         view: "comments",
         users: userList,
         currentUser: userId,
         height: this.settings.height,
         on: {
            onBeforeAdd: function (id, obj, index) {
               _logic.addComment(obj.text, new Date());
            },
            // NOTE: no update event of comment widget !!
            // Updating event handles in .init function
            // https://docs.webix.com/api__ui.comments_onbeforeeditstart_event.html#comment-4509366150

            // onAfterEditStart: function (rowId) {
            // 	let item = this.getItem(rowId);

            // 	_logic.updateComment(rowId, item);
            // },
            onAfterDelete: function (rowId) {
               _logic.deleteComment(rowId);
            },
         },
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {
         this.__dvEvents = this.__dvEvents || {};

         let $comment = $$(ids.component);
         if ($comment) {
            let $commentList = $comment.queryView({ view: "list" });
            if ($commentList) {
               // Updating comment event
               if (!this.__dvEvents.onStoreUpdated)
                  this.__dvEvents.onStoreUpdated = $commentList.data.attachEvent(
                     "onStoreUpdated",
                     (rowId, data, operate) => {
                        if (operate == "update") {
                           _logic.updateComment(rowId, (data || {}).text);
                        }
                     }
                  );

               // Implement progress bar
               webix.extend($commentList, webix.ProgressBar);
            }
         }

         var dv = this.datacollection;
         if (!dv) return;

         // bind dc to component
         // dv.bind($$(ids.component));

         if (!this.__dvEvents.create)
            this.__dvEvents.create = dv.on("create", () =>
               _logic.refreshComment()
            );

         if (!this.__dvEvents.update)
            this.__dvEvents.update = dv.on("update", () =>
               _logic.refreshComment()
            );

         if (!this.__dvEvents.delete)
            this.__dvEvents.delete = dv.on("delete", () =>
               _logic.refreshComment()
            );

         if (!this.__dvEvents.loadData)
            this.__dvEvents.loadData = dv.on("loadData", () =>
               _logic.refreshComment()
            );
      };

      var _logic = {
         getCommentData: () => {
            let dv = this.datacollection;
            if (!dv) return null;

            let userCol = this.getUserField();
            let commentCol = this.getCommentField();
            let dateCol = this.getDateField();

            if (!userCol || !commentCol) return null;

            let userColName = userCol.columnName;
            let commentColName = commentCol.columnName;
            let dateColName = dateCol ? dateCol.columnName : null;

            let dataObject = dv.getData();
            let dataList = [];

            dataObject.forEach((item, index) => {
               if (item[commentColName]) {
                  var user = this.getUserData().find((user) => {
                     return user.value == item[userColName];
                  });
                  var data = {
                     id: item.id,
                     user_id: user ? user.id : 0,
                     date: item[dateColName]
                        ? new Date(item[dateColName])
                        : null,
                     default_date: new Date(item["created_at"]),
                     text: item[commentColName],
                  };

                  dataList.push(data);
               }
            });

            dataList.sort(function (a, b) {
               if (dateColName) {
                  return (
                     new Date(a.date).getTime() - new Date(b.date).getTime()
                  );
               } else {
                  return (
                     new Date(a.default_date).getTime() -
                     new Date(b.default_date).getTime()
                  );
               }
            });

            return {
               data: dataList,
            };
         },
         refreshComment: () => {
            if (this.__refreshTimeout) clearTimeout(this.__refreshTimeout);

            _logic.busy();

            this.__refreshTimeout = setTimeout(() => {
               let $comment = $$(ids.component);
               if (!$comment) return;

               // clear comments
               let $commentList = $comment.queryView({ view: "list" });
               if ($commentList) $commentList.clearAll();

               // populate comments
               let commentData = _logic.getCommentData();
               if (commentData) {
                  $$(ids.component).parse(commentData);
               }

               // scroll to the last item
               if ($commentList)
                  $commentList.scrollTo(0, Number.MAX_SAFE_INTEGER);

               delete this.__refreshTimeout;

               _logic.ready();
            }, 90);
         },
         addComment: (commentText, dateTime) => {
            this.saveData(commentText, dateTime);
         },
         updateComment: (rowId, commentText) => {
            let model = this.model();
            if (!model) return Promise.resolve(); // already notified

            let commentField = this.getCommentField();
            if (!commentField) return Promise.resolve(); // already notified

            let values = {};
            values[commentField.columnName] = commentText || "";

            return model.update(rowId, values);
         },
         deleteComment: (rowId) => {
            let model = this.model();
            if (!model) return;

            return model.delete(rowId);
         },
         busy: () => {
            let $comment = $$(ids.component);
            if (!$comment) return;

            let $commentList = $comment.queryView({ view: "list" });
            if (!$commentList) return;

            $commentList.disable();

            if ($commentList.showProgress)
               $commentList.showProgress({ type: "icon" });
         },
         ready: () => {
            let $comment = $$(ids.component);
            if (!$comment) return;

            let $commentList = $comment.queryView({ view: "list" });
            if (!$commentList) return;

            $commentList.enable();

            if ($commentList.hideProgress) $commentList.hideProgress();
         },
      };

      var onShow = () => {
         base.onShow();

         _logic.refreshComment();
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
         onShow: onShow,
      };
   }

   getUsers() {
      return this.AB.Account.userList().map((u) => {
         return {
            id: u.username,
            value: u.username,
            image: u.image_id,
         };
      });
   }

   getCurrentUserId() {
      var userObject = this.getUsers();
      var currentUser = this.AB.Account.username();
      //Anonymous User = 0
      var currentUserId = 0;

      if (!userObject) return;

      userObject.forEach((item, index) => {
         if (item.value == currentUser) {
            currentUserId = index + 1;
         }
      });
      return currentUserId;
   }

   async saveData(commentText, dateTime) {
      if (commentText == null || commentText == "") return Promise.resolve();

      let dv = this.datacollection;
      if (!dv) return Promise.resolve();

      let model = this.model();
      if (model == null) {
         this.AB.notify.builder(
            {},
            {
               message:
                  "ABViewComment.saveData(): could not pull a model to work with.",
               viewName: this.label,
            }
         );
         return Promise.resolve();
      }

      let comment = {};

      let userField = this.getUserField();
      if (userField) comment[userField.columnName] = this.AB.Account.username();

      let commentField = this.getCommentField();
      if (commentField) comment[commentField.columnName] = commentText;

      let dateField = this.getDateField();
      if (dateField) comment[dateField.columnName] = dateTime;

      // add parent cursor to default
      let dvLink = dv.datacollectionLink;
      if (dvLink && dvLink.getCursor()) {
         let objectLink = dvLink.datasource;
         let fieldLink = dv.fieldLink;

         if (objectLink && fieldLink) {
            comment[fieldLink.columnName] = {};
            comment[fieldLink.columnName][
               objectLink.PK()
            ] = dvLink.getCursor().id;
         }
      }

      return await model.create(comment);
   }
};


/***/ }),

/***/ 85766:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewComponent.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewComponent)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32735);
/**
 * ABViewComponent
 * A common UI component class for our UI widgets.
 */


class ABViewComponent extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(...params) {
      super(...params);

      this.__events = [];
      // {array}
      // A collection of any listeners we are managing.
      // {
      //   emitter:   {EventEmitter} the object we are listening on
      //   eventName: {string} the event key we are listening for
      //   listener:  {fn} the function to call on
      // }

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.CurrentDatacollectionID = null;
      // {string}
      // the ABDataCollection.id of the DC we are working with
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }
   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      return this.AB.datacollectionByID(this.CurrentDatacollectionID);
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      this.CurrentDatacollectionID = datacollection.id;
   }

   objectLoad(object) {
      this.CurrentObjectID = object.id;
   }

   /**
    * @method eventAdd()
    * Create a new listener on an object. Note, this will prevent multiple
    * listeners being applied to the same Object.
    * @param {object} evt
    *        The definition of the event we are adding:
    *        {
    *           emitter:   {EventEmitter} the object we are listening on
    *           eventName: {string} the event key we are listening for
    *           listener:   {fn} the function to call on
    *        }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      // make sure we haven't done this before:
      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventsClear()
    * Remove all the attached event listeners and reset our tracking.
    */
   eventsClear() {
      (this.__events || []).forEach((e) => {
         e.emitter.removeListener(e.eventName, e.listener);
      });
      this.__events = [];
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      // if we manage a datacollection, then make sure it has started
      // loading it's data when we are showing our component.
      var dv = this.datacollection;
      if (dv) {
         if (dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }
      }
   }
}


/***/ }),

/***/ 88016:
/*!*****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewConditionalContainer.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewConditionalContainerCore = __webpack_require__(/*! ../../core/views/ABViewConditionalContainerCore */ 10962);

const ABViewPropertyDefaults = ABViewConditionalContainerCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

let FilterComponent = null;

module.exports = class ABViewConditionalContainer extends (
   ABViewConditionalContainerCore
) {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      // Set filter value
      this.__filterComponent = this.AB.filterComplexNew(
         `${this.id}_filterComponent`
      );
      // this.__filterComponent.applicationLoad(application);
      this.populateFilterComponent();
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      var idBase = "ABViewConditionalContainerPropertyEditor";

      _logic.changeDatacollection = (dvId) => {
         var view = _logic.currentEditObject();

         this.populatePopupEditors(ids, view, dvId);
      };

      _logic.showFilterPopup = ($view) => {
         this.filter_popup.show($view, null, { pos: "top" });
      };

      _logic.onFilterChange = () => {
         var view = _logic.currentEditObject();

         var filterValues = FilterComponent.getValue();

         view.settings.filterConditions = filterValues;

         var allComplete = true;
         filterValues.rules.forEach((f) => {
            // if all 3 fields are present, we are good.
            if (f.key && f.rule && f.value) {
               allComplete = allComplete && true;
            } else {
               // else, we found an entry that wasn't complete:
               allComplete = false;
            }
         });

         // only perform the update if a complete row is specified:
         if (allComplete) {
            // we want to call .save() but give webix a chance to properly update it's
            // select boxes before this call causes them to be removed:
            setTimeout(() => {
               this.propertyEditorSave(ids, view);
            }, 10);
         }

         this.populateBadgeNumber(ids, view);
      };

      FilterComponent = this.AB.filterComplexNew(`${idBase}_filter`);
      FilterComponent.init();
      FilterComponent.on("change", (val) => {
         _logic.onFilterChange(val);
      });

      this.filter_popup = webix.ui({
         view: "popup",
         width: 800,
         hidden: true,
         body: FilterComponent.ui,
      });

      return commonUI.concat([
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            on: {
               onChange: function (dvId) {
                  _logic.changeDatacollection(dvId);
               },
            },
         },
         {
            view: "fieldset",
            name: "filter",
            label: L("Filter:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Filter Data:"),
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "buttonFilter",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           css: "webix_primary",
                           autowidth: true,
                           badge: 0,
                           click: function () {
                              _logic.showFilterPopup(this.$view);
                           },
                        },
                     ],
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // FilterComponent.applicationLoad(view.application);

      var datacollectionId = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;
      var SourceSelector = $$(ids.datacollection);

      // Pull data collections to options
      var dcOptions = view.propertyDatacollections();
      SourceSelector.define("options", dcOptions);
      SourceSelector.define("value", datacollectionId);
      SourceSelector.refresh();

      this.populatePopupEditors(ids, view);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
   }

   static populatePopupEditors(ids, view, datacollectionId) {
      // pull current data collection
      var dv = view.datacollection;

      // specify data collection id
      if (datacollectionId) {
         dv = view.AB.datacollectionByID(datacollectionId);
      }

      if (dv && dv.datasource) {
         FilterComponent.fieldsLoad(dv.datasource.fields());
         view.__filterComponent.fieldsLoad(dv.datasource.fields());
      } else {
         FilterComponent.fieldsLoad();
         view.__filterComponent.fieldsLoad();
      }

      FilterComponent.setValue(
         view.settings.filterConditions ||
            ABViewPropertyDefaults.filterConditions
      );
      view.__filterComponent.setValue(
         view.settings.filterConditions ||
            ABViewPropertyDefaults.filterConditions
      );

      this.populateBadgeNumber(ids, view);
   }

   static populateBadgeNumber(ids, view) {
      if (
         view.settings.filterConditions &&
         view.settings.filterConditions.rules
      ) {
         $$(ids.buttonFilter).define(
            "badge",
            view.settings.filterConditions.rules.length || null
         );
         $$(ids.buttonFilter).refresh();
      } else {
         $$(ids.buttonFilter).define("badge", null);
         $$(ids.buttonFilter).refresh();
      }
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = "ABViewConditionalContainer_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var baseComp = super.component(App);

      const ifComp = this.views()[0].component(App);
      const elseComp = this.views()[1].component(App);

      ifComp.ui.batch = "if";
      elseComp.ui.batch = "else";

      var _ui = {
         id: ids.component,
         view: "multiview",
         cells: [
            {
               batch: "wait",
               view: "layout",
               rows: [
                  {
                     view: "label",
                     label: L("Please wait..."),
                  },
               ],
            },
            ifComp.ui,
            elseComp.ui,
         ],
      };

      var _init = (options, accessLevel) => {
         baseComp.init(options);
         ifComp.init(options, accessLevel);
         elseComp.init(options, accessLevel);

         this.populateFilterComponent();

         var dv = this.datacollection;
         if (dv) {
            // listen DC events
            this.eventAdd({
               emitter: dv,
               eventName: "loadData",
               listener: () => _logic.displayView(),
            });
            this.eventAdd({
               emitter: dv,
               eventName: "initializedData",
               listener: () => _logic.displayView(),
            });

            this.eventAdd({
               emitter: dv,
               eventName: "changeCursor",
               listener: (...p) => _logic.displayView(...p),
            });
         }

         _logic.displayView();
      };

      var _logic = {
         displayView: (currData) => {
            let dv = this.datacollection;
            if (dv && dv.dataStatus === dv.dataStatusFlag.initialized) {
               if (currData == null) {
                  currData = dv.getCursor();
               }
               var isValid = this.__filterComponent.isValid(currData);

               // dataStatus initialized
               // filter is valid
               // currentData has been loaded from cursor
               if (
                  isValid &&
                  currData != undefined // if , at this point, there is no cursor; the data collection is empty
               ) {
                  // if (isValid && currData) {
                  $$(ids.component).showBatch("if");
               } else {
                  $$(ids.component).showBatch("else");
               }
            } else {
               // show 'waiting' panel if data is not loaded
               $$(ids.component).showBatch("wait");
               return;
            }
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: baseComp.onShow,
      };
   }

   populateFilterComponent() {
      let dc = this.datacollection;
      if (dc && dc.datasource)
         this.__filterComponent.fieldsLoad(dc.datasource.fields());
      else this.__filterComponent.fieldsLoad([]);

      this.__filterComponent.setValue(
         this.settings.filterConditions ||
            ABViewPropertyDefaults.filterConditions
      );
   }

   save() {
      // Because conditional container has always IF and ELSE containers, then it should be include them to call save too
      let includeSubViews = true;

      return super.save(includeSubViews);
   }
};


/***/ }),

/***/ 19199:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewConnectDataFilter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewConnectDataFilter)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/views/ABViewConnectDataFilterCore */ 3578);
/* harmony import */ var _core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 85766);



const L = (...params) => AB.Multilingual.label(...params);

class ABViewConnectDataFilterComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(view, idbase) {
      super(idbase ?? `ABViewConnectDataFilter_${view.id}`, {
         reset: "",
      });

      this.view = view;
      this.AB = view.AB;
      this.datacollection = this.view.datacollection;
      this.settings = view.settings;
   }

   ui() {
      return {
         type: "space",
         borderless: true,
         cols: [
            {
               view: "icon",
               icon: "fa fa-filter",
               align: "left",
               disabled: true,
            },
            {
               view: "combo",
               id: this.ids.component,
               labelWidth: this.AB.UISettings.config().labelWidthXLarge,
               disabled: true,
               on: {
                  onChange: (id) => this.applyConnectFilter(id),
               },
            },
            {
               view: "icon",
               id: this.ids.reset,
               icon: "fa fa-times",
               align: "left",
               disabled: true,
               tooltip: L("Renmove this filter"),
               on: {
                  onItemClick: () => this.resetConnectFilter(),
               },
            },
         ],
      };
   }

   async init(options) {
      const dv = this.datacollection;
      if (!dv) return;

      const object = dv.datasource;
      if (!object) return;

      const [field] = object.fields((f) => f.columnName == this.settings.field);
      if (!field) {
         this.AB.notify.developer(
            `Cannot find field "${this.settings.field}" in ${object.name}`,
            {
               context: "ABViewConnectDataFilterComponent.init()",
               data: { settings: this.settings },
            }
         );
         return;
      }
      this.field = field;

      const suggest = webix.ui({
         view: "suggest",
         filter: ({ value }, search) =>
            value.toLowerCase().includes(search.toLowerCase()),
         on: {
            onShow: () => {
               field.populateOptionsDataCy($$(this.ids.component), field, {});
            },
         },
      });
      field.getAndPopulateOptions(suggest, null, field);

      $$(this.ids.component).define("suggest", suggest);
      $$(this.ids.component).define(
         "label",
         `${L("Filter by")} ${field.label}`
      );
      $$(this.ids.component).enable();
      $$(this.ids.component).refresh();
   }

   resetConnectFilter() {
      this.datacollection.filterCondition({ glue: "and", rules: [] });
      this.datacollection.reloadData();
      // Block applyConnectFields() from triggering
      $$(this.ids.component).blockEvent();
      $$(this.ids.component).setValue();
      $$(this.ids.component).unblockEvent();
      $$(this.ids.reset).disable();
   }

   applyConnectFilter(connectId) {
      const filterRule = {
         key: this.field.id,
         rule: "equals",
         value: connectId,
      };

      this.datacollection.filterCondition({ glue: "and", rules: [filterRule] });
      this.datacollection.reloadData();
      $$(this.ids.reset).enable();
   }
}

class ABViewConnectDataFilter extends (_core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_1___default()) {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(v1App = false) {
      let component = new ABViewConnectDataFilterComponent(this);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: newComponent.ui(),
            init: (options, accessLevel) => {
               return newComponent.init(this.AB, accessLevel);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }
      return component;
   }
}


/***/ }),

/***/ 32715:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewContainer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainerCore = __webpack_require__(/*! ../../core/views/ABViewContainerCore */ 45132);

const ABPropertyComponentDefaults = ABViewContainerCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewContainer extends ABViewContainerCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewContainerEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var subComponents = {}; // { viewId: viewComponent, ..., viewIdn: viewComponent }

      var cellHeight = 250;
      // if (this.key == "form" || this.key == "detail") {
      // 	cellHeight = 80;
      // }

      var _ui = {
         rows: [
            {
               id: ids.component,
               view: "dashboard",
               css: "ab-" + this.key + "-container",
               cellHeight: cellHeight,
               gridColumns:
                  this.settings.columns || ABPropertyComponentDefaults.columns,
            },
         ],
      };

      var _init = (options) => {
         var Dashboard = $$(ids.component);
         if (Dashboard) {
            webix.extend(Dashboard, webix.OverlayBox);
            webix.extend(Dashboard, webix.ProgressBar);
         }

         // this.views().reverse().forEach((child) => {

         // NOTE: need to sorting before .addView because there is a render position bug in webix 5.1.7
         // https://webix.com/snippet/404cf0c7
         var childViews = this.viewsSortByPosition();

         // attach all the .UI views:
         childViews.forEach((child) => {
            var component = child.component(App);

            // store
            subComponents[child.id] = component;

            let view = "panel";
            if (child.settings.movable == false) view = "scrollview";

            Dashboard.addView({
               view: view,

               // specific viewId to .name, it will be used to save view position
               name: child.id,
               icon: "fa fa-arrows",
               css: "ab-widget-container",
               body: {
                  rows: [
                     {
                        view: "template",
                        height: 30,
                        css: "ab-widget-header",
                        template: _logic.template(child),
                        onClick: {
                           "ab-component-edit": (e, id, trg) => {
                              _logic.viewEdit(e, child.id, trg);
                           },
                           "ab-component-remove": (e, id, trg) => {
                              _logic.viewDelete(e, child.id, trg);
                           },
                        },
                     },
                     component.ui,
                     // (mode == 'preview' ? component.ui : {
                     // 	// empty element
                     // 	view: 'spacer',
                     // 	hidden: true,
                     // })
                  ],
               },

               // dx: _logic.validatePosition(child.position.dx, 1, Dashboard.config.gridColumns),
               // dy: _logic.validatePosition(child.position.dy, 1, Dashboard.config.gridRows),

               dx: child.position.dx || 1,
               dy: child.position.dy || 1,
               x: _logic.validatePosition(
                  child.position.x,
                  0,
                  Dashboard.config.gridColumns - 1
               ),
               y: child.position.y || 0,
            });

            // initial sub-component
            component.init(null, 2); // when in editor allow full access
         });

         // listen onChange event
         // NOTE: listen after populate views by .addView
         if (this._onChangeId) Dashboard.detachEvent(this._onChangeId);
         this._onChangeId = Dashboard.attachEvent("onChange", () => {
            _logic.onReorder();
         });

         // show "drop here" panel
         _logic.showEmptyPlaceholder();

         Dashboard.adjust();
      };

      var _logic = {
         /**
          * @method template()
          * render the list template for the View
          * @param {obj} obj the current View instance
          * @param {obj} common  Webix provided object with common UI tools
          */
         template: (child) => {
            return `<div>
               <i class="fa fa-${child.icon} webix_icon_btn"></i> ${child.label}
               <div class="ab-component-tools">
               ${
                  child.settings.removable == false
                     ? ""
                     : '<i class="fa fa-trash ab-component-remove"></i>'
               }
               <i class="fa fa-edit ab-component-edit"></i>
               </div></div>`;
         },

         /**
          * @method viewDelete()
          * Called when the [delete] icon for a child View is clicked.
          * @param {obj} e the onClick event object
          * @param {integer} id the id of the element to delete
          * @param {obj} trg  Webix provided object
          */
         viewDelete: (e, id, trg) => {
            var deletedView = this.views((v) => v.id == id)[0];
            if (!deletedView) return false;

            webix.confirm({
               title: L("Delete component"),
               text: L("Do you want to delete <b>{0}</b>?", [
                  deletedView.label,
               ]),
               callback: async (result) => {
                  if (!result) return;
                  // let Dashboard = $$(ids.component);

                  // // remove UI of this component in template
                  // var deletedElem = Dashboard.queryView({ name: id });
                  // if (deletedElem) {

                  // 	// store the removed view to signal event in .onChange
                  // 	this.__deletedView = deletedView;

                  // 	// remove view
                  // 	var remainingViews = this.views((v) => { return v.id != deletedView.id; })
                  // 	this._views = remainingViews;

                  // 	// this calls the remove REST to API server
                  // 	Dashboard.removeView(deletedElem);
                  // }

                  _logic.busy();

                  try {
                     await deletedView.destroy();

                     // signal the current view has been deleted.
                     deletedView.emit("destroyed", deletedView);

                     let Dashboard = $$(ids.component);

                     // Update UI
                     var deletedElem = Dashboard.queryView({ name: id });
                     if (deletedElem) {
                        Dashboard.blockEvent();
                        Dashboard.removeView(deletedElem);
                        Dashboard.unblockEvent();
                     }

                     _logic.showEmptyPlaceholder();
                  } catch (err) {
                     App.AB.notify.developer(err, {
                        message: "Error trying to delete selected View:",
                        view: deletedView,
                     });
                  }

                  _logic.ready();
               },
            });
            e.preventDefault();
         },

         /**
          * @method viewEdit()
          * Called when the [edit] icon for a child View is clicked.
          * @param {obj} e the onClick event object
          * @param {integer} id the id of the element to edit
          * @param {obj} trg  Webix provided object
          */
         viewEdit: (e, id, trg) => {
            var view = this.views((v) => v.id == id)[0];

            if (!view) return false;

            // NOTE: let webix finish this onClick event, before
            // calling .populateInterfaceWorkspace() which will replace
            // the interface elements with the edited view.  (apparently
            // that causes errors.)
            setTimeout(() => {
               App.actions.populateInterfaceWorkspace(view);
            }, 50);

            e.preventDefault();

            return false;
         },

         onReorder: async () => {
            _logic.busy();

            var Dashboard = $$(ids.component);

            // ignore in "preview" mode
            // if (Dashboard == null || Dashboard.config.view != "dashboard") return;

            var viewState = Dashboard.serialize();

            var allViewUpdates = [];

            // save view position state to views
            this.views().forEach((v) => {
               var state = viewState.filter((vs) => vs.name == v.id)[0];
               if (state) {
                  v.position.x = state.x;
                  v.position.y = state.y;

                  // validate position data
                  if (v.position.x < 0) v.position.x = 0;
                  if (v.position.y < 0) v.position.y = 0;

                  allViewUpdates.push(v.save());
               }
            });

            try {
               // save template layout
               // this.saveReorder()
               await Promise.all(allViewUpdates);

               await this.save();

               _logic.ready();
            } catch (err) {
               App.AB.notify.developer(err, {
                  message: "Error trying to save selected View:",
                  view: this.toObj(),
               });
               _logic.ready();
            }
         },

         showEmptyPlaceholder: () => {
            var Dashboard = $$(ids.component);

            // if we don't have any views, then place a "drop here" placeholder
            if (Dashboard.getChildViews().length == 0) {
               Dashboard.showOverlay(
                  "<div class='drop-zone'><div>" +
                     App.labels.componentDropZone +
                     "</div></div>"
               );
            }
         },

         validatePosition: (curPosition, minPosition, maxPosition) => {
            if (curPosition < minPosition) return minPosition;
            if (curPosition > maxPosition) return maxPosition;
            else return curPosition;
         },

         busy: () => {
            let Dashboard = $$(ids.component);
            if (Dashboard) {
               Dashboard.disable();

               if (Dashboard.showProgress)
                  Dashboard.showProgress({ type: "icon" });
            }
         },

         ready: () => {
            let Dashboard = $$(ids.component);
            if (Dashboard) {
               Dashboard.enable();

               if (Dashboard.hideProgress) Dashboard.hideProgress();
            }
         },
      };

      var _onShow = () => {
         this.views().forEach((v) => {
            var component = subComponents[v.id];

            if (component && component.onShow) {
               component.onShow();
            }
         });

         let dc = this.datacollection;
         if (dc && dc.dataStatus == dc.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dc.loadData();
         }
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }

   //
   // Property Editor
   //

   // static propertyEditorComponent(App) {
   // 	return ABViewPropertyComponent.component(App);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      _logic.addColumnGravity = (newVal, oldVal) => {
         var pos = $$(ids.gravity).getParentView().index($$(ids.gravity));
         $$(ids.gravity)
            .getParentView()
            .addView(
               {
                  view: "counter",
                  value: "1",
                  min: 1,
                  label: L("Column {0} Gravity", [newVal]),
                  labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  css: "gravity_counter",
                  on: {
                     onChange: () => {
                        _logic.onChange();
                     },
                  },
               },
               pos
            );
      };

      _logic.removeColumnGravity = (newVal, oldVal) => {
         $$(ids.gravity)
            .getParentView()
            .removeView(
               $$(ids.gravity).getParentView().getChildViews()[
                  $$(ids.gravity).getParentView().index($$(ids.gravity)) - 1
               ]
            );
      };

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "columns",
            view: "counter",
            min: 1,
            label: L("Columns"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
            on: {
               onChange: function (newVal, oldVal) {
                  if (newVal > 8) $$(ids.columns).setValue(8);

                  if (newVal > oldVal) {
                     _logic.addColumnGravity(newVal, oldVal);
                  } else if (newVal < oldVal) {
                     _logic.removeColumnGravity(newVal, oldVal);
                  }
               },
            },
         },
         {
            view: "text",
            name: "gravity",
            height: 1,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view, logic) {
      super.propertyEditorPopulate(App, ids, view, logic);
      this._App = App;

      $$(ids.columns).setValue(
         view.settings.columns || ABPropertyComponentDefaults.columns
      );

      var gravityCounters = $$(ids.gravity)
         .getParentView()
         .queryView({ css: "gravity_counter" }, "all")
         .map((counter) => $$(ids.gravity).getParentView().removeView(counter));

      for (var step = 1; step <= $$(ids.columns).getValue(); step++) {
         var pos = $$(ids.gravity).getParentView().index($$(ids.gravity));
         $$(ids.gravity)
            .getParentView()
            .addView(
               {
                  view: "counter",
                  min: 1,
                  label: L("Column {0} Gravity", [step]),
                  labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  css: "gravity_counter",
                  value:
                     view.settings.gravity && view.settings.gravity[step - 1]
                        ? view.settings.gravity[step - 1]
                        : ABPropertyComponentDefaults.gravity,
                  on: {
                     onChange: () => {
                        logic.onChange();
                     },
                  },
               },
               pos
            );
      }

      // NOTE : Move to .propertyEditorSave
      // // when a change is made in the properties the popups need to reflect the change
      // this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
      // if (!this.updateEventIds[view.id]) {
      // 	this.updateEventIds[view.id] = true;

      // 	// refresh dashboard to update "position.x" and "position.y" of child views
      // 	view.addListener('properties.updated', function () {

      // 		setTimeout(() => {
      // 			view.editorComponent(App).logic.onChange();
      // 		}, 100)

      // 	}, this);
      // }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.columns = $$(ids.columns).getValue();

      var gravity = [];
      $$(ids.gravity)
         .getParentView()
         .queryView({ css: "gravity_counter" }, "all")
         .map((counter) => gravity.push($$(counter).getValue()));
      view.settings.gravity = gravity;
   }

   static async propertyEditorSave(ids, view) {
      this.propertyEditorValues(ids, view);

      // Save .settings of container
      await view.save();

      // signal the current view has been updated.
      view.emit("properties.updated", view);

      // Save reorder of subviews
      let editorComponent = view.editorComponent(this._App);
      await editorComponent.logic.onReorder();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var idBase = "ABViewContainer_" + (idPrefix || "") + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      this.viewComponents = this.viewComponents || {}; // { viewId: viewComponent, ..., viewIdn: viewComponent }

      var _logic = {
         changePage: (pageId) => {
            this.changePage(pageId);
         },

         callbacks: {},

         getElements: (views) => {
            var rows = [];
            var curRowIndex;
            var curColIndex;

            views.forEach((v) => {
               let component = this.viewComponents[v.id];
               // if (!component) {
               component = v.component(App, idPrefix);
               this.viewComponents[v.id] = component;
               // }

               // if key == "form" or "button" register the callbacks to the parent
               // NOTE this will only work on the last form of a page!
               if (v.key == "form" && v._logic.callbacks) {
                  _logic.callbacks = v._logic.callbacks;
               }

               // Create a new row
               if (v.position.y == null || v.position.y != curRowIndex) {
                  curRowIndex = v.position.y || rows.length;
                  curColIndex = 0;

                  var rowNew = {
                     cols: [],
                  };

                  // Create columns following setting value
                  var colNumber =
                     this.settings.columns ||
                     ABPropertyComponentDefaults.columns;
                  for (var i = 0; i < colNumber; i++) {
                     var grav =
                        this.settings.gravity && this.settings.gravity[i]
                           ? parseInt(this.settings.gravity[i])
                           : ABPropertyComponentDefaults.gravity;
                     rowNew.cols.push({
                        gravity: grav,
                     });
                  }

                  rows.push(rowNew);
               }

               // Get the last row
               var curRow = rows[rows.length - 1];

               var newPos = v.position.x || 0;
               var getGrav = 1;

               if (curRow.cols[newPos] && curRow.cols[newPos].gravity) {
                  getGrav = curRow.cols[newPos].gravity;
               }

               component.ui.gravity = getGrav;

               // Add ui of sub-view to column
               curRow.cols[newPos] = component.ui;

               curColIndex += 1;

               // Trigger 'changePage' event to parent
               this.eventAdd({
                  emitter: v,
                  eventName: "changePage",
                  listener: (...p) => _logic.changePage(...p),
               });
            });

            return rows;
         },
      };

      // Generate rows & cols of views to .layout
      var views = this.viewsSortByPosition();
      var rowViews = _logic.getElements(views);

      var _ui = {
         id: ids.component,
         view: "layout",
         rows: rowViews,
      };

      // make sure each of our child views get .init() called
      var _init = (options, parentAccessLevel = 0) => {
         // register our callbacks:
         if (options) {
            for (var c in _logic.callbacks) {
               _logic.callbacks[c] = options[c] || _logic.callbacks[c];
            }
         }

         // see access by CSS class
         if ($$(ids.component))
            $$(ids.component).define("css", "accessLevel-" + parentAccessLevel);

         // attach all the .UI views:
         for (var key in this.viewComponents) {
            // skip when the view is removed.
            if (this.views((v) => v.id == key)[0] == null) return;

            var component = this.viewComponents[key];

            // Initial component along with options in case there are callbacks we need to listen for
            if (parentAccessLevel > 0) {
               component.init(options, parentAccessLevel);
            } else {
               $$(component.ui.id).hide();
            }
         }
      };

      var _onShow = () => {
         let dv = this.datacollection;
         if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }

         // calll .onShow in child components
         this.views().forEach((v) => {
            var component = this.viewComponents[v.id];

            if (component && component.onShow) {
               component.onShow();
            }
         });
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 64411:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDataview.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDataviewCore = __webpack_require__(/*! ../../core/views/ABViewDataviewCore */ 37446);
const ABViewPropertyLinkPage = (__webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 95782)["default"]);

const ABViewDataviewDefaults = ABViewDataviewCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDataview extends ABViewDataviewCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var idBase = "ABViewDataviewPropertyEditor";

      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      this.linkPageComponent = ABViewPropertyLinkPage.propertyComponent(
         App,
         idBase
      );

      return commonUI.concat([
         {
            view: "counter",
            name: "xCount",
            min: 1, // we cannot have 0 columns per row so lets not accept it
            label: L("Items in a row"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            step: 1,
         },
         this.linkPageComponent.ui,
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.xCount).setValue(
         view.settings.xCount || ABViewDataviewDefaults.xCount
      );

      this.linkPageComponent.viewLoad(view);
      this.linkPageComponent.setSettings(view.settings);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.xCount = $$(ids.xCount).getValue();

      let linkSettings = this.linkPageComponent.getSettings();
      for (let key in linkSettings) {
         view.settings[key] = linkSettings[key];
      }
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.detailsPage =
         this.settings.detailsPage || ABViewDataviewDefaults.detailsPage;
      this.settings.editPage =
         this.settings.editPage || ABViewDataviewDefaults.editPage;
      this.settings.detailsTab =
         this.settings.detailsTab || ABViewDataviewDefaults.detailsTab;
      this.settings.editTab =
         this.settings.editTab || ABViewDataviewDefaults.editTab;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj } App
    * @return {obj } UI component
    */
   component(App) {
      var com = {};

      var idBase = "ABViewDataview_" + this.id;
      var ids = {
         scrollview: App.unique(`${idBase}_scrollview`),
         component: App.unique(`${idBase}_component`),
         dataFlexView: App.unique(`${idBase}_dataFlexView`),
      };

      let linkPage = this.linkPageHelper.component(App, idBase);

      com.ui = {
         id: ids.component,
         rows: [
            {
               id: ids.scrollview,
               view: "scrollview",
               scroll: "y",
               body: {
                  id: ids.dataFlexView,
                  view: "flexlayout",
                  paddingX: 15,
                  paddingY: 19,
                  type: "space",
                  cols: [],
               },
               on: {
                  onAfterScroll: function () {
                     let pos = this.getScrollState();

                     com.logic.scroll(pos);
                  },
               },
            },
         ],
      };

      if (this.settings.height) com.ui.height = this.settings.height;

      com.init = (options) => {
         var dc = this.datacollection;
         if (!dc) return;

         let dataView = $$(ids.dataFlexView);

         // initial the link page helper
         linkPage.init({
            view: this,
            datacollection: dc,
         });

         // if (dc.datacollectionLink && dc.fieldLink) {
         //    dc.bind(dataView, dc.datacollectionLink, dc.fieldLink);
         // } else {
         //    dc.bind(dataView);
         // }
         // track all flexlayout component IDs on the data collectino so we can notify them of changes
         dc.attachFlexlayout(dataView);
         dc.on("initializingData", () => {
            com.logic.busy();
         });
         dc.on("initializedData", () => {
            com.logic.ready();
         });
         dc.on("loadData", () => {
            com.emptyView();
            com.renderData();
         });
         dc.on("update", () => {
            com.emptyView();
            com.renderData();
         });
         dc.on("delete", () => {
            com.emptyView();
            com.renderData();
         });
         dc.on("create", () => {
            com.emptyView();
            com.renderData();
         });

         // this.eventClear();
         //
         // this.eventAdd({
         //    emitter: dc,
         //    eventName: "loadData",
         //    listener: () => {
         //       com.renderData();
         //    },
         // });
      };

      com.logic = {
         busy: () => {
            let Layout = $$(ids.dataFlexView);
            let Scroll = $$(ids.scrollview);

            // editor mode doesn't load this ui
            if (!Scroll || !Layout) return;

            Layout.disable();

            if (!Scroll.showProgress) {
               webix.extend(Scroll, webix.ProgressBar);
            }
            Scroll.showProgress({ type: "icon" });
         },

         ready: () => {
            let Layout = $$(ids.dataFlexView);
            let Scroll = $$(ids.scrollview);

            // editor mode doesn't load this ui
            if (!Scroll || !Layout) return;

            Layout.enable();

            if (Scroll && !Scroll.hideProgress) {
               webix.extend(Scroll, webix.ProgressBar);
            }
            Scroll.hideProgress();
         },

         // we need to recursivly look backwards to toggle tabs into view when a user choosed to select a tab for edit or details views
         toggleTab: (parentTab, wb) => {
            // find the tab
            var tab = wb.getTopParentView().queryView({ id: parentTab });
            // if we didn't pass and id we may have passed a domNode
            if (tab == null) {
               tab = $$(parentTab);
            }

            if (tab == null) return;

            // set the tabbar to to the tab
            var tabbar = tab.getParentView().getParentView();

            if (tabbar == null) return;

            if (tabbar.setValue) {
               // if we have reached the top we won't have a tab
               tabbar.setValue(parentTab);
            }

            // find if it is in a multiview of a tab
            var nextTab = tabbar.queryView({ view: "scrollview" }, "parent");
            // if so then do this again
            if (nextTab) {
               com.toggleTab(nextTab, wb);
            }
         },

         /**
          * @method scroll
          * @param pos - {
          * 					x: {integer},
          * 					y: {integer}
          * 				}
          */
         scroll: async (pos) => {
            let loadWhen = 40;

            let y = pos.y;
            let maxYPos =
               $$(ids.dataFlexView).$height - $$(ids.scrollview).$height;
            if (maxYPos - y <= loadWhen) {
               if (this.loadMoreTimer) return;

               com.setYPos(y);

               var dc = this.datacollection;
               if (!dc) return;

               if ($$(ids.dataFlexView).getChildViews().length >= dc.totalCount)
                  return;

               // loading cursor
               com.logic.busy();

               await dc.loadData(
                  $$(ids.dataFlexView).getChildViews().length || 0
               );

               this.loadMoreTimer = setTimeout(() => {
                  this.loadMoreTimer = null;
               }, 1100);
            }
         },
      };

      com.onShow = () => {
         var dc = this.datacollection;
         if (!dc) return;

         if (dc.dataStatus == dc.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dc.loadData();
         } else if (dc.dataStatus == dc.dataStatusFlag.initialized) {
            com.renderData();
         }
      };

      com.setYPos = (pos) => {
         this.yPosition = pos;
      };

      com.getYPos = () => {
         return this.yPosition || 0;
      };

      com.emptyView = () => {
         let flexlayout = {
            id: ids.dataFlexView,
            view: "flexlayout",
            type: "clean",
            padding: 10,
            css: { background: "#ebedf0 !important" },
            cols: [],
         };
         webix.ui(flexlayout, $$(ids.scrollview), $$(ids.dataFlexView));
      };

      com.renderData = () => {
         let editPage = this.settings.editPage;
         let detailsPage = this.settings.detailsPage;
         var editTab = this.settings.editTab;
         var detailsTab = this.settings.detailsTab;
         var records = [];

         var dc = this.datacollection;
         if (!dc) {
            com.logic.ready();
            return;
         }

         let Layout = $$(ids.dataFlexView) || $$(ids.component);

         if (!Layout || isNaN(Layout.$width)) {
            com.logic.ready();
            return;
         }

         let recordWidth = Math.floor(
            (Layout.$width - 20 - parseInt(this.settings.xCount) * 20) /
               parseInt(this.settings.xCount)
         );

         var rows = dc.getData();

         // if this amount of data is already parsed just skip the rest.
         if (Layout.currentLength == rows.length) {
            com.logic.ready();
            return;
         }

         Layout.currentLength = rows.length;

         // store total of rows
         this._startPos = Layout.getChildViews
            ? Layout.getChildViews().length
            : 0;

         let stopPos = rows.length;

         if (this._startPos == 0) {
            stopPos = rows.length;
         } else if (rows.length - this._startPos > 20) {
            stopPos = this._startPos + 20;
         }

         if (dc.settings.loadAll) {
            stopPos = rows.length;
         }

         var dataGrid = [];
         for (var i = this._startPos; i < stopPos; i++) {
            // get the components configuation
            let detailCom = App.AB.cloneDeep(super.component(App, rows[i].id));

            // adjust the UI to make sure it will look like a "card"
            detailCom.ui.type = "space";
            detailCom.ui.css = "ab-detail-view";
            if (detailsPage || editPage) {
               detailCom.ui.css += " ab-detail-hover ab-record-" + rows[i].id;
            }
            if (detailsPage) {
               detailCom.ui.css += " ab-detail-page";
            }
            if (editPage) {
               detailCom.ui.css += " ab-edit-page";
            }
            detailCom.ui.paddingX = 10;
            detailCom.ui.paddingY = 6;
            detailCom.ui.minWidth = recordWidth - 10;
            detailCom.ui.maxWidth = recordWidth;

            if (Layout.addView) {
               Layout.addView(detailCom.ui, -1);
               detailCom.init(null, 2); // 2 - Always allow access to components inside data view
               setTimeout(detailCom.logic.displayData(rows[i]), 0);
            } else {
               records.push(detailCom.ui);
            }
         }

         if (records.length) {
            var flexlayout = {
               id: ids.dataFlexView,
               view: "flexlayout",
               paddingX: 15,
               paddingY: 19,
               type: "space",
               cols: records,
            };
            webix.ui(flexlayout, $$(ids.scrollview), $$(ids.dataFlexView));

            for (let i = this._startPos; i < stopPos; i++) {
               let detailCom = App.AB.cloneDeep(
                  super.component(App, rows[i].id)
               );
               detailCom.init(null, 2); // 2 - Always allow access to components inside data view
               setTimeout(detailCom.logic.displayData(rows[i]), 0);
            }
         }

         if ($$(ids.scrollview)) {
            $$(ids.scrollview).scrollTo(0, com.getYPos());

            if (detailsPage || editPage) {
               Layout.$view.onclick = (e) => {
                  var clicked = false;
                  if (editPage) {
                     for (let p of e.path) {
                        if (
                           p.className &&
                           p.className.indexOf("webix_accordionitem_header") >
                              -1
                        ) {
                           clicked = true;
                           p.parentNode.parentNode.classList.forEach((c) => {
                              if (c.indexOf("ab-record-") > -1) {
                                 // var record = parseInt(c.replace("ab-record-", ""));
                                 var record = c.replace("ab-record-", "");
                                 linkPage.changePage(editPage, record);
                                 // com.logic.toggleTab(detailsTab, ids.component);
                              }
                           });
                           break;
                        }
                     }
                  }
                  if (detailsPage && !clicked) {
                     for (let p of e.path) {
                        if (
                           p.className &&
                           p.className.indexOf("webix_accordionitem") > -1
                        ) {
                           p.parentNode.parentNode.classList.forEach((c) => {
                              if (c.indexOf("ab-record-") > -1) {
                                 // var record = parseInt(c.replace("ab-record-", ""));
                                 var record = c.replace("ab-record-", "");
                                 linkPage.changePage(detailsPage, record);
                                 // com.logic.toggleTab(detailsTab, ids.component);
                              }
                           });
                           break;
                        }
                     }
                  }
               };
            }
         }

         //Add data-cy attributes for cypress tests
         const name = this.name.replace(".dataview", "");
         Layout.$view.setAttribute(
            "data-cy",
            `dataview container ${name} ${this.id}`
         );

         Layout.getChildViews().forEach((child, i) => {
            const uuid = rows[i + this._startPos]["uuid"];
            const view = child.$view;
            view
               .querySelector(".webix_accordionitem_body")
               .setAttribute(
                  "data-cy",
                  `dataview item ${name} ${uuid} ${this.id}`
               );
            view
               .querySelector(".webix_accordionitem_button")
               .setAttribute(
                  "data-cy",
                  `dataview item button ${name} ${uuid} ${this.id}`
               );
         });

         com.logic.ready();
      };

      return com;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new ABViewPropertyLinkPage();

      return this.__linkPageHelper;
   }
};


/***/ }),

/***/ 80414:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetail.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCore = __webpack_require__(/*! ../../core/views/ABViewDetailCore */ 12407);
const ABViewDetailComponent = __webpack_require__(/*! ./ABViewDetailComponent */ 66711);
const ABObjectQuery = __webpack_require__(/*! ../ABObjectQuery */ 88447);

const ABViewDetailPropertyComponentDefaults = ABViewDetailCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDetail extends ABViewDetailCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var comp = super.editorComponent(App, mode);

      // Define height of cell
      comp.ui.rows[0].cellHeight = 75;

      return comp;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // _logic functions

      _logic.selectSource = async (dcId, oldDcId) => {
         // TODO : warning message

         _logic.busy();

         let currView = _logic.currentEditObject();
         currView.settings.dataviewID = dcId;

         // clear sub views
         currView._views = [];

         this.propertyUpdateFieldOptions(ids, currView, dcId);

         // add all fields to editor by default
         if (currView._views.length > 0) return Promise.resolve();

         let fieldSaves = [];
         let fields = $$(ids.fields).find({});
         fields.reverse();
         fields.forEach((f, index) => {
            if (!f.selected) {
               let yPosition = fields.length - index - 1;

               var fieldView = currView.addFieldToView(f, yPosition, ids, App);
               fieldSaves.push(fieldView.save());

               // update item to UI list
               f.selected = 1;
               $$(ids.fields).updateItem(f.id, f);
            }
         });

         await Promise.all(fieldSaves);

         // Saving
         await currView.save();

         currView.emit("properties.updated", currView);

         _logic.ready();
      };

      _logic.listTemplate = (field, common) => {
         return `${common.markCheckbox(field)} ${field.label}`;
      };

      _logic.check = async (e, fieldId) => {
         var currView = _logic.currentEditObject();

         // update UI list
         var item = $$(ids.fields).getItem(fieldId);
         item.selected = item.selected ? 0 : 1;
         $$(ids.fields).updateItem(fieldId, item);

         // add a field to the form
         if (item.selected) {
            await currView.addFieldToView(item, null, ids, App).save();

            // Refresh UI
            currView.emit("properties.updated", currView);

            // .addFieldToView() does not auto update the currView:
            await currView.save();
         }
         // remove field in the form
         else {
            let fieldView = currView.views(
               (c) => c.settings.fieldId == fieldId
            )[0];
            if (fieldView) {
               // let remainingViews = currView.views(c => c.settings.fieldId != fieldId);
               // currView._views = remainingViews;

               await fieldView.destroy();

               // Refresh UI
               currView.emit("properties.updated", currView);
            }
         }

         // trigger a save()
         // this.propertyEditorSave(ids, currView);
      };

      return commonUI.concat([
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            skipAutoSave: true,
            on: {
               onChange: (dcId, oldDcId) => _logic.selectSource(dcId, oldDcId),
            },
         },
         {
            name: "fields",
            view: "list",
            select: false,
            minHeight: 200,
            template: _logic.listTemplate,
            type: {
               markCheckbox: function (item) {
                  return (
                     "<span class='check webix_icon fa fa-" +
                     (item.selected ? "check-" : "") +
                     "square-o'></span>"
                  );
               },
            },
            onClick: {
               check: (e, fieldId) => _logic.check(e, fieldId),
            },
         },
         {
            name: "showLabel",
            view: "checkbox",
            label: L("Display Label"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "labelPosition",
            view: "richselect",
            label: L("Label Position"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "left",
                  value: L("Left"),
               },
               {
                  id: "top",
                  value: L("Top"),
               },
            ],
         },
         {
            name: "labelWidth",
            view: "counter",
            label: L("Label Width"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var SourceSelector = $$(ids.datacollection);
      var datacollectionId = view.settings.dataviewID || null;

      // Pull data views to options
      var dcOptions = view.propertyDatacollections();
      SourceSelector.define("options", dcOptions);
      SourceSelector.define("value", datacollectionId);
      SourceSelector.refresh();

      this.propertyUpdateFieldOptions(ids, view, datacollectionId);

      $$(ids.showLabel).setValue(
         view.settings.showLabel != null
            ? view.settings.showLabel
            : ABViewDetailPropertyComponentDefaults.showLabel
      );
      $$(ids.labelPosition).setValue(
         view.settings.labelPosition ||
            ABViewDetailPropertyComponentDefaults.labelPosition
      );
      $$(ids.labelWidth).setValue(
         parseInt(view.settings.labelWidth) ||
            ABViewDetailPropertyComponentDefaults.labelWidth
      );
      $$(ids.height).setValue(
         view.settings.height >= 0
            ? view.settings.height
            : ABViewDetailPropertyComponentDefaults.height
      );

      // update properties when a field component is deleted
      view.views().forEach((v) => {
         if (v instanceof ABViewDetailComponent)
            v.once("destroyed", () =>
               this.propertyEditorPopulate(App, ids, view)
            );
      });
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.showLabel = $$(ids.showLabel).getValue();
      view.settings.labelPosition = $$(ids.labelPosition).getValue();
      view.settings.labelWidth = $$(ids.labelWidth).getValue();
      view.settings.height = $$(ids.height).getValue();
   }

   static propertyUpdateFieldOptions(ids, view, dcId) {
      var datacollection = view.AB.datacollectionByID(dcId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object.fields().map((f) => {
            f.selected =
               view.views((com) => {
                  return f.id == com.settings.fieldId;
               }).length > 0;

            return f;
         });
      }

      $$(ids.fields).clearAll();
      $$(ids.fields).parse(fieldOptions);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj } App
    * @param {string} idPrefix - define to support in 'Datacollection' widget
    *
    * @return {obj } UI component
    */
   component(App, idPrefix) {
      // get webix.dashboard
      var container = super.component(App, idPrefix);

      var _ui = {
         type: "form",
         borderless: true,
         // height: this.settings.height || ABViewDetailPropertyComponentDefaults.height,
         rows: [
            {
               // view: "scrollview",
               body: container.ui,
            },
         ],
      };

      // make sure each of our child views get .init() called
      var _init = (options, parentAccessLevel) => {
         // populate .views to webix.dashboard
         container.init(options, parentAccessLevel);
      };

      var _logic = {
         displayData: (rowData) => {
            rowData = rowData || {};

            let views = this.views() || [];
            views = views.sort((a, b) => {
               if (!a || !b || !a.field || !b.field) return 0;

               // NOTE: sort order of calculated fields.
               // FORMULA field type should be calculated before CALCULATE field type
               if (a.field.key == "formula" && b.field.key == "calculate") {
                  return -1;
               } else if (
                  a.field.key == "calculate" &&
                  b.field.key == "formula"
               ) {
                  return 1;
               } else {
                  return 0;
               }
            });

            views.forEach((f) => {
               if (f.field) {
                  var field = f.field();
                  var val;

                  if (!field) return;

                  if (!rowData) return;

                  // get value of relation when field is a connect field
                  switch (field.key) {
                     case "connectObject":
                        val = field.pullRelationValues(rowData);
                        break;
                     case "list":
                        val = rowData[field.columnName];
                        if (!val) {
                           val = "";
                           break;
                        }

                        if (field.settings.isMultiple == 0) {
                           let myVal = "";

                           field.settings.options.forEach(function (options) {
                              if (options.id == val) myVal = options.text;
                           });

                           if (field.settings.hasColors) {
                              let myHex = "#66666";
                              let hasCustomColor = "";
                              field.settings.options.forEach(function (h) {
                                 if (h.text == myVal) {
                                    myHex = h.hex;
                                    hasCustomColor = "hascustomcolor";
                                 }
                              });
                              myVal = `<span class="webix_multicombo_value ${hasCustomColor}" style="background-color: ${myHex} !important;"><span>${myVal}</span></span>`;
                           }

                           val = myVal;
                        } else {
                           let items = [];
                           let myVal = "";
                           val.forEach((value) => {
                              var hasCustomColor = "";
                              var optionHex = "";
                              if (field.settings.hasColors && value.hex) {
                                 hasCustomColor = "hascustomcolor";
                                 optionHex = `background: ${value.hex};`;
                              }
                              field.settings.options.forEach(function (
                                 options
                              ) {
                                 if (options.id == value.id)
                                    myVal = options.text;
                              });
                              items.push(
                                 `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${value.id}"><span>${myVal}</span></span>`
                              );
                           });
                           val = items.join("");
                        }
                        break;
                     case "user":
                        val = field.pullRelationValues(rowData);
                        break;
                     case "file":
                        val = rowData[field.columnName];
                        break;
                     case "formula":
                        if (rowData) {
                           let dv = this.datacollection;
                           let ds = dv ? dv.datasource : null;
                           let needRecalculate =
                              !ds || ds instanceof ABObjectQuery ? false : true;

                           val = field.format(rowData, needRecalculate);
                        }
                        break;
                     default:
                        val = field.format(rowData);
                     // break;
                  }
               }

               // set value to each components
               var vComponent = f.component(App, idPrefix);

               // if (vComponent.onShow) vComponent.onShow();

               if (vComponent.logic && vComponent.logic.setValue) {
                  vComponent.logic.setValue(val);
               }

               if (vComponent.logic && vComponent.logic.displayText) {
                  vComponent.logic.displayText(rowData);
               }
            });
         },
      };

      var _onShow = () => {
         container.onShow();
         try {
            const dataCy = `Detail ${this.name.split(".")[0]} ${this.id}`;
            $$(container.ui.id).$view.setAttribute("data-cy", dataCy);
         } catch (e) {
            console.warn("Problem setting data-cy", e);
         }

         // listen DC events
         let dv = this.datacollection;
         if (dv) {
            let currData = dv.getCursor();
            if (currData) {
               _logic.displayData(currData);
            }

            this.eventAdd({
               emitter: dv,
               eventName: "changeCursor",
               listener: (newRow) => {
                  _logic.displayData(newRow);
               },
            });

            this.eventAdd({
               emitter: dv,
               eventName: "create",
               listener: (createdRow) => {
                  let currCursor = dv.getCursor();
                  if (currCursor && currCursor.id == createdRow.id)
                     _logic.displayData(createdRow);
               },
            });

            this.eventAdd({
               emitter: dv,
               eventName: "update",
               listener: (updatedRow) => {
                  let currCursor = dv.getCursor();
                  if (currCursor && currCursor.id == updatedRow.id)
                     _logic.displayData(updatedRow);
               },
            });
         }
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }

   clearFieldComponents() {
      let tasks = [];

      this.views().forEach((comp) => {
         tasks.push(() => comp.destroy());
      });

      return tasks.reduce((promiseChain, currTask) => {
         return promiseChain.then(currTask);
      }, Promise.resolve([]));
   }

   addFieldToView(field, yPosition, ids, App) {
      if (field == null) return;

      let newView = field.detailComponent().newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings || {};
      newView.settings.fieldId = field.id;
      newView.settings.labelWidth =
         this.settings.labelWidth ||
         ABViewDetailPropertyComponentDefaults.labelWidth;

      // keep alias to support Query that contains alias name
      // [alias].[columnName]
      newView.settings.alias = field.alias;

      // TODO : Default settings

      newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      // update properties when a sub-view is destroyed
      newView.once("destroyed", () => {
         ABViewDetail.propertyEditorPopulate(App, ids, this);
      });

      return newView;
   }
};


/***/ }),

/***/ 8990:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailCheckbox.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCheckboxCore = __webpack_require__(/*! ../../core/views/ABViewDetailCheckboxCore */ 24044);

module.exports = class ABViewDetailCheckbox extends ABViewDetailCheckboxCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDetailCheckboxEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var checkboxElem = this.component(App).ui;
      checkboxElem.id = ids.component;

      var _ui = {
         rows: [checkboxElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var component = super.component(App);
      var field = this.field();

      var idBase = "ABViewDetailCheckbox_" + (idPrefix || "") + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
         detail: this.parentDetailComponent()?.id || this.parent.id,
      };

      component.ui.id = ids.component;

      component.ui.on = {
         //Add data-cy attribute for Cypress Testing
         onAfterRender: () => {
            const dataCy = `detail checkbox ${field?.columnName} ${field?.id} ${ids.detail}`;
            $$(ids.component)?.$view.setAttribute("data-cy", dataCy);
         },
      };

      return {
         ui: component.ui,
         init: component.init,

         logic: {
            setValue: (val) => {
               var checkbox = "";

               // Check
               if (val && JSON.parse(val))
                  checkbox =
                     '<span class="check webix_icon fa fa-check-square-o"></span>';
               // Uncheck
               else
                  checkbox =
                     '<span class="check webix_icon fa fa-square-o"></span>';

               component.logic.setValue(ids.component, checkbox);
            },
         },
      };
   }
};


/***/ }),

/***/ 66711:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailComponent.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailComponentCore = __webpack_require__(/*! ../../core/views/ABViewDetailComponentCore */ 79809);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDetailComponent extends ABViewDetailComponentCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      return commonUI.concat([
         {
            name: "fieldLabel",
            view: "text",
            disabled: true,
            label: L("Field"),
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var field = view.field();

      if (field) {
         $$(ids.fieldLabel).setValue(field.label);
      }
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var idBase = "ABViewDetailComponent_" + (idPrefix || "") + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };
      // setup 'label' of the element
      var detailView = this.detailComponent(),
         field = this.field() || {},
         label = "";

      var settings = {};
      if (detailView) settings = detailView.settings;

      var isUsers = false;
      if (field && field.key == "user") isUsers = true;

      var templateLabel = "";
      if (settings.showLabel == true) {
         if (settings.labelPosition == "top")
            templateLabel =
               "<label style='display:block; text-align: left;' class='webix_inp_top_label'>#label#</label>#display#";
         else
            templateLabel =
               "<label style='width: #width#px; display: inline-block; float: left; line-height: 32px;'>#label#</label><div class='ab-detail-component-holder' style='margin-left: #width#px;'>#display#</div>";
      }
      // no label
      else {
         templateLabel = "#display#";
      }

      var template = templateLabel
         .replace(/#width#/g, settings.labelWidth)
         .replace(/#label#/g, field ? field.label : "");

      var height = 38;
      if (settings.labelPosition == "top") height = height * 2;

      if (
         field &&
         field.settings &&
         typeof field.settings.useHeight != "undefined" &&
         field.settings.useHeight == 1
      ) {
         height = parseInt(field.settings.imageHeight) || height;
      }

      var _ui = {
         id: ids.component,
         view: "template",
         borderless: true,
         height: height,
         isUsers: isUsers,
         template: template,
         data: { display: "" }, // show empty data in template
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {};

      var _logic = {
         setValue: (componentId, val) => {
            if ($$(componentId)) {
               if (field.key == "string" || field.key == "LongText") {
                  val = val.replace(/[<]/g, "&lt;");
               } else if (field.key == "user") {
                  val = val.text ?? val.value ?? val.username ?? val;
               }
               $$(componentId).setValues({ display: val });
            }
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }
};


/***/ }),

/***/ 77855:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailConnect.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailConnectCore = __webpack_require__(/*! ../../core/views/ABViewDetailConnectCore */ 16497);
const ABViewPropertyAddPage = (__webpack_require__(/*! ./viewProperties/ABViewPropertyAddPage */ 95751)["default"]);

module.exports = class ABViewDetailConnect extends ABViewDetailConnectCore {
   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.addPageTool.fromSettings(this.settings);
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      let commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      let idBase = "ABViewDetailConnectPropertyEditor";

      if (this.addPageProperty == null) {
         this.addPageProperty = ABViewPropertyAddPage.propertyComponent(
            App,
            idBase
         );
         this.addPageProperty.init({
            onSave: () => {
               let currView = _logic.currentEditObject();
               if (!currView) return;

               // refresh settings
               this.propertyEditorValues(ids, currView);

               // trigger a save()
               this.propertyEditorSave(ids, currView);
            },
         });
      }

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([this.addPageProperty.ui]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      this.addPageProperty.setSettings(view, view.settings);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings = this.addPageProperty.getSettings(view);

      // refresh settings of app page tool
      view.addPageTool.fromSettings(view.settings);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      let idBase = "ABViewDetailConnect_" + (idPrefix || "") + this.id;
      let baseComp = super.component(App, idBase);
      var ids = {
         detail: this.parentDetailComponent()?.id || this.parent.id,
      };

      let addPageComponent = this.addPageTool.component(App, idBase);

      let _init = (options) => {
         baseComp.init(options);

         addPageComponent.applicationLoad(this.application);
         addPageComponent.init({
            // TODO : callbacks
         });
      };

      baseComp.ui.on = {
         //Add data-cy attribute for Cypress Testing
         onAfterRender: () => {
            let field = this.field((fld) => {
               return fld.id == this.settings.fieldId;
            });
            // some form fields are remaining in the UI even after removed from data structure
            if (field?.columnName) {
               let columnName = field.columnName;
               const dataCy = `detail connected ${columnName} ${this.settings.fieldId} ${ids.detail}`;
               $$(baseComp.ui.id)?.$view.setAttribute("data-cy", dataCy);
            }
         },
      };

      // Click to open new data form
      // addPageComponent.ui.onClick = addPageComponent.ui.onClick || {};
      let ui = {};
      if (addPageComponent.ui) {
         addPageComponent.ui.click = (e, id, trg) => {
            // e.stopPropagation();

            // TODO: busy cursor

            let dc;
            let detail = this.detailComponent();
            if (detail) dc = detail.datacollection;

            setTimeout(() => {
               addPageComponent.onClick(dc);
            }, 50);

            return false;
         };

         ui = {
            rows: [
               {
                  cols: [baseComp.ui, addPageComponent.ui],
               },
            ],
         };
      } else {
         ui = baseComp.ui;
      }

      return {
         ui: ui,

         init: _init,
         logic: {
            setValue: (val) => {
               let vals = [];
               if (Array.isArray(val)) {
                  val.forEach((record) => {
                     vals.push(
                        `<span class="webix_multicombo_value">${record.text}</span>`
                     );
                  });
               } else {
                  vals.push(
                     `<span class="webix_multicombo_value">${val.text}</span>`
                  );
               }
               baseComp.logic.setValue(baseComp.ui.id, vals.join(""));
            },
         },
      };
   }

   get addPageTool() {
      if (this.__addPageTool == null)
         this.__addPageTool = new ABViewPropertyAddPage();

      return this.__addPageTool;
   }
};


/***/ }),

/***/ 92885:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailCustom.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCustomCore = __webpack_require__(/*! ../../core/views/ABViewDetailCustomCore */ 78276);

module.exports = class ABViewDetailCustom extends ABViewDetailCustomCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDetailCustomEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var component = this.component(App);

      var textElem = component.ui;
      textElem.id = ids.component;

      var _ui = {
         rows: [textElem, {}],
      };

      var _init = component.init;
      var _logic = component.logic;

      var _onShow = component.onShow;

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var component = super.component(App);
      var field = this.field();
      var detailView = this.detailComponent();

      var idBase = "ABViewDetailCustom_" + (idPrefix || "") + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
         detail: this.parentDetailComponent()?.id || this.parent.id,
      };

      var templateLabel = "";
      if (detailView.settings.showLabel == true) {
         if (detailView.settings.labelPosition == "top")
            templateLabel =
               "<label style='display:block; text-align: left;' class='webix_inp_top_label'>#label#</label>";
         else
            templateLabel =
               "<label style='width: #width#px; display: inline-block; float: left; line-height: 32px;'>#label#</label>";
      }

      var template = (templateLabel + "#result#")
         // var template = (templateLabel)
         .replace(/#width#/g, detailView.settings.labelWidth)
         .replace(/#label#/g, field ? field.label : "")
         .replace(/#result#/g, field ? field.columnHeader().template({}) : "");

      component.ui.id = ids.component;
      component.ui.view = "template";
      component.ui.minHeight = 45;
      component.ui.height = 60;
      component.ui.borderless = true;
      component.ui.template = template;

      component.ui.on = {
         //Add data-cy attribute for Cypress Testing
         onAfterRender: () => {
            const dataCy = `detail custom ${field?.columnName} ${field?.id} ${ids.detail}`;
            $$(ids.component)?.$view.setAttribute("data-cy", dataCy);
         },
      };

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      component.onShow = () => {
         if (!field) return;

         var elem = $$(ids.component);
         if (!elem) return;

         var detailCom = this.detailComponent(),
            rowData = detailCom.datacollection.getCursor() || {},
            node = elem.$view;

         field.customDisplay(rowData, App, node, {
            editable: false,
         });
      };

      component.logic.setValue = (val) => {
         if (!field) return;

         var elem = $$(ids.component);
         if (!elem) return;

         var rowData = {};
         rowData[field.columnName] = val;

         field.setValue(elem, rowData);
      };

      return component;
   }
};


/***/ }),

/***/ 69903:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailImage.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailImageCore = __webpack_require__(/*! ../../core/views/ABViewDetailImageCore */ 81597);

const ABViewDetailImagePropertyComponentDefaults = ABViewDetailImageCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDetailImage extends ABViewDetailImageCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDetailImageEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var elem = this.component(App).ui;
      elem.id = ids.component;

      var _ui = {
         rows: [elem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "width",
            label: L("Width:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.height).setValue(
         view.settings.height ||
            ABViewDetailImagePropertyComponentDefaults.height
      );
      $$(ids.width).setValue(
         view.settings.width || ABViewDetailImagePropertyComponentDefaults.width
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.height = $$(ids.height).getValue();
      view.settings.width = $$(ids.width).getValue();
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var component = super.component(App);
      var field = this.field();

      var idBase = `ABViewDetailImage_${idPrefix || ""}${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
         detail: this.parentDetailComponent()?.id || this.parent.id,
      };

      var defaultImageUrl = field ? field.settings.defaultImageUrl : "";

      component.ui.id = ids.component;

      if (this.settings.height) component.ui.height = this.settings.height;

      // if (this.settings.width)
      // 	component.ui.width = this.settings.width;

      component.ui.on = {
         //Add data-cy attribute for Cypress Testing
         onAfterRender: () => {
            const dataCy = `detail image ${field?.columnName} ${field?.id} ${ids.detail}`;
            $$(ids.component)?.$view.setAttribute("data-cy", dataCy);
         },
      };

      var _logic = {
         setValue: (val) => {
            var imageTemplate = "";

            if (val || (!val && defaultImageUrl)) {
               let imageUrl = field.urlImage(val || defaultImageUrl);
               let width =
                  field && field.settings.imageWidth
                     ? `${field.settings.imageWidth}px`
                     : "200px";
               let height =
                  field && field.settings.imageHeight
                     ? `${field.settings.imageHeight}px`
                     : "100%";

               if (this.settings.height) height = `${this.settings.height}px`;

               if (this.settings.width) width = `${this.settings.width}px`;

               imageTemplate =
                  `<div class="ab-image-data-field">` +
                  `<div style="float: left; background-size: cover; background-position: center center; background-image:url('${imageUrl}');  width: ${width}; height: ${height}; position:relative;">` +
                  `<a href="${imageUrl}" target="_blank" title="" class="fa fa-download ab-image-data-field-download"></a>` +
                  `</div></div>`;
            }

            component.logic.setValue(ids.component, imageTemplate);
         },
      };

      return {
         ui: component.ui,
         init: component.init,

         logic: _logic,
      };
   }
};


/***/ }),

/***/ 82011:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailText.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailTextCore = __webpack_require__(/*! ../../core/views/ABViewDetailTextCore */ 89207);

const ABViewDetailTextPropertyComponentDefaults = ABViewDetailTextCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDetailText extends ABViewDetailTextCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDetailTextEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var textElem = this.component(App).ui;
      textElem.id = ids.component;

      var _ui = {
         rows: [textElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.height).setValue(
         view.settings.height ||
            ABViewDetailTextPropertyComponentDefaults.height
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.height = $$(ids.height).getValue();
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var component = super.component(App);
      var field = this.field();
      var idBase = "ABViewDetailText_" + (idPrefix || "") + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
         detail: this.parentDetailComponent()?.id || this.parent.id,
      };

      component.ui.id = ids.component;

      component.ui.css = "ab-text";

      if (this.settings.height) component.ui.height = this.settings.height;

      component.ui.on = {
         //Add data-cy attribute for Cypress Testing
         onAfterRender: () => {
            const dataCy = `detail text ${field?.columnName} ${field?.id} ${ids.detail}`;
            $$(ids.component)?.$view.setAttribute("data-cy", dataCy);
         },
      };

      return {
         ui: component.ui,
         init: component.init,

         logic: {
            setValue: (val) => {
               component.logic.setValue(ids.component, val);
            },
         },
      };
   }
};


/***/ }),

/***/ 73216:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let ABViewDetailTreeCore = __webpack_require__(/*! ../../core/views/ABViewDetailTreeCore */ 7716);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDetailTree extends ABViewDetailTreeCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDetailTreeEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var elem = this.component(App).ui;
      elem.id = ids.component;

      var _ui = {
         rows: [elem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);
   }

   /**
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var component = super.component(App);
      var field = this.field();
      var detailView = this.detailComponent();

      var idBase = `ABViewDetailTree_${idPrefix || ""}${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };
      var className = "ab-detail-tree";

      component.ui.id = ids.component;

      var _init = (options) => {
         component.init(options);

         // add div of tree to detail
         var divTree = `<div class="${className}"></div>`;
         component.logic.setValue(ids.component, divTree);
      };

      var _logic = {
         getDomTree: () => {
            var elem = $$(ids.component);
            if (!elem) return;

            return elem.$view.getElementsByClassName(className)[0];
         },

         setValue: (val) => {
            // convert value to array
            if (val != null && !(val instanceof Array)) {
               val = [val];
            }

            setTimeout(function () {
               // get tree dom
               var domTree = _logic.getDomTree();

               if (!domTree) return false;

               var branches = [];
               if (typeof field.settings.options.data == "undefined") {
                  field.settings.options = new webix.TreeCollection({
                     data: field.settings.options,
                  });
               }

               field.settings.options.data.each(function (obj) {
                  if (val != null && val.indexOf(obj.id) != -1) {
                     var html = "";

                     var rootid = obj.id;
                     while (this.getParentId(rootid)) {
                        field.settings.options.data.each(function (par) {
                           if (
                              field.settings.options.data.getParentId(rootid) ==
                              par.id
                           ) {
                              html = par.text + ": " + html;
                           }
                        });
                        rootid = this.getParentId(rootid);
                     }

                     html += obj.text;
                     branches.push(html);
                  }
               });

               var myHex = "#4CAF50";
               var nodeHTML = "<div class='list-data-values'>";
               branches.forEach(function (item) {
                  nodeHTML +=
                     '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
                     myHex +
                     ' !important;">' +
                     item +
                     "</span>";
               });
               nodeHTML += "</div>";
               domTree.innerHTML = nodeHTML;

               var height = 33;
               if (domTree.scrollHeight > 33) height = domTree.scrollHeight;

               $$(ids.component).config.height = height;
               $$(ids.component).resize();
            }, 50);
         },
      };

      return {
         ui: component.ui,

         init: _init,
         logic: _logic,
      };
   }
};


/***/ }),

/***/ 4804:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDocxBuilder.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDocxBuilderCore = __webpack_require__(/*! ../../core/views/ABViewDocxBuilderCore */ 24107);

const ABFieldConnect = __webpack_require__(/*! ../dataFields/ABFieldConnect */ 66589);
const ABFieldImage = __webpack_require__(/*! ../dataFields/ABFieldImage */ 70780);
const ABObjectQuery = __webpack_require__(/*! ../ABObjectQuery */ 88447);

const Docxtemplater = __webpack_require__(/*! ../../../js/docxtemplater.v3.0.12.min.js */ 49590);
const ImageModule = __webpack_require__(/*! ../../../js/docxtemplater-image-module.v3.0.2.min.js */ 82824);
const JSZipUtils = __webpack_require__(/*! jszip-utils/dist/jszip-utils.min.js */ 45863);
const JSZip = __webpack_require__(/*! ../../../js/jszip.min.js */ 31290);

const ABViewDocxBuilderPropertyComponentDefaults = ABViewDocxBuilderCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

function letUserDownload(blob, filename) {
   let url = window.URL.createObjectURL(blob);

   let a = document.createElement("a");
   a.href = url;
   a.download = filename;
   document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
   a.click();
   a.remove(); //afterwards we remove the element again

   window.URL.revokeObjectURL(url);
}

module.exports = class ABViewDocxBuilder extends ABViewDocxBuilderCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewDocxBuilderEditorComponent";

      var DocxBuilderComponent = this.component(App, idBase);

      return DocxBuilderComponent;
   }

   //
   // Property Editor
   //
   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      _logic.validateType = (item) => {
         // verify file type
         var acceptableTypes = ["docx"];
         var type = item.type.toLowerCase();
         if (acceptableTypes.indexOf(type) == -1) {
            //// TODO: multilingual
            webix.message(
               "Only [" + acceptableTypes.join(", ") + "] files are supported"
            );
            return false;
         } else {
            // set upload url to uploader
            let currView = _logic.currentEditObject();
            let uploadUrl = currView.uploadUrl();

            $$(ids.docxFile).define("upload", uploadUrl);
            $$(ids.docxFile).refresh();

            return true;
         }
      };

      _logic.uploadedFile = (fileInfo) => {
         if (!fileInfo || !fileInfo.data) return;

         let currView = _logic.currentEditObject();
         currView.settings.filename = fileInfo.data.uuid;
         currView.filelabel = fileInfo.name;

         $$(ids.filelabel).setValue(currView.filelabel);
         $$(ids.docxDownload).show();
      };

      _logic.downloadFile = () => {
         let currView = _logic.currentEditObject();
         let url = currView.downloadUrl();

         fetch(url)
            .then((response) => response.blob())
            .then((blob) => {
               letUserDownload(blob, currView.filelabel);
            });
      };

      // Populate language options
      var langOptions = App.AB.Multilingual.languages().map((lang) => {
         return {
            id: lang.language_code,
            value: lang.language_label,
         };
      });

      $$(ids.language).define("options", langOptions);
      $$(ids.language).refresh();

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            view: "fieldset",
            label: L("Data:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "datacollection",
                     // view: 'richselect',
                     view: "multicombo",
                     label: L("Data Source"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
               ],
            },
         },

         {
            view: "fieldset",
            label: L("Template file:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("DOCX file:"),
                           css: "ab-text-bold",
                           width: this.AB.UISettings.config().labelWidthXLarge,
                        },
                        {
                           view: "uploader",
                           value: L("Upload"),
                           name: "docxFile",
                           apiOnly: true,
                           inputName: "file",
                           multiple: false,
                           on: {
                              onBeforeFileAdd: (item) => {
                                 return _logic.validateType(item);
                              },

                              onFileUpload: (file, response) => {
                                 _logic.uploadedFile(file);
                              },

                              onFileUploadError: (file, response) => {},
                           },
                        },
                     ],
                  },
                  {
                     name: "filelabel",
                     view: "text",
                     label: L("Filename"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
                  {
                     name: "docxDownload",
                     view: "button",
                     type: "icon",
                     css: "webix_primary",
                     icon: "fa fa-file-word-o",
                     label: L("Download Template File"),
                     click: () => {
                        _logic.downloadFile();
                     },
                  },
               ],
            },
         },

         {
            view: "fieldset",
            label: L("Language:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "language",
                     view: "richselect",
                     label: L("Language"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
               ],
            },
         },

         {
            view: "fieldset",
            label: L("Customize Display:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "buttonlabel",
                     view: "text",
                     label: L("Label"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  },

                  {
                     view: "counter",
                     name: "width",
                     label: L("Width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  },
                  {
                     view: "richselect",
                     name: "toolbarBackground",
                     label: L("Page background:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                     options: [
                        {
                           id: "ab-background-default",
                           value: L("White (default)"),
                        },
                        {
                           id: "webix_dark",
                           value: L("Dark"),
                        },
                        {
                           id: "ab-background-lightgray",
                           value: L("Gray"),
                        },
                     ],
                  },

                  {
                     view: "richselect",
                     name: "buttonPosition",
                     label: L("Button Position:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                     options: [
                        {
                           id: "left",
                           value: L("Left (default)"),
                        },
                        {
                           id: "center",
                           value: L("Centered"),
                        },
                        {
                           id: "right",
                           value: L("Right"),
                        },
                     ],
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      let $DcSelector = $$(ids.datacollection);

      let selectedDvId = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;

      $$(ids.toolbarBackground).setValue(
         view.settings.toolbarBackground ||
            ABViewDocxBuilderPropertyComponentDefaults.toolbarBackground
      );
      $$(ids.buttonPosition).setValue(
         view.settings.buttonPosition ||
            ABViewDocxBuilderPropertyComponentDefaults.buttonPosition
      );

      // Pull data views to options
      let dcOptions = view.AB.datacollections().map((dc) => {
         return {
            id: dc.id,
            value: dc.label,
         };
      });

      $DcSelector.define("options", dcOptions);
      $DcSelector.define("value", selectedDvId);
      $DcSelector.refresh();

      $$(ids.language).setValue(
         view.settings.language ||
            ABViewDocxBuilderPropertyComponentDefaults.language
      );

      $$(ids.filelabel).setValue(view.filelabel || view.settings.filelabel);
      $$(ids.buttonlabel).setValue(
         view.buttonlabel || view.settings.buttonlabel
      );
      $$(ids.width).setValue(view.settings.width);

      if (view.settings.filename) {
         $$(ids.docxDownload).show();
      } else {
         $$(ids.docxDownload).hide();
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.buttonlabel = $$(ids.buttonlabel).getValue();
      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.width = $$(ids.width).getValue();
      view.filelabel = $$(ids.filelabel).getValue();
      view.settings.language = $$(ids.language).getValue();
      view.settings.toolbarBackground = $$(ids.toolbarBackground).getValue();
      view.settings.buttonPosition = $$(ids.buttonPosition).getValue();
   }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseCom = super.component(App);

      var idBase = "ABViewDocxBuilder_" + this.id;
      var ids = {
         button: App.unique(`${idBase}_button`),
         noFile: App.unique(`${idBase}_noFile`),
      };

      var autowidth = false;
      var buttonWidth =
         this.settings.width ||
         ABViewDocxBuilderPropertyComponentDefaults.width;
      if (buttonWidth == 0) {
         autowidth = true;
      }

      var leftSpacer = {
         type: "spacer",
         width: 1,
      };
      var rightSpacer = {
         type: "spacer",
         width: 1,
      };
      var buttonPos =
         this.settings.buttonPosition ||
         ABViewDocxBuilderPropertyComponentDefaults.buttonPosition;
      if (buttonPos == "left") {
         rightSpacer = {
            type: "spacer",
         };
      } else if (buttonPos == "center") {
         leftSpacer = {
            type: "spacer",
         };
         rightSpacer = {
            type: "spacer",
         };
      } else if (buttonPos == "right") {
         leftSpacer = {
            type: "spacer",
         };
      }

      var buttonLabelText = this.buttonlabel || this.settings.buttonlabel;
      if (!buttonLabelText) {
         buttonLabelText =
            ABViewDocxBuilderPropertyComponentDefaults.buttonlabel;
      }

      var _ui = {
         view: "toolbar",
         css:
            this.settings.toolbarBackground ||
            ABViewDocxBuilderPropertyComponentDefaults.toolbarBackground,
         cols: [
            leftSpacer,
            {
               id: ids.button,
               view: "button",
               css: "webix_primary",
               type: "icon",
               icon: "fa fa-file-word-o",
               label: buttonLabelText,
               width:
                  this.settings.width ||
                  ABViewDocxBuilderPropertyComponentDefaults.width,
               autowidth: autowidth,
               click: () => {
                  _logic.renderFile();
               },
               on: {
                  // Add data-cy attribute for cypress tests
                  onAfterRender: () => {
                     const name = this.name.replace(".docxBuilder", "");
                     const dataCy = `docx download ${name} ${this.id}`;
                     $$(ids.button)
                        ?.$view.querySelector("button")
                        .setAttribute("data-cy", dataCy);
                  },
               },
            },
            {
               id: ids.noFile,
               view: "label",
               label: L("No template file"),
            },
            {
               type: "spacer",
            },
            rightSpacer,
         ],
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {
         let DownloadButton = $$(ids.button);
         let NoFileLabel = $$(ids.noFile);

         if (this.settings.filename) {
            DownloadButton.show();
            NoFileLabel.hide();
         } else {
            DownloadButton.hide();
            NoFileLabel.show();
         }
      };

      let _logic = {
         busy: () => {
            let DownloadButton = $$(ids.button);
            if (!DownloadButton) return;

            DownloadButton.disable();

            DownloadButton.define("icon", "fa fa-refresh fa-spin");
            DownloadButton.refresh();
         },

         ready: () => {
            let DownloadButton = $$(ids.button);
            if (!DownloadButton) return;

            DownloadButton.enable();

            DownloadButton.define("icon", "fa fa-file-word-o");
            DownloadButton.refresh();
         },

         onShow: (viewId) => {
            let tasks = [];

            this.datacollections.forEach((dc) => {
               if (dc && dc.dataStatus == dc.dataStatusFlag.notInitial) {
                  // load data when a widget is showing
                  tasks.push(dc.loadData());
               }
            });

            // Show loading cursor
            if (tasks.length > 0) _logic.busy();

            Promise.all(tasks)
               .catch((err) => console.error(err))
               .then(() => {
                  // Hide loading cursor
                  _logic.ready();
               });
         },

         renderFile: () => {
            _logic.busy();

            let reportValues = {};
            let images = {};
            let summaries = {}; // { varName: sum number, ..., varName2: number2 }

            Promise.resolve()
               // Get current cursor
               .then(() => {
                  let datacollections = this.datacollections;
                  let isDcLabelAdded = datacollections.length > 1;

                  datacollections.forEach((dc) => {
                     if (dc == null) return;

                     let obj = dc.datasource;
                     if (obj == null) return;

                     let dcValues = [];
                     let dataList = [];

                     let dcCursor = dc.getCursor();

                     // merge cursor to support dc and tree cursor in the report
                     if (dcCursor) {
                        let treeCursor = dc.getCursor(true);
                        dataList.push(App.AB.merge({}, dcCursor, treeCursor));
                     } else dataList = App.AB.cloneDeep(dc.getData());

                     // update property names to column labels to match format names in docx file
                     let mlFields = obj.multilingualFields();

                     let setReportValues = (
                        baseData,
                        targetData,
                        field,
                        fieldLabels = []
                     ) => {
                        let val = null;

                        targetData.id = baseData.id;
                        targetData[`${field.columnName}_ORIGIN`] =
                           baseData[field.columnName]; // Keep origin value for compare value with custom index

                        // Translate multilinguage fields
                        if (mlFields.length) {
                           let transFields = (mlFields || []).filter(
                              (fieldName) => baseData[fieldName] != null
                           );
                           this.translate(
                              baseData,
                              baseData,
                              transFields,
                              this.languageCode
                           );
                        }

                        // Pull value
                        if (field instanceof ABFieldConnect) {
                           // If field is connected field, then
                           // {
                           //		fieldName: {Object} or [Array]
                           // }
                           val = baseData[field.columnName];

                           if (val && val.forEach) {
                              val.forEach((v) => {
                                 if (v == null) return;

                                 // format relation data
                                 if (field.datasourceLink) {
                                    field.datasourceLink
                                       .fields((f) => !f.isConnection)
                                       .forEach((f) => {
                                          v[`${f.columnName}_ORIGIN`] =
                                             v[f.columnName];

                                          v[f.columnName] = f.format(v, {
                                             languageCode: this.languageCode,
                                          });
                                       });
                                 }

                                 // Keep ABObject to relation data
                                 if (v && typeof v == "object")
                                    v._object = field.datasourceLink;
                              });
                           }
                           // TODO
                           // data[label + '_label'] = field.format(baseData);
                        } else {
                           val = field.format(baseData, {
                              languageCode: this.languageCode,
                           });
                        }

                        // Set value to report with every languages of label
                        fieldLabels.forEach((label) => {
                           if (val) {
                              targetData[label] = val;
                           } else if (!targetData[label]) {
                              targetData[label] = "";
                           }
                        });

                        // normalize child items
                        if (baseData.data && baseData.data.length) {
                           targetData.data = targetData.data || [];
                           (baseData.data || []).forEach((childItem, index) => {
                              // add new data item
                              if (targetData.data[index] == null)
                                 targetData.data[index] = {};

                              setReportValues(
                                 childItem,
                                 targetData.data[index],
                                 field,
                                 fieldLabels
                              );
                           });
                        }
                     };

                     dataList.forEach((data) => {
                        let resultData = {};

                        // Keep id of ABObject into .scope of DOCX templater
                        resultData._object = obj;

                        // For support label of columns every languages
                        obj.fields().forEach((f) => {
                           let fieldLabels = [];

                           // Query Objects
                           if (obj instanceof ABObjectQuery) {
                              if (typeof f.object.translations == "string")
                                 f.object.translations = JSON.parse(
                                    f.object.translations
                                 );

                              if (typeof f.translations == "string")
                                 f.translations = JSON.parse(f.translations);

                              (f.object.translations || []).forEach(
                                 (objTran) => {
                                    let fieldTran = (
                                       f.translations || []
                                    ).filter(
                                       (fieldTran) =>
                                          fieldTran.language_code ==
                                          objTran.language_code
                                    )[0];

                                    if (!fieldTran) return;

                                    let objectLabel = objTran.label;
                                    let fieldLabel = fieldTran.label;

                                    // Replace alias with label of object
                                    fieldLabels.push(
                                       `${objectLabel}.${fieldLabel}`
                                    );
                                 }
                              );
                           }
                           // Normal Objects
                           else {
                              if (typeof f.translations == "string")
                                 f.translations = JSON.parse(f.translations);

                              f.translations.forEach((tran) => {
                                 fieldLabels.push(tran.label);
                              });
                           }

                           setReportValues(data, resultData, f, fieldLabels);
                        });

                        dcValues.push(resultData);
                     });

                     // If data sources have more than 1 or the result data more than 1 items, then add label of data source
                     let datacollectionData =
                        dcValues.length > 1 ? dcValues : dcValues[0];
                     if (
                        isDcLabelAdded ||
                        (Array.isArray(datacollectionData) &&
                           datacollectionData.length > 1)
                     ) {
                        (dc.translations || []).forEach((tran) => {
                           reportValues[tran.label] = datacollectionData;
                        });
                     } else reportValues = datacollectionData;
                  });

                  return Promise.resolve();
               })
               // Download images
               .then(() => {
                  console.log("DOCX data: ", reportValues);

                  let tasks = [];

                  let addDownloadTask = (fieldImage, data = []) => {
                     data.forEach((d) => {
                        let imageVal = fieldImage.format(d);
                        if (imageVal && !images[imageVal]) {
                           tasks.push(
                              new Promise((ok, bad) => {
                                 let imgUrl = fieldImage.urlImage(imageVal); // `/opsportal/image/${this.application.name}/${imageVal}`;

                                 JSZipUtils.getBinaryContent(
                                    imgUrl,
                                    function (error, content) {
                                       if (error) return bad(error);
                                       else {
                                          // store binary of image
                                          images[imageVal] = content;

                                          ok();
                                       }
                                    }
                                 );
                              })
                           );
                        }

                        // download images of child items
                        addDownloadTask(fieldImage, d.data || []);
                     });
                  };

                  this.datacollections.forEach((dc) => {
                     if (!dc) return;

                     let obj = dc.datasource;
                     if (!obj) return;

                     let currCursor = dc.getCursor();
                     if (currCursor) {
                        // Current cursor
                        let treeCursor = dc.getCursor(true);
                        currCursor = [App.AB.merge({}, currCursor, treeCursor)];
                     } // List of data
                     else currCursor = dc.getData();

                     obj.fields((f) => f instanceof ABFieldImage).forEach(
                        (f) => {
                           addDownloadTask(f, currCursor);
                        }
                     );
                  });

                  return Promise.all(tasks);
               })
               .then(() => {
                  // Download the template file
                  return new Promise((next, err) => {
                     let url = this.downloadUrl();

                     JSZipUtils.getBinaryContent(url, (error, content) => {
                        if (error) return err(error);

                        next(content);
                     });
                  });
               })
               .then((content) => {
                  // Generate Docx file
                  return new Promise((next, err) => {
                     let zip = new JSZip(content);
                     let doc = new Docxtemplater();

                     let imageModule = new ImageModule({
                        centered: false,
                        getImage: (tagValue, tagName) => {
                           // NOTE: .getImage of version 3.0.2 does not support async
                           //			we can buy newer version to support it
                           //			https://docxtemplater.com/modules/image/

                           return images[tagValue] || "";
                        },
                        getSize: (imgBuffer, tagValue, tagName) => {
                           let defaultVal = [300, 160];

                           let dc = this.datacollection;
                           if (!dc) {
                              let dcs = this.datacollections;
                              if (dcs) {
                                 dcs.forEach((dc) => {
                                    let obj = dc.datasource;
                                    if (!obj) return false;

                                    // This is a query object
                                    if (tagName.indexOf(".") > -1) {
                                       let tagNames = tagName.split(".");

                                       if (!obj.objects) return false; // not a query
                                       obj = obj.objects(
                                          (o) => o.label == tagNames[0]
                                       )[0]; // Label of object
                                       if (!obj) return false;

                                       tagName = tagNames[1]; // Field name
                                    }

                                    let imageField = obj.fields(
                                       (f) => f.columnName == tagName
                                    )[0];
                                    if (!imageField || !imageField.settings)
                                       return false;

                                    if (
                                       imageField.settings.useWidth &&
                                       imageField.settings.imageWidth
                                    )
                                       defaultVal[0] =
                                          imageField.settings.imageWidth;

                                    if (
                                       imageField.settings.useHeight &&
                                       imageField.settings.imageHeight
                                    )
                                       defaultVal[1] =
                                          imageField.settings.imageHeight;

                                    return false;
                                 });
                                 return defaultVal;
                              } else {
                                 return defaultVal;
                              }
                           } else {
                              let obj = dc.datasource;
                              if (!obj) return defaultVal;

                              // This is a query object
                              if (tagName.indexOf(".") > -1) {
                                 let tagNames = tagName.split(".");

                                 obj = obj.objects(
                                    (o) => o.label == tagNames[0]
                                 )[0]; // Label of object
                                 if (!obj) return defaultVal;

                                 tagName = tagNames[1]; // Field name
                              }

                              let imageField = obj.fields(
                                 (f) => f.columnName == tagName
                              )[0];
                              if (!imageField || !imageField.settings)
                                 return defaultVal;

                              if (
                                 imageField.settings.useWidth &&
                                 imageField.settings.imageWidth
                              )
                                 defaultVal[0] = imageField.settings.imageWidth;

                              if (
                                 imageField.settings.useHeight &&
                                 imageField.settings.imageHeight
                              )
                                 defaultVal[1] =
                                    imageField.settings.imageHeight;

                              return defaultVal;
                           }
                        },
                        // getSize: function (imgBuffer, tagValue, tagName) {
                        // 	if (imgBuffer) {
                        // 		var maxWidth = 300;
                        // 		var maxHeight = 160;

                        // 		// Find aspect ratio image dimensions
                        // 		try {
                        // 			var image = sizeOf(imgBuffer);
                        // 			var ratio = Math.min(maxWidth / image.width, maxHeight / image.height);

                        // 			return [image.width * ratio, image.height * ratio];
                        // 		}
                        // 		// if invalid image, then should return 0, 0 sizes
                        // 		catch (err) {
                        // 			return [0, 0];
                        // 		}

                        // 	}
                        // 	else {
                        // 		return [0, 0];
                        // 	}
                        // }
                     });

                     try {
                        doc.attachModule(imageModule)
                           .loadZip(zip)
                           .setData(reportValues)
                           .setOptions({
                              parser: function (tag) {
                                 return {
                                    get: function (scope, context) {
                                       // NOTE: AppBuilder custom filter : no return empty items
                                       if (tag.indexOf("data|") == 0) {
                                          let prop = (
                                             tag.split("|")[1] || ""
                                          ).trim();

                                          return (scope["data"] || []).filter(
                                             function (item) {
                                                return item[prop]
                                                   ? true
                                                   : false;
                                             }
                                          );
                                       }
                                       // Mark number to add to a variable
                                       else if (tag.indexOf("|$sum?") > -1) {
                                          let prop = tag.split("|$sum?")[0];
                                          let varName = tag.split("|$sum?")[1];

                                          let number = scope[prop];
                                          if (typeof number == "string") {
                                             number = number.replace(
                                                /[^\d.]/g, // return only number and dot
                                                ""
                                             );
                                          }

                                          if (summaries[varName] == null)
                                             summaries[varName] = 0.0;

                                          summaries[varName] += parseFloat(
                                             number
                                          );

                                          return scope[prop];
                                       }
                                       // Show sum value ^
                                       else if (tag.indexOf("$sum?") == 0) {
                                          let varName = tag.replace(
                                             "$sum?",
                                             ""
                                          );

                                          return summaries[varName] || 0;
                                       }
                                       // // Sum number of .data (Grouped query)
                                       // else if (tag.indexOf("$sum|") == 0) {
                                       //    let prop = (
                                       //       tag.split("|")[1] || ""
                                       //    ).trim();

                                       //    let sum = 0;
                                       //    (scope["data"] || []).forEach(
                                       //       (childItem) => {
                                       //          if (!childItem[prop]) return;

                                       //          let number = childItem[prop];
                                       //          if (typeof number == "string") {
                                       //             number = number.replace(
                                       //                /[^\d.]/g, // return only number and dot
                                       //                ""
                                       //             );
                                       //          }

                                       //          try {
                                       //             sum += parseFloat(
                                       //                number || 0
                                       //             );
                                       //          } catch (e) {}
                                       //       }
                                       //    );

                                       //    // Print number with commas
                                       //    if (sum) {
                                       //       sum = sum
                                       //          .toString()
                                       //          .replace(
                                       //             /\B(?=(\d{3})+(?!\d))/g,
                                       //             ","
                                       //          );
                                       //    }

                                       //    return sum;
                                       // }
                                       // NOTE: AppBuilder custom filter of another data source
                                       else if (tag.indexOf("$") == 0) {
                                          let props = tag
                                             .replace("$", "")
                                             .split("|");
                                          let propSource = props[0].trim();
                                          let propFilter = props[1].trim(); // column name of ABFieldConnect

                                          if (!propSource || !propFilter)
                                             return "";

                                          // Pull Index field of connect field
                                          let indexColName;
                                          let obj = scope._object;
                                          if (obj) {
                                             let connectedField = obj.fields(
                                                (f) =>
                                                   f.columnName == propFilter
                                             )[0];
                                             if (connectedField) {
                                                let indexField =
                                                   connectedField.indexField;
                                                indexColName = indexField
                                                   ? indexField.columnName
                                                   : null;
                                             }
                                          }

                                          let sourceVals =
                                             reportValues[propSource];
                                          if (
                                             sourceVals &&
                                             !Array.isArray(sourceVals)
                                          )
                                             sourceVals = [sourceVals];

                                          let getVal = (data) => {
                                             return (
                                                data[
                                                   `${indexColName}_ORIGIN`
                                                ] || // Pull origin data to compare by custom index
                                                data[indexColName] ||
                                                data.id ||
                                                data
                                             );
                                          };

                                          return (sourceVals || []).filter(
                                             function (item) {
                                                // Pull data of parent to compare
                                                let comparer =
                                                   scope[propFilter];

                                                if (Array.isArray(comparer))
                                                   return (
                                                      comparer.filter(
                                                         (c) =>
                                                            getVal(c) ==
                                                            getVal(item)
                                                      ).length > 0
                                                   );
                                                else {
                                                   return (
                                                      getVal(item) ==
                                                      getVal(comparer)
                                                   );
                                                }
                                             }
                                          );
                                       }
                                       // ์NOTE : Custom filter
                                       else if (tag.indexOf("?") > -1) {
                                          let result = scope;
                                          let prop = tag.split("?")[0];
                                          let condition = tag.split("?")[1];
                                          if (prop && condition) {
                                             let data = scope[prop];
                                             if (data) {
                                                if (!Array.isArray(data))
                                                   data = [data];

                                                return data.filter((d) =>
                                                   eval(
                                                      condition.replace(
                                                         /\./g,
                                                         "d."
                                                      )
                                                   )
                                                );
                                             }
                                          }
                                          return result;
                                       } else if (tag === ".") {
                                          return scope;
                                       } else {
                                          return scope[tag];
                                       }
                                    },
                                 };
                              },
                           })
                           .render(); // render the document
                     } catch (error) {
                        return err(error);
                     }

                     var docxFile = doc.getZip().generate({
                        type: "blob",
                        mimeType:
                           "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                     }); //Output the document using Data-URI

                     next(docxFile);
                  });
               })
               .then((blobFile) => {
                  // Let user download the output file
                  return new Promise((next, err) => {
                     letUserDownload(blobFile, this.filelabel);

                     next();
                  });
               })
               // Final step
               .then(() => {
                  _logic.ready();
               });
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
         onShow: _logic.onShow,
      };
   }
};


/***/ }),

/***/ 70704:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewForm.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCore = __webpack_require__(/*! ../../core/views/ABViewFormCore */ 36980);
const ABViewFormButton = __webpack_require__(/*! ./ABViewFormButton */ 15651);
const ABViewFormCustom = __webpack_require__(/*! ./ABViewFormCustom */ 79662);
const ABViewFormConnect = __webpack_require__(/*! ./ABViewFormConnect */ 46311);
const ABViewFormComponent = __webpack_require__(/*! ./ABViewFormComponent */ 93787);
const ABViewFormSelectMultiple = __webpack_require__(/*! ./ABViewFormSelectMultiple */ 38386);
const ABViewFormTextbox = __webpack_require__(/*! ./ABViewFormTextbox */ 48167);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 26204);
const ABSubmitRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 51567);

let PopupRecordRule = null;
let PopupSubmitRule = null;

////
//// LEFT OFF HERE: Review and Refactor
////
const ABViewFormPropertyComponentDefaults = ABViewFormCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewForm extends ABViewFormCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var comp = super.editorComponent(App, mode);

      // Define height of cell
      comp.ui.rows[0].cellHeight = 75;

      return comp;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      var idBase = "ABViewForm";

      // PopupDisplayRule = new ABDisplayRule(App, idBase + "_displayrule");

      PopupRecordRule = new ABRecordRule();
      PopupRecordRule.component(App, `${idBase}_recordrule`); // prepare the UI component.

      PopupSubmitRule = new ABSubmitRule();
      PopupSubmitRule.component(App, `${idBase}_submitrule`);

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         // TODO : warning message

         _logic.busy();

         let currView = _logic.currentEditObject();
         let formView = currView.parentFormComponent();

         currView.settings.dataviewID = dcId;

         // clear sub views
         var viewsToRemove = currView._views;
         currView._views = [];

         return (
            Promise.resolve()
               .then(() => {
                  var allRemoves = [];
                  viewsToRemove.forEach((v) => {
                     allRemoves.push(v.destroy());
                  });
                  return Promise.all(allRemoves);
               })
               // .then(() => {
               // 	// remove all old components
               // 	let destroyTasks = [];
               // 	if (oldDcId != null) {
               // 		let oldComps = formView.views();
               // 		oldComps.forEach(child => destroyTasks.push(() => child.destroy()));
               // 	}

               // 	return destroyTasks.reduce((promiseChain, currTask) => {
               // 		return promiseChain.then(currTask);
               // 	}, Promise.resolve([]));
               // })
               .then(() => {
                  // refresh UI
                  // formView.emit('properties.updated', currView);

                  _logic.busy();

                  // Update field options in property
                  this.propertyUpdateFieldOptions(ids, currView, dcId);

                  // add all fields to editor by default
                  if (currView._views.length > 0) return Promise.resolve();

                  let saveTasks = [];
                  let fields = $$(ids.fields).find({});
                  fields.reverse();
                  fields.forEach((f, index) => {
                     if (!f.selected) {
                        let yPosition = fields.length - index - 1;

                        // Add new form field
                        let newFieldView = currView.addFieldToForm(
                           f,
                           yPosition
                        );
                        if (newFieldView) {
                           newFieldView.once("destroyed", () =>
                              this.propertyEditorPopulate(App, ids, currView)
                           );

                           // // Call save API
                           saveTasks.push(newFieldView.save());
                        }

                        // update item to UI list
                        f.selected = 1;
                        $$(ids.fields).updateItem(f.id, f);
                     }
                  });

                  let defaultButton = formView.refreshDefaultButton(ids);
                  if (defaultButton) saveTasks.push(defaultButton.save());

                  return Promise.all(saveTasks);
               })
               // Saving
               .then(() => {
                  //// NOTE: the way the .addFieldToForm() works, it will prevent
                  //// the typical field.save() -> triggering the form.save() on a
                  //// new Field.  So once all our field.saves() are finished, we
                  //// need to perform a form.save() to persist the changes.
                  return currView.save();
               })
               // Finally
               .then(() => {
                  // refresh UI
                  formView.emit("properties.updated", currView);

                  // Update field options in property
                  this.propertyUpdateRules(ids, currView, dcId);

                  _logic.ready();

                  return Promise.resolve();
               })
         );
      };

      _logic.listTemplate = (field, common) => {
         let currView = _logic.currentEditObject();

         // disable in form
         var fieldComponent = field.formComponent();
         if (fieldComponent == null)
            return "<i class='fa fa-times'></i>  #label# <div class='ab-component-form-fields-component-info'> Disable </div>".replace(
               "#label#",
               field.label
            );

         var componentKey = fieldComponent.common().key;
         var formComponent = currView.application.viewAll(
            (v) => v.common().key == componentKey
         )[0];

         return `${common.markCheckbox(field)} ${
            field.label
         } <div class='ab-component-form-fields-component-info'> <i class='fa fa-${
            formComponent ? formComponent.common().icon : "fw"
         }'></i> ${
            formComponent ? L(formComponent.common().labelKey) : ""
         } </div>`;
      };

      _logic.check = (e, fieldId) => {
         let currView = _logic.currentEditObject();
         let formView = currView.parentFormComponent();

         // update UI list
         let item = $$(ids.fields).getItem(fieldId);
         item.selected = item.selected ? 0 : 1;
         $$(ids.fields).updateItem(fieldId, item);

         let doneFn = () => {
            formView
               .refreshDefaultButton(ids)
               .save()
               .then(() => {
                  // refresh UI
                  currView.emit("properties.updated", currView);
               });

            // // trigger a save()
            // this.propertyEditorSave(ids, currView);
         };

         // add a field to the form
         if (item.selected) {
            let fieldView = currView.addFieldToForm(item);
            if (fieldView) {
               fieldView.save().then(() => {
                  fieldView.once("destroyed", () =>
                     this.propertyEditorPopulate(App, ids, currView)
                  );
                  currView.save().then(() => {
                     doneFn();
                  });
               });
            }
         }
         // remove field in the form
         else {
            let fieldView = formView
               .fieldComponents()
               .filter((c) => c.settings.fieldId == fieldId)[0];
            if (fieldView) {
               // let remainingViews = formView.views(c => c.settings.fieldId != fieldId);
               // formView._views = remainingViews;

               fieldView.destroy().then(() => {
                  doneFn();
               });
            }
         }
      };

      // Display rule
      _logic.displayRuleShow = () => {
         // var currView = _logic.currentEditObject();
         // PopupDisplayRule.setValue(currView.settings.displayRules);
         // PopupDisplayRule.show();
      };

      _logic.displayRuleSave = () => {};

      // Record rule
      _logic.recordRuleShow = () => {
         var currView = _logic.currentEditObject();

         var selectedDv = currView.datacollection;
         if (selectedDv) {
            PopupRecordRule.objectLoad(selectedDv.datasource);
         }
         PopupRecordRule.formLoad(currView);
         PopupRecordRule.fromSettings(currView.settings.recordRules);
         PopupRecordRule.show();

         // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
         // choosers properly if it hasn't been shown before the .setValue() call.
         // so this work around allows us to refresh the display after the .show()
         // on the popup.
         // When they've fixed the bug, we'll remove this workaround:
         PopupRecordRule.qbFixAfterShow();
      };

      _logic.recordRuleSave = (settings) => {
         var currView = _logic.currentEditObject();
         currView.settings.recordRules = settings;

         // trigger a save()
         this.propertyEditorSave(ids, currView);

         // update badge number of rules
         this.populateBadgeNumber(ids, currView);
      };

      // Submit rule
      _logic.submitRuleShow = () => {
         var currView = _logic.currentEditObject();

         PopupSubmitRule.fromSettings(currView.settings.submitRules);
         PopupSubmitRule.show();
      };

      _logic.submitRuleSave = (settings) => {
         var currView = _logic.currentEditObject();
         currView.settings.submitRules = settings;

         // trigger a save()
         this.propertyEditorSave(ids, currView);

         // update badge number of rules
         this.populateBadgeNumber(ids, currView);
      };

      /** Initial rule popups */
      // PopupDisplayRule.init({
      // 	onSave: _logic.displayRuleSave
      // });

      PopupRecordRule.init({
         onSave: _logic.recordRuleSave,
      });

      PopupSubmitRule.init({
         onSave: _logic.submitRuleSave,
      });

      return commonUI.concat([
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            skipAutoSave: true,
            on: {
               onChange: _logic.selectSource,
            },
         },

         {
            view: "fieldset",
            label: L("Form Fields:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "fields",
                     view: "list",
                     select: false,
                     minHeight: 200,
                     template: _logic.listTemplate,
                     type: {
                        markCheckbox: function (item) {
                           return (
                              "<span class='check webix_icon fa fa-" +
                              (item.selected ? "check-" : "") +
                              "square-o'></span>"
                           );
                        },
                     },
                     onClick: {
                        check: _logic.check,
                     },
                  },
               ],
            },
         },
         {
            name: "showLabel",
            view: "checkbox",
            label: L("Display Label"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "labelPosition",
            view: "richselect",
            label: L("Label Position"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            options: [
               {
                  id: "left",
                  value: L("Left"),
               },
               {
                  id: "top",
                  value: L("Top"),
               },
            ],
         },
         {
            name: "labelWidth",
            view: "counter",
            label: L("Label Width"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "clearOnLoad",
            view: "checkbox",
            label: L("Clear on load"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "clearOnSave",
            view: "checkbox",
            label: L("Clear on save"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "fieldset",
            label: L("Rules:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Submit Rules:"),
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           name: "buttonSubmitRules",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.submitRuleShow();
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Display Rules:"),
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "buttonDisplayRules",
                           css: "webix_primary",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.displayRuleShow();
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Record Rules:"),
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "buttonRecordRules",
                           css: "webix_primary",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.recordRuleShow();
                           },
                        },
                     ],
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view, logic) {
      super.propertyEditorPopulate(App, ids, view, logic);

      var formCom = view.parentFormComponent();
      var datacollectionId = formCom.settings.dataviewID
         ? formCom.settings.dataviewID
         : null;
      var SourceSelector = $$(ids.datacollection);

      // Pull data collections to options
      var dcOptions = view.propertyDatacollections((dc) => {
         var obj = dc.datasource;

         return dc.sourceType == "object" && obj && !obj.isImported;
      });
      SourceSelector.define("options", dcOptions);
      SourceSelector.define("value", datacollectionId);
      SourceSelector.refresh();

      this.propertyUpdateFieldOptions(ids, view, datacollectionId);

      // update properties when a field component is deleted
      view.views().forEach((v) => {
         if (v instanceof ABViewFormComponent)
            v.once("destroyed", () =>
               this.propertyEditorPopulate(App, ids, view)
            );
      });

      SourceSelector.enable();
      $$(ids.showLabel).setValue(view.settings.showLabel);
      $$(ids.labelPosition).setValue(
         view.settings.labelPosition ||
            ABViewFormPropertyComponentDefaults.labelPosition
      );
      $$(ids.labelWidth).setValue(
         view.settings.labelWidth ||
            ABViewFormPropertyComponentDefaults.labelWidth
      );
      $$(ids.height).setValue(
         view.settings.height || ABViewFormPropertyComponentDefaults.height
      );
      $$(ids.clearOnLoad).setValue(
         view.settings.clearOnLoad ||
            ABViewFormPropertyComponentDefaults.clearOnLoad
      );
      $$(ids.clearOnSave).setValue(
         view.settings.clearOnSave ||
            ABViewFormPropertyComponentDefaults.clearOnSave
      );

      this.propertyUpdateRules(ids, view, datacollectionId);
      this.populateBadgeNumber(ids, view);

      // when a change is made in the properties the popups need to reflect the change
      this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
      if (!this.updateEventIds[view.id]) {
         this.updateEventIds[view.id] = true;

         view.addListener("properties.updated", () => {
            this.populateBadgeNumber(ids, view);
         });
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.showLabel = $$(ids.showLabel).getValue();
      view.settings.labelPosition =
         $$(ids.labelPosition).getValue() ||
         ABViewFormPropertyComponentDefaults.labelPosition;
      view.settings.labelWidth =
         $$(ids.labelWidth).getValue() ||
         ABViewFormPropertyComponentDefaults.labelWidth;
      view.settings.height = $$(ids.height).getValue();
      view.settings.clearOnLoad = $$(ids.clearOnLoad).getValue();
      view.settings.clearOnSave = $$(ids.clearOnSave).getValue();
   }

   /**
    * @method propertyUpdateFieldOptions
    * Populate fields of object to select list in property
    *
    * @param {Object} ids
    * @param {ABViewForm} view - the current component
    * @param {string} dcId - id of ABDatacollection
    */
   static propertyUpdateFieldOptions(ids, view, dcId) {
      var formComponent = view.parentFormComponent();
      var existsFields = formComponent.fieldComponents();
      var datacollection = view.AB.datacollectionByID(dcId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object.fields().map((f) => {
            f.selected =
               existsFields.filter((com) => {
                  return f.id == com.settings.fieldId;
               }).length > 0;

            return f;
         });
      }

      $$(ids.fields).clearAll();
      $$(ids.fields).parse(fieldOptions);
   }

   static propertyUpdateRules(ids, view, dcId) {
      if (!view) return;

      // Populate values to rules
      var selectedDv = view.datacollection;
      if (selectedDv) {
         // PopupDisplayRule.objectLoad(selectedDv.datasource);
         PopupRecordRule.objectLoad(selectedDv.datasource);
         PopupSubmitRule.objectLoad(selectedDv.datasource);
      }

      // PopupDisplayRule.formLoad(view);
      PopupRecordRule.formLoad(view);
      PopupSubmitRule.formLoad(view);
   }

   static populateBadgeNumber(ids, view) {
      if (!view) return;

      if (view.settings.submitRules) {
         $$(ids.buttonSubmitRules).define(
            "badge",
            view.settings.submitRules.length || null
         );
         $$(ids.buttonSubmitRules).refresh();
      } else {
         $$(ids.buttonSubmitRules).define("badge", null);
         $$(ids.buttonSubmitRules).refresh();
      }

      if (view.settings.displayRules) {
         $$(ids.buttonDisplayRules).define(
            "badge",
            view.settings.displayRules.length || null
         );
         $$(ids.buttonDisplayRules).refresh();
      } else {
         $$(ids.buttonDisplayRules).define("badge", null);
         $$(ids.buttonDisplayRules).refresh();
      }

      if (view.settings.recordRules) {
         $$(ids.buttonRecordRules).define(
            "badge",
            view.settings.recordRules.length || null
         );
         $$(ids.buttonRecordRules).refresh();
      } else {
         $$(ids.buttonRecordRules).define("badge", null);
         $$(ids.buttonRecordRules).refresh();
      }
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      this.App = App;
      var idBase = "ABViewForm_" + this.id;
      this.uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         return App.unique(`${idBase}_${key}_${this.uniqueInstanceID}`);
      };
      var ids = {
         component: myUnique("_component"),
         layout: myUnique("_form_layout"),
         filterComplex: myUnique("_filter_complex"),
      };

      var component = super.component(App);

      // Pull fields that have validation rules
      var fieldValidations = [];
      var validationUI = [];
      // NOTE: this._currentObject can be set in the KanBan Side Panel
      var object = this.datacollection?.datasource ?? this._currentObject;
      if (object) {
         var existsFields = this.fieldComponents();

         object.fields().forEach((f) => {
            var view = existsFields.filter((com) => {
               return f.id == com.settings.fieldId;
            })[0];

            // check to see if field has validation rules
            if (view && f.settings.validationRules) {
               // parse the rules because they were stored as a string
               // check if rules are still a string...if so lets parse them
               if (typeof f.settings.validationRules === "string") {
                  f.settings.validationRules = JSON.parse(
                     f.settings.validationRules
                  );
               }
               // there could be more than one so lets loop through and build the UI
               f.settings.validationRules.forEach((rule) => {
                  var Filter = this.AB.filterComplexNew(
                     `${f.columnName}_${webix.uid()}`
                  );
                  // add the new ui to an array so we can add them all at the same time
                  validationUI.push(Filter.ui);
                  // store the filter's info so we can assign values and settings after the ui is rendered
                  fieldValidations.push({
                     filter: Filter,
                     view: Filter.ids.querybuilder,
                     columnName: f.columnName,
                     validationRules: rule.rules,
                     invalidMessage: rule.invalidMessage,
                  });
               });
            }
         });
      }

      var fieldValidationsHolder = [
         {
            hidden: true,
            rows: validationUI,
         },
         // {},
      ];

      // an ABViewForm_ is a collection of rows:
      var _ui = {
         // view: "scrollview",
         // height: this.settings.height || ABViewFormPropertyComponentDefaults.height,
         // body: {
         id: ids.component,
         view: "form",
         abid: this.id,
         rows: component.ui.rows.concat(fieldValidationsHolder),
         // elementsConfig: {
         //    on: {
         //       onChange: function(newv, oldv) {
         //          this.validate();
         //       }
         //    }
         // }
         // }
      };

      // make sure each of our child views get .init() called
      var _init = (options, accessLevel) => {
         // register our callbacks:
         if (options) {
            for (var c in _logic.callbacks) {
               _logic.callbacks[c] = options[c] || _logic.callbacks[c];
            }
         }

         component.init(options, accessLevel);

         var Form = $$(ids.component);
         if (Form) {
            webix.extend(Form, webix.ProgressBar);
         }

         if (accessLevel < 2) {
            Form.disable();
         }

         // bind a data collection to form component
         let dc = this.datacollection;
         if (dc) {
            // listen DC events
            this.eventAdd({
               emitter: dc,
               eventName: "changeCursor",
               listener: (...p) => _logic.displayData(...p),
            });

            this.eventAdd({
               emitter: dc,
               eventName: "initializingData",
               listener: () => {
                  let Form = $$(ids.component);
                  if (Form) {
                     Form.disable();
                     if (Form.showProgress) Form.showProgress({ type: "icon" });
                  }
               },
            });

            this.eventAdd({
               emitter: dc,
               eventName: "initializedData",
               listener: () => {
                  let Form = $$(ids.component);
                  if (Form) {
                     Form.enable();
                     if (Form.hideProgress) Form.hideProgress();
                  }
               },
            });

            this.eventAdd({
               emitter: dc,
               eventName: "ab.datacollection.update",
               listener: (msg, data) => {
                  if (!data || !data.objectId) return;

                  let object = dc.datasource;
                  if (!object) return;

                  if (
                     object.id == data.objectId ||
                     object.fields(
                        (f) => f.settings.linkObject == data.objectId
                     ).length > 0
                  ) {
                     let currData = dc.getCursor();
                     if (currData) _logic.displayData(currData);
                  }
               },
            });

            // bind the cursor event of the parent DC
            var linkDv = dc.datacollectionLink;
            if (linkDv) {
               // update the value of link field when data of the parent dc is changed
               this.eventAdd({
                  emitter: linkDv,
                  eventName: "changeCursor",
                  listener: (...p) => _logic.displayParentData(...p),
               });
            }

            if (fieldValidations.length) {
               // we need to store the rules for use later so lets build a container array
               var complexValidations = [];
               fieldValidations.forEach((f) => {
                  // init each ui to have the properties (app and fields) of the object we are editing
                  // f.filter.applicationLoad(dc.datasource.application);
                  f.filter.fieldsLoad(dc.datasource.fields());
                  // now we can set the value because the fields are properly initialized
                  f.filter.setValue(f.validationRules);
                  // if there are validation rules present we need to store them in a lookup hash
                  // so multiple rules can be stored on a single field
                  if (!Array.isArray(complexValidations[f.columnName]))
                     complexValidations[f.columnName] = [];

                  // now we can push the rules into the hash
                  complexValidations[f.columnName].push({
                     filters: $$(f.view).getFilterHelper(),
                     // values: $$(ids.component).getValues(),
                     invalidMessage: f.invalidMessage,
                  });
               });
               // use the lookup to build the validation rules
               Object.keys(complexValidations).forEach(function (key) {
                  // get our field that has validation rules
                  var formField = $$(ids.component).queryView({
                     name: key,
                  });
                  // store the rules in a data param to be used later
                  formField.$view.complexValidations = complexValidations[key];
                  // define validation rules
                  formField.define("validate", function (nval, oval, field) {
                     // get field now that we are validating
                     var fieldValidating = $$(ids.component).queryView({
                        name: field,
                     });
                     // default valid is true
                     var isValid = true;
                     // check each rule that was stored previously on the element
                     fieldValidating.$view.complexValidations.forEach(
                        (filter) => {
                           let object = dc.datasource;
                           let data = this.getValues();
                           // convert rowData from { colName : data } to { id : data }
                           var newData = {};
                           (object.fields() || []).forEach((field) => {
                              newData[field.id] = data[field.columnName];
                           });
                           // for the case of "this_object" conditions:
                           if (data.uuid) {
                              newData["this_object"] = data.uuid;
                           }

                           // use helper funtion to check if valid
                           var ruleValid = filter.filters(newData);
                           // if invalid we need to tell the field
                           if (ruleValid == false) {
                              isValid = false;
                              // we also need to define an error message
                              fieldValidating.define(
                                 "invalidMessage",
                                 filter.invalidMessage
                              );
                           }
                        }
                     );
                     return isValid;
                  });
                  formField.refresh();
               });
            }
         }

         // init DC in record rules
         if (
            this.settings &&
            this.settings.recordRules &&
            this.settings.recordRules.length
         ) {
            this.settings.recordRules.forEach((rule) => {
               if (
                  !rule ||
                  !rule.actionSettings ||
                  !rule.actionSettings.valueRules ||
                  !rule.actionSettings.valueRules.fieldOperations ||
                  !rule.actionSettings.valueRules.fieldOperations.length
               )
                  return;
               rule.actionSettings.valueRules.fieldOperations.forEach((op) => {
                  if (op.valueType != "exist") return;

                  let pullDataDC = this.AB.datacollectionByID(op.value);

                  if (
                     pullDataDC &&
                     pullDataDC.dataStatus ==
                        pullDataDC.dataStatusFlag.notInitial
                  ) {
                     pullDataDC.loadData();
                  }
               });
            });
         }

         // _onShow();
      };

      this.timerId = undefined;

      var _logic = (this._logic = {
         callbacks: {
            onBeforeSaveData: function () {
               return true;
            },
            onSaveData: function (saveData) {},
            clearOnLoad: function () {
               return false;
            },
         },

         displayData: (rowData) => {
            var customFields = this.fieldComponents((comp) => {
               return (
                  comp instanceof ABViewFormCustom ||
                  comp instanceof ABViewFormConnect ||
                  // rich text
                  (comp instanceof ABViewFormTextbox &&
                     comp.settings.type == "rich")
               );
            });
            // If setTimeout is already scheduled, no need to do anything
            if (this.timerId) {
               return;
            }

            this.timerId = setTimeout(() => {
               var customFields = this.fieldComponents((comp) => {
                  return (
                     comp instanceof ABViewFormCustom ||
                     comp instanceof ABViewFormConnect ||
                     // rich text
                     (comp instanceof ABViewFormTextbox &&
                        comp.settings.type == "rich")
                  );
               });

               // Set default values
               if (rowData == null) {
                  customFields.forEach((f) => {
                     var field = f.field();
                     if (!field) return;

                     var comp = this.viewComponents[f.id];
                     if (comp == null) return;

                     // var colName = field.columnName;
                     if (this._showed && comp.onShow) comp.onShow();

                     // set value to each components
                     var defaultRowData = {};
                     field.defaultValue(defaultRowData);
                     field.setValue(
                        $$(comp.ui.inputId ? comp.ui.inputId : comp.ui.id),
                        defaultRowData
                     );

                     comp.logic?.refresh?.(defaultRowData);
                  });
                  var normalFields = this.fieldComponents(
                     (comp) =>
                        comp instanceof ABViewFormComponent &&
                        !(comp instanceof ABViewFormCustom)
                  );
                  normalFields.forEach((f) => {
                     var field = f.field();
                     if (!field) return;

                     var comp = this.viewComponents[f.id];
                     if (comp == null) return;

                     if (f.key != "button") {
                        var colName = field.columnName;

                        // set value to each components
                        var values = {};
                        field.defaultValue(values);

                        if ($$(comp.ui.id))
                           $$(comp.ui.id).setValue?.(
                              values[colName] == null ? "" : values[colName]
                           );
                     }
                  });
               }

               // Populate value to custom fields
               else {
                  customFields.forEach((f) => {
                     var comp = this.viewComponents[f.id];
                     if (comp == null) return;

                     if (this._showed) comp.onShow?.();

                     // set value to each components
                     if (f.field()) {
                        if (comp.ui.inputId) {
                           f.field().setValue($$(comp.ui.inputId), rowData);
                        } else {
                           f.field().setValue($$(comp.ui.id), rowData);
                        }
                     }

                     comp.logic?.refresh?.(rowData);
                  });
               }
               this.timerId = undefined;
            }, 80);
         },

         displayParentData: (rowData) => {
            let dv = this.datacollection;
            var currCursor = dv.getCursor();

            // If the cursor is selected, then it will not update value of the parent field
            if (currCursor != null) return;

            var Form = $$(ids.component),
               relationField = dv.fieldLink;

            if (relationField == null) return;

            // Pull a component of relation field
            var relationFieldCom = this.fieldComponents((comp) => {
               if (!(comp instanceof ABViewFormComponent)) return false;

               return comp.field() && comp.field().id == relationField.id;
            })[0];

            if (relationFieldCom == null) return;

            var relationFieldView = this.viewComponents[relationFieldCom.id].ui
               .inputId;
            // if (
            //    this.viewComponents[relationFieldCom.id].ui.rows &&
            //    this.viewComponents[relationFieldCom.id].ui.rows[0] &&
            //    this.viewComponents[relationFieldCom.id].ui.rows[0].id
            // ) {
            //    relationFieldView = this.viewComponents[relationFieldCom.id].ui
            //       .rows[0].id;
            // }
            if (relationFieldView == null) return;

            var relationElem = $$(relationFieldView),
               relationName = relationField.relationName();

            // pull data of parent's dc
            var formData = {};
            formData[relationName] = rowData;

            // set data of parent to default value
            relationField.setValue(relationElem, formData);
         },
      });

      var _onShow = (data) => {
         this._showed = true;

         // call .onShow in the base component
         component.onShow();

         var Form = $$(ids.component);

         // var customFields = this.fieldComponents((comp) => {
         // 	return (comp instanceof ABViewFormCustom) ||
         // 		// rich text
         // 		((comp instanceof ABViewFormTextbox) && comp.settings.type == 'rich')
         // });
         // customFields.forEach((f) => {

         // 	var field = f.field();
         // 	if (!field) return;

         // 	var component = this.viewComponents[f.id];
         // 	if (!component) return;

         // 	// set value to each components
         // 	var rowData = {};
         // 	field.defaultValue(rowData);
         // 	field.setValue($$(component.ui.id), rowData);

         // });

         var dc = this.datacollection;
         if (dc) {
            if (Form) dc.bind(Form);

            // clear current cursor on load
            // if (this.settings.clearOnLoad || _logic.callbacks.clearOnLoad() ) {
            if (this.settings.clearOnLoad) {
               dc.setCursor(null);
               _logic.displayData(null);
            }
            // if the cursor is cleared before or after we need to make
            // sure the reload view button does not appear
            if (this.settings.clearOnLoad || this.settings.clearOnSave) {
               if ($$(ids.component + "_reloadView"))
                  $$(ids.component + "_reloadView")
                     .getParentView()
                     .removeView(ids.component + "_reloadView");
            }

            // pull data of current cursor
            data = dc.getCursor();

            // do this for the initial form display so we can see defaults
            _logic.displayData(data);

            // select parent data to default value
            var linkDv = dc.datacollectionLink;
            if (data == null && linkDv) {
               var parentData = linkDv.getCursor();
               _logic.displayParentData(parentData);
            }
         } else {
            // show blank data in the form
            _logic.displayData(data);
         }

         //Focus on first focusable component
         this.focusOnFirst();

         if (Form) Form.adjust();
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }

   refreshDefaultButton(ids) {
      // If default button is not exists, then skip this
      let defaultButton = this.views(
         (v) => v instanceof ABViewFormButton && v.settings.isDefault
      )[0];

      // Add a default button
      if (defaultButton == null) {
         defaultButton = ABViewFormButton.newInstance(this.application, this);
         defaultButton.settings.isDefault = true;
      }
      // Remove default button from array, then we will add it to be the last item later (.push)
      else {
         this._views = this.views(
            (v) => !(v instanceof ABViewFormButton) && !v.settings.isDefault
         );
      }

      // Calculate position Y of the default button
      let yList = this.views().map((v) => (v.position.y || 0) + 1);
      yList.push(this._views.length || 0);
      yList.push($$(ids.fields).length || 0);
      let posY = Math.max(...yList);

      // Update to be the last item
      defaultButton.position.y = posY;

      // Keep the default button is always the last item of array
      this._views.push(defaultButton);

      return defaultButton;
   }

   /**
    * @method getFormValues
    *
    * @param {webix form} formView
    * @param {ABObject} obj
    * @param {ABDatacollection} dc
    * @param {ABDatacollection} dcLink [optional]
    */
   getFormValues(formView, obj, dc, dcLink) {
      // get the fields that are on this form
      var visibleFields = ["id"]; // we always want the id so we can udpate records
      var loopForm = formView.getValues(function (obj) {
         visibleFields.push(obj.config.name);
      });

      // only get data passed from form
      let allVals = formView.getValues();
      let formVals = {};
      visibleFields.forEach((val) => {
         formVals[val] = allVals[val];
      });

      // get custom values
      var customFields = this.fieldComponents(
         (comp) =>
            comp instanceof ABViewFormCustom ||
            comp instanceof ABViewFormConnect ||
            comp instanceof ABViewFormSelectMultiple
      );
      customFields.forEach((f) => {
         var vComponent = this.viewComponents[f.id];
         if (vComponent == null) return;

         let field = f.field();
         if (field) {
            formVals[field.columnName] = vComponent.logic.getValue(formVals);
         }
      });

      // remove connected fields if they were not on the form and they are present in the formVals because it is a datacollection
      obj.connectFields().forEach((f) => {
         if (
            visibleFields.indexOf(f.columnName) == -1 &&
            formVals[f.columnName]
         ) {
            delete formVals[f.columnName];
            delete formVals[f.relationName()];
         }
      });

      // clear undefined values or empty arrays
      for (var prop in formVals) {
         if (formVals[prop] == null || formVals[prop].length == 0)
            formVals[prop] = "";
      }

      // Add parent's data collection cursor when a connect field does not show
      let linkValues;

      if (dcLink) {
         linkValues = dcLink.getCursor();
      }

      if (linkValues) {
         var objectLink = dcLink.datasource;

         var connectFields = obj.connectFields();
         connectFields.forEach((f) => {
            var formFieldCom = this.fieldComponents((fComp) => {
               return fComp.field && fComp.field().id == f.id;
            });

            if (
               objectLink.id == f.settings.linkObject &&
               formFieldCom.length < 1 && // check field does not show
               formVals[f.columnName] === undefined
            ) {
               let linkColName = f.indexField
                  ? f.indexField.columnName
                  : objectLink.PK();

               formVals[f.columnName] = {};
               formVals[f.columnName][linkColName] =
                  linkValues[linkColName] || linkValues.id;
            }
         });
      }

      // NOTE: need to pull data of current cursor to calculate Calculate & Formula fields
      // .formVals variable does not include data that does not display in the Form widget
      let cursorFormVals = Object.assign(dc.getCursor() || {}, formVals);

      // Set value of calculate or formula fields to use in record rule
      obj.fields((f) => f.key == "calculate" || f.key == "formula").forEach(
         (f) => {
            if (formVals[f.columnName] == null) {
               formVals[f.columnName] = f.format(cursorFormVals, true);
            }
         }
      );

      return formVals;
   }

   /**
    * @method validateData
    *
    * @param {webix form} formView
    * @param {ABObject} object
    * @param {object} formVals
    *
    * @return {boolean} isValid
    */
   validateData(formView, object, formVals) {
      let isValid = true;

      // validate required fields
      let requiredFields = this.fieldComponents(
         (fComp) =>
            (fComp.field &&
               fComp.field() &&
               fComp.field().settings.required == true) ||
            fComp.settings.required == true
      ).map((fComp) => fComp.field());

      // validate data
      let validator;
      if (isValid) {
         validator = object.isValidData(formVals);
         isValid = validator.pass();
      }

      $$(formView).validate();

      // Display required messages
      requiredFields.forEach((f) => {
         if (f && !formVals[f.columnName] && formVals[f.columnName] != "0") {
            formView.markInvalid(f.columnName, L("This is a required field."));
            isValid = false;

            // Fix position of invalid message
            let $forminput = formView.elements[f.columnName];
            if ($forminput) {
               // Y position
               let height = $forminput.$height;
               if (height < 56) {
                  $forminput.define("height", 60);
                  $forminput.resize();
               }

               // X position
               let domInvalidMessage = $forminput.$view.getElementsByClassName(
                  "webix_inp_bottom_label"
               )[0];
               if (
                  domInvalidMessage &&
                  !domInvalidMessage.style["margin-left"]
               ) {
                  domInvalidMessage.style.marginLeft = `${
                     this.settings.labelWidth ||
                     ABViewFormPropertyComponentDefaults.labelWidth
                  }px`;
               }
            }
         }
      });

      // if data is invalid
      if (!isValid) {
         let saveButton = formView.queryView({
            view: "button",
            type: "form",
         });

         // error message
         if (validator && validator.errors && validator.errors.length) {
            validator.errors.forEach((err) => {
               formView.markInvalid(err.name, err.message);
            });

            if (saveButton) saveButton.disable();
         } else {
            if (saveButton) saveButton.enable();
         }
      }

      return isValid;
   }

   /**
    * @method recordRulesReady()
    * This returns a Promise that gets resolved when all record rules report
    * that they are ready.
    * @return {Promise}
    */
   async recordRulesReady() {
      return this.RecordRule.rulesReady();
   }

   /**
    * @method saveData
    * save data in to database
    * @param formView - webix's form element
    *
    * @return {Promise}
    */
   async saveData(formView) {
      // call .onBeforeSaveData event
      // if this function returns false, then it will not go on.
      if (!this._logic.callbacks.onBeforeSaveData()) return;

      // form validate
      if (!formView || !formView.validate()) {
         // TODO : error message
         return;
      }

      formView.clearValidation();

      // get ABDatacollection
      var dv = this.datacollection;
      if (dv == null) return;

      // get ABObject
      var obj = dv.datasource;
      if (obj == null) return;

      // get ABModel
      var model = dv.model;
      if (model == null) return;

      // get update data
      var formVals = this.getFormValues(
         formView,
         obj,
         dv,
         dv.datacollectionLink
      );

      // wait for our Record Rules to be ready before we continue.
      await this.recordRulesReady();

      // update value from the record rule (pre-update)
      this.doRecordRulesPre(formVals);

      // validate data
      if (!this.validateData(formView, obj, formVals)) {
         return;
      }

      // show progress icon
      formView.showProgress?.({ type: "icon" });

      // form ready function
      var formReady = (newFormVals) => {
         // clear cursor after saving.
         if (dv) {
            if (this.settings.clearOnSave) {
               dv.setCursor(null);
               formView.clear();
            } else {
               if (newFormVals && newFormVals.id) dv.setCursor(newFormVals.id);
            }
         }

         formView.hideProgress?.();

         // if there was saved data pass it up to the onSaveData callback
         if (newFormVals) this._logic.callbacks.onSaveData(newFormVals);
      };

      let formError = (err) => {
         let saveButton = formView.queryView({
            view: "button",
            type: "form",
         });

         // mark error
         if (err) {
            if (err.invalidAttributes) {
               for (let attr in err.invalidAttributes) {
                  let invalidAttrs = err.invalidAttributes[attr];
                  if (invalidAttrs && invalidAttrs[0])
                     invalidAttrs = invalidAttrs[0];

                  formView.markInvalid(attr, invalidAttrs.message);
               }
            } else if (err.sqlMessage) {
               webix.message({
                  text: err.sqlMessage,
                  type: "error",
               });
            } else {
               webix.message({
                  text: "System could not save your data",
                  type: "error",
               });
               this.AB.notify.developer(err, {
                  message: "Could not save your data",
                  view: this.toObj(),
               });
            }
         }

         saveButton?.enable();

         formView?.hideProgress?.();
      };

      let newFormVals;
      // {obj}
      // The fully populated values returned back from service call
      // We use this in our post processing Rules

      try {
         // is this an update or create?
         if (formVals.id) {
            newFormVals = await model.update(formVals.id, formVals);
         } else {
            newFormVals = await model.create(formVals);
         }
      } catch (err) {
         formError(err.data);
         throw err;
      }

      try {
         await this.doRecordRules(newFormVals);
         // make sure any updates from RecordRules get passed along here.
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return newFormVals;
      } catch (err) {
         this.AB.notify.developer(err, {
            message: "Error processing Record Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
         // Question:  how do we respond to an error?
         // ?? just keep going ??
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return;
      }
   }

   focusOnFirst() {
      var topPosition = 0;
      var topPositionId = "";
      this.views().forEach((item) => {
         if (item.key == "textbox" || item.key == "numberbox") {
            if (item.position.y == topPosition) {
               topPosition = item.position.y;
               topPositionId = item.id;
            }
         }
      });
      var childComponent = this.viewComponents[topPositionId];
      if (childComponent && $$(childComponent.ui.id)) {
         $$(childComponent.ui.id).focus();
      }
   }
};


/***/ }),

/***/ 15651:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormButton.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormButtonCore = __webpack_require__(/*! ../../core/views/ABViewFormButtonCore */ 32609);

const ABViewFormButtonPropertyComponentDefaults = ABViewFormButtonCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormButton extends ABViewFormButtonCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormButtonEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var button = this.component(App).ui;
      button.id = ids.component;

      var _ui = {
         rows: [button, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "includeSave",
            view: "checkbox",
            label: L("Save"),
         },
         {
            name: "saveLabel",
            view: "text",
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            label: L("Save Label"),
            placeholder: L("Save Placeholder"),
         },
         {
            name: "includeCancel",
            view: "checkbox",
            label: L("Cancel"),
         },
         {
            name: "cancelLabel",
            view: "text",
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            label: L("Cancel Label"),
            placeholder: L("Cancel Placeholder"),
         },
         {
            name: "includeReset",
            view: "checkbox",
            label: L("Reset"),
         },
         {
            name: "resetLabel",
            view: "text",
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            label: L("Reset Label"),
            placeholder: L("Reset Placeholder"),
         },
         {
            name: "afterCancel",
            view: "richselect",
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            label: L("After Cancel"),
            // options: []
         },
         {
            name: "alignment",
            view: "richselect",
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            label: L("Alignment"),
            options: [
               {
                  id: "left",
                  value: L("Left"),
               },
               {
                  id: "center",
                  value: L("Center"),
               },
               {
                  id: "right",
                  value: L("Right"),
               },
            ],
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var pagesList = [];
      var allPage = view.application.pages();
      view.AddPagesToList(pagesList, view.application, view.pageRoot().id);

      var opts = pagesList.map(function (opt) {
         return {
            id: opt.id,
            value: opt.value,
         };
      });
      $$(ids.afterCancel).define("options", opts);

      $$(ids.includeSave).setValue(
         view.settings.includeSave != null
            ? view.settings.includeSave
            : ABViewFormButtonPropertyComponentDefaults.includeSave
      );
      $$(ids.includeCancel).setValue(
         view.settings.includeCancel != null
            ? view.settings.includeCancel
            : ABViewFormButtonPropertyComponentDefaults.includeCancel
      );
      $$(ids.includeReset).setValue(
         view.settings.includeReset != null
            ? view.settings.includeReset
            : ABViewFormButtonPropertyComponentDefaults.includeReset
      );

      $$(ids.saveLabel).setValue(view.settings.saveLabel || "");
      $$(ids.cancelLabel).setValue(view.settings.cancelLabel || "");
      $$(ids.resetLabel).setValue(view.settings.resetLabel || "");

      $$(ids.afterCancel).setValue(
         view.settings.afterCancel ||
            ABViewFormButtonPropertyComponentDefaults.afterCancel
      );
      $$(ids.alignment).setValue(
         view.settings.alignment ||
            ABViewFormButtonPropertyComponentDefaults.alignment
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.includeSave = $$(ids.includeSave).getValue();
      view.settings.saveLabel = $$(ids.saveLabel).getValue();
      view.settings.includeCancel = $$(ids.includeCancel).getValue();
      view.settings.cancelLabel = $$(ids.cancelLabel).getValue();
      view.settings.includeReset = $$(ids.includeReset).getValue();
      view.settings.resetLabel = $$(ids.resetLabel).getValue();
      view.settings.afterCancel = $$(ids.afterCancel).getValue();
      view.settings.alignment = $$(ids.alignment).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = this.parentFormUniqueID(`ABViewFormButton_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var form = this.parentFormComponent();

      var _ui = {
         id: ids.component,
         cols: [],
      };

      var alignment =
         this.settings.alignment ||
         ABViewFormButtonPropertyComponentDefaults.alignment;

      // spacer
      if (alignment == "center" || alignment == "right") {
         _ui.cols.push({});
      }

      // cancel button
      if (this.settings.includeCancel) {
         _ui.cols.push(
            {
               view: "button",
               autowidth: true,
               value: this.settings.cancelLabel || L("Cancel"),
               click: function () {
                  _logic.onCancel(this);
               },
               on: {
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        "button cancel " + form.id
                     );
                  },
               },
            },
            {
               width: 10,
            }
         );
      }

      // reset button
      if (this.settings.includeReset) {
         _ui.cols.push(
            {
               view: "button",
               autowidth: true,
               value: this.settings.resetLabel || L("Reset"),
               click: function () {
                  _logic.onClear(this);
               },
               on: {
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        "button reset " + form.id
                     );
                  },
               },
            },
            {
               width: 10,
            }
         );
      }

      // save button
      if (this.settings.includeSave) {
         _ui.cols.push({
            view: "button",
            type: "form",
            css: "webix_primary",
            autowidth: true,
            value: this.settings.saveLabel || L("Save"),
            click: function () {
               _logic.callbacks.onSaveClick(this);
            },
            on: {
               onAfterRender: function () {
                  this.getInputNode().setAttribute(
                     "data-cy",
                     "button save " + form.id
                  );
               },
            },
         });
      }

      // spacer
      if (alignment == "center" || alignment == "left") {
         _ui.cols.push({});
      }

      // make sure each of our child views get .init() called
      var _init = (options) => {
         // register our callbacks:
         if (options) {
            for (var c in _logic.callbacks) {
               _logic.callbacks[c] = options[c] || _logic.callbacks[c];
            }
         }
      };

      var _logic = (this._logic = {
         callbacks: {
            onCancelClick: function () {
               return true;
            },
            onSaveClick: function (saveButton) {
               _logic.onSave(saveButton);
            },
         },

         onCancel: (cancelButton) => {
            // attempt to call onCancleClick callback...if no override is set we simply return false
            var shouldContinue = _logic.callbacks.onCancelClick();

            // if override was called we should have returned true so we can stop now
            if (!shouldContinue) {
               return false;
            }

            // get form component
            var form = this.parentFormComponent();

            // get ABDatacollection
            var dc = form.datacollection;

            // clear cursor of DC
            if (dc) {
               dc.setCursor(null);
            }

            if (cancelButton.getFormView()) cancelButton.getFormView().clear();

            if (this.settings.afterCancel)
               super.changePage(this.settings.afterCancel);
            // If the redirect page is not defined, then redirect to parent page
            else {
               var noPopupFilter = (p) =>
                  p.settings && p.settings.type != "popup";

               var pageCurr = this.pageParent();
               if (pageCurr) {
                  var pageParent =
                     pageCurr.pageParent(noPopupFilter) || pageCurr;

                  if (pageParent) super.changePage(pageParent.id);
               }
            }
         },

         onClear: (resetButton) => {
            // get form component
            var form = this.parentFormComponent();

            // get ABDatacollection
            var dc = form.datacollection;

            // clear cursor of DC
            if (dc) {
               dc.setCursor(null);
            }

            if (resetButton.getFormView()) resetButton.getFormView().clear();
         },

         onSave: (saveButton) => {
            // get form component
            var form = this.parentFormComponent();
            var formView = saveButton.getFormView();

            // disable the save button
            saveButton.disable();

            // save data
            form
               .saveData(formView)
               .then(() => {
                  if (saveButton && saveButton.$view) saveButton.enable();

                  //Focus on first focusable component
                  form.focusOnFirst();
               })
               .catch(() => {
                  if (saveButton && saveButton.$view) saveButton.enable();
               });
         },
      });

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   AddPagesToList(pagesList, parent, rootPageId) {
      if (!parent || !parent.pages || !pagesList) return;

      var pages = parent.pages() || [];

      pages.forEach((page) => {
         if (page.parent != null || page.id == rootPageId) {
            pagesList.push({
               id: page.id,
               value: page.label,
            });

            this.AddPagesToList(pagesList, page, page.id);
         }
      });
   }

   /**
    * @method parentFormUniqueID
    * return a unique ID based upon the closest form object this component is on.
    * @param {string} key  The basic id string we will try to make unique
    * @return {string}
    */
   parentFormUniqueID(key) {
      var form = this.parentFormComponent();
      var uniqueInstanceID;
      if (form) {
         uniqueInstanceID = form.uniqueInstanceID;
      } else {
         uniqueInstanceID = webix.uid();
      }

      return key + uniqueInstanceID;
   }
};


/***/ }),

/***/ 56339:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormCheckbox.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCheckboxCore = __webpack_require__(/*! ../../core/views/ABViewFormCheckboxCore */ 18489);

module.exports = class ABViewFormCheckbox extends ABViewFormCheckboxCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormCheckboxEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var checkboxElem = this.component(App).ui;
      checkboxElem.id = ids.component;

      var _ui = {
         rows: [checkboxElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);

      var idBase = this.parentFormUniqueID(`ABViewFormCheckbox_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      component.ui.id = ids.component;
      component.ui.view = "checkbox";

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      return component;
   }
};


/***/ }),

/***/ 93787:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormComponent.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormComponentCore = __webpack_require__(/*! ../../core/views/ABViewFormComponentCore */ 43960);

const ABViewFormFieldPropertyComponentDefaults = ABViewFormComponentCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormComponent extends ABViewFormComponentCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      return commonUI.concat([
         {
            name: "fieldLabel",
            view: "text",
            disabled: true,
            label: L("Field"),
         },
         {
            name: "required",
            view: "checkbox",
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
            labelRight: L("Required"),
         },
         {
            name: "disable",
            view: "checkbox",
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
            labelRight: L("Disable"),
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var field = view.field();

      $$(ids.fieldLabel).setValue(field ? field.label : "");

      if (field && field.settings.required == 1) {
         $$(ids.required).setValue(field.settings.required);
         $$(ids.required).disable();
      } else {
         $$(ids.required).setValue(
            view.settings.required != null
               ? view.settings.required
               : ABViewFormFieldPropertyComponentDefaults.required
         );
      }

      if (view && view.settings.disable == 1) {
         $$(ids.disable).setValue(view.settings.disable);
      } else {
         $$(ids.disable).setValue(
            ABViewFormFieldPropertyComponentDefaults.disable
         );
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // console.log("here");
      view.settings.required = $$(ids.required).getValue();
      view.settings.disable = $$(ids.disable).getValue();
      // console.log(view);
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      // setup 'label' of the element
      var form = this.parentFormComponent(),
         field = this.field(),
         label = "";

      var settings = {};
      if (form) settings = form.settings;

      var _ui = {
         labelPosition: settings.labelPosition,
         labelWidth: settings.labelWidth,
         label: label,
      };

      if (field != null) {
         _ui.name = field.columnName;

         // default value
         var data = {};
         field.defaultValue(data);
         if (data[field.columnName]) _ui.value = data[field.columnName];

         if (settings.showLabel == true) {
            _ui.label = field.label;
         }

         if (
            field.settings.required == true ||
            this.settings.required == true
         ) {
            _ui.required = 1;
         }

         if (this.settings.disable == 1) {
            _ui.disabled = true;
         }

         // add data-cy to form element for better testing code
         _ui.on = {
            onAfterRender() {
               if (this.getList) {
                  var popup = this.getPopup();
                  if (!popup) return;
                  this.getList().data.each((option) => {
                     if (!option) return;
                     var node = popup.$view.querySelector(
                        "[webix_l_id='" + option.id + "']"
                     );
                     if (!node) return;
                     node.setAttribute(
                        "data-cy",
                        `${field.key} options ${option.id} ${field.id} ${form.id}`
                     );
                  });
               }
               this.getInputNode().setAttribute(
                  "data-cy",
                  `${field.key} ${field.columnName} ${field.id} ${form.id}`
               );
            },
         };

         // this may be needed if we want to format data at this point
         // if (field.format) data = field.format(data);

         _ui.validate = (val, data, colName) => {
            let validator = this.AB.Validation.validator();

            field.isValidData(data, validator);

            return validator.pass();
         };
      }

      var _init = () => {};

      return {
         ui: _ui,
         init: _init,
      };
   }

   /**
    * @method parentFormUniqueID
    * return a unique ID based upon the closest form object this component is on.
    * @param {string} key  The basic id string we will try to make unique
    * @return {string}
    */
   parentFormUniqueID(key) {
      var form = this.parentFormComponent();
      var uniqueInstanceID;
      if (form) {
         uniqueInstanceID = form.uniqueInstanceID;
      } else {
         uniqueInstanceID = webix.uid();
      }

      return key + uniqueInstanceID;
   }
};


/***/ }),

/***/ 46311:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormConnect.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormConnectCore = __webpack_require__(/*! ../../core/views/ABViewFormConnectCore */ 24703);
const ABViewPropertyAddPage = (__webpack_require__(/*! ./viewProperties/ABViewPropertyAddPage */ 95751)["default"]);
const ABViewPropertyEditPage = (__webpack_require__(/*! ./viewProperties/ABViewPropertyEditPage */ 77025)["default"]);

const ABViewFormConnectPropertyComponentDefaults = ABViewFormConnectCore.defaultValues();

const ABPopupSort = __webpack_require__(/*! ../../../ABDesigner/ab_work_object_workspace_popupSortFields */ 43947);

let FilterComponent = null;
let SortComponent = null;

let L = (...params) => AB.Multilingual.label(...params);

function _onShow(App, compId, instance, component) {
   const elem = $$(compId);

   if (!elem) return;

   const field = instance.field();

   if (!field) return;

   const node = elem.$view;

   if (!node) return;

   const $node = $$(node);

   if (!$node) return;

   const filterConditions = instance.settings.objectWorkspace
      .filterConditions || { glue: "and", rules: [] };

   const getFilterByConnectValues = (conditions, depth = 0) => {
      return [
         ...conditions.rules
            .filter((e) => e.rule === "filterByConnectValue")
            .map((e) => {
               const filterByConnectValue = Object.assign({}, e);

               filterByConnectValue.depth = depth;

               return filterByConnectValue;
            }),
      ].concat(
         ...conditions.rules
            .filter((e) => e.glue)
            .map((e) => getFilterByConnectValues(e, depth + 1))
      );
   };

   const filterByConnectValues = getFilterByConnectValues(filterConditions).map(
      (e) => {
         for (const key in instance.parent.viewComponents) {
            const $ui = $$(instance.parent.viewComponents[key].ui.inputId);

            if ($ui?.config?.name === e.value) {
               // we need to use the element id stored in the settings to find out what the
               // ui component id is so later we can use it to look up its current value
               e.filterValue = $ui;

               break;
            }
         }

         const field = instance.AB.objectByID(
            instance.settings.objectId
         ).fieldByID(instance.settings.fieldId);
         const linkedObject = instance.AB.objectByID(field.settings.linkObject);
         const linkedField = linkedObject.fieldByID(e.key);

         if (linkedField.settings.isCustomFK) {
            // finally if this is a custom foreign key we need the stored columnName by
            // default uuid is passed for all non CFK
            e.filterColumn = instance.AB.objectByID(
               linkedField.settings.linkObject
            ).fields(
               (filter) =>
                  filter.id === linkedField.settings.indexField ||
                  linkedField.settings.indexField2
            )[0].columnName;
         } else e.filterColumn = null;

         return e;
      }
   );

   instance.options = {
      formView: instance.settings.formView,
      filters: filterConditions,
      sort: instance.settings.objectWorkspace.sortFields,
      editable: instance.settings.disable === 1 ? false : true,
      editPage:
         !instance.settings.editForm || instance.settings.editForm === "none"
            ? false
            : true,
      filterByConnectValues,
   };

   // if this field's options are filtered off another field's value we need
   // to make sure the UX helps the user know what to do.
   // fetch the options and set placeholder text for this view
   if (instance.options.editable) {
      const parentFields = [];

      for (let i = 0; i < filterByConnectValues?.length; i++) {
         if (
            filterByConnectValues[i].filterValue &&
            filterByConnectValues[i].key
         ) {
            const $filterValueConfig = $$(
               filterByConnectValues[i].filterValue.config.id
            );

            let parentField = null;

            if (!$filterValueConfig) {
               // this happens in the Interface Builder when only the single form UI is displayed
               parentField = {
                  id: "perentElement",
                  label: L("PARENT ELEMENT"),
               };
            } else {
               const value = field.getValue($filterValueConfig);

               if (!value) {
                  // if there isn't a value on the parent select element set this one to readonly and change placeholder text
                  parentField = {
                     id: filterByConnectValues[i].filterValue.config.id,
                     label: $filterValueConfig.config.label,
                  };
               }

               $filterValueConfig.attachEvent(
                  "onChange",
                  (e) => {
                     const parentVal = $filterValueConfig.getValue();

                     if (parentVal) {
                        $node.define("disabled", false);
                        $node.define("placeholder", L("Select items"));
                        field.getAndPopulateOptions(
                           $node,
                           instance.options,
                           field,
                           instance.parentFormComponent()
                        );
                     } else {
                        $node.define("disabled", true);
                        $node.define(
                           "placeholder",
                           L("Must select item from '{0}' first.", [
                              $filterValueConfig.config.label,
                           ])
                        );
                     }

                     $node.setValue("");
                     $node.refresh();
                  },
                  false
               );
            }

            if (
               parentField &&
               parentFields.findIndex((e) => e.id === parentField.id) < 0
            )
               parentFields.push(parentField);
         }
      }

      if (parentFields.length && !$node.getValue()) {
         $node.define("disabled", true);
         $node.define(
            "placeholder",
            L(
               `Must select item from ${parentFields
                  .map((e, i) => `'{${i}}'`)
                  .join(", ")} first.`,
               parentFields.map((e) => e.label)
            )
         );
      } else {
         $node.define("disabled", false);
         $node.define("placeholder", L("Select items"));
      }
   } else {
      $node.define("placeholder", "");
      $node.define("disabled", true);
   }

   $node.refresh();

   field.getAndPopulateOptions(
      $node,
      instance.options,
      field,
      instance.parentFormComponent()
   );
}

module.exports = class ABViewFormConnect extends ABViewFormConnectCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      // Set filter value
      this.__filterComponent = this.AB.filterComplexNew(
         `${this.id}__filterComponent`
      );
      // this.__filterComponent.applicationLoad(application);
      this.__filterComponent.fieldsLoad(
         this.datasource ? this.datasource.fields() : [],
         this.datasource ? this.datasource : null
      );

      if (
         !this.settings.objectWorkspace ||
         !this.settings.objectWorkspace.filterConditions
      ) {
         this.AB.error("Error: filter conditions do not exist", {
            error: "filterConditions do not exist",
            viewLocation: {
               application: this.application.name,
               id: this.id,
               name: this.label,
            },
            view: this,
         });
         // manually place an empty filter
         this.settings["objectWorkspace"] = {};
         this.settings["objectWorkspace"]["filterConditions"] = { glue: "and" };
      }

      this.__filterComponent.setValue(
         this.settings.objectWorkspace.filterConditions ??
            ABViewFormConnectPropertyComponentDefaults.filterConditions
      );
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewFormConnectEditorComponent";
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      let baseComp = this.component(App);
      let templateElem = baseComp.ui;
      templateElem.id = ids.component;

      var _ui = {
         rows: [templateElem, {}],
      };

      return {
         ui: _ui,
         init: baseComp.init,
         logic: baseComp.logic,
         onShow: () => {
            _onShow(App, ids.component, this, baseComp);
         },
      };
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.addPageTool.fromSettings(this.settings);
      this.editPageTool.fromSettings(this.settings);
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      let idBase = "ABViewFormConnectPropertyEditor";
      this.App = App;
      this.idBase = idBase;

      _logic.showFilterPopup = ($view) => {
         this.filter_popup.show($view, null, { pos: "top" });
      };

      _logic.showSortPopup = ($button) => {
         SortComponent.show($button, null, {
            pos: "top",
         });
      };

      _logic.onFilterChange = () => {
         let view = _logic.currentEditObject();
         let filterValues = FilterComponent.getValue() || {};

         let allComplete = true;
         (filterValues.rules || []).forEach((f) => {
            // if all 3 fields are present, we are good.
            if (f.key && f.rule && f.value) {
               allComplete = allComplete && true;
            } else {
               // else, we found an entry that wasn't complete:
               allComplete = false;
            }
         });

         // only perform the update if a complete row is specified:
         if (allComplete) {
            // we want to call .save() but give webix a chance to properly update it's
            // select boxes before this call causes them to be removed:
            setTimeout(() => {
               this.propertyEditorSave(ids, view);
            }, 10);
         }
      };

      _logic.onSortChange = () => {
         let view = _logic.currentEditObject();
         this.propertyEditorSave(ids, view);
      };

      // create filter & sort popups
      this.initPopupEditors(App, ids, _logic);

      let onSave = () => {
         let currView = _logic.currentEditObject();
         if (currView) {
            // refresh settings
            this.propertyEditorValues(ids, currView);

            // trigger a save()
            this.propertyEditorSave(ids, currView);
         }
      };

      this.addPageProperty.init({
         onSave: () => {
            onSave();
         },
      });

      this.editPageProperty.init({
         onSave: () => {
            onSave();
         },
      });

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         this.addPageProperty.ui,
         this.editPageProperty.ui,
         {
            view: "fieldset",
            name: "addNewSettings",
            label: L("Add New Popup Settings:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "text",
                     name: "popupWidth",
                     placeholder: L("Set popup width"),
                     label: L("Width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     validate: webix.rules.isNumber,
                  },
                  {
                     view: "text",
                     name: "popupHeight",
                     placeholder: L("Set popup height"),
                     label: L("Height:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     validate: webix.rules.isNumber,
                  },
               ],
            },
         },
         {
            view: "fieldset",
            name: "advancedOption",
            label: L("Advanced Options:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: L("Filter Options:"),
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           view: "button",
                           name: "buttonFilter",
                           css: "webix_primary",
                           label: L("Settings"),
                           icon: "fa fa-gear",
                           type: "icon",
                           badge: 0,
                           click: function () {
                              _logic.showFilterPopup(this.$view);
                           },
                        },
                     ],
                  },
                  {
                     rows: [
                        {
                           view: "label",
                           label: L("Filter by Connected Field Value:"),
                        },
                        {
                           view: "combo",
                           name: "filterConnectedValue",
                           options: [], // we will add these in propertyEditorPopulate
                        },
                     ],
                  },
                  {
                     height: 30,
                  },
                  {
                     rows: [
                        {
                           cols: [
                              {
                                 view: "label",
                                 label: L("Sort Options:"),
                                 width: App.config.labelWidthLarge,
                              },
                              {
                                 view: "button",
                                 name: "buttonSort",
                                 css: "webix_primary",
                                 label: L("Settings"),
                                 icon: "fa fa-gear",
                                 type: "icon",
                                 badge: 0,
                                 click: function () {
                                    _logic.showSortPopup(this.$view);
                                 },
                              },
                           ],
                        },
                     ],
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // Default set of options for filter connected combo
      let filterConnectedOptions = [{ id: "", value: "" }];

      // get the definitions for the connected field
      let fieldDefs = view.AB.definitionForID(view.settings.fieldId);

      // get the definition for the object that the field is related to
      let objectDefs = view.AB.definitionForID(fieldDefs.settings.linkObject);

      // we need these definitions later as we check to find out which field
      // we are filtering by so push them into an array for later
      let fieldsDefs = [];
      objectDefs.fieldIDs.forEach((fld) => {
         fieldsDefs.push(view.AB.definitionForID(fld));
      });

      // find out what connected objects this field has
      let connectedObjs = view.application.connectedObjects(
         fieldDefs.settings.linkObject
      );

      // loop through the form's elements (need to ensure that just looking at parent is okay in all cases)
      view.parent.views().forEach((element) => {
         // identify if element is a connected field
         if (element.key == "connect") {
            // we need to get the fields defs to find out what it is connected to
            let formElementsDefs = view.AB.definitionForID(
               element.settings.fieldId
            );

            // loop through the connected objects discovered above
            connectedObjs.forEach((connObj) => {
               // see if the connected object matches the connected object of the form element
               if (connObj.id == formElementsDefs.settings.linkObject) {
                  // get the ui id of this component that matches the link Object
                  let fieldToCheck;
                  fieldsDefs.forEach((fdefs) => {
                     // if the field has a custom foreign key we need to store it
                     // so selectivity later can know what value to get, otherwise
                     // we just get the uuid of the record
                     if (
                        fdefs.settings.isCustomFK &&
                        fdefs.settings.indexField != "" &&
                        fdefs.settings.linkObject &&
                        fdefs.settings.linkType == "one" &&
                        fdefs.settings.linkObject ==
                           formElementsDefs.settings.linkObject
                     ) {
                        fieldToCheck = fdefs.id;
                        let customFK = view.application.definitionForID(
                           fdefs.settings.indexField
                        );

                        // if the index definitions were found
                        if (customFK) {
                           fieldToCheck = `${fdefs.id}:${customFK.columnName}`;
                        }
                     } else if (
                        fdefs.settings.linkObject &&
                        fdefs.settings.linkType == "one" &&
                        fdefs.settings.linkObject ==
                           formElementsDefs.settings.linkObject
                     ) {
                        fieldToCheck = `${fdefs.id}:uuid`;
                     }
                  });

                  // only add optinos that have a fieldToCheck
                  if (fieldToCheck) {
                     // get the component we are referencing so we can display its label
                     let formComponent = view.parent.viewComponents[element.id]; // need to ensure that just looking at parent is okay in all cases
                     filterConnectedOptions.push({
                        id: `${formComponent.ui.name}:${fieldToCheck}`, // store the columnName name because the ui id changes on each load
                        value: formComponent.ui.label, // should be the translated field label
                     });
                  }
               }
            });
         }
      });

      // Set the options of the possible edit forms
      this.addPageProperty.setSettings(view, view.settingsAddPage);
      this.editPageProperty.setSettings(view, view.settingsEditPage);
      $$(ids.filterConnectedValue).define("options", filterConnectedOptions);
      $$(ids.filterConnectedValue).setValue(view.settings.filterConnectedValue);

      $$(ids.popupWidth).setValue(
         view.settings.popupWidth ||
            ABViewFormConnectPropertyComponentDefaults.popupWidth
      );
      $$(ids.popupHeight).setValue(
         view.settings.popupHeight ||
            ABViewFormConnectPropertyComponentDefaults.popupHeight
      );

      // initial populate of popups
      this.populatePopupEditors(view);

      // inform the user that some advanced settings have been set
      this.populateBadgeNumber(ids, view);

      // when a change is made in the properties the popups need to reflect the change
      this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
      if (!this.updateEventIds[view.id]) {
         this.updateEventIds[view.id] = true;

         view.addListener("properties.updated", () => {
            this.populatePopupEditors(view);
            this.populateBadgeNumber(ids, view);
         });
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.popupWidth = $$(ids.popupWidth).getValue();
      view.settings.popupHeight = $$(ids.popupHeight).getValue();
      view.settings.filterConnectedValue = $$(
         ids.filterConnectedValue
      ).getValue();
      view.settings.objectWorkspace = {
         filterConditions: FilterComponent.getValue(),
         sortFields: SortComponent.getValue(),
      };

      view.settingsAddPage = this.addPageProperty.getSettings(view);
      view.settingsEditPage = this.editPageProperty.getSettings(view);

      // refresh settings of app page tool
      view.addPageTool.fromSettings(view.settingsAddPage);
      view.editPageTool.fromSettings(view.settingsEditPage);
   }

   static populateBadgeNumber(ids, view) {
      if (
         view.settings.objectWorkspace &&
         view.settings.objectWorkspace.filterConditions &&
         view.settings.objectWorkspace.filterConditions.rules
      ) {
         $$(ids.buttonFilter).define(
            "badge",
            view.settings.objectWorkspace.filterConditions.rules.length || null
         );
         $$(ids.buttonFilter).refresh();
      } else {
         $$(ids.buttonFilter).define("badge", null);
         $$(ids.buttonFilter).refresh();
      }

      if (
         view.settings.objectWorkspace &&
         view.settings.objectWorkspace.sortFields &&
         view.settings.objectWorkspace.sortFields.length
      ) {
         $$(ids.buttonSort).define(
            "badge",
            view.settings.objectWorkspace.sortFields.length || null
         );
         $$(ids.buttonSort).refresh();
      } else {
         $$(ids.buttonSort).define("badge", null);
         $$(ids.buttonSort).refresh();
      }
   }

   static initPopupEditors(App, ids, _logic) {
      var idBase = "ABViewFormConnectPropertyEditor";

      FilterComponent = this.AB.filterComplexNew(`${idBase}_filter`);
      FilterComponent.init();
      // when we make a change in the popups we want to make sure we save the new workspace to the properties to do so just fire an onChange event
      FilterComponent.on("change", (val) => {
         _logic.onFilterChange(val);
      });

      SortComponent = new ABPopupSort(this.App, `${idBase}_sort`);
      SortComponent.init({
         onChange: _logic.onSortChange,
      });

      this.filter_popup = webix.ui({
         view: "popup",
         width: 800,
         hidden: true,
         body: FilterComponent.ui,
      });
   }

   static populatePopupEditors(view) {
      let filterConditions =
         ABViewFormConnectPropertyComponentDefaults.objectWorkspace
            .filterConditions;

      if (
         view.settings.objectWorkspace &&
         view.settings.objectWorkspace.filterConditions
      )
         filterConditions = view.settings.objectWorkspace.filterConditions;

      // Populate data to popups
      // FilterComponent.objectLoad(objectCopy);
      let linkedObj;
      let field = view.field();
      if (field) {
         linkedObj = field.datasourceLink;
         if (linkedObj)
            FilterComponent.fieldsLoad(linkedObj.fields(), linkedObj);
      }

      FilterComponent.setValue(filterConditions);

      if (linkedObj) SortComponent.objectLoad(linkedObj);
      SortComponent.setValue(view.settings.objectWorkspace.sortFields);
   }

   static get addPageProperty() {
      return ABViewPropertyAddPage.propertyComponent(this.App, this.idBase);
   }

   static get editPageProperty() {
      return ABViewPropertyEditPage.propertyComponent(this.App, this.idBase);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      var field = this.field();
      // this field may be deleted
      if (!field) return super.component(App);

      idPrefix = idPrefix ? idPrefix + "_" : "";

      var component = super.component(App);
      var form = this.parentFormComponent();
      var idBase = this.parentFormUniqueID(
         "ABViewFormConnect_" + this.id + "_f_"
      );
      var ids = {
         component: App.unique(`${idPrefix}${idBase}_component`),
         popup: App.unique(`${idPrefix}${idBase}_popup_add_new`),
         editpopup: App.unique(
            `${idPrefix}${idBase}_popup_edit_form_popup_add_new`
         ),
      };

      var settings = {};
      if (form) settings = form.settings;

      let addPageComponent = this.addPageTool.component(App, idBase);
      let editPageComponent;

      component.init = (optionsParam) => {
         var settings = {};
         var options = optionsParam || {};
         if (form) settings = form.settings;

         addPageComponent.applicationLoad(this.application);
         addPageComponent.init({
            onSaveData: component.logic.callbackSaveData,
            onCancelClick: component.logic.callbackCancel,
            clearOnLoad: component.logic.callbackClearOnLoad,
         });

         editPageComponent = this.editPageTool.component(App, idBase);
         editPageComponent.applicationLoad(this.application);
         editPageComponent.init({
            onSaveData: component.logic.callbackSaveData,
            onCancelClick: component.logic.callbackCancel,
            clearOnLoad: component.logic.callbackClearOnLoad,
         });
      };

      component.logic = {
         /**
          * @function callbackSaveData
          *
          */
         callbackSaveData: (saveData) => {
            // find the selectivity component
            var elem = $$(ids.component);
            if (!elem) return;

            field.once("option.data", (data) => {
               data.forEach((item) => {
                  item.value = item.text;
               });
               $$(ids.component).getList().clearAll();
               $$(ids.component).getList().define("data", data);
               if (field.settings.linkType == "many") {
                  let currentVals = $$(ids.component).getValue();
                  if (currentVals.indexOf(saveData.id) == -1) {
                     $$(ids.component).setValue(
                        currentVals
                           ? currentVals + "," + saveData.id
                           : saveData.id
                     );
                  }
               } else {
                  $$(ids.component).setValue(saveData.id);
               }
               // close the popup when we are finished
               $$(ids.popup)?.close();
               $$(ids.editpopup)?.close();
            });

            field
               .getOptions(this.settings.objectWorkspace.filterConditions, "")
               .then(function (data) {
                  // we need new option that will be returned from server (above)
                  // so we will not set this and then just reset it.
               });
         },

         callbackCancel: () => {
            $$(ids.popup).close();
            return false;
         },

         callbackClearOnLoad: () => {
            return true;
         },

         getValue: (rowData) => {
            var elem = $$(ids.component);

            return field.getValue(elem, rowData);
         },

         formBusy: ($form) => {
            if (!$form) return;

            if ($form.disable) $form.disable();

            if ($form.showProgress) $form.showProgress({ type: "icon" });
         },

         formReady: ($form) => {
            if (!$form) return;

            if ($form.enable) $form.enable();

            if ($form.hideProgress) $form.hideProgress();
         },

         goToEditPage: (rowId) => {
            if (!this.settings.editForm) return;

            let editForm = this.application.urlResolve(this.settings.editForm);
            if (!editForm) return;

            let $form;
            let $elem = $$(ids.component);
            if ($elem) {
               $form = $elem.getFormView();
            }

            // Open the form popup
            editPageComponent.onClick().then(() => {
               let dc = editForm.datacollection;
               if (dc) {
                  dc.setCursor(rowId);

                  if (!this.__editFormDcEvent) {
                     this.__editFormDcEvent = dc.on("initializedData", () => {
                        dc.setCursor(rowId);
                     });
                  }
               }
            });
         },
      };

      var multiselect = field.settings.linkType == "many";

      component.ui.label = field.label;
      component.ui.labelWidth = settings.labelWidth;
      component.ui.id = ids.component;
      component.ui.view = multiselect ? "multicombo" : "combo";
      component.ui.on = {
         onItemClick: (id, e) => {
            if (
               e.target.classList.contains("editConnectedPage") &&
               e.target.dataset.itemId
            ) {
               let rowId = e.target.dataset.itemId;
               if (!rowId) return;
               component.logic.goToEditPage(rowId);
            }
         },
         onChange: (data) => {
            let selectedValues;
            if (Array.isArray(data)) {
               selectedValues = [];
               data.forEach((record) => {
                  let recordObj = record;
                  if (typeof record != "object") {
                     // we need to convert either index or uuid to full data object
                     recordObj = field.getItemFromVal(record);
                  }
                  if (recordObj && recordObj.id)
                     selectedValues.push(recordObj.id);
               });
            } else {
               selectedValues = data;
               if (typeof data != "object") {
                  // we need to convert either index or uuid to full data object
                  selectedValues = field.getItemFromVal(data);
               }
               // selectedValues = field.pullRecordRelationValues(selectedValues);
               if (selectedValues && selectedValues.id) {
                  selectedValues = selectedValues.id;
               } else {
                  selectedValues = data;
               }
            }
            // We can now set the new value but we need to block event listening
            // so it doesn't trigger onChange again
            const $$component = $$(ids.component);
            if ($$component) {
               $$component.blockEvent();
               let prepedVals = selectedValues.join
                  ? selectedValues.join()
                  : selectedValues;
               $$component.setValue(prepedVals);
               $$component.unblockEvent();
            }
         },
      };

      component.ui.dataFieldId = field.id;

      let editForm = "";
      if (settings.editForm && settings.editForm != "") {
         editForm =
            '<i data-item-id="#id#" class="fa fa-cog editConnectedPage"></i>';
      }
      component.ui.suggest = {
         button: true,
         selectAll: multiselect ? true : false,
         body: {
            template: editForm + "#value#",
         },
         on: {
            onShow: () => {
               field.populateOptionsDataCy($$(ids.component), field, form);
            },
         },
         // Support partial matches
         filter: ({ value }, search) =>
            value.toLowerCase().includes(search.toLowerCase()),
      };

      component.ui.onClick = {
         customField: (id, e, trg) => {
            if (this.settings.disable == 1) return;

            var rowData = {};

            if ($$(ids.component)) {
               var node = $$(ids.component).$view;
               field.customEdit(rowData, App, node);
            }
         },
      };

      if (addPageComponent.ui) {
         // reset some component vals to make room for button
         component.ui.label = "";
         component.ui.labelWidth = 0;

         // add click event to add new button
         addPageComponent.ui.on = {
            onItemClick: (id, evt) => {
               let $form = $$(id).getFormView();

               let dc = form.datacollection;

               addPageComponent.onClick(dc);

               return false;
            },
         };

         component.ui = {
            inputId: component.ui.id,
            rows: [
               {
                  cols: [
                     {
                        view: "label",
                        label: field.label,
                        width: settings.labelWidth,
                        align: "left",
                     },
                     addPageComponent.ui,
                     component.ui,
                  ],
               },
            ],
         };
      } else {
         component.ui = {
            inputId: component.ui.id,
            rows: [component.ui],
         };
      }

      component.onShow = () => {
         _onShow(App, ids.component, this, component);
         let elem = $$(ids.component);
         if (!elem) return;

         let node = elem.$view;

         // Add data-cy attributes
         const dataCy = `${field.key} ${field.columnName} ${field.id} ${this.parent.id}`;
         node.setAttribute("data-cy", dataCy);
      };

      return component;
   }

   get addPageTool() {
      if (this.__addPageTool == null)
         this.__addPageTool = new ABViewPropertyAddPage();

      return this.__addPageTool;
   }

   get editPageTool() {
      if (this.__editPageTool == null)
         this.__editPageTool = new ABViewPropertyEditPage();

      return this.__editPageTool;
   }
};


/***/ }),

/***/ 79662:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormCustom.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustomCore = __webpack_require__(/*! ../../core/views/ABViewFormCustomCore */ 21984);

const ABFieldImage = __webpack_require__(/*! ../dataFields/ABFieldImage */ 70780);
const DEFAULT_HEIGHT = 80;

module.exports = class ABViewFormCustom extends ABViewFormCustomCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormCustomEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var templateElem = this.component(App).ui;
      templateElem.id = ids.component;

      var _ui = {
         rows: [templateElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();
      var form = this.parentFormComponent();

      // this field may be deleted
      if (!field) return component;

      var idBase = this.parentFormUniqueID(`ABViewFormCustom_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var settings = {};
      if (form) settings = form.settings;

      var requiredClass = "";
      if (field.settings.required || this.settings.required) {
         requiredClass = "webix_required";
      }

      var templateLabel = "";
      if (settings.showLabel) {
         if (settings.labelPosition == "top")
            templateLabel =
               '<label style="display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="webix_inp_top_label ' +
               requiredClass +
               '">#label#</label>';
         else
            templateLabel =
               '<label style="width: #width#px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="' +
               requiredClass +
               '">#label#</label>';
      }

      var newWidth = settings.labelWidth;
      if (this.settings.formView) newWidth += 40;
      else if (settings.showLabel == true && settings.labelPosition == "top")
         newWidth = 0;

      let height = 38;
      if (field instanceof ABFieldImage) {
         if (field.settings.useHeight) {
            if (settings.labelPosition == "top") {
               height = parseInt(field.settings.imageHeight) || DEFAULT_HEIGHT;
               height += 38;
            } else {
               height = parseInt(field.settings.imageHeight) || DEFAULT_HEIGHT;
            }
         } else if (settings.labelPosition == "top") {
            height = DEFAULT_HEIGHT + 38;
         } else {
            if (DEFAULT_HEIGHT > 38) {
               height = DEFAULT_HEIGHT;
            }
         }
      } else if (
         settings.showLabel == true &&
         settings.labelPosition == "top"
      ) {
         height = DEFAULT_HEIGHT;
      }

      let template = `<div class="customField ${settings.labelPosition}">${templateLabel}#template#</div>`
         .replace(/#width#/g, settings.labelWidth)
         .replace(/#label#/g, field.label)
         .replace(
            /#template#/g,
            field
               .columnHeader({
                  width: newWidth,
                  height: height,
                  editable: true,
               })
               .template({})
         );

      component.ui = {
         id: ids.component,
         view: "forminput",
         labelWidth: 0,
         paddingY: 0,
         paddingX: 0,
         css: "ab-custom-field",
         name: component.ui.name,
         // label:  field.label,
         // labelPosition: settings.labelPosition, // webix.forminput does not have .labelPosition T T
         // labelWidth: settings.labelWidth,
         body: {
            // id: ids.component,
            view: App.custom.focusabletemplate.view,
            css: "customFieldCls",
            borderless: true,
            template: template,
            height: height,
            onClick: {
               customField: (evt, e, trg) => {
                  if (this.settings.disable == 1) return;

                  let rowData = {};

                  let formView = this.parentFormComponent();
                  if (formView) {
                     let dv = formView.datacollection;
                     if (dv) rowData = dv.getCursor() || {};
                  }

                  // var node = $$(ids.component).$view;
                  let node = $$(trg).getParentView().$view;
                  field.customEdit(rowData, App, node, ids.component, evt);
               },
            },
         },
      };

      component.onShow = () => {
         let elem = $$(ids.component);
         if (!elem) return;

         let rowData = {},
            node = elem.$view;

         // Add data-cy attributes
         const dataCy = `${this.key} ${field.key} ${field.columnName} ${this.id} ${this.parent.id}`;
         node.setAttribute('data-cy', dataCy);

         let options = {
            formId: ids.component,
            editable: this.settings.disable == 1 ? false : true,
         };

         if (field instanceof ABFieldImage) {
            options.height = field.settings.useHeight
               ? parseInt(field.settings.imageHeight) || DEFAULT_HEIGHT
               : DEFAULT_HEIGHT;
            options.width = field.settings.useWidth
               ? parseInt(field.settings.imageWidth) || newWidth
               : newWidth;
         }

         field.customDisplay(rowData, App, node, options);
      };

      // make sure each of our child views get .init() called
      component.init = (options) => {
         // component.onShow();
      };

      component.logic = {
         getValue: (rowData) => {
            let elem = $$(ids.component);

            return field.getValue(elem, rowData);
         },
      };

      return component;
   }
};


/***/ }),

/***/ 16816:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormDatepicker.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormDatepickerCore = __webpack_require__(/*! ../../core/views/ABViewFormDatepickerCore */ 86237);

module.exports = class ABViewFormDatepicker extends ABViewFormDatepickerCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormDatepickerEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var datepickerElem = this.component(App).ui;
      datepickerElem.id = ids.component;

      var _ui = {
         rows: [datepickerElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();

      var idBase = this.parentFormUniqueID(
         `ABViewFormDatepicker_${this.id}_f_`
      );
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      component.ui.id = ids.component;
      component.ui.view = "datepicker";
      if (!field) return component;

      // Ignore date - Only time picker
      if (field.settings.dateFormat == 1) {
         component.ui.type = "time";
      }

      // Date & Time picker
      if (
         field.key == "datetime" &&
         field.settings &&
         field.settings.timeFormat &&
         field.settings.timeFormat != 1
      ) {
         component.ui.timepicker = true;
      }

      // allows entering characters in datepicker input, false by default
      component.ui.editable = true;

      // default value
      if (component.ui.value && !(component.ui.value instanceof Date)) {
         component.ui.value = new Date(component.ui.value);
      }

      // if we have webix locale set, will use the date format form there.
      if (field != null && !window.webixLocale) {
         component.ui.format = field.getFormat();
      }

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      return component;
   }
};


/***/ }),

/***/ 87856:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormNumber.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormNumberCore = __webpack_require__(/*! ../../core/views/ABViewFormNumberCore */ 84909);

const ABViewFormNumberPropertyComponentDefaults = ABViewFormNumberCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormNumber extends ABViewFormNumberCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormNumberEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var numberElem = this.component(App).ui;
      numberElem.id = ids.component;

      var _ui = {
         type: "space",
         rows: [numberElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "isStepper",
            view: "checkbox",
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
            labelRight: L("Plus/Minus Buttons"),
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.isStepper).setValue(
         view.settings.isStepper != null
            ? view.settings.isStepper
            : ABViewFormNumberPropertyComponentDefaults.isStepper
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.isStepper = $$(ids.isStepper).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();

      var idBase = this.parentFormUniqueID(`ABViewFormNumber_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var viewType = this.settings.isStepper
         ? "counter"
         : App.custom.numbertext.view;

      component.ui.id = ids.component;
      component.ui.view = viewType;
      component.ui.type = "number";
      component.ui.validate = (val) => {
         return !isNaN(val * 1);
      };

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      return component;
   }
};


/***/ }),

/***/ 62941:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormReadonly.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormReadonlyCore = __webpack_require__(/*! ../../core/views/ABViewFormReadonlyCore */ 83569);

module.exports = class ABViewFormReadonly extends ABViewFormReadonlyCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   ///
   /// Instance Methods
   ///

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormReadonlyEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var templateElem = this.component(App).ui;
      templateElem.id = ids.component;

      var _ui = {
         rows: [templateElem, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();
      var form = this.parentFormComponent();

      // this field may be deleted
      if (!field) return component;

      var idBase = this.parentFormUniqueID("ABViewFormReadonly_" + this.id);
      var ids = {
         component: App.unique(`${idBase}_component`),
         template: App.unique(`${idBase}template`),
      };

      component.ui = {
         id: ids.component,
         view: "forminput",
         labelWidth: 0,
         paddingY: 0,
         paddingX: 0,
         readonly: true,
         css: "ab-readonly-field",
         // name: component.ui.name,
         // label:  field.label,
         // labelPosition: settings.labelPosition, // webix.forminput does not have .labelPosition T T
         // labelWidth: settings.labelWidth,
         body: {
            id: ids.template,
            view: "label",
            borderless: true,
            css: { "background-color": "#fff" },
            label: "",
         },
      };

      let settings = {};
      if (form) settings = form.settings;

      if (settings.showLabel == true && settings.labelPosition == "top") {
         component.ui.body.height = 80;
      } else if (field.settings.useHeight) {
         component.ui.body.height = parseInt(field.settings.imageHeight) || 38;
      } else {
         component.ui.body.height = 38;
      }

      // make sure each of our child views get .init() called
      component.init = (options) => {
         let $elem = $$(ids.component);
         if (!$elem) return;

         let $form = $elem.getFormView();
         if (!$form) return;

         let rowData = $form.getValues();
         component.logic.refresh(rowData);

         $form.attachEvent("onChange", function (newv, oldv) {
            let rowData = $form.getValues();
            component.logic.refresh(rowData);
         });
      };

      component.onShow = () => {
         var $elem = $$(ids.component);
         if (!$elem) return;

         let $form = $elem.getFormView();
         if (!$form) return;

         let rowData = $form.getValues();
         component.logic.refresh(rowData);
      };

      component.logic = {
         getValue: (rowData) => {
            let field = this.field();
            if (!field) return null;
            return rowData[field.columnName];
         },

         refresh: (rowData) => {
            let field = this.field(),
               form = this.parentFormComponent();

            let settings = {};
            if (form) settings = form.settings;

            let templateLabel = "";
            if (settings.showLabel == true) {
               if (settings.labelPosition == "top")
                  templateLabel = `<label style="display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="webix_inp_top_label">${field.label}</label>`;
               else
                  templateLabel = `<label style="width: ${settings.labelWidth}px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;">${field.label}</label>`;
            }

            let newWidth = settings.labelWidth;
            if (this.settings.formView) newWidth += 40;
            else if (
               settings.showLabel == true &&
               settings.labelPosition == "top"
            )
               newWidth = 0;

            let template = `<div class="readonlyField">${templateLabel}#template#</div>`.replace(
               /#template#/g,
               field
                  .columnHeader({
                     width: newWidth,
                     editable: true,
                  })
                  .template(rowData)
            );

            // Re-build template element
            if ($$(ids.template)) {
               $$(ids.template).setHTML(template);
            }
         },
      };

      return component;
   }
};


/***/ }),

/***/ 38386:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormSelectMultiple.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormSelectMultipleCore = __webpack_require__(/*! ../../core/views/ABViewFormSelectMultipleCore */ 71172);

const ABViewFormSelectMultiplePropertyComponentDefaults = ABViewFormSelectMultipleCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormSelectMultiple extends (
   ABViewFormSelectMultipleCore
) {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormSelectMultipleEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         options: App.unique(`${idBase}_option`),
      };

      var selectlist = this.component(App).ui;
      selectlist.id = ids.component;

      var _ui = {
         rows: [selectlist, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "type",
            view: "richselect",
            label: L("Type"),
            options: [
               {
                  id: "multicombo",
                  value: L("Multi Combo"),
               },

               {
                  id: "checkbox",
                  value: L("Checkboxes"),
               },
            ],
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.type).setValue(
         view.settings.type ||
            ABViewFormSelectMultiplePropertyComponentDefaults.type
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.type = $$(ids.type).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();

      var idBase = this.parentFormUniqueID(
         `ABViewFormSelectMultiple_${this.id}_f_`
      );
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      component.ui.view =
         this.settings.type ||
         ABViewFormSelectMultiplePropertyComponentDefaults.type;

      var options = [];

      if (field && field.key == "user") options = field.getUsers();
      else if (field)
         options = field.settings.options || this.settings.options || [];

      component.ui.id = ids.component;
      component.ui.options = options.map((opt) => {
         return {
            id: opt.id,
            value: opt.text,
            hex: opt.hex,
         };
      });

      if (component.ui.view == "multicombo") {
         component.ui.tagMode = false;
         component.ui.css = "hideWebixMulticomboTag";
         component.ui.tagTemplate = function (values) {
            let selectedOptions = [];
            values.forEach((val) => {
               selectedOptions.push($$(ids.component).getList().getItem(val));
            });
            let vals = selectedOptions;
            if (field.getSelectedOptions) {
               vals = field.getSelectedOptions(field, selectedOptions);
            }

            var items = [];
            vals.forEach((val) => {
               var hasCustomColor = "";
               var optionHex = "";
               if (field.settings.hasColors && val.hex) {
                  hasCustomColor = "hascustomcolor";
                  optionHex = `background: ${val.hex};`;
               }
               let text = val.text ? val.text : val.value;
               items.push(
                  `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${val.id}"><span>${text}</span><span class="webix_multicombo_delete" role="button" aria-label="Remove item"></span></span>`
               );
            });
            return items.join("");
         };
      }

      // radio element could not be empty options
      if (component.ui.view == "checkbox") {
         component.ui.options.push({
            id: "temp",
            value: L("Option"),
         });
      }

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      component.logic = {
         getValue: (rowData) => {
            var elem = $$(ids.component);

            return field.getValue(elem, rowData);
         },
      };

      return component;
   }
};


/***/ }),

/***/ 26114:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormSelectSingle.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormSelectSingleCore = __webpack_require__(/*! ../../core/views/ABViewFormSelectSingleCore */ 54098);

const ABViewFormSelectSinglePropertyComponentDefaults = ABViewFormSelectSingleCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormSelectSingle extends (
   ABViewFormSelectSingleCore
) {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormSelectSingleEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         options: App.unique(`${idBase}_option`),
      };

      var selectlist = this.component(App).ui;
      selectlist.id = ids.component;

      var _ui = {
         rows: [selectlist, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "type",
            view: "richselect",
            label: L("Type"),
            options: [
               {
                  id: "richselect",
                  value: L("Select list"),
               },
               {
                  id: "radio",
                  value: L("Radio"),
               },
            ],
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.type).setValue(
         view.settings.type ||
            ABViewFormSelectSinglePropertyComponentDefaults.type
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.type = $$(ids.type).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();

      var idBase = this.parentFormUniqueID(
         `ABViewFormSelectSingle_${this.id}_f_`
      );
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      component.ui.view =
         this.settings.type ||
         ABViewFormSelectSinglePropertyComponentDefaults.type;

      var options = [];

      if (field && field.key == "user") options = field.getUsers();
      else if (field)
         options = field.settings.options || this.settings.options || [];
      else options = this.settings.options || [];

      component.ui.id = ids.component;

    if (field?.settings.hasColors) {
         component.ui.css = "combowithcolors";
         component.ui.options = {
            view: "suggest",
            body: {
               view: "list",
               data: options.map((opt) => {
                  return {
                     id: opt.id,
                     value: opt.text || opt.value,
                     hex: field.settings.hasColors ? opt.hex : "",
                  };
               }),
               template: function (value) {
                  var items = [];
                  var hasCustomColor = "";
                  var optionHex = "";
                  if (value.hex) {
                     hasCustomColor = "hascustomcolor";
                     optionHex = `background: ${value.hex};`;
                  }
                  items.push(
                     `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${value.id}"><span>${value.value}</span></span>`
                  );
                  return items.join("");
               },
            },
         };
      } else {
         component.ui.options = options.map((opt) => {
            return {
               id: opt.id,
               value: opt.text || opt.value,
            };
         });
      }

      // radio element could not be empty options
      if (component.ui.view == "radio" && component.ui.options.length < 1) {
         component.ui.options.push({
            id: "temp",
            value: L("Option"),
         });
      }

      // component.ui = {
      //    rows: [component.ui],
      // };

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      return component;
   }
};


/***/ }),

/***/ 48167:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormTextbox.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormTextboxCore = __webpack_require__(/*! ../../core/views/ABViewFormTextboxCore */ 87209);

const ABViewFormTextboxPropertyComponentDefaults = ABViewFormTextboxCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewFormTextbox extends ABViewFormTextboxCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormTextboxEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };
      var textView = this.component(App);

      var textUi = textView.ui;
      textUi.id = ids.component;

      var _ui = {
         rows: [textUi, {}],
      };

      var _init = (options) => {
         textView.init(options);
      };

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "type",
            view: "radio",
            label: L("Type"),
            vertical: true,
            options: [
               {
                  id: "single",
                  value: L("Single line"),
               },
               {
                  id: "multiple",
                  value: L("Multiple lines"),
               },
               {
                  id: "rich",
                  value: L("Rich editor"),
               },
            ],
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.type).setValue(
         view.settings.type || ABViewFormTextboxPropertyComponentDefaults.type
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.type = $$(ids.type).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);

      var idBase = this.parentFormUniqueID(`ABViewFormTextbox_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      component.ui.id = ids.component;

      switch (
         this.settings.type ||
         ABViewFormTextboxPropertyComponentDefaults.type
      ) {
         case "single":
            component.ui.view = "text";
            break;
         case "multiple":
            component.ui.view = "textarea";
            component.ui.height = 200;
            break;
         case "rich":
            component.ui.view = "forminput";
            component.ui.height = 200;
            component.ui.css = "ab-rich-text";
            component.ui.body = {
               view: "tinymce-editor",
               value: "",
               cdn: "/js/webix/extras/tinymce",
               config: {
                  plugins: "link",
                  menubar: "format edit",
                  toolbar:
                     "undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | fontsizeselect | link",
               },
            };
            break;
      }

      component.onShow = () => {
         // WORKAROUND : to fix breaks TinyMCE when switch pages/tabs
         // https://forum.webix.com/discussion/6772/switching-tabs-breaks-tinymce
         if (
            this.settings.type &&
            this.settings.type == "rich" &&
            $$(component.ui.id)
         ) {
            // recreate rich editor
            webix.ui(component.ui, $$(component.ui.id));
            // Add dataCy to TinyMCE text editor
            $$(component.ui.id).getChildViews()[0].getEditor(true).then((editor) => {
               const dataCy = `${this.key} rich ${component.ui.name} ${this.id} ${this.parent.id}`;
               editor.contentAreaContainer.setAttribute('data-cy', dataCy);
            });
         }
      };

      return webix.copy(component);
   }
};


/***/ }),

/***/ 56222:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormTree.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormTreeCore = __webpack_require__(/*! ../../core/views/ABViewFormTreeCore */ 80926);

module.exports = class ABViewFormTree extends ABViewFormTreeCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewFormTreeEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         options: App.unique(`${idBase}_option`),
      };

      var selectlist = this.component(App).ui;
      selectlist.id = ids.component;

      var _ui = {
         rows: [selectlist, {}],
      };

      var _init = (options) => {};

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );
      // var L = App.Label;

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         // {
         // 	name: 'type',
         // 	view: 'richselect',
         // 	label: L('ab.component.selectsingle.type', '*Type'),
         // 	options: [
         // 		{
         // 			id: 'richselect',
         // 			value: L('ab.component.selectsingle.selectlist', '*Select list')
         // 		},
         // 		{
         // 			id: 'radio',
         // 			value: L('ab.component.selectsingle.radio', '*Radio')
         // 		}
         // 	]
         // }
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      // $$(ids.type).setValue(view.settings.type || ABViewFormTreePropertyComponentDefaults.type);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      // view.settings.type = $$(ids.type).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var component = super.component(App);
      var field = this.field();
      var form = this.parentFormComponent();

      // this field may be deleted
      if (!field) return component;

      var idBase = this.parentFormUniqueID(`ABViewFormTree_${this.id}_f_`);
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var settings = {};
      if (form) settings = form.settings;

      var requiredClass = "";
      if (field.settings.required == 1) {
         requiredClass = "webix_required";
      }

      var templateLabel = "";
      if (settings.showLabel == true) {
         if (settings.labelPosition == "top")
            templateLabel =
               '<label style="display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="webix_inp_top_label ' +
               requiredClass +
               '">#label#</label>';
         else
            templateLabel =
               '<label style="width: #width#px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="' +
               requiredClass +
               '">#label#</label>';
      }

      var newWidth = settings.labelWidth;
      if (typeof this.settings.formView != "undefined") newWidth += 40;

      var template = (templateLabel + "#template#")
         .replace(/#width#/g, settings.labelWidth)
         .replace(/#label#/g, field.label)
         .replace(
            /#template#/g,
            field.columnHeader({
               width: newWidth,
            }).template
         );

      component.ui.id = ids.component;
      component.ui.view = "template";
      component.ui.css = "webix_el_box";
      if (
         typeof field.settings.useHeight != "undefined" &&
         field.settings.useHeight == 1
      ) {
         component.ui.height = parseInt(field.settings.imageHeight);
      } else {
         component.ui.height = 38;
      }
      component.ui.borderless = true;

      component.ui.template = '<div class="customField">' + template + "</div>";

      component.ui.onClick = {
         customField: function (id, e, trg) {
            var rowData = {},
               node = $$(ids.component).$view;

            rowData[field.columnName] = component.logic.getValue();
            field.customEdit(rowData, App, node, component);
         },
      };

      component.onShow = () => {};

      // make sure each of our child views get .init() called
      component.init = (options) => {};

      component.logic = {
         getValue: () => {
            var vals = $$(ids.component).getValues();
            // Pass empty string if the returned values is empty array
            if (Array.isArray(vals) && vals.length == 0) vals = "";
            return vals;
         },
      };

      return component;
   }
};


/***/ }),

/***/ 59136:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGantt.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGantt)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 85766);
const ABViewGanttCore = __webpack_require__(/*! ../../core/views/ABViewGanttCore */ 66959);


let L = null;

const DAY_SCALE = { unit: "day", format: "%d" },
   WEEK_SCALE = {
      unit: "week",
      format: (start) => {
         const parser = webix.Date.dateToStr("%d %M");
         const wstart = webix.Date.weekStart(start);
         const wend = webix.Date.add(
            webix.Date.add(wstart, 1, "week", true),
            -1,
            "day",
            true
         );
         return parser(wstart) + " - " + parser(wend);
      },
   },
   MONTH_SCALE = { unit: "month", format: "%F" },
   YEAR_SCALE = { unit: "year", format: "%Y" };

class ABViewGanttComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(viewGantt, idBase) {
      var base = idBase || `ABViewGantt_${viewGantt.id}`;

      super(base, {
         menu: "",
         gantt: "",
      });

      this.viewGantt = viewGantt;
      this.AB = viewGantt.AB;

      this.settings = viewGantt.settings;

      this._tempDC = null;
      // {ABDataCollection}
      // A link to a DC that was passed in.  NOTE: this is only for
      // the temp DCs created in the AppBuilder Designer and passed
      // in.  Normal DCs are handled by the default CurrentDatacollection
      // methods.

      this.TitleField = null;
      this.StartDateField = null;
      this.EndDateField = null;
      this.DurationField = null;
      this.ProgressField = null;
      this.NotesField = null;

      this.originalStartDate = null;
      this.originalEndDate = null;

      this.pendingAdds = {};
      // {Promise}  /* id : {Promise} */
      // In order to prevent a race condition where multiple adds can be
      // generated on the same item, we catch the repeats and just return
      // the same data for each.

      this.ganttElement = {
         isExistsTask: (taskId) => {
            let localService = $$(this.ids.gantt).getService("local");
            if (!localService) return false;

            let tasksData = localService.tasks();
            if (!tasksData || !tasksData.exists) return false;

            return tasksData.exists(taskId);
         },
         removeTask: (taskId) => {
            if (!this.ganttElement.isExistsTask(taskId)) return;

            let opsService = $$(this.ids.gantt).getService("operations");
            if (!opsService) return;

            return opsService.removeTask(taskId);
         },
      };

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   ui() {
      var ids = this.ids;
      var _this = this;

      return {
         id: ids.component,
         rows: [
            {
               cols: [
                  { fillspace: true },
                  {
                     view: "menu",
                     id: ids.menu,
                     layout: "x",
                     width: 300,
                     data: [
                        {
                           id: "day",
                           value: L("Day"),
                        },
                        {
                           id: "week",
                           value: L("Week"),
                        },
                        {
                           id: "month",
                           value: L("Month"),
                        },
                        {
                           id: "year",
                           value: L("Year"),
                        },
                     ],
                     on: {
                        onItemClick: (id /* , e, node */) => {
                           this.setScale(id);
                        },
                     },
                  },
               ],
            },
            {
               id: ids.gantt,
               view: "gantt",
               scales: [YEAR_SCALE, MONTH_SCALE, DAY_SCALE],
               override: new Map([
                  [
                     gantt.services.Backend,
                     // global webix gantt object
                     class MyBackend extends gantt.services.Backend {
                        async tasks() {
                           var DC = _this.CurrentDatacollection;
                           if (!DC) return [];

                           // if (DC.dataStatus != DC.dataStatusFlag.initialized) {
                           //    await DC.loadData().catch((err) => {
                           //       console.error(err);
                           //    });
                           // }
                           return (DC.getData() || []).map((d, indx) =>
                              _this.convertFormat(d, indx)
                           );
                        }
                        links() {
                           return Promise.resolve([]);
                        }
                        async addTask(obj, index, parent) {
                           if (!_this.pendingAdds[obj.id]) {
                              _this.pendingAdds[obj.id] = _this.taskAdd(obj);
                           }
                           let newTask = await _this.pendingAdds[obj.id];
                           delete _this.pendingAdds[obj.id];
                           return {
                              id: (newTask || {}).id,
                           };
                        }
                        async updateTask(id, obj) {
                           await _this.taskUpdate(obj.id, obj);
                           return {};
                        }
                        async removeTask(id) {
                           await _this.taskRemove(id);
                           return {};
                        }
                     },
                  ],
               ]),
            },
         ],
      };
   }

   async init(AB) {
      this.AB = AB;

      // #HACK!: as of webix v.8.1.1 there is a visual glitch of the Gantt
      // object if you replace a gantt widget with a new definition (like in
      // the ABDesigner you can switch from Gantt1 to Gantt2 in the object
      // workspace).  In that one case, the menu would disappear even though
      // the data is present.  So this makes sure the menu is shown
      let $menu = $$(this.ids.menu);
      if ($menu) {
         $menu.showItem("day");
      }
   }

   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      let DC = super.CurrentDatacollection;
      if (!DC) {
         DC = this._tempDC;
      }
      return DC;
   }

   /**
    * @method convertFormat()
    * Convert an ABObject's row value into a gantt task data format.
    * @param {obj} row
    *        The current row of data returned from an ABObject.
    * @param {int} index
    *        The order of this task.
    * @return {obj}
    *         A key=>value hash corresponding to the gantt task that
    *         represents this row of data.
    */
   convertFormat(row, index = null) {
      let data = {};
      row = row || {};

      if (!this.StartDateField || (!this.EndDateField && !this.DurationField))
         return data;

      let currDate = new Date();
      data["id"] = row.id || row.uuid;
      data["type"] = "task";
      data["parent"] = 0;
      data["open"] = true;
      // define label
      data["text"] = this.TitleField
         ? row[this.TitleField.columnName] || ""
         : this.CurrentObject.displayData(row);
      data["start_date"] = row[this.StartDateField.columnName] || currDate;
      data["progress"] = this.ProgressField
         ? parseFloat(row[this.ProgressField.columnName] || 0)
         : 0;

      if (this.NotesField)
         data["details"] = row[this.NotesField.columnName] || "";

      if (this.EndDateField)
         data["end_date"] = row[this.EndDateField.columnName] || currDate;

      if (this.DurationField)
         data["duration"] = row[this.DurationField.columnName] || 1;

      // Default values
      if (!data["end_date"] && !data["duration"]) {
         data["end_date"] = currDate;
         data["duration"] = 1;
      }

      if (index != null) data["order"] = index;

      return data;
   }

   /**
    * @method convertValues()
    * Convert a Gantt task into a set of values for our ABObject.
    * @param {obj} task
    *        The current gantt task data.
    * @return {obj}
    *         A key=>value hash corresponding to the ABObject that
    *         is tied to this gantt.
    */
   convertValues(task) {
      let patch = {};

      if (this.TitleField)
         patch[this.TitleField.columnName] = task["text"] || "";

      if (this.StartDateField)
         patch[this.StartDateField.columnName] = task["start_date"];

      if (this.ProgressField)
         patch[this.ProgressField.columnName] = parseFloat(
            task["progress"] || 0
         );

      if (this.NotesField) patch[this.NotesField.columnName] = task["details"];

      if (this.EndDateField)
         patch[this.EndDateField.columnName] = task["end_date"];

      if (this.DurationField)
         patch[this.DurationField.columnName] = task["duration"];

      return patch;
   }

   /**
    * @method objectLoad
    * @param {ABObject} object
    */
   objectLoad(object) {
      super.objectLoad(object);
      if (object) {
         this.TitleField = object.fieldByID(this.settings.titleFieldID);
         this.StartDateField = object.fieldByID(this.settings.startDateFieldID);
         this.EndDateField = object.fieldByID(this.settings.endDateFieldID);
         this.DurationField = object.fieldByID(this.settings.durationFieldID);
         this.ProgressField = object.fieldByID(this.settings.progressFieldID);
         this.NotesField = object.fieldByID(this.settings.notesFieldID);
      }
   }

   /**
    * @method datacollectionLoad
    * @param {ABDatacollection} datacollection
    */
   datacollectionLoad(datacollection) {
      super.datacollectionLoad(datacollection);

      let DC = this.CurrentDatacollection;
      if (!DC && datacollection) {
         // NOTE: this can happen in the ABDesigner object workspace.
         // we send in a temp DC with no .id
         this._tempDC = datacollection;
         DC = datacollection;
      }

      // NOTE: keep .objectLoad() before any .initData() is called.
      this.objectLoad(DC.datasource);

      if (DC.dataStatus == DC.dataStatusFlag.initialized) {
         this.initData();
      }

      this.eventAdd({
         emitter: DC,
         eventName: "initializedData",
         listener: () => {
            this.initData();
         },
      });

      // real-time update
      this.eventAdd({
         emitter: DC,
         eventName: "create",
         listener: () => {
            this.initData();
         },
      });

      this.eventAdd({
         emitter: DC,
         eventName: "update",
         listener: () => {
            this.initData();
         },
      });

      this.eventAdd({
         emitter: DC,
         eventName: "delete",
         listener: (taskId) => {
            // remove this task in gantt
            if (this.ganttElement.isExistsTask(taskId))
               this.ganttElement.removeTask(taskId);
         },
      });
   }

   /**
    * @function hide()
    * hide this component.
    */
   hide() {
      $$(this.ids.component)?.hide();
   }

   initData() {
      let ganttElem = $$(this.ids.gantt);
      if (!ganttElem) return;

      let dataService = ganttElem.getService("local");
      if (!dataService) return;

      let dcTasks = dataService.tasks();
      if (!dcTasks) return;

      // gantt v 8.1.1
      // Note: there is a race condition that can happen here.
      // dataService.tasks() calls the MyBackend.tasks() above which
      // returns a Promise.
      // when you call dcTasks.clearAll() before the promise
      // is resolved, the gantt internally throws an error.
      //
      // So give webix some time to internally complete it's process
      // before we do .clearAll();
      setTimeout(() => {
         dcTasks.clearAll();

         let DC = this.CurrentDatacollection;
         let gantt_data = {
            data: DC
               ? (DC.getData() || []).map((d, index) =>
                    this.convertFormat(d, index)
                 )
               : [],
         };

         // check required fields before parse
         if (this.StartDateField && (this.EndDateField || this.DurationField)) {
            dcTasks.parse(gantt_data);
         }

         // Keep original start and end dates for calculate scale to display
         const currScale = dataService.getScales();
         this.originalStartDate = currScale.start;
         this.originalEndDate = currScale.end;

         this.sort();
      }, 10);
   }

   setScale(scale) {
      let ganttElem = $$(this.ids.gantt);
      if (!ganttElem) return;

      let ganttData = ganttElem.getService("local");
      if (!ganttData) return;

      let newScales = [];

      switch (scale) {
         case "day":
            newScales = [YEAR_SCALE, MONTH_SCALE, DAY_SCALE];
            break;
         case "week":
            newScales = [YEAR_SCALE, MONTH_SCALE, WEEK_SCALE];
            break;
         case "month":
            newScales = [YEAR_SCALE, MONTH_SCALE];
            break;
         case "year":
            newScales = [YEAR_SCALE];
            break;
      }

      const currScale = ganttElem.getService("local").getScales(),
         start = webix.Date.add(this.originalStartDate, -1, scale, true),
         end = webix.Date.add(this.originalEndDate, 1, scale, true);

      ganttData.setScales(
         start,
         end,
         currScale.precise,
         currScale.cellWidth,
         currScale.cellHeight,
         newScales
      );
      ganttElem.$app.refresh();
      ganttElem.getState().$batch({ top: 0, left: 0 });
   }

   /**
    * @function show()
    * Show this component.
    */
   show() {
      $$(this.ids.component)?.show();
   }

   sort() {
      // TODO: sorting;
      return;
      // let gantt = $$(ids.gantt).getGantt();
      // if (!gantt) return;

      // // default sort
      // let MAX_date = new Date(8640000000000000);
      // gantt.sort(function(a, b) {
      //    let aStartDate = a["start_date"],
      //       aEndDate = a["end_date"],
      //       aDuration = a["duration"] || 1,
      //       bStartDate = b["start_date"],
      //       bEndDate = b["end_date"],
      //       bDuration = b["duration"] || 1;

      //    // if no start date, then be a last item
      //    if (
      //       a[this.StartDateField.columnName] == null ||
      //       b[this.StartDateField.columnName] == null
      //    ) {
      //       return (
      //          (a[this.StartDateField.columnName] || MAX_date) -
      //          (b[this.StartDateField.columnName] || MAX_date)
      //       );
      //    } else if (aStartDate != bStartDate) {
      //       return aStartDate - bStartDate;
      //    } else if (aEndDate != bEndDate) {
      //       return aEndDate - bEndDate;
      //    } else if (aDuration != bDuration) {
      //       return bDuration - aDuration;
      //    }
      // }, false);
   }

   async taskAdd(taskData) {
      let patch = this.convertValues(taskData);

      try {
         return await this.CurrentObject?.model().create(patch);
      } catch (e) {
         webix.alert({
            title: L("Error Saving Item"),
            ok: L("Okay"),
            text: L("Unable to save this item."),
         });
         this.AB.notify.developer(e, {
            context: "ABViewGantt:taskAdd(): Error Saving Item",
            patch,
         });
         throw e;
      }
   }

   async taskRemove(rowId) {
      try {
         await this.CurrentObject.model().delete(rowId);
      } catch (e) {
         webix.alert({
            title: L("Error Removing Item"),
            ok: L("Okay"),
            text: L("Unable to remove this item."),
         });
         this.AB.notify.developer(e, {
            context: "ABViewGantt:taskRemove(): Error Removing Item",
            rowId,
         });
         throw e;
      }
   }

   async taskUpdate(rowId, updatedTask) {
      let patch = this.convertValues(updatedTask);
      try {
         await this.CurrentObject.model().update(rowId, patch);
      } catch (e) {
         webix.alert({
            title: L("Error Updating Item"),
            ok: L("Okay"),
            text: L("Unable to update this item."),
         });
         this.AB.notify.developer(e, {
            context: "ABViewGantt:taskUpdate(): Error Updating Item",
            patch,
         });
         throw e;
      }
   }
}

class ABViewGantt extends ABViewGanttCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      return this.component(App);
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(v1App = false) {
      var component = new ABViewGanttComponent(this);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (/* options, accessLevel*/) => {
               return newComponent.init(this.AB);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }
}


/***/ }),

/***/ 58052:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGrid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGrid)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 85766);
/* harmony import */ var _ABViewGridPopupExport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewGridPopupExport */ 55090);
/* harmony import */ var _ABViewGridPopupMassUpdate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ABViewGridPopupMassUpdate */ 33414);
/* harmony import */ var _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ABViewGridPopupSortFields */ 60732);
/* harmony import */ var _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyFilterData */ 84204);
const ABViewGridCore = __webpack_require__(/*! ../../core/views/ABViewGridCore */ 12268);






const ABViewPropertyLinkPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 95782)["default"]);

const KEY_STORAGE_SETTINGS = "abviewgrid_settings";
// {string}
// the unique key for ABViewGrids to store/retrieve their local settings

var GridSettings = null;
// {hash} { grid.id : [ {columnHeader}, {columnHeader} ...]}
// Keep a global copy of our local Grid settings, so we can optimize the header
// sizes.

// let PopupHideFieldComponent = null;
// let PopupFrozenColumnsComponent = null;
// let PopupFilterProperty = null;
// let PopupSummaryColumnsComponent = null;
// let PopupCountColumnsComponent = null;

var L = null;
// multilingual Label fn()

class ABViewGridComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(viewGrid, idBase) {
      var base = idBase || `ABViewGrid_${viewGrid.id}`;

      super(base, {
         // component: `${base}_component`,
         toolbar: "",
         buttonDeleteSelected: "",

         buttonFilter: "",
         buttonMassUpdate: "",
         buttonSort: "",
         buttonExport: "",

         globalSearchToolbar: "",

         datatable: "",
      });

      this.viewGrid = viewGrid;
      this.viewGrid.filterHelper.on("filter.data", (fnFilter, filterRules) => {
         this.callbackFilterData(fnFilter, filterRules); // be notified when there is a change in the filter
      });

      // derive these from viewGrid
      this.AB = viewGrid.AB;
      this.id = viewGrid.id;
      this.settings = viewGrid.settings || {};

      /////
      ///// For TEsting:
      /////
      // this.settings.showToolbar = 1;
      // this.settings.isEditable = 1;
      // this.settings.isExportable = 1;
      // this.settings.gridFilter = {
      //    filterOption: 1,
      //    userFilterPosition: "form",
      //    isGlobalToolbar: 1,
      // };

      // this.settings.detailsPage = "some-uuid";
      // this.settings.detailTab = "some_uuid_2";
      // this.settings.trackView = 1;
      /////
      ///// end testing
      /////

      this.columnSplitLeft = 0;
      // {integer}
      // Which column to "split"/"freeze" from the left side of the grid.

      this.columnSplitRight = 0;
      // {integer}
      // The # columns to the right to freeze.

      this.datacollection = null;
      // {ABDataCollection}
      // The Webix DataCollection that manages the data we are displaying.

      this.validationError = false;
      // {bool}
      // Has a Validation Error occured?

      this.linkPage = this.viewGrid.linkPageHelper.component(
         this.AB._App,
         `${base}_gridlinkpage`
      );
      // {ABViewPropertyLinkPage}
      //

      this.PopupExport = new _ABViewGridPopupExport__WEBPACK_IMPORTED_MODULE_1__["default"](base);
      this.PopupExport.init(this.AB);
      // {ABViewGridPopupExport}
      // Popup for managing how to export our data.

      this.PopupMassUpdateComponent = new _ABViewGridPopupMassUpdate__WEBPACK_IMPORTED_MODULE_2__["default"](this, this.id);
      this.PopupMassUpdateComponent.init(this.AB);
      // this.PopupMassUpdateComponent.on("")
      // {}
      // The popup for performing a Mass Edit operation.

      this.PopupSortDataTableComponent = new _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_3__["default"](base);
      this.PopupSortDataTableComponent.init(this.AB);
      this.PopupSortDataTableComponent.on("changed", (sortOptions) => {
         this.callbackSortData(sortOptions);
      });
      // {ABViewGridPopupSortFields}
      // The popup for adding sort criteria to our grid.

      this.skippableColumns = [
         "appbuilder_select_item",
         "appbuilder_view_detail",
         "appbuilder_view_track",
         "appbuilder_view_edit",
         "appbuilder_trash",
      ];
      // {array}
      // An array of column names that should be skipped from some of our
      // event handlers.

      // this.EditField = null;
      // // {ABFieldXXX}
      // // Which ABField is the focus of our PopupHeader menu?

      // this.EditNode = null;
      // // {HTML DOM}
      // // The webix.$node where the ABField Header is that our PopupHeader
      // // should be displayed at.

      this.handler_select = (...params) => {
         this.selectRow(...params);
      };
      // {fn} .handler_select
      // the callback fn for our selectRow()
      // We want this called when the .datacollection we are linked to
      // emits an "onChange" event.

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   /**
    * @method getColumnIndex()
    * return the Datatable.getColumnIndex() value
    * @param {string} id
    *        the uuid of the column we are referencing.
    * @return {integer}
    */
   getColumnIndex(id) {
      var indx = this.getDataTable().getColumnIndex(id);
      if (!this.settings.massUpdate) {
         // the index is 0 based. So if the massUpdate feature isn't
         // enabled, we need to add 1 to the result so they look like
         // a 1, 2, ...

         indx++;
      }
      return indx;
   }

   uiDatatable() {
      var ids = this.ids;
      var settings = this.settings;
      var self = this;

      var view = "datatable";
      if (settings.isTreeDatable || settings.groupBy) {
         // switch datatable to support tree
         view = "treetable";
      }

      var selectType = "cell";
      if (!settings.isEditable && (settings.detailsPage || settings.editPage)) {
         selectType = "row";
      }

      return {
         view: view,
         id: ids.datatable,
         resizeColumn: { size: 10 },
         resizeRow: { size: 10 },
         prerender: false,
         editable: settings.isEditable,
         fixedRowHeight: false,
         height: settings.height || 0,
         editaction: "custom",
         select: selectType,
         footer:
            // show footer when there are summary columns
            settings.summaryColumns.length > 0 ||
            settings.countColumns.length > 0,
         tooltip: true,
         // tooltip: {
         //    // id: ids.tooltip,
         //    template: (obj, common) => {
         //       return this.toolTip(obj, common);
         //    },
         //    on: {
         //       // When showing a larger image preview the tooltip sometime displays part of the image off the screen...this attempts to fix that problem
         //       onBeforeRender: function () {
         //          self.toolTipOnBeforeRender(this.getNode());
         //       },
         //       onAfterRender: function (data) {
         //          self.toolTipOnAfterRender(this.getNode());
         //       },
         //    },
         // },
         dragColumn: true,
         on: {
            onBeforeSelect: function (data, preserve) {
               if (self.skippableColumns.indexOf(data.column) != -1) {
                  return false;
               } else if (settings.isEditable) {
                  var currObject = self.datacollection.datasource;
                  var selectField = currObject.fields((f) => {
                     return f.columnName == data.column;
                  })[0];

                  if (selectField == null) return true;

                  var cellNode = this.getItemNode({
                        row: data.row,
                        column: data.column,
                     }),
                     rowData = this.getItem(data.row);

                  console.error("TODO: field.customEdit() remove App param!");
                  return selectField.customEdit(
                     rowData,
                     self.AB._App,
                     cellNode
                  );
               } else if (!settings.detailsPage && !settings.editPage) {
                  return false;
               }
            },
            onAfterSelect: (data, preserve) => {
               // {ABObject} data
               //            the selected object
               // {bool} prevent
               //        indicates whether the previous selection state should
               //        be saved. (is multiselect and they are holding SHIFT)
               if (this.settings.isEditable) {
                  this.onAfterSelect(data, preserve);
               }
            },
            onBeforeEditStart: function (id) {
               if (!this.getItem(id) == "appbuilder_select_item") return false;
            },
            onCheck: function (row, col, val) {
               // Update checkbox data
               if (col == "appbuilder_select_item") {
                  // do nothing because we will parse the table once we decide
                  // if we are deleting or updating rows
                  self.toggleUpdateDelete();
               } else {
                  if (self.settings.isEditable) {
                     // if the colum is not the select item column move on to
                     // the next step to save
                     var state = {
                        value: val,
                     };

                     var editor = {
                        row: row,
                        column: col,
                        config: null,
                     };
                     self.onAfterEditStop(state, editor);
                  } else {
                     var node = this.getItemNode({
                        row: row,
                        column: col,
                     });
                     var checkbox = node.querySelector(
                        'input[type="checkbox"]'
                     );
                     if (val == 1) {
                        checkbox.checked = false;
                     } else {
                        checkbox.checked = true;
                     }
                  }
               }
            },
            onBeforeEditStop: function (state, editor) {
               // console.warn("!! ToDo: onBeforeEditStop()");
            },
            onAfterEditStop: (state, editor, ignoreUpdate) => {
               if (this.validationError == false)
                  this.onAfterEditStop(state, editor, ignoreUpdate);
            },
            onValidationError: function () {
               this.validationError = true;
            },
            onValidationSuccess: function () {
               this.validationError = false;
            },

            // We are sorting with server side requests now so we can remove this
            // onAfterLoad: function () {
            //    _logic.onAfterLoad();
            // },
            onColumnResize: function (
               columnName,
               newWidth,
               oldWidth,
               user_action
            ) {
               // if we resize the delete column we want to resize the last
               // column but Webix will not allow since the column is split
               var rightSplitItems = [
                  "appbuilder_view_detail",
                  "appbuilder_view_track",
                  "appbuilder_view_edit",
                  "appbuilder_trash",
               ];
               if (rightSplitItems.indexOf(columnName) != -1) {
                  // Block events so we can leave the delete column alone
                  this.blockEvent();
                  // keeps original width
                  this.setColumnWidth(columnName, oldWidth);
                  this.unblockEvent();
                  // Listen to events again

                  // find the last column's config
                  var column = self.getLastColumn();

                  columnName = column.id;

                  // determine if we are making the column larger or smaller
                  if (newWidth < oldWidth) {
                     newWidth = column.width + 40;
                     // add 40 because there is not any more space to drag so we
                     // will allow 40px increments
                  } else {
                     newWidth = column.width - (newWidth - 40);
                     // take the column's width and subtrack the difference of
                     // the expanded delet column drag
                  }
                  // we don't want columns to be smaller than 50 ?? do we ??
                  // I could be wrong maybe a checkbox could be smaller so this
                  // could change
                  if (newWidth < 50) {
                     newWidth = 50;
                  }
                  // minWidth is important because we are using fillspace:true
                  column.minWidth = newWidth;
                  // Sets the UI
                  this.setColumnWidth(columnName, newWidth);
               }
               // Saves the new width
               if (user_action) {
                  self.onColumnResize(
                     columnName,
                     newWidth,
                     oldWidth,
                     user_action
                  );
               }
            },
            onRowResize: (rowId) => {
               // V2: we no longer do anything onRowResize()
               // before we saved the row height in the record.
               // this.onRowResize(rowId);
            },
            onBeforeColumnDrag: (sourceId, event) => {
               if (this.skippableColumns.indexOf(sourceId) != -1) return false;
               else return true;
            },
            onBeforeColumnDrop: (sourceId, targetId, event) => {
               // Make sure we are not trying to drop onto one of our special
               // columns ...
               if (this.skippableColumns.indexOf(targetId) != -1) return false;
            },
            onAfterColumnDrop: (sourceId, targetId, event) => {
               this.onAfterColumnDrop(sourceId, targetId, event);
            },
            // onAfterColumnShow: function (id) {
            //    // console.warn("!! ToDo: onAfterColumnShow()");
            //    // $$(self.webixUiId.visibleFieldsPopup).showField(id);
            // },
            // onAfterColumnHide: function (id) {
            //    // console.warn("!! ToDo: onAfterColumnHide()");
            //    // $$(self.webixUiId.visibleFieldsPopup).hideField(id);
            // },

            onHeaderClick: (id, e, node) => {
               /* if (settings.configureHeaders) */
               this.onHeaderClick(id, e, node);
            },
         },
      };
   }

   uiFilter() {
      return this.viewGrid.filterHelper.ui();

      // make sure onFilterData is now .emit()ed instead of passing in a callback.
   }

   /**
    * @method uiToolbar()
    * Return the webix definition for the toolbar row for our Grids.
    * @return {json}
    */
   uiToolbar() {
      var ids = this.ids;
      var self = this;

      return {
         view: "toolbar",
         id: ids.toolbar,
         hidden: true,
         css: "ab-data-toolbar",
         cols: [
            {
               view: "button",
               id: ids.buttonMassUpdate,
               css: "webix_transparent",
               label: L("Edit"),
               icon: "fa fa-pencil-square-o",
               type: "icon",
               disabled: true,
               autowidth: true,
               click: function () {
                  self.toolbarMassUpdate(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonDeleteSelected,
               css: "webix_transparent",
               label: L("Delete"),
               icon: "fa fa-trash",
               type: "icon",
               disabled: true,
               autowidth: true,
               click: function () {
                  self.toolbarDeleteSelected(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonFilter,
               css: "webix_transparent",
               label: L("Filters"),
               icon: "fa fa-filter",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarFilter(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonSort,
               css: "webix_transparent",
               label: L("Sort"),
               icon: "fa fa-sort",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarSort(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonExport,
               css: "webix_transparent",
               label: L("Export"),
               icon: "fa fa-print",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarExport(this.$view);
               },
            },
            {},
            {
               id: ids.globalSearchToolbar,
               view: "search",
               placeholder: L("Search..."),
               on: {
                  onTimedKeyPress: () => {
                     let searchText = $$(ids.globalSearchToolbar).getValue();
                     this.viewGrid.filterHelper.externalSearchText(searchText);
                  },
               },
            },
         ],
      };
   }

   ui() {
      var tableUI = {
         type: "space",
         borderless: true,
         rows: [
            {},
            {
               view: "label",
               label: L("Select an object to load."),
               inputWidth: 200,
               align: "center",
            },
            {},
         ],
      };

      if (this.datacollection || this.settings.dataviewID != "") {
         tableUI.padding = this.settings.padding;
         tableUI.rows = [];
         if (this.settings.showToolbar) {
            tableUI.rows.push(this.uiToolbar());
         }
         if (this.settings.gridFilter.filterOption) {
            tableUI.rows.push(this.uiFilter());
         }

         tableUI.rows.push(this.uiDatatable());
      }

      return tableUI;
   }

   async init(AB, accessLevel = 2) {
      if (AB) {
         this.AB = AB;
      }
      var self = this;
      var ids = this.ids;

      // WORKAROUND : Where should we define this ??
      // For include PDF.js
      webix.codebase = "";
      webix.cdn = "/js/webix";

      // this shows the options to Hide, Filter, sort , etc...
      // only in Designer?
      // PopupHeaderEditComponent.init({
      //    onClick: _logic.callbackHeaderEdit, // be notified when there is a change in the hidden fields
      // });

      // NOTE: register the onAfterRender() here, so it only registers
      // one.
      var DataTable = this.getDataTable();
      var throttleCustomDisplay = null;
      var scrollStarted = null;

      webix.extend(DataTable, webix.ProgressBar);

      DataTable.config.accessLevel = accessLevel;
      if (accessLevel < 2) {
         DataTable.define("editable", false);
      }

      let customDisplays = (data) => {
         var CurrentObject = this.datacollection?.datasource;
         if (!CurrentObject || !DataTable.data) return;

         var displayRecords = [];

         let verticalScrollState = DataTable.getScrollState().y,
            rowHeight = DataTable.config.rowHeight,
            height =
               DataTable.$view.querySelector(".webix_ss_body").clientHeight,
            startRecIndex = Math.floor(verticalScrollState / rowHeight),
            endRecIndex = startRecIndex + DataTable.getVisibleCount(),
            index = 0;

         DataTable.data.order.each(function (id) {
            if (id != null && startRecIndex <= index && index <= endRecIndex)
               displayRecords.push(id);

            index++;
         });

         var editable = this.settings.isEditable;
         if (DataTable.config.accessLevel < 2) {
            editable = false;
         }
         CurrentObject.customDisplays(
            data,
            this.AB._App,
            DataTable,
            displayRecords,
            editable
         );
      };

      DataTable.attachEvent("onAfterRender", function (data) {
         DataTable.resize();

         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);
         throttleCustomDisplay = setTimeout(() => {
            if (scrollStarted) clearTimeout(scrollStarted);
            customDisplays(this.data);
         }, 350);

         AB.ClassUI.CYPRESS_REF(DataTable);
         Object.keys(ids).forEach((key) => {
            var $el = $$(ids[key]);
            if ($el) {
               AB.ClassUI.CYPRESS_REF($el);
            }
         });
      });

      // we have some data types that have custom displays that don't look
      // right after scrolling large data sets we need to call customDisplays
      // again
      DataTable.attachEvent("onScroll", function () {
         if (scrollStarted) clearTimeout(scrollStarted);
         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);

         scrollStarted = setTimeout(() => {
            customDisplays(this.data);
         }, 1500);
      });
      DataTable.attachEvent("onAfterScroll", function () {
         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);

         throttleCustomDisplay = setTimeout(() => {
            if (scrollStarted) clearTimeout(scrollStarted);
            customDisplays(this.data);
         }, 350);
      });

      // Process our onItemClick events.
      // this is a good place to check if our delete/trash icon was clicked.
      DataTable.attachEvent("onItemClick", function (id, e, node) {
         // make sure we have an object selected before processing this.
         var CurrentObject = self.datacollection?.datasource;
         if (!CurrentObject) {
            return;
         }

         if (self.settings.isEditable == 0) {
            var items = DataTable.getItem(id);
         }
         // if this was our edit icon:
         // console.log(e.target.className);
         if (e == "auto" || e.target.className.indexOf("eye") > -1) {
            // View a Details Page:
            self.changePage(dv, id, self.settings.detailsPage);
            self.toggleTab(self.settings.detailsTab, this);
         } else if (e.target.className.indexOf("pencil") > -1) {
            self.changePage(dv, id, self.settings.editPage);
            self.toggleTab(self.settings.editTab, this);
         } else if (e.target.className.indexOf("track") > -1) {
            self.emit("object.track", CurrentObject, id.row);
            // App.actions.openObjectTrack(CurrentObject, id.row);
         } else if (e.target.className.indexOf("clear-combo-value") > -1) {
            let clearValue = {};
            clearValue[id.column] = "";
            CurrentObject.model()
               .update(id.row, clearValue)
               .then((response) => {
                  // console.log(response);
               })
               .catch((err) => {
                  self.AB.notify.developer(err, {
                     context: "ABViewGridComponent.onItemClick",
                     message: "Error updating item",
                     obj: CurrentObject.toObj(),
                     id: id.row,
                  });
               });
         } else if (e.target.className.indexOf("trash") > -1) {
            // if this was our trash icon:

            webix.confirm({
               title: L("Delete data"),
               text: L("Do you want to delete this row?"),
               callback: function (result) {
                  if (result) {
                     CurrentObject.model()
                        .delete(id.row)
                        .then((response) => {
                           if (response.numRows > 0) {
                              DataTable.remove(id);
                              DataTable.clearSelection();
                           } else {
                              webix.alert({
                                 text: L(
                                    "No rows were effected.  This does not seem right."
                                 ),
                              });
                           }
                        })
                        .catch((err) => {
                           self.AB.notify.developer(err, {
                              context: "ABViewGridComponent.onItemClick",
                              message: "Error deleting item",
                              obj: CurrentObject.toObj(),
                              id: id.row,
                           });

                           //// TODO: what do we do here?
                        });
                  }

                  DataTable.clearSelection();
                  return true;
               },
            });
         } else if (self.settings.detailsPage.length) {
            // If an icon wasn't selected but a details page is set
            // view the details page
            self.changePage(dv, id, self.settings.detailsPage);
            self.toggleTab(self.settings.detailsTab, this);
         } else if (self.settings.editPage.length) {
            // If an icon wasn't selected but an edit page is set
            // view the edit page
            self.changePage(dv, id, self.settings.editPage);
            self.toggleTab(self.settings.editTab, this);
         }
      });

      // ABViewGrid Original init();

      if (this.settings.showToolbar) {
         if (
            this.settings.massUpdate ||
            this.settings.isSortable ||
            this.settings.isExportable ||
            (this.settings.gridFilter &&
               this.settings.gridFilter.filterOption &&
               this.settings.gridFilter.userFilterPosition == "toolbar")
         ) {
            $$(ids.toolbar).show();
         }

         if (this.settings.massUpdate == false) {
            $$(ids.buttonMassUpdate).hide();
            $$(ids.buttonDeleteSelected).hide();
         }

         if (this.settings.allowDelete == false) {
            $$(ids.buttonDeleteSelected).hide();
         }

         if (this.settings.gridFilter) {
            if (
               this.settings.gridFilter.filterOption != 1 ||
               this.settings.gridFilter.userFilterPosition != "toolbar"
            ) {
               $$(ids.buttonFilter).hide();
            }

            if (
               this.settings.gridFilter.filterOption == 3 &&
               this.settings.gridFilter.globalFilterPosition == "single"
            ) {
               DataTable.hide();
            }

            if (this.settings.gridFilter.isGlobalToolbar)
               $$(ids.globalSearchToolbar).show();
            else $$(ids.globalSearchToolbar).hide();

            if (this.settings.gridFilter.filterOption) {
               this.viewGrid.filterHelper.init(this.AB);
            }
         }

         if (this.settings.isSortable == false) {
            $$(ids.buttonSort).hide();
         }

         if (this.settings.isExportable == false) {
            $$(ids.buttonExport).hide();
         }
      }

      if (this.settings.hideHeader == true) {
         this.hideHeader();
      }

      if (!this.datacollection) {
         if (this.settings.dataviewID) {
            var dv = this.AB.datacollectionByID(this.settings.dataviewID);
            this.datacollectionLoad(dv);
         }
      }

      // Make sure
      if (!GridSettings) {
         GridSettings = (await this.AB.Storage.get(KEY_STORAGE_SETTINGS)) || {};
      }

      if (this.datacollection?.datasource) {
         // TRANSITION: ABViewGrid_orig line 862 ...

         this.linkPage.init({
            view: this.viewGrid,
            datacollection: this.datacollection,
         });

         this.refreshHeader();
      }

      return Promise.resolve();
   }

   /**
    * @method busy()
    * Indicate that our datatable is currently busy loading/processing
    * data.
    */
   busy() {
      this.getDataTable()?.showProgress?.({ type: "icon" });
   }

   /**
    * @method callbackFilterData()
    * Process the provided filter options from our filterHelper.
    * @param {fn} fnFilter
    *        A function that returns true/false for each row of data
    *        to determine if is should exist.
    * @param {array} filterRules
    *        Any Filter Rules added by the user.
    */
   callbackFilterData(fnFilter, filterRules = []) {
      var ids = this.ids;
      var $ButtonFilter = $$(ids.buttonFilter);
      if ($ButtonFilter) {
         var badge = null;
         var onlyFilterRules = this.viewGrid.filterHelper.filterRules();
         if (onlyFilterRules?.rules?.length) {
            badge = 1;
         }
         $ButtonFilter.define("badge", badge);
         $ButtonFilter.refresh();
      }

      this.datacollection.filterCondition(filterRules);
      this.datacollection.reloadData();

      /*
      var $DataTable = $$(ids.datatable);
      Promise.resolve()
         .then(
            () =>
               new Promise((next, err) => {
                  // if (
                  //    !this.settings ||
                  //    !this.settings.gridFilter ||
                  //    this.settings.gridFilter.filterOption != 3
                  // )
                  //    // Global search
                  //    return next();

                  let dc = this.datacollection;
                  if (
                     !dc ||
                     (dc.settings.loadAll &&
                        dc.dataStatus != dc.dataStatusFlag.notInitial)
                  )
                     // Load all already
                     return next();

                  let limit = null;

                  // Load all data
                  // let gridElem = $$(this.ids.datatable);
                  if (
                     $DataTable.data.find({}).length < $DataTable.data.count()
                  ) {
                     dc.reloadData(0, limit)
                        .then(() => {
                           // Should set .loadAll to this data collection ?
                           if (limit == null) dc.settings.loadAll = true;

                           next();
                        })
                        .catch(err);
                  } else {
                     next();
                  }
               })
         )
         // client filter data
         .then(
            () =>
               new Promise((next, err) => {
                  if (!fnFilter) return next();

                  // wait the data are parsed into webix.datatable
                  setTimeout(() => {
                     $DataTable.filter((rowData) => {
                        // rowData is null when is not load from paging
                        if (rowData == null) return false;

                        return fnFilter(rowData);
                     });

                     if (
                        this.settings.gridFilter.globalFilterPosition ==
                        "single"
                     ) {
                        if ($DataTable.count() > 0) {
                           $DataTable.show();
                           $DataTable.select($DataTable.getFirstId(), false);
                           $DataTable.callEvent("onItemClick", [
                              $DataTable.getFirstId(),
                              "auto",
                              null,
                           ]);
                        } else {
                           $DataTable.hide();
                        }
                     }

                     next();
                  }, 500);
               })
         );
         */
   }

   async callbackSortData(sortRules = []) {
      $$(this.ids.buttonSort).define("badge", sortRules.length || null);
      $$(this.ids.buttonSort).refresh();

      let gridElem = this.getDataTable();
      if (gridElem.data.find({}).length < gridElem.data.count()) {
         try {
            // NOTE: Webix's client sorting does not support dynamic loading.
            // If the data does not be loaded, then load all data.
            await this.datacollection.reloadData(0, 0);
         } catch (err) {
            this.AB.notify.developer(err, {
               context:
                  "ABViewGrid:callbackSortData(): Error perform datacollection.reloadData()",
            });
         }
      }
      // wait until the grid component will done to repaint UI
      setTimeout(() => {
         gridElem.sort((a, b) => this.PopupSortDataTableComponent.sort(a, b));
      }, 777);
   }

   /**
    * @method changePage()
    * Helper method to switch to another View.
    * @param {ABDataCollection} dv
    *        The DataCollection we are working with.
    * @param {obj} rowItem
    *        the { row:#, column:{string} } of the item that was clicked.
    * @param {ABViewPage.uuid} page
    *        The .uuid of the ABViewPage/ABViewTab we are to swtich to.
    *
    */
   changePage(dv, rowItem, page) {
      let rowId = rowItem?.row ?? null;

      // Set cursor to data view
      if (dv) {
         dv.setCursor(rowId);
      }

      // Pass settings to link page module
      // console.error("!!!! TODO: implement linkPageHelper() !!!!");
      if (this.linkPage) {
         this.linkPage.changePage(page, rowId);
      }

      super.changePage(page);
   }

   columnConfig(headers = []) {
      this.settings.columnConfig = headers;
   }
   /**
    * @method datacollectionLoad()
    * Assign an ABDataCollection to this component to use instead of any
    * provided .dataviewID in our settings.
    * NOTE: this primarily happens in the ABDesigner's Object Workspace.
    * @param {ABDataCollection} dc
    */
   datacollectionLoad(dc) {
      var oldDC = this.datacollection;
      this.datacollection = dc;

      var CurrentObject = dc?.datasource;
      var $DataTable = this.getDataTable();
      if ($DataTable) {
         // preventing too many handlers
         if (!this.__handler_dc_busy) {
            this.__handler_dc_busy = () => {
               this.busy();
            };

            this.__handler_dc_ready = () => {
               this.ready();
            };

            this.__handler_dc_loadData = () => {
               if (
                  $DataTable.config.view == "treetable" &&
                  CurrentObject &&
                  !CurrentObject.isGroup
               ) {
                  $DataTable.clearAll();
                  $DataTable.parse(dc.getData());

                  this.grouping();
                  this.ready();
               }
            };
         }

         if (oldDC) {
            // remove our listeners from the previous DC
            oldDC.removeListener("initializingData", this.__handler_dc_busy);
            oldDC.removeListener("initializedData", this.__handler_dc_ready);
            oldDC.removeListener("loadData", this.__handler_dc_loadData);
         }

         if (dc) {
            if (dc.datacollectionLink && dc.fieldLink) {
               dc.bind($DataTable, dc.datacollectionLink, dc.fieldLink);
            } else {
               dc.bind($DataTable);
            }
            // making sure we only have 1 registered listener on this dc
            dc.removeListener("initializingData", this.__handler_dc_busy);
            dc.on("initializingData", this.__handler_dc_busy);
            dc.removeListener("initializedData", this.__handler_dc_ready);
            dc.on("initializedData", this.__handler_dc_ready);
            dc.removeListener("loadData", this.__handler_dc_loadData);
            dc.on("loadData", this.__handler_dc_loadData);
            this.grouping();
         } else {
            $DataTable.unbind();
         }

         // Be sure to pass on our CurrentObject to our dependent components.
         if (CurrentObject) {
            this.viewGrid.filterHelper.objectLoad(CurrentObject);
            this.PopupMassUpdateComponent.objectLoad(
               CurrentObject,
               this.getDataTable()
            );
            this.PopupSortDataTableComponent.objectLoad(CurrentObject);

            this.PopupExport.objectLoad(CurrentObject);
            this.PopupExport.dataCollectionLoad(dc);
            this.PopupExport.setGridComponent(this.getDataTable());
            this.PopupExport.setHiddenFields(this.settings.hiddenFields);
            this.PopupExport.setFilename(this.viewGrid.label);
         }
      }
   }

   /**
    * @function enableUpdateDelete
    *
    * disable the update or delete buttons in the toolbar if there no items selected
    * we will make this externally accessible so we can call it from within the datatable component
    */
   disableUpdateDelete() {
      $$(this.ids.buttonMassUpdate)?.disable();
      $$(this.ids.buttonDeleteSelected)?.disable();
      // externally indicate that no rows are selected
      this.emit("selection.cleared");
   }

   /**
    * @function enableUpdateDelete
    *
    * enable the update or delete buttons in the toolbar if there are any items selected
    * we will make this externally accessible so we can call it from within the datatable component
    */
   enableUpdateDelete() {
      $$(this.ids.buttonMassUpdate)?.enable();
      $$(this.ids.buttonDeleteSelected)?.enable();
      // externally indicate that a row has been selected
      this.emit("selection");
   }

   freezeDeleteColumn() {
      // we are going to always freeze the delete column if the datatable
      // is wider than the container so it is easy to get to
      return this.getDataTable().define("rightSplit", this.columnSplitRight);
   }

   /**
    * @method getDataTable()
    * return the webix grid component.
    * @return {webix.grid}
    */
   getDataTable() {
      return $$(this.ids.datatable);
   }

   /**
    * @method getLastColumn
    * return the last column of a datagrid that is resizeable
    */
   getLastColumn() {
      var DataTable = this.getDataTable();
      var lastColumn = {};

      // Loop through each columns config to find out if it is in the split 1 region and set it as the last item...then it will be overwritten by next in line
      DataTable.eachColumn(function (columnId) {
         var columnConfig = DataTable.getColumnConfig(columnId);
         if (columnConfig.split == 1) lastColumn = columnConfig;
      });

      return lastColumn;
   }

   /**
    * @method grouping()
    * perform any grouping operations
    */
   grouping() {
      if (!this.settings.groupBy) return;

      let $treetable = this.getDataTable();

      // map: {
      //     votes:["votes", "sum"],
      //     title:["year"]
      // }
      let baseGroupMap = {};
      let CurrentObject = this.datacollection.datasource;
      CurrentObject.fields().forEach((f) => {
         switch (f.key) {
            case "number":
               baseGroupMap[f.columnName] = [f.columnName, "sum"];
               break;
            case "calculate":
            case "formula":
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  function (prop, listData) {
                     if (!listData) return 0;

                     let sum = 0;

                     listData.forEach((r) => {
                        sum += f.format(r) * 1;
                     });

                     return sum;
                  },
               ];
               break;
            case "connectObject":
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  function (prop, listData) {
                     if (!listData || !listData.length) return 0;

                     let count = 0;

                     listData.forEach((r) => {
                        var valRelation = r[f.relationName()];

                        // array
                        if (valRelation && valRelation.length != null)
                           count += valRelation.length;
                        // object
                        else if (valRelation) count += 1;
                     });

                     return count;
                  },
               ];
               break;
            default:
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  function (prop, listData) {
                     if (!listData || !listData.length) return 0;

                     let count = 0;

                     listData.forEach((r) => {
                        var val = prop(r);

                        // count only exists data
                        if (val) {
                           count += 1;
                        }
                     });

                     return count;
                  },
               ];
               break;
         }
      });

      // set group definition
      // DataTable.define("scheme", {
      //    $group: {
      //       by: settings.groupBy,
      //       map: groupMap
      //    }
      // });

      // NOTE: https://snippet.webix.com/e3a2bf60
      let groupBys = (this.settings.groupBy || "")
         .split(",")
         .map((g) => g.trim());
      // Reverse the array NOTE: call .group from child to root
      groupBys = groupBys.reverse();
      groupBys.forEach((colName, gIndex) => {
         let by;
         let groupMap = this.AB.cloneDeep(baseGroupMap);

         // Root
         if (gIndex == groupBys.length - 1) {
            by = colName;
         }
         // Sub groups
         else {
            by = (row) => {
               let byValue = row[colName];
               for (let i = gIndex + 1; i < groupBys.length; i++) {
                  byValue = `${row[groupBys[i]]} - ${byValue}`;
               }
               return byValue;
            };

            // remove parent group data
            groupBys.forEach((gColName) => {
               if (gColName != colName) groupMap[gColName] = [gColName];
            });
         }

         $treetable.data.group({
            by: by,
            map: groupMap,
         });
      });
   }

   hideHeader() {
      var DataTable = this.getDataTable();
      DataTable.define("header", false);
      DataTable.refresh();
   }

   /**
    * @function onAfterColumnDrop
    * When an editor drops a column to save a new column order
    * @param {string} sourceId
    *        the columnName of the item dragged
    * @param {string} targetId
    *        the columnName of the item dropped on
    * @param {event} event
    */
   async onAfterColumnDrop(sourceId, targetId, event) {
      var DataTable = this.getDataTable();
      let CurrentObject = this.datacollection.datasource;
      var settings = this.settings;
      var columnConfig = this.localSettings();

      // Reorder our current columnConfig
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position
      for (var i = 0; i < columnConfig.length; i++) {
         if (columnConfig[i].id == sourceId) {
            itemMoved = columnConfig[i];
            columnConfig.splice(i, 1);
            oPos = i;
            break;
         }
      }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (var j = 0; j < columnConfig.length; j++) {
         if (columnConfig[j].id == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) {
               j++;
            }
            columnConfig.splice(j, 0, itemMoved);
            break;
         }
      }

      // special case: dropped on end and need to update .fillspace
      // if (j == columnConfig.length - 1) {
      //    if (columnConfig[j - 1].fillspace) {
      //       columnConfig[j - 1].fillspace = false;
      //       columnConfig[j].fillspace = true;
      //    }
      // }

      // if we allow local changes
      this.localSettings(columnConfig);
      if (settings.saveLocal) {
         this.localSettingsSave();
      }

      // Now emit this event, in case an external object is wanting to
      // respond to this: ABDesigner.objectBuilder, Interface  Designer,
      // we send back an array[ ABField.id, ...] in the order we have
      // them.
      this.emit(
         "column.order",
         columnConfig.map((c) => c.fieldID)
      );

      this.refreshHeader();

      // CurrentObject.fieldReorder(sourceId, targetId)
      //    .then(() => {
      //       // reset each column after a drop so we do not have multiple fillspace and minWidth settings
      //       var editiable = settings.isEditable;
      //       if (DataTable.config.accessLevel < 2) {
      //          editiable = false;
      //       }
      //       var columnHeaders = CurrentObject.columnHeaders(true, editiable);
      //       columnHeaders.forEach(function (col) {
      //          if (col.id == sourceId && col.fillspace == true) {
      //             columnHeader.fillspace = false;
      //             columnHeader.minWidth = columnHeader.width;
      //          }
      //       });

      //       _logic.callbacks.onColumnOrderChange(CurrentObject);
      //       // freeze columns:
      //       let frozenColumnID =
      //          settings.frozenColumnID != null
      //             ? settings.frozenColumnID
      //             : CurrentObject.workspaceFrozenColumnID;
      //       if (frozenColumnID != "") {
      //          DataTable.define(
      //             "leftSplit",
      //             DataTable.getColumnIndex(frozenColumnID) + columnSplitLeft
      //          );
      //       } else {
      //          DataTable.define("leftSplit", columnSplitLeft);
      //       }
      //       _logic.freezeDeleteColumn();
      //       DataTable.refreshColumns();
      //    })
      //    .catch((err) => {
      //       OP.Error.log("Error saving new column order:", {
      //          error: err,
      //       });
      //    });
   }

   /**
    * @function onAfterEditStop
    * When an editor is finished.
    * @param {json} state
    * @param {} editor
    * @param {} ignoreUpdate
    * @return
    */
   async onAfterEditStop(state, editor, ignoreUpdate) {
      // state:   {value: "new value", old: "old value"}
      // editor:  { column:"columnName", row:ID, value:'value', getInputNode:fn(), config:{}, focus: fn(), getValue: fn(), setValue: function, getInputNode: function, render: function…}

      var DataTable = this.getDataTable();

      // if you don't edit an empty cell we just need to move on
      if (
         (state.old == null && state.value === "") ||
         (state.old === "" && state.value === "")
      ) {
         DataTable.clearSelection();
         return false;
      }

      if (editor.config) {
         switch (editor.config.editor) {
            case "number":
               state.value = parseFloat(state.value);
               break;
            case "datetime":
               state.value = state.value.getTime();
               if (state && state.old && state.old.getTime)
                  state.old = state.old.getTime();
               break;
            default:
            // code block
         }
      }

      if (state.value != state.old) {
         var item = DataTable.getItem(editor.row);
         item[editor.column] = state.value;

         DataTable.removeCellCss(item.id, editor.column, "webix_invalid");
         DataTable.removeCellCss(item.id, editor.column, "webix_invalid_cell");

         var CurrentObject = this.datacollection.datasource;
         var validator = CurrentObject.isValidData(item);
         if (validator.pass()) {
            //// Question: do we submit full item updates?  or just patches?
            // IF Patch:
            // var patch = {};
            // patch.id = item.id;
            // patch[editor.column] = item[editor.column];
            // await CurrentObject.model().update(item.id, patch)

            try {
               await CurrentObject.model().update(item.id, item);
               if (DataTable.exists(editor.row)) {
                  DataTable.updateItem(editor.row, item);
                  DataTable.clearSelection();
                  DataTable.refresh(editor.row);
               }
            } catch (err) {
               this.AB.notify.developer(err, {
                  context: "ABViewGrid:onAfterEditStop(): Error saving item",
                  item,
                  editor,
                  state,
                  object: CurrentObject.toObj(),
               });

               DataTable.clearSelection();
               if (
                  this.AB.Validation.isGridValidationError(
                     err,
                     editor.row,
                     DataTable
                  )
               ) {
                  // Do we reset the value?
                  // item[editor.column] = state.old;
                  // DataTable.updateItem(editor.row, item);
               } else {
                  // this was some other Error!
               }
            }
            // CurrentObject.model()
            //    .update(item.id, item)
            //    .then(() => {
            //       if (DataTable.exists(editor.row)) {
            //          DataTable.updateItem(editor.row, item);
            //          DataTable.clearSelection();
            //          DataTable.refresh(editor.row);
            //       }
            //    })
            //    .catch((err) => {
            //       OP.Error.log("Error saving item:", {
            //          error: err
            //       });

            //       DataTable.clearSelection();
            //       if (
            //          OP.Validation.isGridValidationError(
            //             err,
            //             editor.row,
            //             DataTable
            //          )
            //       ) {
            //          // Do we reset the value?
            //          // item[editor.column] = state.old;
            //          // DataTable.updateItem(editor.row, item);
            //       } else {
            //          // this was some other Error!
            //       }
            //    });
         } else {
            validator.updateGrid(editor.row, DataTable);
         }
      } else {
         DataTable.clearSelection();
      }
      return false;

      // var item = $$(self.webixUiId.objectDatatable).getItem(editor.row);

      // self.updateRowData(state, editor, ignoreUpdate)
      //    .fail(function (err) { // Cached
      //       item[editor.column] = state.old;
      //       $$(self.webixUiId.objectDatatable).updateItem(editor.row, item);
      //       $$(self.webixUiId.objectDatatable).refresh(editor.row);

      //       // TODO : Message

      //       $$(self.webixUiId.objectDatatable).hideProgress();
      //    })
      //    .then(function (result) {
      //       if (item) {
      //          item[editor.column] = state.value;

      //          if (result && result.constructor.name === 'Cached' && result.isUnsync())
      //             item.isUnsync = true;

      //          $$(self.webixUiId.objectDatatable).updateItem(editor.row, item);
      //       }

      //       // TODO : Message

      //       $$(self.webixUiId.objectDatatable).hideProgress();
      //    });
   }

   /**
    * @function onAfterSelect
    * This is when a user clicks on a cell.  We use the onAfterSelect to
    * trigger a normal .editCell() if there isn't a custom editor for this field.
    * @param {json} data webix cell data
    * @return
    */
   onAfterSelect(data /*, preserve */) {
      // data: {row: 1, column: "name", id: "1_name", toString: function}
      // data.row: ABObject.id
      // data.column => columnName of the field

      // Normal update data
      this.getDataTable()?.editCell(data.row, data.column);
   }

   /**
    * @function onColumnResizeResize
    * This is when a user adjusts the size of a column
    * @param {} columnName
    * @param {int} newWidth
    * @param {int} oldWidth
    * @param {} user_action
    * @return
    */
   async onColumnResize(columnName, newWidth, oldWidth, user_action) {
      // update the settings

      var requireRefresh = false;
      if (newWidth < 30) {
         newWidth = 30;
         requireRefresh = true;
         webix.message({
            type: "info",
            text: this.AB.Multilingual.label("minimum column width is {0}", [
               30,
            ]),
            expire: 1000,
         });
      }

      var localSettings = this.localSettings();
      if (localSettings) {
         var header = localSettings.find((h) => h.id == columnName);
         if (header) {
            header.width = newWidth;
            delete header.adjust;
         }
      }

      this.localSettings(localSettings);
      if (this.settings.saveLocal) {
         this.localSettingsSave();
         // for (const item in GridSettings) {
         //    GridSettings[item].forEach((item) => {
         //       // we cannot include field info because of the cicular structure
         //       if (item?.footer?.field) {
         //          delete item.footer.field;
         //       }
         //    });
         // }
         // await this.AB.Storage.set(KEY_STORAGE_SETTINGS, GridSettings);
      }

      // refresh the display
      if (requireRefresh) {
         this.refreshHeader();
      }
      this.freezeDeleteColumn();

      // this.getDataTable().refreshColumns();

      // TODO: allow external app to respond in special cases:
      // eg: ABDesigner object workspace, interface builder, etc...
      this.emit("column.resize", columnName, newWidth, oldWidth);
   }

   /**
    * @method onHeaderClick
    * process the user clicking on the header for one of our columns.
    */
   onHeaderClick(id, e, node) {
      if (this.skippableColumns.indexOf(id.column) != -1) return false;

      // save our EditNode & EditField:
      // this.EditNode = node;

      var EditField = this.datacollection.datasource.fields(
         (f) => f.columnName == id.column
      )[0];
      // if (this.EditField) {
      //    // show the popup
      //    PopupHeaderEditComponent.show(node, this.EditField);
      // }

      this.emit("column.header.clicked", node, EditField);
      return false;
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      super.onShow();

      // make sure our grid is properly .adjust()ed to the screen.
      this.getDataTable()?.adjust();

      var dv = this.datacollection;
      if (dv) {
         this.eventAdd({
            emitter: dv,
            eventName: "changeCursor",
            listener: this.handler_select,
         });
      }
   }

   /**
    * @method ready()
    * Indicate that our datatable is currently ready for operation.
    */
   ready() {
      this.getDataTable()?.hideProgress?.();
   }

   /**
    * @function refreshHeader()
    *
    * refresh the header for the table apart from the refresh() command
    * @param {bool} ignoreLocal
    *        Should we ignore our local settings and build directly from
    *        our config settings?
    */
   refreshHeader(ignoreLocal = false) {
      // columnSplitRight = 0;
      // wait until we have an Object defined:
      var CurrentObject = this.datacollection.datasource;
      if (!CurrentObject) return;

      var ids = this.ids;
      var DataTable = $$(ids.datatable);
      if (!DataTable) return;

      var accessLevel = DataTable.config.accessLevel;
      DataTable.define("leftSplit", 0);
      DataTable.define("rightSplit", 0);

      let rowHeight = 0;
      CurrentObject.imageFields().forEach((image) => {
         if (
            image.settings.useHeight &&
            image.settings.imageHeight > rowHeight
         ) {
            rowHeight = image.settings.imageHeight;
         }
      });
      if (rowHeight) {
         DataTable.define("rowHeight", rowHeight);
      }

      // DataTable.clearAll();

      var settings = this.settings;
      var editable = settings.isEditable;
      if (DataTable.config.accessLevel < 2) {
         editable = false;
      }

      //// update DataTable structure:
      // get column list from our local settings
      var objColumnHeaders = CurrentObject.columnHeaders(
         true,
         editable,
         // TRANSITION: moving these from .columnHeaders() to here:
         [], //settings.summaryColumns,
         [], //settings.countColumns,
         [] //settings.hiddenFields
      );
      var columnHeaders = this.localSettings();
      if (!columnHeaders || ignoreLocal) {
         // if that is empty, pull from our settings.columnConfig
         columnHeaders = this.AB.cloneDeep(this.settings.columnConfig);
      }
      if (columnHeaders.length == 0) {
         // if that is empty for some reason, rebuild from our CurrentObject

         columnHeaders = objColumnHeaders;
      }

      // sanity check:
      // columnHeaders can't contain a column that doesn't exist in objColumHeaders:
      // (eg: a field might have been removed but localStorage doesn't know that )
      var objColumnHeaderIDs = objColumnHeaders.map((h) => h.fieldID);
      columnHeaders = columnHeaders.filter(
         (c) => objColumnHeaderIDs.indexOf(c.fieldID) > -1
      );

      // default our columnConfig values to our columnHeaders:
      columnHeaders.forEach((c) => {
         // we want to overwrite our default settings with anything stored
         // in local storage
         var origCol = objColumnHeaders.find((h) => h.fieldID == c.fieldID);

         // none of our functions can be stored in localStorage, so scan
         // the original column and attach any template functions to our
         // stashed copy.
         // also the suggest for selects and connected fields may contain a
         // function so go ahead and copy the original suggest to the column
         Object.keys(origCol).forEach((k) => {
            if (typeof origCol[k] == "function" || k == "suggest") {
               c[k] = origCol[k];
            }
         });

         var f = CurrentObject.fieldByID(c.fieldID);
         if (!f) return;

         // if it's a hidden field:
         if (settings.hiddenFields.indexOf(f.columnName) > -1) {
            c.hidden = true;
         }
         // add summary footer:
         if (settings.summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula") {
               c.footer = { content: "totalColumn", field: f };
            } else {
               c.footer = { content: "summColumn" };
            }
         }
         // or add the count footer
         else if (settings.countColumns.indexOf(f.id) > -1)
            c.footer = { content: "countColumn" };
      });

      var localSettings = this.localSettings();
      if (!localSettings || ignoreLocal) {
         this.localSettings(columnHeaders);
         localSettings = columnHeaders;
      }
      columnHeaders = this.AB.cloneDeep(localSettings);

      var fieldValidations = [];
      var rulePops = [];

      columnHeaders.forEach((col) => {
         col.fillspace = false;

         // parse the rules because they were stored as a string
         // check if rules are still a string...if so lets parse them
         if (col.validationRules) {
            if (typeof col.validationRules === "string") {
               col.validationRules = JSON.parse(col.validationRules);
            }

            if (col.validationRules.length) {
               var validationUI = [];
               // there could be more than one so lets loop through and build the UI
               col.validationRules.forEach((rule) => {
                  var Filter = this.AB.filterComplexNew(
                     col.id /*+ "_" + webix.uid()*/
                  );
                  // add the new ui to an array so we can add them all at the same time
                  validationUI.push(Filter.ui);
                  // store the filter's info so we can assign values and settings after the ui is rendered
                  fieldValidations.push({
                     filter: Filter,
                     view: Filter.ids.querybuilder,
                     columnName: col.id,
                     validationRules: rule.rules,
                     invalidMessage: rule.invalidMessage,
                  });
               });
               // create a unique view id for popup
               var popUpId = ids.rules + "_" + col.id; /* + "_" + webix.uid() */
               // store the popup ids so we can remove the later
               rulePops.push(popUpId);
               // add the popup to the UI but don't show it
               webix.ui({
                  view: "popup",
                  css: "ab-rules-popup",
                  id: popUpId,
                  body: {
                     rows: validationUI,
                  },
               });
            }
         }

         // group header
         if (
            settings.groupBy &&
            (settings.groupBy || "").indexOf(col.id) > -1
         ) {
            var groupField = CurrentObject.fieldByID(col.fieldID);
            if (groupField) {
               col.template = (obj, common) => {
                  // return common.treetable(obj, common) + obj.value;
                  if (obj.$group) {
                     let rowData = this.AB.cloneDeep(obj);
                     rowData[groupField.columnName] = rowData.value;

                     return (
                        common.treetable(obj, common) +
                        groupField.format(rowData)
                     );
                  } else return groupField.format(obj);
               };
            }
         }
      });

      if (fieldValidations.length) {
         // we need to store the rules for use later so lets build a container array
         var complexValidations = [];
         fieldValidations.forEach((f) => {
            // init each ui to have the properties (app and fields) of the object we are editing
            // f.filter.applicationLoad(CurrentObject.application);
            f.filter.fieldsLoad(CurrentObject.fields());
            // now we can set the value because the fields are properly initialized
            f.filter.setValue(f.validationRules);
            // if there are validation rules present we need to store them in a lookup hash
            // so multiple rules can be stored on a single field
            if (!Array.isArray(complexValidations[f.columnName]))
               complexValidations[f.columnName] = [];

            // now we can push the rules into the hash
            complexValidations[f.columnName].push({
               filters: $$(f.view).getFilterHelper(),
               values: DataTable.getSelectedItem(),
               invalidMessage: f.invalidMessage,
            });
         });
         var rules = {};

         // store the rules in a data param to be used later
         DataTable.$view.complexValidations = complexValidations;
         // use the lookup to build the validation rules
         Object.keys(complexValidations).forEach(function (key) {
            rules[key] = function (value, data) {
               // default valid is true
               var isValid = true;
               var invalidMessage = "";
               DataTable.$view.complexValidations[key].forEach((filter) => {
                  // convert rowData from { colName : data } to { id : data }
                  var newData = {};
                  (CurrentObject.fields() || []).forEach((field) => {
                     newData[field.id] = data[field.columnName];
                  });
                  // for the case of "this_object" conditions:
                  if (data.uuid) {
                     newData["this_object"] = data.uuid;
                  }

                  // use helper funtion to check if valid
                  var ruleValid = filter.filters(newData);
                  // if invalid we need to tell the field
                  if (ruleValid == false) {
                     isValid = false;
                     invalidMessage = filter.invalidMessage;
                  }
               });
               if (isValid == false) {
                  // we also need to define an error message
                  webix.message({
                     type: "error",
                     text: invalidMessage,
                  });
               }
               return isValid;
            };
         });
         // define validation rules
         DataTable.define("rules", rules);
         // store the array of view ids on the webix object so we can get it later
         DataTable.config.rulePops = rulePops;
         DataTable.refresh();
      } else {
         // check if the previous datatable had rule popups and remove them
         if (DataTable.config.rulePops) {
            DataTable.config.rulePops.forEach((popup) => {
               if ($$(popup)) $$(popup).destructor();
            });
         }
         // remove any validation rules from the previous table
         DataTable.define("rules", {});
         DataTable.refresh();
      }

      var addedColumns = [];
      // {array} the .id of the columnHeaders we add based upon our settings.
      // this will help us pick the lastColumn that is part of the
      // object.

      if (settings.labelAsField) {
         // console.log(CurrentObject);
         columnHeaders.unshift({
            id: "appbuilder_label_field",
            header: "Label",
            fillspace: true,
            template: function (obj) {
               return CurrentObject.displayData(obj);
            },
            // css: { 'text-align': 'center' }
         });
         addedColumns.push("appbuilder_label_field");
      }

      if (settings.massUpdate && accessLevel == 2) {
         columnHeaders.unshift({
            id: "appbuilder_select_item",
            header: { content: "masterCheckbox", contentId: "mch" },
            width: 40,
            template: "<div class='singleSelect'>{common.checkbox()}</div>",
            css: { "text-align": "center" },
         });
         this.columnSplitLeft = 1;
         addedColumns.push("appbuilder_select_item");
      } else {
         this.columnSplitLeft = 0;
      }
      if (settings.detailsPage != "" && !settings.hideButtons) {
         columnHeaders.push({
            id: "appbuilder_view_detail",
            header: "",
            width: 40,
            template: function (obj, common) {
               return "<div class='detailsView'><span class='webix_icon fa fa-eye'></span></div>";
            },
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_detail");
      }
      if (settings.trackView != 0 && accessLevel == 2) {
         columnHeaders.push({
            id: "appbuilder_view_track",
            header: "",
            width: 40,
            template:
               "<div class='track'><span class='track fa fa-history'></span></div>",
            css: { "text-align": "center", cursor: "pointer" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_track");
      }
      if (
         settings.editPage != "" &&
         !settings.hideButtons &&
         accessLevel == 2
      ) {
         columnHeaders.push({
            id: "appbuilder_view_edit",
            header: "",
            width: 40,
            template: "<div class='edit'>{common.editIcon()}</div>",
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_edit");
      }
      if (settings.allowDelete && accessLevel == 2) {
         columnHeaders.push({
            id: "appbuilder_trash",
            header: "",
            width: 40,
            template: "<div class='trash'>{common.trashIcon()}</div>",
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_trash");
      }

      // find our last displayed column (that isn't one we added);
      var lastCol = null;
      for (var i = columnHeaders.length - 1; i >= 0; i--) {
         if (!lastCol) {
            var col = columnHeaders[i];
            if (!col.hidden && addedColumns.indexOf(col.id) == -1) {
               lastCol = col;
               break;
            }
         }
      }

      if (lastCol) {
         lastCol.fillspace = true;
         lastCol.minWidth = lastCol.width;
         lastCol.width = 150; // set a width for last column but by default it will fill the available space or use the minWidth to take up more
      }

      DataTable.refreshColumns(columnHeaders);

      // the addedColumns represent the additional icons that can be added.
      this.columnSplitRight = addedColumns.length;
      // the .massUpdate gets added to Left so don't include that in split right:
      if (addedColumns.indexOf("appbuilder_select_item") > -1)
         this.columnSplitRight -= 1;
      // .columnSplitRight can't be < 0
      if (this.columnSplitRight < 0) this.columnSplitRight = 0;

      // freeze columns:
      let frozenColumnID = settings.frozenColumnID;
      if (frozenColumnID != "") {
         DataTable.define(
            "leftSplit",
            DataTable.getColumnIndex(frozenColumnID) + 1
         );
      } else {
         DataTable.define("leftSplit", this.columnSplitLeft);
      }
      this.freezeDeleteColumn();
      DataTable.refreshColumns();

      // }
   }

   /**
    * localSettingsSave()
    * Persist our current working copy of our GridSettings to localStorage.
    * @return {Promise}
    */
   async localSettingsSave() {
      var savedLocalSettings =
         (await this.AB.Storage.get(KEY_STORAGE_SETTINGS)) || {};

      savedLocalSettings[this.settingsID()] = GridSettings[this.settingsID()]
         ? GridSettings[this.settingsID()]
         : [];

      for (const item in savedLocalSettings) {
         savedLocalSettings[item].forEach((item) => {
            // we cannot include field info because of the cicular structure
            if (item?.footer?.field) {
               delete item.footer.field;
            }
         });
      }

      await this.AB.Storage.set(KEY_STORAGE_SETTINGS, savedLocalSettings);
   }

   /**
    * @method localSettings()
    * An interface method to handle get/set operations on our local GridSettings
    * storage.
    * .localStorage() : a getter to return the current value
    * .localStorage(value) : a setter to save value as our current value.
    * @param {various} value
    *        the value to set to our settings.
    * @return {various}
    */
   localSettings(value = null) {
      if (value) {
         GridSettings[this.settingsID()] = value;
      } else {
         return GridSettings[this.settingsID()];
      }
   }

   /**
    * @method selectRow()
    * Select the grid row that correspondes to the provided rowData.
    * @param {json} rowData
    *        A key=>value hash of data that matches an entry in the grid.
    *        rowData.id should match an existing entry.
    */
   selectRow(rowData) {
      let $DataTable = this.getDataTable();
      if (!$DataTable) return;

      if (rowData == null) $DataTable.unselect();
      else if (rowData?.id && $DataTable.exists(rowData.id))
         $DataTable.select(rowData.id, false);
      else $DataTable.select(null, false);
   }

   /**
    * @method settingsID()
    * return the unique key for this Grid + object combo to store data
    * in our localStorage.
    * @return {string}
    */
   settingsID() {
      var CurrentObject = this.datacollection.datasource;
      return `${this.id}-${CurrentObject ? CurrentObject.id : "0"}`;
   }

   /**
    * @method toggleTab()
    * recursively toggle tabs into view once a user chooses a detail/edit view
    * to display.
    * @param {ABView.id} parentTab
    * @param {webix.view} wb
    */
   toggleTab(parentTab, wb) {
      // find the tab
      var tab = wb.getTopParentView().queryView({ id: parentTab });
      // if we didn't pass and id we may have passed a domNode
      if (tab == null) {
         tab = $$(parentTab);
      }

      if (tab == null) return;

      // set the tabbar to to the tab
      var tabbar = tab.getParentView().getParentView();

      if (tabbar == null) return;

      if (tabbar.setValue) {
         // if we have reached the top we won't have a tab
         tabbar.setValue(parentTab);
      }

      // find if it is in a multiview of a tab
      var nextTab = tabbar.queryView({ view: "scrollview" }, "parent");
      // if so then do this again
      if (nextTab) {
         this.toggleTab(nextTab, wb);
      }
   }

   toggleUpdateDelete() {
      var DataTable = this.getDataTable();
      var checkedItems = 0;
      DataTable.data.each(function (obj) {
         if (
            typeof obj != "undefined" &&
            obj.hasOwnProperty("appbuilder_select_item") &&
            obj.appbuilder_select_item == 1
         ) {
            checkedItems++;
         }
      });
      if (checkedItems > 0) {
         this.enableUpdateDelete();
      } else {
         this.disableUpdateDelete();
      }
   }

   toolbarDeleteSelected($view) {
      var DataTable = this.getDataTable();
      let CurrentObject = this.datacollection.datasource;
      var deleteTasks = [];
      DataTable.data.each(function (row) {
         if (
            typeof row != "undefined" &&
            // row.hasOwnProperty("appbuilder_select_item") &&
            Object.prototype.hasOwnProperty.call(
               row,
               "appbuilder_select_item"
            ) &&
            row.appbuilder_select_item == 1
         ) {
            // NOTE: store a fn() to run later.
            deleteTasks.push(() => CurrentObject.model().delete(row.id));
         }
      });

      if (deleteTasks.length > 0) {
         webix.confirm({
            title: L("Delete Multiple Records"),
            text: L("Are you sure you want to delete the selected records?"),
            callback: async (result) => {
               if (result) {
                  // Now run those functions
                  await Promise.all(deleteTasks.map((t) => t()));

                  // Anything we need to do after we are done.
                  this.disableUpdateDelete();
               }
            },
         });
      } else {
         webix.alert({
            title: L("No Records Selected"),
            text: L(
               "You need to select at least one record...did you drink your coffee today?"
            ),
         });
      }
   }

   toolbarFilter($view) {
      this.viewGrid.filterHelper.showPopup($view);
   }

   toolbarSort($view) {
      this.PopupSortDataTableComponent.show($view);
   }

   toolbarExport($view) {
      this.PopupExport.show($view);
   }

   toolbarMassUpdate($view) {
      this.PopupMassUpdateComponent.show($view);
   }

   /**
    * @function toolTip()
    *
    * Retrieve the items toolTip
    */
   toolTip(obj, common) {
      let CurrentObject = this.datacollection.datasource;
      var imageFieldColNames = CurrentObject.imageFields().map(
         (f) => f.columnName
      );
      var tip = "";
      var columnName = common.column.id.replace(" ", "");
      if (Array.isArray(obj[columnName])) {
         obj[columnName].forEach(function (o) {
            if (o.text) tip += o.text + "<br/>";
         });
      } else if (typeof obj[columnName + "__relation"] != "undefined") {
         var relationData = obj[columnName + "__relation"];
         if (!Array.isArray(relationData)) relationData = [relationData];

         (relationData || []).forEach(function (o) {
            if (o) tip += o.text + "<br/>";
         });
      } else if (
         typeof obj[columnName + "__relation"] != "undefined" &&
         typeof obj[columnName] == "number"
      ) {
         tip = obj[columnName + "__relation"].text;
      } else if (imageFieldColNames.indexOf(columnName) != -1) {
         if (obj[columnName] == null) {
            return "";
         } else {
            // TODO: we need to get this URL from the ABFieldImage object!
            tip = `<img style='max-width: 500px; max-height: 500px;' src='/file/${obj[columnName]}' />`;
         }
      } else if (common.column.editor == "date") {
         tip = common.column.format(obj[columnName]);
      } else if (common.column.editor == "richselect") {
         CurrentObject.fields().forEach(function (f) {
            if (f.columnName == columnName) {
               if (f.settings.options) {
                  f.settings.options.forEach(function (o) {
                     if (o.id == obj[columnName]) {
                        tip = o.text;
                     }
                  });
               }
            }
         });
      } else {
         tip = obj[columnName];
      }
      if (tip == null) {
         return "";
      } else {
         return tip;
      }
   }

   /**
    * @function toolTipOnBeforeRender()
    *
    * Add visibility "hidden" to all tooltips before render so we can move to a new location without the visual jump
    */
   toolTipOnBeforeRender(node) {
      // var node = $$(ids.tooltip).getNode();
      node.style.visibility = "hidden";
   }

   /**
    * @function toolTipOnAfterRender()
    *
    * If the tooltip is displaying off the screen we want to try to reposition it for a better experience
    */
   toolTipOnAfterRender(node) {
      // var node = $$(ids.tooltip).getNode();
      if (node.firstChild != null && node.firstChild.nodeName == "IMG") {
         setTimeout(function () {
            var imgBottom = parseInt(node.style.top.replace("px", "")) + 500;
            var imgRight = parseInt(node.style.left.replace("px", "")) + 500;
            if (imgBottom > window.innerHeight) {
               var imgOffsetY = imgBottom - window.innerHeight;
               var newTop =
                  parseInt(node.style.top.replace("px", "")) - imgOffsetY;
               node.style.top = newTop + "px";
            }
            if (imgRight > window.innerWidth) {
               var imgOffsetX = imgRight - window.innerWidth;
               var newLeft =
                  parseInt(node.style.left.replace("px", "")) - imgOffsetX;
               node.style.left = newLeft + "px";
            }
            node.style.visibility = "visible";
         }, 250);
      } else {
         node.style.visibility = "visible";
      }
   }
}

class ABViewGrid extends ABViewGridCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // filter property
      this.filterHelper.fromSettings(this.settings.gridFilter);
   }

   //
   // Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   // editorComponent(App, mode) {
   //    var idBase = "ABViewGridEditorComponent";

   //    var DataTable = this.component(App, idBase);

   //    return {
   //       ui: DataTable.ui,
   //       logic: DataTable.logic,
   //       onShow: DataTable.onShow,

   //       init: () => {
   //          // remove id of the component in caching for refresh .bind of the data collection
   //          let dv = this.datacollection;
   //          if (dv) dv.removeComponent(DataTable.ui.id);

   //          DataTable.init();
   //       },
   //    };
   // }

   //
   // Property Editor
   //

   // static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
   //    var commonUI = super.propertyEditorDefaultElements(
   //       App,
   //       ids,
   //       _logic,
   //       ObjectDefaults
   //    );
   //    var L = App.Label;

   //    var idBase = "ABViewGridPropertyEditor";

   //    // initialize our popup editors with unique names so we don't overwrite the previous editor each time
   //    PopupHideFieldComponent = new ABPopupHideFields(App, idBase + "_hide");
   //    PopupFrozenColumnsComponent = new ABPopupFrozenColumns(
   //       App,
   //       idBase + "_freeze"
   //    );

   //    PopupSummaryColumnsComponent = new ABPopupSummaryColumns(
   //       App,
   //       idBase + "_summary"
   //    );
   //    PopupCountColumnsComponent = new ABPopupCountColumns(
   //       App,
   //       idBase + "_count"
   //    );

   //    PopupFilterProperty = ABViewPropertyFilterData.propertyComponent(
   //       App,
   //       idBase + "_gridfiltermenu"
   //    );
   //    this.linkPageComponent = ABViewPropertyLinkPage.propertyComponent(
   //       App,
   //       idBase + "_gridlinkpage"
   //    );

   //    let filter_property_popup = webix.ui({
   //       view: "window",
   //       modal: true,
   //       position: "center",
   //       resize: true,
   //       width: 700,
   //       height: 450,
   //       css: "ab-main-container",
   //       head: {
   //          view: "toolbar",
   //          cols: [
   //             {
   //                view: "label",
   //                label: L("ab.component.grid.filterMenu", "*Filter Menu"),
   //             },
   //          ],
   //       },
   //       body: PopupFilterProperty.ui,
   //    });

   //    _logic.newObject = () => {
   //       var currView = _logic.currentEditObject();
   //       currView.settings.objectWorkspace = {
   //          sortFields: [],
   //          filterConditions: [],
   //          frozenColumnID: "",
   //          hiddenFields: [],
   //          summaryColumns: [],
   //          countColumns: [],
   //       };
   //       currView.populatePopupEditors(currView);
   //    };

   //    // Open our popup editors when their settings button is clicked
   //    _logic.toolbarFieldsVisible = ($view) => {
   //       PopupHideFieldComponent.show($view, { pos: "top" });
   //    };

   //    _logic.toolbarFrozen = ($view) => {
   //       PopupFrozenColumnsComponent.show($view, { pos: "top" });
   //    };

   //    _logic.gridFilterMenuShow = () => {
   //       let currView = _logic.currentEditObject();

   //       // show filter popup
   //       filter_property_popup.show();
   //    };

   //    _logic.summaryColumns = ($view) => {
   //       PopupSummaryColumnsComponent.show($view, { pos: "top" });
   //    };

   //    _logic.countColumns = ($view) => {
   //       PopupCountColumnsComponent.show($view, { pos: "top" });
   //    };

   //    _logic.callbackHideFields = (settings) => {
   //       var currView = _logic.currentEditObject();

   //       currView.objectWorkspace = currView.objectWorkspace || {};
   //       currView.objectWorkspace.hiddenFields = settings;

   //       _logic.onChange();
   //    };

   //    _logic.callbackFrozenFields = (settings) => {
   //       var currView = _logic.currentEditObject();

   //       currView.objectWorkspace = currView.objectWorkspace || {};
   //       currView.objectWorkspace.frozenColumnID = settings || "";

   //       _logic.onChange();
   //    };

   //    _logic.callbackSaveWorkspace = (data) => {
   //       // when we make a change in the popups we want to make sure we save the new workspace to the properties to do so just fire an onChange event
   //       _logic.onChange();
   //    };

   //    _logic.gridFilterSave = () => {
   //       var currView = _logic.currentEditObject();
   //       // currView.settings.isFilterable = settings.filterOption == 1 ? true : false;

   //       // hide filter popup
   //       filter_property_popup.hide();

   //       // refresh settings
   //       this.propertyEditorValues(ids, currView);

   //       // trigger a save()
   //       this.propertyEditorSave(ids, currView);
   //    };

   //    _logic.gridFilterCancel = () => {
   //       // hide filter popup
   //       filter_property_popup.hide();
   //    };

   //    _logic.callbackSaveSummaryColumns = (data) => {
   //       var currObj = _logic.currentEditObject();
   //       currObj.settings.objectWorkspace.summaryColumns = data;

   //       // when we make a change in the popups we want to make sure we save the new workspace to the properties to do so just fire an onChange event
   //       _logic.onChange();
   //    };

   //    _logic.callbackSaveCountColumns = (data) => {
   //       var currObj = _logic.currentEditObject();
   //       currObj.settings.objectWorkspace.countColumns = data;

   //       // when we make a change in the popups we want to make sure we save the new workspace to the properties to do so just fire an onChange event
   //       _logic.onChange();
   //    };

   //    PopupHideFieldComponent.init({
   //       onChange: _logic.callbackHideFields, // be notified when there is a change in the hidden fields
   //    });

   //    PopupFrozenColumnsComponent.init({
   //       onChange: _logic.callbackFrozenFields, // be notified when there is a change in the hidden fields
   //    });

   //    PopupFilterProperty.init({
   //       onSave: _logic.gridFilterSave,
   //       onCancel: _logic.gridFilterCancel,
   //    });

   //    PopupSummaryColumnsComponent.init({
   //       onChange: _logic.callbackSaveSummaryColumns, // be notified when there is a change in the summary columns
   //    });

   //    PopupCountColumnsComponent.init({
   //       onChange: _logic.callbackSaveCountColumns, // be notified when there is a change in the count columns
   //    });

   //    var view = "button";
   //    // in addition to the common .label  values, we
   //    // ask for:
   //    return commonUI.concat([
   //       {
   //          view: "fieldset",
   //          label: L("ab.component.label.gridProperties", "*Grid Properties:"),
   //          labelWidth: App.config.labelWidthLarge,
   //          body: {
   //             type: "clean",
   //             padding: 10,
   //             rows: [
   //                {
   //                   view: "checkbox",
   //                   name: "isEditable",
   //                   labelRight: L(
   //                      "ab.component.label.isEditable",
   //                      "*User can edit in grid."
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //                {
   //                   view: "checkbox",
   //                   name: "massUpdate",
   //                   labelRight: L(
   //                      "ab.component.label.massUpdate",
   //                      "*User can edit multiple items at one time."
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //                {
   //                   view: "checkbox",
   //                   name: "allowDelete",
   //                   labelRight: L(
   //                      "ab.component.label.allowDelete",
   //                      "*User can delete records."
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //                {
   //                   view: "checkbox",
   //                   name: "isSortable",
   //                   labelRight: L(
   //                      "ab.component.label.isSortable",
   //                      "*User can sort records."
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //                {
   //                   view: "checkbox",
   //                   name: "isExportable",
   //                   labelRight: L(
   //                      "ab.component.label.isExportable",
   //                      "*User can export."
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //             ],
   //          },
   //       },
   //       {
   //          view: "fieldset",
   //          label: L("ab.component.label.dataSource", "*Grid Data:"),
   //          labelWidth: App.config.labelWidthLarge,
   //          body: {
   //             type: "clean",
   //             padding: 10,
   //             rows: [
   //                {
   //                   view: "select",
   //                   name: "datacollection",
   //                   label: L("ab.component.label.dataSource", "*Object:"),
   //                   labelWidth: App.config.labelWidthLarge,
   //                   on: {
   //                      onChange: (newv, oldv) => {
   //                         if (newv != oldv) {
   //                            $$(ids.detailsPage).setValue("");
   //                            $$(ids.editPage).setValue("");

   //                            let editingGrid = _logic.currentEditObject();
   //                            let currDC = editingGrid.AB.datacollections(
   //                               (dc) => dc.id == newv
   //                            )[0];
   //                            // disallow edit data of query
   //                            if (currDC && currDC.sourceType == "query") {
   //                               $$(ids.isEditable).setValue(false);
   //                               $$(ids.massUpdate).setValue(false);
   //                               $$(ids.allowDelete).setValue(false);
   //                               $$(ids.isEditable).disable();
   //                               $$(ids.massUpdate).disable();
   //                               $$(ids.allowDelete).disable();
   //                            } else {
   //                               $$(ids.isEditable).enable();
   //                               $$(ids.massUpdate).enable();
   //                               $$(ids.allowDelete).enable();
   //                            }
   //                         }
   //                      },
   //                   },
   //                },
   //             ],
   //          },
   //       },
   //       {
   //          view: "fieldset",
   //          label: L("ab.component.grid.group", "*Group:"),
   //          labelWidth: App.config.labelWidthLarge,
   //          body: {
   //             type: "clean",
   //             padding: 10,
   //             rows: [
   //                {
   //                   view: "multiselect",
   //                   name: "groupBy",
   //                   label: L("ab.component.grid.groupBy", "*Group by:"),
   //                   labelWidth: App.config.labelWidthLarge,
   //                   options: [],
   //                   on: {
   //                      onChange: (newV, oldV) => {
   //                         let currView = _logic.currentEditObject();
   //                         currView.propertyGroupByList(ids, newV);
   //                      },
   //                   },
   //                },
   //                {
   //                   view: "list",
   //                   name: "groupByList",
   //                   drag: true,
   //                   data: [],
   //                   height: 200,
   //                   template:
   //                      "<span class='fa fa-sort'></span>&nbsp;&nbsp; #value#",
   //                   on: {
   //                      onAfterDrop: () => {
   //                         let currView = _logic.currentEditObject();
   //                         this.propertyEditorSave(ids, currView);
   //                      },
   //                   },
   //                },
   //             ],
   //          },
   //       },
   //       this.linkPageComponent.ui,
   //       {
   //          view: "fieldset",
   //          label: L(
   //             "ab.component.label.customizeDisplay",
   //             "*Customize Display:"
   //          ),
   //          labelWidth: App.config.labelWidthLarge,
   //          body: {
   //             type: "clean",
   //             padding: 10,
   //             rows: [
   //                {
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L(
   //                            "ab.component.label.hiddenFields",
   //                            "*Hidden Fields:"
   //                         ),
   //                         css: "ab-text-bold",
   //                         width: App.config.labelWidthXLarge,
   //                      },
   //                      {
   //                         view: view,
   //                         name: "buttonFieldsVisible",
   //                         label: L("ab.component.label.settings", "*Settings"),
   //                         icon: "fa fa-gear",
   //                         type: "icon",
   //                         click: function () {
   //                            _logic.toolbarFieldsVisible(this.$view);
   //                         },
   //                      },
   //                   ],
   //                },
   //                {
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L(
   //                            "ab.component.label.filterData",
   //                            "*Filter Option:"
   //                         ),
   //                         css: "ab-text-bold",
   //                         width: App.config.labelWidthXLarge,
   //                      },
   //                      {
   //                         view: view,
   //                         name: "buttonFilterData",
   //                         label: L("ab.component.label.settings", "*Settings"),
   //                         icon: "fa fa-gear",
   //                         type: "icon",
   //                         click: function () {
   //                            _logic.gridFilterMenuShow(this.$view);
   //                         },
   //                      },
   //                   ],
   //                },
   //                {
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L(
   //                            "ab.component.label.freezeColumns",
   //                            "*Freeze Columns:"
   //                         ),
   //                         css: "ab-text-bold",
   //                         width: App.config.labelWidthXLarge,
   //                      },
   //                      {
   //                         view: view,
   //                         name: "buttonFieldsFreeze",
   //                         label: L("ab.component.label.settings", "*Settings"),
   //                         icon: "fa fa-gear",
   //                         type: "icon",
   //                         click: function () {
   //                            _logic.toolbarFrozen(this.$view);
   //                         },
   //                      },
   //                   ],
   //                },

   //                {
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L(
   //                            "ab.component.label.summaryFields",
   //                            "*Summary Fields:"
   //                         ),
   //                         css: "ab-text-bold",
   //                         width: App.config.labelWidthXLarge,
   //                      },
   //                      {
   //                         view: view,
   //                         name: "buttonSummaryFields",
   //                         label: L("ab.component.label.settings", "*Settings"),
   //                         icon: "fa fa-gear",
   //                         type: "icon",
   //                         click: function () {
   //                            _logic.summaryColumns(this.$view);
   //                         },
   //                      },
   //                   ],
   //                },

   //                {
   //                   cols: [
   //                      {
   //                         view: "label",
   //                         label: L(
   //                            "ab.component.label.countFields",
   //                            "*Count Fields:"
   //                         ),
   //                         css: "ab-text-bold",
   //                         width: App.config.labelWidthXLarge,
   //                      },
   //                      {
   //                         view: view,
   //                         name: "buttonCountFields",
   //                         label: L("ab.component.label.settings", "*Settings"),
   //                         icon: "fa fa-gear",
   //                         type: "icon",
   //                         click: function () {
   //                            _logic.countColumns(this.$view);
   //                         },
   //                      },
   //                   ],
   //                },

   //                {
   //                   view: "counter",
   //                   name: "height",
   //                   label: L("ab.component.grid.height", "*Height:"),
   //                   labelWidth: App.config.labelWidthXLarge,
   //                },

   //                {
   //                   view: "checkbox",
   //                   name: "hideHeader",
   //                   labelRight: L(
   //                      "ab.component.label.hideHeader",
   //                      "*Hide table header"
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },

   //                {
   //                   view: "checkbox",
   //                   name: "labelAsField",
   //                   labelRight: L(
   //                      "ab.component.label.labelAsField",
   //                      "*Show a field using label template"
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },

   //                {
   //                   view: "checkbox",
   //                   name: "hideButtons",
   //                   labelRight: L(
   //                      "ab.component.label.hideButtons",
   //                      "*Hide edit and view buttons"
   //                   ),
   //                   labelWidth: App.config.labelWidthCheckbox,
   //                },
   //             ],
   //          },
   //       },
   //       {},
   //    ]);
   // }

   // static propertyEditorPopulate(App, ids, view) {
   //    super.propertyEditorPopulate(App, ids, view);

   //    this.view = view;

   //    $$(ids.datacollection).setValue(view.settings.dataviewID);
   //    $$(ids.isEditable).setValue(view.settings.isEditable);
   //    $$(ids.massUpdate).setValue(view.settings.massUpdate);
   //    $$(ids.allowDelete).setValue(view.settings.allowDelete);
   //    $$(ids.isSortable).setValue(view.settings.isSortable);
   //    $$(ids.isExportable).setValue(view.settings.isExportable);
   //    var details = view.settings.detailsPage;
   //    if (view.settings.detailsTab != "") {
   //       details += ":" + view.settings.detailsTab;
   //    }
   //    $$(ids.detailsPage).setValue(details);
   //    var edit = view.settings.editPage;
   //    if (view.settings.editTab != "") {
   //       edit += ":" + view.settings.editTab;
   //    }
   //    $$(ids.editPage).setValue(edit);
   //    $$(ids.height).setValue(view.settings.height);
   //    $$(ids.hideHeader).setValue(view.settings.hideHeader);
   //    $$(ids.labelAsField).setValue(view.settings.labelAsField);
   //    $$(ids.hideButtons).setValue(view.settings.hideButtons);
   //    $$(ids.groupBy).setValue(view.settings.groupBy);

   //    // initial populate of properties and popups
   //    view.populateEditor(ids, view);
   //    view.populatePopupEditors(view);
   //    view.populateBadgeNumber(ids, view);

   //    // when a change is made in the properties the popups need to reflect the change
   //    this.updateEventIds = this.updateEventIds || {}; // { viewId: boolean, ..., viewIdn: boolean }
   //    if (!this.updateEventIds[view.id]) {
   //       this.updateEventIds[view.id] = true;

   //       view.addListener(
   //          "properties.updated",
   //          function () {
   //             view.populateEditor(ids, view);
   //             view.populatePopupEditors(view);
   //             view.populateBadgeNumber(ids, view);
   //          },
   //          this
   //       );
   //    }

   //    //Load ABDatacollection to QueryBuilder
   //    this.propertyUpdateGridFilterObject(ids, view);

   //    // Populate values to link page properties
   //    this.linkPageComponent.viewLoad(view);
   //    this.linkPageComponent.setSettings(view.settings);
   // }

   // static propertyEditorValues(ids, view) {
   //    super.propertyEditorValues(ids, view);

   //    // Retrive the values of your properties from Webix and store them in the view
   //    view.settings.dataviewID = $$(ids.datacollection).getValue();
   //    view.settings.isEditable = $$(ids.isEditable).getValue();
   //    view.settings.massUpdate = $$(ids.massUpdate).getValue();
   //    view.settings.allowDelete = $$(ids.allowDelete).getValue();
   //    view.settings.isSortable = $$(ids.isSortable).getValue();
   //    view.settings.isExportable = $$(ids.isExportable).getValue();

   //    var detailsPage = $$(ids.detailsPage).getValue();
   //    var detailsTab = "";
   //    if (detailsPage.split(":").length > 1) {
   //       var detailsVals = detailsPage.split(":");
   //       detailsPage = detailsVals[0];
   //       detailsTab = detailsVals[1];
   //    }
   //    view.settings.detailsPage = detailsPage;
   //    view.settings.detailsTab = detailsTab;

   //    var editPage = $$(ids.editPage).getValue();
   //    var editTab = "";
   //    if (editPage.split(":").length > 1) {
   //       var editVals = editPage.split(":");
   //       editPage = editVals[0];
   //       editTab = editVals[1];
   //    }
   //    view.settings.editPage = editPage;
   //    view.settings.editTab = editTab;

   //    view.settings.height = $$(ids.height).getValue();
   //    view.settings.hideHeader = $$(ids.hideHeader).getValue();
   //    view.settings.labelAsField = $$(ids.labelAsField).getValue();
   //    view.settings.hideButtons = $$(ids.hideButtons).getValue();
   //    // view.settings.groupBy = $$(ids.groupBy).getValue();

   //    // pull order groupBy list
   //    let groupByList = $$(ids.groupByList).serialize() || [];
   //    view.settings.groupBy = groupByList.map((item) => item.id).join(",");

   //    view.settings.gridFilter = PopupFilterProperty.getSettings();

   //    view.settings.objectWorkspace = view.settings.objectWorkspace || {};
   //    view.settings.objectWorkspace.hiddenFields = PopupHideFieldComponent.getValue();
   //    view.settings.objectWorkspace.frozenColumnID = PopupFrozenColumnsComponent.getValue();

   //    // link pages
   //    let linkSettings = this.linkPageComponent.getSettings();
   //    for (let key in linkSettings) {
   //       view.settings[key] = linkSettings[key];
   //    }

   //    // Populate values to link page properties
   //    this.linkPageComponent.viewLoad(view);
   //    this.linkPageComponent.setSettings(view.settings);
   // }

   // static propertyUpdateGridFilterObject(ids, view) {
   //    if (!view) return;

   //    // Populate values to QueryBuilder
   //    var selectedDv = view.datacollection;

   //    if (selectedDv) {
   //       let object = selectedDv.datasource;
   //       if (object) {
   //          PopupFilterProperty.objectLoad(object, selectedDv.settings.loadAll);
   //       }
   //    }
   // }

   propertyGroupByList(ids, groupBy) {
      let colNames = groupBy || [];
      if (typeof colNames == "string") {
         colNames = colNames.split(",");
      }

      let options = $$(ids.groupBy).getList().data.find({});

      $$(ids.groupByList).clearAll();
      colNames.forEach((colName) => {
         let opt = options.filter((o) => o.id == colName)[0];
         if (opt) {
            $$(ids.groupByList).add(opt);
         }
      });
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   // component(App, objId) {
   //    let baseCom = super.component(App);
   //    var L = App.Label;

   //    var idBase = objId || "ABViewGrid_" + this.id;
   //    var ids = {
   //       component: App.unique(idBase + "_component"),
   //       toolbar: App.unique(idBase + "_toolbar"),
   //       buttonDeleteSelected: App.unique(idBase + "_deleteSelected"),
   //       // buttonExport: App.unique('buttonExport'),
   //       buttonFilter: App.unique(idBase + "_buttonFilter"),
   //       buttonMassUpdate: App.unique(idBase + "_buttonMassUpdate"),
   //       buttonSort: App.unique(idBase + "_buttonSort"),
   //       buttonExport: App.unique(idBase + "_buttonExport"),

   //       globalSearchToolbar: App.unique(idBase + "_globalSearchToolbar"),
   //    };

   //    var labels = {
   //       common: App.labels,
   //    };

   //    var CurrentObject = null;

   //    var settings = {
   //       allowDelete: this.settings.allowDelete,
   //       detailsView: this.settings.detailsPage,
   //       editView: this.settings.editPage,
   //       isEditable: this.settings.isEditable,
   //       massUpdate: this.settings.massUpdate,
   //       configureHeaders: false,
   //       summaryColumns: this.settings.summaryColumns,
   //       countColumns: this.settings.countColumns,
   //       hideHeader: this.settings.hideHeader,
   //       labelAsField: this.settings.labelAsField,
   //       hideButtons: this.settings.hideButtons,
   //       groupBy: this.settings.groupBy,
   //       hiddenFields: this.settings.hiddenFields,
   //       frozenColumnID: this.settings.frozenColumnID || "",
   //       isTreeDatable: this.datacollection && this.datacollection.isGroup,
   //    };

   //    let DataTable = new ABWorkspaceDatatable(App, idBase, settings);
   //    let PopupMassUpdateComponent = new ABPopupMassUpdate(
   //       App,
   //       idBase + "_mass"
   //    );
   //    let PopupSortDataTableComponent = new ABPopupSortField(
   //       App,
   //       idBase + "_sort"
   //    );
   //    let exportPopup = new ABPopupExport(App, idBase + "_export");

   //    let filterUI = this.filterHelper.component(App, idBase + "_gridfilter");
   //    this.filterHelper.fromSettings(this.settings.gridFilter);

   //    let linkPage = this.linkPageHelper.component(
   //       App,
   //       idBase + "_gridlinkpage"
   //    );

   //    let _init = (options, accessLevel) => {
   //       if (this.settings.dataviewID != "") {
   //          DataTable.init(
   //             {
   //                onCheckboxChecked: _logic.callbackCheckboxChecked,
   //             },
   //             accessLevel
   //          );

   //          PopupMassUpdateComponent.init({
   //             // onSave:_logic.callbackAddFields        // be notified of something...who knows...
   //          });

   //          PopupSortDataTableComponent.init({
   //             onChange: _logic.callbackSortData,
   //          });

   //          filterUI.init({
   //             onFilterData: (fnFilter, filterRules) => {
   //                _logic.callbackFilterData(fnFilter, filterRules); // be notified when there is a change in the filter
   //             },
   //          });

   //          exportPopup.init({});

   //          if (
   //             this.settings.massUpdate ||
   //             this.settings.isSortable ||
   //             this.settings.isExportable ||
   //             (this.settings.gridFilter &&
   //                this.settings.gridFilter.filterOption &&
   //                this.settings.gridFilter.userFilterPosition == "toolbar")
   //          ) {
   //             $$(ids.toolbar).show();
   //          }

   //          if (this.settings.massUpdate == false) {
   //             $$(ids.buttonMassUpdate).hide();
   //             $$(ids.buttonDeleteSelected).hide();
   //          }

   //          if (this.settings.allowDelete == false) {
   //             $$(ids.buttonDeleteSelected).hide();
   //          }

   //          if (this.settings.gridFilter) {
   //             if (
   //                this.settings.gridFilter.filterOption != 1 ||
   //                this.settings.gridFilter.userFilterPosition != "toolbar"
   //             ) {
   //                $$(ids.buttonFilter).hide();
   //             }

   //             if (
   //                this.settings.gridFilter.filterOption == 3 &&
   //                this.settings.gridFilter.globalFilterPosition == "single"
   //             ) {
   //                $$(DataTable.ui.id).hide();
   //             }

   //             if (this.settings.gridFilter.isGlobalToolbar)
   //                $$(ids.globalSearchToolbar).show();
   //             else $$(ids.globalSearchToolbar).hide();
   //          }

   //          if (this.settings.isSortable == false) {
   //             $$(ids.buttonSort).hide();
   //          }

   //          if (this.settings.isExportable == false) {
   //             $$(ids.buttonExport).hide();
   //          }

   //          if (this.settings.hideHeader == true) {
   //             DataTable.hideHeader();
   //          }

   //          var dv = this.datacollection;
   //          if (dv && dv.datasource) {
   //             CurrentObject = dv.datasource;

   //             DataTable.objectLoad(CurrentObject);
   //             PopupMassUpdateComponent.objectLoad(CurrentObject, DataTable);
   //             PopupSortDataTableComponent.objectLoad(CurrentObject);
   //             PopupSortDataTableComponent.setValue(this.settings.sortFields);
   //             this.filterHelper.objectLoad(CurrentObject);
   //             this.filterHelper.viewLoad(this);
   //             exportPopup.objectLoad(CurrentObject);
   //             exportPopup.dataCollectionLoad(dv);
   //             exportPopup.setGridComponent($$(DataTable.ui.id));
   //             exportPopup.setHiddenFields(this.settings.hiddenFields);
   //             exportPopup.setFilename(this.label);
   //             DataTable.refreshHeader();

   //             // link page helper
   //             linkPage.init({
   //                view: this,
   //                datacollection: dv,
   //             });

   //             // dv.bind($$(DataTable.ui.id));
   //             DataTable.datacollectionLoad(dv);

   //             var editPage = this.settings.editPage;
   //             var detailsPage = this.settings.detailsPage;
   //             var editTab = this.settings.editTab;
   //             var detailsTab = this.settings.detailsTab;
   //             var isEditable = this.settings.isEditable;

   //             // we need to recursivly look backwards to toggle tabs into view when a user choosed to select a tab for edit or details views
   //             function toggleTab(parentTab, wb) {
   //                // find the tab
   //                var tab = wb.getTopParentView().queryView({ id: parentTab });
   //                // if we didn't pass and id we may have passed a domNode
   //                if (tab == null) {
   //                   tab = $$(parentTab);
   //                }

   //                if (tab == null) return;

   //                // set the tabbar to to the tab
   //                var tabbar = tab.getParentView().getParentView();

   //                if (tabbar == null) return;

   //                if (tabbar.setValue) {
   //                   // if we have reached the top we won't have a tab
   //                   tabbar.setValue(parentTab);
   //                }

   //                // find if it is in a multiview of a tab
   //                var nextTab = tabbar.queryView(
   //                   { view: "scrollview" },
   //                   "parent"
   //                );
   //                // if so then do this again
   //                if (nextTab) {
   //                   toggleTab(nextTab, wb);
   //                }
   //             }

   //             $$(DataTable.ui.id).attachEvent(
   //                "onItemClick",
   //                function (id, e, node) {
   //                   var item = id;

   //                   if (e == "auto") {
   //                      // automatically choose the details page if a record matches
   //                      // later on we can decide if we want to have the choice to select the edit page intead.
   //                      _logic.changePage(dv, item, detailsPage);
   //                      toggleTab(detailsTab, this);
   //                   } else if (e.target.className.indexOf("eye") > -1) {
   //                      _logic.changePage(dv, item, detailsPage);
   //                      toggleTab(detailsTab, this);
   //                   } else if (e.target.className.indexOf("pencil") > -1) {
   //                      _logic.changePage(dv, item, editPage);
   //                      toggleTab(editTab, this);
   //                   } else if (e.target.className.indexOf("trash") > -1) {
   //                      // don't do anything for delete it is handled elsewhere
   //                   } else if (!isEditable && detailsPage.length) {
   //                      _logic.changePage(dv, item, detailsPage);
   //                      toggleTab(detailsTab, this);
   //                   } else if (
   //                      !isEditable &&
   //                      !detailsPage.length &&
   //                      editPage.length &&
   //                      this.config.accessLevel == 2
   //                   ) {
   //                      _logic.changePage(dv, item, editPage);
   //                      toggleTab(editTab, this);
   //                   }
   //                }
   //             );

   //             $$(DataTable.ui.id).attachEvent(
   //                "onAfterRender",
   //                function (data) {
   //                   if ($$(DataTable.ui.id)) {
   //                      //set cy data
   //                      $$(DataTable.ui.id).$view.setAttribute(
   //                         "data-cy",
   //                         DataTable.idBase
   //                      );
   //                      for (const key in ids) {
   //                         if (Object.hasOwnProperty.call(ids, key)) {
   //                            let element = ids[key].toString();
   //                            if ($$(element)) {
   //                               $$(element).$view.setAttribute(
   //                                  "data-cy",
   //                                  element
   //                               );
   //                            }
   //                         }
   //                      }
   //                   }
   //                }
   //             );

   //             // $$(DataTable.ui.id).attachEvent('onBeforeRender', function (data) {
   //             //    _logic.clientSideDataFilter();
   //             // });

   //             $$(DataTable.ui.id).adjust();
   //          }

   //          // Adjust grid based off Access Level of parent view
   //          if (accessLevel < 2) {
   //             $$(ids.buttonMassUpdate).hide();
   //             $$(ids.buttonDeleteSelected).hide();
   //          }
   //       }
   //    };

   //    // specify height of the grid
   //    if (this.settings.height) DataTable.ui.height = this.settings.height;

   //    var tableUI = {
   //       type: "space",
   //       rows: [
   //          {
   //             view: "label",
   //             label: "Select an object to load.",
   //             inputWidth: 200,
   //             align: "center",
   //          },
   //          {},
   //       ],
   //    };
   //    if (this.settings.dataviewID != "") {
   //       tableUI = {
   //          type: "space",
   //          padding: 17,
   //          rows: [
   //             {
   //                view: "toolbar",
   //                id: ids.toolbar,
   //                hidden: true,
   //                css: "ab-data-toolbar",
   //                cols: [
   //                   {
   //                      view: "button",
   //                      id: ids.buttonMassUpdate,
   //                      css: "webix_transparent",
   //                      label: L("ab.object.toolbar.massUpdate", "*Edit"),
   //                      icon: "fa fa-pencil-square-o",
   //                      type: "icon",
   //                      disabled: true,
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.toolbarMassUpdate(this.$view);
   //                      },
   //                   },
   //                   {
   //                      view: "button",
   //                      id: ids.buttonDeleteSelected,
   //                      css: "webix_transparent",
   //                      label: L("ab.object.toolbar.deleteRecords", "*Delete"),
   //                      icon: "fa fa-trash",
   //                      type: "icon",
   //                      disabled: true,
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.toolbarDeleteSelected(this.$view);
   //                      },
   //                   },
   //                   {
   //                      view: "button",
   //                      id: ids.buttonFilter,
   //                      css: "webix_transparent",
   //                      label: L("ab.object.toolbar.filterFields", "*Filters"),
   //                      icon: "fa fa-filter",
   //                      type: "icon",
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.toolbarFilter(this.$view);
   //                      },
   //                   },
   //                   {
   //                      view: "button",
   //                      id: ids.buttonSort,
   //                      css: "webix_transparent",
   //                      label: L("ab.object.toolbar.sortFields", "*Sort"),
   //                      icon: "fa fa-sort",
   //                      type: "icon",
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.toolbarSort(this.$view);
   //                      },
   //                   },
   //                   {
   //                      view: "button",
   //                      id: ids.buttonExport,
   //                      css: "webix_transparent",
   //                      label: L("ab.object.toolbar.export", "*Export"),
   //                      icon: "fa fa-print",
   //                      type: "icon",
   //                      autowidth: true,
   //                      click: function () {
   //                         _logic.toolbarExport(this.$view);
   //                      },
   //                   },
   //                   /*
   //             {
   //                view: view,
   //                id: ids.buttonExport,
   //                label: labels.component.export,
   //                icon: "fa fa-download",
   //                type: "icon",
   //                click: function() {
   //                   _logic.toolbarButtonExport(this.$view);
   //                }
   //             }
   //                          */
   //                   {},
   //                   {
   //                      id: ids.globalSearchToolbar,
   //                      view: "search",
   //                      placeholder: "Search...",
   //                      on: {
   //                         onTimedKeyPress: () => {
   //                            let searchText = $$(
   //                               ids.globalSearchToolbar
   //                            ).getValue();

   //                            filterUI.searchText(searchText);
   //                         },
   //                      },
   //                   },
   //                ],
   //             },
   //             filterUI.ui,
   //             DataTable.ui,
   //          ],
   //       };
   //    }

   //    // our internal business logic
   //    var _logic = {
   //       callbackCheckboxChecked: (state) => {
   //          if (state == "enable") {
   //             _logic.enableUpdateDelete();
   //          } else {
   //             _logic.disableUpdateDelete();
   //          }
   //       },

   //       callbackSortData: (sort_settings) => {
   //          let sortRules = sort_settings || [];

   //          $$(ids.buttonSort).define("badge", sortRules.length || null);
   //          $$(ids.buttonSort).refresh();

   //          let gridElem = $$(DataTable.ui.id);
   //          Promise.resolve()
   //             // NOTE: Webix's client sorting does not support dynamic loading.
   //             // If the data does not be loaded, then load all data.
   //             .then(() => {
   //                if (gridElem.data.find({}).length < gridElem.data.count()) {
   //                   return new Promise((next, bad) => {
   //                      this.datacollection
   //                         .reloadData(0, 0)
   //                         .catch(bad)
   //                         .then(() => {
   //                            // wait until the grid component will done to repaint UI
   //                            setTimeout(() => {
   //                               next();
   //                            }, 777);
   //                         });
   //                   });
   //                } else {
   //                   return Promise.resolve();
   //                }
   //             })
   //             // client sort data
   //             .then(() => {
   //                gridElem.sort(PopupSortDataTableComponent.sort);
   //             });
   //       },

   //       callbackFilterData: (fnFilter, filterRules) => {
   //          filterRules = filterRules || [];

   //          if ($$(ids.buttonFilter)) {
   //             $$(ids.buttonFilter).define("badge", filterRules.length || null);
   //             $$(ids.buttonFilter).refresh();
   //          }

   //          Promise.resolve()
   //             .then(
   //                () =>
   //                   new Promise((next, err) => {
   //                      // if (
   //                      //    !this.settings ||
   //                      //    !this.settings.gridFilter ||
   //                      //    this.settings.gridFilter.filterOption != 3
   //                      // )
   //                      //    // Global search
   //                      //    return next();

   //                      let dc = this.datacollection;
   //                      if (
   //                         !dc ||
   //                         (dc.settings.loadAll &&
   //                            dc.dataStatus != dc.dataStatusFlag.notInitial)
   //                      )
   //                         // Load all already
   //                         return next();

   //                      let limit = null;

   //                      // limit pull data to reduce time and performance loading
   //                      // if (dc.__dataCollection.count() > 300) limit = 300;

   //                      // Load all data
   //                      let gridElem = $$(DataTable.ui.id);
   //                      if (
   //                         gridElem.data.find({}).length < gridElem.data.count()
   //                      ) {
   //                         dc.reloadData(0, limit)
   //                            .then(() => {
   //                               // Should set .loadAll to this data collection ?
   //                               if (limit == null) dc.settings.loadAll = true;

   //                               next();
   //                            })
   //                            .catch(err);
   //                      } else {
   //                         next();
   //                      }
   //                   })
   //             )
   //             // client filter data
   //             .then(
   //                () =>
   //                   new Promise((next, err) => {
   //                      if (!fnFilter) return next();

   //                      // wait the data are parsed into webix.datatable
   //                      setTimeout(() => {
   //                         let table = $$(DataTable.ui.id);
   //                         table.filter((rowData) => {
   //                            // rowData is null when is not load from paging
   //                            if (rowData == null) return false;

   //                            return fnFilter(rowData);
   //                         });

   //                         if (
   //                            this.settings.gridFilter.globalFilterPosition ==
   //                            "single"
   //                         ) {
   //                            if (table.count() > 0) {
   //                               table.show();
   //                               table.select(table.getFirstId(), false);
   //                               table.callEvent("onItemClick", [
   //                                  table.getFirstId(),
   //                                  "auto",
   //                                  null,
   //                               ]);
   //                            } else {
   //                               table.hide();
   //                            }
   //                         }

   //                         next();
   //                      }, 500);
   //                   })
   //             );
   //       },

   //       changePage: (dv, rowItem, page) => {
   //          let rowId = rowItem && rowItem.row ? rowItem.row : null;

   //          // Set cursor to data view
   //          if (dv) {
   //             dv.setCursor(rowId);
   //          }

   //          // Pass settings to link page module
   //          if (linkPage) {
   //             linkPage.changePage(page, rowId);
   //          }

   //          super.changePage(page);
   //       },

   //       selectRow: (rowData) => {
   //          if (!$$(DataTable.ui.id)) return;

   //          if (rowData == null) $$(DataTable.ui.id).unselect();
   //          else if (
   //             rowData &&
   //             rowData.id &&
   //             $$(DataTable.ui.id).exists(rowData.id)
   //          )
   //             $$(DataTable.ui.id).select(rowData.id, false);
   //          else $$(DataTable.ui.id).select(null, false);
   //       },

   //       /**
   //        * @function enableUpdateDelete
   //        *
   //        * enable the update or delete buttons in the toolbar if there are any items selected
   //        * we will make this externally accessible so we can call it from within the datatable component
   //        */
   //       enableUpdateDelete: function () {
   //          $$(ids.buttonMassUpdate).enable();
   //          $$(ids.buttonDeleteSelected).enable();
   //       },

   //       /**
   //        * @function enableUpdateDelete
   //        *
   //        * disable the update or delete buttons in the toolbar if there no items selected
   //        * we will make this externally accessible so we can call it from within the datatable component
   //        */
   //       disableUpdateDelete: function () {
   //          $$(ids.buttonMassUpdate).disable();
   //          $$(ids.buttonDeleteSelected).disable();
   //       },

   //       toolbarDeleteSelected: function ($view) {
   //          var deleteTasks = [];
   //          $$(DataTable.ui.id).data.each(function (obj) {
   //             if (
   //                typeof obj != "undefined" &&
   //                obj.hasOwnProperty("appbuilder_select_item") &&
   //                obj.appbuilder_select_item == 1
   //             ) {
   //                deleteTasks.push(function (next) {
   //                   CurrentObject.model()
   //                      .delete(obj.id)
   //                      .then((response) => {
   //                         next();
   //                      }, next);
   //                });
   //             }
   //          });

   //          if (deleteTasks.length > 0) {
   //             App.AB.Dialog.Confirm({
   //                title: L("ab.massDelete.title", "*Delete Multiple Records"),
   //                text: L(
   //                   "ab.massDelete.description",
   //                   "*Are you sure you want to delete the selected records?"
   //                ),
   //                callback: function (result) {
   //                   if (result) {
   //                      async.parallel(deleteTasks, function (err) {
   //                         if (err) {
   //                            // TODO : Error message
   //                         } else {
   //                            // Anything we need to do after we are done.
   //                            _logic.disableUpdateDelete();
   //                         }
   //                      });
   //                   }
   //                },
   //             });
   //          } else {
   //             App.AB.Dialog.Alert({
   //                title: L("key.no.records.selected", "No Records Selected"),
   //                text: L(
   //                   "key.select.one",
   //                   "You need to select at least one record...did you drink your coffee today?"
   //                ),
   //             });
   //          }
   //       },

   //       toolbarFilter: ($view) => {
   //          filterUI.showPopup($view);
   //       },

   //       toolbarSort: ($view) => {
   //          PopupSortDataTableComponent.show($view);
   //       },

   //       toolbarExport: ($view) => {
   //          exportPopup.show($view);
   //       },

   //       toolbarMassUpdate: function ($view) {
   //          PopupMassUpdateComponent.show($view);
   //       },
   //    };

   //    var _onShow = () => {
   //       baseCom.onShow();

   //       if ($$(DataTable.ui.id)) {
   //          $$(DataTable.ui.id).adjust();
   //       }

   //       var dv = this.datacollection;
   //       if (dv) {
   //          this.eventAdd({
   //             emitter: dv,
   //             eventName: "changeCursor",
   //             listener: _logic.selectRow,
   //          });
   //       }
   //    };

   //    return {
   //       ui: tableUI,
   //       init: _init,
   //       logic: _logic,

   //       onShow: _onShow,
   //    };
   // }

   component(v1App = false) {
      var component = new ABViewGridComponent(this);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               return newComponent.init(this.AB, accessLevel);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   // populateEditor(ids, view) {
   //    // Pull data collections to options
   //    var objectOptions = view.propertyDatacollections();
   //    $$(ids.datacollection).define("options", objectOptions);
   //    $$(ids.datacollection).refresh();
   //    if (view.settings.datacollection != "") {
   //       $$(ids.datacollection).setValue(view.settings.dataviewID);
   //       // $$(ids.linkedObject).show();
   //    } else {
   //       $$(ids.datacollection).setValue("");
   //       // $$(ids.linkedObject).hide();
   //    }

   //    // Grouping options
   //    let groupFields = [];
   //    let dv = this.datacollection;
   //    if (dv && dv.datasource) {
   //       dv.datasource
   //          .fields((f) => {
   //             return (
   //                !f.isConnection &&
   //                view.settings.hiddenFields.indexOf(f.columnName) < 0
   //             );
   //          })
   //          .forEach((f) => {
   //             groupFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //             });
   //          });
   //    }
   //    $$(ids.groupBy).define("options", groupFields);
   //    $$(ids.groupBy).refresh();

   //    this.propertyGroupByList(ids, view.settings.groupBy);
   // }

   // populatePopupEditors(view, dataSource) {
   //    var dv = this.datacollection;
   //    if (!dv) return;

   //    let object = dv.datasource;
   //    if (!object) return;

   //    PopupHideFieldComponent.objectLoad(object);
   //    PopupHideFieldComponent.setValue(view.settings.hiddenFields || []);
   //    PopupHideFieldComponent.setFrozenColumnID(
   //       view.settings.frozenColumnID || ""
   //    );
   //    PopupFrozenColumnsComponent.objectLoad(object);
   //    PopupFrozenColumnsComponent.setValue(view.settings.frozenColumnID || "");
   //    PopupFrozenColumnsComponent.setHiddenFields(
   //       view.settings.hiddenFields || []
   //    );

   //    PopupFilterProperty.objectLoad(object);
   //    PopupFilterProperty.setSettings(view.settings.gridFilter);

   //    PopupSummaryColumnsComponent.objectLoad(object, view);
   //    PopupSummaryColumnsComponent.setValue(view.settings.summaryColumns || []);

   //    PopupCountColumnsComponent.objectLoad(object, view);
   //    PopupCountColumnsComponent.setValue(view.settings.countColumns || []);
   // }

   // populateBadgeNumber(ids, view) {
   //    // set badge numbers to setting buttons
   //    if (view.settings.hiddenFields) {
   //       $$(ids.buttonFieldsVisible).define(
   //          "badge",
   //          view.settings.hiddenFields.length || null
   //       );
   //       $$(ids.buttonFieldsVisible).refresh();
   //    } else {
   //       $$(ids.buttonFieldsVisible).define("badge", null);
   //       $$(ids.buttonFieldsVisible).refresh();
   //    }

   //    if (view.settings.gridFilter && view.settings.gridFilter.filterOption) {
   //       $$(ids.buttonFilterData).define("badge", "Y");
   //       $$(ids.buttonFilterData).refresh();
   //    } else {
   //       $$(ids.buttonFilterData).define("badge", null);
   //       $$(ids.buttonFilterData).refresh();
   //    }

   //    if (view.settings && view.settings.frozenColumnID) {
   //       $$(ids.buttonFieldsFreeze).define("badge", "Y");
   //       $$(ids.buttonFieldsFreeze).refresh();
   //    } else {
   //       $$(ids.buttonFieldsFreeze).define("badge", null);
   //       $$(ids.buttonFieldsFreeze).refresh();
   //    }

   //    if (view.settings && view.settings.summaryColumns) {
   //       $$(ids.buttonSummaryFields).define(
   //          "badge",
   //          view.settings.summaryColumns.length || null
   //       );
   //       $$(ids.buttonSummaryFields).refresh();
   //    } else {
   //       $$(ids.buttonSummaryFields).define("badge", null);
   //       $$(ids.buttonSummaryFields).refresh();
   //    }

   //    if (view.settings && view.settings.countColumns) {
   //       $$(ids.buttonCountFields).define(
   //          "badge",
   //          view.settings.countColumns.length || null
   //       );
   //       $$(ids.buttonCountFields).refresh();
   //    } else {
   //       $$(ids.buttonCountFields).define("badge", null);
   //       $$(ids.buttonCountFields).refresh();
   //    }
   // }

   get filterHelper() {
      if (this.__filterHelper == null) {
         this.__filterHelper = new _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_4__["default"](
            this.AB,
            `${this.id}_filterHelper`
         );
      }

      return this.__filterHelper;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new ABViewPropertyLinkPage();

      return this.__linkPageHelper;
   }
}


/***/ }),

/***/ 55090:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupExport.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABWorkObjectPopupExport)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32735);
/*
 * ABViewGridPopupExport.js
 * Manage the Popup that allows you to export data into one of our supported
 * formats.
 */



class ABWorkObjectPopupExport extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase) {
      idBase = idBase || "abviewgridpopupExport";

      super({
         popupExport: `${idBase}_popupExport`,
         list: `${idBase}_popupExport_list`,
      });

      this._currentObject = null;
      // {ABObject}
      // The ABObject of the data we will export.  We can find out the fields
      // from the object.

      this._dataCollection = null;
      // {ABDatacCollection}
      // The ABDataCollection that contains the data we are going to export.

      this._grid = null;
      // {webix.grid}
      // the current webix.grid that contains the data we are going to export.

      this._filename = null;
      // {string}
      // the name of the desired output file.

      this._hiddenFields = [];
      // {array}
      // An array of ABField.columnName(s) that we are not wanting to export
   }

   ui() {
      var self = this;

      // webix UI definition:
      return {
         view: "popup",
         id: this.ids.popupExport,
         width: 160,
         height: 0, //150,
         select: false,
         hidden: true,
         body: {
            id: this.ids.list,
            view: "list",
            autoheight: true,
            data: [
               { name: "CSV", icon: "file-excel-o" },
               { name: "Excel", icon: "file-excel-o" },
               { name: "PDF", icon: "file-pdf-o" },
               { name: "PNG", icon: "file-image-o" },
            ],
            template:
               "<div><i class='fa fa-#icon# webix_icon_btn' aria-hidden='true'></i> #name#</div>",
            on: {
               onItemClick: function (id /*, e, node */) {
                  var component = this.getItem(id);
                  self.export(component.name);
               },
            },
         },
      };
   }

   async init(AB) {
      if (AB) {
         this.AB = AB;
      }
      webix.ui(this.ui());
      $$(this.ids.popupExport).resize();
   }

   // internal business logic

   /**
    * @method dataCollectionLoad()
    * the current ABDataCollection we are working with.
    * @param {ABDataCollection} dc
    */
   dataCollectionLoad(dc) {
      this._dataCollection = dc;
   }

   /**
    * @method objectLoad()
    * The current ABObject we are working with.
    * @param {ABObject} object
    */
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method setHiddenFields
    * Register Fields we don't want exported in our data.
    * @param {array} fields
    *        An array of ABField.columnName(s) to exclude from our export.
    */
   setHiddenFields(fields = []) {
      this._hiddenFields = fields ?? [];
   }

   /**
    * @method setFilename()
    * Register the name of the file we want our data to export as.
    * @param {string} filename
    */
   setFilename(filename) {
      this._filename = filename;
   }

   /**
    * @method setGridComponent()
    * Register the webix.grid that currently stores the data we are
    * exporting.
    * @param {webix.grid} $grid
    */
   setGridComponent($grid) {
      this._grid = $grid;
   }

   /**
    * @function show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    */
   show($view) {
      $$(this.ids.popupExport).show($view);
   }

   async export(name) {
      let fnExport;

      let columns = {};

      let dc = this._dataCollection;
      let _currentObject = this._currentObject;
      let _grid = this._grid;
      let _filename = this._filename;

      if (
         dc &&
         (!dc.settings.loadAll || dc.dataStatus == dc.dataStatusFlag.notInitial)
      ) {
         // Load all data
         await dc.reloadData(0, null);
         dc.settings.loadAll = true;
      }

      // client filter data
      // template of report
      if (_currentObject) {
         _currentObject.fields().forEach((f) => {
            // hidden fields
            if (this._hiddenFields.indexOf(f.columnName) > -1) return;

            columns[f.columnName] = {
               template: (rowData) => {
                  return f.format(rowData);
               },
            };
         });
      }

      // If there are checked items, then export them only
      // Otherwise export all items
      const noCheckedRow = _grid.data.find({appbuilder_select_item: 1}).length < 1;
      const filterRow = (row) => noCheckedRow || row?.appbuilder_select_item == 1;

      switch (name) {
         case "CSV":
            webix.csv.delimiter.cols = ",";

            fnExport = webix.toCSV(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               columns: columns,
               filter: filterRow
            });
            break;
         case "Excel":
            fnExport = webix.toExcel(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               name:
                  _filename || (_currentObject ? _currentObject.label : null),
               columns: columns,
               filterHTML: true,
               filter: filterRow
            });
            break;
         case "PDF":
            fnExport = webix.toPDF(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               filterHTML: true,
               filter: filterRow
            });
            break;
         case "PNG":
            fnExport = webix.toPNG(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               // filter: NOT SUPPORT
            });
            break;
      }

      try {
         await fnExport;
         $$(this.ids.popupExport).hide();
      } catch (err) {
         this.AB.notify.developer(err, {
            message: `ABViewGridPopupExport:export(): System could not export: ${name}`,
            exportType: name,
            columns,
            fileName: _filename,
         });
      }
   }

   // this.dataCollectionLoad = _logic.dataCollectionLoad;
   // this.objectLoad = _logic.objectLoad;
   // this.setGridComponent = _logic.setGridComponent;
   // this.setFilename = _logic.setFilename;
   // this.setHiddenFields = _logic.setHiddenFields;
   // this.show = _logic.show;
}


/***/ }),

/***/ 33414:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupMassUpdate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGridPopupMassUpdate)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32735);
/* harmony import */ var _RowUpdater__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RowUpdater */ 82021);
/*
 * ABViewGridPopupMassUpdate
 *
 * An ABViewGrid can offer a mass update feature.  This is a ui component
 * to help with the processing of the update.
 *
 */




var L = null;

class ABViewGridPopupMassUpdate extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   //.extend(idBase, function(App) {

   constructor(ABViewGridComponent, idBase) {
      idBase = idBase || "abviewgridpopupMassUpdate";

      super({
         component: `${idBase}_popupMassUpdate`,
         submit: `${idBase}_submitMassUpdate`,
      });

      this.CurrentObject = null;
      // {ABObject}
      // Which ABObject are we currently working with.

      this.GridComponent = ABViewGridComponent;
      // {ABViewGridComponent}
      // The current ABViewGridComponent we are working with.

      this.AB = ABViewGridComponent.AB;
      // {ABFactory}

      this.rowUpdater = new _RowUpdater__WEBPACK_IMPORTED_MODULE_1__["default"](idBase, this.AB);
      // {RowUpdater}
      // An instance of our RowUpdater form builder.

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   ui() {
      var ids = this.ids;

      // Our webix UI definition:
      return {
         view: "popup",
         id: ids.component,
         // modal: true,
         body: {
            width: 500,
            rows: [
               // Update panel
               this.rowUpdater.ui(),
               { height: 15 },
               {
                  cols: [
                     {},
                     {
                        view: "button",
                        value: L("Cancel"),
                        width: 100,
                        click: () => {
                           this.hide();
                        },
                     },
                     {
                        id: ids.submit,
                        css: "webix_primary",
                        view: "button",
                        label: L("Update"),
                        type: "form",
                        width: 120,
                        click: () => {
                           this.submit();
                        },
                     },
                  ],
               },
            ],
         },
         on: {
            onShow: () => {
               this.onShow();
            },
         },
      };
   }

   async init(AB) {
      webix.ui(this.ui());
      this.rowUpdater.init(AB);

      return Promise.resolve();
   }

   /**
    * @method hide()
    * Hide the popup.
    */
   hide() {
      $$(this.ids.component).hide();
   }

   /**
    * @function objectLoad
    * Ready the Popup according to the current object & datatable
    * @param {ABObject} object
    *        the currently selected object.
    * @param {webix.datatable} dataTable
    *        the dataTable we need to run the mass update on...trust me this
    *        will be good
    */
   objectLoad(object, dataTable) {
      this.CurrentObject = object;
      this.rowUpdater.objectLoad(object);
      this.DataTable = dataTable;
   }

   onShow() {}

   /**
    * @method show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    * @param {json} options
    *        Additional webix options related to the .show() method.
    */
   show($view, options = null) {
      if (options != null) {
         $$(this.ids.component).show($view, options);
      } else {
         $$(this.ids.component).show($view);
      }
   }

   /**
    * @method submit()
    * Process the submit action by getting the values to change and then
    * running a batchUpdate() on the items in our datatable that were selected.
    */
   submit() {
      // Update values to records
      let update_button = $$(this.ids.submit),
         update_items = this.rowUpdater.getValue() || [];

      update_button.disable();

      if (!this.GridComponent) {
         // TODO : Message
         // console.log("no data collection to update");
         update_button.enable();
         return;
      } else if (update_items.length < 1) {
         // TODO : Message
         update_button.enable();
         return;
      }

      let $datatable = this.GridComponent.getDataTable(); // $$(DataTable.ui.id);
      let updatedRowIds = [];
      $datatable.data.each(function (row) {
         if (
            row &&
            row.hasOwnProperty("appbuilder_select_item") &&
            row.appbuilder_select_item == 1
         ) {
            updatedRowIds.push(row.id);
         }
      });

      let vals = {};
      update_items.forEach((item) => {
         let fieldInfo = this.CurrentObject.fieldByID(item.fieldId);
         if (!fieldInfo) return;

         vals[fieldInfo.columnName] = item.value;
      });

      if (updatedRowIds.length > 0) {
         webix.confirm({
            title: L("Updating Multiple Records"),
            text: L("Are you sure you want to update the selected records?"),
            callback: (result) => {
               if (result) {
                  if ($datatable && $datatable.showProgress)
                     $datatable.showProgress({ type: "icon" });

                  let objModel = this.CurrentObject.model();
                  objModel
                     .batchUpdate({
                        rowIds: updatedRowIds,
                        values: vals,
                     })
                     .then(() => {
                        // Anything we need to do after we are done.
                        update_button.enable();
                        this.hide();

                        if ($datatable && $datatable.hideProgress)
                           $datatable.hideProgress();
                     })
                     .catch((err) => {
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewGridPopupMassUpdate:submit(): Error during batchUpdate",
                           rowIds: updatedRowIds,
                           values: vals,
                        });
                     });
               } else {
                  update_button.enable();
               }
            },
         });
      } else {
         webix.alert({
            title: L("No Records Selected"),
            text: L(
               "You need to select at least one record...did you drink your coffee today?"
            ),
         });
         update_button.enable();
         this.hide();
      }
   }
}


/***/ }),

/***/ 60732:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupSortFields.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AB_Work_Object_Workspace_PopupSortFields)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32735);
/*
 * ABViewGridPopupSortFields
 *
 * Manage the Sort Fields popup.
 *
 */



var L = null;

class AB_Work_Object_Workspace_PopupSortFields extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase) {
      idBase = idBase || "abviewgridpopupSortFields";

      super({
         component: `${idBase}_popupSort`,
         list: `${idBase}_popupSort_list`,
         form: `${idBase}_popupSort_form`,
      });

      this.CurrentObject = null;
      // {ABObject}
      // The current ABObject we are working with.

      this._blockOnChange = false;
      // {bool}
      // Should we skip the onChange handler processing at this time?

      this._settings = null;
      // {json}
      // default sort settings.

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   uiForm() {
      return {
         view: "form",
         id: this.ids.form,
         // autoheight: true,
         borderless: true,
         elements: [
            {
               view: "button",
               type: "form",
               css: "webix_primary",
               value: L("Add new sort"),
               on: {
                  onItemClick: (/* id, e, node */) => {
                     this.clickAddNewSort();
                     this.triggerOnChange();
                  },
               },
            },
         ],
      };
   }

   ui() {
      return {
         view: "popup",
         id: this.ids.component,
         // autoheight:true,
         width: 600,
         body: this.uiForm(),
         on: {
            onShow: () => {
               this.onShow();
            },
         },
      };
   }

   // Our init() function for setting up our UI
   async init(AB) {
      if (AB) {
         this.AB = AB;
      }

      webix.ui(this.ui());
   }

   /**
    * @function clickAddNewSort
    * When the user clicks the "Add New Sort" button, this routine will
    * add another row to the sort form.
    * @param {string} fieldId
    *        The ABField.id of the field to auto select in this new row.
    * @param {string} dir
    *        The sort order to auto select in this new row.
    */
   // clickAddNewSort: function(by, dir, isMulti, id) {
   clickAddNewSort(fieldId, dir) {
      var self = this;
      var sort_form = $$(this.ids.form);

      var viewIndex = sort_form.getChildViews().length - 1;
      var listFields = this.getFieldList(true);
      sort_form.addView(
         {
            id: "sort" + webix.uid(),
            cols: [
               {
                  view: "combo",
                  width: 220,
                  options: listFields,
                  on: {
                     onChange: function (columnId) {
                        var el = this;
                        self.onChangeCombo(columnId, el);
                     },
                  },
               },
               {
                  view: "segmented",
                  width: 200,
                  options: [
                     {
                        id: "",
                        value: L("Please select field"),
                     },
                  ],
                  on: {
                     onChange: (/* newv, oldv */) => {
                        // 'asc' or 'desc' values
                        this.triggerOnChange();
                     },
                  },
               },
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  width: 30,
                  on: {
                     onItemClick: function () {
                        sort_form.removeView(this.getParentView());
                        self.refreshFieldList(true);
                        self.triggerOnChange();
                     },
                  },
               },
            ],
         },
         viewIndex
      );

      // Select field
      if (fieldId) {
         var fieldsCombo = sort_form
            .getChildViews()
            [viewIndex].getChildViews()[0];
         fieldsCombo.setValue(fieldId);
      }
      // select direction
      if (dir) {
         var segmentButton = sort_form
            .getChildViews()
            [viewIndex].getChildViews()[1];
         segmentButton.setValue(dir);
      }
   }

   /**
    * @function getFieldList
    * return field list so we can present a custom UI for view
    * @param {bool} excludeSelected
    *        Should we ignore fields that already exist in the form?
    * @return {array} [ { id, value } ]
    *         an array that is compatible with the webix.list
    *         widget.
    */
   getFieldList(excludeSelected) {
      var sort_form = $$(this.ids.form),
         listFields = [];

      var allFields = this.CurrentObject.fields();
      if (allFields.length == 0) return listFields;

      // Get all fields include hidden fields
      allFields.forEach((f) => {
         if (f.fieldIsSortable()) {
            listFields.push({
               id: f.id,
               value: f.label,
            });
         }
      });

      // Remove selected field
      if (excludeSelected) {
         var childViews = sort_form.getChildViews();
         if (childViews.length > 1) {
            // Ignore 'Add new sort' button
            childViews.forEach(function (cView, index) {
               if (childViews.length - 1 <= index) return false;

               var selectedValue = cView.getChildViews()[0].getValue();
               if (selectedValue) {
                  listFields = listFields.filter((f) => f.id != selectedValue);
               }
            });
         }
      }
      return listFields;
   }

   /**
    * @function objectLoad
    * Ready the Popup according to the current object
    * @param {ABObject} object  the currently selected object.
    */
   objectLoad(object) {
      this.CurrentObject = object;
   }

   /**
    * @method setSettings
    * Initialize the form with a set of conditions.
    * @param {Array} settings
    *        The default settings for this form.
    *        [
    *           {
    *              key: uuid,     // ABField.id
    *              dir: string,   // 'asc' or 'desc'
    *           }
    *        ]
    */
   setSettings(settings) {
      this._settings = this.AB.cloneDeep(settings);
   }

   /**
    * @method getSettings
    * return the current sort settings stored by this form.
    * @return {Array} -
    *         [
    *            {
    *               key: uuid,     // ABField.id
    *               dir: string,   // 'asc' or 'desc'
    *            }
    *         ]
    */
   getSettings() {
      var sort_form = $$(this.ids.form),
         sortFields = [];

      var childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach(function (cView, index) {
            if (childViews.length - 1 <= index) return false;

            var fieldId = cView.getChildViews()[0].getValue();
            var dir = cView.getChildViews()[1].getValue();
            sortFields.push({
               key: fieldId,
               dir: dir,
            });
         });
      }
      return sortFields;
   }

   /**
    * @method onChangeCombo()
    * Update the display once they have chosen a field to sort by.
    * We now need to offer the appropriate sort direction chooser.
    * @param {string} fieldID
    *        The value of the combo box now.
    * @param {webix.$view} el
    *        The current Webix.$view that was the combo box that just
    *        changed.
    */
   onChangeCombo(fieldID, el) {
      var allFields = this.CurrentObject.fields();
      var chosenField = null,
         sortDir = el.getParentView().getChildViews()[1],
         // isMultiLingual = el.getParentView().getChildViews()[2],
         // isMulti = 0,
         options = null;

      chosenField = allFields.find((f) => f.id == fieldID);
      if (!chosenField) return;

      switch (chosenField.key) {
         case "date":
            options = [
               { id: "asc", value: L("Before -> After") },
               { id: "desc", value: L("After -> Before") },
            ];
            break;
         case "number":
            options = [
               { id: "asc", value: L("1 -> 9") },
               { id: "desc", value: L("9 -> 1") },
            ];
            break;
         case "string":
         default:
            options = [
               { id: "asc", value: L("A -> Z") },
               { id: "desc", value: L("Z -> A") },
            ];
            break;
      }

      sortDir.define("options", options);
      sortDir.refresh();

      // if (columnConfig.settings.supportMultilingual)
      //    isMulti = columnConfig.settings.supportMultilingual;

      // isMultiLingual.setValue(isMulti);

      this.refreshFieldList();
      this.triggerOnChange();
   }

   /**
    * @function onShow
    * Rebuild the form when an onShow() is called.
    */
   onShow() {
      var sort_form = $$(this.ids.form);

      // clear field options in the form
      webix.ui(this.uiForm(), sort_form);

      var sorts = this._settings;
      if (sorts && sorts.forEach) {
         sorts.forEach((s) => {
            this.clickAddNewSort(s.key, s.dir);
         });
      }

      if (sorts == null || sorts.length == 0) {
         this.clickAddNewSort();
      }
   }

   /**
    * @method refreshFieldList
    * return an updated field list so you cannot duplicate a sort
    * @param {bool} ignoreRemoveViews
    *
    */
   refreshFieldList(ignoreRemoveViews) {
      var sort_form = $$(this.ids.form),
         listFields = this.getFieldList(false),
         selectedFields = [],
         removeChildViews = [];

      var childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach(function (cView, index) {
            if (childViews.length - 1 <= index) return false;

            var fieldId = cView.getChildViews()[0].getValue(),
               // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId });
               fieldObj = listFields.find((f) => f.id == fieldId);

            if (fieldObj) {
               // Add selected field to list
               selectedFields.push(fieldObj);
            } else {
               // Add condition to remove
               removeChildViews.push(cView);
            }
         });
      }

      // Remove filter conditions when column is deleted
      if (!ignoreRemoveViews) {
         removeChildViews.forEach(function (cView) {
            sort_form.removeView(cView);
         });
      }

      // Field list should not duplicate field items
      childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach(function (cView, index) {
            if (childViews.length - 1 <= index) return false;

            var fieldId = cView.getChildViews()[0].getValue(),
               // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId }),
               fieldObj = listFields.filter(function (f) {
                  return f.id == fieldId;
               });

            // var selectedFieldsExcludeCurField = $(selectedFields).not(fieldObj);
            var selectedFieldsExcludeCurField = selectedFields.filter(function (
               x
            ) {
               if (Array.isArray(fieldObj) && fieldObj.indexOf(x) !== -1) {
                  return false;
               }
               return true;
            });

            // var enableFields = $(listFields).not(selectedFieldsExcludeCurField).get();
            var enableFields = listFields.filter(function (x) {
               if (
                  Array.isArray(selectedFieldsExcludeCurField) &&
                  selectedFieldsExcludeCurField.indexOf(x) !== -1
               ) {
                  return false;
               }
               return true;
            });

            // Update field list
            cView.getChildViews()[0].define("options", enableFields);
            cView.getChildViews()[0].refresh();
         });
      }
   }

   /**
    * @function triggerOnChange
    * This parses the sort form to build in order the sorts then saves to the application object workspace
    */
   triggerOnChange() {
      // block .onChange callback
      if (this._blockOnChange) return;

      this._settings = this.getSettings();

      this.emit("changed", this._settings);
   }

   blockOnChange() {
      this._blockOnChange = true;
   }

   unblockOnChange() {
      this._blockOnChange = false;
   }

   /**
    * @function show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    * @param {uuid} fieldId
    *        the ABField.id we want to prefill the sort with
    * @param {json} options
    *        Additional webix.show() options parameters.
    */
   show($view, fieldId, options) {
      this.blockOnChange();

      $$(this.ids.component).show($view, options || null);

      if (fieldId) {
         this.clickAddNewSort(fieldId);
      }

      this.unblockOnChange();
   }

   /**
    * @function sort()
    * client sort data in list
    *
    * @param {Object} a
    * @param {Object} b
    */
   sort(a, b) {
      let result = 0;

      const childViews = $$(this.ids.form).getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach((cView, index) => {
            if (childViews.length - 1 <= index || result != 0) return;

            const fieldId = cView.getChildViews()[0].getValue();
            const dir = cView.getChildViews()[1].getValue();

            const field = this.CurrentObject.fieldByID(fieldId);
            if (!field) return;

            const by = field.columnName; // column name

            let aValue = a[by],
               bValue = b[by];

            if (Array.isArray(aValue)) {
               aValue = (aValue || [])
                  .map(function (item) {
                     return item.text || item;
                  })
                  .join(" ");
            }

            if (Array.isArray(bValue)) {
               bValue = (bValue ?? [])
                  .map((item) => item.text || item)
                  .join(" ");
            }

            if (aValue != bValue) {
               if (dir == "asc") {
                  result = aValue > bValue ? 1 : -1;
               } else {
                  result = aValue < bValue ? 1 : -1;
               }
            }
         });
      }

      return result;
   }
}


/***/ }),

/***/ 38446:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewImage.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewImageCore = __webpack_require__(/*! ../../core/views/ABViewImageCore */ 27950);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewImage extends ABViewImageCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewImageEditorComponent";

      var ImageComponent = this.component(App, idBase);

      return ImageComponent;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      _logic.validateType = (item) => {
         // verify file type
         var acceptableTypes = ["jpg", "jpeg", "bmp", "png", "gif"];
         var type = item.type.toLowerCase();
         if (acceptableTypes.indexOf(type) == -1) {
            webix.message(
               L("Only [{0}] images are supported", [
                  acceptableTypes.join(", "),
               ])
            );
            return false;
         } else {
            // set upload url to uploader
            var currView = _logic.currentEditObject();
            let actionKey = `opstool.AB_${currView.application.name.replace(
               "_",
               ""
            )}.view`;
            let url = `/file/upload/${currView.application.name}/${actionKey}/1`;

            $$(ids.file).define("upload", url);
            $$(ids.file).refresh();

            return true;
         }
      };

      _logic.uploadedFile = (fileInfo) => {
         if (!fileInfo || !fileInfo.data) return;

         var currView = _logic.currentEditObject();
         currView.settings.filename = fileInfo.data.uuid;

         // get width & height of images
         if (fileInfo.file) {
            let img = new Image();
            img.onload = function () {
               $$(ids.width).setValue(img.width);
               $$(ids.height).setValue(img.height);
            };
            img.src = URL.createObjectURL(fileInfo.file);
         }

         // trigger a save()
         this.propertyEditorSave(ids, currView);
      };

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            cols: [
               {
                  view: "label",
                  label: L("Image:"),
                  css: "ab-text-bold",
                  width: this.AB.UISettings.config().labelWidthXLarge,
               },
               {
                  view: "uploader",
                  value: L("Upload image"),
                  name: "file",
                  apiOnly: true,
                  inputName: "image",
                  multiple: false,
                  on: {
                     onBeforeFileAdd: (item) => {
                        return _logic.validateType(item);
                     },

                     onFileUpload: (file, response) => {
                        _logic.uploadedFile(file);
                     },

                     onFileUploadError: (file, response) => {},
                  },
               },
            ],
         },
         {
            view: "counter",
            name: "width",
            label: L("Width:"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.width).setValue(view.settings.width);
      $$(ids.height).setValue(view.settings.height);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.width = $$(ids.width).getValue();
      view.settings.height = $$(ids.height).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = `ABViewImage_${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      // an ABViewLabel is a simple Label
      var _ui = {
         cols: [
            {
               id: ids.component,
               view: "template",
               template: "",
               height: this.settings.height,
               width: this.settings.width,
            },
            {},
         ],
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {
         if (!$$(ids.component)) return;

         if (this.settings.filename) {
            let imgTag = `<img src="/file/${this.settings.filename}" height="${this.settings.height}" width="${this.settings.width}">`;

            $$(ids.component).define("template", imgTag);
         } else {
            $$(ids.component).define("template", "");
         }

         $$(ids.component).refresh();
      };

      return {
         ui: _ui,
         init: _init,
      };
   }
};


/***/ }),

/***/ 99258:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewKanban.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewKanban)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 85766);
const ABViewKanbanCore = __webpack_require__(/*! ../../core/views/ABViewKanbanCore */ 77907);


const ABViewPropertyLinkPage = (__webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 95782)["default"]);

const ABFormSidePanel = __webpack_require__(/*! ./ABViewKanbanFormSidePanel */ 95341);

var L = null;
// multilingual Label fn()

var ABFieldConnect = null;
var ABFieldUser = null;
var ABFieldList = null;

class ABViewKanBanComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(viewKanBan, idBase) {
      var base = idBase || `ABViewKanBan_${viewKanBan.id}`;

      super(base, {
         // component: "",
         kanban: "",
         resizer: "",
      });

      this.viewKanBan = viewKanBan;
      this.AB = viewKanBan.AB;

      this.settings = viewKanBan.settings;

      this.FormSide = new ABFormSidePanel(
         this,
         `${base}_formSidePanel`,
         this.settings.editFields
      );

      this.CurrentVerticalField = null;
      this.CurrentHorizontalField = null;
      this.CurrentOwnerField = null;

      this.TextTemplate = viewKanBan.TextTemplate;

      this._updatingOwnerRowId = null;

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };

         ABFieldConnect = this.AB.Class.ABFieldManager.fieldByKey(
            "connectObject"
         );
         ABFieldUser = this.AB.Class.ABFieldManager.fieldByKey("user");
         ABFieldList = this.AB.Class.ABFieldManager.fieldByKey("list");
      }
   }

   ui() {
      var ids = this.ids;
      var self = this;

      return {
         id: ids.component,
         cols: [
            {
               id: ids.kanban,
               view: "kanban",
               cols: [],
               userList: {
                  view: "menu",
                  // yCount: 8,
                  // scroll: false,
                  template: '<i class="fa fa-user"></i> #value#',
                  width: 150,
                  on: {
                     onSelectChange: function () {
                        if (self._updatingOwnerRowId == null)
                           // get this row id from onAvatarClick event
                           return;

                        let userId = this.getSelectedId(false);
                        if (userId == null) return;

                        self.updateOwner(self._updatingOwnerRowId, userId);
                     },
                  },
               },
               editor: false, // we use side bar
               users: [],
               tags: [],
               data: [],
               on: {
                  onListAfterSelect: (itemId, list) => {
                     this.CurrentDatacollection?.setCursor(itemId);
                     this.emit("select", itemId);

                     if (itemId) {
                        let data = $$(ids.kanban).getItem(itemId);
                        this.FormSide.show(data);

                        $$(ids.resizer)?.show();
                     } else {
                        this.FormSide.hide();

                        $$(ids.resizer)?.hide();
                     }
                  },
                  onAfterStatusChange: (rowId, status /*, list */) => {
                     this.updateStatus(rowId, status);
                  },
                  onAvatarClick: (rowId /*, ev, node, list */) => {
                     // keep this row id for update owner data in .userList
                     this._updatingOwnerRowId = rowId;
                  },
               },
            },
            {
               id: ids.resizer,
               view: "resizer",
               css: "bg_gray",
               width: 11,
               hidden: true,
            },
            this.FormSide.ui(),
         ],
      };
   }

   init(AB) {
      this.AB = AB;

      if (this.$kb) webix.extend(this.$kb, webix.ProgressBar);

      this.FormSide.init(AB);
      this.FormSide.on("add", (newVals) => {
         this.saveData(newVals);
      });
      this.FormSide.on("update", (updateVals) => {
         this.saveData(updateVals);
      });
   }

   get $kb() {
      if (!this._kb) {
         this._kb = $$(this.ids.kanban);
      }
      return this._kb;
   }

   kanbanListTemplate() {
      return {
         icons: [
            // { icon: "mdi mdi-comment", show: function (obj) { return !!obj.comments }, template: "#comments.length#" },
            {
               icon: "fa fa-trash-o",
               click: (rowId /*, e */) => {
                  this.removeCard(rowId);
               },
            },
         ],
         // avatar template
         templateAvatar: (obj) => {
            if (
               this.CurrentOwnerField &&
               obj[this.CurrentOwnerField.columnName]
            ) {
               return this.CurrentOwnerField.format(obj);
            } else {
               return "<span class='webix_icon fa fa-user'></span>";
            }
         },
         // template for item body
         // show item image and text
         templateBody: (data) => {
            if (!this.settings.template) {
               return this.CurrentObject?.displayData(data);
            }
            // return our default text template
            return this.TextTemplate.displayText(data);
         },
      };
   }

   /**
    * @function hide()
    *
    * hide this component.
    */
   hide() {
      $$(this.ids.component)?.hide();
   }

   /**
    * @function show()
    * Show this component.
    */
   async show() {
      var ids = this.ids;
      $$(ids.component)?.show();

      this.FormSide.hide();

      $$(ids.resizer)?.hide();

      var CurrentObject = this.CurrentObject;
      if (!CurrentObject) return;

      // Get vertical grouping field and populate to kanban list
      // NOTE: this field should be the select list type
      var CurrentVerticalField = CurrentObject.fieldByID(
         this.settings.verticalGroupingField
      );
      if (!CurrentVerticalField) return;
      this.CurrentVerticalField = CurrentVerticalField;

      let horizontalOptions = [];
      var CurrentHorizontalField = CurrentObject.fieldByID(
         this.settings.horizontalGroupingField
      );
      this.CurrentHorizontalField = CurrentHorizontalField;

      if (
         CurrentHorizontalField &&
         CurrentHorizontalField instanceof ABFieldConnect
      ) {
         // Pull horizontal options
         horizontalOptions = await CurrentHorizontalField.getOptions();
      }

      // Option format -  { id: "1543563751920", text: "Normal", hex: "#4CAF50" }
      let verticalOptions = (CurrentVerticalField.settings.options || []).map(
         (opt) => {
            // Vertical & Horizontal fields
            if (CurrentVerticalField && CurrentHorizontalField) {
               let rows = [],
                  // [{
                  //    id: '',
                  //    text: ''
                  // }]
                  horizontalVals = [];

               // pull options of the Horizontal field
               if (CurrentHorizontalField instanceof ABFieldList) {
                  // make a copy of the settings.
                  horizontalVals = (
                     CurrentHorizontalField.settings.options || []
                  ).map((o) => o);
               } else if (CurrentHorizontalField instanceof ABFieldUser) {
                  horizontalVals = CurrentHorizontalField.getUsers().map(
                     (u) => {
                        return {
                           id: u.id,
                           text: u.text || u.value,
                        };
                     }
                  );
               } else if (CurrentHorizontalField instanceof ABFieldConnect) {
                  horizontalVals = horizontalOptions.map(({ id, text }) => ({
                     id,
                     text,
                  }));
               }

               horizontalVals.push({
                  id: null,
                  text: L("Other"),
               });

               horizontalVals.forEach((val) => {
                  let statusOps = {};
                  statusOps[CurrentVerticalField.columnName] = opt.id;
                  statusOps[CurrentHorizontalField.columnName] = val.id;

                  // Header
                  rows.push({
                     template: val.text,
                     height: 20,
                     css: "progress_header",
                  });

                  // Kanban list
                  rows.push({
                     view: "kanbanlist",
                     status: statusOps,
                     type: this.kanbanListTemplate(),
                  });
               });

               return {
                  header: opt.text,
                  body: {
                     margin: 0,
                     rows: rows,
                  },
               };
            }
            // Vertical field only
            else if (CurrentVerticalField) {
               let statusOps = {};
               statusOps[CurrentVerticalField.columnName] = opt.id;

               return {
                  header: opt.text,
                  body: {
                     view: "kanbanlist",
                     status: statusOps,
                     type: this.kanbanListTemplate(),
                  },
               };
            }
         }
      );

      // Rebuild kanban that contains options
      // NOTE: webix kanban does not support dynamic vertical list
      webix.ui(verticalOptions, $$(ids.kanban));
      $$(ids.kanban).reconstruct();

      // Owner field
      var CurrentOwnerField = CurrentObject.fieldByID(this.settings.ownerField);
      this.CurrentOwnerField = CurrentOwnerField;
      if (CurrentOwnerField) {
         let $menuUser = $$(ids.kanban).getUserList();
         $menuUser.clearAll();

         if (CurrentOwnerField instanceof ABFieldUser) {
            let users = this.AB.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            });

            $menuUser.parse(users);
         } else if (CurrentOwnerField instanceof ABFieldConnect) {
            let options = await CurrentOwnerField.getOptions();

            $menuUser.parse(
               options.map((opt) => {
                  return {
                     id: opt.id,
                     value: opt.text,
                  };
               })
            );
         }
      }
   }

   busy() {
      this.$kb?.showProgress?.({ type: "icon" });
   }

   ready() {
      this.$kb?.hideProgress?.();
   }

   objectLoad(object) {
      super.objectLoad(object);

      this.TextTemplate.objectLoad(object);
      this.FormSide.objectLoad(object);
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      super.datacollectionLoad(datacollection);

      var DC = this.CurrentDatacollection;
      if (!DC) {
         DC = datacollection;
      }
      if (DC) {
         DC.bind(this.$kb);
         var obj = DC.datasource;
         if (obj) this.objectLoad(obj);
         return;
      }

      this.$kb.unbind();
   }

   async updateStatus(rowId, status) {
      if (!this.CurrentVerticalField) return;

      // Show loading cursor
      this.busy();

      let patch = {};

      // update multi-values
      if (status instanceof Object) {
         patch = status;
      }
      // update single value
      else {
         patch[this.CurrentVerticalField.columnName] = status;
      }

      // update empty value
      let needRefresh = false;
      for (let key in patch) {
         if (patch[key] == null) {
            patch[key] = "";

            // WORKAROUND: if update data is empty, then it will need to refresh
            // the kanban after update
            needRefresh = true;
         }
      }

      try {
         await this.CurrentObject?.model().update(rowId, patch);

         this.ready();

         if (needRefresh) this.show();

         // update form data
         if (this.FormSide.isVisible()) {
            let data = $$(ids.kanban).getItem(rowId);
            this.FormSide.refresh(data);
         }
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABViewKanban:updateStatus(): Error saving item:",
            rowId,
            patch,
         });
         this.ready();
      }
   }

   async updateOwner(rowId, val) {
      if (!this.CurrentOwnerField) return;

      // Show loading cursor
      this.busy();

      let patch = {};
      patch[this.CurrentOwnerField.columnName] = val;

      try {
         let updatedRow = await this.CurrentObject?.model().update(
            rowId,
            patch
         );

         // update card
         this.$kb?.updateItem(rowId, updatedRow);

         // update form data
         if (this.FormSide.isVisible()) {
            let data = this.$kb.getItem(rowId);
            this.FormSide.refresh(data);
         }

         this.ready();
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABViewKanban:updateOwner(): Error saving item:",
            rowId,
            val,
         });

         this.ready();
      }
   }

   saveData(data) {
      // update
      if (data.id && this.$kb.exists(data.id)) {
         this.$kb.updateItem(data.id, data);
      }
      // insert
      else {
         this.$kb.add(data);
      }
   }

   unselect() {
      if (this.$kb) {
         this.$kb.eachList(function (list /*, status*/) {
            list?.unselect?.();
         });
      }
   }

   addCard() {
      this.unselect();

      // show the side form
      this.FormSide.show();
      $$(this.ids.resizer).show();
   }

   async removeCard(rowId) {
      webix.confirm({
         title: L("Remove card"),
         text: L("Do you want to delete this card?"),
         callback: async (result) => {
            if (!result) return;

            this.busy();

            try {
               let response = await this.CurrentObject?.model().delete(rowId);

               if (response.numRows > 0) {
                  this.$kb.remove(rowId);
               } else {
                  webix.alert({
                     text: L(
                        "No rows were effected. This does not seem right."
                     ),
                  });
               }
            } catch (err) {
               this.AB.notify.developer(err, {
                  message: "ABViewKanban:removeCard(): Error deleting item:",
                  rowId,
               });
            }
            this.ready();
         },
      });
   }

   /**
    * @method setFields()
    * Save the current view options.
    * @param options - {
    *       verticalGrouping:    {ABField} - required
    *       horizontalGrouping:  {ABField} - optional
    *       ownerField:          {ABField} - optional
    * }
    */
   setFields(options) {
      this.CurrentVerticalField = options.verticalGrouping;
      this.CurrentHorizontalField = options.horizontalGrouping;
      this.CurrentOwnerField = options.ownerField;
   }
}

class ABViewKanban extends ABViewKanbanCore {
   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewKanbanEditorComponent";

      var Kanban = this.component(App, idBase);

      return {
         ui: Kanban.ui,
         logic: Kanban.logic,
         onShow: Kanban.onShow,

         init: () => {
            // remove id of the component in caching for refresh .bind of the data collection
            let dv = this.datacollection;
            if (dv) dv.removeComponent(Kanban.ui.id);

            Kanban.init();
         },
      };
   }

   component(v1App = false) {
      var component = new ABViewKanBanComponent(this);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               return newComponent.init(this.AB);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new ABViewPropertyLinkPage();

      return this.__linkPageHelper;
   }
}


/***/ }),

/***/ 95341:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewKanbanFormSidePanel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewKanbanFormSidePanel
 *
 * Provide a form area for editing data in the Kan Ban view.
 *
 */

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 85766)["default"]);
const ABViewForm = __webpack_require__(/*! ./ABViewForm */ 70704);
const ABViewFormButton = __webpack_require__(/*! ./ABViewFormButton */ 15651);

var L = null;
// multilingual Label fn()

module.exports = class ABWorkObjectKanBan extends ABViewComponent {
   constructor(comKanBan, idBase, editFields) {
      idBase = idBase || `${comKanBan.id}_formSidePanel`;
      super(idBase, {
         form: "",
      });

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }

      this.AB = comKanBan.AB;

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.editFields = editFields;
      // {array}
      // An array of {ABField.id} that determines which fields should show up
      // in the editor.

      this._mockApp = this.AB.applicationNew({});
      // {ABApplication}
      // Any ABViews we create are expected to be in relation to
      // an ABApplication, so we create a "mock" app for our
      // workspace views to use to display.
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }

   ui() {
      var ids = this.ids;

      // Our webix UI definition:
      return {
         id: ids.component,
         width: 300,
         hidden: true,
         rows: [
            {
               view: "toolbar",
               css: "webix_dark",
               cols: [
                  {
                     view: "label",
                     label: L("Edit Record"),
                  },
                  {
                     view: "icon",
                     icon: "wxi-close",
                     align: "right",
                     click: (/* id */) => {
                        this.hide();
                     },
                  },
               ],
            },
            {
               view: "scrollview",
               body: {
                  rows: [
                     {
                        id: ids.form,
                        view: "form",
                        borderless: true,
                        rows: [],
                     },
                  ],
               },
            },
         ],
      };
   }

   async init(AB) {
      this.AB = AB;
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }

   objectLoad(object) {
      this.CurrentObjectID = object.id;
   }

   hide() {
      $$(this.ids.component)?.hide();

      this.emit("close");
   }

   show(data) {
      $$(this.ids.component)?.show();

      this.refreshForm(data);
   }

   isVisible() {
      return $$(this.ids.component)?.isVisible() ?? false;
   }

   refreshForm(data) {
      var ids = this.ids;
      let $formView = $$(ids.form);
      let CurrentObject = this.CurrentObject;

      if (!CurrentObject || !$formView) return;

      data = data || {};

      let formAttrs = {
         id: `${this.ids.component}_sideform`,
         key: ABViewForm.common().key,
         settings: {
            columns: 1,
            labelPosition: "top",
            showLabel: 1,
            clearOnLoad: 0,
            clearOnSave: 0,
            labelWidth: 120,
            height: 0,
         },
      };

      // let form = new ABViewForm(formAttrs, this._mockApp);
      let form = this.AB.viewNewDetatched(formAttrs);

      form.objectLoad(CurrentObject);

      // Populate child elements
      CurrentObject.fields().forEach((f, index) => {
         // if this is one of our .editFields
         if (!this.editFields || this.editFields.indexOf(f.id) > -1) {
            form.addFieldToForm(f, index);
         }
      });

      // add default button (Save button)
      form._views.push(
         new ABViewFormButton(
            {
               settings: {
                  includeSave: true,
                  includeCancel: false,
                  includeReset: false,
               },
               position: {
                  y: CurrentObject.fields().length, // yPosition
               },
            },
            this._mockApp,
            form
         )
      );

      // add temp id to views
      form._views.forEach(
         (v, index) => (v.id = `${form.id}_${v.key}_${index}`)
      );

      let formCom = form.component(this.AB._App);

      // Rebuild form
      webix.ui(formCom.ui.rows.concat({}), $formView);
      webix.extend($formView, webix.ProgressBar);

      formCom.init(
         {
            onBeforeSaveData: () => {
               // get update data
               var formVals = form.getFormValues($formView, CurrentObject);

               // validate data
               if (!form.validateData($formView, CurrentObject, formVals))
                  return false;

               // show progress icon
               $formView?.showProgress({ type: "icon" });

               if (formVals.id) {
                  CurrentObject.model()
                     .update(formVals.id, formVals)
                     .then((updateVals) => {
                        this.emit("update", updateVals);
                        // _logic.callbacks.onUpdateData(updateVals);

                        $formView?.hideProgress({ type: "icon" });
                     })
                     .catch((err) => {
                        // TODO : error message
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewKanbanFormSidePanel:onBeforeSaveData():update(): Error updating value",
                           formVals,
                        });
                        $formView?.hideProgress({ type: "icon" });
                     });
               }
               // else add new row
               else {
                  CurrentObject.model()
                     .create(formVals)
                     .then((newVals) => {
                        // _logic.callbacks.onAddData(newVals);
                        this.emit("add", newVals);

                        $formView?.hideProgress({ type: "icon" });
                     })
                     .catch((err) => {
                        // TODO : error message
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewKanbanFormSidePanel:onBeforeSaveData():.create(): Error creating value",
                           formVals,
                        });

                        $formView?.hideProgress({ type: "icon" });
                     });
               }

               return false;
            },
         },
         2 /* NOTE: if you can see this KanBan, you should be able to see the side form? */
      );

      // display data
      $formView.clear();
      $formView.parse(data);

      formCom.onShow(data);
   }
};


/***/ }),

/***/ 76145:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewLabel.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewLabelCore = __webpack_require__(/*! ../../core/views/ABViewLabelCore */ 55759);

const ABViewLabelPropertyComponentDefaults = ABViewLabelCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewLabel extends ABViewLabelCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewLabelEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _ui = {
         type: "form",
         margin: 10,
         padding: 10,
         borderless: true,
         rows: [
            {
               id: ids.component,
               view: "label",
               label: this.text || "",
               align: this.settings.alignment,
            },
            {},
         ],
      };

      _ui = this.uiFormatting(_ui);

      var _init = (options) => {};

      // var _logic = {
      // }

      return {
         ui: _ui,
         init: _init,
      };
   }

   //
   // Property Editor
   //

   // static propertyEditorComponent(App) {
   // 	return ABViewPropertyComponent.component(App);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         // .text :  The Text displayed for this label
         {
            view: "text",
            name: "text",
            label: L("Text"),
            placeholder: L("Text Placeholder"),
            // labelWidth: this.AB.UISettings.config().labelWidthMedium,
         },
         {
            view: "fieldset",
            label: L("Format Options:"),
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "radio",
                     name: "format",
                     vertical: true,
                     value: ABViewLabelPropertyComponentDefaults.format,
                     options: [
                        {
                           id: 0,
                           value: L("normal"),
                        },
                        {
                           id: 1,
                           value: L("title"),
                        },
                        {
                           id: 2,
                           value: L("description"),
                        },
                     ],
                  },
               ],
            },
         },
         {
            view: "fieldset",
            label: L("Alignment:"),
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "radio",
                     name: "alignment",
                     vertical: true,
                     value: ABViewLabelPropertyComponentDefaults.alignment,
                     options: [
                        {
                           id: "left",
                           value: L("Left"),
                        },
                        {
                           id: "center",
                           value: L("Center"),
                        },
                        {
                           id: "right",
                           value: L("Right"),
                        },
                     ],
                  },
               ],
            },
         },
         {},
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.text).setValue(view.text);
      $$(ids.format).setValue(view.settings.format);
      $$(ids.alignment).setValue(view.settings.alignment);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.text = $$(ids.text).getValue();
      view.settings.format = $$(ids.format).getValue();
      view.settings.alignment = $$(ids.alignment).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      // get a UI component for each of our child views
      var viewComponents = [];
      this.views().forEach((v) => {
         viewComponents.push(v.component(App));
      });

      var idBase = `ABViewLabel_${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      // an ABViewLabel is a simple Label
      var _ui = {
         type: "form",
         padding: 15,
         borderless: true,
         rows: [
            {
               id: ids.component,
               view: "label",
               // css: 'ab-component-header ab-ellipses-text',
               label: this.text || "*",
               align: this.settings.alignment,
               type: {
                  height: "auto",
               },
            },
         ],
      };
      _ui = this.uiFormatting(_ui);

      // make sure each of our child views get .init() called
      var _init = (options) => {};

      return {
         ui: _ui,
         init: _init,
      };
   }

   /**
    * @method uiFormatting
    * a common routine to properly update the displayed label
    * UI with the css formatting for the given .settings
    * @param {obj} _ui the current webix.ui definition
    * @return {obj} a properly formatted webix.ui definition
    */
   uiFormatting(_ui) {
      // add different css settings based upon it's format
      // type.
      switch (parseInt(this.settings.format)) {
         // normal
         case 0:
            _ui.rows[0].css = "ab-component-label ab-ellipses-text";
            break;

         // title
         case 1:
            _ui.rows[0].css = "ab-component-header ab-ellipses-text";
            break;

         // description
         case 2:
            _ui.rows[0].css = "ab-component-description ab-ellipses-text";
            break;
      }

      return _ui;
   }
};


/***/ }),

/***/ 6541:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewLayout.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 32715);
const ABViewLayoutCore = __webpack_require__(/*! ../../core/views/ABViewLayoutCore */ 96897);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewLayout extends ABViewLayoutCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewLayoutEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         view: App.unique(`${idBase}_view`),
      };

      var component = this.component(App);

      /** Logic */
      var _logic = {
         templateButton: function (obj) {
            return `<div class="ab-widget-header ab-layout-header">
               <i class="fa fa-${obj.icon} webix_icon_btn"></i> ${obj.label}
               <div class="ab-component-tools">'
               <i class="fa fa-trash ab-component-remove"></i>
               <i class="fa fa-edit ab-component-edit"></i>
               </div></div>`;
         },

         viewEdit: (e, id, trg) => {
            var view = this.views(function (v) {
               return v.id == id;
            })[0];

            if (!view) return false;

            // NOTE: let webix finish this onClick event, before
            // calling .populateInterfaceWorkspace() which will replace
            // the interface elements with the edited view.  (apparently
            // that causes errors.)
            setTimeout(() => {
               App.actions.populateInterfaceWorkspace(view);
            }, 50);

            e.preventDefault();
            return false;
         },

         viewDelete: (e, id, trg) => {
            var view = this.views(function (v) {
               return v.id == id;
            })[0];

            webix.confirm({
               title: L("Delete component"),
               text: L("Do you want to delete <b>{0}</b>?", [view.label]),
               callback: (result) => {
                  if (result) {
                     // this.viewDestroy(view)
                     view.destroy().then(() => {
                        // refresh the editor interface.
                        console.error(
                           "ABViewLayout: convert App.actions.* to .emit()"
                        );
                        App.actions.populateInterfaceWorkspace(this);
                     });
                  }
               },
            });
            e.preventDefault();
         },
      };

      /** UI */
      var _ui = Object.assign(component.ui, {});
      _ui.type = "form";

      this.views().forEach((v, index) => {
         _ui.cols[index] = {
            rows: [
               // Add action buttons
               {
                  type: "template",
                  css: "ab-layout-header",
                  height: 30,
                  template: _logic.templateButton({
                     icon: v.icon,
                     label: v.label,
                  }),
                  onClick: {
                     "ab-component-edit": (e, id, trg) => {
                        _logic.viewEdit(e, v.id, trg);
                     },
                     "ab-component-remove": (e, id, trg) => {
                        _logic.viewDelete(e, v.id, trg);
                     },
                  },
               },
               // Preview display here
               _ui.cols[index],
               {},
            ],
         };
      });

      if (this.views().length == 0) {
         _ui.cols[0] = {};
      }

      return {
         ui: _ui,
         init: component.init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   /**
    * @method addView
    * called when the .propertyEditorDefaultElements() button is clicked.
    * This method should find the current View instance and call it's .addColumn()
    * method.
    */
   static addView(ids, _logic) {
      // get current instance and .addColumn()
      var LayoutView = _logic.currentEditObject();
      LayoutView.addColumn();

      var includeSubViews = true; // we ask later on down the save if we should save subviews...we do this time

      // trigger a save()
      this.propertyEditorSave(ids, LayoutView, includeSubViews);
   }

   /**
    * @method propertyEditorDefaultElements
    * return the input form used in the property editor for this View.
    */
   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // if I don't create my own propertyEditorComponent, then I need to
      // create the onClick handler that will cause the current view instance
      // to create a vew sub view/ column
      if (!_logic.onClick) {
         _logic.onClick = () => {
            this.addView(ids, _logic);
         };
      }

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         // [button] : add column
         {
            view: "button",
            css: "webix_primary",
            value: L("Add Column "),
            click: _logic.onClick,
         },
      ]);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @param {string} idPrefix
    *
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      let idBase = `ABViewLayout_${idPrefix || ""}${this.id}`;
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      this.viewComponents = this.viewComponents || {}; // { viewId: viewComponent, ..., viewIdn: viewComponent }

      let _ui = {
         id: ids.component,
         view: "layout",
         cols: [],
      };

      this.views().forEach((v) => {
         this.viewComponents[v.id] = v.component(App, idPrefix);
         _ui.cols.push(this.viewComponents[v.id].ui);

         // Trigger 'changePage' event to parent
         this.eventAdd({
            emitter: v,
            eventName: "changePage",
            listener: (pageId) => {
               this.changePage(pageId);
            },
         });
      });

      // make sure each of our child views get .init() called
      var _init = (options, accessLevel) => {
         this.views().forEach((v) => {
            var component = this.viewComponents[v.id];

            // initial sub-component
            if (component && component.init) {
               component.init(options, accessLevel);
            }
         });
      };

      var _onShow = () => {
         // calll .onShow in child components
         this.views().forEach((v) => {
            var component = this.viewComponents[v.id];

            if (component && component.onShow) {
               component.onShow();
            }
         });
      };

      return {
         ui: _ui,
         init: _init,
         // logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 59285:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewList.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewListCore = __webpack_require__(/*! ../../core/views/ABViewListCore */ 76589);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewList extends ABViewListCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewListEditorComponent";

      var ListView = this.component(App, idBase);

      return {
         ui: ListView.ui,
         logic: ListView.logic,
         onShow: ListView.onShow,

         init: () => {
            // remove id of the component in caching for refresh .bind of the data collection
            let dv = this.datacollection;
            if (dv) dv.removeComponent(ListView.ui.id);

            ListView.init();
         },
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         var currView = _logic.currentEditObject();

         // Update field options in property
         this.propertyUpdateFieldOptions(ids, currView, dcId);
      };

      return commonUI.concat([
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            on: {
               onChange: _logic.selectSource,
            },
         },
         {
            name: "field",
            view: "richselect",
            label: L("Field"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
      ]);
   }

   /**
    * @method propertyUpdateFieldOptions
    * Populate fields of object to select list in property
    *
    * @param {Object} ids
    * @param {ABViewForm} view - the current component
    * @param {string} dvId - id of ABDatacollection
    */
   static propertyUpdateFieldOptions(ids, view, dvId) {
      var datacollection = view.AB.datacollectionByID(dvId);
      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      var fieldOptions = [];
      if (object != null) {
         fieldOptions = object.fields().map((f) => {
            return {
               id: f.id,
               value: f.label,
            };
         });
      }

      $$(ids.field).define("options", fieldOptions);
      $$(ids.field).refresh();
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var datacollectionId = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;
      var SourceSelector = $$(ids.datacollection);

      // Pull data collections to options
      var dcOptions = view.propertyDatacollections();
      SourceSelector.define("options", dcOptions);
      SourceSelector.define("value", datacollectionId);
      SourceSelector.refresh();

      this.propertyUpdateFieldOptions(ids, view, datacollectionId);

      $$(ids.field).setValue(view.settings.field);
      $$(ids.height).setValue(view.settings.height);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
      view.settings.field = $$(ids.field).getValue();
      view.settings.height = $$(ids.height).getValue();
      view.settings.height =
         parseInt(view.settings.height) || ABViewList.defaultValues().height;
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseCom = super.component(App);

      var idBase = "ABViewListEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _ui = {
         id: ids.component,
         view: "dataview",
         type: {
            width: 1000,
            height: 30,
         },
         template: (item) => {
            var field = this.field();
            if (!field) return "";

            return field.format(item);
         },
      };

      // set height or autoHeight
      if (this.settings.height != 0) {
         _ui.height = this.settings.height;
      } else {
         _ui.autoHeight = true;
      }

      var _init = (options) => {
         var dv = this.datacollection;
         if (!dv) return;

         // bind dc to component
         dv.bind($$(ids.component));
         // $$(ids.component).sync(dv);
      };

      // var _logic = {
      // }

      return {
         ui: _ui,
         init: _init,

         onShow: baseCom.onShow,
      };
   }
};


/***/ }),

/***/ 37726:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewMenu.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewMenuCore = __webpack_require__(/*! ../../core/views/ABViewMenuCore */ 42579);
const ABViewTab = __webpack_require__(/*! ./ABViewTab */ 12235);

const ABViewMenuPropertyComponentDefaults = ABViewMenuCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewMenu extends ABViewMenuCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewMenuEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         pages: App.unique(`${idBase}_pages`),
         tree: App.unique(`${idBase}_tree`),
      };

      var component = this.component(App);

      var menu = component.ui;
      if (component.ui.elements) {
         var menuIndex = 0;
         component.ui.elements.forEach((elem) => {
            if (elem.view == "menu") {
               menu = component.ui.elements[menuIndex];
            }
            menuIndex++;
         });
      }
      menu.id = ids.component;

      var _ui = {
         type: "space",
         rows: [menu, {}],
      };

      var _init = (options) => {
         var Menu = $$(ids.component);

         this.ClearPagesInView(Menu);
         if (this.settings.order && this.settings.order.length) {
            this.AddPagesToView(Menu, this.settings.order);
            // } else if (this.settings.pages && this.settings.pages.length) {
            //    this.AddPagesToView(Menu, this.settings.pages);
         }
      };

      var _logic = {};

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // _logic functions

      _logic.updateTreeDnD = (id, state) => {
         var currView = _logic.currentEditObject();

         // var curPage = currView.settings.pages.filter((page) => {
         //    return page.pageId == id || page.tabId == id;
         // })[0];

         var curPage = currView.application.pages(
            (page) => page.id == id,
            true
         )[0];

         // must not have been a page...lets check tabs
         if (!curPage) {
            curPage = currView.application.views(
               (view) => view.id == id,
               true
            )[0];
         }

         if (state) {
            let label = currView.getAliasname(curPage);
            $$(ids.treeDnD).add({
               id: curPage.id,
               value: label,
               type: curPage.type,
               pageId: curPage.pageId || "",
               tabId: curPage.tabId || "",
            });
            _logic.reorderPages();
         } else {
            // if this item exists in the tree and does not have a submenu you can remove it
            // otherwise we will ask the user to move its submenu items out before deleting
            if ($$(ids.treeDnD).exists(id) && !$$(ids.treeDnD).isBranch(id)) {
               $$(ids.treeDnD).remove(id);
               _logic.reorderPages();
            } else if (
               $$(ids.treeDnD).exists(id) &&
               $$(ids.treeDnD).isBranch(id)
            ) {
               $$(ids.pages).blockEvent();
               // we don't want to send a toggle event because it triggers saves to the database
               $$(ids.pages).checkItem(id);
               webix.message({
                  text: L(
                     "Item comtains submenu, please remove items in submenu before removing."
                  ),
                  type: "error",
                  expire: 10000,
               });
               //resume listening
               $$(ids.pages).unblockEvent();
            }
         }
      };

      _logic.reorderPages = () => {
         var currView = _logic.currentEditObject();

         // add a new pages container
         var pages = [];
         // loop through tree to reorder pages
         $$(ids.treeDnD).data.each((obj) => {
            // find the page in settings that matches the item in the tree
            // var curPage = currView.settings.pages.filter((page) => {
            //    return page.pageId == obj.id || page.tabId == obj.id;
            // })[0];

            var curPage = currView.application.pages(
               (page) => page.id == obj.id,
               true
            )[0];

            // must not have been a page...lets check tabs
            if (!curPage) {
               curPage = currView.application.views(
                  (view) => view.id == obj.id,
                  true
               )[0];
            }

            // put that page in the next possition of the page container
            pages.push(curPage);
         });

         var newPageOrder = [];
         // loop through pages
         /*
         {
            "pageId": "9b8a9458-3ad4-46c1-9ea8-6c96950e161d",
            "tabId": "",
            "type": "page",
            "isChecked": "true",
            "translations": [
               {
                  "language_code": "en",
                  "label": "Sub Page 1",
                  "aliasname": "Sub Page 1"
               }
            ],
            "parent": "0",
            "position": "0"
         }
         */
         pages.forEach((page) => {
            if (page) {
               var thisPage = {};
               // get the id of the element we are clicking to
               var id = page.id;
               // get the object of the data with the id in the tree view
               var treeItem = $$(ids.treeDnD).getItem(id);
               // set the parent element in the page if the treeItem has one
               thisPage.parent = treeItem.$parent;
               // store the position so we can put it back in the right spot later
               thisPage.position = $$(ids.treeDnD).getBranchIndex(id);
               // store the icon
               thisPage.icon = treeItem.icon;
               // store the getAliasname
               //thisPage.aliasname = currView.getAliasname(page);
               // store the page types
               thisPage.type = page.key == "viewcontainer" ? "tab" : "page";
               if (thisPage.type == "tab") {
                  thisPage.tabId = page.id;
                  thisPage.pageId = currView.getParentPageId(page);
               } else {
                  thisPage.pageId = page.id;
               }
               thisPage.isChecked = "true";
               thisPage.translations = page.translations;
               newPageOrder.push(thisPage);
            }
         });
         currView.settings.order = newPageOrder;

         _logic.onChange();
         $$(ids.treeDnD).openAll();
      };

      return commonUI.concat([
         {
            name: "orientation",
            view: "richselect",
            label: L("Orientation"),
            value: ABViewMenuPropertyComponentDefaults.orientation,
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
            options: [
               {
                  id: "x",
                  value: L("Horizontal"),
               },
               {
                  id: "y",
                  value: L("Vertical"),
               },
            ],
         },
         {
            name: "buttonStyle",
            view: "richselect",
            label: L("Button Style"),
            value: ABViewMenuPropertyComponentDefaults.buttonStyle,
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
            options: [
               {
                  id: "ab-menu-default",
                  value: L("Default"),
               },
               {
                  id: "ab-menu-link",
                  value: L("Link"),
               },
            ],
         },
         {
            name: "menuAlignment",
            view: "richselect",
            label: L("Menu Alignment"),
            value: ABViewMenuPropertyComponentDefaults.menuAlignment,
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
            options: [
               {
                  id: "ab-menu-left",
                  value: L("Left"),
               },
               {
                  id: "ab-menu-center",
                  value: L("Center"),
               },
               {
                  id: "ab-menu-right",
                  value: L("Right"),
               },
            ],
         },
         {
            name: "menuInToolbar",
            view: "checkbox",
            labelRight: L("Put menu in toolbar"),
            value: ABViewMenuPropertyComponentDefaults.menuInToolbar,
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            name: "toolbarFieldset",
            view: "fieldset",
            label: L("Toolbar Settings:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               view: "layout",
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "menuPadding",
                     view: "counter",
                     label: L("Toolbar padding"),
                     value: ABViewMenuPropertyComponentDefaults.menuPadding,
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
                  {
                     name: "menuTheme",
                     view: "richselect",
                     label: L("Toolbar theme"),
                     value: ABViewMenuPropertyComponentDefaults.menuTheme,
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [
                        {
                           id: "white",
                           value: L("White (Default)"),
                        },
                        {
                           id: "bg_gray",
                           value: L("Gray"),
                        },
                        {
                           id: "webix_dark",
                           value: L("Dark"),
                        },
                     ],
                  },
                  {
                     name: "menuPosition",
                     view: "richselect",
                     label: L("Menu Position"),
                     value: ABViewMenuPropertyComponentDefaults.menuPosition,
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     options: [
                        {
                           id: "left",
                           value: L("Left"),
                        },
                        {
                           id: "center",
                           value: L("Center"),
                        },
                        {
                           id: "right",
                           value: L("Right"),
                        },
                     ],
                  },
                  {
                     name: "menuTextLeft",
                     view: "text",
                     label: L("Text Left"),
                     placeholder: L("Place text in left region of toolbar."),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     labelPosition: "top",
                  },
                  {
                     name: "menuTextCenter",
                     view: "text",
                     label: L("Text Center"),
                     placeholder: L("Place text in center region of toolbar."),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     labelPosition: "top",
                  },
                  {
                     name: "menuTextRight",
                     view: "text",
                     label: L("Text Right"),
                     placeholder: L("Place text in right region of toolbar."),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     labelPosition: "top",
                  },
               ],
            },
         },
         {
            name: "pagesFieldset",
            view: "fieldset",
            label: L("Page List:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               view: "layout",
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "pages",
                     view: "edittree",
                     borderless: true,
                     css: "transparent",
                     // editor: "inline-text",
                     editable: true,
                     editValue: "aliasname",
                     editor: "text",
                     template: function (item, common) {
                        return `<div class='ab-page-list-item'>
                           ${common.icon(item)} ${common.checkbox(
                           item,
                           false
                        )} <div class="fa fa-${
                           item.key == "viewcontainer"
                              ? "window-maximize"
                              : "file"
                        }"></div> 
                           ${item.label}</div>`;
                     },
                     on: {
                        onItemCheck: function (id, state) {
                           // trigger to save settings
                           _logic.onChange();
                           _logic.updateTreeDnD(id, state);
                        },
                        onBeforeEditStart: function (id) {
                           var item = this.getItem(id);
                           if (!item.aliasname) {
                              item.aliasname = item.label;
                              this.updateItem(item);
                           }
                        },
                        onBeforeEditStop: function (state, editor) {
                           var item = this.getItem(editor.id);
                           if (item) {
                              item.translations.forEach((t) => {
                                 if (
                                    t.language_code ==
                                    App.AB.Multilingual.currentLanguage()
                                 ) {
                                    t.aliasname = state.value;
                                 }
                              });
                              item.label = state.value;
                              this.updateItem(editor.id, item);
                           }

                           if ($$(ids.treeDnD).exists(editor.id)) {
                              // we need to update the drag and drop tree item as well so get it first
                              var treeItem =
                                 $$(ids.treeDnD).getItem(editor.id) || {};
                              // change the value (since that is what is being displayed)
                              treeItem.value = state.value;
                              // then change the aliasname (since that property controls the final view)
                              treeItem.aliasname = state.value;
                              // trigger a save so when we update the preview it has the new data to work with
                              _logic.onChange();
                              // tell the tree to update with new alias (this will trigger a page reorder save and the values already saved will be used to rebuild the component)
                              $$(ids.treeDnD).updateItem(editor.id, treeItem);
                           }
                        },
                     },
                  },
               ],
            },
         },
         {
            name: "pageOrderFieldset",
            view: "fieldset",
            label: L("Drag & Drop to Reorder/Click to Add Icon:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               view: "layout",
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "edittree",
                     borderless: true,
                     name: "treeDnD",
                     template:
                        "{common.icon()} <i class='fa fa-fw fa-#icon#'></i> <span>#value#</span>",
                     drag: true,
                     editable: true,
                     editValue: "icon",
                     editor: "combo",
                     options: App.icons,
                     suggest: {
                        template: "#value#",
                        filter: function (item, value) {
                           if (
                              item.value
                                 .toString()
                                 .toLowerCase()
                                 .indexOf(value.toLowerCase()) === 0
                           )
                              return true;
                           return false;
                        },
                        body: {
                           template:
                              "<i class='fa fa-fw fa-#value#'></i> #value#",
                        },
                     },
                     on: {
                        onBeforeDrop: function (context) {
                           context.parent = context.target; //drop as child
                           context.index = -1; //as last child
                        },
                        onAfterDrop: function (context, native_event) {
                           _logic.reorderPages();
                        },
                        onDataUpdate: function () {
                           _logic.reorderPages();
                        },
                     },
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.orientation).setValue(
         view.settings.orientation ||
            ABViewMenuPropertyComponentDefaults.orientation
      );
      $$(ids.buttonStyle).setValue(
         view.settings.buttonStyle ||
            ABViewMenuPropertyComponentDefaults.buttonStyle
      );
      $$(ids.menuAlignment).setValue(
         view.settings.menuAlignment ||
            ABViewMenuPropertyComponentDefaults.menuAlignment
      );
      $$(ids.menuInToolbar).setValue(
         parseInt(view.settings.menuInToolbar) ||
            ABViewMenuPropertyComponentDefaults.menuInToolbar
      );
      $$(ids.menuPadding).setValue(
         view.settings.menuPadding ||
            ABViewMenuPropertyComponentDefaults.menuPadding
      );
      $$(ids.menuTheme).setValue(
         view.settings.menuTheme ||
            ABViewMenuPropertyComponentDefaults.menuTheme
      );
      $$(ids.menuPosition).setValue(
         view.settings.menuPosition ||
            ABViewMenuPropertyComponentDefaults.menuPosition
      );
      if (view.menuTextLeft == "" && view.settings.menuTextLeft) {
         view.menuTextLeft = view.settings.menuTextLeft;
      }
      $$(ids.menuTextLeft).setValue(
         view.menuTextLeft || ABViewMenuPropertyComponentDefaults.menuTextLeft
      );
      if (view.menuTextCenter == "" && view.settings.menuTextCenter) {
         view.menuTextCenter = view.settings.menuTextCenter;
      }
      $$(ids.menuTextCenter).setValue(
         view.menuTextCenter ||
            ABViewMenuPropertyComponentDefaults.menuTextCenter
      );
      if (view.menuTextRight == "" && view.settings.menuTextRight) {
         view.menuTextRight = view.settings.menuTextRight;
      }
      $$(ids.menuTextRight).setValue(
         view.menuTextRight || ABViewMenuPropertyComponentDefaults.menuTextRight
      );

      var pageTree = new webix.TreeCollection();
      var application = view.application;
      var currentPage = view.pageParent();
      var parentPage = currentPage.pageParent();
      var rootPage = view.pageRoot();

      /**
       * @method addPage
       *
       * @param {ABView} page
       * @param {integer} index
       * @param {uuid} parentId
       */
      var addPage = function (page, index, parentId) {
         // update .aliasname and .translations of the page
         if (view.settings.order && view.settings.order.forEach) {
            view.settings.order.forEach((localpage) => {
               if (
                  (localpage.pageId == page.id && !localpage.id) ||
                  (parentId &&
                     localpage.pageId == parentId &&
                     localpage.tabId == page.id)
               ) {
                  page.translations = localpage.translations;
               }
            });
         }
         let alias = view.getAliasname(page);
         page.label = alias ? alias : page.label;
         // add to tree collection
         pageTree.add(page, index, parentId);

         // add sub-pages
         var subPages = page.pages ? page.pages() : [];
         subPages.forEach((childPage, childIndex) => {
            addPage(childPage, childIndex, page.id);
         });

         // add tabs
         page
            .views((v) => v instanceof ABViewTab)
            .forEach((tab, tabIndex) => {
               // tab views
               tab.views().forEach((tabView, tabViewIndex) => {
                  // tab items will be below sub-page items
                  var tIndex = subPages.length + tabIndex + tabViewIndex;

                  addPage(tabView, tIndex, page.id);
               });
            });
      };

      application
         .pages((p) => rootPage && rootPage.id == p.id, true)
         .forEach((p, index) => {
            addPage(p, index);
         });

      $$(ids.pages).clearAll();
      $$(ids.pages).data.importData(pageTree);
      $$(ids.pages).refresh();
      $$(ids.pages).blockEvent();
      $$(ids.pages).uncheckAll();
      $$(ids.pages).unblockEvent();
      $$(ids.pages).openAll();

      // Select pages
      // if (view.settings.pages && view.settings.pages.forEach) {
      // $$(ids.treeDnD).clearAll();
      // view.settings.pages.forEach((page) => {
      //    if (page.isChecked) {
      //       if ($$(ids.pages).exists(page.tabId || page.pageId)) {
      //          //after this command all events will be ignored
      //          $$(ids.pages).blockEvent();
      //          // we don't want to send a toggle event because it triggers saves to the database
      //          $$(ids.pages).checkItem(page.tabId || page.pageId);
      //          //resume listening
      //          $$(ids.pages).unblockEvent();
      //       }
      //    }
      // });

      $$(ids.treeDnD).clearAll();
      if (view.settings.order && view.settings.order.forEach) {
         view.settings.order.forEach((page) => {
            if ($$(ids.pages).exists(page.tabId || page.pageId)) {
               //after this command all events will be ignored
               $$(ids.pages).blockEvent();
               // we don't want to send a toggle event because it triggers saves to the database
               $$(ids.pages).checkItem(page.tabId || page.pageId);
               //resume listening
               $$(ids.pages).unblockEvent();
            }
            let label = view.getAliasname(page);
            $$(ids.treeDnD).add(
               {
                  id: page.tabId || page.pageId,
                  value: label,
                  type: page.type,
                  pageId: page.pageId || "",
                  tabId: page.tabId || "",
                  icon: page.icon,
               },
               page.position ? parseInt(page.position) : 0,
               page.parent && page.parent != "0" ? page.parent : ""
            );
         });
         // } else if (view.settings.pages && view.settings.pages.forEach) {
         //    view.settings.pages.forEach((page) => {
         //       if (page.isChecked) {
         //          let label = view.getAliasname(page);
         //          $$(ids.treeDnD).add({
         //             id: page.tabId || page.pageId,
         //             value: label,
         //             type: page.type,
         //             pageId: page.pageId
         //          });
         //       }
         //    });
      }
      $$(ids.treeDnD).openAll();
      // }

      // $$(ids.pagesFieldset).config.height = ($$(ids.pages).count()*28)+18; // Number of pages plus 9px of padding top and bottom
      $$(ids.pagesFieldset).config.height =
         $$(ids.pages).count() * 28 + 18 + 40; // Number of pages plus 9px of padding top and bottom
      $$(ids.pagesFieldset).resize();
      $$(ids.pageOrderFieldset).config.height =
         $$(ids.pages).count() * 28 + 18 + 40; // Number of pages plus 9px of padding top and bottom
      $$(ids.pageOrderFieldset).resize();
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.orientation = $$(ids.orientation).getValue();
      view.settings.buttonStyle = $$(ids.buttonStyle).getValue();
      view.settings.menuAlignment = $$(ids.menuAlignment).getValue();
      view.settings.menuInToolbar = $$(ids.menuInToolbar).getValue();
      view.settings.menuPadding = $$(ids.menuPadding).getValue();
      view.settings.menuTheme = $$(ids.menuTheme).getValue();
      view.settings.menuPosition = $$(ids.menuPosition).getValue();
      view.menuTextLeft = $$(ids.menuTextLeft).getValue();
      view.menuTextCenter = $$(ids.menuTextCenter).getValue();
      view.menuTextRight = $$(ids.menuTextRight).getValue();
      // Legacy support: clear the old settings when new values are created
      // otherwise leave them
      if (view.menuTextLeft.length) {
         view.settings.menuTextLeft = "";
      }
      if (view.menuTextCenter.length) {
         view.settings.menuTextCenter = "";
      }
      if (view.menuTextCenter.length) {
         view.settings.menuTextRight = "";
      }

      // var pagesIdList = [];
      if ($$(ids.pages)) {
         for (var i = 0; i < $$(ids.pages).data.count(); i++) {
            var currentPageId = $$(ids.pages).getIdByIndex(i);
            var currentItem = $$(ids.pages).getItem(currentPageId);

            var type = "page",
               tabId;
            if (currentItem.key == "viewcontainer") {
               type = "tab";
               tabId = currentPageId;
               currentPageId = currentItem.pageParent().id;
            } else {
               // if we have left the tabs we were looping through we need to reset the tabId
               tabId = "";
            }

            // let pageInfo = view.settings.pages.filter(
            //    (p) => p.pageId == currentPageId
            // )[0];

            let translations = [];

            if (currentItem && currentItem.translations)
               translations = currentItem.translations;
            // else if (pageInfo && pageInfo.translations)
            //    translations = AB.cloneDeep(pageInfo.translations);

            // pagesIdList.push({
            //    pageId: currentPageId,
            //    tabId: tabId,
            //    type: type,
            //    aliasname: currentItem.aliasname,
            //    isChecked: currentItem.checked,
            //    translations: translations
            // });
         }
         // view.settings.pages = pagesIdList;
         if (view.settings.pages) delete view.settings.pages;
      }
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var idBase = `ABMenuLabel_${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var css = "";

      if (this.settings.buttonStyle) {
         css += this.settings.buttonStyle + " ";
      } else {
         css += ABViewMenuPropertyComponentDefaults.buttonStyle + " ";
      }

      if (this.settings.menuAlignment) {
         css += this.settings.menuAlignment + " ";
      } else {
         css += ABViewMenuPropertyComponentDefaults.menuAlignment + " ";
      }

      var _ui = {
         id: ids.component,
         view: "menu",
         autoheight: true,
         autowidth: true,
         datatype: "json",
         css: css,
         layout:
            this.settings.orientation ||
            ABViewMenuPropertyComponentDefaults.orientation,
         on: {
            onMenuItemClick: (id, e, node) => {
               // switch tab view
               var item = $$(ids.component).getMenuItem(id);
               if (item.type == "tab") {
                  this.changePage(item.pageId);

                  var redirectPage = this.application.pages(
                     (p) => p.id == item.pageId,
                     true
                  )[0];
                  if (!redirectPage) return;

                  var tabView = redirectPage.views(
                     (v) => v.id == item.id,
                     true
                  )[0];
                  if (!tabView) return;

                  var tab = tabView.parent;
                  if (!tab) return;

                  toggleParent(tab);
                  // if (!$$(tabView.id) || !$$(tabView.id).isVisible()) {
                  let showIt = setInterval(function () {
                     if ($$(tabView.id) && $$(tabView.id).isVisible()) {
                        clearInterval(showIt);
                        return;
                     }
                     tab.emit("changeTab", tabView.id);
                  }, 100);
                  // }
               }
               // switch page
               else {
                  this.changePage(id);
               }
            },
            onAfterRender: () => {
               const Menu = $$(ids.component);
               if (!Menu) return;
               Menu?.data.each((item) => {
                  const node = Menu.getItemNode(item.id);
                  if (!node) return;
                  // get linked page/tab info so we can use its name in the data-cy
                  const viewInfo = this.AB.definitionByID(item.id);
                  node.setAttribute(
                     "data-cy",
                     `menu-item ${viewInfo?.name} ${item.id} ${this.id}`
                  );
               });
            },
         },
         type: {
            subsign: true,
         },
      };

      if (parseInt(this.settings.menuInToolbar)) {
         var elems = [];
         var menuIncluded = false;

         // Legacy support: use old settings values if translated values are not set
         if (this.menuTextLeft == "" && this.settings.menuTextLeft) {
            this.menuTextLeft = this.settings.menuTextLeft;
         }
         if (this.menuTextCenter == "" && this.settings.menuTextCenter) {
            this.menuTextCenter = this.settings.menuTextCenter;
         }
         if (this.menuTextRight == "" && this.settings.menuTextRight) {
            this.menuTextRight = this.settings.menuTextRight;
         }

         if (
            this.settings.menuPosition &&
            this.settings.menuPosition == "left"
         ) {
            menuIncluded = true;
            elems.push(_ui);
         } else if (this.menuTextLeft && this.menuTextLeft.length) {
            let width = this.menuTextLeft.length * 15;
            elems.push({
               view: "label",
               label: this.menuTextLeft,
               align: "left",
               width: width,
            });
         } else {
            elems.push({
               view: "label",
               label: "",
               autowidth: true,
            });
         }

         if (
            this.settings.menuPosition &&
            this.settings.menuPosition == "center"
         ) {
            menuIncluded = true;
            elems.push(_ui);
         } else if (this.menuTextCenter && this.menuTextCenter.length) {
            let width = this.menuTextLeft.length * 15;
            elems.push({});
            elems.push({
               view: "label",
               label: this.menuTextCenter,
               align: "center",
               width: width,
            });
            elems.push({});
         } else {
            elems.push({
               view: "label",
               label: "",
               autowidth: true,
            });
         }

         if (
            this.settings.menuPosition &&
            this.settings.menuPosition == "right"
         ) {
            menuIncluded = true;
            elems.push(_ui);
         } else if (this.menuTextRight && this.menuTextRight.length) {
            let width = this.menuTextLeft.length * 15;
            elems.push({
               view: "label",
               label: this.menuTextRight,
               align: "right",
               width: width,
            });
         } else {
            elems.push({
               view: "label",
               label: "",
               autowidth: true,
            });
         }

         if (menuIncluded == false) {
            elems = [_ui];
         }

         _ui = {
            view: "toolbar",
            css: this.settings.menuTheme
               ? this.settings.menuTheme
               : ABViewMenuPropertyComponentDefaults.menuTheme,
            padding: this.settings.menuPadding
               ? parseInt(this.settings.menuPadding)
               : ABViewMenuPropertyComponentDefaults.menuPadding,
            elements: elems,
         };
      }

      // make sure each of our child views get .init() called
      var _init = (options) => {
         var Menu = $$(ids.component);
         if (Menu) {
            this.ClearPagesInView(Menu);
            if (this.settings.order && this.settings.order.length) {
               this.AddPagesToView(Menu, this.settings.order);
               // Force onAfterRender to fire
               Menu.refresh();
            }
         }
      };

      var toggleParent = (element) => {
         if (!element.parent) return false;
         var parentElem = element.parent;
         if (!parentElem.parent) return false;
         parentElem.parent.emit("changeTab", parentElem.id);
         toggleParent(parentElem.parent);
      };

      return {
         ui: _ui,
         init: _init,
      };
   }
};


/***/ }),

/***/ 26239:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewPage.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewPageCore = __webpack_require__(/*! ../../core/views/ABViewPageCore */ 72094);

const ABPropertyComponentDefaults = ABViewPageCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewPage extends ABViewPageCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var comp = super.editorComponent(App, mode);

      var _init = (options) => {
         comp.init(options);
      };

      return {
         ui: comp.ui,
         init: _init,
         logic: comp.logic,

         onShow: comp.onShow,
      };
   }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      _logic.permissionClick = (id, e, node, isRetry = false) => {
         var List = $$(ids.permissions);
         var item = List.getItem(id);

         List.showProgress({ type: "icon" });

         if (item.markCheckbox) {
            console.warn("ABViewPage:check for depreciated role removal here:");
            App.AB.Network.delete({
               url: "/app_builder/page/" + item.action_key + "/role",
               data: {
                  role_id: item.id,
               },
            })
               .then((data) => {
                  item.markCheckbox = false;
                  List.updateItem(id, item);
                  List.hideProgress();
               })
               .catch((err) => {
                  console.error(err);
                  if (err.code == "E_NOACTIONKEY") {
                     // if this our second time through, then display an error:
                     if (isRetry) {
                        console.error("Error Saving Permisison: ", err);
                        List.hideProgress();
                        return;
                     }

                     // in the case where no ActionKey was present,
                     // we can still mark that this is no longer connected:
                     item.markCheckbox = false;
                     List.updateItem(id, item);

                     // Now if we got here, there is an issue with the data in our
                     // Permissions.  These permissions get created when a Page is
                     // .created/saved, so let's run through our pages again and
                     // save() them
                     var allSaves = [];
                     item._view.application.pages().forEach((page) => {
                        allSaves.push(page.save());
                     });

                     // once that is all done, try this again:
                     Promise.all(allSaves).then(() => {
                        _logic.permissionClick(id, e, node, true);
                     });
                  }
               });
         } else {
            console.warn("ABViewPage:check for depreciated role operation");
            App.AB.Network.put({
               url: "/app_builder/page/" + item.action_key + "/role",
               data: {
                  role_id: item.id,
               },
            })
               .then((data) => {
                  item.markCheckbox = true;
                  List.updateItem(id, item);
                  List.hideProgress();
               })
               .catch((err) => {
                  console.error(err);
                  if (err.code == "E_NOACTIONKEY") {
                     // if this our second time through, then display an error:
                     if (isRetry) {
                        console.error("Error Saving Permisison: ", err);
                        List.hideProgress();
                        return;
                     }

                     // Now if we got here, there is an issue with the data in our
                     // Permissions.  These permissions get created when a Page is
                     // .created/saved, so let's run through our pages again and
                     // save() them
                     var allSaves = [];
                     item._view.application.pages().forEach((page) => {
                        allSaves.push(page.save());
                     });

                     // once that is all done, try this again:
                     Promise.all(allSaves).then(() => {
                        _logic.permissionClick(id, e, node, true);
                     });
                  }
               });
         }
      };

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "type",
            view: "richselect",
            label: L("Type"),
            options: [
               { id: "page", value: L("Page") },
               { id: "popup", value: L("Popup") },
            ],
            on: {
               onChange: function (newv, oldv) {
                  if (newv == "page") {
                     $$(ids.popupSettings).hide();
                     $$(ids.pageSettings).show();
                  } else {
                     $$(ids.popupSettings).show();
                     $$(ids.pageSettings).hide();
                  }
               },
            },
         },
         {
            view: "fieldset",
            name: "popupSettings",
            label: L("Popup Settings"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "text",
                     name: "popupWidth",
                     placeholder: L("Set popup width"),
                     label: L("Width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     validate: webix.rules.isNumber,
                  },
                  {
                     view: "text",
                     name: "popupHeight",
                     placeholder: L("Set popup height"),
                     label: L("Height:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     validate: webix.rules.isNumber,
                  },
               ],
            },
         },
         {
            view: "fieldset",
            name: "pageSettings",
            label: L("Page Settings"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     view: "checkbox",
                     name: "fixedPageWidth",
                     labelRight: L("Page has fixed width"),
                     labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
                     click: function (id, event) {
                        if (this.getValue() == 1) {
                           $$(ids.pageWidth).show();
                        } else {
                           $$(ids.pageWidth).hide();
                        }
                     },
                  },
                  {
                     view: "text",
                     name: "pageWidth",
                     placeholder: L("Set page width"),
                     label: L("Page width:"),
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                  },
                  {
                     view: "richselect",
                     name: "pageBackground",
                     label: L("Page background:"),
                     labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                     options: [
                        {
                           id: "ab-background-default",
                           value: L("White (default)"),
                        },
                        {
                           id: "ab-background-gray",
                           value: L("Dark"),
                        },
                        // { "id":"ab-background-texture", "value":L('ab.component.page.pageBackgroundTextured', '*Textured')}
                     ],
                  },
               ],
            },
         },
         {
            view: "fieldset",
            name: "pagePermissionPanel",
            label: L("Page Permissions:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            body: {
               type: "clean",
               padding: 10,
               rows: [
                  {
                     name: "permissions",
                     view: "list",
                     select: false,
                     minHeight: 200,
                     template: "{common.markCheckbox()} #name#",
                     type: {
                        markCheckbox: function (obj) {
                           return `<span class='check webix_icon fa fa-${
                              obj.markCheckbox ? "check-" : ""
                           }square-o'></span>`;
                        },
                     },
                     on: {
                        onItemClick: function (id, e, node) {
                           _logic.permissionClick(id, e, node);
                        },
                     },
                  },
               ],
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view, logic) {
      super.propertyEditorPopulate(App, ids, view, logic);

      $$(ids.type).setValue(
         view.settings.type || ABPropertyComponentDefaults.type
      );
      $$(ids.popupWidth).setValue(
         view.settings.popupWidth || ABPropertyComponentDefaults.popupWidth
      );
      $$(ids.popupHeight).setValue(
         view.settings.popupHeight || ABPropertyComponentDefaults.popupHeight
      );
      $$(ids.pageWidth).setValue(
         view.settings.pageWidth || ABPropertyComponentDefaults.pageWidth
      );
      $$(ids.fixedPageWidth).setValue(
         view.settings.fixedPageWidth ||
            ABPropertyComponentDefaults.fixedPageWidth
      );
      $$(ids.pageBackground).setValue(
         view.settings.pageBackground ||
            ABPropertyComponentDefaults.pageBackground
      );

      // Disable select type of page when this page is root
      if (view.isRoot()) {
         $$(ids.type).hide();

         // Update permission options
         $$(ids.pagePermissionPanel).show();
         this.propertyUpdatePermissionsOptions(ids, view);
      } else {
         $$(ids.pagePermissionPanel).hide();
         $$(ids.type).show();
      }

      if (view.settings.type == "popup") {
         $$(ids.popupSettings).show();
         $$(ids.pageSettings).hide();
      } else {
         $$(ids.popupSettings).hide();
         $$(ids.pageSettings).show();
      }

      if (view.settings.fixedPageWidth == 1) {
         $$(ids.pageWidth).show();
      } else {
         $$(ids.pageWidth).hide();
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.type = $$(ids.type).getValue();
      view.settings.popupWidth = $$(ids.popupWidth).getValue();
      view.settings.popupHeight = $$(ids.popupHeight).getValue();
      view.settings.pageWidth = $$(ids.pageWidth).getValue();
      view.settings.fixedPageWidth = $$(ids.fixedPageWidth).getValue();
      view.settings.pageBackground = $$(ids.pageBackground).getValue();
   }

   /**
    * @method propertyUpdatePermissionsOptions
    * Populate permissions of Ops Portal to select list in property
    *
    */
   static propertyUpdatePermissionsOptions(ids, view) {
      var action_key = this.getPageActionKey(view);
      var roles = [];

      var List = $$(ids.permissions);

      // make sure our list has been made into a ProgressBar
      if (!List.showProgress) {
         webix.extend(List, webix.ProgressBar);
      }

      List.clearAll();
      List.showProgress({ type: "icon" });

      console.error(
         "ABViewPage: check for depreciated Permission checks here."
      );
      view.application
         .getPermissions()
         .then(function (selected_role_ids) {
            var app_roles = selected_role_ids;

            view.AB.Network.get({
               url: "/app_builder/page/" + action_key + "/role",
            }).then((data) => {
               var selectedRoles = [];
               data.selected.forEach((s) => {
                  selectedRoles.push(s.id);
               });

               data.roles.forEach((r) => {
                  if (app_roles.indexOf(r.id) != -1) {
                     if (selectedRoles.indexOf(r.id) != -1) {
                        r.markCheckbox = true;
                     } else {
                        r.markCheckbox = false;
                     }
                     r.action_key = action_key;
                     r._view = view;
                     roles.push(r);
                  }
               });

               roles = view.AB.orderBy(roles, "id", "asc");

               List.parse(roles);
               List.hideProgress();
            });
         })
         .catch(function (err) {
            List.hideProgress();

            console.error(err);
         });
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var comp = super.component(App);
      var _ui = {
         view: "scrollview",
         borderless: true,
         css:
            this.settings.pageBackground ||
            ABPropertyComponentDefaults.pageBackground,
         body: comp.ui,
      };

      var _init = (options) => {
         var accessLevel = this.getUserAccess();
         comp.init(options, accessLevel);
      };

      return {
         ui: _ui,
         init: _init,
         logic: comp.logic,

         onShow: comp.onShow,
      };
   }
};


/***/ }),

/***/ 71227:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewPivot.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewPivotCore = __webpack_require__(/*! ../../core/views/ABViewPivotCore */ 57766);
const ABFieldCalculate = __webpack_require__(/*! ../dataFields/ABFieldCalculate */ 43088);
const ABFieldFormula = __webpack_require__(/*! ../dataFields/ABFieldFormula */ 58439);
const ABFieldNumber = __webpack_require__(/*! ../dataFields/ABFieldNumber */ 41812);
const ABObjectQuery = __webpack_require__(/*! ../ABObjectQuery */ 88447);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewPivot extends ABViewPivotCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewPivotEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var componentBase = this.component(App);
      var component = App.AB.cloneDeep(componentBase);

      component.ui.id = ids.component;
      component.ui.readonly = false;
      component.ui.on = {
         onBeforeApply: (structure) => {
            this.settings.structure = structure;
            this.save();
         },
      };

      component.init = (options) => {
         componentBase.init({
            componentId: ids.component,
         });
      };

      return component;
   }

   //
   // Property Editor
   //

   // static propertyEditorComponent(App) {
   // 	return ABViewPropertyComponent.component(App);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      let commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      return commonUI.concat([
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            view: "checkbox",
            name: "removeMissed",
            labelRight: L("Remove empty data."),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "checkbox",
            name: "totalColumn",
            labelRight: L("Show a total column."),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "checkbox",
            name: "separateLabel",
            labelRight: L("Separate header label."),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "checkbox",
            name: "min",
            labelRight: L(
               "Highlighting of a cell(s) with the least value in a row."
            ),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "checkbox",
            name: "max",
            labelRight: L(
               "Highlighting of a cell(s) with the biggest value in a row."
            ),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            name: "decimalPlaces",
            view: "counter",
            min: 1,
            label: L("Decimal Places"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      var datacollectionId = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;
      var SourceSelector = $$(ids.datacollection);

      // Pull data collections to options
      var dcOptions = view.propertyDatacollections();
      SourceSelector.define("options", dcOptions);
      SourceSelector.define("value", datacollectionId);
      SourceSelector.refresh();

      $$(ids.removeMissed).setValue(view.settings.removeMissed);
      $$(ids.totalColumn).setValue(view.settings.totalColumn);
      $$(ids.separateLabel).setValue(view.settings.separateLabel);
      $$(ids.min).setValue(view.settings.min);
      $$(ids.max).setValue(view.settings.max);
      $$(ids.height).setValue(view.settings.height);
      $$(ids.decimalPlaces).setValue(
         view.settings.decimalPlaces == null ? 2 : view.settings.decimalPlaces
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();

      view.settings.removeMissed = $$(ids.removeMissed).getValue();
      view.settings.totalColumn = $$(ids.totalColumn).getValue();
      view.settings.separateLabel = $$(ids.separateLabel).getValue();
      view.settings.min = $$(ids.min).getValue();
      view.settings.max = $$(ids.max).getValue();
      view.settings.height = $$(ids.height).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseCom = super.component(App);

      var idBase = `ABViewPivot_${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      // an ABViewLabel is a simple Label
      var _ui = {
         id: ids.component,
         view: "pivot",
         readonly: true,
         removeMissed: this.settings.removeMissed,
         totalColumn: this.settings.totalColumn,
         separateLabel: this.settings.separateLabel,
         min: this.settings.min,
         max: this.settings.max,
         format: (value) => {
            let decimalPlaces = this.settings.decimalPlaces || 2;
            return value && value != "0"
               ? parseFloat(value).toFixed(decimalPlaces || 0)
               : value;
         },
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {
         options = options || {};
         options.componentId = options.componentId || ids.component;

         let dc = this.datacollection;
         if (!dc) return Promise.resolve();

         let object = dc.datasource;
         if (!object) return Promise.resolve();

         let $pivotComp = $$(ids.component);
         if ($pivotComp && object instanceof ABObjectQuery) {
            let customLabels = {};
            object.fields().forEach((f) => {
               customLabels[f.columnName] = f.label;
            });

            $pivotComp.define("fieldMap", customLabels);
         }

         let populateData = () => {
            let data = dc.getData();
            let dataMapped = data.map((d) => {
               let result = {};

               object.fields().forEach((f) => {
                  if (
                     f instanceof ABFieldCalculate ||
                     f instanceof ABFieldFormula ||
                     f instanceof ABFieldNumber
                  )
                     result[f.columnName] = d[f.columnName];
                  else result[f.columnName] = f.format(d);
               });

               return result;
            });

            $$(options.componentId).parse(dataMapped);

            // set pivot configuration
            if (this.settings.structure)
               $$(options.componentId).setStructure(this.settings.structure);
         };

         this.eventAdd({
            emitter: dc,
            eventName: "initializedData",
            listener: () => {
               populateData();
            },
         });

         return (
            Promise.resolve()
               // get data
               .then(() => {
                  return new Promise((next, err) => {
                     switch (dc.dataStatus) {
                        case dc.dataStatusFlag.notInitial:
                           dc.loadData();
                           break;
                        case dc.dataStatusFlag.initialized:
                           next();
                           break;
                     }
                  });
               })

               // populate data into pivot
               .then(() => {
                  return new Promise((next, err) => {
                     populateData();
                     next();
                  });
               })
         );
      };

      return {
         ui: _ui,
         init: _init,

         onShow: baseCom.onShow,
      };
   }
};


/***/ }),

/***/ 41226:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewReportsManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewReportsManagerCore = __webpack_require__(/*! ../../core/views/ABViewReportsManagerCore */ 35154);

module.exports = class ABViewReportsManager extends ABViewReportsManagerCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      let idBase = "ABViewReportsManagerEditorComponent";
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      let component = this.component(App);

      component.ui.id = ids.component;

      component.init = (options) => {};

      return component;
   }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      return commonUI.concat([]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.dataviewID = $$(ids.datacollection).getValue();
   }

   /*
    * @component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let baseCom = super.component(App);

      let idBase = `ABViewReportManager_${this.id}`;
      let ids = {
         component: App.unique(`${idBase}_component`),
      };

      let compInstance = this;

      let _ui = {
         id: ids.component,
         view: "reports",
         toolbar: true,
         override: new Map([
            [
               reports.services.Backend,
               class MyBackend extends reports.services.Backend {
                  getModules() {
                     return Promise.resolve(
                        compInstance.settings.moduleList || []
                     );
                  }
                  saveModule(id, data) {
                     id = id || webix.uid();
                     compInstance.settings.moduleList =
                        compInstance.settings.moduleList || [];

                     let indexOfModule = null;
                     let module = compInstance.settings.moduleList.filter(
                        (m, index) => {
                           let isExists = m.id == id;
                           if (isExists) indexOfModule = index;

                           return isExists;
                        }
                     )[0];

                     // Update
                     if (module) {
                        compInstance.settings.moduleList[indexOfModule] = data;
                     }
                     // Add
                     else {
                        compInstance.settings.moduleList.push(data);
                     }

                     return new Promise((resolve, reject) => {
                        compInstance
                           .save()
                           .catch(reject)
                           .then(() => {
                              resolve({ id: id });
                           });
                     });
                  }
                  deleteModule(id) {
                     compInstance.settings.moduleList =
                        compInstance.settings.moduleList || [];

                     compInstance.settings.moduleList = compInstance.settings.moduleList.filter(
                        (m) => m.id != id
                     );

                     return new Promise((resolve, reject) => {
                        compInstance
                           .save()
                           .catch(reject)
                           .then(() => {
                              resolve({ id: id });
                           });
                     });
                  }

                  getModels() {
                     let reportModels = {};

                     (compInstance.AB.datacollections() || []).forEach((dc) => {
                        let obj = dc.datasource;
                        if (!obj) return;

                        let reportFields = _logic.getReportFields(dc);

                        // get connected data collections
                        // let linkedFields = [];
                        // (obj.connectFields() || []).forEach((f, index) => {
                        //    let connectedDcs = compInstance.AB.datacollections(
                        //       (dColl) =>
                        //          dColl &&
                        //          dColl.datasource &&
                        //          dColl.datasource.id == f.settings.linkObject
                        //    );
                        //    (connectedDcs || []).forEach((linkedDc) => {
                        //       linkedFields.push({
                        //          id: index + 1,
                        //          name: linkedDc.label,
                        //          source: dc.id,
                        //          target: linkedDc.id
                        //       });
                        //    });
                        // });

                        // // MOCK UP for testing
                        // let linkedFields = [
                        //    {
                        //       id: "id",
                        //       name: "id",
                        //       source: "39378ee0-38f0-4b9d-a5aa-dddc61137fcd", // Player
                        //       target: "0de82362-4ab5-4f0f-8cfa-d1288d173cba" // Team
                        //    }
                        // ];

                        reportModels[dc.id] = {
                           id: dc.id,
                           name: dc.label,
                           data: reportFields,
                           refs: [],
                        };
                     });

                     return Promise.resolve(reportModels);
                  }

                  getQueries() {
                     return Promise.resolve(
                        compInstance.settings.queryList || []
                     );
                  }
                  saveQuery(id, data) {
                     id = id || webix.uid();
                     compInstance.settings.queryList =
                        compInstance.settings.queryList || [];

                     let indexOfQuery = null;
                     let query = compInstance.settings.queryList.filter(
                        (m, index) => {
                           let isExists = m.id == id;
                           if (isExists) indexOfQuery = index;

                           return isExists;
                        }
                     )[0];

                     // Update
                     if (query) {
                        compInstance.settings.queryList[indexOfQuery] = data;
                     }
                     // Add
                     else {
                        compInstance.settings.queryList.push(data);
                     }

                     return new Promise((resolve, reject) => {
                        compInstance
                           .save()
                           .catch(reject)
                           .then(() => {
                              resolve({ id: id });
                           });
                     });
                  }
                  deleteQuery(id) {
                     compInstance.settings.queryList =
                        compInstance.settings.queryList || [];

                     compInstance.settings.queryList = compInstance.settings.queryList.filter(
                        (m) => m.id != id
                     );

                     return new Promise((resolve, reject) => {
                        compInstance
                           .save()
                           .catch(reject)
                           .then(() => {
                              resolve({ id: id });
                           });
                     });
                  }

                  getData(config) {
                     let result = [];
                     let pullDataTasks = [];
                     let dcIds = [];
                     let dcData = {};
                     let reportFields = [];

                     // pull data of the base and join DCs
                     dcIds.push(config.data);
                     (config.joins || []).forEach((j) => {
                        dcIds.push(j.sid);
                        dcIds.push(j.tid);
                     });
                     dcIds = compInstance.AB.uniq(dcIds);
                     dcIds.forEach((dcId) => {
                        pullDataTasks.push(
                           new Promise((next, bad) => {
                              _logic
                                 .getData(dcId)
                                 .catch(bad)
                                 .then((data) => {
                                    dcData[dcId] = data || [];
                                    next();
                                 });
                           })
                        );
                     });

                     dcIds.forEach((dcId) => {
                        let dataCol = compInstance.AB.datacollectionByID(dcId);
                        if (!dataCol) return;

                        reportFields = reportFields.concat(
                           _logic.getReportFields(dataCol).map((f) => {
                              // change format of id to match the report widget
                              f.id = `${dcId}.${f.id}`; // dc_id.field_id
                              return f;
                           })
                        );
                     });

                     return (
                        Promise.resolve()
                           .then(() => Promise.all(pullDataTasks))
                           .then(
                              () =>
                                 new Promise((next, bad) => {
                                    // the data result equals data of the base DC
                                    result = dcData[config.data] || [];

                                    // no join settings
                                    if (!config.joins || !config.joins.length) {
                                       return next();
                                    }

                                    (config.joins || []).forEach((j) => {
                                       let sourceDc = compInstance.AB.datacollectionByID(
                                          j.sid
                                       );
                                       if (!sourceDc) return;

                                       let sourceObj = sourceDc.datasource;
                                       if (!sourceObj) return;

                                       let targetDc = compInstance.AB.datacollectionByID(
                                          j.tid
                                       );
                                       if (!targetDc) return;

                                       let targetObj = targetDc.datasource;
                                       if (!targetObj) return;

                                       let sourceLinkField = sourceObj.fieldByID(
                                          j.sf
                                       );
                                       let targetLinkField = targetObj.fieldByID(
                                          j.tf
                                       );
                                       if (!sourceLinkField && !targetLinkField)
                                          return;

                                       let sourceData = dcData[j.sid] || [];
                                       let targetData = dcData[j.tid] || [];
                                       sourceData.forEach((sData) => {
                                          targetData.forEach((tData) => {
                                             let sVal =
                                                sData[
                                                   sourceLinkField
                                                      ? `${j.sid}.${sourceLinkField.columnName}.id`
                                                      : `${j.sid}.id`
                                                ] || [];

                                             let tVal =
                                                tData[
                                                   targetLinkField
                                                      ? `${j.tid}.${targetLinkField.columnName}.id`
                                                      : `${j.tid}.id`
                                                ] || [];

                                             if (!Array.isArray(sVal))
                                                sVal = [sVal];
                                             if (!Array.isArray(tVal))
                                                tVal = [tVal];

                                             // Add joined row to the result array
                                             let matchedVal = sVal.filter(
                                                (val) => tVal.indexOf(val) > -1
                                             );
                                             if (
                                                matchedVal &&
                                                matchedVal.length
                                             ) {
                                                let updateRows =
                                                   result.filter(
                                                      (r) =>
                                                         r[`${j.sid}.id`] ==
                                                            sData[
                                                               `${j.sid}.id`
                                                            ] &&
                                                         r[`${j.tid}.id`] ==
                                                            null
                                                   ) || [];

                                                if (
                                                   updateRows &&
                                                   updateRows.length
                                                ) {
                                                   (updateRows || []).forEach(
                                                      (r) => {
                                                         for (let key in tData) {
                                                            if (key != "id")
                                                               r[key] =
                                                                  tData[key];
                                                         }
                                                      }
                                                   );
                                                } else {
                                                   result.push(
                                                      Object.assign(
                                                         compInstance.AB.cloneDeep(
                                                            sData
                                                         ),
                                                         compInstance.AB.cloneDeep(
                                                            tData
                                                         )
                                                      )
                                                   );
                                                }
                                             }
                                          });
                                       });
                                    });

                                    next();
                                 })
                           )
                           // filter & sort
                           .then(
                              () =>
                                 new Promise((next, bad) => {
                                    let queryVal;
                                    try {
                                       queryVal = JSON.parse(
                                          config.query || "{}"
                                       );
                                    } catch (err) {
                                       bad(err);
                                    }

                                    if (
                                       queryVal &&
                                       queryVal.rules &&
                                       queryVal.rules.length
                                    ) {
                                       queryVal.rules.forEach((r) => {
                                          if (!r || !r.type || !r.condition)
                                             return;

                                          switch (r.type) {
                                             case "date":
                                             case "datetime":
                                                // Convert string to Date object
                                                if (r.condition.filter) {
                                                   if (
                                                      this.AB.isString(
                                                         r.condition.filter
                                                      )
                                                   ) {
                                                      r.condition.filter = this.AB.toDate(
                                                         r.condition.filter
                                                      );
                                                   }

                                                   if (
                                                      r.condition.filter
                                                         .start &&
                                                      this.AB.isString(
                                                         r.condition.filter
                                                            .start
                                                      )
                                                   ) {
                                                      r.condition.filter.start = this.AB.toDate(
                                                         r.condition.filter
                                                            .start
                                                      );
                                                   }

                                                   if (
                                                      r.condition.filter.end &&
                                                      this.AB.isString(
                                                         r.condition.filter.end
                                                      )
                                                   ) {
                                                      r.condition.filter.end = this.AB.toDate(
                                                         r.condition.filter.end
                                                      );
                                                   }
                                                }
                                                break;
                                          }
                                       });
                                    }

                                    // create a new query widget to get the filter function
                                    let filterElem = webix.ui({
                                       view: "query",
                                       fields: reportFields,
                                       value: queryVal,
                                    });

                                    // create a new data collection and apply the query filter
                                    let tempDc = new webix.DataCollection();
                                    tempDc.parse(result);

                                    // filter
                                    let filterFn;
                                    try {
                                       filterFn = filterElem.getFilterFunction();
                                    } catch (error) {
                                       // continue regardless of error
                                    }
                                    if (filterFn) tempDc.filter(filterFn);

                                    // sorting
                                    (config.sort || []).forEach((sort) => {
                                       if (sort.id)
                                          tempDc.sort({
                                             as: "string",
                                             dir: sort.mod || "asc",
                                             by: `#${sort.id}#`,
                                          });
                                    });

                                    result = tempDc.serialize();

                                    // clear
                                    filterElem.destructor();
                                    tempDc.destructor();

                                    // group by
                                    if (config.group && config.group.length) {
                                       (config.group || []).forEach(
                                          (groupProp) => {
                                             result = _(result).groupBy(
                                                groupProp
                                             );
                                          }
                                       );

                                       result = result
                                          .map((groupedData, id) => {
                                             let groupedResult = {};

                                             (config.columns || []).forEach(
                                                (col) => {
                                                   let agg = col.split(".")[0];
                                                   let rawCol = col.replace(
                                                      /sum.|avg.|count.|max.|min./g,
                                                      ""
                                                   );

                                                   switch (agg) {
                                                      case "sum":
                                                         groupedResult[
                                                            col
                                                         ] = compInstance.AB.sumBy(
                                                            groupedData,
                                                            rawCol
                                                         );
                                                         break;
                                                      case "avg":
                                                         groupedResult[
                                                            col
                                                         ] = compInstance.AB.meanBy(
                                                            groupedData,
                                                            rawCol
                                                         );
                                                         break;
                                                      case "count":
                                                         groupedResult[col] = (
                                                            groupedData || []
                                                         ).length;
                                                         break;
                                                      case "max":
                                                         groupedResult[col] =
                                                            (compInstance.AB.maxBy(
                                                               groupedData,
                                                               rawCol
                                                            ) || {})[rawCol] ||
                                                            "";
                                                         break;
                                                      case "min":
                                                         groupedResult[col] =
                                                            (compInstance.AB.minBy(
                                                               groupedData,
                                                               rawCol
                                                            ) || {})[rawCol] ||
                                                            "";
                                                         break;
                                                      default:
                                                         groupedResult[col] =
                                                            groupedData[0][col];
                                                         break;
                                                   }
                                                }
                                             );

                                             return groupedResult;
                                          })
                                          .value();
                                    }

                                    next();
                                 })
                           )
                           .then(() => Promise.resolve(result))
                     );
                  }
                  getOptions(fields) {
                     // TODO
                     // [
                     //    {"id":"1","value":"South"},
                     //    {"id":"2","value":"North"},
                     //    // other options
                     //  ]
                     return Promise.resolve([]);
                  }
                  getFieldData(fieldId) {
                     // TODO
                     return Promise.resolve([]);
                  }
               },
            ],
            [
               reports.views.table,
               class MyTable extends reports.views.table {
                  // NOTE: fix format of date column type
                  GetColumnConfig(a) {
                     if (a.type === "date") {
                        return {
                           id: a.id,
                           header:
                              !a.meta.header || a.meta.header === "none"
                                 ? a.meta.name || a.name
                                 : [
                                      a.meta.name || a.name,
                                      {
                                         content:
                                            a.header === "text"
                                               ? "textFilter"
                                               : "richSelectFilter",
                                      },
                                   ],
                           type: a.type,
                           sort: "date",
                           width: a.width || 200,
                           format: (val) => {
                              // check valid date
                              if (val && val.getTime && !isNaN(val.getTime())) {
                                 return webix.i18n.dateFormatStr(val);
                              } else {
                                 return "";
                              }
                           },
                        };
                     } else {
                        return super.GetColumnConfig(a);
                     }
                  }
               },
            ],
         ]),
      };

      // make sure each of our child views get .init() called
      let _init = (options) => {
         options = options || {};
         options.componentId = options.componentId || ids.component;

         return Promise.resolve();
      };

      let _logic = {
         getReportFields: (dc) => {
            if (!dc) return [];

            let object = dc.datasource;
            if (!object) return [];

            let fields = [];

            object.fields().forEach((f) => {
               let columnFormat = f.columnHeader();

               fields.push({
                  id: f.columnName,
                  name: f.label,
                  filter: f.fieldIsFilterable(),
                  edit: false,
                  type: columnFormat.editor || "text",
                  format: columnFormat.format,
                  options: columnFormat.options,
                  ref: "",
                  key: false,
                  show: true,
                  abField: f,
               });

               if (f.isConnection && f.settings.isSource) {
                  let linkedDcs = compInstance.AB.datacollectionByID(f.settings.linkObject);
                  (linkedDcs || []).forEach((linkDc) => {
                     fields.push({
                        id: f.id,
                        name: f.label,
                        filter: false,
                        edit: false,
                        type: "reference",
                        ref: linkDc.id,
                        key: false,
                        show: false,
                     });
                  });
               }
            });

            return fields;
         },

         getData: (datacollectionId) => {
            let datacollection = compInstance.AB.datacollectionByID(
               datacollectionId
            );
            if (!datacollection) return Promise.resolve([]);

            let object = datacollection.datasource;
            if (!object) return Promise.resolve([]);

            return Promise.resolve()
               .then(
                  () =>
                     new Promise((next, bad) => {
                        if (
                           datacollection.dataStatus ==
                           datacollection.dataStatusFlag.notInitial
                        ) {
                           datacollection
                              .loadData()
                              .catch(bad)
                              .then(() => next());
                        } else {
                           next();
                        }
                     })
               )
               .then(
                  () =>
                     new Promise((next, bad) => {
                        let reportFields = _logic.getReportFields(
                           datacollection
                        );

                        let reportData = [];
                        let rawData = datacollection.getData();
                        (rawData || []).forEach((row) => {
                           let reportRow = { id: row.id };
                           reportRow[`${datacollection.id}.id`] = row.id;

                           object.fields().forEach((field) => {
                              let columnName = field.columnName;
                              let col = `${datacollection.id}.${columnName}`;

                              reportRow[col] = field
                                 ? field.format(row)
                                 : row[columnName];

                              // FK value of the connect field
                              if (field && field.isConnection) {
                                 if (Array.isArray(row[columnName])) {
                                    reportRow[`${col}.id`] = row[
                                       columnName
                                    ].map(
                                       (link) =>
                                          link[field.datasourceLink.PK()] ||
                                          link.id ||
                                          link
                                    );
                                 } else if (row[columnName]) {
                                    reportRow[`${col}.id`] =
                                       row[columnName][
                                          field.datasourceLink.PK()
                                       ] ||
                                       row[columnName].id ||
                                       row[columnName];
                                 }
                              }

                              let rField = reportFields.filter(
                                 (f) => f.id == columnName
                              )[0];
                              if (!rField) return;

                              switch (rField.type) {
                                 case "text":
                                 case "reference":
                                    reportRow[col] = (
                                       reportRow[col] || ""
                                    ).toString();
                                    break;
                                 case "number":
                                    reportRow[col] = parseFloat(
                                       (reportRow[col] || 0)
                                          .toString()
                                          .replace(/[^\d.-]/g, "")
                                    );
                                    break;
                                 case "date":
                                 case "datetime":
                                    reportRow[col] = row[columnName];
                                    if (reportRow[col]) {
                                       if (!(reportRow[col] instanceof Date)) {
                                          reportRow[
                                             col
                                          ] = compInstance.AB.toDate(
                                             row[columnName]
                                          );
                                       }
                                    } else {
                                       reportRow[col] = "";
                                    }
                                    break;
                              }
                           });
                           reportData.push(reportRow);
                        });

                        return next(reportData);
                     })
               );
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: baseCom.onShow,
      };
   }
};


/***/ }),

/***/ 12235:
/*!************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewTab.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewTabCore = __webpack_require__(/*! ../../core/views/ABViewTabCore */ 56463);

const ABViewTabPropertyComponentDefaults = ABViewTabCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewTab extends ABViewTabCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      var idBase = "ABViewTabEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
         view: App.unique(`${idBase}_view`),
      };
      var component = this.component(App);

      var tabElem = component.ui;

      if (tabElem.rows) {
         tabElem.rows[0].id = ids.component;
         tabElem.rows[0].tabbar = {
            height: 60,
            type: "bottom",
            css: this.settings.darkTheme ? "webix_dark" : "",
            on: {
               onItemClick: (id, e) => {
                  var tabId = $$(ids.component).getValue(),
                     tab = this.views((v) => v.id == tabId)[0],
                     currIndex = this._views.findIndex((v) => v.id == tabId);

                  // Rename
                  if (e.target.classList.contains("rename")) {
                     ABViewTab.popupShow(tab);
                  }
                  // Reorder back
                  else if (e.target.classList.contains("move-back")) {
                     this.viewReorder(tabId, currIndex - 1);

                     // refresh editor view
                     this.emit("properties.updated", this);
                  }
                  // Reorder next
                  else if (e.target.classList.contains("move-next")) {
                     this.viewReorder(tabId, currIndex + 1);

                     // refresh editor view
                     this.emit("properties.updated", this);
                  }
               },
            },
         };

         // Add action buttons
         if (tabElem.rows[0].cells && tabElem.rows[0].cells.length > 0) {
            tabElem.rows[0].cells.forEach((tabView) => {
               // Add 'move back' icon
               tabView.header =
                  '<i class="fa fa-caret-left move-back ab-tab-back"></i>' +
                  tabView.header;
               // Add 'edit' icon
               tabView.header +=
                  ' <i class="fa fa-pencil-square rename ab-tab-edit"></i>';
               // Add 'move next' icon
               tabView.header +=
                  ' <i class="fa fa-caret-right move-next ab-tab-next"></i>';
            });
         }
      } else if (tabElem.cols) {
         // if we detect colums we are using sidebar and need to format the onItemClick event differently
         var viewIndex = 1;
         var tabIndex = 0;

         if (this.settings.sidebarPos == "right") {
            // the sidebar is in the second column now so we need to reference it properly
            viewIndex = 0;
            tabIndex = 1;
         }

         tabElem.cols[viewIndex].id = ids.component;
         tabElem.cols[tabIndex].on = {
            onItemClick: (id, e) => {
               var tabId = id.replace("_menu", ""),
                  tab = this.views((v) => v.id == tabId)[0],
                  currIndex = this._views.findIndex((v) => v.id == tabId);

               component.onShow(tabId);

               // Rename
               if (e.target.classList.contains("rename")) {
                  ABViewTab.popupShow(tab);
               }
               // Reorder back
               else if (e.target.classList.contains("move-back")) {
                  this.viewReorder(tabId, currIndex - 1);

                  // refresh editor view
                  this.emit("properties.updated", this);
               }
               // Reorder next
               else if (e.target.classList.contains("move-next")) {
                  this.viewReorder(tabId, currIndex + 1);

                  // refresh editor view
                  this.emit("properties.updated", this);
               }
            },
         };

         // Add action buttons
         if (
            tabElem.cols[tabIndex].data &&
            tabElem.cols[tabIndex].data.length > 0
         ) {
            tabElem.cols[tabIndex].data.forEach((sidebarItem) => {
               // Add 'edit' icon
               sidebarItem.value =
                  sidebarItem.value +
                  ' <i class="fa fa-pencil-square rename ab-tab-edit"></i>';
               // Add 'move up' icon
               sidebarItem.value +=
                  '<i class="fa fa-caret-up move-back ab-tab-up"></i>';
               // Add 'move down' icon
               sidebarItem.value +=
                  ' <i class="fa fa-caret-down move-next ab-tab-down"></i>';
            });
         }
      }

      var _ui = {
         rows: [tabElem],
      };

      var _init = (options) => {
         component.init(options);

         // Add actions buttons - Edit , Delete
         if ($$(ids.component) && $$(ids.component).config.view == "tabview") {
            webix.ui({
               container: $$(ids.component).getMultiview().$view,
               view: "template",
               autoheight: false,
               height: 1,
               width: 0,
               template:
                  '<div class="ab-component-tools ab-layout-view ab-tab-tools">' +
                  '<i class="fa fa-trash ab-component-remove"></i>' +
                  '<i class="fa fa-edit ab-component-edit"></i>' +
                  "</div>",
               onClick: {
                  "ab-component-edit": function (e, id, trg) {
                     _logic.tabEdit(e, id, trg);
                  },
                  "ab-component-remove": function (e, id, trg) {
                     _logic.tabRemove(e, id, trg);
                  },
               },
            });
         } else if (
            $$(ids.component) &&
            $$(ids.component).config.view == "multiview"
         ) {
            webix.ui({
               container: $$(ids.component).$view,
               view: "template",
               autoheight: false,
               height: 1,
               width: 0,
               template:
                  '<div class="ab-component-tools ab-layout-view ab-tab-tools">' +
                  '<i class="fa fa-trash ab-component-remove"></i>' +
                  '<i class="fa fa-edit ab-component-edit"></i>' +
                  "</div>",
               onClick: {
                  "ab-component-edit": function (e, id, trg) {
                     _logic.tabEdit(e, id, trg);
                  },
                  "ab-component-remove": function (e, id, trg) {
                     _logic.tabRemove(e, id, trg);
                  },
               },
            });
         }

         component.onShow();
      };

      var _logic = {
         // templateBlock: (tab) => {
         // 	var _template = [
         // 		'<div class="ab-component-in-page">',
         // 		'<div id="' + ids.view + '_#objID#" >',
         // 		'<i class="fa fa-#icon#"></i>',
         // 		' #label#',
         // 		'</div>',
         // 		'</div>'
         // 	].join('');

         // 	return _template
         // 		.replace('#objID#', tab.id)
         // 		.replace('#icon#', tab.icon)
         // 		.replace('#label#', tab.label);
         // },

         tabEdit: (e, nodeId, trg) => {
            var tabId = $$(ids.component).getValue();
            var view = this.views(function (v) {
               return v.id == tabId;
            })[0];

            if (!view) return false;

            // NOTE: let webix finish this onClick event, before
            // calling .populateInterfaceWorkspace() which will replace
            // the interface elements with the edited view.  (apparently
            // that causes errors.)
            setTimeout(() => {
               console.error("ABViewTab: refactor .actions to .emit");
               App.actions.populateInterfaceWorkspace(view);
            }, 50);

            e.preventDefault();
            return false;
         },

         tabRemove: (e, nodeId, trg) => {
            var tabId = $$(ids.component).getValue();
            var deletedView = this.views((v) => v.id == tabId)[0];
            if (deletedView) {
               webix.confirm({
                  title: L("Delete tab"),
                  text: L("Do you want to delete <b>{0}</b>?", [
                     deletedView.label,
                  ]),
                  callback: (result) => {
                     if (result) {
                        // this.viewDestroy(deletedView);
                        deletedView.destroy();

                        // remove tab option
                        $$(ids.component).removeView(tabId);
                     }
                  },
               });
            }

            e.preventDefault();
            return false;
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   static addTab(ids, _logic, tabName, tabIcon) {
      // get current instance and .addTab()
      var LayoutView = _logic.currentEditObject();
      return LayoutView.addTab(tabName, tabIcon);

      // trigger a save()
      // this.propertyEditorSave(ids, LayoutView);
   }

   static editTab(ids, _logic, tabId, tabName, tabIcon) {
      // get current instance and rename tab
      var LayoutView = _logic.currentEditObject();
      var editedTab = LayoutView.views((v) => v.id == tabId)[0];

      if (!editedTab) return;

      editedTab.label = tabName;
      editedTab.tabicon = tabIcon;

      // trigger a save()
      // this.propertyEditorSave(ids, LayoutView);
      return editedTab.save();
   }

   static popupShow(tab) {
      var popup = $$("ab-component-tab-add-new-tab-popup");
      var form = $$("ab-component-tab-add-new-tab-form");
      var button = $$("ab-component-tab-save-button");

      if (popup) {
         // Edit tab
         if (tab) {
            form.setValues({
               id: tab.id,
               label: tab.label,
               tabicon: tab.tabicon,
            });

            popup.getHead().setHTML(L("Edit Tab"));
            button.setValue(L("Save"));
         }
         // Add new tab
         else {
            form.setValues({
               id: null,
               label: "",
            });

            popup.getHead().setHTML(L("Add Tab"));
            button.setValue(L("Add"));
         }

         button.refresh();

         // show 'add new field' popup
         popup.show();
      }
   }

   static popupClose() {
      var popup = $$("ab-component-tab-add-new-tab-popup");

      if (popup) popup.hide();
   }

   static popupBusy() {
      var button = $$("ab-component-tab-save-button");

      if (button) button.disable();
   }

   static popupReady() {
      var button = $$("ab-component-tab-save-button");

      if (button) button.enable();
   }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // create 'add new tab' popup
      webix
         .ui({
            id: "ab-component-tab-add-new-tab-popup",
            view: "window",
            height: 250,
            width: 300,
            modal: true,
            position: "center",
            head: " ",
            body: {
               id: "ab-component-tab-add-new-tab-form",
               view: "form",
               elements: [
                  {
                     view: "text",
                     name: "label",
                     id: "ab-component-tab-name",
                     label: L("Label"),
                     required: true,
                  },
                  {
                     view: "combo",
                     id: "ab-component-tab-icon",
                     name: "tabicon",
                     label: L("Icon"),
                     options: {
                        filter: function (item, value) {
                           if (
                              item.value
                                 .toString()
                                 .toLowerCase()
                                 .indexOf(value.toLowerCase()) === 0
                           )
                              return true;
                           return false;
                        },
                        body: {
                           data: App.icons,
                           template:
                              "<i class='fa fa-fw fa-#value#'></i> #value#",
                        },
                     },
                  },
                  // action buttons
                  {
                     cols: [
                        { fillspace: true },
                        {
                           view: "button",
                           value: L("Cancel"),
                           css: "ab-cancel-button",
                           autowidth: true,
                           click: () => {
                              this.popupClose();
                           },
                        },
                        {
                           id: "ab-component-tab-save-button",
                           view: "button",
                           css: "webix_primary",
                           value: L("Add Tab"),
                           autowidth: true,
                           type: "form",
                           click: () => {
                              let form = $$(
                                 "ab-component-tab-add-new-tab-form"
                              );
                              if (form.validate()) {
                                 this.popupBusy();

                                 let vals = form.getValues();

                                 let doneFn = () => {
                                    this.popupReady();

                                    this.popupClose();

                                    // Refresh UI
                                    let currView = _logic.currentEditObject();
                                    currView.emit(
                                       "properties.updated",
                                       currView
                                    );
                                 };

                                 // add
                                 if (vals.id == null) {
                                    this.addTab(
                                       ids,
                                       _logic,
                                       vals.label,
                                       vals.tabicon
                                    ).then(() => doneFn());
                                 }
                                 // edit
                                 else {
                                    this.editTab(
                                       ids,
                                       _logic,
                                       vals.id,
                                       vals.label,
                                       vals.tabicon
                                    ).then(() => doneFn());
                                 }
                              }
                           },
                        },
                     ],
                  },
               ],
            },
         })
         .hide();

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            view: "counter",
            name: "height",
            label: L("Height"),
         },
         {
            view: "counter",
            name: "minWidth",
            label: L("Minimum width"),
         },
         {
            view: "checkbox",
            name: "stackTabs",
            labelRight: L("Stack Tabs Vertically"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
            on: {
               onChange: (newv, oldv) => {
                  if (newv == 1) {
                     $$(ids.sidebarWidth).show();
                     $$(ids.sidebarPos).show();
                     $$(ids.iconOnTop).hide();
                  } else {
                     $$(ids.sidebarWidth).hide();
                     $$(ids.sidebarPos).hide();
                     $$(ids.iconOnTop).show();
                  }
               },
            },
         },
         {
            view: "checkbox",
            name: "iconOnTop",
            labelRight: L("Position icon above text"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "checkbox",
            name: "darkTheme",
            labelRight: L("Use Dark Theme"),
            labelWidth: this.AB.UISettings.config().labelWidthCheckbox,
         },
         {
            view: "counter",
            name: "sidebarWidth",
            label: L("Width of Sidebar"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         },
         {
            view: "richselect",
            name: "sidebarPos",
            label: L("Position of Sidebar"),
            labelWidth: this.AB.UISettings.config().labelWidthXLarge,
            options: [
               { id: "left", value: L("Left") },
               { id: "right", value: L("Right") },
            ],
         },
         // [button] : add tab
         {
            view: "button",
            css: "webix_primary",
            value: L("Add Tab"),
            click: () => {
               this.popupShow();
            },
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.height).setValue(
         view.settings.height || ABViewTabPropertyComponentDefaults.height
      );
      $$(ids.minWidth).setValue(
         view.settings.minWidth || ABViewTabPropertyComponentDefaults.minWidth
      );
      $$(ids.stackTabs).setValue(
         view.settings.stackTabs || ABViewTabPropertyComponentDefaults.stackTabs
      );
      $$(ids.darkTheme).setValue(
         view.settings.darkTheme || ABViewTabPropertyComponentDefaults.darkTheme
      );
      $$(ids.sidebarWidth).setValue(
         view.settings.sidebarWidth ||
            ABViewTabPropertyComponentDefaults.sidebarWidth
      );
      $$(ids.sidebarPos).setValue(
         view.settings.sidebarPos ||
            ABViewTabPropertyComponentDefaults.sidebarPos
      );
      $$(ids.iconOnTop).setValue(
         view.settings.iconOnTop || ABViewTabPropertyComponentDefaults.iconOnTop
      );

      if (view.settings.stackTabs) {
         $$(ids.sidebarWidth).show();
         $$(ids.sidebarPos).show();
         $$(ids.iconOnTop).hide();
      } else {
         $$(ids.sidebarWidth).hide();
         $$(ids.sidebarPos).hide();
         $$(ids.iconOnTop).show();
      }
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.height = $$(ids.height).getValue();
      view.settings.minWidth = $$(ids.minWidth).getValue();
      view.settings.stackTabs = $$(ids.stackTabs).getValue();
      view.settings.darkTheme = $$(ids.darkTheme).getValue();
      view.settings.sidebarWidth = $$(ids.sidebarWidth).getValue();
      view.settings.sidebarPos = $$(ids.sidebarPos).getValue();
      view.settings.iconOnTop = $$(ids.iconOnTop).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      var AB = this.AB;

      var comp = super.component(App);
      // get a UI component for each of our child views
      this._viewComponents = [];
      this.views().forEach((v) => {
         var accessLevel = v.getUserAccess();
         if (accessLevel > 0) {
            this._viewComponents.push({
               view: v,
               // component: v.component(App)
            });
         }
      });

      var idBase = "ABViewTab_" + this.id;
      var ids = {
         component: App.unique(`${idBase}_component`),
         sidebar: App.unique(`${idBase}_sidebar`),
         expandMenu: App.unique(`${idBase}_expand_menu`),
         collapseMenu: App.unique(`${idBase}_collapse_menu`),
      };

      var _ui = {};

      // We are going to make a custom icon using the first letter of a menu item for menu items that don't have an icon
      // to do this we need to modify the default template with the method webix recommended form this snippet https://snippet.webix.com/b566d9f8
      webix.type(webix.ui.tree, {
         baseType: "sideBar", // inherit everything else from sidebar type
         name: "customIcons",
         icon: function (obj, common) {
            if (obj.icon.length)
               return (
                  "<span class='webix_icon webix_sidebar_icon fa fa-fw fa-" +
                  obj.icon +
                  "'></span>"
               );
            return (
               "<span class='webix_icon webix_sidebar_icon sidebarCustomIcon'>" +
               obj.value.charAt(0).toUpperCase() +
               "</span>"
            );
         },
      });

      if (this._viewComponents.length > 0) {
         if (this.settings.stackTabs) {
            // define your menu items from the view components
            var menuItems = this.views((view) => {
               var accessLevel = view.getUserAccess();
               if (accessLevel > 0) {
                  return view;
               }
            }).map((v) => {
               return {
                  id: v.id + "_menu",
                  value: v.label,
                  icon: v.tabicon ? v.tabicon : "",
               };
            });

            if (menuItems.length) {
               // create a menu item for the collapse option to use later
               var collapseMenu = {
                  id: ids.collapseMenu,
                  value: L("Collapse Menu"),
                  icon: "chevron-circle-left",
               };

               // create a menu item from the expand option to use later
               var expandMenu = {
                  id: ids.expandMenu,
                  value: L("Expand Menu"),
                  icon: "chevron-circle-right",
                  hidden: true,
               };

               // find out what the first option is so we can set it later
               var selectedItem = this._viewComponents[0].view.id + "_menu";

               var sidebar = {
                  view: "sidebar",
                  type: "customIcons", // define the sidebar type with the new template created above
                  id: ids.sidebar,
                  width: this.settings.sidebarWidth
                     ? this.settings.sidebarWidth
                     : 0,
                  scroll: true,
                  position: this.settings.sidebarPos
                     ? this.settings.sidebarPos
                     : "left",
                  css: this.settings.darkTheme ? "webix_dark" : "",
                  data: menuItems.concat(collapseMenu), // add you menu items along with the collapse option to start
                  on: {
                     onItemClick: function (id, e, node) {
                        // when a menu item is clicked
                        if (id == ids.collapseMenu) {
                           // if it was the collapse menu item
                           setTimeout(function () {
                              // remove the collapse option from the menu
                              $$(ids.sidebar).remove(ids.collapseMenu);
                              // add the expand option to the menu
                              $$(ids.sidebar).add(expandMenu);
                              // toggle the sidebar state
                              $$(ids.sidebar).toggle();
                              // we just clicked the collapse...but we don't wanted highlighted
                              // so highlight the previously selected menu item
                              $$(ids.sidebar).select(selectedItem);
                              // store this state in local storage the user preference is
                              // remembered next time they see this sidebar
                              this.AB.Storage.set(
                                 `${idBase}-state`,
                                 $$(ids.sidebar).getState()
                              );
                           }, 0);
                        } else if (id == ids.expandMenu) {
                           setTimeout(function () {
                              // remove the expand option from the menu
                              $$(ids.sidebar).remove(ids.expandMenu);
                              // add the collapse option to the menu
                              $$(ids.sidebar).add(collapseMenu);
                              // toggle the sidebar state
                              $$(ids.sidebar).toggle();
                              // we just clicked the collapse...but we don't wanted highlighted
                              // so highlight the previously selected menu item
                              $$(ids.sidebar).select(selectedItem);
                              // store this state in local storage the user preference is
                              // remembered next time they see this sidebar
                              this.AB.Storage.set(
                                 `${idBase}-state`,
                                 $$(ids.sidebar).getState()
                              );
                           }, 0);
                        } else {
                           // store the selecte menu item just in case someone toggles the menu later
                           selectedItem = id;
                           // if the menu item is a regular menu item
                           // call the onShow with the view id to load the view
                           id = id.replace("_menu", "");
                           $$(id).show(false, false);
                           // _onShow(id);
                        }
                     },
                     onAfterRender: () => {
                        // set ids of controller buttons
                        let collapseNode = $$(ids.sidebar).$view.querySelector(
                           `[webix_tm_id="${ids.collapseMenu}"]`
                        );
                        if (collapseNode) {
                           collapseNode.setAttribute(
                              "data-cy",
                              `tab-collapseMenu-${ids.collapseMenu}`
                           );
                        }
                        let expandNode = $$(ids.sidebar).$view.querySelector(
                           `[webix_tm_id="${ids.expandMenu}"]`
                        );
                        if (expandNode) {
                           expandNode.setAttribute(
                              "data-cy",
                              `tab-expandMenu-${ids.expandMenu}`
                           );
                        }
                        this.views((view) => {
                           var node = $$(ids.sidebar).$view.querySelector(
                              `[webix_tm_id="${view.id}_menu"]`
                           );
                           if (!node) return;
                           node.setAttribute(
                              "data-cy",
                              `tab-${view.label.replace(" ", "")}-${view.id}-${
                                 this.id
                              }`
                           );
                        });
                     },
                  },
               };

               var multiview = {
                  view: "multiview",
                  id: ids.component,
                  keepViews: true,
                  minWidth: this.settings.minWidth,
                  height: this.settings.height,
                  cells: this._viewComponents.map((v) => {
                     var tabUi = {
                        id: v.view.id,
                        // ui will be loaded when its tab is opened
                        view: "layout",
                        rows: [],
                     };

                     return tabUi;
                  }),
                  on: {
                     onViewChange: function (prevId, nextId) {
                        _onShow(nextId);
                     },
                  },
               };

               var columns = [sidebar, multiview];
               if (this.settings.sidebarPos == "right") {
                  columns = [multiview, sidebar];
               }

               _ui = {
                  cols: columns,
               };
            } else {
               _ui = {
                  view: "spacer",
               };
            }
         } else {
            var cells = this.views((view) => {
               var accessLevel = view.getUserAccess();
               if (accessLevel > 0) {
                  return view;
               }
            }).map((v) => {
               var tabUi = {
                  id: v.id,
                  // ui will be loaded when its tab is opened
                  view: "layout",
                  rows: [],
               };

               var tabTemplate = "";
               // tab icon
               if (v.tabicon) {
                  if (this.settings.iconOnTop) {
                     tabTemplate =
                        "<div class='ab-tabIconContainer'><span class='fa fa-lg fa-fw fa-" +
                        v.tabicon +
                        "'></span><br/>" +
                        v.label +
                        "</div>";
                  } else {
                     tabTemplate =
                        "<span class='fa fa-lg fa-fw fa-" +
                        v.tabicon +
                        "'></span> " +
                        v.label;
                  }
               }
               // no icon
               else {
                  tabTemplate = v.label;
               }

               return {
                  header: tabTemplate,
                  body: tabUi,
               };
            });

            // if there are cells to display then return a tabview
            if (cells.length) {
               _ui = {
                  rows: [
                     {
                        view: "tabview",
                        id: ids.component,
                        minWidth: this.settings.minWidth,
                        tabbar: {
                           height: 60,
                           type: "bottom",
                           css: this.settings.darkTheme ? "webix_dark" : "",
                           on: {
                              onAfterRender: () => {
                                 this.views((view) => {
                                    var node = $$(
                                       ids.component
                                    ).$view.querySelector(
                                       '[button_id="' + view.id + '"]'
                                    );
                                    if (!node) return;
                                    node.setAttribute(
                                       "data-cy",
                                       "tab " +
                                          view.name +
                                          " " +
                                          view.id +
                                          " " +
                                          this.id
                                    );
                                 });
                              },
                           },
                        },
                        multiview: {
                           height: this.settings.height,
                           on: {
                              onViewChange: function (prevId, nextId) {
                                 _onShow(nextId);
                              },
                           },
                        },
                        cells: cells,
                     },
                  ],
               };
            } else {
               // else we return a spacer
               _ui = {
                  view: "spacer",
               };
            }
         }
      } else {
         _ui = {
            view: "spacer",
         };
      }

      var _logic = {
         changePage: (pageId) => {
            $$(ids.component).blockEvent();
            this.changePage(pageId);
            $$(ids.component).unblockEvent();
         },

         changeTab: (tabViewId) => {
            // switch tab view
            _logic.toggleParent(this.parent);
            if (this.settings.stackTabs) {
               if (!$$(tabViewId).isVisible()) {
                  var showIt = setInterval(function () {
                     if ($$(tabViewId).isVisible()) {
                        clearInterval(showIt);
                     }
                     $$(tabViewId).show(false, false);
                  }, 200);
               }
            } else {
               $$(ids.component).setValue(tabViewId);
            }
         },

         toggleParent: (view) => {
            if (
               (view.key == "tab" || view.key == "viewcontainer") &&
               $$(view.id) &&
               $$(view.id).show
            ) {
               $$(view.id).show(false, false);
            }
            if (view.parent) {
               _logic.toggleParent(view.parent);
            }
         },
      };

      // make sure each of our child views get .init() called
      var _init = (options) => {
         var parent = this;

         if ($$(ids.component))
            webix.extend($$(ids.component), webix.ProgressBar);

         this._viewComponents.forEach((v) => {
            // v.component.init(options);

            // Trigger 'changePage' event to parent
            this.eventAdd({
               emitter: v.view,
               eventName: "changePage",
               listener: (...p) => _logic.changePage(...p),
            });
         });

         // Trigger 'changeTab' event to parent
         this.eventAdd({
            emitter: this,
            eventName: "changeTab",
            listener: (...p) => _logic.changeTab(...p),
         });

         // initialize the sidebar and figure out if it should be collased or not
         this.AB.Storage.get(`${idBase}-state`).then((state) => {
            if (state) {
               // this will collapse or expand the sidebar
               $$(ids.sidebar).setState(state);

               // if the state is collapsed we need to make sure the expand option is available
               if (state.collapsed) {
                  setTimeout(function () {
                     $$(ids.sidebar).remove(ids.collapseMenu);
                     $$(ids.sidebar).add(expandMenu);
                  }, 0);
               }
            }
         });
      };

      var _onShow = (viewId) => {
         var parent = this;

         var defaultViewIsSet = false;
         // if no viewId is given, then try to get the currently selected ID
         if (!viewId) {
            var sidebar = $$(ids.sidebar);
            if (sidebar) {
               viewId = sidebar.getSelectedId().replace("_menu", "");
            }
         }

         this._viewComponents.forEach((v, index) => {
            // set default view id
            var currView = this.views((view) => {
               return view.id == v.view.id;
            });
            var accessLevel = 0;
            if (currView.length) {
               accessLevel = currView[0].getUserAccess();
            }
            // choose the 1st View if we don't have one we are looking for.
            if (!viewId && !defaultViewIsSet && accessLevel > 0) {
               viewId = v.view.id;
               defaultViewIsSet = true;
            }

            // create view's component once
            if (v.component == null && v.view.id == viewId) {
               // show loading cursor
               if ($$(ids.component) && $$(ids.component).showProgress)
                  $$(ids.component).showProgress({ type: "icon" });

               v.component = v.view.component(App);

               if (parent.settings.stackTabs) {
                  // update multiview UI
                  webix.ui(
                     {
                        // able to 'scroll' in tab view
                        id: v.view.id,
                        view: "scrollview",
                        css: "ab-multiview-scrollview",
                        body: v.component.ui,
                     },
                     $$(v.view.id)
                  );
               } else {
                  // update tab UI
                  webix.ui(
                     {
                        // able to 'scroll' in tab view
                        id: v.view.id,
                        view: "scrollview",
                        css: "ab-tabview-scrollview",
                        body: v.component.ui,
                     },
                     $$(v.view.id)
                  );
               }

               // for tabs we need to look at the view's accessLevels
               accessLevel = v.view.getUserAccess();
               v.component.init(null, accessLevel);

               // done
               setTimeout(() => {
                  // $$(v.view.id).adjust();

                  if ($$(ids.component) && $$(ids.component).hideProgress)
                     $$(ids.component).hideProgress();
               }, 10);
            }

            // show UI
            if (v.view.id == viewId && v.component && v.component.onShow)
               v.component.onShow();

            if (parent.settings.stackTabs && v.view.id == viewId) {
               $$(viewId).show(false, false);
               $$(ids.sidebar).select(viewId + "_menu");
            }
         });
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,

         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 9403:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewText.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewTextCore = __webpack_require__(/*! ../../core/views/ABViewTextCore */ 55239);

const ABViewTextPropertyComponentDefaults = ABViewTextCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewText extends ABViewTextCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method editorComponent
    * return the Editor for this UI component.
    * the editor should display either a "block" view or "preview" of
    * the current layout of the view.
    * @param {string} mode what mode are we in ['block', 'preview']
    * @return {Component}
    */
   editorComponent(App, mode) {
      webix.codebase = "/js/webix/extras/";

      var idBase = "ABViewTextEditorComponent";
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _ui = {
         id: ids.component,
         view: "tinymce-editor",
         value: this.text || ABViewTextPropertyComponentDefaults.text,
         config: {
            plugins: [
               "advlist autolink lists link image charmap print preview anchor",
               "searchreplace visualblocks code fullscreen",
               "insertdatetime media table contextmenu paste imagetools wordcount",
            ],
            toolbar:
               "insertfile undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image",
            // menu: {
            // 	file: { title: 'File', items: 'newdocument' },
            // 	edit: { title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall' },
            // 	format: { title: 'Format', items: 'formats | removeformat' }
            // },
            init_instance_callback: (editor) => {
               editor.on("KeyUp", (event) => {
                  _logic.onChange();
               });

               editor.on("Change", function (event) {
                  _logic.onChange();
               });
            },
         },
      };

      var _init = (options) => {};

      var _logic = {
         onChange: () => {
            if (this.__onChangeFn) {
               clearTimeout(this.__onChangeFn);

               this.__onChangeFn = null;
            }

            this.__onChangeFn = setTimeout(() => {
               this.text = $$(ids.component).getValue();
               this.save();
            }, 400);
         },
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
      };
   }

   //
   // Property Editor
   //

   // static propertyEditorComponent(App) {
   // 	return ABViewPropertyComponent.component(App);
   // }

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // _logic functions

      _logic.selectSource = (dcId, oldDcId) => {
         var currView = _logic.currentEditObject();

         // Update field options in property
         this.propertyUpdateFieldOptions(ids, currView, dcId);
      };

      _logic.selectField = (field) => {
         let format = `{${field.label}}`;

         // insert text to tinymce
         tinymce.activeEditor.execCommand("mceInsertContent", false, format);
      };

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            view: "counter",
            name: "height",
            label: L("Height:"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
         },
         {
            name: "datacollection",
            view: "richselect",
            label: L("Data Source"),
            labelWidth: this.AB.UISettings.config().labelWidthLarge,
            on: {
               onChange: _logic.selectSource,
            },
         },
         {
            name: "field",
            view: "list",
            autoheight: true,
            template: "#label#",
            on: {
               onItemClick: function (id, e, node) {
                  var field = this.getItem(id);

                  _logic.selectField(field);
               },
            },
         },
      ]);
   }

   /**
    * @method propertyUpdateFieldOptions
    * Populate fields of object to select list in property
    *
    * @param {Object} ids
    * @param {ABViewForm} view - the current component
    * @param {string} dvId - id of ABDatacollection
    */
   static propertyUpdateFieldOptions(ids, view, dvId) {
      var datacollection = view.AB.datacollectionByID(dvId);

      if (!datacollection && view.parent.key == "dataview") {
         datacollection = view.AB.datacollectionByID(
            view.parent.settings.dataviewID
         );
         $$(ids.datacollection).setValue(view.parent.settings.dataviewID);
      }

      var object = datacollection ? datacollection.datasource : null;

      // Pull field list
      $$(ids.field).clearAll();
      if (object) $$(ids.field).parse(object.fields());
      $$(ids.field).refresh();
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.height).setValue(view.settings.height);

      var dataviewID = view.settings.dataviewID
         ? view.settings.dataviewID
         : null;
      var SourceSelector = $$(ids.datacollection);

      // Pull data collections to options
      var dvOptions = view.propertyDatacollections();
      SourceSelector.define("options", dvOptions);
      SourceSelector.define("value", dataviewID);
      SourceSelector.refresh();

      this.propertyUpdateFieldOptions(ids, view, dataviewID);
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.settings.height = $$(ids.height).getValue();
      view.settings.dataviewID = $$(ids.datacollection).getValue();
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App, idPrefix) {
      let baseCom = super.component(App);

      var idBase = `ABViewText_${idPrefix ? idPrefix : ""}${this.id}`;
      var ids = {
         component: App.unique(`${idBase}_component`),
      };

      var _logic = {
         displayText: (val) => {
            var result = this.displayText(val, ids.component);

            if ($$(ids.component)) {
               $$(ids.component).define("template", result);
               $$(ids.component).refresh();
            }
         },
      };

      // an ABViewLabel is a simple Label
      var _ui = {
         id: ids.component,
         view: "template",
         autoheight: true,
         minHeight: 10,
         css: "ab-custom-template",
         borderless: true,
      };

      // define height
      if (this.settings.height) _ui.height = this.settings.height;
      else _ui.autoheight = true;

      // make sure each of our child views get .init() called
      var _init = (options) => {};

      var _onShow = (viewId) => {
         baseCom.onShow(viewId);

         // listen DC events
         let dv = this.datacollection;
         if (dv && this.parent.key != "dataview") {
            this.eventAdd({
               emitter: dv,
               eventName: "changeCursor",
               listener: (...p) => _logic.displayText(...p),
            });
         }

         _logic.displayText();
      };

      return {
         ui: _ui,
         init: _init,
         logic: _logic,
         onShow: _onShow,
      };
   }
};


/***/ }),

/***/ 11895:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewWidget.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidgetCore = __webpack_require__(/*! ../../core/views/ABViewWidgetCore */ 29436);

const ABPropertyComponentDefaults = ABViewWidgetCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewWidget extends ABViewWidgetCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   // Property Editor
   //

   static propertyEditorDefaultElements(App, ids, _logic, ObjectDefaults) {
      var commonUI = super.propertyEditorDefaultElements(
         App,
         ids,
         _logic,
         ObjectDefaults
      );

      // in addition to the common .label  values, we
      // ask for:
      return commonUI.concat([
         {
            name: "columnSpan",
            view: "counter",
            min: 1,
            label: L("Column Span"),

            hidden: true, // TODO
         },
         {
            name: "rowSpan",
            view: "counter",
            min: 1,
            label: L("Row Span"),

            hidden: true, // TODO
         },
      ]);
   }

   static propertyEditorPopulate(App, ids, view) {
      super.propertyEditorPopulate(App, ids, view);

      $$(ids.columnSpan).setValue(
         view.position.dx || ABPropertyComponentDefaults.columnSpan
      );
      $$(ids.rowSpan).setValue(
         view.position.dy || ABPropertyComponentDefaults.rowSpan
      );
   }

   static propertyEditorValues(ids, view) {
      super.propertyEditorValues(ids, view);

      view.position.dx = $$(ids.columnSpan).getValue();
      view.position.dy = $$(ids.rowSpan).getValue();
   }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let base = super.component(App);

      base.onShow = (viewId) => {
         let dv = this.datacollection; // get from a function or a (get) property
         if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }
      };

      return base;
   }
};


/***/ }),

/***/ 70557:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewProperty.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewProperty)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../ui/ClassUI */ 32735);


class ABViewProperty extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor() {}

   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {};
   }

   /** == Property == */
   /**
    * @function propertyComponent
    * return the view and logic to display in property panel
    *
    * @return {Object} - {
    * 						ui: webix element,
    * 						init: function,
    * 						logic: object
    * 					}
    */
   static propertyComponent() {
      let ui = {
         view: "template",
         template: "No UI",
      };

      let init = (options) => {
         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }
      };

      let logic = {
         callbacks: {},
      };

      return {
         ui: ui,
         init: init,
         logic: logic,
      };
   }

   fromSettings(settings) {
      this.settings = settings;
   }

   toSettings() {
      return this.settings || {};
   }

   /** == UI == */
   /**
    * @function component
    * return the view and logic to display in display widget
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    *
    * @return {Object} - {
    * 						ui: webix element,
    * 						init: function,
    * 						logic: object
    * 					}
    */
   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      let ui = {
         view: "template",
         template: "No UI",
      };

      let init = (options) => {
         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }
      };

      let logic = {
         callbacks: {},
      };

      return {
         ui: ui,
         init: init,
         logic: logic,
      };
   }
}


/***/ }),

/***/ 95751:
/*!***************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyAddPage.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyAddPage)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewProperty */ 70557);


let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyAddPage extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         formView: "none", // id of form to add new data
      };
   }

   static propertyComponent(App, idBase) {
      let ids = {
         formView: `${idBase}_formView`,
      };

      let ui = {
         id: ids.formView,
         name: "formView",
         view: "richselect",
         label: L("Add New Form"),
         labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         on: {
            onChange: (newVal, oldVal) => {
               if (newVal == L("No add new option")) {
                  $$(ids.formView).setValue("");
               }

               _logic.callbacks.onSave();
            },
         },
      };

      let _init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      let _logic = {
         callbacks: {
            onSave: function () {
               console.warn("NO onSave()!");
            },
         },

         setSettings: (view, settings = {}) => {
            if (view == null) return;

            // Set the options of the possible edit forms
            let editForms = [
               {
                  id: "none",
                  value: L("No add new option"),
               },
            ];

            let pagesHasForm = view
               .pageRoot()
               .pages((p) => {
                  return p.views((v) => {
                     return (
                        v &&
                        v.key == "form" &&
                        v.datacollection &&
                        v.datacollection.datasource &&
                        v.datacollection.datasource.id ==
                           view.field().settings.linkObject
                     );
                  }, true).length;
               }, true)
               .map((p) => {
                  return {
                     id: p.id,
                     value: p.label,
                  };
               });

            editForms = editForms.concat(pagesHasForm);

            let $selector = $$(ids.formView);
            if ($selector) {
               $selector.define("options", editForms);
               $selector.define(
                  "value",
                  settings.formView || this.default.formView
               );
               $selector.refresh();
            }
         },

         getSettings: (view) => {
            let settings = view.settings || {};

            settings.formView = $$(ids.formView).getValue();

            return settings;
         },
      };

      return {
         ui: ui,
         init: _init,
         setSettings: _logic.setSettings,
         getSettings: _logic.getSettings,
      };
   }

   fromSettings(settings = {}) {
      this.settings = this.settings || {};
      this.settings.formView =
         settings.formView || this.constructor.default.formView;
   }

   component(App, idBase) {
      let ids = {
         popup: App.unique(`${idBase}_popup_add_new`),
         field: idBase.split("_")[1],
         button: App.unique(`${idBase}_popup_add_new_button`),
      };

      let ui = "";

      if (
         this.settings.formView &&
         this.settings.formView != this.constructor.default.formView
      ) {
         // let iDiv = document.createElement("div");
         // iDiv.className = "ab-connect-add-new";
         const dataCy = `add new CR button ${this.settings.formView} ${ids.field}`;
         // iDiv.innerHTML = `<a href="javascript:void(0);" class="fa fa-plus ab-connect-add-new-link" data-cy="${dataCy}"></a>`;
         // iDiv.appendChild(node);
         // ui = iDiv.outerHTML;
         ui = {
            id: ids.button,
            view: "button",
            type: "icon",
            icon: "fa fa-plus",
            width: 32,
            height: 32,
            css: "webix_primary ab-connect-add-new-link",
            on: {
               onAfterRender: () => {
                  $$(ids.button)
                     ?.$view.querySelector("button")
                     .setAttribute("data-cy", dataCy);
               },
            },
         };
      }

      let _logic = {
         callbacks: {
            onSaveData: (saveData) => {
               if ($$(ids.popup)) $$(ids.popup).close();
            },
            onCancel: () => {
               if ($$(ids.popup)) $$(ids.popup).close();

               return false;
            },
            onClearOnLoad: () => {
               return true;
            },
         },

         applicationLoad: (application) => {
            this._application = application;
         },

         onClick: (dc) => {
            let pageId = this.settings.formView;
            let page = this._application.pages((p) => p.id == pageId, true)[0];

            return _logic.openFormPopup(page, dc);
         },

         /**
          * @method openFormPopup
          *
          * @param page {ABViewPage}
          * @param dc {ABDataCollection}
          */
         openFormPopup: (page, dc) => {
            return new Promise((resolve, reject) => {
               if (this._application == null) return resolve();

               if ($$(ids.popup)) {
                  $$(ids.popup).show();
                  return resolve();
               }

               // Clone page so we modify without causing problems
               let pageClone = page.clone(null, null, { ignoreSubPages: true });
               pageClone.id = this._application.AB.uuid(); // lets take the stored id can create a new dynamic one so our views don't duplicate
               // pageClone.id = pageClone.id + "-" + webix.uid(); // lets take the stored id can create a new dynamic one so our views don't duplicate
               let popUpComp = pageClone.component(App);
               let ui = popUpComp.ui;

               let popupTemplate = {
                  view: "window",
                  id: ids.popup,
                  modal: true,
                  position: "center",
                  // position:function(stthis.__addPageToolate){
                  // 	state.left = x + 20this.__addPageTool; // offset the popups
                  // 	state.top = y + 20;this.__addPageTool
                  // },
                  resize: true,
                  width: parseInt(this.settings.popupWidth) || 700,
                  height: parseInt(this.settings.popupHeight) + 44 || 450,
                  css: "ab-main-container",
                  head: {
                     view: "toolbar",
                     css: "webix_dark",
                     cols: [
                        {
                           view: "label",
                           label: page.label,
                           css: "modal_title",
                           align: "center",
                        },
                        {
                           view: "button",
                           label: L("Close"),
                           autowidth: true,
                           align: "center",
                           click: function () {
                              var popup = this.getTopParentView();
                              popup.close();
                           },
                        },
                     ],
                  },
                  body: {
                     view: "scrollview",
                     scroll: true,
                     body: ui,
                  },
               };

               // Create popup
               webix.ui(popupTemplate).show();

               // Initial UI components
               setTimeout(() => {
                  popUpComp.init({
                     onSaveData: _logic.callbacks.onSaveData,
                     onCancelClick: _logic.callbacks.onCancel,
                     clearOnLoad: _logic.callbacks.onClearOnLoad,
                  });

                  popUpComp.onShow();

                  _logic.setDefaultValue(dc, pageClone);

                  resolve();
               }, 50);
            });
         },

         setDefaultValue: (dc, page) => {
            if (!dc) return;

            let obj = dc.datasource;
            if (!obj) return;

            let linkedData = dc.getCursor();
            if (!linkedData) return;

            page.views().forEach((v) => {
               if (!v || v.key != "form") return;

               v.views().forEach((fView) => {
                  if (fView.key != "connect" || fView.settings == null) return;

                  let field = fView.field();
                  if (field == null) return;

                  let objLink = field.datasourceLink;
                  if (objLink == null || objLink.id != obj.id) return;

                  let data = {};
                  let relationName = field.relationName();
                  data[relationName] = {
                     id: linkedData.id,
                  };

                  // Add custom index values
                  let indexes = obj.indexes() || [];
                  indexes.forEach((idx) => {
                     (idx.fields || []).forEach((f) => {
                        data[relationName][f.columnName] =
                           linkedData[f.columnName];
                     });
                  });

                  // Set label of selected item
                  if (linkedData.text) {
                     data[relationName].text = linkedData.text;
                     data[relationName].value = data[relationName].text;
                  } else {
                     let rawData = {};
                     rawData[relationName] = linkedData;
                     data[relationName].text = field.format(rawData);
                     data[relationName].value = data[relationName].text;
                  }

                  let comp = v.viewComponents[fView.id];
                  if (!comp) return;

                  field.setValue($$(comp.ui.inputId), data);
               });
            });
         },
      };

      let init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      return {
         ui: ui,
         init: init,

         applicationLoad: _logic.applicationLoad,
         onClick: _logic.onClick,
         openFormPopup: _logic.openFormPopup,
      };
   }
}


/***/ }),

/***/ 77025:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyEditPage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyEditPage)
/* harmony export */ });
/* harmony import */ var _ABViewPropertyAddPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewPropertyAddPage */ 95751);


let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyEditPage extends _ABViewPropertyAddPage__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         editForm: "none", // The url pointer of ABViewForm
      };
   }

   static propertyComponent(App, idBase) {
      let ids = {
         formEdit: `${idBase}_editForm`,
      };

      let ui = {
         id: ids.formEdit,
         name: "editForm",
         view: "richselect",
         label: L("Edit Form"),
         labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         on: {
            onChange: (newVal, oldVal) => {
               if (newVal == L("No add new option")) {
                  $$(ids.formEdit).setValue("");
               }

               _logic.callbacks.onSave();
            },
         },
      };

      let _init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      let _logic = {
         callbacks: {
            onSave: function () {
               console.warn("NO onSave()!");
            },
         },

         setSettings: (view, settings = {}) => {
            if (view == null) return;

            // Set the options of the possible edit forms
            let editForms = [
               {
                  id: "none",

                  value: L("No add new option"),
               },
            ];

            (view.pageRoot().pages(() => true, true) || []).forEach((p) => {
               if (!p) return;

               p.views(() => true, true).forEach((v) => {
                  if (
                     v &&
                     v.key == "form" &&
                     v.datacollection &&
                     v.datacollection.datasource &&
                     v.datacollection.datasource.id ==
                        view.field().settings.linkObject
                  ) {
                     editForms.push({
                        id: v.urlPointer(),
                        value: `${p.label} - ${v.label}`,
                     });
                  }
               });
            });

            let $selector = $$(ids.formEdit);
            if ($selector) {
               $selector.define("options", editForms);
               $selector.define(
                  "value",
                  settings.editForm || this.default.editForm
               );
               $selector.refresh();
            }
         },

         getSettings: (view) => {
            let settings = view.settings || {};

            let $selector = $$(ids.formEdit);
            let $selectPopup = $selector.getPopup();
            let selectedItem = ($selectPopup.config.body.data || []).filter(
               (opt) => opt.id == $selector.getValue()
            )[0];
            if (selectedItem) {
               settings.editForm = selectedItem.id; // The url pointer of ABViewForm
            }

            return settings;
         },
      };

      return {
         ui: ui,
         init: _init,
         setSettings: _logic.setSettings,
         getSettings: _logic.getSettings,
      };
   }

   fromSettings(settings = {}) {
      this.settings = this.settings || {};
      this.settings.editForm =
         settings.editForm || this.constructor.default.editForm;
   }

   component(App, idBase) {
      idBase = `${idBase}_popup_edit_form`;

      let comp = super.component(App, idBase);

      comp.onClick = () => {
         if (
            !this._application ||
            !this.settings.editForm ||
            this.settings.editForm == this.constructor.default.editForm
         )
            return Promise.resolve();

         let form = this._application.urlResolve(this.settings.editForm);
         if (!form) return Promise.resolve();

         let page = form.pageParent();
         if (!page) return Promise.resolve();

         return comp.openFormPopup(page);
      };

      return comp;
   }
}


/***/ }),

/***/ 84204:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyFilterData.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyFilterData)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewProperty */ 70557);
/*
 * ABViewPropertyFilterData
 * This is a displayable ui component that will manage displaying a
 * means of searching for the user.
 *
 * This component will emit: "filter.data" when one of the filter options
 * have been enabled.
 *    "filter.data" has 2 parameters: fnFilter, filterRules
 *       fnFilter {function} when passed a row of data from the grid,
 *                return true/false if it passes the filter.
 *       filterRules {array} of each of the filter rules that have been
 *                created. Note: the fnFilter still checks the validity
 *                of the row based on these rules.
 *                (this is used for the parent component to indicate how
 *                many rules are currently applied to the data being displayed)
 */


// const ABViewGridFilterRule = require("../../../rules/ABViewGridFilterRule");

let L = (...params) => AB.Multilingual.label(...params);

// var getRule = (object, App, idBase) => {
//    var FilterRule = new ABViewGridFilterRule();
//    FilterRule.objectLoad(object);

//    // run .component because it need to have .getValue and .setValue functions to Rule
//    // NOTE: ABViewQueryBuilderObjectFieldCondition - why does not return new object from .compnent ?
//    if ((App, idBase)) FilterRule.component(App, idBase);

//    return FilterRule;
// };

// var rowFilter = null;
// var rowFilterForm = null;

class ABViewPropertyFilterData extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(AB, idBase) {
      super({
         filterPanel: `${idBase}_filterPanel`,
         globalFilterFormContainer: `${idBase}__globalFilterFormContainer`,
         globalFilterForm: `${idBase}_globalFilterForm`,
         filterMenutoolbar: `${idBase}_filterMenuToolbar`,
         resetFilterButton: `${idBase}_resetFilterButton`,
         component: `${idBase}_filterData_popup`,
      });

      this.AB = AB;
      this.idBase = idBase;
      this.object = null;
      // this.queryRules = [];

      this.__externalSearchText = null;
      // {string}
      // External sources of text filters are stored here. This is most likely
      // from the global search toolbar entry.

      this.rowFilter = this.AB.filterComplexNew(`${this.ids.component}_filter`);
      // {RowFilter}
      // When .userFilterPosition == "toolbar" we use this RowFilter to
      // display a form in a popup where the toolbar button is.

      this.rowFilterForm = this.AB.filterComplexNew(
         `${this.ids.component}_filter_form`
      );
      // {RowFilter}
      // When .userFilterPosition == "form" we use this RowFilter to
      // display a form under the toolbar.
   }

   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         filterOption: 1,
         // {integer}
         // 0 - Not allow
         // 1 - Enable user filter
         // 2 - Predefined filter menu
         // 3 - Global filter input

         // filterOptions == 1 options
         userFilterPosition: "toolbar",
         // {string} the location of the filter:
         //    "toolbar" : there will be an "Add Filters" button on
         //                the toolbar that will trigger the form popup
         //    "form"    : there will be a button under the toolbar that
         //                will bring up the form popup.

         isGlobalToolbar: 1,
         // {boolean|truthy}
         // when "toolbar" is chosen for userFilterPosition, this setting
         // allows us to also include the search criteria specified in
         // the search box on the toolbar.

         // filterOptions == 2 options
         // predefined filters created by the builders. There will be
         // an area under the toolbar that displays buttons to choose
         // between one of the predefined queryRules.
         // queryRules: [], // An array of ABViewGridFilterRule object

         // filterOptions == 3 options
         // globalFilterPosition: "default",
         // {string} [ "default", "single" ]
         //    "default" : shows default grid with all potential matches
         //    "single"  : grid only shows when it has a match.  only 1
         //                match is shown. ( is this true?? )
      };
   }

   // static propertyComponent(App, idBase) {
   //    let base = super.propertyComponent();

   //    let ids = {
   //       /** Property */
   //       filterRules: idBase + "_rules",
   //       filterRulesScrollview: idBase + "_filterRulesScrollview",

   //       filterOptionRadio: idBase + "_filterOptionRadio",
   //       filterUserLayout: idBase + "_filterUserLayout",
   //       filterUser: idBase + "_filterUser",
   //       filterGlobal: idBase + "_filterGlobal",
   //       filterMenuLayout: idBase + "_filterMenuLayout",

   //       needLoadAllLabel: idBase + "_needLoadAll",
   //       globalToolbar: idBase + "_globalToolbar",
   //    };

   //    let labels = {
   //       common: App.labels,
   //       component: {
   //          header: L("ab.component.grid.filterMenu", "*Filter Menu"),
   //          addNewFilter: L(
   //             "ab.components.grid.addNewFilter",
   //             "*Add new filter"
   //          ),
   //       },
   //    };

   //    let ui = {
   //       type: "form",
   //       rows: [
   //          {
   //             view: "radio",
   //             id: ids.filterOptionRadio,
   //             value: 0,
   //             options: [
   //                { id: 0, value: "Do not Allow User filters" },
   //                { id: 1, value: "Enable User filters" },
   //                { id: 2, value: "Use a filter menu" },
   //                { id: 3, value: "Use a global filter input" },
   //             ],
   //             vertical: true,
   //             label: "Filter Option",
   //             labelWidth: App.config.labelWidthLarge,
   //             on: {
   //                onChange: (newValue, oldValue) => {
   //                   logic.setFilterOption(newValue);
   //                },
   //             },
   //          },

   //          {
   //             view: "radio",
   //             id: ids.filterGlobal,
   //             hidden: true,
   //             vertical: true,
   //             label: "Show",
   //             labelWidth: App.config.labelWidthLarge,
   //             options: [
   //                { id: "default", value: "All matching records" },
   //                { id: "single", value: "Single records only" },
   //             ],
   //          },

   //          {
   //             view: "layout",
   //             id: ids.filterUserLayout,
   //             hidden: true,
   //             cols: [
   //                {
   //                   view: "radio",
   //                   vertical: true,
   //                   id: ids.filterUser,
   //                   value: "toolbar",
   //                   label: "Display",
   //                   labelWidth: App.config.labelWidthLarge,
   //                   width: 200,
   //                   options: [
   //                      { id: "toolbar", value: "Toolbar" },
   //                      { id: "form", value: "Form" },
   //                   ],
   //                   on: {
   //                      onChange: (newValue) => {
   //                         logic.setFilterUser(newValue);
   //                      },
   //                   },
   //                },
   //                {
   //                   view: "checkbox",
   //                   id: ids.globalToolbar,
   //                   width: 350,
   //                   labelRight: "Include a global filter input",
   //                },
   //                {},
   //             ],
   //          },

   //          {
   //             view: "layout",
   //             id: ids.filterMenuLayout,
   //             hidden: true,
   //             rows: [
   //                {
   //                   css: { "padding-bottom": 10 },
   //                   cols: [
   //                      {
   //                         view: "button",
   //                         css: "webix_primary",
   //                         icon: "fa fa-plus",
   //                         type: "iconButton",
   //                         label: labels.component.addNewFilter,
   //                         width: 150,
   //                         click: () => {
   //                            logic.addFilterRule();
   //                         },
   //                      },
   //                      {
   //                         view: "label",
   //                         label: '*need "LoadAll" from datasource',
   //                         css: { color: "red" },
   //                         id: ids.needLoadAllLabel,
   //                         hidden: true,
   //                      },
   //                      { fillspace: true },
   //                   ],
   //                },
   //                {
   //                   view: "scrollview",
   //                   id: ids.filterRulesScrollview,
   //                   scroll: "xy",
   //                   body: {
   //                      view: "layout",
   //                      id: ids.filterRules,
   //                      margin: 20,
   //                      padding: 10,
   //                      rows: [],
   //                   },
   //                },
   //             ],
   //          },
   //          {
   //             css: { "background-color": "#fff" },
   //             cols: [
   //                { fillspace: true },
   //                {
   //                   view: "button",
   //                   name: "cancel",
   //                   value: labels.common.cancel,
   //                   css: "ab-cancel-button",
   //                   autowidth: true,
   //                   click: function () {
   //                      logic.buttonCancel();
   //                   },
   //                },
   //                {
   //                   view: "button",
   //                   css: "webix_primary",
   //                   name: "save",
   //                   label: labels.common.save,
   //                   type: "form",
   //                   autowidth: true,
   //                   click: function () {
   //                      logic.buttonSave();
   //                   },
   //                },
   //                { fillspace: true },
   //             ],
   //          },
   //       ],
   //    };

   //    let init = (options) => {
   //       // register callbacks:
   //       for (var c in logic.callbacks) {
   //          logic.callbacks[c] = options[c] || logic.callbacks[c];
   //       }
   //    };

   //    let instance = this;
   //    instance.queryRules = [];

   //    let logic = {
   //       callbacks: {
   //          onCancel: function () {
   //             console.warn("NO onCancel()!");
   //          },
   //          onSave: function () {
   //             console.warn("NO onSave()!");
   //          },
   //       },

   //       buttonCancel: function () {
   //          logic.callbacks.onCancel();
   //       },

   //       buttonSave: () => {
   //          logic.callbacks.onSave();
   //       },

   //       objectLoad(object, isLoadAll = false) {
   //          instance.object = object;
   //          instance.isLoadAll = isLoadAll;

   //          //tell each of our rules about our object
   //          if (instance.queryRules && instance.queryRules.length) {
   //             instance.queryRules.forEach((r) => {
   //                r.objectLoad(object);
   //             });
   //          }
   //       },

   //       setSettings(settings = {}) {
   //          //Convert some condition from string to integer
   //          (settings.queryRules || []).forEach((qr) => {
   //             if (
   //                qr &&
   //                qr.queryRules &&
   //                qr.queryRules[0] &&
   //                qr.queryRules[0].rules
   //             ) {
   //                qr.queryRules[0].rules.forEach((rule) => {
   //                   if (/^[+-]?\d+(\.\d+)?$/.exec(rule.value)) {
   //                      rule.value = JSON.parse(rule.value);
   //                   }
   //                });
   //             }
   //          });

   //          $$(ids.filterOptionRadio).setValue(settings.filterOption);
   //          $$(ids.filterUser).setValue(
   //             settings.userFilterPosition ||
   //                ABViewPropertyFilterData.default.userFilterPosition
   //          );
   //          $$(ids.globalToolbar).setValue(
   //             typeof settings.isGlobalToolbar != "undefined"
   //                ? settings.isGlobalToolbar
   //                : ABViewPropertyFilterData.default.isGlobalToolbar
   //          );

   //          $$(ids.filterGlobal).setValue(
   //             settings.globalFilterPosition ||
   //                ABViewPropertyFilterData.default.globalFilterPosition
   //          );

   //          // clear any existing Rules:
   //          if (instance.queryRules && instance.queryRules.length > 0) {
   //             instance.queryRules.forEach((rule) => {
   //                if ($$(ids.filterRules))
   //                   $$(ids.filterRules).removeView(rule.ids.component);
   //             });
   //          }
   //          instance.queryRules = [];

   //          (settings.queryRules || []).forEach((ruleSettings) => {
   //             logic.addFilterRule(ruleSettings);
   //          });
   //       },

   //       getSettings() {
   //          var settings = this.settings || {};
   //          settings.filterOption = parseInt(
   //             $$(ids.filterOptionRadio).getValue()
   //          );
   //          settings.queryRules = [];

   //          switch (settings.filterOption) {
   //             case 0: // Disable User filters
   //                settings.isGlobalToolbar = 0;
   //                break;
   //             case 1: // Enable User filters
   //                settings.userFilterPosition = $$(ids.filterUser).getValue();

   //                settings.isGlobalToolbar = $$(ids.globalToolbar).getValue();
   //                break;
   //             case 2: // Use a filter menu
   //                instance.queryRules.forEach((r) => {
   //                   settings.queryRules.push(r.toSettings());
   //                });
   //                break;
   //             case 3: // Use a global filter menu
   //                settings.globalFilterPosition = $$(
   //                   ids.filterGlobal
   //                ).getValue();
   //                break;
   //          }

   //          return settings;
   //       },

   //       /**
   //        * @method addFilterRule
   //        * Instantiate a new Rule in our list.
   //        * @param {obj} settings  The settings object from the Rule we created in .toSettings()
   //        */
   //       addFilterRule(settings) {
   //          if (instance.object == null) return;

   //          var Rule = getRule(instance.object, App, idBase);
   //          instance.queryRules.push(Rule);

   //          // if we have tried to create our component:
   //          if (ids) {
   //             // if our actually exists, then populate it:
   //             var RulesUI = $$(ids.filterRules);
   //             if (RulesUI) {
   //                // make sure Rule.ui is created before calling .init()
   //                Rule.component(App, idBase); // prepare the UI component
   //                var viewId = RulesUI.addView(Rule.ui);
   //                Rule.showQueryBuilderContainer();
   //                Rule.init({
   //                   onDelete: (deletedRule) => {
   //                      $$(ids.filterRules).removeView(Rule.ids.component);

   //                      var index = instance.queryRules.indexOf(deletedRule);
   //                      if (index !== -1) {
   //                         instance.queryRules.splice(index, 1);
   //                      }
   //                   },
   //                });
   //             }
   //          }

   //          if (settings) {
   //             Rule.fromSettings(settings);
   //          }
   //       },

   //       onShow: function () {
   //          if (!this.isLoadAll) {
   //             $$(ids.needLoadAllLabel).show();
   //          } else {
   //             $$(ids.needLoadAllLabel).hide();
   //          }
   //       },

   //       setFilterOption: function (value) {
   //          switch (JSON.parse(value || 0)) {
   //             case 1: // Enable User filters
   //                $$(ids.filterMenuLayout).hide();
   //                $$(ids.filterGlobal).hide();
   //                $$(ids.filterUserLayout).show();
   //                break;
   //             case 2: // Use a filter menu
   //                $$(ids.filterUserLayout).hide();
   //                $$(ids.filterGlobal).hide();
   //                $$(ids.filterMenuLayout).show();
   //                break;
   //             case 3: // Use a global filter menu
   //                $$(ids.filterUserLayout).hide();
   //                $$(ids.filterMenuLayout).hide();
   //                $$(ids.filterGlobal).show();
   //                break;
   //             case 0:
   //             default:
   //                // Do not Allow User filters
   //                $$(ids.filterUserLayout).hide();
   //                $$(ids.filterMenuLayout).hide();
   //                $$(ids.filterGlobal).hide();
   //                break;
   //          }
   //       },

   //       setFilterUser: (val) => {
   //          switch (val) {
   //             case "toolbar":
   //                $$(ids.globalToolbar).show();
   //                break;
   //             case "form":
   //                $$(ids.globalToolbar).hide();
   //                break;
   //          }
   //       },
   //    };

   //    return {
   //       ui: ui,
   //       init: init,
   //       logic: logic,
   //       onShow: logic.onShow,
   //       objectLoad: logic.objectLoad,
   //       setSettings: logic.setSettings,
   //       getSettings: logic.getSettings,
   //    };
   // }

   /**
    * @method fromSettings
    * Create an initial set of default values based upon our settings object.
    * @param {obj} settings  The settings object we created in .toSettings()
    */
   fromSettings(settings) {
      settings = settings || {};

      settings.filterOption =
         typeof settings.filterOption != "undefined"
            ? settings.filterOption
            : ABViewPropertyFilterData.default.filterOption;

      settings.isGlobalToolbar =
         typeof settings.isGlobalToolbar != "undefined"
            ? settings.isGlobalToolbar
            : ABViewPropertyFilterData.default.isGlobalToolbar;

      this.settings = settings;
   }

   /**
    * @method objectLoad
    * A rule is based upon a Form that was working with an Object.
    * .objectLoad() is how we specify which object we are working with.
    *
    * @param {ABObject} The object that will be used to evaluate the Rules
    */
   objectLoad(object) {
      this.object = object;

      //tell each of our rules about our object
      // if (this.queryRules &&
      // 	this.queryRules.length) {
      // 	this.queryRules.forEach((r) => {
      // 		r.objectLoad(object);
      // 	});
      // }

      if (this.rowFilter) {
         // this.rowFilter.applicationLoad(object.application);
         this.rowFilter.fieldsLoad(object.fields());
      }

      if (this.rowFilterForm) {
         // this.rowFilterForm.applicationLoad(object.application);
         this.rowFilterForm.fieldsLoad(object.fields());
      }
   }

   viewLoad(view) {
      this.view = view;
   }

   /** == UI == */
   ui() {
      var self = this;
      var ids = this.ids;

      return {
         id: ids.filterPanel,
         type: "space",
         borderless: true,
         padding: 0,
         rows: [
            {
               id: ids.globalFilterFormContainer,
               hidden: true,
               cols: [
                  {
                     id: ids.globalFilterForm,
                     view: "text",
                     placeholder: L("Search or scan a barcode to see results"),
                     on: {
                        onTimedKeyPress: () => {
                           this.triggerCallback();
                           // var searchText = this.getValue();

                           // self.searchText(searchText);
                        },
                     },
                  },
                  {
                     view: "button",
                     css: "webix_primary",
                     width: 28,
                     type: "icon",
                     icon: "fa fa-times",
                     click: function () {
                        var $form = $$(ids.globalFilterForm);
                        $form.setValue("");
                        $form.focus();
                        $form.callEvent("onTimedKeyPress");
                     },
                  },
               ],
            },
            this.rowFilterForm.ui,
            {
               view: "toolbar",
               id: ids.filterMenutoolbar,
               css: "ab-data-toolbar",
               hidden: true,
               cols: [
                  {
                     view: "button",
                     css: "webix_primary",
                     id: ids.resetFilterButton,
                     label: L("Reset Filter"),
                     icon: "fa fa-ban",
                     type: "icon",
                     badge: 0,
                     autowidth: true,
                     click: function () {
                        self.resetFilter();
                     },
                  },
               ],
            },
         ],
      };
   }

   async init(AB) {
      if (AB) {
         this.AB = AB;
      }

      var ids = this.ids;
      // this.filter_popup = webix.ui({
      //    view: "popup",
      //    id: ids.component,
      //    width: 600,
      //    height: 400,
      //    hidden: true,
      //    body: this.rowFilter.ui,
      // });

      this.rowFilter.init();
      this.rowFilter.on("changed", (value) => {
         let filterRules = value.rules || [];

         // if ($$(ids.buttonFilter)) {
         // 	$$(ids.buttonFilter).define('badge', filterRules.length || null);
         // 	$$(ids.buttonFilter).refresh();
         // }

         // be notified when there is a change in the filter
         this.triggerCallback((rowData) => {
            return this.rowFilter.isValid(rowData);
         }, filterRules);
      });

      this.rowFilterForm.init();
      this.rowFilterForm.on("changed", () => {
         this.triggerCallback();
      });

      $$(ids.filterPanel)?.hide();
      if ($$(this.rowFilterForm.ui.id)) $$(this.rowFilterForm.ui.id).hide();
      $$(ids.filterMenutoolbar).hide();
      $$(ids.globalFilterFormContainer).hide();

      switch (this.settings.filterOption) {
         case 0:
            break;
         case 1:
            switch (this.settings.userFilterPosition) {
               case "form":
                  $$(this.rowFilterForm.ui.id).show();
                  $$(ids.filterPanel).show();
                  break;
               case "toolbar":
                  $$(ids.filterPanel).hide();
                  break;
            }
            break;
         case 2:
            $$(ids.filterPanel).show();
            var $filterMenutoolbar = $$(ids.filterMenutoolbar);
            if ($filterMenutoolbar) {
               $filterMenutoolbar.show();

               // populate filter items
               if (this.settings?.queryRules) {
                  (this.settings.queryRules || []).forEach((qr) => {
                     var filterRuleButton = {
                        view: "button",
                        css: "webix_primary",
                        label: qr.ruleName,
                        icon: "fa fa-filter",
                        type: "icon",
                        badge: 0,
                        autowidth: true,
                        click: () => {
                           this.selectFilter(qr.queryRules);
                        },
                     };
                     $filterMenutoolbar.addView(filterRuleButton);
                  });
               }
            }
            break;
         case 3:
            $$(ids.globalFilterFormContainer).show();
            $$(ids.filterPanel).show();
            break;
      }
   }

   filterRules() {
      let rowFilterRules = null;

      switch (this.settings.userFilterPosition) {
         case "form":
            rowFilterRules = this.rowFilterForm.getValue();
            break;
         case "toolbar":
            rowFilterRules = this.rowFilter.getValue();
            break;
      }

      return rowFilterRules;
   }

   /**
    * @method triggerCallback()
    * We compile our current search options and emit them back to our
    * parent container.
    */
   triggerCallback(/*fnFilter, filterRules*/) {
      let searchRules = this.searchText(this.__externalSearchText);
      let rowFilterRules = this.filterRules();

      if (rowFilterRules?.rules?.length) {
         if (searchRules) {
            rowFilterRules = {
               glue: "and",
               rules: [rowFilterRules, searchRules],
            };
         }
      } else {
         rowFilterRules = searchRules;
      }

      this.emit("filter.data", null, rowFilterRules);
   }

   resetFilter() {
      this.triggerCallback(() => true, []);
   }

   /**
    * @method externalSearchText()
    * Save any search criteria established from outside this filterHelper.
    * NOTE: The ABViewGrid has a toolbar search entry that will provide
    * this value.
    * @param {string} search
    *        The typed in search criteria.
    */
   externalSearchText(search = null) {
      this.__externalSearchText = search;
      this.triggerCallback(); // update each time
   }

   /**
    * @method searchText()
    * Retrieve the typed in search terms from the user, and convert them
    * into a set of Rules that will modify our results.
    * If an external search param is provided, use that instead.
    * @param {string} externalText
    * @return {json} The QB Rule condition for the search criteria
    */
   searchText(externalText) {
      var search;
      if (externalText) {
         search = externalText;
      } else {
         search = ($$(this.ids.globalFilterForm).getValue() || "").trim();
      }
      if (!search) return null; // <-- includes ""

      // find the individual "terms" that we should search for
      let terms = search.trim().toLowerCase().split(" ");

      // build a set of conditions for each term
      var allTerms = [];

      var allFields = this.object?.fields() || [];

      terms.forEach((t) => {
         var fieldTerms = [];

         // for each field, add a match condition for that field
         // (if the field applies)
         allFields.forEach((f) => {
            if (f.fieldIsFilterable()) {
               switch (f.key) {
                  case "string":
                  case "LongText":
                  case "email":
                     fieldTerms.push({
                        key: f.id,
                        rule: "contains",
                        value: t,
                     });
                     break;

                  case "list":
                     var options = f.options();
                     options.forEach((o) => {
                        if (o.text.indexOf(t) > -1) {
                           fieldTerms.push({
                              key: f.id,
                              rule: "equals",
                              value: o.id,
                           });
                        }
                     });
                     break;
               }
            }
         });

         if (fieldTerms.length > 0) {
            allTerms.push({
               glue: "or",
               rules: fieldTerms,
            });
         }
      });

      if (allTerms.length > 0) {
         var searchRules = {
            glue: "and",
            rules: allTerms,
         };
         return searchRules;
      } else {
         return null;
      }

      // let isTextValid = (rowData) => {
      //    var isValid = false;

      //    // if empty search text in global single mode, then no display rows
      //    if (
      //       this.settings.filterOption == 3 &&
      //       this.settings.globalFilterPosition == "single" &&
      //       search.replace(/ /g, "") == ""
      //    ) {
      //       return isValid;
      //    }

      //    for (let key in rowData || {}) {
      //       if (isValid || key == "uuid" || key == "id") continue;

      //       texts.forEach((text) => {
      //          if (
      //             rowData[key] &&
      //             rowData[key].toString().toLowerCase().indexOf(text) > -1
      //          )
      //             isValid = true;
      //       });
      //    }

      //    return isValid;
      // };

      // this.triggerCallback(isTextValid);

      // var table = $$(DataTable.ui.id);
      // var columns = table.config.columns;
      // var count = 0;
      // var matchArray = [];
      // table.filter(function (obj) {
      //    matchArray = [];
      //    // console.log("filter", obj);
      //    for (var i = 0; i < columns.length; i++) {
      //       for (var x = 0; x < text.length; x++) {
      //          var searchFor = text[x];
      //          if (obj[columns[i].id] && obj[columns[i].id].toString().toLowerCase().indexOf(searchFor) !== -1) {
      //             // console.log("matched on:", searchFor);
      //             if (matchArray.indexOf(searchFor) == -1) {
      //                matchArray.push(searchFor);
      //             }
      //          }
      //       }
      //    }

      //    if (matchArray.length == text.length) {
      //       count++;
      //       return true;
      //    } else {
      //       return false;
      //    }
      // });
      // if (globalFilterPosition == "single") {
      //    if (count == 1) {
      //       table.show();
      //       table.select(table.getFirstId(), false);
      //       table.callEvent("onItemClick", [table.getFirstId(), "auto", null]);
      //    } else {
      //       table.hide();
      //    }
      // }
   }

   showPopup($view) {
      // this.filter_popup.show($view, null, { pos: "top" });
      this.rowFilter.popUp($view);
   }

   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   component(App, idBase) {
      super.component(App, idBase);

      this.App = App;
      this.idBase = idBase;

      this.rowFilter = this.AB.filterComplexNew(`${idBase}_filter`);
      this.rowFilterForm = this.AB.filterComplexNew(`${idBase}_filter_form`);

      if (this.object) {
         // this.rowFilter.applicationLoad(this.object.application);
         this.rowFilter.fieldsLoad(this.object.fields());

         // this.rowFilterForm.applicationLoad(this.object.application);
         this.rowFilterForm.fieldsLoad(this.object.fields());
      }

      let ids = {
         /** UI */
         filterPanel: App.unique(`${idBase}_filterPanel`),
         globalFilterFormContainer: App.unique(
            `${idBase}_globalFilterFormContainer`
         ),
         globalFilterForm: App.unique(`${idBase}_globalFilterForm`),
         filterMenutoolbar: App.unique(`${idBase}_filterMenuToolbar`),
         resetFilterButton: App.unique(`${idBase}_resetFilterButton`),
         component: App.unique(`${idBase}_filterData_popup`),
      };

      let instance = this;

      // hide filter form
      this.rowFilterForm.ui.hidden = true;

      let _ui = {
         id: ids.filterPanel,
         type: "space",
         borderless: true,
         padding: 0,
         rows: [
            {
               id: ids.globalFilterFormContainer,
               hidden: true,
               cols: [
                  {
                     id: ids.globalFilterForm,
                     view: "text",
                     placeholder: L("Search or scan a barcode to see results"),
                     on: {
                        onTimedKeyPress: function () {
                           var searchText = this.getValue();

                           logic.searchText(searchText);
                        },
                     },
                  },
                  {
                     view: "button",
                     css: "webix_primary",
                     width: 28,
                     type: "icon",
                     icon: "fa fa-times",
                     click: function () {
                        $$(ids.globalFilterForm).setValue("");
                        $$(ids.globalFilterForm).focus();
                        $$(ids.globalFilterForm).callEvent("onTimedKeyPress");
                     },
                  },
               ],
            },
            this.rowFilterForm.ui,
            {
               view: "toolbar",
               id: ids.filterMenutoolbar,
               css: "ab-data-toolbar",
               hidden: true,
               cols: [
                  {
                     view: "button",
                     css: "webix_primary",
                     id: ids.resetFilterButton,
                     label: L("Reset Filter"),
                     icon: "fa fa-ban",
                     type: "icon",
                     badge: 0,
                     autowidth: true,
                     click: function () {
                        logic.resetFilter();
                     },
                  },
               ],
            },
         ],
      };

      let init = (options) => {
         // this.filter_popup = webix.ui({
         //    view: "popup",
         //    id: ids.component,
         //    width: 800,
         //    hidden: true,
         //    body: this.rowFilter.ui,
         // });

         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }

         this.rowFilter.init({
            //    onChange: () => {
            //       let filterRules = this.rowFilter.getValue().rules || [];
            //       // if ($$(ids.buttonFilter)) {
            //       // 	$$(ids.buttonFilter).define('badge', filterRules.length || null);
            //       // 	$$(ids.buttonFilter).refresh();
            //       // }
            //       // be notified when there is a change in the filter
            //       logic.triggerCallback((rowData) => {
            //          return this.rowFilter.isValid(rowData);
            //       }, filterRules);
            //    },
         });

         this.rowFilterForm.init({
            //    onChange: () => {
            //       let filterRules = this.rowFilterForm.getValue().rules || [];
            //       // be notified when there is a change in the filter
            //       logic.triggerCallback((rowData) => {
            //          return this.rowFilterForm.isValid(rowData);
            //       }, filterRules);
            //    },
         });

         $$(ids.filterPanel).hide();
         if ($$(this.rowFilterForm.ui.id)) $$(this.rowFilterForm.ui.id).hide();
         $$(ids.filterMenutoolbar).hide();
         $$(ids.globalFilterFormContainer).hide();

         switch (this.settings.filterOption) {
            case 0:
               break;
            case 1:
               switch (this.settings.userFilterPosition) {
                  case "form":
                     $$(this.rowFilterForm.ui.id).show();
                     $$(ids.filterPanel).show();
                     break;
                  case "toolbar":
                     $$(ids.filterPanel).hide();
                     break;
               }

               break;
            case 2:
               $$(ids.filterPanel).show();
               $$(ids.filterMenutoolbar).show();

               // populate filter items
               if (
                  this.settings.queryRules &&
                  this.settings.queryRules.length > 0
               ) {
                  this.settings.queryRules.forEach((qr) => {
                     var filterRuleButton = {
                        view: "button",
                        css: "webix_primary",
                        label: qr.ruleName,
                        icon: "fa fa-filter",
                        type: "icon",
                        badge: 0,
                        autowidth: true,
                        click: function () {
                           logic.selectFilter(qr.queryRules);
                        },
                     };
                     $$(ids.filterMenutoolbar).addView(filterRuleButton);
                  });
               }
               break;
            case 3:
               $$(ids.globalFilterFormContainer).show();
               $$(ids.filterPanel).show();
               break;
         }
      };

      let logic = {
         callbacks: {
            /**
             * @param {function} fnFilter
             */
            onFilterData: function (/*fnFilter, filterRules*/) {
               console.warn("NO onFilterData()");
            },
         },

         triggerCallback: (fnFilter, filterRules) => {
            instance.__currentFilter = fnFilter;
            logic.callbacks.onFilterData(this.__currentFilter, filterRules);
            //// TODO: this.emit("filter.data", )
         },

         resetFilter: () => {
            let showAllFn = function (/* rowData */) {
                  return true;
               },
               filterRules = [];

            logic.triggerCallback(showAllFn, filterRules);
         },

         selectFilter: (queryRules) => {
            let id = "hiddenQB_" + webix.uid();

            debugger;
            console.error("::: TODO: refactor getRule()");
            let queryRule; /* = getRule(this.object, this.App, this.idBase); */

            let ui = {
               id: id,
               hidden: true,
               view: "querybuilder",
               fields: queryRule?.conditionFields(),
            };
            let hiddenQB = webix.ui(ui);

            hiddenQB.setValue(queryRules);

            let QBHelper = hiddenQB.getFilterHelper();

            hiddenQB.destructor(); // remove the QB

            logic.triggerCallback(QBHelper);
         },

         getFilter() {
            // default filter
            if (instance.__currentFilter == null) {
               // if empty search text in global single mode, then no display rows
               if (
                  instance.settings.filterOption == 3 &&
                  instance.settings.globalFilterPosition == "single"
               )
                  instance.__currentFilter = (/* row */) => {
                     return false;
                  };
               // always true, show every rows
               else
                  instance.__currentFilter = (/* row */) => {
                     return true;
                  };
            }

            return instance.__currentFilter;
         },

         showFilterPopup($view) {
            instance.filter_popup.show($view, null, { pos: "top" });
         },

         closeFilterPopup() {
            instance.filter_popup.hide();
         },

         // searchText(search) {
         //    let texts = search.trim().toLowerCase().split(" ");

         //    let isTextValid = (rowData) => {
         //       var isValid = false;

         //       // if empty search text in global single mode, then no display rows
         //       if (
         //          instance.settings.filterOption == 3 &&
         //          instance.settings.globalFilterPosition == "single" &&
         //          search.replace(/ /g, "") == ""
         //       ) {
         //          return isValid;
         //       }

         //       for (let key in rowData || {}) {
         //          if (isValid || key == "uuid" || key == "id") continue;

         //          texts.forEach((text) => {
         //             if (
         //                rowData[key] &&
         //                rowData[key].toString().toLowerCase().indexOf(text) > -1
         //             )
         //                isValid = true;
         //          });
         //       }

         //       return isValid;
         //    };

         //    logic.triggerCallback(isTextValid);

         //    // var table = $$(DataTable.ui.id);
         //    // var columns = table.config.columns;
         //    // var count = 0;
         //    // var matchArray = [];
         //    // table.filter(function (obj) {
         //    // 	matchArray = [];
         //    // 	// console.log("filter", obj);
         //    // 	for (var i = 0; i < columns.length; i++) {
         //    // 		for (var x = 0; x < text.length; x++) {
         //    // 			var searchFor = text[x];
         //    // 			if (obj[columns[i].id] && obj[columns[i].id].toString().toLowerCase().indexOf(searchFor) !== -1) {
         //    // 				// console.log("matched on:", searchFor);
         //    // 				if (matchArray.indexOf(searchFor) == -1) {
         //    // 					matchArray.push(searchFor);
         //    // 				}
         //    // 			}
         //    // 		}
         //    // 	}

         //    // 	if (matchArray.length == text.length) {
         //    // 		count++;
         //    // 		return true;
         //    // 	} else {
         //    // 		return false;
         //    // 	}
         //    // });
         //    // if (globalFilterPosition == "single") {
         //    // 	if (count == 1) {
         //    // 		table.show();
         //    // 		table.select(table.getFirstId(), false);
         //    // 		table.callEvent("onItemClick", [table.getFirstId(), "auto", null]);
         //    // 	} else {
         //    // 		table.hide();
         //    // 	}
         //    // }
         // },
      };

      return {
         ui: _ui,
         init: init,
         logic: logic,

         showPopup: logic.showFilterPopup,
         closePopup: logic.closeFilterPopup,

         getFilter: logic.getFilter,

         searchText: logic.searchText,
      };
   }
}


/***/ }),

/***/ 95782:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyLinkPage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyLinkPage)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewProperty */ 70557);


let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyLinkPage extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();
   }

   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         detailsPage: null, // uuid
         detailsTab: null, // uuid
         editPage: null, // uuid
         editTab: null, // uuid
      };
   }

   static propertyComponent(App, idBase) {
      let base = super.propertyComponent();
      const uiConfig = this.AB.Config.uiSettings();

      let ids = {
         detailsPage: idBase + "_linkPage_detailsPage",
         editPage: idBase + "_linkPage_editPage",
      };

      let labels = {
         common: App.labels,
         component: {
            // header: L("ab.component.grid.filterMenu", "*Filter Menu")
         },
      };

      let ui = {
         view: "fieldset",
         label: L("Linked Pages:"),
         labelWidth: uiConfig.labelWidthLarge,
         body: {
            type: "clean",
            padding: 10,
            rows: [
               {
                  id: ids.detailsPage,
                  view: "select",
                  name: "detailsPage",
                  label: L("Details Page:"),
                  labelWidth: uiConfig.labelWidthLarge,
               },
               {
                  id: ids.editPage,
                  view: "select",
                  name: "editPage",
                  label: L("Edit Form:"),
                  labelWidth: uiConfig.labelWidthLarge,
               },
            ],
         },
      };

      let init = (options) => {
         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }
      };

      let logic = {
         callbacks: {
            // onCancel: function () { console.warn('NO onCancel()!') },
         },

         viewLoad: (view) => {
            this.view = view;

            let filter = (v, widgetKey) => {
               return (
                  v.key == widgetKey &&
                  v.settings.dataviewID == view.settings.dataviewID
               );
            };

            // Set the options of the possible detail views
            let pagesHasDetail = [];

            pagesHasDetail = pagesHasDetail.concat(
               view
                  .pageRoot()
                  .views((v) => {
                     return filter(v, "detail");
                  }, true)
                  .map((p) => {
                     return {
                        id: p.id,
                        value: p.label,
                     };
                  })
            );

            pagesHasDetail = pagesHasDetail.concat(
               view
                  .pageRoot()
                  .pages((p) => {
                     return p.views((v) => {
                        return filter(v, "detail");
                     }, true).length;
                  }, true)
                  .map((p) => {
                     return {
                        id: p.id,
                        value: p.label,
                     };
                  })
            );

            pagesHasDetail.unshift({
               id: "",
               value: L("No linked view"),
            });
            $$(ids.detailsPage).define("options", pagesHasDetail);
            $$(ids.detailsPage).refresh();

            // Set the options of the possible edit forms
            let pagesHasForm = [];

            pagesHasForm = pagesHasForm.concat(
               view
                  .pageRoot()
                  .views((v) => {
                     return filter(v, "form");
                  }, true)
                  .map((p) => {
                     return {
                        id: p.id,
                        value: p.label,
                     };
                  })
            );

            pagesHasForm = pagesHasForm.concat(
               view
                  .pageRoot()
                  .pages((p) => {
                     return p.views((v) => {
                        return filter(v, "form");
                     }, true).length;
                  }, true)
                  .map((p) => {
                     return {
                        id: p.id,
                        value: p.label,
                     };
                  })
            );

            pagesHasForm.unshift({
               id: "",
               value: L("No linked form"),
            });
            $$(ids.editPage).define("options", pagesHasForm);
            $$(ids.editPage).refresh();
         },

         setSettings: (settings) => {
            var details = settings.detailsPage;
            if (settings.detailsTab != "") {
               details += ":" + settings.detailsTab;
            }
            $$(ids.detailsPage).setValue(details);

            var edit = settings.editPage;
            if (settings.editTab != "") {
               edit += ":" + settings.editTab;
            }
            $$(ids.editPage).setValue(edit);
         },

         getSettings: () => {
            let settings = {};

            var detailsPage = $$(ids.detailsPage).getValue();
            var detailsTab = "";
            if (detailsPage.split(":").length > 1) {
               var detailsVals = detailsPage.split(":");
               detailsPage = detailsVals[0];
               detailsTab = detailsVals[1];
            }
            settings.detailsPage = detailsPage;
            settings.detailsTab = detailsTab;

            var editPage = $$(ids.editPage).getValue();
            var editTab = "";
            if (editPage.split(":").length > 1) {
               var editVals = editPage.split(":");
               editPage = editVals[0];
               editTab = editVals[1];
            }
            settings.editPage = editPage;
            settings.editTab = editTab;

            return settings;
         },
      };

      return {
         ui: ui,
         init: init,
         logic: logic,

         viewLoad: logic.viewLoad,
         setSettings: logic.setSettings,
         getSettings: logic.getSettings,
      };
   }

   /** == UI == */
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   component(App, idBase) {
      let base = super.component(App, idBase);

      /**
       * @method init
       * @param {Object} options - {
       * 								view: {ABView},
       * 								datacollection: {ABDatacollection}
       * 							}
       */
      let init = (options) => {
         base.init(options);

         if (options.view) this.view = options.view;

         if (options.datacollection)
            this.datacollection = options.datacollection;
      };

      let logic = {
         changePage: (pageId, rowId) => {
            if (this.datacollection) this.datacollection.setCursor(rowId);

            if (this.view) this.view.changePage(pageId);
         },
      };

      return {
         ui: base.ui,
         init: init,
         logic: logic,

         changePage: logic.changePage,
      };
   }
}


/***/ }),

/***/ 60069:
/*!*********************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceView.js ***!
  \*********************************************************************/
/***/ ((module) => {

// ABObjectWorkspaceView.js
//
// Manages the settings for a view in the AppBuilder Object Workspace

module.exports = class ABObjectWorkspaceView {
   constructor(attributes, object, defaultLabel) {
      this.defaultLabel = defaultLabel || "default view";
      /*
	{
		id:uuid(),

	}

*/
      // Note: keep this before .fromObj()
      this.object = object;

      this.fromObj(attributes || {});

      // multilingual fields: label
      this.object.translate(this, this, ["label"]);

      // user ids.  if has user id, then only those users can see this.
      // this.users = [];
   }

   /**
    * unique key describing this View.
    * @return {string}
    */
   static type() {
      return "view";
   }

   /**
    * @method fromObj
    * take our persisted data, and properly load it
    * into this object instance.
    * @param {json} data  the persisted data
    */
   fromObj(data) {
      this.id = data.id || this.object.AB.uuid();
      this.isDefaultView = JSON.parse(data.isDefaultView || false);
      this.translations =
         data.translations ||
         this.object.defaultTranslations(["label"], {
            label: this.defaultLabel,
         });
   }

   /**
    * @method toObj()
    * compile our current state into a {json} object
    * that can be persisted.
    */
   toObj() {
      this.object.unTranslate(this, this, ["label"]);
      return {
         id: this.id,
         translations: this.translations,
         isDefaultView: this.isDefaultView,
      };
   }

   update(view) {
      for (var key in view) {
         this[key] = view[key];
      }
   }
};


/***/ }),

/***/ 23847:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceViewCollection.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABObjectWorkspaceViewCollection.js
//
// Manages the settings for a collection of views in the AppBuilder Object Workspace

const ABObjectWorkspaceViewGrid = __webpack_require__(/*! ./ABObjectWorkspaceViewGrid */ 67112);
const ABObjectWorkspaceViewKanban = __webpack_require__(/*! ./ABObjectWorkspaceViewKanban */ 18318);
const ABObjectWorkspaceViewGantt = __webpack_require__(/*! ./ABObjectWorkspaceViewGantt */ 23989);

var hashViews = {};
hashViews[ABObjectWorkspaceViewGrid.type()] = ABObjectWorkspaceViewGrid;
hashViews[ABObjectWorkspaceViewKanban.type()] = ABObjectWorkspaceViewKanban;
hashViews[ABObjectWorkspaceViewGantt.type()] = ABObjectWorkspaceViewGantt;

const defaultAttributes = {
   currentViewID: undefined,
   list: [],
};

module.exports = class ABObjectWorkspaceViewCollection {
   constructor(attributes, object, AB) {
      // link me to my parent ABObject
      this.object = object;
      this.AB = AB;

      this.fromObj(attributes);
   }

   /**
    * @method fromObj
    * take our persisted data, and properly load it
    * into this object instance.
    * @param {json} data  the persisted data
    */
   fromObj(data) {
      // import our Workspace View Objects
      data.objectWorkspaceViews =
         data.objectWorkspaceViews && data.objectWorkspaceViews.list
            ? data.objectWorkspaceViews
            : defaultAttributes;

      // Temp
      // data.objectWorkspaceViews = defaultAttributes;

      if (
         data.objectWorkspaceViews.list.filter((v) => v.isDefaultView)
            .length === 0
      ) {
         // We should always have at least one default grid view. So if this list
         // is empty we can assume we're 'upgrading' from the old single-view workspace...

         /// So we import the 'old' format workspace settings
         if (typeof data.objectWorkspace != "undefined") {
            if (typeof data.objectWorkspace.sortFields == "undefined")
               data.objectWorkspace.sortFields = [];
            if (typeof data.objectWorkspace.filterConditions == "undefined")
               data.objectWorkspace.filterConditions = [];
            if (typeof data.objectWorkspace.frozenColumnID == "undefined")
               data.objectWorkspace.frozenColumnID = "";
            if (typeof data.objectWorkspace.hiddenFields == "undefined")
               data.objectWorkspace.hiddenFields = [];
         }

         // ...and initialize our grid view attributes
         var gridAttributes = data.objectWorkspace || {
            sortFields: [], // array of columns with their sort configurations
            filterConditions: [], // array of filters to apply to the data table
            frozenColumnID: "", // id of column you want to stop freezing
            hiddenFields: [], // array of [ids] to add hidden:true to
         };
         gridAttributes.isDefaultView = true;

         var defaultGrid = new ABObjectWorkspaceViewGrid(
            gridAttributes,
            this.object
         );
         data.objectWorkspaceViews.list.unshift(defaultGrid);
      }

      this.importViews(data.objectWorkspaceViews);

      this.currentViewID = data.objectWorkspaceViews.currentViewID;
      if (!this.currentViewID) {
         this.currentViewID = this.list()[0].id;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      return {
         currentViewID: this.currentViewID,
         list: this.exportViews(),
      };
   }

   list(fn = () => true) {
      return this._views.filter(fn);
   }

   importViews(viewSettings) {
      this._views = [];
      viewSettings.list.forEach((view) => {
         this.addView(view, false);
      });
   }

   exportViews() {
      var views = [];
      this._views.forEach((view) => {
         views.push(view.toObj());
      });

      return views;
   }

   setCurrentView(viewID) {
      this.currentViewID = viewID;
   }

   getCurrentView() {
      return this.list((v) => {
         return v.id == this.currentViewID;
      })[0];
   }

   addView(view, save = true) {
      var newView = new hashViews[view.type](view, this.object);
      this._views.push(newView);
      if (save) {
         this.object.save();
      }
      return newView;
   }

   removeView(view) {
      var indexToRemove = this._views.indexOf(view);
      this._views.splice(indexToRemove, 1);
      if (view.id === this.currentViewID) {
         this.currentViewID = this._views[0].id;
      }
      this.object.save();
   }

   updateView(viewToUpdate, view) {
      var newView;
      if (view.type === viewToUpdate.type) {
         viewToUpdate.update(view);
         newView = viewToUpdate;
      } else {
         newView = new hashViews[view.type](view, this.object);
         var indexToRemove = this._views.indexOf(viewToUpdate);
         this._views.splice(indexToRemove, 1, newView);
         if (this.currentViewID === viewToUpdate.id) {
            this.currentViewID = newView.id;
         }
      }
      this.object.save();
      return newView;
   }
};


/***/ }),

/***/ 88412:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceViewComponent.js ***!
  \******************************************************************************/
/***/ ((module) => {

// ABObjectWorkspaceViewComponent.js
//

module.exports = class ABObjectWorkspaceViewComponent {
   constructor(options) {
      this.elements =
         options.elements ||
         function () {
            return [];
         };
      this.init = options.init || function () {};
      this.validate =
         options.validate ||
         function () {
            return true;
         };
      this.values =
         options.values ||
         function () {
            return {};
         };
      this.logic = options.logic || {};
   }
};


/***/ }),

/***/ 23989:
/*!**************************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceViewGantt.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABObjectWorkspaceViewGantt.js
//
// Manages the settings for a Gantt Chart View in the AppBuilder Object Workspace

const ABObjectWorkspaceView = __webpack_require__(/*! ./ABObjectWorkspaceView */ 60069);
const ABObjectWorkspaceViewComponent = __webpack_require__(/*! ./ABObjectWorkspaceViewComponent */ 88412);

const ABPopupNewDataField = __webpack_require__(/*! ../../../ABDesigner/ab_work_object_workspace_popupNewDataField */ 28893);

const ABFieldDate = __webpack_require__(/*! ../dataFields/ABFieldDate */ 90176);
const ABFieldNumber = __webpack_require__(/*! ../dataFields/ABFieldNumber */ 41812);
const ABFieldString = __webpack_require__(/*! ../dataFields/ABFieldString */ 98134);
const ABFieldLongText = __webpack_require__(/*! ../dataFields/ABFieldLongText */ 74384);

let L = (...params) => AB.Multilingual.label(...params);

var defaultValues = {
   name: "Default Gantt",
   filterConditions: [], // array of filters to apply to the data table
   sortFields: [],
   title: "none", // id of a ABFieldString, ABFieldLongText
   startDate: null, // id of a ABFieldDate
   endDate: "none", // id of a ABFieldDate
   duration: "none", // id of a ABFieldNumber
   progress: "none", // id of a ABFieldNumber
   notes: "none", // id of a ABFieldString, ABFieldLongText
};

module.exports = class ABObjectWorkspaceViewGantt extends (
   ABObjectWorkspaceView
) {
   constructor(attributes, object) {
      super(attributes, object, "gantt");

      /*
         {
            id:uuid(),
            type:'gantt',  
            filterConditions:[],
         }
      
      */
   }

   /**
    * unique key describing this View.
    * @return {string}
    */
   static type() {
      return "gantt";
   }

   /**
    * @return {string}
    */
   static icon() {
      return "fa fa-tasks";
   }

   static component(App, idBase) {
      let ids = {
         title: App.unique(`${idBase}_popupGanttTitle`),
         startDate: App.unique(`${idBase}_popupGanttStartDate`),
         endDate: App.unique(`${idBase}_popupGanttEndDate`),
         duration: App.unique(`${idBase}_popupGanttDuration`),
         progress: App.unique(`${idBase}_popupGanttProgress`),
         notes: App.unique(`${idBase}_popupGanttNotes`),
      };

      let refreshOptions = (object, view) => {
         let dateFields = object
            .fields((f) => f instanceof ABFieldDate)
            .map(({ id, label }) => ({ id, value: label }));

         // Start date
         $$(ids.startDate).define("options", dateFields);

         // Add default option
         dateFields.unshift({
            id: "none",
            value: L("Select a date field"),
         });

         // End date
         $$(ids.endDate).define("options", dateFields);

         // Duration
         let numberFields = object
            .fields((f) => f instanceof ABFieldNumber)
            .map(({ id, label }) => ({ id, value: label }));

         // Add default option
         numberFields.unshift({
            id: "none",
            value: L("Select a number field"),
         });
         $$(ids.duration).define("options", numberFields);

         // Progress
         let decimalFields = object
            .fields((f) => f instanceof ABFieldNumber)
            .map(({ id, label }) => ({ id, value: label }));

         // Add default option
         decimalFields.unshift({
            id: "none",
            value: L("Select a number field"),
         });
         $$(ids.progress).define("options", decimalFields);

         // Title & Notes
         let stringFields = object
            .fields(
               (f) => f instanceof ABFieldString || f instanceof ABFieldLongText
            )
            .map(({ id, label }) => ({ id, value: label }));

         // Add default option
         stringFields.unshift({
            id: "none",
            value: L("Select a string field"),
         });
         $$(ids.title).define("options", stringFields);
         $$(ids.notes).define("options", stringFields);

         // Select view's values
         if (view && view.title) {
            $$(ids.title).define("value", view.title);
            $$(ids.title).refresh();
         }

         if (view && view.startDate) {
            $$(ids.startDate).define("value", view.startDate);
            $$(ids.startDate).refresh();
         }

         if (view && view.endDate) {
            $$(ids.endDate).define(
               "value",
               view.endDate || defaultValues.endDate
            );
            $$(ids.endDate).refresh();
         }

         if (view && view.duration) {
            $$(ids.duration).define(
               "value",
               view.duration || defaultValues.duration
            );
            $$(ids.duration).refresh();
         }

         if (view && view.progress) {
            $$(ids.progress).define("value", view.progress);
            $$(ids.progress).refresh();
         }

         if (view && view.notes) {
            $$(ids.notes).define("value", view.notes);
            $$(ids.notes).refresh();
         }
      };

      var PopupNewDataFieldComponent = new ABPopupNewDataField(
         App,
         `${idBase}_gantt`
      );

      let ViewComponent = new ABObjectWorkspaceViewComponent({
         elements: () => {
            return {
               batch: "gantt",
               rows: [
                  {
                     cols: [
                        {
                           id: ids.title,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-calendar'></span> ${L(
                              "Title"
                           )}`,
                           placeholder: L("Select a string field"),
                           labelWidth: 130,
                           name: "title",
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldString.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           id: ids.startDate,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-calendar'></span> ${L(
                              "Start Date"
                           )}`,
                           placeholder: L("Select a date field"),
                           labelWidth: 130,
                           name: "startDate",
                           required: true,
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldDate.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           id: ids.endDate,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-calendar'></span> ${L(
                              "End Date"
                           )}`,
                           placeholder: L("Select a date field"),
                           labelWidth: 130,
                           name: "endDate",
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldDate.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           id: ids.duration,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-hashtag'></span> ${L(
                              "Duration"
                           )}`,
                           placeholder: L("Select a number field"),
                           labelWidth: 130,
                           name: "duration",
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldNumber.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           id: ids.progress,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-hashtag'></span> ${L(
                              "Progress"
                           )}`,
                           placeholder: L("Select a number field"),
                           labelWidth: 130,
                           name: "progress",
                           required: false,
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldNumber.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           id: ids.notes,
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-align-right'></span> ${L(
                              "Notes"
                           )}`,
                           placeholder: L("Select a string field"),
                           labelWidth: 130,
                           name: "notes",
                           required: false,
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldLongText.defaults().key
                              );
                           },
                        },
                     ],
                  },
               ],
            };
         },

         init: (object, view) => {
            if (!object) return;

            refreshOptions(object, view);

            PopupNewDataFieldComponent.applicationLoad(object.application);
            PopupNewDataFieldComponent.objectLoad(object);
            PopupNewDataFieldComponent.init({
               onSave: () => {
                  // be notified when a new Field is created & saved

                  refreshOptions(object, view);
               },
            });
         },

         validate: function ($form) {
            let endDate = $$(ids.endDate).getValue() || defaultValues.endDate,
               duration = $$(ids.duration).getValue() || defaultValues.duration;

            if (
               endDate == defaultValues.endDate &&
               duration == defaultValues.duration
            ) {
               $form.markInvalid("endDate", "Required");
               $form.markInvalid("duration", "Required");

               return false;
            } else {
               return true;
            }
         },

         values: function () {
            let result = {};

            result.title = $$(ids.title).getValue() || defaultValues.title;
            result.startDate =
               $$(ids.startDate).getValue() || defaultValues.startDate;
            result.endDate =
               $$(ids.endDate).getValue() || defaultValues.endDate;
            result.duration =
               $$(ids.duration).getValue() || defaultValues.duration;
            result.progress =
               $$(ids.progress).getValue() || defaultValues.progress;
            result.notes = $$(ids.notes).getValue() || defaultValues.notes;

            return result;
         },

         logic: {},
      });

      return ViewComponent;
   }

   /**
    * @method fromObj
    * take our persisted data, and properly load it
    * into this object instance.
    * @param {json} data  the persisted data
    */
   fromObj(data) {
      super.fromObj(data);

      for (var v in defaultValues) {
         this[v] = data[v] || defaultValues[v];
      }

      this.type = ABObjectWorkspaceViewGantt.type();
   }

   /**
    * @method toObj()
    * compile our current state into a {json} object
    * that can be persisted.
    */
   toObj() {
      var obj = super.toObj();

      for (var v in defaultValues) {
         obj[v] = this[v];
      }

      obj.type = ABObjectWorkspaceViewGantt.type();
      return obj;
   }

   get titleField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.title);
   }

   get startDateField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.startDate);
   }

   get endDateField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.endDate);
   }

   get durationField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.duration);
   }

   get progressField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.progress);
   }

   get notesField() {
      let viewCollection = this.object,
         object = viewCollection.object;

      return object.fieldByID(this.notes);
   }
};


/***/ }),

/***/ 67112:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceViewGrid.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABObjectWorkspaceViewGrid.js
//
// Manages the settings for a Data Grid View in the AppBuilder Object Workspace

const ABObjectWorkspaceView = __webpack_require__(/*! ./ABObjectWorkspaceView */ 60069);

var defaultValues = {
   name: "Default Grid",
   sortFields: [], // array of columns with their sort configurations
   filterConditions: [], // array of filters to apply to the data table
   frozenColumnID: "", // id of column you want to stop freezing
   hiddenFields: [], // array of [ids] to add hidden:true to
};

module.exports = class ABObjectWorkspaceViewGrid extends ABObjectWorkspaceView {
   constructor(attributes, object) {
      super(attributes, object, "grid");

      /*
	{
		id:uuid(),
		type:'grid',  
		sortFields:[],
		filterConditions:[],
		frozenColumnID:"",
		hiddenFields:[],
	}

*/
   }

   /**
    * unique key describing this View.
    * @return {string}
    */
   static type() {
      return "grid";
   }

   /**
    * @return {string}
    */
   static icon() {
      return "fa fa-table";
   }

   /**
    * @method fromObj
    * take our persisted data, and properly load it
    * into this object instance.
    * @param {json} data  the persisted data
    */
   fromObj(data) {
      super.fromObj(data);

      for (var v in defaultValues) {
         this[v] = data[v] || defaultValues[v];
      }

      this.type = ABObjectWorkspaceViewGrid.type();
   }

   /**
    * @method toObj()
    * compile our current state into a {json} object
    * that can be persisted.
    */
   toObj() {
      var obj = super.toObj();

      for (var v in defaultValues) {
         obj[v] = this[v];
      }

      obj.type = "grid";
      return obj;
   }
};


/***/ }),

/***/ 18318:
/*!***************************************************************************!*\
  !*** ./AppBuilder/platform/workspaceViews/ABObjectWorkspaceViewKanban.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABObjectWorkspaceViewKanban.js
//
// Manages the settings for a Data Grid View in the AppBuilder Object Workspace

const ABObjectWorkspaceView = __webpack_require__(/*! ./ABObjectWorkspaceView */ 60069);
const ABObjectWorkspaceViewComponent = __webpack_require__(/*! ./ABObjectWorkspaceViewComponent */ 88412);

const ABPopupNewDataField = __webpack_require__(/*! ../../../ABDesigner/ab_work_object_workspace_popupNewDataField */ 28893);

const ABFieldConnect = __webpack_require__(/*! ../dataFields/ABFieldConnect */ 66589);
const ABFieldList = __webpack_require__(/*! ../dataFields/ABFieldList */ 69319);
const ABFieldUser = __webpack_require__(/*! ../dataFields/ABFieldUser */ 29333);

var defaultValues = {
   name: "Default Kanban",
   filterConditions: [], // array of filters to apply to the data table
   sortFields: [],
   verticalGroupingField: null,
   horizontalGroupingField: null,
   ownerField: null,
};

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABObjectWorkspaceViewKanban extends (
   ABObjectWorkspaceView
) {
   constructor(attributes, object) {
      super(attributes, object, "kanban");

      /*
			{
				id:uuid(),
				type:'kanban',  
				filterConditions:[],
			}
		
		*/
   }

   /**
    * unique key describing this View.
    * @return {string}
    */
   static type() {
      return "kanban";
   }

   /**
    * @return {string}
    */
   static icon() {
      return "fa fa-columns";
   }

   static component(AB, idBase) {
      let ids = {
         vGroupInput: `${idBase}_popupAddViewVGroup`,
         hGroupInput: `${idBase}_popupAddViewHGroup`,
         ownerInput: `${idBase}_popupAddViewOwner`,
      };

      // let labels = {
      //    common: App.labels,
      //    component: {
      //       vGroup: L("ab.add_view.kanban.vGroup", "*Vertical Grouping"),
      //       hGroup: L("ab.add_view.kanban.hGroup", "*Horizontal Grouping"),
      //       owner: L("ab.add_view.kanban.owner", "*Card Owner"),
      //       groupingPlaceholder: L(
      //          "ab.add_view.kanban.grouping_placeholder",
      //          "*Select a field"
      //       ),
      //       ownerPlaceholder: L(
      //          "ab.add_view.kanban.owner_placeholder",
      //          "*Select a user field"
      //       ),
      //       noneOption: L("ab.add_view.kanban.none_option", "*None"),
      //    },
      // };

      let refreshOptions = (object, view, options = {}) => {
         // Utility function to initialize the options for a field select input
         const initSelect = (
            $option,
            attribute,
            filter = (f) => f.key === ABFieldList.defaults().key,
            isRequired
         ) => {
            if ($option == null || object == null) return;

            // populate options
            var options = object
               .fields()
               .filter(filter)
               .map(({ id, label }) => ({ id, value: label }));
            if (!isRequired && options.length) {
               options.unshift({
                  id: 0,
                  value: L("None"),
               });
            }
            $option.define("options", options);

            // select a value
            if (view) {
               if (view[attribute]) {
                  $option.define("value", view[attribute]);
               } else if (!isRequired && options[0]) {
                  $option.define("value", options[0].id);
               }
            } else if (options.filter((o) => o.id).length === 1) {
               // If there's just one (real) option, default to the first one
               $option.define("value", options[0].id);
            }

            $option.refresh();
         };

         const verticalGroupingFieldFilter = (field) =>
            [ABFieldList.defaults().key, ABFieldUser.defaults().key].includes(
               field.key
            );

         const horizontalGroupingFieldFilter = (field) =>
            [
               ABFieldConnect.defaults().key,
               ABFieldList.defaults().key,
               ABFieldUser.defaults().key,
            ].includes(field.key);

         initSelect(
            options.vGroupInput || $$(ids.vGroupInput),
            "verticalGroupingField",
            verticalGroupingFieldFilter,
            true
         );
         initSelect(
            options.hGroupInput || $$(ids.hGroupInput),
            "horizontalGroupingField",
            horizontalGroupingFieldFilter,
            false
         );
         initSelect(
            options.ownerInput || $$(ids.ownerInput),
            "ownerField",
            (f) => {
               // User field
               return (
                  f.key === ABFieldUser.defaults().key ||
                  // Connected field : type 1:M
                  (f.key === ABFieldConnect.defaults().key &&
                     f.settings.linkType == "one" &&
                     f.settings.linkViaType == "many")
               );
            },
            false
         );
      };

      var PopupNewDataFieldComponent = new ABPopupNewDataField(
         AB,
         `${idBase}_kanban`
      );

      return new ABObjectWorkspaceViewComponent({
         elements: () => {
            return {
               batch: "kanban",
               rows: [
                  {
                     cols: [
                        {
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-columns'></span> ${L(
                              "Vertical Grouping"
                           )}`,
                           id: ids.vGroupInput,
                           placeholder: L("Select a field"),
                           labelWidth: 180,
                           name: "vGroup",
                           required: true,
                           options: [],
                           on: {
                              onChange: function (id) {
                                 $$(ids.vGroupInput).validate();
                                 $$(ids.hGroupInput).validate();
                              },
                           },
                           invalidMessage: L("Required"),
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldList.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-list'></span> ${L(
                              "Horizontal Grouping"
                           )}`,
                           id: ids.hGroupInput,
                           placeholder: L("Select a field"),
                           labelWidth: 180,
                           name: "hGroup",
                           required: false,
                           options: [],
                           invalidMessage: L(
                              "Cannot be the same as vertical grouping field"
                           ),
                           validate: (value) => {
                              var vGroupValue = $$(ids.vGroupInput).getValue();
                              return (
                                 !vGroupValue || !value || vGroupValue !== value
                              );
                           },
                           on: {
                              onChange: function (id) {
                                 $$(ids.hGroupInput).validate();
                              },
                           },
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldList.defaults().key
                              );
                           },
                        },
                     ],
                  },
                  {
                     cols: [
                        {
                           view: "richselect",
                           label: `<span class='webix_icon fa fa-user-circle'></span> ${L(
                              "Card Owner"
                           )}`,
                           placeholder: L("Select a user field"),
                           id: ids.ownerInput,
                           labelWidth: 180,
                           name: "owner",
                           options: [],
                        },
                        {
                           view: "button",
                           css: "webix_primary",
                           type: "icon",
                           icon: "fa fa-plus",
                           label: "",
                           width: 20,
                           click: () => {
                              PopupNewDataFieldComponent.show(
                                 null,
                                 ABFieldConnect.defaults().key
                              );
                           },
                        },
                     ],
                  },
               ],
            };
         },

         init: (object, view) => {
            refreshOptions(object, view);

            PopupNewDataFieldComponent.applicationLoad(object.application);
            PopupNewDataFieldComponent.objectLoad(object);
            PopupNewDataFieldComponent.init({
               onSave: () => {
                  // be notified when a new Field is created & saved

                  refreshOptions(object, view);
               },
            });
         },

         values: function () {
            let result = {};

            result.verticalGroupingField =
               $$(ids.vGroupInput).getValue() || null;
            result.horizontalGroupingField =
               $$(ids.hGroupInput).getValue() || null;
            result.ownerField = $$(ids.ownerInput).getValue() || null;

            return result;
         },

         logic: {
            refreshOptions: refreshOptions,
         },
      });
   }

   /**
    * @method fromObj
    * take our persisted data, and properly load it
    * into this object instance.
    * @param {json} data  the persisted data
    */
   fromObj(data) {
      super.fromObj(data);

      for (var v in defaultValues) {
         this[v] = data[v] || defaultValues[v];
      }

      this.type = ABObjectWorkspaceViewKanban.type();
   }

   /**
    * @method toObj()
    * compile our current state into a {json} object
    * that can be persisted.
    */
   toObj() {
      var obj = super.toObj();

      for (var v in defaultValues) {
         obj[v] = this[v];
      }

      obj.type = ABObjectWorkspaceViewKanban.type();
      return obj;
   }

   getHorizontalGroupingField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.horizontalGroupingField);
   }

   getVerticalGroupingField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.verticalGroupingField);
   }

   getOwnerField() {
      let viewCollection = this.object, // Should use another name property ?
         object = viewCollection.object;

      return object.fieldByID(this.ownerField);
   }
};


/***/ }),

/***/ 10679:
/*!*********************************************************************!*\
  !*** ./AppBuilder/rules/ABViewQueryBuilderObjectFieldConditions.js ***!
  \*********************************************************************/
/***/ ((module) => {

//
// ABViewQueryBuilderObjectFieldConditions
//
// A UI component that is responsible for displaying a QueryBuilder based upon
// the fields of a given ABObject.
//
// This object is also responsible for saving it's state to a settings value,
// and generating the settings value to be saved.

module.exports = class ABViewQueryBuilderObjectFieldConditions {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(label) {
      this.label = label;
      this.ui = null;
   }

   /**
    * cleanRules
    * walk through all the QueryBuilder (QB) rules and make conversions
    * of the data into their proper formats.
    * @param {obj} rules  the {rules} obj that is returned from the QB object
    * @param {array} fields  an array of field definitions from the QB object
    * @param {bool} dateToString  convert Dates to String format?
    */
   cleanRules(rules, fields, dateToString) {
      if (typeof dateToString == "undefined") dateToString = true;

      // walk the given condition rules / values, walk them and make sure
      // any given rules have properly formatted values.
      function processCondition(rule) {
         // make sure rule is provided
         if (rule) {
            if (rule.glue && rule.rules) {
               rule.rules.forEach((r) => {
                  processCondition(r);
               });
            } else {
               // converting a single rule:

               var field = fields.filter((f) => {
                  return f.id == rule.key;
               })[0];
               if (field) {
                  switch (field.type) {
                     case "number":
                     case "formula":
                        // when getting data from the server, the numbers are
                        // sent back as strings ("100.25").
                        // make sure to convert strings to numbers:
                        if (typeof rule.value == "string") {
                           if (rule.value.indexOf(".") == -1) {
                              rule.value = parseInt(rule.value);
                           } else {
                              rule.value = parseFloat(rule.value);
                           }
                        }
                        break;
                     case "date":
                        // in some cases we want to convert the Date() object returned
                        // by QueryBuilder into a string for saving on the Server.
                        if (dateToString) {
                           // if we have a Date() obj returned from QueryBuilder,
                           // convert to a string format:
                           if (rule.value instanceof Date) {
                              rule.value = webix.i18n.dateFormatStr(rule.value);
                           }
                        } else {
                           // in other cases we want to convert the string returned
                           // by the server into a Date() for the QB
                           if (typeof rule.value == "string") {
                              rule.value = new Date(rule.value);
                           }
                        }

                        break;
                  }
               }
            }
         }
      }
      processCondition(rules);
   }

   // component
   // initialize the UI display for this popup editor.
   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      var L = App.Label;

      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return this.unique(idBase + key ) + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         component: myUnique("qbObjectFieldConditions"),
         queryBuilder: myUnique("qBuilder"),
         queryBuilderContainer: myUnique("qBuilderContainer"),
         queryBuilderLayout: myUnique("qBuilderLayout"),
         showQBButton: myUnique("showQBButton"),
      });

      // webix UI definition:
      this.ui = {
         view: "layout",
         id: ids.queryBuilderLayout,
         hidden: true,
         type: "line",
         rows: [
            {
               id: ids.showQBButton,
               cols: [
                  { fillspace: true },
                  {
                     view: "button",
                     css: "webix_primary",
                     name: "addqb",
                     value: L("Add Custom Conditions"),
                     autowidth: true,
                     click: function () {
                        $$(ids.queryBuilderContainer).show();
                        $$(ids.showQBButton).hide();
                        // _logic.buttonCancel();
                     },
                  },
                  { fillspace: true },
               ],
            },
            {
               hidden: true,
               id: ids.queryBuilderContainer,
               cols: [
                  {
                     view: "querybuilder",
                     id: ids.queryBuilder,
                     fields: this.conditionFields(),
                  },
               ],
            },
         ],
      };

      // tack on a label if provided.
      if (this.label) {
         this.ui.rows[1].cols.unshift({
            view: "label",
            css: "ab-text-bold",
            label: this.label,
            width: this.AB.UISettings.config().labelWidthLarge,
         });
      }

      // for setting up UI
      this.init = (options) => {
         options = options || {};

         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onCancel: function () {
               console.warn("NO onCancel()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         /**
          * cleanRules
          * walk through all the QueryBuilder (QB) rules and make conversions
          * of the data into their proper formats.
          * @param {obj} rules  the {rules} obj that is returned from the QB object
          * @param {array} fields  an array of field definitions from the QB object
          * @param {bool} dateToString  convert Dates to String format?
          */
         cleanRules: (rules, fields, dateToString) => {
            this.cleanRules(rules, fields, dateToString);
         },

         getValue: () => {
            var values = null;
            var QB = $$(ids.queryBuilder);
            if (QB) {
               values = QB.getValue();
            }

            // convert dates to simpler format:
            // by default we're getting long values: "Mon Feb 2, 2018 GMT xxxxxxx",
            // and webix doesn't seem to understand them when we send them back.
            // so save simple date values: "mm/dd/yyyy"
            if (values) {
               _logic.cleanRules(values[0], values[1], true);
            }

            return values;
         },

         setValue: (values) => {
            values = values || [];
            if (!Array.isArray(values)) values = [values];
            if (values.length == 0) {
               values.push({});
            } // push default rules
            if (values.length < 2) {
               values.push(this.conditionFields());
            }

            // convert dates from our server side "string" format into
            // Date() objects.
            _logic.cleanRules(values[0], values[1], false);

            var QB = $$(ids.queryBuilder);
            if (QB) {
               if (values[0] && values[0].rules && values[0].rules.length) {
                  QB.setValue(values[0]);
                  $$(ids.queryBuilderContainer).show();
                  $$(ids.showQBButton).hide();
               }
            }
         },
      });

      this.getValue = _logic.getValue;
      this.show = _logic.show;
      this.setValue = _logic.setValue;
   }

   objectLoad(object) {
      this.currentObject = object;
   }

   // conditionFields()
   // Return the list of fields we are able to update.
   // @return {array} of querybuilder field definitions:
   //					[
   // 						{ id:"fname",   value:"First Name", type:"string" },
   //					    { id:"lname",   value:"Last Name",  type:"string" },
   //					    { id:"age",     value:"Age",        type:"number" },
   //					    { id:"bdate",   value:"Birth Date", type:"date" }
   //					]
   conditionFields() {
      var fieldTypes = [
         "string",
         "LongText",
         "number",
         "date",
         "email",
         "formula",
         "calculate",
      ];

      var currFields = [];

      if (this.currentObject) {
         this.currentObject.fields().forEach((f) => {
            if (fieldTypes.indexOf(f.key) != -1) {
               // NOTE: the .id value must match the obj[.id]  in the data set
               // so if your object data looks like:
               // 	{
               //		name_first:'Neo',
               //		name_last: 'The One'
               //  },
               // then the ids should be:
               // { id:'name_first', value:'xxx', type:'string' }

               let type = f.key;
               if (f.key == "formula" || f.key == "calculate") type = "number";
               else if (f.key == "LongText") type = "string";

               currFields.push({
                  id: f.columnName,
                  value: f.label,
                  type: type,
               });
            }
         });
      }

      return currFields;
   }

   // process
   // Take the provided data and process each of our rules.
   // @param {obj} options
   // @return {promise}
   process(options) {
      return new Promise((resolve, reject) => {
         var numDone = 0;
         var onDone = () => {
            numDone++;
            if (numDone >= this.listRules.length) {
               resolve();
            }
         };

         this.listRules.forEach((rule) => {
            rule
               .process(options)
               .then(function () {
                  onDone();
               })
               .catch((err) => {
                  reject(err);
               });
         });

         if (this.listRules.length == 0) {
            resolve();
         }
      });
   }

   showQueryBuilderContainer() {
      $$(this.ids.queryBuilderLayout).show();
      $$(this.ids.queryBuilderContainer).show();
      $$(this.ids.showQBButton).hide();
   }

   // // fromSettings
   // // Create an initial set of default values based upon our settings object.
   // // @param {obj} settings  The settings object we created in .toSettings()
   // fromSettings (settings) {
   // 	// settings: [
   // 	//  { rule.settings },
   // 	//  { rule.settings }
   // 	// ]

   // 	// clear any existing Rules:
   // 	this.listRules.forEach((rule)=>{
   // 		$$(this.ids.rules).removeView(rule.ids.component);
   // 	})
   // 	this.listRules = [];

   // 	if (settings) {
   // 		settings.forEach((ruleSettings)=>{
   // 			this.addRule(ruleSettings);
   // 		})
   // 	}
   // }

   // // toSettings
   // // create a settings object to be persisted with the application.
   // // @return {array} of rule settings.
   // toSettings () {
   // 	var settings = [];
   // 	this.listRules.forEach((r)=>{
   // 		settings.push(r.toSettings());
   // 	})
   // 	return settings;
   // }
};


/***/ }),

/***/ 12608:
/*!****************************************!*\
  !*** ./AppBuilder/rules/ABViewRule.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRule
//
// A component that manages an individual Rule in a Rule list.
//
// Each rule can manage a set of given Actions.  For each Rule, one Action
// can be chosen, A condition for when that action is executed, and then
// inputs for any additional data required by that action.
//
// Rules are used in the Interface Builder to present the designer an interface
// for defining the Action+Condition:
//
//
//
// In live apps, Rules are used when processing events and determining if an
// action is to be performed:
//
//
//
// A Rule needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//
const ObjectQueryBuilder = __webpack_require__(/*! ./ABViewQueryBuilderObjectFieldConditions */ 10679);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRule {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(listActions) {
      this.listActions = listActions || []; // the list of Actions this Rule manages

      this.actionDropList = []; // the Webix UI droplist
      this.listActions.forEach((a) => {
         this.actionDropList.push({ id: a.key, value: a.label });
      });

      this.selectedAction = null; // the currently selected Action.key
      if (this.actionDropList.length > 0) {
         this.selectedAction = this.actionDropList[0].id;
      }

      this.removable = true; // can I delete this rule?

      this.currentObject = null; // What ABObject is this associated with
      // NOTE: this is important for Actions.

      this.objectQB = null; // The QueryBuilder (QB) object

      this.currentForm = null;
   }

   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      // this is different because multiple instances of this View can be displayed
      // at the same time.  So make each instance Unique:
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return this.unique(idBase + key ) + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         // each instance must be unique
         component: myUnique("component"),

         selectAction: myUnique("chooseAction"),

         queryBuilder: myUnique("queryBuilder"),

         valueDisplay: myUnique("valueArea"),
      });

      this.objectQB.label = L("When");
      this.objectQB.component(this.App, this.idBase);
      this.ui = this._generateUI();

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         this.objectQB.init();

         // make sure the current Action's value display is initialized:
         var Action = this.currentAction();
         if (Action) {
            Action.component(this.App, this.idBase);
            var comp = Action.valueDisplay(ids.valueDisplay);

            _logic.replaceValueDisplay(comp);

            // webix.ui(comp.ui, $$(this.ids.valueDisplay));
            comp.init();
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onDelete: function () {
               console.warn("NO onDelete()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         replaceValueDisplay: (component) => {
            // remove current content area:
            var $ValueDisplay = $$(this.ids.valueDisplay);
            if (!$ValueDisplay) return;

            var children = $ValueDisplay.getChildViews();
            var cloneChildren = [];
            children.forEach((c) => {
               cloneChildren.push(c);
            });
            cloneChildren.forEach((c) => {
               $ValueDisplay.removeView(c);
            });

            $ValueDisplay.addView(component.ui);
         },

         selectAction: (newValue, oldVal) => {
            if (newValue) {
               $$(this.ids.component)
                  .getChildViews()
                  .forEach((views) => {
                     views.show();
                  });
            }
            // bonus:  save current state of previous Action
            var prevAction = this.getAction(oldVal);
            if (prevAction) {
               prevAction.stashCondition(this.objectQB.getValue());
            }

            // now switch to the new Action
            this.selectedAction = newValue;
            var currAction = this.currentAction();
            if (currAction) {
               // reset Condition filters.
               this.objectQB.setValue(currAction.condition());

               // have Action display it's values form
               currAction.component(this.App, this.idBase);
               var component = currAction.valueDisplay(ids.valueDisplay);
               _logic.replaceValueDisplay(component);
               component.init();
               // currAction.valueDisplay(ids.valueDisplay);
            }
         },
      });
   }

   // not intended to be called externally
   _generateUI() {
      return {
         id: this.ids.component,
         view: "layout",
         css: "ab-component-form-rules",
         padding: 20,
         // margin: 10,

         // this should be a CSS setting: this.AB.Config.xxxx
         // width: 680,
         type: "line",
         rows: [
            {
               view: "template",
               css: "ab-component-form-rules-delete",
               template: '<i class="fa fa-trash ab-component-remove"></i>',
               height: 30,
               borderless: true,
               hidddatasourceen: this.removable == false,
               onClick: {
                  "ab-component-remove": (e, id, trg) => {
                     this._logic.callbacks.onDelete(this);
                  },
               },
            },
            // Action
            {
               id: this.ids.selectAction,
               view: "richselect",
               label: L("Action"),
               placeholder: L("Choose an action"),
               labelWidth: this.AB.UISettings.config().labelWidthLarge,
               options: this.actionDropList,
               on: {
                  onChange: (newVal, oldVal) => {
                     this._logic.selectAction(newVal, oldVal);
                  },
               },
            },

            // Values
            {
               for: "values",
               hidden: true,
               cells: [
                  {
                     view: "layout",
                     cols: [
                        {
                           view: "label",
                           label: L("Values"),
                           css: "ab-text-bold",
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           id: this.ids.valueDisplay,
                           view: "layout",
                           rows: [
                              {
                                 label: L(
                                    " ABViewRule: This should be the Set Area"
                                 ),
                                 css: "ab-text-bold",
                                 height: 30,
                              },
                           ],
                        },
                     ],
                  },
               ],
            },

            // When
            this.objectQB.ui,
         ],
      };
   }

   // return the QueryBuilder fields data for the currently selected Action.
   conditionFields() {
      var fields = [];

      var selectedAction = this.currentAction();
      if (selectedAction) {
         fields = selectedAction.conditionFields();
      }

      return fields;
   }

   currentAction() {
      return this.getAction(this.selectedAction);
   }

   getAction(key) {
      return this.listActions.filter((a) => {
         return a.key == key;
      })[0];
   }

   objectLoad(object) {
      this.currentObject = object;
      this.listActions.forEach((a) => {
         a.objectLoad(object);
      });

      var label = L("When");

      this.objectQB = new ObjectQueryBuilder(label);
      this.objectQB.objectLoad(object);

      // regenerate our UI when a new object is loaded.
      if (this.ids) {
         this.ui = this._generateUI();
      }
   }

   formLoad(form) {
      this.currentForm = form;
      this.listActions.forEach((a) => {
         a.formLoad(form);
      });
   }

   processPre(options = {}) {
      let isValid = this.isValid(options.data);
      if (!isValid) return;

      let currentAction = this.currentAction();
      if (!currentAction) return;

      currentAction.processUpdateObject({}, options.data);
   }

   // process
   // Take the provided data and process this rule
   // @param {obj} options
   // @return {Promise}
   process(options) {
      var currentAction = this.currentAction();
      if (!currentAction) return Promise.resolve();

      let isValid = this.isValid(options.data);
      if (isValid) {
         return currentAction.process(options);
      } else {
         // else just resolve and continue on
         return new Promise((resolve, reject) => {
            resolve();
         });
      }
   }

   fromSettings(settings) {
      settings = settings || {};

      if (settings.selectedAction) {
         // store our Query Rules
         this.selectedAction = settings.selectedAction;
         var selectedAction = this.currentAction();
         if (!selectedAction) return;
         selectedAction.stashCondition(settings.queryRules || {});

         // if our UI components are present, populate them properly:
         if (this.ids) {
            // Trigger our UI to refresh with this selected Action:
            // NOTE: this also populates the QueryBuilder
            $$(this.ids.selectAction).setValue(this.selectedAction);
            // this._logic.selectAction(this.selectedAction);
         }

         // now continue with setting up our settings:
         selectedAction.fromSettings(settings.actionSettings);
      }
   }

   toSettings() {
      var settings = {};

      if (this.selectedAction) {
         settings.selectedAction = this.selectedAction;
         settings.queryRules = this.objectQB.getValue();
         let currentAction = this.currentAction();
         if (currentAction) {
            settings.actionSettings = currentAction.toSettings();
         }
      }

      return settings;
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      var currAction = this.currentAction();
      if (currAction && this.objectQB) {
         this.objectQB.setValue(currAction.condition());
         currAction.qbFixAfterShow();
      }
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   async isReady() {
      let currentAction = this.currentAction();
      if (currentAction) {
         return currentAction.isReady();
      }
      return Promise.resolve();
   }

   isValid(data = {}) {
      var id = "hiddenQB_" + webix.uid();

      // if our data passes the QueryRules then tell Action to process
      var ui = {
         id: id,
         hidden: true,
         view: "querybuilder",
      };
      var hiddenQB = webix.ui(ui);

      let currentAction = this.currentAction();
      var QBCondition = currentAction.condition();

      if (this.objectQB) {
         this.objectQB.cleanRules(QBCondition[0], QBCondition[1], false);
      }

      let query = QBCondition[0] || {},
         fields = QBCondition[1] || [];

      let convertToNumber = (text = "") => {
         // if we have multiple rules we need to check if value is already a number before converting.
         if (typeof text == "number") return text;

         return parseFloat(text.replace(/[^-0-9.]/g, ""));
      };

      // Fix string data in number type
      // NOTE: "1000" > "99" = false    >_<!
      fields
         .filter(
            (f) =>
               f.type == "number" ||
               f.type == "calculate" ||
               f.type == "formula"
         )
         .forEach((f) => {
            try {
               // filter conditions
               if (query && query.rules && Array.isArray(query.rules)) {
                  query.rules.forEach((r) => {
                     if (r.key != f.id) return;

                     r.value = convertToNumber(r.value);
                  });
               }

               // row data
               if (data[f.id] && typeof data[f.id] === "string") {
                  data[f.id] = convertToNumber(data[f.id]);
               }
            } catch (e) {
               // continue regardless of error
            }
         });

      // hiddenQB.setValue(QBCondition);
      hiddenQB.setValue({
         query: query,
         fields: fields,
      });

      var QBHelper = hiddenQB.getFilterHelper();
      var isValid = QBHelper(data);

      hiddenQB.destructor(); // remove the QB

      return isValid;
   }

   get isPreProcess() {
      let currentAction = this.currentAction();
      return currentAction.isPreProcess || false;
   }
};


/***/ }),

/***/ 84496:
/*!**********************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleAction.js ***!
  \**********************************************/
/***/ ((module) => {

//
// ABViewRuleAction
//
// A component that manages an individual Action in a Rule.
//
// Each Action is responsible for figuring out when it can run, and what to do.
//
// Actions are used in the Interface Builder to present the designer an interface
// for defining the a Condition and a set of data necessary to complete the Action:
//
//
//
// In live apps, Actions are used when processing events and determining if an
// if and what is to be performed:
//
//
//
// An Action needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleAction {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    * @param {ABViewForm} currentForm	the current form this Action is associated with.
    */
   constructor(App, idBase, currentForm) {
      this.key = "ABViewRuleAction";

      this.queryObject = null; // the current ABObject we use to create QueryBuilder information.

      this.currentForm = null;

      this.queryRules = {}; // default set of rules for the Query Builder condition

      this.valueRules = {}; // the initial Value Rules for this Action
      // The Action Subclass defines what this {} is.

      this.currentForm = currentForm; // the ABViewForm object that this rule Action is tied to.
   }

   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      this.label = L("generic abviewruleaction");

      function myUnique(key) {
         return App.unique(`${idBase}_${key}`);
      }

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         // each instance must be unique
         component: `${myUnique("component")}_${webix.uid()}`,
      });

      this._ui = null; // internally track our UI Component value Rules

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onDelete: function () {
               console.warn("NO onDelete()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },
      });
   }

   // condition
   // Return the querybuilder setup structure for this Action.
   // @return {array}  of querybuilder setup
   //					[
   //						{rules},
   //						[fields]
   //					]
   condition() {
      return [this.conditionRules(), this.conditionFields()];
   }

   // stashCondition
   // capture the current set of rules provided by the QB object.
   // This doesn't guarantee these will be saved to the App settings.
   // Instead it is a temporary stash. Only the selected Action's
   // values will be persisited to the App settings.
   // @param {obj/Array} rules  The QueryBuilder rule value returned from
   //							 .getValue()
   //							 note: it is the first entry .getValue()[0]
   //
   stashCondition(rules) {
      // check to see if they sent us the raw QueryBuilder values and only
      // pull off the rules if they did
      if (Array.isArray(rules)) {
         rules = rules[0];
      }

      // sanity check on glue value: don't update if null or not given.
      if (rules) {
         // sometimes .glue is undefined  so default to 'and'
         if (rules.glue != "or") rules.glue = "and";

         this.queryRules = rules;
      }
   }

   // conditionFields()
   // Return the list of fields we are able to update.
   // @return {array} of querybuilder field definitions:
   //					[
   // 						{ id:"fname",   value:"First Name", type:"string" },
   //					    { id:"lname",   value:"Last Name",  type:"string" },
   //					    { id:"age",     value:"Age",        type:"number" },
   //					    { id:"bdate",   value:"Birth Date", type:"date" }
   //					]
   conditionFields() {
      var fieldTypes = ["string", "number", "date", "formula", "calculate"];

      var currFields = [];

      if (this.queryObject) {
         this.queryObject.fields().forEach((f) => {
            if (fieldTypes.indexOf(f.key) != -1) {
               // NOTE: the .id value must match the obj[.id]  in the data set
               // so if your object data looks like:
               // 	{
               //		name_first:'Neo',
               //		name_last: 'The One'
               //  },
               // then the ids should be:
               // { id:'name_first', value:'xxx', type:'string' }
               currFields.push({
                  id: f.columnName,
                  value: f.label,
                  type: f.key,
               });
            }
         });
      }

      return currFields;
   }

   // conditionRules()
   // Return the current rule definition object for this Action.
   // @return {obj}
   conditionRules() {
      return this.queryRules;
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      // this.currentObject = object;				// DO WE NEED THIS?
      this.queryObjectLoad(object);
   }

   // queryObjectLoad
   // save the current object this Action is using to build query rules.
   queryObjectLoad(object) {
      this.queryObject = object;
   }

   formLoad(form) {
      this.currentForm = form;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      console.error(
         "!!! ABViewRuleAction.process() should be overridden by its child class."
      );
      return new Promise((resolve, reject) => {
         reject(
            new Error(
               "ABViewRuleAction.process() should be overridden by its child class."
            )
         );
      });
   }

   // valueDisplay
   // create the form to collect the specific data this Action needs to function.
   // @param {string} webixID  the $$(webixID) of the area to insert our display.
   valueDisplay(webixID) {
      return this.valueDisplayComponent(webixID);
   }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      return (this._ui = {
         ui: {
            template: "ABViewRuleAction.valueDisplayComponent",
         },
         init: (data) => {
            console.error(
               "!!! ABViewRuleAction.valueDisplayComponent() should be overridden."
            );
            console.warn(" --> passed in data:", data);
         },
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      // settings: {
      //	valueRules:{}
      // }
      settings = settings || {};
      this.valueRules = settings.valueRules || {};
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      var settings = {};

      // require the child to insert the valueRules
      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   isReady() {
      return Promise.resolve();
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      // our child classes can implement this if needed.
      // 	- ABViewRuleActionFormRecordRuleUpdateConnected
   }
};


/***/ }),

/***/ 97341:
/*!********************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleList.js ***!
  \********************************************/
/***/ ((module) => {

//
// ABViewRuleList
//
// A UI component that is responsible for displaying a list of current "Rules"
// for a given purpose.  Some examples are the
//		Form -> Submit Rules,
//		Form -> Display Rules
// 		Form -> Record Rules.
//

// ABViewRuleList is the parent object that manages displaying the common popup,
// list, adding a rule, removing rules, etc...
//
// It is intending to be subclassed by a Specific List object that will load
// up a given set of Actions for their list.
//
// When using it in the AppBuilder Interface Builder, this object provides:
// 	var PopupRecordList = new ABViewRuleList(App, idBase);
//  PopupRecordList.fromSettings(CurrentObjectDefinition.rules); // populates List with current settings defined in CurrentObjectDefinition
//  PopupRecordList.init({ onSave:()=>{}})	// displays the popup for IB
//  CurrentObjectDefinition.rules = PopupRecordList.toSettings(); // save the settings to store in json config
//
// When using on a live running App:
//  PopupRecordList = new ABViewRuleList(App, idBase);
//  PopupRecordList.fromSettings();
//
//  onFormSubmit(data) {
//		// note: this automatically validates and runs each rule:
//		PopupRecordList.process({data:data, view:{ current ABViewForm object }})
//		.then()
//		.catch();
//  }

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleList {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(childSettings) {
      this.listRules = [];
      this.currentObject = null;

      // ensure required values:
      childSettings = childSettings || {};
      childSettings.labels = childSettings.labels || {};
      childSettings.labels.header =
         childSettings.labels.header || "ab.components.form.ruleList";
      childSettings.labels.headerDefault =
         childSettings.labels.headerDefault || "*Rule List";
      this.childSettings = childSettings;
   }

   /**
    * @method component
    * initialize the UI display for this popup editor.
    * @param {obj} App  The common UI App object shared among our UI components
    * @param {string} idBase A unique Key used the the base of our unique ids
    */
   component(App, idBase) {
      this.App = this.App || App;
      this.idBase = idBase;

      App = App || this.App;

      this.currentForm = null;

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         component: `${idBase}_component`,
         rules: `${idBase}_rules`,
         rulesScrollview: `${idBase}_rulesScrollview`,

         action: `${idBase}_action`,
         when: `${idBase}_when`,

         values: `${idBase}_values`,
         set: `${idBase}_set`,
      });

      // webix UI definition:
      this.ui = {
         view: "window",
         id: ids.component,
         modal: true,
         position: "center",
         resize: true,
         width: 700,
         height: 450,
         css: "ab-main-container",
         head: {
            view: "toolbar",
            css: "webix_dark",
            cols: [
               {
                  view: "label",
                  label: this.childSettings.labels.headerDefault,
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "iconButton",
                  label: L("Add new rule"),
                  width: 150,
                  click: () => {
                     this.addRule();
                     console.log($$(ids.rules).$height);
                     $$(ids.rulesScrollview).scrollTo(0, $$(ids.rules).$height);
                  },
               },
            ],
         },
         body: {
            type: "form",
            rows: [
               {
                  view: "scrollview",
                  id: ids.rulesScrollview,
                  scroll: "xy",
                  body: {
                     view: "layout",
                     id: ids.rules,
                     margin: 20,
                     padding: 10,
                     rows: [],
                  },
               },
               // {
               // 	css: { 'background-color': '#fff' },
               // 	cols: [
               // 		{
               // 			view: "button",
               // 			icon: "plus",
               // 			type: "iconButton",
               // 			label: labels.component.addNewRule,
               // 			width: 150,
               // 			click: () => {
               // 				this.addRule();
               // 			}
               // 		},
               // 		{ fillspace: true }
               // 	]
               // },
               {
                  css: { "background-color": "#fff" },
                  cols: [
                     { fillspace: true },
                     {
                        view: "button",
                        name: "cancel",
                        value: L("Cancel"),
                        css: "ab-cancel-button",
                        autowidth: true,
                        click: function () {
                           _logic.buttonCancel();
                        },
                     },
                     {
                        view: "button",
                        css: "webix_primary",
                        name: "save",
                        label: L("Save"),
                        type: "form",
                        autowidth: true,
                        click: function () {
                           _logic.buttonSave();
                        },
                     },
                     { fillspace: true },
                  ],
               },
            ],
         },
      };

      // var _currentObject = null;
      var _rules = [];

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         webix.ui(this.ui);
      };

      // internal business logic
      var _logic = (this._logic = {
         buttonCancel: function () {
            $$(ids.component).hide();
         },

         buttonSave: () => {
            var results = this.toSettings();

            _logic.callbacks.onSave(results);
            _logic.hide();
         },

         callbacks: {
            onCancel: function () {
               console.warn("NO onCancel()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         hide: function () {
            $$(ids.component).hide();
         },

         show: function () {
            $$(ids.component).show();
         },
      });

      this.show = _logic.show;
      this.setValue = _logic.setValue;
   }

   /**
    * @method addRule
    * Instantiate a new Rule in our list.
    * @param {obj} settings  The settings object from the Rule we created in .toSettings()
    */
   addRule(settings) {
      var Rule = this.getRule();
      if (!Rule) return;

      this.listRules.push(Rule);

      // if we have tried to create our component:
      if (this.ids) {
         // if our actually exists, then populate it:
         var RulesUI = $$(this.ids.rules);
         if (RulesUI) {
            // make sure Rule.ui is created before calling .init()
            Rule.component(this.App, this.idBase); // prepare the UI component
            var viewId = RulesUI.addView(Rule.ui);

            Rule.init({
               onDelete: (deletedRule) => {
                  $$(this.ids.rules).removeView(Rule.ids.component);

                  var index = this.listRules.indexOf(deletedRule);
                  if (index !== -1) {
                     this.listRules.splice(index, 1);
                  }
               },
            });
         }
      }

      if (settings) {
         Rule.fromSettings(settings);
      }
   }

   /**
    * @method fromSettings
    * Create an initial set of default values based upon our settings object.
    * @param {obj} settings  The settings object we created in .toSettings()
    */
   fromSettings(settings) {
      // settings: [
      //  { rule.settings },
      //  { rule.settings }
      // ]

      // clear any existing Rules:
      this.listRules.forEach((rule) => {
         if (
            this.ids &&
            this.ids.rules &&
            rule &&
            rule.ids &&
            rule.ids.component
         ) {
            $$(this.ids.rules).removeView(rule.ids.component);
         }
      });
      this.listRules = [];

      if (settings) {
         settings.forEach((ruleSettings) => {
            this.addRule(ruleSettings);
         });
      }
   }

   /**
    * @method objectLoad
    * A rule is based upon a Form that was working with an Object.
    * .objectLoad() is how we specify which object we are working with.
    *
    * @param {ABObject} The object that will be used to evaluate the Rules
    */
   objectLoad(object) {
      this.currentObject = object;

      // tell each of our rules about our object
      this.listRules.forEach((r) => {
         r.objectLoad(object);
      });
   }

   processPre(options) {
      (this.listRules || [])
         .filter((rule) => rule.isPreProcess == true)
         .forEach((rule) => {
            rule.processPre(options, options.data);
         });
   }

   /**
    * @method process
    * Take the provided data and process each of our rules.
    * @param {obj} options
    * @return {promise}
    */
   process(options) {
      return new Promise((resolve, reject) => {
         let listRules = (this.listRules || []).filter(
            (rule) => !rule.isPreProcess
         );

         var numDone = 0;
         var onDone = () => {
            numDone++;
            if (numDone >= listRules.length) {
               resolve();
            }
         };

         listRules.forEach((rule) => {
            rule
               .process(options)
               .then(function () {
                  onDone();
               })
               .catch((err) => {
                  reject(err);
               });
         });

         if (listRules.length == 0) {
            resolve();
         }
      });
   }

   /**
    * @method toSettings
    * create a settings object to be persisted with the application.
    * @return {array} of rule settings.
    */
   toSettings() {
      var settings = [];
      this.listRules.forEach((r) => {
         settings.push(r.toSettings());
      });
      return settings;
   }

   getRule() {
      console.error(
         "!!! ABViewRuleList.getRule() should be overridded by a child object."
      );
      return null;
   }

   formLoad(form) {
      this.currentForm = form;
      this.App = this.App || form.App;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   rulesReady() {
      // This base class should be overwritten by any subclass that needs
      // to prepare:
      return Promise.resolve();
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      this.listRules.forEach((r) => {
         r.qbFixAfterShow();
      });
   }
};


/***/ }),

/***/ 26204:
/*!***********************************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleListFormRecordRules.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleListFormRecordRules
//
// A component that is responsible for displaying the specific list of Record
// Rules for a form.
//
const ABViewRuleList = __webpack_require__(/*! ./ABViewRuleList */ 97341);
const ABViewRule = __webpack_require__(/*! ./ABViewRule */ 12608);

const RoleUpdateExisting = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdate */ 7318);
const RoleInsertConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleInsertConnected */ 37857);
const RoleUpdateConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected */ 38135);
const RoleRemoveConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected */ 4120);

module.exports = class ABViewRuleListFormRecordRules extends ABViewRuleList {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor() {
      var settings = {
         labels: {
            header: "ab.components.form.recordRules",
            headerDefault: "*Record Rules",
         },
      };
      super(settings);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new RoleUpdateExisting(
            this.App,
            `${this.idBase}_ruleActionUpdate`,
            this.currentForm
         ),
         new RoleInsertConnected(
            this.App,
            `${this.idBase}_ruleActionInsert`,
            this.currentForm
         ),
         new RoleUpdateConnected(
            this.App,
            `${this.idBase}_ruleActionUpdateConnected`,
            this.currentForm
         ),
         new RoleRemoveConnected(
            this.App,
            `${this.idBase}_ruleActionRemoveConnected`,
            this.currentForm
         ),
      ];

      var Rule = new ABViewRule(listActions);
      if (this.currentObject) {
         Rule.objectLoad(this.currentObject);
      }
      return Rule;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our list of Rules is
    * ready to work.
    * @return {Promise}
    */
   async rulesReady() {
      var allReady = (this.listRules || []).map((r) => r.isReady());
      await Promise.all(allReady);
   }
};


/***/ }),

/***/ 51567:
/*!***********************************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleListFormSubmitRules.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleListFormSubmitRules
//
// A component that is responsible for displaying the specific list of Submit
// Rules for a form.
//
const ABViewRuleList = __webpack_require__(/*! ./ABViewRuleList */ 97341);
const ABViewRule = __webpack_require__(/*! ./ABViewRule */ 12608);

const RoleConfirmMessage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage */ 26220);
const RuleExistPage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleExistPage */ 14316);
const RuleParentPage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleParentPage */ 50924);
const RuleClosePopup = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleClosePopup */ 97521);
const RuleWebsite = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleWebsite */ 64151);
const RuleEmail = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleEmail */ 8873);

module.exports = class ABViewRuleListFormSubmitRules extends ABViewRuleList {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor() {
      var settings = {
         labels: {
            header: "ab.component.form.submitRule",
            headerDefault: "*Submit Rules",
         },
      };
      super(settings);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new RoleConfirmMessage(
            this.App,
            `${this.idBase}_ruleActionConfirmMessage`
         ),
         new RuleExistPage(this.App, `${this.idBase}_ruleActionExistPage`),
         new RuleParentPage(this.App, `${this.idBase}_ruleActionParentPage`),
         new RuleClosePopup(this.App, `${this.idBase}_ruleActionClosePopup`),
         new RuleWebsite(this.App, `${this.idBase}_ruleActionWebsite`),
         new RuleEmail(this.App, `${this.idBase}_ruleActionEmail`),
      ];

      var Rule = new ABViewRule(listActions);
      Rule.objectLoad(this.currentObject);
      Rule.formLoad(this.currentForm);
      return Rule;
   }
};


/***/ }),

/***/ 37857:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleInsertConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleInsertConnected
//
// An action that allows you to insert a connected object.
//
// NOTE: this is very similar to the Update Connected Rule, so we subclass that one and
// modify it to only Insert data.
//
//
const UpdateConnected = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 38135);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleInsertConnected extends (
   UpdateConnected
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleInsertConnected";
      this.label = L("Insert Connected Object");
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayChooser(idBase) {
      var Component = super.valueDisplayChooser(idBase);

      // in our case, there are no additional QB conditions:
      // so overwrite the .showQBIfNeeded() routine to not show anything:
      Component._logic.showQBIfNeeded = function () {};

      return Component;
   }

   /**
    * queryBuilderDisplay
    * override our parent .queryBuilderDisplay to not create a new .objectQB
    * @return {null}
    */
   queryBuilderDisplay() {
      return null;
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      // var condition = null; // our lookup condition

      // we are going to create a new instance of the connected object
      // and make sure our .id is in the connected object's connectionField
      // the server side will take care of making the proper relationship.

      // first, create a new set of values:
      var newObjectValues = {};

      // update them according to our rules
      this.processUpdateObject({}, newObjectValues);

      if (newObjectValues.newRecords) {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues.newRecords.forEach((r) => {
            r[connectedObjectField.columnName] = options.data.id;
            // perform the update/insert
            return model.create(r);
         });
      } else {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues[connectedObjectField.columnName] = options.data.id;

         // perform the update/insert
         return model.create(newObjectValues);
      }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //	valueRules:{}		// from ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      // we don't use .qpCondition
      delete settings.qbCondition;

      return settings;
   }
};


/***/ }),

/***/ 4120:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleRemoveConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//
const ABViewRuleActionFormRecordRuleUpdateConnected = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 38135);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleRemoveConnected extends (
   ABViewRuleActionFormRecordRuleUpdateConnected
) {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleRemoveConnected";
      this.label = L("Remove Connected Record");

      this.isUpdateValueDisabled = true; // disable update data of each fields
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      let selectedField = this.selectedField();
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         // get the model from the provided Form Obj:
         let dc = options.form.datacollection;
         if (!dc) return resolve();

         let model = dc.model;
         if (!model) return resolve();

         let updatedVals = {};
         updatedVals[selectedField.columnName] = "";

         model
            .update(options.data.id, updatedVals)
            .then(resolve)
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message:
                     "!!! ABViewRuleActionFormRecordRuleUpdate.process(): update error:",
                  data: options.data,
               });
               reject(err);
            });
      });
   }
};


/***/ }),

/***/ 7318:
/*!******************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdate.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleUpdate
//
// An action that allows you to update fields on an object that was currently
// Added/Updated.
//
//
const ABViewRuleActionObjectUpdater = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 45263);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleUpdate extends (
   ABViewRuleActionObjectUpdater
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = L("Update Record");
   }

   get isPreProcess() {
      return true;
   }
};


/***/ }),

/***/ 38135:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleUpdateConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//
const ABViewRuleActionObjectUpdater = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 45263);
const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 66589);
const ObjectQueryBuilder = __webpack_require__(/*! ../ABViewQueryBuilderObjectFieldConditions */ 10679);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleUpdateConnected extends (
   ABViewRuleActionObjectUpdater
) {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdateConnected";
      this.label = L("Update Connected Record");

      this.baseObject = null; // the object the current form is working with.
      // Use this to find our connected fields.

      this.selectedFieldID = null; // the selected field ID in the .baseObject that is
      // used for updating.  This should be one of the connection Fields.

      this.fieldDropList = []; // the list of fields to offer based upon the current .baseObject.

      this.objectQB = null; // the QueryBuilder used for offering conditions based upon our connected Object.
      this.qbCondition = null; // the QB condition entered for selecting which remote object.
   }

   // field

   /**
    * objectLoad
    * save the current object this Action is associated with.
    * in the case of the UpdateConnected Action, assigning us
    * this object only impacts the queryObject.
    *
    * The Updater form will use another object we select in
    * the form dropdown.
    *
    * @param {object} object
    *
    */
   objectLoad(object) {
      this.queryObjectLoad(object);
      this.baseObject = object;

      // now build our fieldDropList for the select
      var connectionFields = this.connectedFieldList();
      connectionFields.forEach((cf) => {
         this.fieldDropList.push({
            id: cf.id,
            value: cf.label,
         });
      });
   }

   /**
    * connectedFieldList
    * return the fields in our .baseObject that are connections to other objects.
    * @return {array} of {ABField}
    */
   connectedFieldList() {
      var connectKey = ABFieldConnect.defaults().key;
      if (this.baseObject && this.baseObject.fields) {
         return this.baseObject.fields((f) => {
            return f.key == connectKey;
         });
      } else {
         return [];
      }
   }

   /**
    * connectedObject
    * return the ABObject associated with the selected connection field.
    * @return {ABObject}
    */
   connectedObject() {
      if (this.selectedFieldID) {
         var selectedField = this.selectedField();
         if (selectedField) {
            return selectedField.datasourceLink;
         }
      }

      return null;
   }

   /**
    * selectedField
    * return the selected {ABField} object.
    * @return {ABField}
    */
   selectedField() {
      return this.connectedFieldList().filter((f) => {
         return f.id == this.selectedFieldID;
      })[0];
   }

   /**
    * valueDisplayComponent
    * Return an ABView to display our values form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayComponent(idBase) {
      if (this._uiChooser == null) {
         this._uiChooser = this.valueDisplayChooser(idBase);
      }

      return this._uiChooser;
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayChooser(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return key + "_" + uniqueInstanceID;
      };

      var ids = {
         component: myUnique("updateConnectedValues"),
         updateForm: myUnique("updateChooser"),
         selectConnectedField: myUnique("updateSelect"),
         updateFieldsForm: myUnique("updateForm"),
      };

      var _ui = {
         id: ids.component,
         view: "layout",
         css: "ab-component-form-rule",
         rows: [
            {
               id: ids.selectConnectedField,
               view: "richselect",
               label: L("Select which connected object to update."),
               labelWidth: 300,
               value: this.selectedField,
               options: this.fieldDropList,
               on: {
                  onChange: (newVal, oldVal) => {
                     _logic.selectAction(newVal, oldVal);
                  },
               },
            },
         ],
      };

      var init = (valueRules) => {
         valueRules = valueRules || this.valueRules;

         // make sure our currently selected field is selected.
         if (this.selectedFieldID) {
            var select = $$(ids.selectConnectedField);
            if (select) {
               select.setValue(this.selectedFieldID);
            }
         }
      };

      var _logic = (this._logic = {
         addDisplay: (view) => {
            $$(ids.component).addView(view);
         },

         // removePreviousDisplays
         // remove the previous components that reflected the conditions and
         // update values of the previously selected field.
         removePreviousDisplays: () => {
            var allViews = $$(ids.component).getChildViews();
            var cloneAllViews = [];
            allViews.forEach((v) => {
               cloneAllViews.push(v);
            });
            cloneAllViews.forEach((v) => {
               // don't remove the field picker
               if (v.config.id != ids.selectConnectedField) {
                  $$(ids.component).removeView(v);
               }
            });
         },

         selectAction: (newVal, oldVal) => {
            _logic.removePreviousDisplays(); // of the Query Builder and Update form for old selection:

            this.selectedFieldID = newVal;
            var connectedObject = this.connectedObject();

            if (connectedObject) {
               // it is the remote object that we are allowed to Update fields on.
               this.updateObjectLoad(connectedObject);
               ///// NOTE: important to call super.valueDisplayComponent()
               this.updateComponent = super.valueDisplayComponent(
                  ids.updateFieldsForm
               ); // parent obj

               _logic.showQBIfNeeded();

               // create a new blank update form
               _logic.addDisplay(this.updateComponent.ui);
               this.updateComponent.init();

               if (this.isUpdateValueDisabled) {
                  let $updateForm = $$(this.updateComponent.ui.id);
                  if ($updateForm) {
                     $updateForm.disable();
                     $updateForm.hide();
                  }
               }
            } else {
               this.AB.notify.builder(new Error("No connectedObject found."), {
                  fieldID: this.selectedFieldID,
               });
            }
         },

         showQBIfNeeded: () => {
            //// NOTE: we decided to go ahead and display the QB in ALL situations to give
            //// the user the ability to set a condition on the update even if the field
            //// is only a one to one.
            //// If we want to remove the filter in case of a "one" linkType, then put
            //// these conditions back in:

            // var field = this.selectedField();

            // // we don't need the QB if the destination object link type if 'one'.
            // // there will only be one to get back, so no conditions needed.
            // if (field.settings.linkType != 'one') {

            var qbComponent = this.queryBuilderDisplay();

            qbComponent.component(this.App, this.idBase);
            _logic.addDisplay(qbComponent.ui);
            qbComponent.init({});

            // }
         },

         fromSettings: (settings) => {
            // // first time through, be sure to set the connectedObject first
            // this.selectedFieldID = settings.selectedFieldID;
            // var connectedObject = this.connectedObject();

            // this triggers the update of the display, creation of QB,
            $$(ids.selectConnectedField).setValue(settings.selectedFieldID);

            if (this.objectQB) {
               this.objectQB.setValue(this.qbCondition);
            }

            if (this.updateComponent) {
               this.updateComponent.fromSettings(settings);
            }
         },

         toSettings: () => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }
            var settings = { fieldOperations: [] };

            // for each of our formRows, decode the propery {}
            this.formRows.forEach((fr) => {
               var rowSettings = fr.toSettings();
               if (rowSettings) {
                  settings.fieldOperations.push(rowSettings);
               }
            });

            return settings;
         },
      });

      return {
         ui: _ui,
         init: init,
         fromSettings: (settings) => {
            _logic.fromSettings(settings);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   /**
    * queryBuilderDisplay
    * returns our Query Builder object used in our display.
    * It is called by the .showQBIfNeeded() method.
    * @return {ABViewQueryBuilderObjectFieldConditions}
    */
   queryBuilderDisplay() {
      if (!this.objectQB) {
         this.objectQB = new ObjectQueryBuilder(
            L("How to choose which object:")
         );

         var connObj = this.connectedObject();
         if (connObj) this.objectQB.objectLoad(connObj);
      }
      return this.objectQB;
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      this._formData = options.data;

      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      var condition = null; // our lookup condition

      // modifyCondition
      // async fn() to fill out what the condition should be for limiting the remote
      // objects to values in use by the current object.
      // @param {fn} cb  the callback to use when we are finished:
      //					cb(err, )
      var modifyCondition = (cb) => {
         // So, let's get a copy of our current data, with all it's connected items
         // attached.
         var thisModel = this.baseObject.model();
         thisModel
            .findConnected(connectionField.columnName, options.data)
            .then((items) => {
               // if we didn't get any results, then simply return
               // NOTE: this will leave condition == null and cancel this update.
               if (!items || items.length == 0) {
                  cb();
                  return;
               }

               // then use these to limit the connected data of our Action:

               // get all the ids
               var ids = items.map((i) => {
                  return i.id;
               });

               // resulting condition: { id in [listIDs]} AND { QB Condition }
               condition = {
                  glue: "and",
                  rules: [
                     {
                        key: connObj.PK(),
                        rule: "in",
                        value: ids,
                     },
                  ],
               };

               // check to make sure qbCondition actually has a condition before adding it
               // to our condition:
               if (Object.keys(this.qbCondition).length > 0) {
                  condition.rules.push(this.qbCondition);
               }

               cb();
            })
            .catch(cb);
      };

      // .process() returns a Promise
      return new Promise((resolve, reject) => {
         // upateIt()
         // updates a given item with our changes.
         // @param {obj} item  the item to update
         // @param {fn}  cb    a callback function when update is complete.
         var updateIt = (item, cb) => {
            let isUpdated = this.processUpdateObject({}, item);
            if (!isUpdated) {
               cb();
            } else {
               model
                  .update(item.id, item)
                  .then(() => {
                     cb();
                  })
                  .catch((err) => {
                     this.AB.notify.developer(err, {
                        message:
                           "!!! ABViewRuleActionFormRecordRuleUpdateConnected.process(): update error:",
                        data: options.data,
                     });
                     cb(err);
                  });
            }
         };

         // now figure out which elements belong to this object
         // done in modifyCondition()
         modifyCondition((err) => {
            if (err) {
               reject(err);
               return;
            }

            if (condition === null) {
               // this is the case where we didn't have the proper data to complete our
               // update.  So let's just fail gracefully, and continue on.

               // QUESTION: is this the right way to handle it?
               resolve();
            } else {
               // get all the entries that match our condition:
               model
                  .findAll({ where: condition })
                  .then((list) => {
                     var done = 0;

                     // list : {data: Array(4), total_count: 4, pos: null, offset: null, limit: null}
                     if (list && list.data) {
                        list = list.data;
                     }

                     // for each entry, update it with our values:
                     list.forEach((item) => {
                        updateIt(item, (err) => {
                           if (err) {
                              return reject(err);
                           }
                           done++;
                           if (done >= list.length) {
                              // now they are all updated, so continue.
                              resolve();
                           }
                        });
                     });

                     // if there were no entries to update -> continue
                     if (list.length == 0) {
                        resolve();
                     }
                  })
                  .catch(reject);
            }
         }); // end modifyCondition()
      }); // end Promise()
   }

   /**
    * fromSettings
    * initialize this Action = require(a given set of setting values.
    * @param {obj} settings  the settings {} returned = require(toSettings()
    */
   fromSettings(settings) {
      settings = settings || {};

      this.selectedFieldID = settings.selectedFieldID || null;
      this.qbCondition = settings.qbCondition || {};

      super.fromSettings(settings);

      // if we have a display component, then populate it:
      if (this._uiChooser) {
         this._logic.fromSettings(settings);
      }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //  qbCondition: [],
      //	valueRules:{}		// = require(ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.selectedFieldID = this.selectedFieldID;

      var qbCond = null;
      if (this.objectQB) {
         qbCond = this.objectQB.getValue();
         if (Array.isArray(qbCond)) {
            qbCond = qbCond[0];
         }

         // FIX: make sure qbCond root element has a 'glue'
         if (qbCond) {
            qbCond.glue = qbCond.glue || "and";
         }
      }
      settings.qbCondition = qbCond;

      // if we have a display component, then request our details = require(it:
      if (this._uiChooser) {
         settings.valueRules = this._logic.toSettings();
      }

      return settings;
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      if (this.objectQB) {
         this.objectQB.setValue(this.qbCondition);
      }
   }
};


/***/ }),

/***/ 97521:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleClosePopup.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleClosePopup
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleClosePopup extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleClosePopup";
      this.label = L("Close the current popup");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      this._ui = {
         ui: {
            view: "layout",
            rows: [],
         },

         init: () => {},
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         let form = options.form;
         if (!form) return;

         let popup = form.pageParent((p) => p.settings.type == "popup");
         if (!popup) return;

         // get the dom id of page. it is dom id that is generated in ABLiveTool.js
         // let pageDomId = ["ab_live_page", popup.application.id, popup.id].join(
         //    "_"
         // );

         // close current popup
         let $popup = $$(popup.id);
         if ($popup) $popup.hide();

         // this clears the UI's record of the current form.
         options.form.changePage(null);

         resolve();
      });
   }
};


/***/ }),

/***/ 26220:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleConfirmMessage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleConfirmMessage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleConfirmMessage";
      this.label = L("Show a confirmation message");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         message: `${idBase}_message`,
      };

      this._ui = {
         ui: {
            id: ids.message,
            view: "textarea",
            // label: this.labels.component.message,
            // labelWidth: this.AB.UISettings.config().labelWidthLarge,
            height: 130,
         },

         init: () => {},

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.message).setValue(valueRules.message || "");
         },

         toSettings: () => {
            // return the confirm message
            return {
               message: $$(ids.message).getValue() || "",
            };
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var confirmMessage = this.valueRules.message || "";

         webix.message({
            text: confirmMessage,
            type: "info",
         });

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 8873:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleEmail.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);
const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 66589);
const ABFieldEmail = __webpack_require__(/*! ../../platform/dataFields/ABFieldEmail */ 39137);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleEmail extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleEmail";
      this.label = L("Send a custom email");

      this.queryObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.queryObject) {
   //       this.queryObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         form: `${idBase}_form`,
         popup: `${idBase}_popup`,
         list: `${idBase}_fieldList`,
         toEmailsContainer: `${idBase}_toEmailsContainer`,
         toEmails: `${idBase}_toEmails`,
         message: `${idBase}_message`,
      };

      this._ui = {
         ui: {
            id: ids.form,
            view: "form",
            width: 450,
            elementsConfig: {
               labelPosition: "top",
               labelWidth: 100,
            },
            cols: [
               // email form
               {
                  width: 330,
                  rows: [
                     {
                        view: "text",
                        name: "fromName",
                        label: L("From Name"),
                     },
                     {
                        view: "text",
                        name: "fromEmail",
                        label: L("From Email"),
                        validate: webix.rules.isEmail,
                        on: {
                           onChange: function (newVal, oldVal) {
                              if (this.getValue() && !this.validate()) {
                                 $$(ids.form).markInvalid(
                                    "fromEmail",
                                    "Email is invalid"
                                 );
                              } else {
                                 $$(ids.form).markInvalid("fromEmail", false);
                              }
                           },
                        },
                     },
                     {
                        id: ids.toEmailsContainer,
                        view: "forminput",
                        name: "toEmails",
                        label: L("Send"),
                        css: "ab-rich-text",
                        width: 320,
                        body: {
                           width: 320,
                           rows: [
                              {
                                 height: 25,
                              },
                              {
                                 id: ids.toEmails,
                                 width: 320,
                                 view: "layout",
                                 rows: [],
                              },
                              {
                                 view: "button",
                                 css: "webix_primary",
                                 type: "icon",
                                 icon: "fa fa-plus",
                                 label: L("Add a recipient"),
                                 width: 150,
                                 click: () => {
                                    _logic.toEmailAdd();
                                 },
                              },
                           ],
                        },
                     },
                     {
                        view: "text",
                        name: "subject",
                        label: L("Subject"),
                     },
                     {
                        view: "textarea",
                        id: ids.message,
                        name: "message",
                        label: L("Message"),
                        width: 320,
                        height: 400,
                     },
                     // {
                     // 	view: 'label',
                     // 	label: 'Message',
                     // 	css: { 'font-weight': 'bold' }
                     // },
                     // {
                     // 	view: 'forminput',
                     // 	id: ids.message,
                     // 	name: 'message',
                     // 	label: 'Message',
                     // 	css: "ab-rich-text",
                     // 	width: 320,
                     // 	height: 400,
                     // 	body: {
                     // 		view: 'tinymce-editor'
                     // 	}
                     // }
                  ],
               },
               // field list
               {
                  rows: [
                     {
                        view: "template",
                        type: "header",
                        template: "Fields",
                     },
                     {
                        id: ids.list,
                        view: "list",
                        width: 120,
                        css: { "background-color": "#fff !important;" },
                        template: function (obj, common) {
                           return _logic.fieldTemplate(obj, common);
                        },
                        on: {
                           onItemClick: function (id, e, node) {
                              var component = this.getItem(id);

                              _logic.enterField(component);
                           },
                        },
                     },
                  ],
               },
            ],
         },

         init: () => {
            if (this.queryObject) {
               $$(ids.list).parse(
                  this.queryObject.fields((f) => f.fieldUseAsLabel())
               );
               $$(ids.list).refresh();
            }

            _logic.refreshUI();
         },

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.form).setValues(valueRules);

            // Populate recipients
            var recipients = valueRules.toEmails || [];
            recipients.forEach((r) => {
               _logic.toEmailAdd({
                  type: r.type, // 'to', 'cc' or 'bcc'
                  emailType: r.emailType, // 'email' or 'field'
                  value: r.value,
               });
            });

            _logic.refreshUI();
         },

         toSettings: () => {
            var formVals = $$(ids.form).getValues() || {};

            // Get recipients
            var recipients = [];
            $$(ids.toEmails)
               .getChildViews()
               .forEach((e) => {
                  // var type = e.queryView({ name: 'type' }).getValue();
                  var type = "to"; // TODO
                  var emailType = e.queryView({ name: "emailType" }).getValue();
                  var value = e.queryView({ name: emailType }).getValue();

                  recipients.push({
                     type: type,
                     emailType: emailType,
                     value: value,
                  });
               });

            // return the confirm message
            return {
               fromName: formVals["fromName"],
               fromEmail: formVals["fromEmail"],
               toEmails: recipients,
               subject: formVals["subject"],
               message: formVals["message"],
            };
         },

         /**
          * @method toEmailTemplate
          *
          * @param settings - {
          * 			type: string, // 'to', 'cc' or 'bcc'
          * 			emailType: string, // 'email' or 'field'
          * 			value: string
          * }
          */
         toEmailTemplate: (settings) => {
            settings = settings || {};

            return {
               width: 320,
               cols: [
                  // {
                  // 	view: 'richselect',
                  // 	name: 'type',
                  // 	value: settings.type || 'to',
                  // 	width: 80,
                  // 	options: [
                  // 		{ id: 'to', value: "To:" },
                  // 		// EmailNotification does not support cc, bcc and reply.
                  // 		// { id: 'cc', value: "Cc:" },
                  // 		// { id: 'bcc', value: "Bcc:" },
                  // 		// { id: 'reply', value: "Reply-To:" }
                  // 	]
                  // },
                  {
                     view: "richselect",
                     name: "emailType",
                     value: settings.emailType || "email",
                     width: 150,
                     options: [
                        {
                           id: "email",
                           value: L("A custom email address"),
                        },
                        { id: "field", value: L("An email field") },
                        { id: "query", value: L("From query") },
                     ],
                     on: {
                        onChange: function (newVal, oldVal) {
                           _logic.emailTypeChange(newVal, this);
                        },
                     },
                  },
                  {
                     width: 150,
                     name: "emailValue",
                     visibleBatch: settings.emailType || "email",
                     cols: [
                        {
                           view: "text",
                           name: "email",
                           batch: "email",
                           value:
                              settings.emailType == "email"
                                 ? settings.value
                                 : "",
                           validate: webix.rules.isEmail,
                           width: 150,
                           on: {
                              onChange: function (newVal, oldVal) {
                                 _logic.toEmailValidate();
                              },
                           },
                        },
                        {
                           view: "richselect",
                           name: "field",
                           batch: "field",
                           value:
                              settings.emailType == "field"
                                 ? settings.value
                                 : "",
                           width: 150,
                           suggest: {
                              on: {
                                 onBeforeShow: function () {
                                    this.define("width", 300);
                                    this.resize();
                                 },
                              },
                              data: _logic.emailFieldOptions(),
                           },
                        },
                        {
                           view: "richselect",
                           name: "query",
                           batch: "query",
                           value:
                              settings.emailType == "query"
                                 ? settings.value
                                 : "",
                           width: 150,
                           suggest: {
                              on: {
                                 onBeforeShow: function () {
                                    this.define("width", 300);
                                    this.resize();
                                 },
                              },
                              data: _logic.queryOptions(),
                           },
                        },
                     ],
                  },
                  {
                     view: "button",
                     css: "webix_danger",
                     type: "icon",
                     icon: "fa fa-trash-o",
                     width: 32,
                     click: function () {
                        var $toView = this.getParentView();

                        _logic.toEmailRemove($toView);
                     },
                  },
               ],
            };
         },

         toEmailAdd: (settings) => {
            var count = $$(ids.toEmails).getChildViews().length;

            $$(ids.toEmails).addView(_logic.toEmailTemplate(settings), count);

            _logic.refreshUI();
         },

         emailTypeChange: (type, $select) => {
            var $recipient = $select.getParentView();
            var $emailValue = $recipient.queryView({ name: "emailValue" });

            switch (type) {
               case "field":
                  $emailValue.showBatch("field");
                  break;
               case "query":
                  $emailValue.showBatch("query");
                  break;
               default:
                  $emailValue.showBatch("email");
                  break;
            }

            $$(ids.toEmailsContainer).adjust();
         },

         toEmailRemove: ($toView) => {
            $$(ids.toEmails).removeView($toView);

            _logic.refreshUI();
         },

         toEmailValidate: () => {
            var isAllValid = true;

            $$(ids.toEmails)
               .getChildViews()
               .forEach((v) => {
                  let emailText = v.queryView({ name: "email" });
                  if (emailText.getValue() && !emailText.validate()) {
                     isAllValid = false;
                  }
               });

            if (isAllValid) $$(ids.form).markInvalid("toEmails", false);
            else $$(ids.form).markInvalid("toEmails", "Email is invalid");
         },

         fieldTemplate: (field, common) => {
            return `<i class='fa fa-${field.icon} webix_icon_btn' aria-hidden='true'></i> ${field.label}`;
         },

         emailFieldOptions: () => {
            var existsFieldIds = [];
            var options = [];

            var fnAddOptions = (currObj, fLink) => {
               var emailFields = currObj
                  .fields((f) => f instanceof ABFieldEmail)
                  .map((f) => {
                     var optId = "",
                        optLabel = "";

                     if (fLink) {
                        optId = `${fLink.id}|${f.urlPointer()}`;
                        optLabel = `${currObj.label}.${f.label} (${fLink.label})`;
                     } else {
                        optId = `|${f.urlPointer()}`;
                        optLabel = `${currObj.label}.${f.label}`;
                     }

                     return {
                        id: optId, // linkFieldId|fieldUrl
                        value: optLabel,
                     };
                  });

               // TODO: prevent duplicate

               options = options.concat(emailFields);
            };

            fnAddOptions(this.queryObject);

            this.queryObject.connectFields().forEach((f) => {
               // prevent looping
               if (
                  // - prevent include connect objects of the base object
                  // f.datasourceLink.id == this.queryObject.id ||
                  // - check duplicate include objects
                  existsFieldIds.indexOf(f.id) > -1
               )
                  return;

               // store
               existsFieldIds.push(f.id);

               // add email fields of link object
               fnAddOptions(f.datasourceLink, f);
            });

            return options;
         },

         queryOptions: () => {
            var options = [];

            // get data collections who is query and contains email field
            let dcQueries = this.currentForm.AB.datacollections((dc) => {
               let obj = dc.datasource;
               return (
                  dc.settings.isQuery &&
                  obj &&
                  obj.fields((f) => f.key == "email").length > 0
               );
            });

            dcQueries.forEach((dv) => {
               if (dv.datasource) {
                  dv.datasource
                     .fields((f) => f.key == "email")
                     .forEach((f) => {
                        options.push({
                           id: `${dv.id}|${f.id}`, // ABDatacollectionID|fieldID
                           value: `${dv.label}.${f.label}`,
                        });
                     });
               }
            });

            return options;
         },

         enterField: (field) => {
            var focusElem = webix.UIManager.getFocus();
            var val = "";

            if (
               focusElem.config.view != "text" ||
               focusElem.config.view != "textarea"
            ) {
               if (focusElem.getValue) val = focusElem.getValue();

               if (focusElem.setValue)
                  focusElem.setValue(`${val}${field.label}`);

               webix.UIManager.setFocus(focusElem);
            }
         },

         refreshUI: () => {
            $$(ids.toEmailsContainer).adjust();
            $$(ids.message).adjust();
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options - {
   //							data: {obj} rowData,
   //							form: {ABViewForm}
   //						}
   process(options) {
      // validate sender's email is invalid
      if (!webix.rules.isEmail(this.valueRules.fromEmail)) {
         return Promise.resolve();
      }

      var recipients = [];

      return Promise.resolve()
         .then(() => {
            // Pull recipients data
            return new Promise((resolve, reject) => {
               var tasks = [];

               this.valueRules.toEmails.forEach((rec) => {
                  tasks.push(
                     new Promise((next, err) => {
                        // TODO: Cc, Bcc

                        // field
                        if (rec.emailType == "field") {
                           var emailFieldUrl = rec.value.split("|")[1]; // linkFieldId|emailFieldUrl
                           var emailField = this.queryObject.application.urlResolve(
                              emailFieldUrl
                           );
                           if (emailField) {
                              // Pull email source object
                              if (emailField.object.id == this.queryObject.id) {
                                 var emailData =
                                    options.data[emailField.columnName];
                                 if (emailData)
                                    recipients = recipients.concat(emailData);
                              }
                              // Pull emails from link object
                              else {
                                 let linkFieldId = rec.value.split("|")[0];
                                 let linkFields = this.queryObject.fields(
                                    (f) =>
                                       f instanceof ABFieldConnect &&
                                       f.id == linkFieldId
                                 );
                                 linkFields.forEach((f) => {
                                    var linkedData =
                                       options.data[f.relationName()] || [];

                                    // convert to an array
                                    if (
                                       linkedData &&
                                       !Array.isArray(linkedData)
                                    )
                                       linkedData = [linkedData];

                                    // pull email address
                                    linkedData.forEach((d) => {
                                       var email = d[emailField.columnName];
                                       if (email)
                                          recipients = recipients.concat(email);
                                    });
                                 });
                              }

                              next();
                           } else {
                              next();
                           }
                        }

                        // query
                        else if (rec.emailType == "query") {
                           var dvIdAndFieldId = rec.value; // ABDatacollectionId|fieldId
                           if (!dvIdAndFieldId) return next();

                           var dcId = dvIdAndFieldId.split("|")[0];
                           var fieldId = dvIdAndFieldId.split("|")[1];

                           var dcQuery = this.currentForm.AB.datacollectionByID(
                              dcId
                           );
                           if (!dcQuery) return next();

                           var field = dcQuery.datasource.fieldByID(fieldId);
                           if (!field) return next();

                           // get data of data collection
                           dcQuery.getData().forEach((data) => {
                              var emailAddr = data[field.columnName];
                              if (emailAddr) recipients.push(emailAddr);
                           });

                           next();
                        }

                        // email
                        else {
                           recipients.push(rec.value);
                           next();
                        }
                     })
                  );
               });

               Promise.all(tasks).catch(reject).then(resolve);
            });
         })
         .then(() => {
            // send out
            return new Promise((resolve, reject) => {
               recipients = this.AB.uniq(recipients).filter((r) => r);

               if (!recipients || recipients.length < 1) return resolve();

               // replace form value to template
               var fromName = this.valueRules.fromName,
                  subject = this.valueRules.subject,
                  message = this.valueRules.message;

               this.queryObject
                  .fields((f) => f.fieldUseAsLabel())
                  .forEach((f) => {
                     var template = new RegExp(`{${f.label}}`, "g"),
                        data = f.format(options.data);

                     fromName = fromName.replace(template, data);
                     subject = subject.replace(template, data);
                     message = message.replace(template, data);
                  });

               // send a email
               this.AB.Network.post({
                  url: "/app_builder/email",
                  params: {
                     fromName: fromName,
                     fromEmail: this.valueRules.fromEmail,
                     subject: subject,
                     message: message,
                     recipients: this.AB.uniq(recipients),
                  },
               })
                  .then(() => {
                     resolve();
                  })
                  .catch(reject);
            });
         });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 14316:
/*!*********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleExistPage.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleExistPage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleExistPage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleExistPage";
      this.label = L("Redirect to an existing page");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         pagesAndTabs: `${idBase}_PagesAndTabs`,
      };

      this._ui = {
         ui: { id: ids.pagesAndTabs, view: "richselect", options: [] },

         init: () => {
            _logic.populateOptions();
         },

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         populateOptions: () => {
            // Pull page list to "Redirect to an existing page"
            var _pageOptions = [];

            /**
             * @param pageOrTab	{Object}	- ABViewPage or ABViewTab
             * @param indent	{integer}
             * @param type		{string}	- 'page' or 'tab'
             * @param pageId	{uuid}		- the id of page (only tab)
             */
            var addPage = (pageOrTab, indent, type, pageId) => {
               indent = indent || "";

               let icon = "fa fa-file-o";
               if (type == "tab") icon = "fa fa-window-maximize";

               let pageParent = pageOrTab.pageParent();

               _pageOptions.push({
                  id: pageOrTab.id,
                  value: indent + pageOrTab.label,
                  type: type,
                  pageId: pageParent ? pageParent.id : null,

                  icon: icon,
               });

               if (type == "page" || type == "tab") {
                  if (pageOrTab.pages) {
                     pageOrTab.pages().forEach(function (p) {
                        addPage(p, indent + "-", "page");
                     });
                  }

                  // add 'tab' options
                  if (pageOrTab.views) {
                     pageOrTab
                        .views((v) => v.key == "tab")
                        .forEach((tab) => {
                           // add 'tab view' to options
                           tab.views().forEach((tabView) => {
                              addPage(
                                 tabView,
                                 indent + "-",
                                 "tab",
                                 pageOrTab.id
                              );
                           });
                        });
                  }
               }
            };

            addPage(this.currentForm.pageRoot(), "", "page");

            $$(ids.pagesAndTabs).define("options", _pageOptions);
            $$(ids.pagesAndTabs).refresh();
         },

         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.pagesAndTabs).setValue(
               valueRules.tabId || valueRules.pageId || ""
            );
         },

         toSettings: () => {
            var result = {};

            var selectedId = $$(ids.pagesAndTabs).getValue();
            var selectedItem = $$(ids.pagesAndTabs)
               .getPopup()
               .getList()
               .config.data.filter((opt) => opt.id == selectedId)[0];
            if (selectedItem) {
               if (selectedItem.type == "tab") {
                  // store page id and tab id
                  result = {
                     pageId: selectedItem.pageId,
                     tabId: selectedId,
                  };
               } else {
                  // store only page id
                  result = {
                     pageId: selectedId,
                  };
               }
            }

            // return the confirm message
            return result;
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect page
         if (this.valueRules.pageId) {
            options.form.changePage(this.valueRules.pageId);

            if (this.valueRules.tabId) {
               var curPage = options.form.application.pages(
                  (p) => p.id == this.valueRules.pageId,
                  true
               )[0];
               if (!curPage) return resolve();

               // switch tab
               var tabView = curPage.views(
                  (v) => v.id == this.valueRules.tabId,
                  true
               )[0];
               if (!tabView) return resolve();

               var tab = tabView.parent;
               if (!tab) return resolve();

               var toggleParent = (element) => {
                  if (!element.parent) return false;
                  var parentElem = element.parent;
                  if (!parentElem.parent) return false;
                  parentElem.parent.emit("changeTab", parentElem.id);
                  toggleParent(parentElem.parent);
               };

               toggleParent(tab);
               let showIt = setInterval(function () {
                  if ($$(tabView.id) && $$(tabView.id).isVisible()) {
                     clearInterval(showIt);
                     return;
                  }
                  tab.emit("changeTab", tabView.id);
               }, 100);
            }
         }

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 50924:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleParentPage.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleParentPage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleParentPage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleParentPage";
      this.label = L("Redirect to the parent page");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      this._ui = {
         ui: {
            view: "label",
            label: this.label,
         },

         init: () => {},

         _logic: _logic,
      };

      var _logic = {};

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var pageCurrent = options.form.pageParent();
         var pageParent = pageCurrent.pageParent();

         // redirect page
         options.form.changePage(pageParent.id);

         resolve();
      });
   }
};


/***/ }),

/***/ 64151:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleWebsite.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleWebsite extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleWebsite";
      this.label = L("Redirect to another website URL");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         website: `${idBase}_website`,
      };

      this._ui = {
         ui: {
            id: ids.website,
            view: "text",
         },

         init: () => {},

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.website).setValue(valueRules.website || "");
         },

         toSettings: () => {
            // return the confirm message
            return {
               website: $$(ids.website).getValue() || "",
            };
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect to website
         if (this.valueRules.website)
            window.open(
               `http://${this.valueRules.website.replace("http://", "")}`,
               "_blank"
            );

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 45263:
/*!***********************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionObjectUpdater.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABViewRuleActionObjectUpdater
//
// An action that allows you to update fields on an object.
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 84496);

let L = (...params) => AB.Multilingual.label(...params);

var ABViewRuleActionObjectUpdaterDefaults = {
   filterConditions: {
      // array of filters to apply to the data table
      glue: "and",
      rules: [],
   },
};

module.exports = class ABViewRuleActionObjectUpdater extends ABViewRuleAction {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = L("Update Record");

      this.updateObject = null; // the object this Action will Update.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]

      this.stashRules = {}; // keep track of rule settings among our selected objects.
   }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      if (this._uiUpdater == null) {
         this._uiUpdater = this.valueDisplayList(idBase);
      }

      return this._uiUpdater;
   }

   // Our Values Display is a List of ValueRows
   // Each ValueRow will display an additional set of [add] [delete] buttons.

   valueDisplayList(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };
      var ids = {
         updateForm: myUnique("updateForm"),
      };

      var _ui = {
         view: "form",
         id: ids.updateForm,
         elements: [],
      };

      var init = (valueRules) => {
         valueRules = valueRules || this.valueRules;
         _logic.setValues(valueRules);
      };

      var _logic = {
         removeAddRow: () => {
            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // check row that's unselect a field
            var rows = UpdateForm.getChildViews();

            var addRow = rows.filter((r) => {
               return r.queryView(function (view) {
                  return view.config.name == "field" && !view.getValue();
               });
            })[0];
            if (!addRow) return;

            UpdateForm.removeView(addRow);
         },

         // addRow
         // add a new data entry to this form.
         // @param {obj} data  (optional) initial values for this row.
         addRow: (data) => {
            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // check row that's unselect a field
            var rows = UpdateForm.getChildViews();
            if (
               data == null &&
               rows.filter((r) => {
                  return r.queryView(function (view) {
                     return view.config.name == "field" && !view.getValue();
                  });
               }).length > 0
            )
               return;

            // get a new Row Component
            var row = this.valueDisplayRow(idBase);

            // add row to Form
            UpdateForm.addView(row.ui);

            // initialize row with any provided data:
            row.init({
               onAdd: () => {
                  // add a new Row
                  _logic.addRow();
               },
               onDelete: (rowId) => {
                  // remove a row
                  _logic.delRow(rowId);
               },
               data: data,
            });

            // store this row
            this.formRows.push(row);
         },

         delRow: (rowId) => {
            // store this row
            this.formRows.forEach((r, index) => {
               if (r.ui.id == rowId) this.formRows.splice(index, 0);
            });

            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // remove UI
            UpdateForm.removeView($$(rowId));
         },

         formClear: () => {
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            var children = UpdateForm.getChildViews();

            // NOTE: need to clone this array, because it is connected with the UpdatForm's
            // internal array of items.  Once we start .removeView() the element actually
            // is removed from the internal array, which then upset's the .forEach() from
            // properly iterating through the structure.  It results in missed items from
            // being sent to the .forEach().
            // So Clone it and use that for .forEach()
            var cloneChildren = [];
            children.forEach((c) => {
               cloneChildren.push(c);
            });
            cloneChildren.forEach((c) => {
               UpdateForm.removeView(c);
            });

            // clear our stored .formRows
            this.formRows = [];
         },

         formGet: () => {
            var UpdateForm = $$(ids.updateForm);
            if (!UpdateForm) {
               // this is a problem!
               this.currentForm.AB.notify.developer(
                  new Error("no webix form"),
                  {
                     context:
                        "ABViewRuleActionObjectUpdater:formGet  could not find webix form",
                     id: ids.updateForm,
                  }
               );
               return null;
            }

            return UpdateForm;
         },

         setValues: (valueRules) => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }

            valueRules = valueRules || {};
            valueRules.fieldOperations = valueRules.fieldOperations || [];

            // find the form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // clear form:
            _logic.formClear();

            // if there are values to
            if (valueRules.fieldOperations.length > 0) {
               valueRules.fieldOperations.forEach((r) => {
                  _logic.addRow(r);
               });
            }

            // our default operation will cause an empty row to
            // appear after our first value entry.
            // let's remove that one, and then add a new one
            // at the end:
            _logic.removeAddRow();

            // display an empty row
            _logic.addRow();
         },

         fromSettings: (settings) => {
            // Note: we just want the { valueRules:[] } here:
            var mySettings = settings.valueRules || settings;

            _logic.setValues(mySettings);
         },

         toSettings: () => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }
            var settings = { fieldOperations: [] };

            // for each of our formRows, decode the propery {}
            this.formRows.forEach((fr) => {
               var rowSettings = fr.toSettings();
               if (rowSettings) {
                  settings.fieldOperations.push(fr.toSettings());
               }
            });

            return settings;
         },
      };

      return {
         ui: _ui,
         init: init,
         fromSettings: (settings) => {
            _logic.fromSettings(settings);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   valueDisplayRow(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return key + "_" + uniqueInstanceID;
      };

      var ids = {
         row: myUnique("row"),
         updateForm: myUnique("updateFormRow"),
         field: myUnique("field"),
         value: myUnique("value"),
         selectDc: myUnique("selectDc"),
         selectBy: myUnique("selectBy"),
         queryField: myUnique("queryField"),
         multiview: myUnique("multiview"),
         buttonAdd: myUnique("add"),
         buttonDelete: myUnique("delete"),
      };

      var FilterComponent;

      var _logic = {
         callbacks: {
            onAdd: () => {},
            onDelete: () => {},
         },

         buttonsToggle: () => {
            $$(ids.row).getChildViews()[0].getChildViews()[4].hide();
            $$(ids.row).getChildViews()[0].getChildViews()[5].show();
         },

         getFieldList: (shouldFilter) => {
            var options = [];
            if (this.updateObject) {
               options = (this.updateObject.fields() || []).map((f) => {
                  return {
                     id: f.id,
                     value: f.label,
                  };
               });

               // options = (this.updateObject.fields() || [])
               // .filter(f => {
               //
               // 	if (f.key != 'connectObject') {
               // 		return true;
               // 	} else {
               // 		// if this is a connection field, only return
               // 		// fields that are 1:x  where this field is the
               // 		// source:
               // 		// return ((f.linkType() == 'one') && (f.isSource()))
               //
               // 		// 6-14-2018 Changing from only 1:x to support many
               // 		// if this is a connected field, only return
               // 		// fields that this is the source
               // 		return (f.isSource())
               // 	}
               // })
               // .map(f => {
               // 	return {
               // 		id: f.id,
               // 		value: f.label
               // 	};
               // });

               // Remove fields who are selected
               if (shouldFilter) {
                  // store this row
                  var usedHash = {};
                  this.formRows.forEach((row) => {
                     var rowView = $$(row.ui.id);
                     if (rowView) {
                        var field = rowView
                           .getChildViews()[0]
                           .getChildViews()[1];
                        usedHash[field.getValue()] = true;
                     }
                  });
                  options = options.filter((o) => {
                     return !usedHash[o.id];
                  });
               }
            }
            return options;
         },

         isValid: () => {
            var validator = this.currentForm.AB.Validation.validator();
            var valueField = $$(ids.row).getChildViews()[0].getChildViews()[3];
            var FormView = valueField.getParentView().getParentView();

            var field = this.getUpdateObjectField($$(ids.field).getValue());
            if (field) {
               var value = field.getValue(valueField, {});

               // // if a standard component that supports .getValue()
               // if (valueField.getValue) {
               // 	value = valueField.getValue();
               // } else {
               // 	// else use for field.getValue();
               // 	value = field.getValue(valueField, {});
               // }

               // our .isValidData() wants value in an object:
               var obj = {};
               obj[field.columnName] = value;

               field.isValidData(obj, validator);

               // if value is empty, this is also an error:
               if (
                  value == "" ||
                  value == null ||
                  (Array.isArray(value) && value.length == 0)
               ) {
                  validator.addError(
                     field.columnName,
                     L("A value is required")
                  );
               }

               // field.getParentView()  ->  row
               // row.getParentView()  -> Form
               FormView.clearValidation();
               validator.updateForm(FormView);

               return validator.pass();
            } else {
               // if we didn't find an associated field ... then this isn't good
               // data.

               //// TODO: display error for our field picker.  Note, it doesn't have a unique .name
               // field.
               var fieldField = $$(ids.row)
                  .getChildViews()[0]
                  .getChildViews()[1];
               fieldField.define("invalidMessage", L("A value is required"));
               fieldField.define("invalid", true);
               fieldField.refresh();
               // fieldField.markInvalid(this.labels.component.errorRequired);
               return false;
            }
         },

         selectField: (columnID) => {
            var field = this.getUpdateObjectField(columnID);
            if (!field) return;

            var fieldComponent = field.formComponent(),
               abView = fieldComponent.newInstance(field.object.application),
               formFieldComponent = abView.component(this.App),
               $componentView = formFieldComponent.ui,
               $inputView;

            $componentView.id = ids.value; // set our expected id

            // find all the DataSources
            var datasources = this.currentForm.AB.datacollections(
               (dc) => dc.datasource
            );

            // create a droplist with those dataSources
            var optionsDataSources = [];
            datasources.forEach((dc) => {
               optionsDataSources.push({ id: dc.id, value: dc.label });
            });

            // create a droplist with select options
            var optionsSelectBy = [
               { id: "select-one", value: L("Current selection") },
               {
                  id: "filter-select-one",
                  value: L("Select first after filter by..."),
               },
            ];

            var $optionUpdateExsits = {
               type: "clean",
               rows: [
                  {
                     cols: [
                        {
                           id: ids.selectDc,
                           view: "combo",
                           options: optionsDataSources,
                           placeholder: L("Choose a data source"),
                           on: {
                              onChange: (newv, oldv) => {
                                 var selectedDC = this.currentForm.AB.datacollectionByID(
                                    newv
                                 );
                                 if (
                                    selectedDC &&
                                    (selectedDC.sourceType == "query" ||
                                       !field.isConnection)
                                 ) {
                                    var queryFieldOptions = [];
                                    selectedDC.datasource
                                       .fields()
                                       .forEach((f) => {
                                          queryFieldOptions.push({
                                             id: f.id,
                                             value: f.label,
                                          });
                                       });
                                    $$(ids.queryField).define(
                                       "options",
                                       queryFieldOptions
                                    );
                                    $$(ids.queryField).refresh();
                                    $$(ids.queryField).show();
                                 } else {
                                    $$(ids.queryField).hide();
                                 }
                              },
                           },
                        },
                        // we will place a list of query fields if you choose a datasource that has a query source type
                        {
                           id: ids.queryField,
                           view: "combo",
                           hidden: true,
                           placeholder: L("Choose value from..."),
                           options: [{ id: 1, value: "figure this out" }],
                        },
                     ],
                  },
                  {
                     id: ids.selectBy,
                     view: "combo",
                     options: optionsSelectBy,
                     placeholder: L("Choose select option"),
                     on: {
                        onChange: (newv, oldv) => {
                           var $row = $$(ids.row);
                           $row.removeView($row.getChildViews()[1]);
                           if (newv == "select-one") {
                              $row.addView({}, 1);
                           } else {
                              var options = this.currentForm.datacollection.datasource
                                 .fields()
                                 .map(function (f) {
                                    return {
                                       id: f.id,
                                       value: f.label,
                                    };
                                 });

                              FilterComponent = this.AB.filterComplexNew(
                                 `${idBase}_filter`
                              );
                              // FilterComponent.applicationLoad(
                              //    this.currentForm.application
                              // );
                              FilterComponent.init({
                                 isRecordRule: true,
                                 fieldOptions: options,
                              });
                              FilterComponent.on("change", (val) => {
                                 _logic.onFilterChange(val);
                              });

                              $row.addView(FilterComponent.ui, 1);

                              var dcId = $$(ids.selectDc).getValue();
                              var dataCollection = this.currentForm.AB.datacollectionByID(
                                 dcId
                              );
                              if (dataCollection) {
                                 _logic.populateFilters(dataCollection);
                              }
                           }
                        },
                     },
                  },
               ],
            };

            // WORKAROUND: add '[Current User]' option to the user data field
            if (field.key == "user") {
               $componentView.options = $componentView.options || [];
               $componentView.options.unshift({
                  id: "ab-current-user",
                  value: L("[Current User]"),
               });
            }

            // UPDATE: ok, in practice we have not had any use cases where
            // we want individual values on connectedObject fields, but
            // instead we want to insert the current selected element from
            // a relevant data view.  So, replace the fieldComponet
            // from a connectedObject field with a list of data views that
            // are based upon the same object we are connected to:
            if (field.isConnection) {
               // find the ABObject this field connects to
               var connectedObject = field.datasourceLink;

               // find all the DataSources that are based upon this ABObject
               // to do this, we find the root Page we are on, then ask that Page for datasources:
               datasources = datasources.filter((dc) => {
                  return dc.datasource.id == connectedObject.id;
               });

               var dcQueries = this.currentForm.AB.datacollections((dc) => {
                  return (
                     dc.sourceType == "query" &&
                     dc.datasource &&
                     dc.datasource.canFilterObject(connectedObject)
                  );
                  // return dc.datasource.id == connectedObject.id;
               });

               datasources = datasources.concat(dcQueries);

               // refresh a droplist with those dataSources
               optionsDataSources = [];
               datasources.forEach((dc) => {
                  optionsDataSources.push({ id: dc.id, value: dc.label });
               });

               // add select an array value option
               optionsSelectBy.push({
                  id: "filter-select-all",
                  value: L("Select all after filter by..."),
               });

               $inputView = $optionUpdateExsits;

               // and the upcoming formFieldComponent.init()
               // doesn't need to do anything:
               formFieldComponent = {
                  init: function () {},
               };

               // and we reset field so it's customDisplay isn't called:
               // field = {};
            } else {
               $inputView = {
                  id: ids.multiview,
                  view: "multiview",
                  cells: [
                     {
                        batch: "custom",
                        rows: [
                           $componentView,
                           {
                              view: "label",
                              label: `<a>${L("Or exists value")}</a>`,
                              on: {
                                 onItemClick: function () {
                                    var $container = this.getParentView(),
                                       $multiview = $container.getParentView();

                                    $multiview.showBatch("exist");
                                 },
                              },
                           },
                        ],
                     },
                     {
                        // Update value from exists object
                        batch: "exist",
                        rows: [
                           $optionUpdateExsits,
                           {
                              view: "label",
                              label: `<a>${L("Or custom value")}</a>`,
                              on: {
                                 onItemClick: function () {
                                    var $container = this.getParentView(),
                                       $multiview = $container.getParentView();

                                    // clear filter view
                                    $$(ids.selectBy).setValue("select-one");

                                    $multiview.showBatch("custom");
                                 },
                              },
                           },
                        ],
                     },
                  ],
               };
            }

            // Change component to display this field's form input
            var $row = $$(ids.row).getChildViews()[0];
            $row.removeView($row.getChildViews()[3]);
            $row.addView($inputView, 3);

            formFieldComponent.init();

            // Show custom display of data field
            if (!field.isConnection && field.customDisplay) {
               // field.customDisplay(field, this.App, $row.getChildViews()[3].$view, {

               var compNodeView = $$($componentView.id).$view;

               // wait until render UI complete
               setTimeout(() => {
                  field.customDisplay(field, this.App, compNodeView, {
                     editable: true,

                     // tree
                     isForm: true,
                  });
               }, 50);
            }

            // Show the remove button
            var $buttonRemove = $row.getChildViews()[4];
            $buttonRemove.show();

            // Add a new row
            if (columnID) _logic.callbacks.onAdd();
         },

         setValue: (data) => {
            $$(ids.field).setValue(data.fieldID);
            // note: this triggers our _logic.selectField() fn.
            var field = this.getUpdateObjectField(data.fieldID);
            if (field) {
               var setValueFn = () => {
                  $$(ids.selectDc).setValue(data.value);
                  if (data.queryField) {
                     $$(ids.queryField).setValue(data.queryField);
                  }
                  var selectBy = data.selectBy || "select-one";
                  $$(ids.selectBy).setValue(selectBy);

                  if (selectBy != "select-one") {
                     var collectionId = data.value;
                     var dataCollection = this.currentForm.AB.datacollectionByID(
                        collectionId
                     );
                     if (dataCollection && data.filterConditions) {
                        _logic.populateFilters(
                           dataCollection,
                           data.filterConditions
                        );
                     }
                  }
               };

               // now handle our special connectedObject case:
               if (field.isConnection) {
                  setValueFn();
               } else {
                  if (data.valueType == "exist") {
                     $$(ids.multiview).showBatch("exist");

                     setValueFn();
                  } else {
                     $$(ids.multiview).showBatch("custom");

                     // wait until render UI complete
                     setTimeout(function () {
                        // set value to custom field
                        var rowData = {};
                        rowData[field.columnName] = data.value;
                        field.setValue($$(ids.value), rowData);
                     }, 50);
                  }
               }
            }
         },

         populateFilters: (dataView, filterConditions) => {
            filterConditions =
               filterConditions ||
               ABViewRuleActionObjectUpdaterDefaults.filterConditions;

            // Populate data to popups
            // FilterComponent.objectLoad(objectCopy);
            FilterComponent.fieldsLoad(
               dataView.datasource ? dataView.datasource.fields() : []
            );
            FilterComponent.setValue(filterConditions);
         },

         toSettings: () => {
            // if this isn't the last entry row
            // * a row with valid data has the [delete] button showing.
            var buttonDelete = $$(ids.buttonDelete);
            if (buttonDelete && buttonDelete.isVisible()) {
               var data = {};
               data.fieldID = $$(ids.field).getValue();

               var $valueField = $$(ids.value);
               var field = this.getUpdateObjectField(data.fieldID);

               var getValueFn = () => {
                  data.value = $$(ids.selectDc).getValue();
                  data.queryField = $$(ids.queryField).getValue();
                  data.op = "set"; // possible to create other types of operations.
                  data.type = field.key;
                  data.selectBy = $$(ids.selectBy).getValue();
                  data.valueType = "exist";
                  if (FilterComponent) {
                     data.filterConditions = FilterComponent.getValue();
                  }
               };

               // now handle our special connectedObject case:
               if (field.isConnection) {
                  getValueFn();
               } else {
                  if ($$(ids.multiview).config.visibleBatch == "exist") {
                     getValueFn();
                  } else {
                     data.value = field.getValue($valueField, {});
                     data.op = "set"; // possible to create other types of operations.
                     data.type = field.key;
                     data.valueType = "custom";
                  }
               }

               return data;
            } else {
               return null;
            }
         },
      };

      var _ui = {
         id: ids.row,
         view: "layout",
         rows: [
            {
               cols: [
                  {
                     // Label
                     view: "label",
                     width: this.currentForm.AB.Config.labelWidthSmall,
                     label: L("Set"),
                  },
                  {
                     // Field list
                     view: "combo",
                     name: "field",
                     placeholder: L("Choose a field"),
                     id: ids.field,
                     height: 32,
                     options: _logic.getFieldList(true),
                     on: {
                        onChange: function (columnId) {
                           _logic.selectField(columnId);
                        },
                     },
                  },
                  {
                     // Label
                     view: "label",
                     width: this.currentForm.AB.Config.labelWidthSmall,
                     label: L("To"),
                  },

                  // Field value
                  // NOTE: this view gets replaced each time a field is selected.
                  // We replace it with a component associated with the Field
                  {},

                  {
                     // "Remove" button
                     view: "button",
                     css: "webix_danger",
                     id: ids.buttonDelete,
                     icon: "fa fa-trash",
                     type: "icon",
                     width: 30,
                     hidden: true,
                     click: function () {
                        _logic.callbacks.onDelete(ids.row);
                     },
                  },
               ],
            },
            {}, // we will add filters here if we need them
         ],
      };

      var init = (options) => {
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         if (options.data) {
            // options.data = { formID:xxx, value:yyy,  type:zzzz }
            _logic.setValue(options.data);

            // _logic.buttonsToggle();
         }
      };

      return {
         ui: _ui,
         init: init,
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   getUpdateObjectField(fieldID) {
      return this.updateObject ? this.updateObject.fieldByID(fieldID) : null;
   }

   /**
    * @method processUpdateObject
    * Perform the specified update actions on the provided objectToUpdate
    * @param {obj} options  Additional information required to make updates.
    * @param {obj} objectToUpdate  The object to make the updates on.
    * @return {boolean}   true if an update took place, false if no updates.
    */
   processUpdateObject(options, objectToUpdate) {
      this._formData = objectToUpdate;
      // return new Promise((resolve, reject) => {
      var isUpdated = false;

      this.valueRules = this.valueRules || {};
      this.valueRules.fieldOperations = this.valueRules.fieldOperations || [];

      // var allPromises = [];

      // for each of our operations
      this.valueRules.fieldOperations.forEach((op) => {
         // op = {
         // 	fieldID:'zzzzz',
         //	value: 'xxx',
         //	op: 'set',
         //  type:'',
         //  queryField: '', // id of ABField
         //  selectBy:'',   ['select-one', 'filter-select-one', 'filter-select-all']
         //  valueType: "", ['custom', 'exist']
         // 	filterConditions: { // array of filters to apply to the data table
         //		glue: 'and',
         // 		rules: []
         //  }
         // }

         var field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;

         var value = op.value;

         if (value == "ab-current-user") {
            value = this.currentForm.AB.Account.username();

         // in the case of a connected Field, we use op.value to get the
         // datacollection, and find it's currently selected value:
         } else if (field.isConnection || op.valueType == "exist") {
            // NOTE: 30 May 2018 :current decision from Ric is to limit this
            // to only handle 1:x connections where we update the current obj
            // with the PK of the value from the DC.
            //
            // In the future, if we want to handle the other options,
            // we need to modify this to handle the M:x connections where
            // we insert our PK into the value from the DC.

            // op.value is the ABDatacollection.id we need to find
            var dataCollection = this.currentForm.AB.datacollectionByID(
               op.value
            );

            // we don't want to mess with the dataView directly since it might
            // be used by other parts of the system and this refresh might reset
            // it's cursor.
            // var clonedDataCollection = dataView.filteredClone(op.filterConditions);

            // loop through rules to find "same-as-field" or "not-same-as-field"
            // adjust operator and switch key value to actual value when found
            var filterConditions = this.currentForm.AB.cloneDeep(
               op.filterConditions
            );
            if (filterConditions && filterConditions.rules) {
               filterConditions.rules
                  .filter((r) => {
                     return (
                        r.rule == "same_as_field" ||
                        r.rule == "not_same_as_field"
                     );
                  })
                  .forEach((item) => {
                     var valueField = this.currentForm.datacollection.datasource.fieldByID(
                        item.value
                     );
                     if (valueField.isConnection) {
                        item.value = valueField.format(this._formData);
                     } else {
                        item.value = this._formData[valueField.columnName];
                     }

                     if (item.rule == "not_same_as_field") {
                        item.rule = "not equals";
                     } else {
                        item.rule = "equals";
                     }
                  });
            }

            let clonedDataCollection = dataCollection.filteredClone(
               filterConditions
            );

            switch (op.selectBy) {
               // the 'select-one' is getting the currently set cursor on this data collection
               // and using that value.
               // TODO: rename to 'select-cursor'
               case "select-one":
               default:
                  value = clonedDataCollection.getCursor(); // dataView.getItem(dataView.getCursor());

                  if (value) {
                     // NOTE: webix documentation issue: .getCursor() is supposed to return
                     // the .id of the item.  However it seems to be returning the {obj}

                     if (op.valueType == "exist") {
                        var fieldWithValue = clonedDataCollection.datasource.fieldByID(
                           op.queryField
                        );

                        if (fieldWithValue)
                           value = value[fieldWithValue.columnName];
                     } else if (value.id) {
                        value = value.id;
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (!value) break;

                        if (field.isConnection) {
                           // if we are setting a connection we do not want to pass the full object because
                           // batch creates payload gets too large
                           objectToUpdate[field.columnName] = {};
                           objectToUpdate[field.columnName].id =
                              value[field.datasourceLink.PK()];
                           objectToUpdate[field.columnName][
                              field.datasourceLink.PK()
                           ] = value[field.datasourceLink.PK()];

                           // If the connect field use the custom FK, then it requires to pass value of the custom FK.
                           if (field.settings.isCustomFK) {
                              if (field.indexField) {
                                 objectToUpdate[field.columnName][
                                    field.indexField.columnName
                                 ] = value[field.indexField.columnName];
                              }
                              if (field.indexField2) {
                                 objectToUpdate[field.columnName][
                                    field.indexField2.columnName
                                 ] = value[field.indexField2.columnName];
                              }
                           }

                           field.datasourceLink
                              .fields(
                                 (f) =>
                                    f.key == "combined" || f.key == "AutoIndex"
                              )
                              .forEach((f) => {
                                 objectToUpdate[field.columnName][
                                    f.columnName
                                 ] = value[f.columnName];
                              });
                        } else {
                           objectToUpdate[field.columnName] = value;
                        }

                        break;
                  }
                  break;

               // attempt to filter this data collection by the given filterConditions
               case "filter-select-all":
                  var newValues = [];

                  var currRow = clonedDataCollection.getFirstRecord();
                  while (currRow) {
                     // do something there

                     switch (clonedDataCollection.sourceType) {
                        // case: datacollection is an object
                        // we want to set our field to this values
                        case "object":
                           newValues.push(currRow.id);
                           break;

                        // case: datacollection is a query
                        // our field is a pointer to an object. we want to pull out that object
                        // from the query data.
                        case "query":
                           var fieldWithValue = clonedDataCollection.datasource.fieldByID(
                              op.queryField
                           );

                           var newValue = currRow[fieldWithValue.columnName];

                           if (typeof newValue == "undefined") {
                              newValue = currRow[fieldWithValue.relationName()];

                              if (Array.isArray(newValue)) {
                                 newValue = newValue.map((v) => {
                                    return v.id ? v.id : v;
                                 });
                              } else if (newValue.id) {
                                 newValue = newValue.id;
                              }
                           }

                           newValues = this.currentForm.AB.uniq(
                              newValues.concat(newValue)
                           );

                           break;
                     }

                     currRow = clonedDataCollection.getNextRecord(currRow);
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (field.linkType() == "one") {
                           var updates = [];
                           newValues.forEach((v) => {
                              var objectToUpdateClone = this.currentForm.AB.cloneDeep(
                                 objectToUpdate
                              );
                              objectToUpdateClone[field.columnName] = v;
                              updates.push(objectToUpdateClone);
                           });
                           objectToUpdate.newRecords = updates;
                        } else {
                           objectToUpdate[field.columnName] = newValues;
                        }
                        break;
                  }
                  break;

               case "filter-select-one":
                  newValues = [];

                  value = clonedDataCollection.getFirstRecord();

                  if (value) {
                     // case: datacollection is a query
                     // our field is a pointer to an object. we want to pull out that object
                     // from the query data.
                     if (
                        clonedDataCollection.sourceType == "query" ||
                        (op.valueType == "exist" && op.queryField)
                     ) {
                        fieldWithValue = clonedDataCollection.datasource.fieldByID(
                           op.queryField
                        );

                        newValue = value[fieldWithValue.columnName];

                        if (typeof newValue == "undefined") {
                           newValue = value[fieldWithValue.relationName()];
                           if (Array.isArray(newValue)) {
                              newValue = newValue[0];
                           }
                           if (newValue.id) newValue = newValue.id;
                        }

                        value = newValue;
                     }
                     // case: datacollection is an object
                     // we want to set our field to this values
                     else if (clonedDataCollection.sourceType == "object") {
                        // NOTE: webix documentation issue: .getCursor() is supposed to return
                        // the .id of the item.  However it seems to be returning the {obj}

                        // we need to use the objects indexField(2) if there is one
                        // otherwise default to the id
                        var lookup;
                        if (field.indexField) {
                           lookup = field.indexField.columnName;
                        } else if (field.indexField2) {
                           lookup = field.indexField2.columnName;
                        }
                        if (lookup && value[lookup]) {
                           value = value[lookup];
                        } else if (value.id) {
                           value = value.id;
                        }
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        objectToUpdate[field.columnName] = value;
                        break;
                  }
                  break;
            }

            isUpdated = true;

            // allPromises.push(connectedPromise);
         } else {
            // var setPromise = new Promise((resolve, reject) => {
            switch (op.op) {
               case "set":
                  objectToUpdate[field.columnName] = value;
                  break;
            }

            isUpdated = true;

            //    resolve(isUpdated);
            // });

            // allPromises.push(setPromise);

            // console.log("finished");
         }
      });

      return isUpdated;
      // Promise.all(allPromises).then(() => {
      //    resolve(isUpdated);
      // });
      // });
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         let isUpdated = this.processUpdateObject({}, options.data);
         if (!isUpdated) {
            resolve();
         } else {
            // get the model from the provided Form Obj:
            var dv = options.form.datacollection;
            if (!dv) return resolve();

            var model = dv.model;
            model
               .update(options.data.id, options.data)
               .then(resolve)
               .catch((err) => {
                  this.currentForm.AB.notify.developer(err, {
                     context:
                        "ABViewRuleActionObjectUpdater:process  update error",
                     id: options.data.id,
                     data: options.data,
                  });
                  reject(err);
               });
         }
      });
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      super.objectLoad(object);
      this.updateObjectLoad(object);
   }

   // updateObjectLoad
   // save the given object as the object we will update.
   updateObjectLoad(object) {
      // stash rules for old object
      if (this.updateObject) {
         this.stashRules[this.updateObject.id] = this.valueRules;
      }

      this.updateObject = object;

      // with a new updateObject, then reset our UI
      this._uiUpdater = null;

      // reload any stashed rules, or set to {}
      this.valueRules = this.stashRules[this.updateObject.id] || {};
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};

      super.fromSettings(settings); // let the parent handle the QB

      // make sure UI is updated:
      // set our updateObject
      if (settings.updateObjectURL) {
         var updateObject = this.currentForm.application.urlResolve(
            settings.updateObjectURL
         );
         this.updateObject = updateObject;
      }

      // if we have a display component, then populate it:
      if (this._uiUpdater) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._uiUpdater.fromSettings(settings);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	valueRules:{}
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._uiUpdater.toSettings();
      settings.updateObjectURL = this.updateObject.urlPointer();

      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * Here we need to scan each of our field operations, and verify all
    * related data collections are initialized before we can continue.
    * @return {Promise}
    */
   isReady() {
      var allReady = [];
      let fieldOps = this.valueRules?.fieldOperations ?? [];
      fieldOps.forEach((op) => {
         let field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;
         if (!field.isConnection && op.valueType !== "exist") return;

         // this references a DC
         let DC = this.currentForm.AB.datacollectionByID(op.value);
         if (DC?.dataStatus === DC?.dataStatusFlag.initialized) return;

         // not ready yet, so wait until the 'initializedData' event
         allReady.push(
            new Promise((resolve /*, reject */) => {
               DC.on("initializedData", () => {
                  resolve();
               });
            })
         );
      });
      return Promise.all(allReady);
   }
};


/***/ }),

/***/ 6534:
/*!*****************************************!*\
  !*** ./AppBuilder/uiSettings/config.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _configDesktop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./configDesktop */ 64068);
/* harmony import */ var _configMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configMobile */ 74269);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ 14339);
/**
 * @class config
 *
 * Manage our configuration settings.
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   config: function () {
      // TODO: decide which config file to return here:
      if (window.innerWidth < 768) {
         return _configMobile__WEBPACK_IMPORTED_MODULE_0__["default"];
      }
      return _configDesktop__WEBPACK_IMPORTED_MODULE_1__["default"];
   },
   icons: _icons__WEBPACK_IMPORTED_MODULE_2__["default"].icons,
});


/***/ }),

/***/ 64068:
/*!************************************************!*\
  !*** ./AppBuilder/uiSettings/configDesktop.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class configDesktop
 *
 * Manage our configuration settings for Desktop styles.

 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Application List
   appListRowHeight: 67,

   // button types
   buttonWidthLarge: 200,
   buttonWidthMedium: 150,
   buttonWidthSmall: 100,
   buttonWidthExtraSmall: 50,

   // tab types
   tabWidthLarge: 200,
   tabWidthMedium: 120,
   tabWidthSmall: 100,
   tabWidthExtraSmall: 50,

   // column types
   columnWidthXLarge: 350,
   columnWidthLarge: 250,
   columnWidthMedium: 200,
   columnWidthSmall: 150,
   columnWidthExtraSmall: 100,

   // spacers
   xSmallSpacer: 5,
   smallSpacer: 10,
   mediumSpacer: 25,
   largeSpacer: 50,
   xLargeSpacer: 100,
   xxLargeSpacer: 200,
   xxxLargeSpacer: 400,
   appListSpacerRowHeight: 100,
   appListSpacerColMinWidth: 100,
   appListSpacerColMaxWidth: 200,
   objectWorkspaceColWidth: 20,

   // labels
   labelWidthSmall: 50,
   labelWidthMedium: 80,
   labelWidthLarge: 120,
   labelWidthXLarge: 150,
   labelWidthXXLarge: 200,
   labelWidthXXXLarge: 280,
   labelWidthCheckbox: 0,

   // show elements on desktop
   hideMobile: false,
});


/***/ }),

/***/ 74269:
/*!***********************************************!*\
  !*** ./AppBuilder/uiSettings/configMobile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class configMobile
 *
 * Manage our configuration settings for mobile styles.

 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Application List
   appListRowHeight: 67,

   // button types
   buttonWidthLarge: 200,
   buttonWidthMedium: 150,
   buttonWidthSmall: 100,
   buttonWidthExtraSmall: 50,

   // tab types
   tabWidthLarge: 200,
   tabWidthMedium: 120,
   tabWidthSmall: 100,
   tabWidthExtraSmall: 50,

   // column types
   columnWidthLarge: 250,
   columnWidthMedium: 200,
   columnWidthSmall: 150,
   columnWidthExtraSmall: 100,

   // spacers
   xSmallSpacer: 1,
   smallSpacer: 1,
   mediumSpacer: 10,
   largeSpacer: 20,
   xLargeSpacer: 50,
   xxLargeSpacer: 100,
   xxxLargeSpacer: 120,
   appListSpacerRowHeight: 10,
   appListSpacerColMinWidth: 1,
   appListSpacerColMaxWidth: 1,
   objectWorkspaceColWidth: 1,

   // labels
   labelWidthSmall: 50,
   labelWidthMedium: 80,
   labelWidthLarge: 120,
   labelWidthXLarge: 120,
   labelWidthXXLarge: 120,
   labelWidthCheckbox: 0,

   // hide elements for mobile
   hideMobile: true,
});


/***/ }),

/***/ 14339:
/*!****************************************!*\
  !*** ./AppBuilder/uiSettings/icons.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   icons: [
      "500px",
      "address-book",
      "address-book-o",
      "address-card",
      "address-card-o",
      "adjust",
      "adn",
      "align-center",
      "align-justify",
      "align-left",
      "align-right",
      "amazon",
      "ambulance",
      "american-sign-language-interpreting",
      "anchor",
      "android",
      "angellist",
      "angle-double-down",
      "angle-double-left",
      "angle-double-right",
      "angle-double-up",
      "angle-down",
      "angle-left",
      "angle-right",
      "angle-up",
      "apple",
      "archive",
      "area-chart",
      "arrow-circle-down",
      "arrow-circle-left",
      "arrow-circle-o-down",
      "arrow-circle-o-left",
      "arrow-circle-o-right",
      "arrow-circle-o-up",
      "arrow-circle-right",
      "arrow-circle-up",
      "arrow-down",
      "arrow-left",
      "arrow-right",
      "arrow-up",
      "arrows",
      "arrows-alt",
      "arrows-h",
      "arrows-v",
      "asl-interpreting",
      "assistive-listening-systems",
      "asterisk",
      "at",
      "audio-description",
      "automobile",
      "backward",
      "balance-scale",
      "ban",
      "bandcamp",
      "bank",
      "bar-chart",
      "bar-chart-o",
      "barcode",
      "bars",
      "bath",
      "bathtub",
      "battery",
      "battery-0",
      "battery-1",
      "battery-2",
      "battery-3",
      "battery-4",
      "battery-empty",
      "battery-full",
      "battery-half",
      "battery-quarter",
      "battery-three-quarters",
      "bed",
      "beer",
      "behance",
      "behance-square",
      "bell",
      "bell-o",
      "bell-slash",
      "bell-slash-o",
      "bicycle",
      "binoculars",
      "birthday-cake",
      "bitbucket",
      "bitbucket-square",
      "bitcoin",
      "black-tie",
      "blind",
      "bluetooth",
      "bluetooth-b",
      "bold",
      "bolt",
      "bomb",
      "book",
      "bookmark",
      "bookmark-o",
      "braille",
      "briefcase",
      "btc",
      "bug",
      "building",
      "building-o",
      "bullhorn",
      "bullseye",
      "bus",
      "buysellads",
      "cab",
      "calculator",
      "calendar",
      "calendar-check-o",
      "calendar-minus-o",
      "calendar-o",
      "calendar-plus-o",
      "calendar-times-o",
      "camera",
      "camera-retro",
      "car",
      "caret-down",
      "caret-left",
      "caret-right",
      "caret-square-o-down",
      "caret-square-o-left",
      "caret-square-o-right",
      "caret-square-o-up",
      "caret-up",
      "cart-arrow-down",
      "cart-plus",
      "cc",
      "cc-amex",
      "cc-diners-club",
      "cc-discover",
      "cc-jcb",
      "cc-mastercard",
      "cc-paypal",
      "cc-stripe",
      "cc-visa",
      "certificate",
      "chain",
      "chain-broken",
      "check",
      "check-circle",
      "check-circle-o",
      "check-square",
      "check-square-o",
      "chevron-circle-down",
      "chevron-circle-left",
      "chevron-circle-right",
      "chevron-circle-up",
      "chevron-down",
      "chevron-left",
      "chevron-right",
      "chevron-up",
      "child",
      "chrome",
      "circle",
      "circle-o",
      "circle-o-notch",
      "circle-thin",
      "clipboard",
      "clock-o",
      "clone",
      "close",
      "cloud",
      "cloud-download",
      "cloud-upload",
      "cny",
      "code",
      "code-fork",
      "codepen",
      "codiepie",
      "coffee",
      "cog",
      "cogs",
      "columns",
      "comment",
      "comment-o",
      "commenting",
      "commenting-o",
      "comments",
      "comments-o",
      "compass",
      "compress",
      "connectdevelop",
      "contao",
      "copy",
      "copyright",
      "creative-commons",
      "credit-card",
      "credit-card-alt",
      "crop",
      "crosshairs",
      "css3",
      "cube",
      "cubes",
      "cut",
      "cutlery",
      "dashboard",
      "dashcube",
      "database",
      "deaf",
      "deafness",
      "dedent",
      "delicious",
      "desktop",
      "deviantart",
      "diamond",
      "digg",
      "dollar",
      "dot-circle-o",
      "download",
      "dribbble",
      "drivers-license",
      "drivers-license-o",
      "dropbox",
      "drupal",
      "edge",
      "edit",
      "eercast",
      "eject",
      "ellipsis-h",
      "ellipsis-v",
      "empire",
      "envelope",
      "envelope-o",
      "envelope-open",
      "envelope-open-o",
      "envelope-square",
      "envira",
      "eraser",
      "etsy",
      "eur",
      "euro",
      "exchange",
      "exclamation",
      "exclamation-circle",
      "exclamation-triangle",
      "expand",
      "expeditedssl",
      "external-link",
      "external-link-square",
      "eye",
      "eye-slash",
      "eyedropper",
      "fa",
      "facebook",
      "facebook-f",
      "facebook-official",
      "facebook-square",
      "fast-backward",
      "fast-forward",
      "fax",
      "feed",
      "female",
      "fighter-jet",
      "file",
      "file-archive-o",
      "file-audio-o",
      "file-code-o",
      "file-excel-o",
      "file-image-o",
      "file-movie-o",
      "file-o",
      "file-pdf-o",
      "file-photo-o",
      "file-picture-o",
      "file-powerpoint-o",
      "file-sound-o",
      "file-text",
      "file-text-o",
      "file-video-o",
      "file-word-o",
      "file-zip-o",
      "files-o",
      "film",
      "filter",
      "fire",
      "fire-extinguisher",
      "firefox",
      "first-order",
      "flag",
      "flag-checkered",
      "flag-o",
      "flash",
      "flask",
      "flickr",
      "floppy-o",
      "folder",
      "folder-o",
      "folder-open",
      "folder-open-o",
      "font",
      "font-awesome",
      "fonticons",
      "fort-awesome",
      "forumbee",
      "forward",
      "foursquare",
      "free-code-camp",
      "frown-o",
      "futbol-o",
      "gamepad",
      "gavel",
      "gbp",
      "ge",
      "gear",
      "gears",
      "genderless",
      "get-pocket",
      "gg",
      "gg-circle",
      "gift",
      "git",
      "git-square",
      "github",
      "github-alt",
      "github-square",
      "gitlab",
      "gittip",
      "glass",
      "glide",
      "glide-g",
      "globe",
      "google",
      "google-plus",
      "google-plus-circle",
      "google-plus-official",
      "google-plus-square",
      "google-wallet",
      "graduation-cap",
      "gratipay",
      "grav",
      "group",
      "h-square",
      "hacker-news",
      "hand-grab-o",
      "hand-lizard-o",
      "hand-o-down",
      "hand-o-left",
      "hand-o-right",
      "hand-o-up",
      "hand-paper-o",
      "hand-peace-o",
      "hand-pointer-o",
      "hand-rock-o",
      "hand-scissors-o",
      "hand-spock-o",
      "hand-stop-o",
      "handshake-o",
      "hard-of-hearing",
      "hashtag",
      "hdd-o",
      "header",
      "headphones",
      "heart",
      "heart-o",
      "heartbeat",
      "history",
      "home",
      "hospital-o",
      "hotel",
      "hourglass",
      "hourglass-1",
      "hourglass-2",
      "hourglass-3",
      "hourglass-end",
      "hourglass-half",
      "hourglass-o",
      "hourglass-start",
      "houzz",
      "html5",
      "i-cursor",
      "id-badge",
      "id-card",
      "id-card-o",
      "ils",
      "image",
      "imdb",
      "inbox",
      "indent",
      "industry",
      "info",
      "info-circle",
      "inr",
      "instagram",
      "institution",
      "internet-explorer",
      "intersex",
      "ioxhost",
      "italic",
      "joomla",
      "jpy",
      "jsfiddle",
      "key",
      "keyboard-o",
      "krw",
      "language",
      "laptop",
      "lastfm",
      "lastfm-square",
      "leaf",
      "leanpub",
      "legal",
      "lemon-o",
      "level-down",
      "level-up",
      "life-bouy",
      "life-buoy",
      "life-ring",
      "life-saver",
      "lightbulb-o",
      "line-chart",
      "link",
      "linkedin",
      "linkedin-square",
      "linode",
      "linux",
      "list",
      "list-alt",
      "list-ol",
      "list-ul",
      "location-arrow",
      "lock",
      "long-arrow-down",
      "long-arrow-left",
      "long-arrow-right",
      "long-arrow-up",
      "low-vision",
      "magic",
      "magnet",
      "mail-forward",
      "mail-reply",
      "mail-reply-all",
      "male",
      "map",
      "map-marker",
      "map-o",
      "map-pin",
      "map-signs",
      "mars",
      "mars-double",
      "mars-stroke",
      "mars-stroke-h",
      "mars-stroke-v",
      "maxcdn",
      "meanpath",
      "medium",
      "medkit",
      "meetup",
      "meh-o",
      "mercury",
      "microchip",
      "microphone",
      "microphone-slash",
      "minus",
      "minus-circle",
      "minus-square",
      "minus-square-o",
      "mixcloud",
      "mobile",
      "mobile-phone",
      "modx",
      "money",
      "moon-o",
      "mortar-board",
      "motorcycle",
      "mouse-pointer",
      "music",
      "navicon",
      "neuter",
      "newspaper-o",
      "object-group",
      "object-ungroup",
      "odnoklassniki",
      "odnoklassniki-square",
      "opencart",
      "openid",
      "opera",
      "optin-monster",
      "outdent",
      "pagelines",
      "paint-brush",
      "paper-plane",
      "paper-plane-o",
      "paperclip",
      "paragraph",
      "paste",
      "pause",
      "pause-circle",
      "pause-circle-o",
      "paw",
      "paypal",
      "pencil",
      "pencil-square",
      "pencil-square-o",
      "percent",
      "phone",
      "phone-square",
      "photo",
      "picture-o",
      "pie-chart",
      "pied-piper",
      "pied-piper-alt",
      "pied-piper-pp",
      "pinterest",
      "pinterest-p",
      "pinterest-square",
      "plane",
      "play",
      "play-circle",
      "play-circle-o",
      "plug",
      "plus",
      "plus-circle",
      "plus-square",
      "plus-square-o",
      "podcast",
      "power-off",
      "print",
      "product-hunt",
      "puzzle-piece",
      "qq",
      "qrcode",
      "question",
      "question-circle",
      "question-circle-o",
      "quora",
      "quote-left",
      "quote-right",
      "ra",
      "random",
      "ravelry",
      "rebel",
      "recycle",
      "reddit",
      "reddit-alien",
      "reddit-square",
      "refresh",
      "registered",
      "remove",
      "renren",
      "reorder",
      "repeat",
      "reply",
      "reply-all",
      "resistance",
      "retweet",
      "rmb",
      "road",
      "rocket",
      "rotate-left",
      "rotate-right",
      "rouble",
      "rss",
      "rss-square",
      "rub",
      "ruble",
      "rupee",
      "s15",
      "safari",
      "save",
      "scissors",
      "scribd",
      "search",
      "search-minus",
      "search-plus",
      "sellsy",
      "send",
      "send-o",
      "server",
      "share",
      "share-alt",
      "share-alt-square",
      "share-square",
      "share-square-o",
      "shekel",
      "sheqel",
      "shield",
      "ship",
      "shirtsinbulk",
      "shopping-bag",
      "shopping-basket",
      "shopping-cart",
      "shower",
      "sign-in",
      "sign-language",
      "sign-out",
      "signal",
      "signing",
      "simplybuilt",
      "sitemap",
      "skyatlas",
      "skype",
      "slack",
      "sliders",
      "slideshare",
      "smile-o",
      "snapchat",
      "snapchat-ghost",
      "snapchat-square",
      "snowflake-o",
      "soccer-ball-o",
      "sort",
      "sort-alpha-asc",
      "sort-alpha-desc",
      "sort-amount-asc",
      "sort-amount-desc",
      "sort-asc",
      "sort-desc",
      "sort-down",
      "sort-numeric-asc",
      "sort-numeric-desc",
      "sort-up",
      "soundcloud",
      "space-shuttle",
      "spinner",
      "spoon",
      "spotify",
      "square",
      "square-o",
      "stack-exchange",
      "stack-overflow",
      "star",
      "star-half",
      "star-half-empty",
      "star-half-full",
      "star-half-o",
      "star-o",
      "steam",
      "steam-square",
      "step-backward",
      "step-forward",
      "stethoscope",
      "sticky-note",
      "sticky-note-o",
      "stop",
      "stop-circle",
      "stop-circle-o",
      "street-view",
      "strikethrough",
      "stumbleupon",
      "stumbleupon-circle",
      "subscript",
      "subway",
      "suitcase",
      "sun-o",
      "superpowers",
      "superscript",
      "support",
      "table",
      "tablet",
      "tachometer",
      "tag",
      "tags",
      "tasks",
      "taxi",
      "telegram",
      "television",
      "tencent-weibo",
      "terminal",
      "text-height",
      "text-width",
      "th",
      "th-large",
      "th-list",
      "themeisle",
      "thermometer",
      "thermometer-0",
      "thermometer-1",
      "thermometer-2",
      "thermometer-3",
      "thermometer-4",
      "thermometer-empty",
      "thermometer-full",
      "thermometer-half",
      "thermometer-quarter",
      "thermometer-three-quarters",
      "thumb-tack",
      "thumbs-down",
      "thumbs-o-down",
      "thumbs-o-up",
      "thumbs-up",
      "ticket",
      "times",
      "times-circle",
      "times-circle-o",
      "times-rectangle",
      "times-rectangle-o",
      "tint",
      "toggle-down",
      "toggle-left",
      "toggle-off",
      "toggle-on",
      "toggle-right",
      "toggle-up",
      "trademark",
      "train",
      "transgender",
      "transgender-alt",
      "trash",
      "trash-o",
      "tree",
      "trello",
      "tripadvisor",
      "trophy",
      "truck",
      "try",
      "tty",
      "tumblr",
      "tumblr-square",
      "turkish-lira",
      "tv",
      "twitch",
      "twitter",
      "twitter-square",
      "umbrella",
      "underline",
      "undo",
      "universal-access",
      "university",
      "unlink",
      "unlock",
      "unlock-alt",
      "unsorted",
      "upload",
      "usb",
      "usd",
      "user",
      "user-circle",
      "user-circle-o",
      "user-md",
      "user-o",
      "user-plus",
      "user-secret",
      "user-times",
      "users",
      "vcard",
      "vcard-o",
      "venus",
      "venus-double",
      "venus-mars",
      "viacoin",
      "viadeo",
      "viadeo-square",
      "video-camera",
      "vimeo",
      "vimeo-square",
      "vine",
      "vk",
      "volume-control-phone",
      "volume-down",
      "volume-off",
      "volume-up",
      "warning",
      "wechat",
      "weibo",
      "weixin",
      "whatsapp",
      "wheelchair",
      "wheelchair-alt",
      "wifi",
      "wikipedia-w",
      "window-close",
      "window-close-o",
      "window-maximize",
      "window-minimize",
      "window-restore",
      "windows",
      "won",
      "wordpress",
      "wpbeginner",
      "wpexplorer",
      "wpforms",
      "wrench",
      "xing",
      "xing-square",
      "y-combinator",
      "y-combinator-square",
      "yahoo",
      "yc",
      "yc-square",
      "yelp",
      "yen",
      "yoast",
      "youtube",
      "youtube-play",
      "youtube-square",
   ],
});


/***/ }),

/***/ 82824:
/*!*****************************************************!*\
  !*** ./js/docxtemplater-image-module.v3.0.2.min.js ***!
  \*****************************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";var DocUtils=require("docxtemplater").DocUtils;DocUtils.convertPixelsToEmus=function(pixel){return Math.round(pixel*9525)};module.exports=DocUtils},{docxtemplater:5}],2:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./docUtils");var extensionRegex=/[^.]+\.([^.]+)/;var rels={getPrefix:function getPrefix(fileType){return fileType==="docx"?"word":"ppt"},getFileTypeName:function getFileTypeName(fileType){return fileType==="docx"?"document":"presentation"},getRelsFileName:function getRelsFileName(fileName){return fileName.replace(/^.*?([a-zA-Z0-9]+)\.xml$/,"$1")+".xml.rels"},getRelsFilePath:function getRelsFilePath(fileName,fileType){var relsFileName=rels.getRelsFileName(fileName);var prefix=fileType==="pptx"?"ppt/slides":"word";return prefix+"/_rels/"+relsFileName}};module.exports=function(){function ImgManager(zip,fileName,xmlDocuments,fileType){_classCallCheck(this,ImgManager);this.fileName=fileName;this.prefix=rels.getPrefix(fileType);this.zip=zip;this.xmlDocuments=xmlDocuments;this.fileTypeName=rels.getFileTypeName(fileType);this.mediaPrefix=fileType==="pptx"?"../media":"media";var relsFilePath=rels.getRelsFilePath(fileName,fileType);this.relsDoc=xmlDocuments[relsFilePath]||this.createEmptyRelsDoc(xmlDocuments,relsFilePath)}_createClass(ImgManager,[{key:"createEmptyRelsDoc",value:function createEmptyRelsDoc(xmlDocuments,relsFileName){var mainRels=this.prefix+"/_rels/"+this.fileTypeName+".xml.rels";var doc=xmlDocuments[mainRels];if(!doc){var err=new Error("Could not copy from empty relsdoc");err.properties={mainRels:mainRels,relsFileName:relsFileName,files:Object.keys(this.zip.files)};throw err}var relsDoc=DocUtils.str2xml(DocUtils.xml2str(doc));var relationships=relsDoc.getElementsByTagName("Relationships")[0];var relationshipChilds=relationships.getElementsByTagName("Relationship");for(var i=0,l=relationshipChilds.length;i<l;i++){relationships.removeChild(relationshipChilds[i])}xmlDocuments[relsFileName]=relsDoc;return relsDoc}},{key:"loadImageRels",value:function loadImageRels(){var iterable=this.relsDoc.getElementsByTagName("Relationship");return Array.prototype.reduce.call(iterable,function(max,relationship){var id=relationship.getAttribute("Id");if(/^rId[0-9]+$/.test(id)){return Math.max(max,parseInt(id.substr(3),10))}return max},0)}},{key:"addExtensionRels",value:function addExtensionRels(contentType,extension){var contentTypeDoc=this.xmlDocuments["[Content_Types].xml"];var defaultTags=contentTypeDoc.getElementsByTagName("Default");var extensionRegistered=Array.prototype.some.call(defaultTags,function(tag){return tag.getAttribute("Extension")===extension});if(extensionRegistered){return}var types=contentTypeDoc.getElementsByTagName("Types")[0];var newTag=contentTypeDoc.createElement("Default");newTag.namespaceURI=null;newTag.setAttribute("ContentType",contentType);newTag.setAttribute("Extension",extension);types.appendChild(newTag)}},{key:"addImageRels",value:function addImageRels(imageName,imageData,i){if(i==null){i=0}var realImageName=i===0?imageName:imageName+("("+i+")");var imagePath=this.prefix+"/media/"+realImageName;if(this.zip.files[imagePath]!=null){return this.addImageRels(imageName,imageData,i+1)}var image={name:imagePath,data:imageData,options:{binary:true}};this.zip.file(image.name,image.data,image.options);var extension=realImageName.replace(extensionRegex,"$1");this.addExtensionRels("image/"+extension,extension);var relationships=this.relsDoc.getElementsByTagName("Relationships")[0];var newTag=this.relsDoc.createElement("Relationship");newTag.namespaceURI=null;var maxRid=this.loadImageRels()+1;newTag.setAttribute("Id","rId"+maxRid);newTag.setAttribute("Type","http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");newTag.setAttribute("Target",this.mediaPrefix+"/"+realImageName);relationships.appendChild(newTag);return maxRid}}]);return ImgManager}()},{"./docUtils":1}],3:[function(require,module,exports){"use strict";module.exports={getImageXml:function getImageXml(rId,size){return('<w:drawing>\n\t\t<wp:inline distT="0" distB="0" distL="0" distR="0">\n\t\t\t<wp:extent cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t<wp:effectExtent l="0" t="0" r="0" b="0"/>\n\t\t\t<wp:docPr id="2" name="Image 2" descr="image"/>\n\t\t\t<wp:cNvGraphicFramePr>\n\t\t\t\t<a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/>\n\t\t\t</wp:cNvGraphicFramePr>\n\t\t\t<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n\t\t\t\t<a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t<pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:cNvPr id="0" name="Picture 1" descr="image"/>\n\t\t\t\t\t\t\t<pic:cNvPicPr>\n\t\t\t\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t\t\t\t</pic:cNvPicPr>\n\t\t\t\t\t\t</pic:nvPicPr>\n\t\t\t\t\t\t<pic:blipFill>\n\t\t\t\t\t\t\t<a:blip r:embed="rId'+rId+'">\n\t\t\t\t\t\t\t\t<a:extLst>\n\t\t\t\t\t\t\t\t\t<a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n\t\t\t\t\t\t\t\t\t\t<a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n\t\t\t\t\t\t\t\t\t</a:ext>\n\t\t\t\t\t\t\t\t</a:extLst>\n\t\t\t\t\t\t\t</a:blip>\n\t\t\t\t\t\t\t<a:srcRect/>\n\t\t\t\t\t\t\t<a:stretch>\n\t\t\t\t\t\t\t\t<a:fillRect/>\n\t\t\t\t\t\t\t</a:stretch>\n\t\t\t\t\t\t</pic:blipFill>\n\t\t\t\t\t\t<pic:spPr bwMode="auto">\n\t\t\t\t\t\t\t<a:xfrm>\n\t\t\t\t\t\t\t\t<a:off x="0" y="0"/>\n\t\t\t\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t\t\t</a:xfrm>\n\t\t\t\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t\t\t\t<a:avLst/>\n\t\t\t\t\t\t\t</a:prstGeom>\n\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t<a:ln>\n\t\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t</a:ln>\n\t\t\t\t\t\t</pic:spPr>\n\t\t\t\t\t</pic:pic>\n\t\t\t\t</a:graphicData>\n\t\t\t</a:graphic>\n\t\t</wp:inline>\n\t</w:drawing>\n\t\t').replace(/\t|\n/g,"")},getImageXmlCentered:function getImageXmlCentered(rId,size){return('<w:p>\n\t\t\t<w:pPr>\n\t\t\t\t<w:jc w:val="center"/>\n\t\t\t</w:pPr>\n\t\t\t<w:r>\n\t\t\t\t<w:rPr/>\n\t\t\t\t<w:drawing>\n\t\t\t\t\t<wp:inline distT="0" distB="0" distL="0" distR="0">\n\t\t\t\t\t<wp:extent cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t<wp:docPr id="0" name="Picture" descr=""/>\n\t\t\t\t\t<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n\t\t\t\t\t\t<a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t\t<pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:cNvPr id="0" name="Picture" descr=""/>\n\t\t\t\t\t\t\t<pic:cNvPicPr>\n\t\t\t\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t\t\t\t</pic:cNvPicPr>\n\t\t\t\t\t\t\t</pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:blipFill>\n\t\t\t\t\t\t\t<a:blip r:embed="rId'+rId+'"/>\n\t\t\t\t\t\t\t<a:stretch>\n\t\t\t\t\t\t\t\t<a:fillRect/>\n\t\t\t\t\t\t\t</a:stretch>\n\t\t\t\t\t\t\t</pic:blipFill>\n\t\t\t\t\t\t\t<pic:spPr bwMode="auto">\n\t\t\t\t\t\t\t<a:xfrm>\n\t\t\t\t\t\t\t\t<a:off x="0" y="0"/>\n\t\t\t\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t\t\t</a:xfrm>\n\t\t\t\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t\t\t\t<a:avLst/>\n\t\t\t\t\t\t\t</a:prstGeom>\n\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t<a:ln w="9525">\n\t\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t\t<a:miter lim="800000"/>\n\t\t\t\t\t\t\t\t<a:headEnd/>\n\t\t\t\t\t\t\t\t<a:tailEnd/>\n\t\t\t\t\t\t\t</a:ln>\n\t\t\t\t\t\t\t</pic:spPr>\n\t\t\t\t\t\t</pic:pic>\n\t\t\t\t\t\t</a:graphicData>\n\t\t\t\t\t</a:graphic>\n\t\t\t\t\t</wp:inline>\n\t\t\t\t</w:drawing>\n\t\t\t</w:r>\n\t\t</w:p>\n\t\t').replace(/\t|\n/g,"")},getPptxImageXml:function getPptxImageXml(rId,size,offset){return('<p:pic>\n\t\t\t<p:nvPicPr>\n\t\t\t\t<p:cNvPr id="6" name="Picture 2"/>\n\t\t\t\t<p:cNvPicPr>\n\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t</p:cNvPicPr>\n\t\t\t\t<p:nvPr/>\n\t\t\t</p:nvPicPr>\n\t\t\t<p:blipFill>\n\t\t\t\t<a:blip r:embed="rId'+rId+'" cstate="print">\n\t\t\t\t\t<a:extLst>\n\t\t\t\t\t\t<a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n\t\t\t\t\t\t\t<a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n\t\t\t\t\t\t</a:ext>\n\t\t\t\t\t</a:extLst>\n\t\t\t\t</a:blip>\n\t\t\t\t<a:srcRect/>\n\t\t\t\t<a:stretch>\n\t\t\t\t\t<a:fillRect/>\n\t\t\t\t</a:stretch>\n\t\t\t</p:blipFill>\n\t\t\t<p:spPr bwMode="auto">\n\t\t\t\t<a:xfrm>\n\t\t\t\t\t<a:off x="'+offset.x+'" y="'+offset.y+'"/>\n\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t</a:xfrm>\n\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t<a:avLst/>\n\t\t\t\t</a:prstGeom>\n\t\t\t\t<a:noFill/>\n\t\t\t\t<a:ln>\n\t\t\t\t\t<a:noFill/>\n\t\t\t\t</a:ln>\n\t\t\t\t<a:effectLst/>\n\t\t\t\t<a:extLst>\n\t\t\t\t\t<a:ext uri="{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}">\n\t\t\t\t\t\t<a14:hiddenFill xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main">\n\t\t\t\t\t\t\t<a:solidFill>\n\t\t\t\t\t\t\t\t<a:schemeClr val="accent1"/>\n\t\t\t\t\t\t\t</a:solidFill>\n\t\t\t\t\t\t</a14:hiddenFill>\n\t\t\t\t\t</a:ext>\n\t\t\t\t\t<a:ext uri="{91240B29-F687-4F45-9708-019B960494DF}">\n\t\t\t\t\t\t<a14:hiddenLine xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" w="9525">\n\t\t\t\t\t\t\t<a:solidFill>\n\t\t\t\t\t\t\t\t<a:schemeClr val="tx1"/>\n\t\t\t\t\t\t\t</a:solidFill>\n\t\t\t\t\t\t\t<a:miter lim="800000"/>\n\t\t\t\t\t\t\t<a:headEnd/>\n\t\t\t\t\t\t\t<a:tailEnd/>\n\t\t\t\t\t\t</a14:hiddenLine>\n\t\t\t\t\t</a:ext>\n\t\t\t\t\t<a:ext uri="{AF507438-7753-43E0-B8FC-AC1667EBCBE1}">\n\t\t\t\t\t\t<a14:hiddenEffects xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main">\n\t\t\t\t\t\t\t<a:effectLst>\n\t\t\t\t\t\t\t\t<a:outerShdw dist="35921" dir="2700000" algn="ctr" rotWithShape="0">\n\t\t\t\t\t\t\t\t\t<a:schemeClr val="bg2"/>\n\t\t\t\t\t\t\t\t</a:outerShdw>\n\t\t\t\t\t\t\t</a:effectLst>\n\t\t\t\t\t\t</a14:hiddenEffects>\n\t\t\t\t\t</a:ext>\n\t\t\t\t</a:extLst>\n\t\t\t</p:spPr>\n\t\t</p:pic>\n\t\t').replace(/\t|\n/g,"")}}},{}],4:[function(require,module,exports){"use strict";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}var memoize=require("./memoize");var DOMParser=require("xmldom").DOMParser;var XMLSerializer=require("xmldom").XMLSerializer;var Errors=require("./errors");var DocUtils={};function parser(tag){return _defineProperty({},"get",function get(scope){if(tag==="."){return scope}return scope[tag]})}DocUtils.defaults={nullGetter:function nullGetter(part){if(!part.module){return"undefined"}if(part.module==="rawxml"){return""}return""},parser:memoize(parser),fileType:"docx",delimiters:{start:"{",end:"}"}};DocUtils.mergeObjects=function(){var resObj={};var obj=void 0,keys=void 0;for(var i=0;i<arguments.length;i+=1){obj=arguments[i];keys=Object.keys(obj);for(var j=0;j<keys.length;j+=1){resObj[keys[j]]=obj[keys[j]]}}return resObj};DocUtils.xml2str=function(xmlNode){var a=new XMLSerializer;return a.serializeToString(xmlNode)};DocUtils.decodeUtf8=function(s){try{if(s===undefined){return undefined}return decodeURIComponent(escape(DocUtils.convertSpaces(s)))}catch(e){var err=new Error("End");err.properties.data=s;err.properties.explanation="Could not decode string to UTF8";throw err}};DocUtils.encodeUtf8=function(s){return unescape(encodeURIComponent(s))};DocUtils.str2xml=function(str,errorHandler){var parser=new DOMParser({errorHandler:errorHandler});return parser.parseFromString(str,"text/xml")};DocUtils.charMap={"&":"&amp;","'":"&apos;","<":"&lt;",">":"&gt;"};var regexStripRegexp=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;DocUtils.escapeRegExp=function(str){return str.replace(regexStripRegexp,"\\$&")};DocUtils.charMapRegexes=Object.keys(DocUtils.charMap).map(function(endChar){var startChar=DocUtils.charMap[endChar];return{rstart:new RegExp(DocUtils.escapeRegExp(startChar),"g"),rend:new RegExp(DocUtils.escapeRegExp(endChar),"g"),start:startChar,end:endChar}});DocUtils.wordToUtf8=function(string){var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rstart,r.end)}return string};DocUtils.utf8ToWord=function(string){if(typeof string!=="string"){string=string.toString()}var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rend,r.start)}return string};DocUtils.cloneDeep=function(obj){return JSON.parse(JSON.stringify(obj))};DocUtils.concatArrays=function(arrays){return arrays.reduce(function(result,array){Array.prototype.push.apply(result,array);return result},[])};var spaceRegexp=new RegExp(String.fromCharCode(160),"g");DocUtils.convertSpaces=function(s){return s.replace(spaceRegexp," ")};DocUtils.pregMatchAll=function(regex,content){var matchArray=[];var match=void 0;while((match=regex.exec(content))!=null){matchArray.push({array:match,offset:match.index})}return matchArray};DocUtils.sizeOfObject=function(obj){return Object.keys(obj).length};function throwXmlTagNotFound(options){var err=new Errors.XTTemplateError("No tag '"+options.element+"' was found at the "+options.position);err.properties={id:"no_xml_tag_found_at_"+options.position,explanation:"No tag '"+options.element+"' was found at the "+options.position,parsed:options.parsed,index:options.index,element:options.element};throw err}DocUtils.getRight=function(parsed,element,index){for(var i=index,l=parsed.length;i<l;i++){var part=parsed[i];if(part.value==="</"+element+">"){return i}}throwXmlTagNotFound({position:"right",element:element,parsed:parsed,index:index})};DocUtils.getLeft=function(parsed,element,index){var parts=parsed.slice(0,index);for(var i=parts.length-1;i>=0;i--){var part=parts[i];if(part.value.indexOf("<"+element)===0&&[">"," "].indexOf(part.value[element.length+1])!==-1){return i}}throwXmlTagNotFound({position:"left",element:element,parsed:parsed,index:index})};module.exports=DocUtils;DocUtils.traits=require("./traits");DocUtils.moduleWrapper=require("./module-wrapper")},{"./errors":6,"./memoize":9,"./module-wrapper":11,"./traits":20,xmldom:23}],5:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var wrapper=DocUtils.moduleWrapper;var Docxtemplater=function(){function Docxtemplater(){_classCallCheck(this,Docxtemplater);if(arguments.length>0){throw new Error("The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.")}this.compiled={};this.modules=[];this.setOptions({})}_createClass(Docxtemplater,[{key:"attachModule",value:function attachModule(module){this.modules.push(wrapper(module));return this}},{key:"setOptions",value:function setOptions(options){var _this=this;this.options=options;Object.keys(DocUtils.defaults).forEach(function(key){var defaultValue=DocUtils.defaults[key];_this[key]=_this.options[key]!=null?_this.options[key]:defaultValue});if(this.fileType==="docx"||this.fileType==="pptx"){this.fileTypeConfig=Docxtemplater.FileTypeConfig[this.fileType]}this.fileTypeConfig=this.options.fileTypeConfig||this.fileTypeConfig;this.options.xmlFileNames=[];return this}},{key:"loadZip",value:function loadZip(zip){if(zip.loadAsync){throw new Error("Docxtemplater doesn't handle JSZip version >=3, see changelog")}this.zip=zip;return this}},{key:"compileFile",value:function compileFile(fileName){var currentFile=this.createTemplateClass(fileName);currentFile.parse();this.compiled[fileName]=currentFile}},{key:"compile",value:function compile(){this.templatedFiles=this.fileTypeConfig.getTemplatedFiles(this.zip)}},{key:"render",value:function render(){var _this2=this;this.modules=this.fileTypeConfig.baseModules.map(function(moduleFunction){return moduleFunction()}).concat(this.modules);this.options=this.modules.reduce(function(options,module){return module.optionsTransformer(options,_this2)},this.options);this.xmlDocuments=this.options.xmlFileNames.reduce(function(xmlDocuments,fileName){var content=_this2.zip.files[fileName].asText();xmlDocuments[fileName]=DocUtils.str2xml(content);return xmlDocuments},{});this.modules.forEach(function(module){module.set({zip:_this2.zip,xmlDocuments:_this2.xmlDocuments,data:_this2.data})});this.compile();this.modules.forEach(function(module){module.set({compiled:_this2.compiled})});this.templatedFiles.forEach(function(fileName){if(_this2.zip.files[fileName]!=null){_this2.compileFile(fileName)}});this.mapper=this.modules.reduce(function(value,module){return module.getRenderedMap(value)},{});Object.keys(this.mapper).forEach(function(to){var mapped=_this2.mapper[to];var from=mapped.from;var currentFile=_this2.compiled[from];currentFile.setTags(mapped.data);currentFile.render();_this2.zip.file(to,currentFile.content)});Object.keys(this.xmlDocuments).forEach(function(fileName){_this2.zip.remove(fileName);var content=DocUtils.encodeUtf8(DocUtils.xml2str(_this2.xmlDocuments[fileName]));return _this2.zip.file(fileName,content,{})});return this}},{key:"setData",value:function setData(data){this.data=data;return this}},{key:"getZip",value:function getZip(){return this.zip}},{key:"createTemplateClass",value:function createTemplateClass(path){var usedData=this.zip.files[path].asText();return this.createTemplateClassFromContent(usedData,path)}},{key:"createTemplateClassFromContent",value:function createTemplateClassFromContent(content,filePath){var _this3=this;var xmltOptions={filePath:filePath};Object.keys(DocUtils.defaults).forEach(function(key){xmltOptions[key]=_this3[key]});xmltOptions.fileTypeConfig=this.fileTypeConfig;xmltOptions.modules=this.modules;return new Docxtemplater.XmlTemplater(content,xmltOptions)}},{key:"getFullText",value:function getFullText(path){return this.createTemplateClass(path||this.fileTypeConfig.textPath).getFullText()}},{key:"getTemplatedFiles",value:function getTemplatedFiles(){this.compile();return this.templatedFiles}}]);return Docxtemplater}();Docxtemplater.DocUtils=require("./doc-utils");Docxtemplater.Errors=require("./errors");Docxtemplater.XmlTemplater=require("./xml-templater");Docxtemplater.FileTypeConfig=require("./file-type-config");Docxtemplater.XmlMatcher=require("./xml-matcher");module.exports=Docxtemplater},{"./doc-utils":4,"./errors":6,"./file-type-config":7,"./xml-matcher":21,"./xml-templater":22}],6:[function(require,module,exports){"use strict";function XTError(message){this.name="GenericError";this.message=message;this.stack=new Error(message).stack}XTError.prototype=Error.prototype;function XTTemplateError(message){this.name="TemplateError";this.message=message;this.stack=new Error(message).stack}XTTemplateError.prototype=new XTError;function XTScopeParserError(message){this.name="ScopeParserError";this.message=message;this.stack=new Error(message).stack}XTScopeParserError.prototype=new XTError;function XTInternalError(message){this.name="InternalError";this.properties={explanation:"InternalError"};this.message=message;this.stack=new Error(message).stack}XTInternalError.prototype=new XTError;module.exports={XTError:XTError,XTTemplateError:XTTemplateError,XTInternalError:XTInternalError,XTScopeParserError:XTScopeParserError}},{}],7:[function(require,module,exports){"use strict";var loopModule=require("./modules/loop");var spacePreserveModule=require("./modules/space-preserve");var rawXmlModule=require("./modules/rawxml");var expandPairTrait=require("./modules/expand-pair-trait");var render=require("./modules/render");var PptXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["ppt/presentation.xml"])},textPath:"ppt/slides/slide1.xml",tagsXmlTextArray:["a:t","m:t"],tagsXmlLexedArray:["p:sp","a:tc","a:tr","a:table","a:p","a:r"],tagRawXml:"p:sp",tagTextXml:"a:t",baseModules:[render,expandPairTrait,rawXmlModule,loopModule]};var DocXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/word\/(header|footer)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["word/document.xml"])},textPath:"word/document.xml",tagsXmlTextArray:["w:t","m:t"],tagsXmlLexedArray:["w:tc","w:tr","w:table","w:p","w:r"],tagRawXml:"w:p",tagTextXml:"w:t",baseModules:[render,spacePreserveModule,expandPairTrait,rawXmlModule,loopModule]};module.exports={docx:DocXFileTypeConfig,pptx:PptXFileTypeConfig}},{"./modules/expand-pair-trait":12,"./modules/loop":13,"./modules/rawxml":14,"./modules/render":15,"./modules/space-preserve":16}],8:[function(require,module,exports){"use strict";var Errors=require("./errors");var DocUtils=require("./doc-utils");function inRange(range,match){return range[0]<=match.offset&&match.offset<range[1]}function updateInTextTag(part,inTextTag){if(part.type==="tag"&&part.position==="start"&&part.text){if(inTextTag){throw new Error("Malformed xml : Already in text tag")}return true}if(part.type==="tag"&&part.position==="end"&&part.text){if(!inTextTag){throw new Error("Malformed xml : Already not in text tag")}return false}return inTextTag}function offsetSort(a,b){return a.offset-b.offset}function getTag(tag){var start=1;if(tag[1]==="/"){start=2}var index=tag.indexOf(" ");var end=index===-1?tag.length-1:index;return{tag:tag.slice(start,end),position:start===1?"start":"end"}}function tagMatcher(content,textMatchArray,othersMatchArray){var cursor=0;var contentLength=content.length;var allMatches=DocUtils.concatArrays([textMatchArray.map(function(tag){return{tag:tag,text:true}}),othersMatchArray.map(function(tag){return{tag:tag,text:false}})]).reduce(function(allMatches,t){allMatches[t.tag]=t.text;return allMatches},{});var totalMatches=[];while(cursor<contentLength){cursor=content.indexOf("<",cursor);if(cursor===-1){break}var offset=cursor;cursor=content.indexOf(">",cursor);var tagText=content.slice(offset,cursor+1);var _getTag=getTag(tagText),tag=_getTag.tag,position=_getTag.position;var text=allMatches[tag];if(text==null){continue}totalMatches.push({type:"tag",position:position,text:text,offset:offset,value:tagText})}return totalMatches}function throwUnopenedTagException(options){var err=new Errors.XTTemplateError("Unopened tag");err.properties={xtag:options.xtag.split(" ")[0],id:"unopened_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function throwUnclosedTagException(options){var err=new Errors.XTTemplateError("Unclosed tag");err.properties={xtag:options.xtag.split(" ")[0].substr(1),id:"unclosed_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function assertDelimiterOrdered(delimiterMatches,fullText){var inDelimiter=false;var lastDelimiterMatch={offset:0};var xtag=void 0;delimiterMatches.forEach(function(delimiterMatch){xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(delimiterMatch.position==="start"&&inDelimiter||delimiterMatch.position==="end"&&!inDelimiter){if(delimiterMatch.position==="start"){throwUnclosedTagException({xtag:xtag})}else{throwUnopenedTagException({xtag:xtag})}}inDelimiter=!inDelimiter;lastDelimiterMatch=delimiterMatch});var delimiterMatch={offset:fullText.length};xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(inDelimiter){throwUnclosedTagException({xtag:xtag})}}function getAllIndexes(arr,val,position){var indexes=[];var offset=-1;do{offset=arr.indexOf(val,offset+1);if(offset!==-1){indexes.push({offset:offset,position:position})}}while(offset!==-1);return indexes}function Reader(innerContentParts){var _this=this;this.innerContentParts=innerContentParts;this.full="";this.parseDelimiters=function(delimiters){_this.full=_this.innerContentParts.join("");var offset=0;_this.ranges=_this.innerContentParts.map(function(part){offset+=part.length;return offset-part.length});var delimiterMatches=DocUtils.concatArrays([getAllIndexes(_this.full,delimiters.start,"start"),getAllIndexes(_this.full,delimiters.end,"end")]).sort(offsetSort);assertDelimiterOrdered(delimiterMatches,_this.full);var delimiterLength={start:delimiters.start.length,end:delimiters.end.length};var cutNext=0;var delimiterIndex=0;_this.parsed=_this.ranges.map(function(offset,i){var range=[offset,offset+this.innerContentParts[i].length];var partContent=this.innerContentParts[i];var delimitersInOffset=[];while(delimiterIndex<delimiterMatches.length&&inRange(range,delimiterMatches[delimiterIndex])){delimitersInOffset.push(delimiterMatches[delimiterIndex]);delimiterIndex++}var parts=[];var cursor=0;if(cutNext>0){cursor=cutNext;cutNext=0}delimitersInOffset.forEach(function(delimiterInOffset){var value=partContent.substr(cursor,delimiterInOffset.offset-offset-cursor);if(value.length>0){parts.push({type:"content",value:value})}parts.push({type:"delimiter",position:delimiterInOffset.position});cursor=delimiterInOffset.offset-offset+delimiterLength[delimiterInOffset.position]});cutNext=cursor-partContent.length;var value=partContent.substr(cursor);if(value.length>0){parts.push({type:"content",value:value})}return parts},_this)}}module.exports={parse:function parse(xmlparsed,delimiters){var inTextTag=false;var innerContentParts=[];xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(inTextTag&&part.type==="content"){innerContentParts.push(part.value)}});var reader=new Reader(innerContentParts);reader.parseDelimiters(delimiters);var newArray=[];var index=0;xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(part.type==="content"){part.position=inTextTag?"insidetag":"outsidetag"}if(inTextTag&&part.type==="content"){Array.prototype.push.apply(newArray,reader.parsed[index].map(function(p){if(p.type==="content"){p.position="insidetag"}return p}));index++}else{newArray.push(part)}});return newArray},xmlparse:function xmlparse(content,xmltags){var matches=tagMatcher(content,xmltags.text,xmltags.other);var cursor=0;var parsed=matches.reduce(function(parsed,match){var value=content.substr(cursor,match.offset-cursor);if(value.length>0){parsed.push({type:"content",value:value})}cursor=match.offset+match.value.length;delete match.offset;if(match.value.length>0){parsed.push(match)}return parsed},[]);var value=content.substr(cursor);if(value.length>0){parsed.push({type:"content",value:value})}return parsed}}},{"./doc-utils":4,"./errors":6}],9:[function(require,module,exports){"use strict";function memoize(func){var stringifyJson=JSON.stringify,cache={};function cachedfun(){var hash=stringifyJson(arguments);return hash in cache?cache[hash]:cache[hash]=func.apply(this,arguments)}return cachedfun}module.exports=memoize},{}],10:[function(require,module,exports){"use strict";function getMinFromArrays(arrays,state){var minIndex=-1;for(var i=0,l=arrays.length;i<l;i++){if(state[i]>=arrays[i].length){continue}if(minIndex===-1||arrays[i][state[i]].offset<arrays[minIndex][state[minIndex]].offset){minIndex=i}}if(minIndex===-1){throw new Error("minIndex negative")}return minIndex}module.exports=function(arrays){var totalLength=arrays.reduce(function(sum,array){return sum+array.length},0);arrays=arrays.filter(function(array){return array.length>0});var resultArray=new Array(totalLength);var state=arrays.map(function(){return 0});var i=0;while(i<=totalLength-1){var arrayIndex=getMinFromArrays(arrays,state);resultArray[i]=arrays[arrayIndex][state[arrayIndex]];state[arrayIndex]++;i++}return resultArray}},{}],11:[function(require,module,exports){"use strict";function emptyFun(){}function identity(i){return i}module.exports=function(module){var defaults={set:emptyFun,parse:emptyFun,render:emptyFun,getTraits:emptyFun,optionsTransformer:identity,getRenderedMap:identity,postparse:identity};if(Object.keys(defaults).every(function(key){return!module[key]})){throw new Error("This module cannot be wrapped, because it doesn't define any of the necessary functions")}Object.keys(defaults).forEach(function(key){module[key]=module[key]||defaults[key]});return module}},{}],12:[function(require,module,exports){"use strict";var traitName="expandPair";var mergeSort=require("../mergesort");var DocUtils=require("../doc-utils");var wrapper=require("../module-wrapper");var _require=require("../traits"),getExpandToDefault=_require.getExpandToDefault;var Errors=require("../errors");function throwUnmatchedLoopException(options){var location=options.location;var t=location==="start"?"unclosed":"unopened";var T=location==="start"?"Unclosed":"Unopened";var err=new Errors.XTTemplateError(T+" loop");var tag=options.part.value;err.properties={id:t+"_loop",explanation:"The loop with tag "+tag+" is "+t,xtag:tag};throw err}function throwClosingTagNotMatchOpeningTag(options){var tags=options.tags;var err=new Errors.XTTemplateError("Closing tag does not match opening tag");err.properties={id:"closing_tag_does_not_match_opening_tag",explanation:'The tag "'+tags[0].value+'" is closed by the tag "'+tags[1].value+'"',openingtag:tags[0].value,closingtag:tags[1].value};throw err}function getOpenCountChange(part){switch(part.location){case"start":return 1;case"end":return-1;default:throw new Error("Location should be one of 'start' or 'end' (given : "+part.location+")")}}function getPairs(traits){if(traits.length===0){return[]}var countOpen=1;var firstTrait=traits[0];for(var i=1;i<traits.length;i++){var currentTrait=traits[i];countOpen+=getOpenCountChange(currentTrait.part);if(countOpen===0){if(currentTrait.part.value!==firstTrait.part.value&&currentTrait.part.value!==""){throwClosingTagNotMatchOpeningTag({tags:[firstTrait.part,currentTrait.part]})}var outer=getPairs(traits.slice(i+1));
return[[firstTrait,currentTrait]].concat(outer)}}var part=firstTrait.part;throwUnmatchedLoopException({part:part,location:part.location})}var expandPairTrait={name:"ExpandPairTrait",postparse:function postparse(parsed,_ref){var getTraits=_ref.getTraits,_postparse=_ref.postparse;var traits=getTraits(traitName,parsed);traits=traits.map(function(trait){return trait||[]});traits=mergeSort(traits);var pairs=getPairs(traits);var expandedPairs=pairs.map(function(pair){var expandTo=pair[0].part.expandTo;if(expandTo==="auto"){expandTo=getExpandToDefault(parsed.slice(pair[0].offset,pair[1].offset))}if(!expandTo){return[pair[0].offset,pair[1].offset]}var left=DocUtils.getLeft(parsed,expandTo,pair[0].offset);var right=DocUtils.getRight(parsed,expandTo,pair[1].offset);return[left,right]});var currentPairIndex=0;var innerParts=void 0;return parsed.reduce(function(newParsed,part,i){var inPair=currentPairIndex<pairs.length&&expandedPairs[currentPairIndex][0]<=i;var pair=pairs[currentPairIndex];var expandedPair=expandedPairs[currentPairIndex];if(!inPair){newParsed.push(part);return newParsed}if(expandedPair[0]===i){innerParts=[]}if(pair[0].offset!==i&&pair[1].offset!==i){innerParts.push(part)}if(expandedPair[1]===i){var basePart=parsed[pair[0].offset];delete basePart.location;delete basePart.expandTo;basePart.subparsed=_postparse(innerParts);newParsed.push(basePart);currentPairIndex++}return newParsed},[])}};module.exports=function(){return wrapper(expandPairTrait)}},{"../doc-utils":4,"../errors":6,"../mergesort":10,"../module-wrapper":11,"../traits":20}],13:[function(require,module,exports){"use strict";var DocUtils=require("../doc-utils");var dashInnerRegex=/^-([^\s]+)\s(.+)$/;var wrapper=require("../module-wrapper");var moduleName="loop";var loopModule={name:"LoopModule",parse:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent[0]==="#"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:false}}if(placeHolderContent[0]==="^"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:true}}if(placeHolderContent[0]==="/"){return{type:type,value:placeHolderContent.substr(1),module:module,location:"end"}}if(placeHolderContent[0]==="-"){var value=placeHolderContent.replace(dashInnerRegex,"$2");var expandTo=placeHolderContent.replace(dashInnerRegex,"$1");return{type:type,value:value,expandTo:expandTo,module:module,location:"start",inverted:false}}return null},getTraits:function getTraits(traitName,parsed){if(traitName!=="expandPair"){return}return parsed.reduce(function(tags,part,offset){if(part.type==="placeholder"&&part.module===moduleName){tags.push({part:part,offset:offset})}return tags},[])},render:function render(part,options){if(!part.type==="placeholder"||part.module!==moduleName){return null}var totalValue=[];function loopOver(scope){var scopeManager=options.scopeManager.createSubScopeManager(scope,part.value);totalValue.push(options.render(DocUtils.mergeObjects({},options,{compiled:part.subparsed,tags:{},scopeManager:scopeManager})))}options.scopeManager.loopOver(part.value,loopOver,part.inverted);return{value:totalValue.join("")}}};module.exports=function(){return wrapper(loopModule)}},{"../doc-utils":4,"../module-wrapper":11}],14:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("../doc-utils");var Errors=require("../errors");var moduleName="rawxml";var wrapper=require("../module-wrapper");function throwRawTagShouldBeOnlyTextInParagraph(options){var err=new Errors.XTTemplateError("Raw tag should be the only text in paragraph");var tag=options.part.value;err.properties={id:"raw_xml_tag_should_be_only_text_in_paragraph",explanation:"The tag "+tag,xtag:options.part.value,paragraphParts:options.paragraphParts};throw err}function getInner(_ref){var part=_ref.part,left=_ref.left,right=_ref.right,postparsed=_ref.postparsed,index=_ref.index;var paragraphParts=postparsed.slice(left+1,right);paragraphParts.forEach(function(p,i){if(i===index-left-1){return}if(p.type==="placeholder"||p.type==="content"&&p.position==="insidetag"){throwRawTagShouldBeOnlyTextInParagraph({paragraphParts:paragraphParts,part:part})}});return part}var RawXmlModule=function(){function RawXmlModule(){_classCallCheck(this,RawXmlModule);this.name="RawXmlModule"}_createClass(RawXmlModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){this.fileTypeConfig=docxtemplater.fileTypeConfig;return options}},{key:"parse",value:function parse(placeHolderContent){var type="placeholder";if(placeHolderContent[0]!=="@"){return null}return{type:type,value:placeHolderContent.substr(1),module:moduleName}}},{key:"postparse",value:function postparse(parsed){return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:this.fileTypeConfig.tagRawXml})}},{key:"render",value:function render(part,options){if(part.module!==moduleName){return null}var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return{value:value}}}]);return RawXmlModule}();module.exports=function(){return wrapper(new RawXmlModule)}},{"../doc-utils":4,"../errors":6,"../module-wrapper":11}],15:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var wrapper=require("../module-wrapper");var Render=function(){function Render(){_classCallCheck(this,Render);this.name="Render"}_createClass(Render,[{key:"set",value:function set(obj){if(obj.compiled){this.compiled=obj.compiled}if(obj.data!=null){this.data=obj.data}}},{key:"getRenderedMap",value:function getRenderedMap(mapper){var _this=this;return Object.keys(this.compiled).reduce(function(mapper,from){mapper[from]={from:from,data:_this.data};return mapper},mapper)}}]);return Render}();module.exports=function(){return wrapper(new Render)}},{"../module-wrapper":11}],16:[function(require,module,exports){"use strict";var wrapper=require("../module-wrapper");var spacePreserve={name:"SpacePreserveModule",postparse:function postparse(parsed){var chunk=[];var inChunk=false;var result=parsed.reduce(function(parsed,part){if(part.type==="tag"&&part.position==="start"&&part.text&&part.value==="<w:t>"){inChunk=true}if(inChunk){if(part.type==="placeholder"&&!part.module){chunk[0].value='<w:t xml:space="preserve">'}chunk.push(part)}else{parsed.push(part)}if(part.type==="tag"&&part.position==="end"&&part.text&&part.value==="</w:t>"){Array.prototype.push.apply(parsed,chunk);inChunk=false;chunk=[]}return parsed},[]);Array.prototype.push.apply(result,chunk);return result}};module.exports=function(){return wrapper(spacePreserve)}},{"../module-wrapper":11}],17:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var parser={postparse:function postparse(parsed,modules){function getTraits(traitName,parsed){return modules.map(function(module){return module.getTraits(traitName,parsed)})}function postparse(parsed){return modules.reduce(function(parsed,module){return module.postparse(parsed,{postparse:postparse,getTraits:getTraits})},parsed)}return postparse(parsed)},parse:function parse(lexed,modules){function moduleParse(placeHolderContent,parsed){var moduleParsed=void 0;for(var i=0,l=modules.length;i<l;i++){var _module=modules[i];moduleParsed=_module.parse(placeHolderContent);if(moduleParsed){parsed.push(moduleParsed);return moduleParsed}}return null}var inPlaceHolder=false;var placeHolderContent=void 0;var tailParts=[];return lexed.reduce(function(parsed,token){if(token.type==="delimiter"){inPlaceHolder=token.position==="start";if(token.position==="end"){placeHolderContent=DocUtils.wordToUtf8(placeHolderContent);if(!moduleParse(placeHolderContent,parsed)){parsed.push({type:"placeholder",value:placeHolderContent})}Array.prototype.push.apply(parsed,tailParts);tailParts=[];return parsed}placeHolderContent="";return parsed}if(inPlaceHolder){if(token.type==="content"&&token.position==="insidetag"){placeHolderContent+=token.value}else{tailParts.push(token)}return parsed}parsed.push(token);return parsed},[])}};module.exports=parser},{"./doc-utils":4}],18:[function(require,module,exports){"use strict";var ScopeManager=require("./scope-manager");var DocUtils=require("./doc-utils");function moduleRender(part,options){var moduleRendered=void 0;for(var i=0,l=options.modules.length;i<l;i++){var _module=options.modules[i];moduleRendered=_module.render(part,options);if(moduleRendered){return moduleRendered}}return false}function render(options){options.render=render;options.modules=options.modules;if(!options.scopeManager){options.scopeManager=ScopeManager.createBaseScopeManager(options)}return options.compiled.map(function(part){var moduleRendered=moduleRender(part,options);if(moduleRendered){return moduleRendered.value}if(part.type==="placeholder"){var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return DocUtils.utf8ToWord(value)}if(part.type==="content"||part.type==="tag"){return part.value}throw new Error('Unimplemented tag type "'+part.type+'"')}).join("")}module.exports=render},{"./doc-utils":4,"./scope-manager":19}],19:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var Errors=require("./errors");var ScopeManager=function(){function ScopeManager(options){_classCallCheck(this,ScopeManager);this.scopePath=options.scopePath;this.scopeList=options.scopeList;this.parser=options.parser}_createClass(ScopeManager,[{key:"loopOver",value:function loopOver(tag,callback,inverted){inverted=inverted||false;return this.loopOverValue(this.getValue(tag),callback,inverted)}},{key:"functorIfInverted",value:function functorIfInverted(inverted,functor,value){if(inverted){functor(value)}}},{key:"isValueFalsy",value:function isValueFalsy(value,type){return value==null||!value||type==="[object Array]"&&value.length===0}},{key:"loopOverValue",value:function loopOverValue(value,functor,inverted){var type=Object.prototype.toString.call(value);var currentValue=this.scopeList[this.num];if(this.isValueFalsy(value,type)){return this.functorIfInverted(inverted,functor,currentValue)}if(type==="[object Array]"){for(var i=0,scope;i<value.length;i++){scope=value[i];this.functorIfInverted(!inverted,functor,scope)}return}if(type==="[object Object]"){return this.functorIfInverted(!inverted,functor,value)}if(value===true){return this.functorIfInverted(!inverted,functor,currentValue)}}},{key:"getValue",value:function getValue(tag,num){this.num=num==null?this.scopeList.length-1:num;var err=void 0;var parser=void 0;var result=void 0;var scope=this.scopeList[this.num];try{parser=this.parser(tag)}catch(error){err=new Errors.XTScopeParserError("Scope parser compilation failed");err.properties={id:"scopeparser_compilation_failed",tag:tag,explanation:"The scope parser for the tag "+tag+" failed to compile",rootError:error};throw err}try{result=parser.get(scope,{num:this.num,scopeList:this.scopeList})}catch(error){err=new Errors.XTScopeParserError("Scope parser execution failed");err.properties={id:"scopeparser_execution_failed",explanation:"The scope parser for the tag "+tag+" failed to execute",scope:scope,tag:tag,rootError:error};throw err}if(result==null&&this.num>0){return this.getValue(tag,this.num-1)}return result}},{key:"createSubScopeManager",value:function createSubScopeManager(scope,tag){var options={scopePath:this.scopePath.slice(0),scopeList:this.scopeList.slice(0)};options.parser=this.parser;options.scopeList=this.scopeList.concat(scope);options.scopePath=this.scopePath.concat(tag);return new ScopeManager(options)}}]);return ScopeManager}();ScopeManager.createBaseScopeManager=function(_ref){var parser=_ref.parser,tags=_ref.tags;var options={parser:parser,tags:tags};options.scopePath=[];options.scopeList=[tags];return new ScopeManager(options)};module.exports=ScopeManager},{"./errors":6}],20:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var Errors=require("./errors");function throwRawTagNotInParagraph(options){var err=new Errors.XTTemplateError("Raw tag not in paragraph");var tag=options.part.value;err.properties={id:"raw_tag_outerxml_invalid",explanation:'The tag "'+tag+'"',rootError:options.rootError,xtag:tag};throw err}function lastTagIsOpenTag(array,tag){if(array.length===0){return false}var lastTag=array[array.length-1];var innerLastTag=lastTag.tag.substr(1);var innerCurrentTag=tag.substr(2,tag.length-3);return innerLastTag.indexOf(innerCurrentTag)===0}function addTag(array,tag){array.push({tag:tag});return array}function getListXmlElements(parts){var tags=parts.filter(function(part){return part.type==="tag"}).map(function(part){return part.value});var result=[];for(var i=0,tag;i<tags.length;i++){tag=tags[i];if(tag[1]==="/"){if(lastTagIsOpenTag(result,tag)){result.pop()}else{result=addTag(result,tag)}}else if(tag[tag.length-1]!=="/"){result=addTag(result,tag)}}return result}function getExpandToDefault(parts){var xmlElements=getListXmlElements(parts);for(var i=0;i<xmlElements.length;i++){var xmlElement=xmlElements[i];if(xmlElement.tag.indexOf("<w:tc")===0){return"w:tr"}}return false}function expandOne(part,postparsed,options){var expandTo=part.expandTo||options.expandTo;var index=postparsed.indexOf(part);if(!expandTo){return postparsed}var right=void 0,left=void 0;try{right=DocUtils.getRight(postparsed,expandTo,index);left=DocUtils.getLeft(postparsed,expandTo,index)}catch(rootError){throwRawTagNotInParagraph({part:part,rootError:rootError})}var leftParts=postparsed.slice(left,index);var rightParts=postparsed.slice(index+1,right+1);var inner=options.getInner({index:index,part:part,leftParts:leftParts,rightParts:rightParts,left:left,right:right,postparsed:postparsed});var type=Object.prototype.toString.call(inner);if(type==="[object Array]"){inner=DocUtils.concatArrays(inner)}return DocUtils.concatArrays([postparsed.slice(0,left),[inner],postparsed.slice(right+1)])}function expandToOne(postparsed,options){var expandToElements=postparsed.reduce(function(elements,part){if(part.type==="placeholder"&&part.module===options.moduleName){elements.push(part)}return elements},[]);expandToElements.forEach(function(part){postparsed=expandOne(part,postparsed,options)});return postparsed}module.exports={expandToOne:expandToOne,getExpandToDefault:getExpandToDefault}},{"./doc-utils":4,"./errors":6}],21:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var memoize=require("./memoize");function handleRecursiveCase(res){function replacerUnshift(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.shift();var match=pn.array[0]+pn.array[1];pn.array.unshift(match);pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.first=true;res.matches.unshift(pn);res.charactersAdded.unshift(0);return res.charactersAddedCumulative.unshift(0)}if(res.content.indexOf("<")===-1&&res.content.indexOf(">")===-1){res.content.replace(/^()([^<>]*)$/,replacerUnshift)}var r=new RegExp("^()([^<]+)</(?:"+res.tagsXmlArrayJoined+")>");res.content.replace(r,replacerUnshift);function replacerPush(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.last=true;res.matches.push(pn);res.charactersAdded.push(0);return res.charactersAddedCumulative.push(0)}r=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^>]+)$");res.content.replace(r,replacerPush);return res}function xmlMatcher(content,tagsXmlArray){var res={};res.content=content;res.tagsXmlArray=tagsXmlArray;res.tagsXmlArrayJoined=res.tagsXmlArray.join("|");var regexp=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^<>]*)</(?:"+res.tagsXmlArrayJoined+")>","g");res.matches=DocUtils.pregMatchAll(regexp,res.content);res.charactersAddedCumulative=res.matches.map(function(){return 0});res.charactersAdded=res.matches.map(function(){return 0});return handleRecursiveCase(res)}var memoized=memoize(xmlMatcher);module.exports=function(content,tagsXmlArray){return DocUtils.cloneDeep(memoized(content,tagsXmlArray))}},{"./doc-utils":4,"./memoize":9}],22:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var ScopeManager=require("./scope-manager");var xmlMatcher=require("./xml-matcher");var Errors=require("./errors");var Lexer=require("./lexer");var Parser=require("./parser.js");var _render=require("./render.js");function _getFullText(content,tagsXmlArray){var matcher=xmlMatcher(content,tagsXmlArray);var result=matcher.matches.map(function(match){return match.array[2]});return DocUtils.wordToUtf8(DocUtils.convertSpaces(result.join("")))}module.exports=function(){function XmlTemplater(content,options){_classCallCheck(this,XmlTemplater);this.fromJson(options);this.setModules({inspect:{filePath:this.filePath}});this.load(content)}_createClass(XmlTemplater,[{key:"load",value:function load(content){if(typeof content!=="string"){var err=new Errors.XTInternalError("Content must be a string");err.properties.id="xmltemplater_content_must_be_string";throw err}this.content=content}},{key:"setTags",value:function setTags(tags){this.tags=tags!=null?tags:{};this.scopeManager=ScopeManager.createBaseScopeManager({tags:this.tags,parser:this.parser});return this}},{key:"fromJson",value:function fromJson(options){this.filePath=options.filePath;this.modules=options.modules;this.fileTypeConfig=options.fileTypeConfig;Object.keys(DocUtils.defaults).map(function(key){this[key]=options[key]!=null?options[key]:DocUtils.defaults[key]},this)}},{key:"getFullText",value:function getFullText(){return _getFullText(this.content,this.fileTypeConfig.tagsXmlTextArray)}},{key:"setModules",value:function setModules(obj){this.modules.forEach(function(module){module.set(obj)})}},{key:"parse",value:function parse(){this.xmllexed=Lexer.xmlparse(this.content,{text:this.fileTypeConfig.tagsXmlTextArray,other:this.fileTypeConfig.tagsXmlLexedArray});this.setModules({inspect:{xmllexed:this.xmllexed}});this.lexed=Lexer.parse(this.xmllexed,this.delimiters);this.setModules({inspect:{lexed:this.lexed}});this.parsed=Parser.parse(this.lexed,this.modules);this.setModules({inspect:{parsed:this.parsed}});this.postparsed=Parser.postparse(this.parsed,this.modules);return this}},{key:"render",value:function render(){this.setModules({inspect:{postparsed:this.postparsed}});this.content=_render({compiled:this.postparsed,tags:this.tags,modules:this.modules,parser:this.parser,nullGetter:this.nullGetter,filePath:this.filePath});this.setModules({inspect:{content:this.content}});return this}}]);return XmlTemplater}()},{"./doc-utils":4,"./errors":6,"./lexer":8,"./parser.js":17,"./render.js":18,"./scope-manager":19,"./xml-matcher":21}],23:[function(require,module,exports){function DOMParser(options){this.options=options||{locator:{}}}DOMParser.prototype.parseFromString=function(source,mimeType){var options=this.options;var sax=new XMLReader;var domBuilder=options.domBuilder||new DOMHandler;var errorHandler=options.errorHandler;var locator=options.locator;var defaultNSMap=options.xmlns||{};var entityMap={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"};if(locator){domBuilder.setDocumentLocator(locator)}sax.errorHandler=buildErrorHandler(errorHandler,domBuilder,locator);sax.domBuilder=options.domBuilder||domBuilder;if(/\/x?html?$/.test(mimeType)){entityMap.nbsp=" ";entityMap.copy="©";defaultNSMap[""]="http://www.w3.org/1999/xhtml"}defaultNSMap.xml=defaultNSMap.xml||"http://www.w3.org/XML/1998/namespace";if(source){sax.parse(source,defaultNSMap,entityMap)}else{sax.errorHandler.error("invalid doc source")}return domBuilder.doc};function buildErrorHandler(errorImpl,domBuilder,locator){if(!errorImpl){if(domBuilder instanceof DOMHandler){return domBuilder}errorImpl=domBuilder}var errorHandler={};var isCallback=errorImpl instanceof Function;locator=locator||{};function build(key){var fn=errorImpl[key];if(!fn&&isCallback){fn=errorImpl.length==2?function(msg){errorImpl(key,msg)}:errorImpl}errorHandler[key]=fn&&function(msg){fn("[xmldom "+key+"]\t"+msg+_locator(locator))}||function(){}}build("warning");build("error");build("fatalError");return errorHandler}function DOMHandler(){this.cdata=false}function position(locator,node){node.lineNumber=locator.lineNumber;node.columnNumber=locator.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=(new DOMImplementation).createDocument(null,null,null);if(this.locator){this.doc.documentURI=this.locator.systemId}},startElement:function(namespaceURI,localName,qName,attrs){var doc=this.doc;var el=doc.createElementNS(namespaceURI,qName||localName);var len=attrs.length;appendElement(this,el);this.currentElement=el;this.locator&&position(this.locator,el);for(var i=0;i<len;i++){var namespaceURI=attrs.getURI(i);var value=attrs.getValue(i);var qName=attrs.getQName(i);var attr=doc.createAttributeNS(namespaceURI,qName);this.locator&&position(attrs.getLocator(i),attr);attr.value=attr.nodeValue=value;el.setAttributeNode(attr)}},endElement:function(namespaceURI,localName,qName){var current=this.currentElement;var tagName=current.tagName;this.currentElement=current.parentNode},startPrefixMapping:function(prefix,uri){},endPrefixMapping:function(prefix){},processingInstruction:function(target,data){var ins=this.doc.createProcessingInstruction(target,data);this.locator&&position(this.locator,ins);appendElement(this,ins)},ignorableWhitespace:function(ch,start,length){},characters:function(chars,start,length){chars=_toString.apply(this,arguments);if(chars){if(this.cdata){var charNode=this.doc.createCDATASection(chars)}else{var charNode=this.doc.createTextNode(chars)}if(this.currentElement){this.currentElement.appendChild(charNode)}else if(/^\s*$/.test(chars)){this.doc.appendChild(charNode)}this.locator&&position(this.locator,charNode)}},skippedEntity:function(name){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(locator){if(this.locator=locator){locator.lineNumber=0}},comment:function(chars,start,length){chars=_toString.apply(this,arguments);var comm=this.doc.createComment(chars);this.locator&&position(this.locator,comm);appendElement(this,comm)},startCDATA:function(){this.cdata=true},endCDATA:function(){this.cdata=false},startDTD:function(name,publicId,systemId){var impl=this.doc.implementation;if(impl&&impl.createDocumentType){var dt=impl.createDocumentType(name,publicId,systemId);this.locator&&position(this.locator,dt);appendElement(this,dt)}},warning:function(error){console.warn("[xmldom warning]\t"+error,_locator(this.locator))},error:function(error){console.error("[xmldom error]\t"+error,_locator(this.locator))},fatalError:function(error){console.error("[xmldom fatalError]\t"+error,_locator(this.locator));throw error}};function _locator(l){if(l){return"\n@"+(l.systemId||"")+"#[line:"+l.lineNumber+",col:"+l.columnNumber+"]"}}function _toString(chars,start,length){if(typeof chars=="string"){return chars.substr(start,length)}else{if(chars.length>=start+length||start){return new java.lang.String(chars,start,length)+""}return chars}}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){DOMHandler.prototype[key]=function(){return null}});function appendElement(hander,node){if(!hander.currentElement){hander.doc.appendChild(node)}else{hander.currentElement.appendChild(node)}}var XMLReader=require("./sax").XMLReader;var DOMImplementation=exports.DOMImplementation=require("./dom").DOMImplementation;exports.XMLSerializer=require("./dom").XMLSerializer;exports.DOMParser=DOMParser},{"./dom":24,"./sax":25}],24:[function(require,module,exports){function copy(src,dest){for(var p in src){dest[p]=src[p]}}function _extends(Class,Super){var pt=Class.prototype;if(Object.create){var ppt=Object.create(Super.prototype);pt.__proto__=ppt}if(!(pt instanceof Super)){function t(){}t.prototype=Super.prototype;t=new t;copy(pt,t);Class.prototype=pt=t}if(pt.constructor!=Class){if(typeof Class!="function"){console.error("unknow Class:"+Class)}pt.constructor=Class}}var htmlns="http://www.w3.org/1999/xhtml";var NodeType={};var ELEMENT_NODE=NodeType.ELEMENT_NODE=1;var ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2;var TEXT_NODE=NodeType.TEXT_NODE=3;var CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4;var ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5;var ENTITY_NODE=NodeType.ENTITY_NODE=6;var PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7;var COMMENT_NODE=NodeType.COMMENT_NODE=8;var DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9;var DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10;var DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11;var NOTATION_NODE=NodeType.NOTATION_NODE=12;var ExceptionCode={};var ExceptionMessage={};var INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1);var DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2);var HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3);var WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4);var INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5);var NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6);var NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7);var NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8);var NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9);var INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10);var INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11);var SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12);var INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13);var NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14);var INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(code,message){if(message instanceof Error){var error=message}else{error=this;Error.call(this,ExceptionMessage[code]);this.message=ExceptionMessage[code];if(Error.captureStackTrace)Error.captureStackTrace(this,DOMException)}error.code=code;if(message)this.message=this.message+": "+message;return error}DOMException.prototype=Error.prototype;copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(index){return this[index]||null},toString:function(isHTML,nodeFilter){for(var buf=[],i=0;i<this.length;i++){serializeToString(this[i],buf,isHTML,nodeFilter)}return buf.join("")}};function LiveNodeList(node,refresh){this._node=node;this._refresh=refresh;_updateLiveList(this)}function _updateLiveList(list){var inc=list._node._inc||list._node.ownerDocument._inc;if(list._inc!=inc){var ls=list._refresh(list._node);__set__(list,"length",ls.length);copy(ls,list);list._inc=inc}}LiveNodeList.prototype.item=function(i){_updateLiveList(this);return this[i]};_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(list,node){var i=list.length;while(i--){if(list[i]===node){return i}}}function _addNamedNode(el,list,newAttr,oldAttr){if(oldAttr){list[_findNodeIndex(list,oldAttr)]=newAttr}else{list[list.length++]=newAttr}if(el){newAttr.ownerElement=el;var doc=el.ownerDocument;if(doc){oldAttr&&_onRemoveAttribute(doc,el,oldAttr);_onAddAttribute(doc,el,newAttr)}}}function _removeNamedNode(el,list,attr){var i=_findNodeIndex(list,attr);if(i>=0){var lastIndex=list.length-1;while(i<lastIndex){list[i]=list[++i]}list.length=lastIndex;if(el){var doc=el.ownerDocument;if(doc){_onRemoveAttribute(doc,el,attr);attr.ownerElement=null}}}else{throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+"@"+attr))}}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(key){var i=this.length;while(i--){var attr=this[i];if(attr.nodeName==key){return attr}}},setNamedItem:function(attr){var el=attr.ownerElement;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}var oldAttr=this.getNamedItem(attr.nodeName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},setNamedItemNS:function(attr){var el=attr.ownerElement,oldAttr;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}oldAttr=this.getNamedItemNS(attr.namespaceURI,attr.localName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},removeNamedItem:function(key){var attr=this.getNamedItem(key);_removeNamedNode(this._ownerElement,this,attr);return attr},removeNamedItemNS:function(namespaceURI,localName){var attr=this.getNamedItemNS(namespaceURI,localName);_removeNamedNode(this._ownerElement,this,attr);return attr},getNamedItemNS:function(namespaceURI,localName){var i=this.length;while(i--){var node=this[i];if(node.localName==localName&&node.namespaceURI==namespaceURI){return node}}return null}};function DOMImplementation(features){this._features={};if(features){for(var feature in features){this._features=features[feature]}}}DOMImplementation.prototype={hasFeature:function(feature,version){var versions=this._features[feature.toLowerCase()];if(versions&&(!version||version in versions)){
return true}else{return false}},createDocument:function(namespaceURI,qualifiedName,doctype){var doc=new Document;doc.implementation=this;doc.childNodes=new NodeList;doc.doctype=doctype;if(doctype){doc.appendChild(doctype)}if(qualifiedName){var root=doc.createElementNS(namespaceURI,qualifiedName);doc.appendChild(root)}return doc},createDocumentType:function(qualifiedName,publicId,systemId){var node=new DocumentType;node.name=qualifiedName;node.nodeName=qualifiedName;node.publicId=publicId;node.systemId=systemId;return node}};function Node(){}Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(newChild,refChild){return _insertBefore(this,newChild,refChild)},replaceChild:function(newChild,oldChild){this.insertBefore(newChild,oldChild);if(oldChild){this.removeChild(oldChild)}},removeChild:function(oldChild){return _removeChild(this,oldChild)},appendChild:function(newChild){return this.insertBefore(newChild,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(deep){return cloneNode(this.ownerDocument||this,this,deep)},normalize:function(){var child=this.firstChild;while(child){var next=child.nextSibling;if(next&&next.nodeType==TEXT_NODE&&child.nodeType==TEXT_NODE){this.removeChild(next);child.appendData(next.data)}else{child.normalize();child=next}}},isSupported:function(feature,version){return this.ownerDocument.implementation.hasFeature(feature,version)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(namespaceURI){var el=this;while(el){var map=el._nsMap;if(map){for(var n in map){if(map[n]==namespaceURI){return n}}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},lookupNamespaceURI:function(prefix){var el=this;while(el){var map=el._nsMap;if(map){if(prefix in map){return map[prefix]}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},isDefaultNamespace:function(namespaceURI){var prefix=this.lookupPrefix(namespaceURI);return prefix==null}};function _xmlEncoder(c){return c=="<"&&"&lt;"||c==">"&&"&gt;"||c=="&"&&"&amp;"||c=='"'&&"&quot;"||"&#"+c.charCodeAt()+";"}copy(NodeType,Node);copy(NodeType,Node.prototype);function _visitNode(node,callback){if(callback(node)){return true}if(node=node.firstChild){do{if(_visitNode(node,callback)){return true}}while(node=node.nextSibling)}}function Document(){}function _onAddAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){el._nsMap[newAttr.prefix?newAttr.localName:""]=newAttr.value}}function _onRemoveAttribute(doc,el,newAttr,remove){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){delete el._nsMap[newAttr.prefix?newAttr.localName:""]}}function _onUpdateChild(doc,el,newChild){if(doc&&doc._inc){doc._inc++;var cs=el.childNodes;if(newChild){cs[cs.length++]=newChild}else{var child=el.firstChild;var i=0;while(child){cs[i++]=child;child=child.nextSibling}cs.length=i}}}function _removeChild(parentNode,child){var previous=child.previousSibling;var next=child.nextSibling;if(previous){previous.nextSibling=next}else{parentNode.firstChild=next}if(next){next.previousSibling=previous}else{parentNode.lastChild=previous}_onUpdateChild(parentNode.ownerDocument,parentNode);return child}function _insertBefore(parentNode,newChild,nextChild){var cp=newChild.parentNode;if(cp){cp.removeChild(newChild)}if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){var newFirst=newChild.firstChild;if(newFirst==null){return newChild}var newLast=newChild.lastChild}else{newFirst=newLast=newChild}var pre=nextChild?nextChild.previousSibling:parentNode.lastChild;newFirst.previousSibling=pre;newLast.nextSibling=nextChild;if(pre){pre.nextSibling=newFirst}else{parentNode.firstChild=newFirst}if(nextChild==null){parentNode.lastChild=newLast}else{nextChild.previousSibling=newLast}do{newFirst.parentNode=parentNode}while(newFirst!==newLast&&(newFirst=newFirst.nextSibling));_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){newChild.firstChild=newChild.lastChild=null}return newChild}function _appendSingleChild(parentNode,newChild){var cp=newChild.parentNode;if(cp){var pre=parentNode.lastChild;cp.removeChild(newChild);var pre=parentNode.lastChild}var pre=parentNode.lastChild;newChild.parentNode=parentNode;newChild.previousSibling=pre;newChild.nextSibling=null;if(pre){pre.nextSibling=newChild}else{parentNode.firstChild=newChild}parentNode.lastChild=newChild;_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);return newChild}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(newChild,refChild){if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){var child=newChild.firstChild;while(child){var next=child.nextSibling;this.insertBefore(child,refChild);child=next}return newChild}if(this.documentElement==null&&newChild.nodeType==ELEMENT_NODE){this.documentElement=newChild}return _insertBefore(this,newChild,refChild),newChild.ownerDocument=this,newChild},removeChild:function(oldChild){if(this.documentElement==oldChild){this.documentElement=null}return _removeChild(this,oldChild)},importNode:function(importedNode,deep){return importNode(this,importedNode,deep)},getElementById:function(id){var rtv=null;_visitNode(this.documentElement,function(node){if(node.nodeType==ELEMENT_NODE){if(node.getAttribute("id")==id){rtv=node;return true}}});return rtv},createElement:function(tagName){var node=new Element;node.ownerDocument=this;node.nodeName=tagName;node.tagName=tagName;node.childNodes=new NodeList;var attrs=node.attributes=new NamedNodeMap;attrs._ownerElement=node;return node},createDocumentFragment:function(){var node=new DocumentFragment;node.ownerDocument=this;node.childNodes=new NodeList;return node},createTextNode:function(data){var node=new Text;node.ownerDocument=this;node.appendData(data);return node},createComment:function(data){var node=new Comment;node.ownerDocument=this;node.appendData(data);return node},createCDATASection:function(data){var node=new CDATASection;node.ownerDocument=this;node.appendData(data);return node},createProcessingInstruction:function(target,data){var node=new ProcessingInstruction;node.ownerDocument=this;node.tagName=node.target=target;node.nodeValue=node.data=data;return node},createAttribute:function(name){var node=new Attr;node.ownerDocument=this;node.name=name;node.nodeName=name;node.localName=name;node.specified=true;return node},createEntityReference:function(name){var node=new EntityReference;node.ownerDocument=this;node.nodeName=name;return node},createElementNS:function(namespaceURI,qualifiedName){var node=new Element;var pl=qualifiedName.split(":");var attrs=node.attributes=new NamedNodeMap;node.childNodes=new NodeList;node.ownerDocument=this;node.nodeName=qualifiedName;node.tagName=qualifiedName;node.namespaceURI=namespaceURI;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}attrs._ownerElement=node;return node},createAttributeNS:function(namespaceURI,qualifiedName){var node=new Attr;var pl=qualifiedName.split(":");node.ownerDocument=this;node.nodeName=qualifiedName;node.name=qualifiedName;node.namespaceURI=namespaceURI;node.specified=true;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}return node}};_extends(Document,Node);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(name){return this.getAttributeNode(name)!=null},getAttribute:function(name){var attr=this.getAttributeNode(name);return attr&&attr.value||""},getAttributeNode:function(name){return this.attributes.getNamedItem(name)},setAttribute:function(name,value){var attr=this.ownerDocument.createAttribute(name);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},removeAttribute:function(name){var attr=this.getAttributeNode(name);attr&&this.removeAttributeNode(attr)},appendChild:function(newChild){if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){return this.insertBefore(newChild,null)}else{return _appendSingleChild(this,newChild)}},setAttributeNode:function(newAttr){return this.attributes.setNamedItem(newAttr)},setAttributeNodeNS:function(newAttr){return this.attributes.setNamedItemNS(newAttr)},removeAttributeNode:function(oldAttr){return this.attributes.removeNamedItem(oldAttr.nodeName)},removeAttributeNS:function(namespaceURI,localName){var old=this.getAttributeNodeNS(namespaceURI,localName);old&&this.removeAttributeNode(old)},hasAttributeNS:function(namespaceURI,localName){return this.getAttributeNodeNS(namespaceURI,localName)!=null},getAttributeNS:function(namespaceURI,localName){var attr=this.getAttributeNodeNS(namespaceURI,localName);return attr&&attr.value||""},setAttributeNS:function(namespaceURI,qualifiedName,value){var attr=this.ownerDocument.createAttributeNS(namespaceURI,qualifiedName);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},getAttributeNodeNS:function(namespaceURI,localName){return this.attributes.getNamedItemNS(namespaceURI,localName)},getElementsByTagName:function(tagName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType==ELEMENT_NODE&&(tagName==="*"||node.tagName==tagName)){ls.push(node)}});return ls})},getElementsByTagNameNS:function(namespaceURI,localName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType===ELEMENT_NODE&&(namespaceURI==="*"||node.namespaceURI===namespaceURI)&&(localName==="*"||node.localName==localName)){ls.push(node)}});return ls})}};Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName;Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS;_extends(Element,Node);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE;_extends(Attr,Node);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(offset,count){return this.data.substring(offset,offset+count)},appendData:function(text){text=this.data+text;this.nodeValue=this.data=text;this.length=text.length},insertData:function(offset,text){this.replaceData(offset,0,text)},appendChild:function(newChild){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(offset,count){this.replaceData(offset,count,"")},replaceData:function(offset,count,text){var start=this.data.substring(0,offset);var end=this.data.substring(offset+count);text=start+text+end;this.nodeValue=this.data=text;this.length=text.length}};_extends(CharacterData,Node);function Text(){}Text.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(offset){var text=this.data;var newText=text.substring(offset);text=text.substring(0,offset);this.data=this.nodeValue=text;this.length=text.length;var newNode=this.ownerDocument.createTextNode(newText);if(this.parentNode){this.parentNode.insertBefore(newNode,this.nextSibling)}return newNode}};_extends(Text,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE};_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE};_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE;_extends(DocumentType,Node);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE;_extends(Notation,Node);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE;_extends(Entity,Node);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE;_extends(EntityReference,Node);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment";DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE;_extends(DocumentFragment,Node);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE;_extends(ProcessingInstruction,Node);function XMLSerializer(){}XMLSerializer.prototype.serializeToString=function(node,isHtml,nodeFilter){return nodeSerializeToString.call(node,isHtml,nodeFilter)};Node.prototype.toString=nodeSerializeToString;function nodeSerializeToString(isHtml,nodeFilter){var buf=[];var refNode=this.nodeType==9?this.documentElement:this;var prefix=refNode.prefix;var uri=refNode.namespaceURI;if(uri&&prefix==null){var prefix=refNode.lookupPrefix(uri);if(prefix==null){var visibleNamespaces=[{namespace:uri,prefix:null}]}}serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);return buf.join("")}function needNamespaceDefine(node,isHTML,visibleNamespaces){var prefix=node.prefix||"";var uri=node.namespaceURI;if(!prefix&&!uri){return false}if(prefix==="xml"&&uri==="http://www.w3.org/XML/1998/namespace"||uri=="http://www.w3.org/2000/xmlns/"){return false}var i=visibleNamespaces.length;while(i--){var ns=visibleNamespaces[i];if(ns.prefix==prefix){return ns.namespace!=uri}}return true}function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){if(nodeFilter){node=nodeFilter(node);if(node){if(typeof node=="string"){buf.push(node);return}}else{return}}switch(node.nodeType){case ELEMENT_NODE:if(!visibleNamespaces)visibleNamespaces=[];var startVisibleNamespaces=visibleNamespaces.length;var attrs=node.attributes;var len=attrs.length;var child=node.firstChild;var nodeName=node.tagName;isHTML=htmlns===node.namespaceURI||isHTML;buf.push("<",nodeName);for(var i=0;i<len;i++){var attr=attrs.item(i);if(attr.prefix=="xmlns"){visibleNamespaces.push({prefix:attr.localName,namespace:attr.value})}else if(attr.nodeName=="xmlns"){visibleNamespaces.push({prefix:"",namespace:attr.value})}}for(var i=0;i<len;i++){var attr=attrs.item(i);if(needNamespaceDefine(attr,isHTML,visibleNamespaces)){var prefix=attr.prefix||"";var uri=attr.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces)}if(needNamespaceDefine(node,isHTML,visibleNamespaces)){var prefix=node.prefix||"";var uri=node.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}if(child||isHTML&&!/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){buf.push(">");if(isHTML&&/^script$/i.test(nodeName)){while(child){if(child.data){buf.push(child.data)}else{serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces)}child=child.nextSibling}}else{while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}}buf.push("</",nodeName,">")}else{buf.push("/>")}return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var child=node.firstChild;while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}return;case ATTRIBUTE_NODE:return buf.push(" ",node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');case TEXT_NODE:return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));case CDATA_SECTION_NODE:return buf.push("<![CDATA[",node.data,"]]>");case COMMENT_NODE:return buf.push("<!--",node.data,"-->");case DOCUMENT_TYPE_NODE:var pubid=node.publicId;var sysid=node.systemId;buf.push("<!DOCTYPE ",node.name);if(pubid){buf.push(' PUBLIC "',pubid);if(sysid&&sysid!="."){buf.push('" "',sysid)}buf.push('">')}else if(sysid&&sysid!="."){buf.push(' SYSTEM "',sysid,'">')}else{var sub=node.internalSubset;if(sub){buf.push(" [",sub,"]")}buf.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return buf.push("<?",node.target," ",node.data,"?>");case ENTITY_REFERENCE_NODE:return buf.push("&",node.nodeName,";");default:buf.push("??",node.nodeName)}}function importNode(doc,node,deep){var node2;switch(node.nodeType){case ELEMENT_NODE:node2=node.cloneNode(false);node2.ownerDocument=doc;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:deep=true;break}if(!node2){node2=node.cloneNode(false)}node2.ownerDocument=doc;node2.parentNode=null;if(deep){var child=node.firstChild;while(child){node2.appendChild(importNode(doc,child,deep));child=child.nextSibling}}return node2}function cloneNode(doc,node,deep){var node2=new node.constructor;for(var n in node){var v=node[n];if(typeof v!="object"){if(v!=node2[n]){node2[n]=v}}}if(node.childNodes){node2.childNodes=new NodeList}node2.ownerDocument=doc;switch(node2.nodeType){case ELEMENT_NODE:var attrs=node.attributes;var attrs2=node2.attributes=new NamedNodeMap;var len=attrs.length;attrs2._ownerElement=node2;for(var i=0;i<len;i++){node2.setAttributeNode(cloneNode(doc,attrs.item(i),true))}break;case ATTRIBUTE_NODE:deep=true}if(deep){var child=node.firstChild;while(child){node2.appendChild(cloneNode(doc,child,deep));child=child.nextSibling}}return node2}function __set__(object,key,value){object[key]=value}try{if(Object.defineProperty){Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){_updateLiveList(this);return this.$$length}});Object.defineProperty(Node.prototype,"textContent",{get:function(){return getTextContent(this)},set:function(data){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:while(this.firstChild){this.removeChild(this.firstChild)}if(data||String(data)){this.appendChild(this.ownerDocument.createTextNode(data))}break;default:this.data=data;this.value=data;this.nodeValue=data}}});function getTextContent(node){switch(node.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var buf=[];node=node.firstChild;while(node){if(node.nodeType!==7&&node.nodeType!==8){buf.push(getTextContent(node))}node=node.nextSibling}return buf.join("");default:return node.nodeValue}}__set__=function(object,key,value){object["$$"+key]=value}}}catch(e){}exports.DOMImplementation=DOMImplementation;exports.XMLSerializer=XMLSerializer},{}],25:[function(require,module,exports){var nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;var nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");var tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$");var S_TAG=0;var S_ATTR=1;var S_ATTR_SPACE=2;var S_EQ=3;var S_ATTR_NOQUOT_VALUE=4;var S_ATTR_END=5;var S_TAG_SPACE=6;var S_TAG_CLOSE=7;function XMLReader(){}XMLReader.prototype={parse:function(source,defaultNSMap,entityMap){var domBuilder=this.domBuilder;domBuilder.startDocument();_copy(defaultNSMap,defaultNSMap={});parse(source,defaultNSMap,entityMap,domBuilder,this.errorHandler);domBuilder.endDocument()}};function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){function fixedFromCharCode(code){if(code>65535){code-=65536;var surrogate1=55296+(code>>10),surrogate2=56320+(code&1023);return String.fromCharCode(surrogate1,surrogate2)}else{return String.fromCharCode(code)}}function entityReplacer(a){var k=a.slice(1,-1);if(k in entityMap){return entityMap[k]}else if(k.charAt(0)==="#"){return fixedFromCharCode(parseInt(k.substr(1).replace("x","0x")))}else{errorHandler.error("entity not found:"+a);return a}}function appendText(end){if(end>start){var xt=source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);locator&&position(start);domBuilder.characters(xt,0,end-start);start=end}}function position(p,m){while(p>=lineEnd&&(m=linePattern.exec(source))){lineStart=m.index;lineEnd=lineStart+m[0].length;locator.lineNumber++}locator.columnNumber=p-lineStart+1}var lineStart=0;var lineEnd=0;var linePattern=/.*(?:\r\n?|\n)|.*$/g;var locator=domBuilder.locator;var parseStack=[{currentNSMap:defaultNSMapCopy}];var closeMap={};var start=0;while(true){try{var tagStart=source.indexOf("<",start);if(tagStart<0){if(!source.substr(start).match(/^\s*$/)){var doc=domBuilder.doc;var text=doc.createTextNode(source.substr(start));doc.appendChild(text);domBuilder.currentElement=text}return}if(tagStart>start){appendText(tagStart)}switch(source.charAt(tagStart+1)){case"/":var end=source.indexOf(">",tagStart+3);var tagName=source.substring(tagStart+2,end);var config=parseStack.pop();if(end<0){tagName=source.substring(tagStart+2).replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" is not complete:"+config.tagName);end=tagStart+1+tagName.length}else if(tagName.match(/\s</)){tagName=tagName.replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" maybe not complete");end=tagStart+1+tagName.length}var localNSMap=config.localNSMap;var endMatch=config.tagName==tagName;var endIgnoreCaseMach=endMatch||config.tagName&&config.tagName.toLowerCase()==tagName.toLowerCase();if(endIgnoreCaseMach){domBuilder.endElement(config.uri,config.localName,tagName);if(localNSMap){for(var prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}if(!endMatch){errorHandler.fatalError("end tag name: "+tagName+" is not match the current start tagName:"+config.tagName)}}else{parseStack.push(config)}end++;break;case"?":locator&&position(tagStart);end=parseInstruction(source,tagStart,domBuilder);break;case"!":locator&&position(tagStart);end=parseDCC(source,tagStart,domBuilder,errorHandler);break;default:locator&&position(tagStart);var el=new ElementAttributes;var currentNSMap=parseStack[parseStack.length-1].currentNSMap;var end=parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);var len=el.length;if(!el.closed&&fixSelfClosed(source,end,el.tagName,closeMap)){el.closed=true;if(!entityMap.nbsp){errorHandler.warning("unclosed xml attribute")}}if(locator&&len){var locator2=copyLocator(locator,{});for(var i=0;i<len;i++){var a=el[i];position(a.offset);a.locator=copyLocator(locator,{})}domBuilder.locator=locator2;if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}domBuilder.locator=locator}else{if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}}if(el.uri==="http://www.w3.org/1999/xhtml"&&!el.closed){end=parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)}else{end++}}}catch(e){errorHandler.error("element parse error: "+e);end=-1}if(end>start){start=end}else{appendText(Math.max(tagStart,start)+1)}}}function copyLocator(f,t){t.lineNumber=f.lineNumber;t.columnNumber=f.columnNumber;return t}function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){var attrName;var value;var p=++start;var s=S_TAG;while(true){var c=source.charAt(p);switch(c){case"=":if(s===S_ATTR){attrName=source.slice(start,p);s=S_EQ}else if(s===S_ATTR_SPACE){s=S_EQ}else{throw new Error("attribute equal must after attrName")}break;case"'":case'"':if(s===S_EQ||s===S_ATTR){if(s===S_ATTR){errorHandler.warning('attribute value must after "="');attrName=source.slice(start,p)}start=p+1;p=source.indexOf(c,start);if(p>0){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start-1);s=S_ATTR_END}else{throw new Error("attribute value no end '"+c+"' match")}}else if(s==S_ATTR_NOQUOT_VALUE){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start);errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+")!!");start=p+1;s=S_ATTR_END}else{throw new Error('attribute value must after "="')}break;case"/":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:s=S_TAG_CLOSE;el.closed=true;case S_ATTR_NOQUOT_VALUE:case S_ATTR:case S_ATTR_SPACE:break;default:throw new Error("attribute invalid close char('/')")}break;case"":errorHandler.error("unexpected end of input");if(s==S_TAG){el.setTagName(source.slice(start,p))}return p;case">":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:value=source.slice(start,p);if(value.slice(-1)==="/"){el.closed=true;value=value.slice(0,-1)}case S_ATTR_SPACE:if(s===S_ATTR_SPACE){value=attrName}if(s==S_ATTR_NOQUOT_VALUE){errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)}else{if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!value.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')}el.add(value,value,start)}break;case S_EQ:throw new Error("attribute value missed!!")}return p;case"":c=" ";default:if(c<=" "){switch(s){case S_TAG:el.setTagName(source.slice(start,p));s=S_TAG_SPACE;break;case S_ATTR:attrName=source.slice(start,p);s=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value,start);case S_ATTR_END:s=S_TAG_SPACE;break}}else{switch(s){case S_ATTR_SPACE:var tagName=el.tagName;if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!attrName.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')}el.add(attrName,attrName,start);start=p;s=S_ATTR;break;case S_ATTR_END:errorHandler.warning('attribute space is required"'+attrName+'"!!');case S_TAG_SPACE:s=S_ATTR;start=p;break;case S_EQ:s=S_ATTR_NOQUOT_VALUE;start=p;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}}p++}}function appendElement(el,domBuilder,currentNSMap){var tagName=el.tagName;var localNSMap=null;var i=el.length;while(i--){var a=el[i];var qName=a.qName;var value=a.value;var nsp=qName.indexOf(":");if(nsp>0){var prefix=a.prefix=qName.slice(0,nsp);var localName=qName.slice(nsp+1);var nsPrefix=prefix==="xmlns"&&localName}else{localName=qName;prefix=null;nsPrefix=qName==="xmlns"&&""}a.localName=localName;if(nsPrefix!==false){if(localNSMap==null){localNSMap={};_copy(currentNSMap,currentNSMap={})}currentNSMap[nsPrefix]=localNSMap[nsPrefix]=value;a.uri="http://www.w3.org/2000/xmlns/";domBuilder.startPrefixMapping(nsPrefix,value)}}var i=el.length;while(i--){a=el[i];var prefix=a.prefix;if(prefix){if(prefix==="xml"){a.uri="http://www.w3.org/XML/1998/namespace"}if(prefix!=="xmlns"){a.uri=currentNSMap[prefix||""]}}}var nsp=tagName.indexOf(":");if(nsp>0){prefix=el.prefix=tagName.slice(0,nsp);localName=el.localName=tagName.slice(nsp+1)}else{prefix=null;localName=el.localName=tagName}var ns=el.uri=currentNSMap[prefix||""];domBuilder.startElement(ns,localName,tagName,el);if(el.closed){domBuilder.endElement(ns,localName,tagName);if(localNSMap){for(prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}}else{el.currentNSMap=currentNSMap;el.localNSMap=localNSMap;return true}}function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){if(/^(?:script|textarea)$/i.test(tagName)){var elEndStart=source.indexOf("</"+tagName+">",elStartEnd);var text=source.substring(elStartEnd+1,elEndStart);if(/[&<]/.test(text)){if(/^script$/i.test(tagName)){domBuilder.characters(text,0,text.length);return elEndStart}text=text.replace(/&#?\w+;/g,entityReplacer);domBuilder.characters(text,0,text.length);return elEndStart}}return elStartEnd+1}function fixSelfClosed(source,elStartEnd,tagName,closeMap){var pos=closeMap[tagName];if(pos==null){pos=source.lastIndexOf("</"+tagName+">");if(pos<elStartEnd){pos=source.lastIndexOf("</"+tagName)}closeMap[tagName]=pos}return pos<elStartEnd}function _copy(source,target){for(var n in source){target[n]=source[n]}}function parseDCC(source,start,domBuilder,errorHandler){var next=source.charAt(start+2);switch(next){case"-":if(source.charAt(start+3)==="-"){var end=source.indexOf("-->",start+4);if(end>start){domBuilder.comment(source,start+4,end-start-4);return end+3}else{errorHandler.error("Unclosed comment");return-1}}else{return-1}default:if(source.substr(start+3,6)=="CDATA["){var end=source.indexOf("]]>",start+9);domBuilder.startCDATA();domBuilder.characters(source,start+9,end-start-9);domBuilder.endCDATA();return end+3}var matchs=split(source,start);var len=matchs.length;if(len>1&&/!doctype/i.test(matchs[0][0])){var name=matchs[1][0];var pubid=len>3&&/^public$/i.test(matchs[2][0])&&matchs[3][0];var sysid=len>4&&matchs[4][0];var lastMatch=matchs[len-1];domBuilder.startDTD(name,pubid&&pubid.replace(/^(['"])(.*?)\1$/,"$2"),sysid&&sysid.replace(/^(['"])(.*?)\1$/,"$2"));domBuilder.endDTD();return lastMatch.index+lastMatch[0].length}}return-1}function parseInstruction(source,start,domBuilder){var end=source.indexOf("?>",start);if(end){var match=source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(match){var len=match[0].length;domBuilder.processingInstruction(match[1],match[2]);return end+2}else{return-1}}return-1}function ElementAttributes(source){}ElementAttributes.prototype={setTagName:function(tagName){if(!tagNamePattern.test(tagName)){throw new Error("invalid tagName:"+tagName)}this.tagName=tagName},add:function(qName,value,offset){if(!tagNamePattern.test(qName)){throw new Error("invalid attribute:"+qName)}this[this.length++]={qName:qName,value:value,offset:offset}},length:0,getLocalName:function(i){return this[i].localName},getLocator:function(i){return this[i].locator},getQName:function(i){return this[i].qName},getURI:function(i){return this[i].uri},getValue:function(i){return this[i].value}};function _set_proto_(thiz,parent){thiz.__proto__=parent;return thiz}if(!(_set_proto_({},_set_proto_.prototype)instanceof _set_proto_)){_set_proto_=function(thiz,parent){function p(){}p.prototype=parent;p=new p;for(parent in thiz){p[parent]=thiz[parent]}return p}}function split(source,start){var match;var buf=[];var reg=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;reg.lastIndex=start;reg.exec(source);while(match=reg.exec(source)){buf.push(match);if(match[1])return buf}}exports.XMLReader=XMLReader},{}],"/src/js/index.js":[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var templates=require("./templates");var DocUtils=require("docxtemplater").DocUtils;var DOMParser=require("xmldom").DOMParser;function isNaN(number){return!(number===number)}var ImgManager=require("./imgManager");var moduleName="open-xml-templating/docxtemplater-image-module";function getInnerDocx(_ref){var part=_ref.part;return part}function getInnerPptx(_ref2){var part=_ref2.part,left=_ref2.left,right=_ref2.right,postparsed=_ref2.postparsed;var xmlString=postparsed.slice(left+1,right).reduce(function(concat,item){return concat+item.value},"");var xmlDoc=(new DOMParser).parseFromString("<xml>"+xmlString+"</xml>");var offset=xmlDoc.getElementsByTagName("a:off");var ext=xmlDoc.getElementsByTagName("a:ext");part.ext={cx:parseInt(ext[0].getAttribute("cx"),10),cy:parseInt(ext[0].getAttribute("cy"),10)};part.offset={x:parseInt(offset[0].getAttribute("x"),10),y:parseInt(offset[0].getAttribute("y"),10)};return part}var ImageModule=function(){function ImageModule(options){_classCallCheck(this,ImageModule);this.name="ImageModule";this.options=options||{};this.imgManagers={};if(this.options.centered==null){this.options.centered=false}if(this.options.getImage==null){throw new Error("You should pass getImage")}if(this.options.getSize==null){throw new Error("You should pass getSize")}this.imageNumber=1}_createClass(ImageModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){
var relsFiles=docxtemplater.zip.file(/\.xml\.rels/).concat(docxtemplater.zip.file(/\[Content_Types\].xml/)).map(function(file){return file.name});this.fileTypeConfig=docxtemplater.fileTypeConfig;this.fileType=docxtemplater.fileType;this.zip=docxtemplater.zip;options.xmlFileNames=options.xmlFileNames.concat(relsFiles);return options}},{key:"set",value:function set(options){if(options.zip){this.zip=options.zip}if(options.xmlDocuments){this.xmlDocuments=options.xmlDocuments}}},{key:"parse",value:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent.substring(0,2)==="%%"){return{type:type,value:placeHolderContent.substr(2),module:module,centered:true}}if(placeHolderContent.substring(0,1)==="%"){return{type:type,value:placeHolderContent.substr(1),module:module,centered:false}}return null}},{key:"postparse",value:function postparse(parsed){var expandTo=void 0;var getInner=void 0;if(this.fileType==="pptx"){expandTo="p:sp";getInner=getInnerPptx}else{expandTo=this.options.centered?"w:p":"w:t";getInner=getInnerDocx}return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:expandTo})}},{key:"render",value:function render(part,options){this.imgManagers[options.filePath]=this.imgManagers[options.filePath]||new ImgManager(this.zip,options.filePath,this.xmlDocuments,this.fileType);var imgManager=this.imgManagers[options.filePath];if(!part.type==="placeholder"||part.module!==moduleName){return null}try{var tagValue=options.scopeManager.getValue(part.value);if(!tagValue){throw new Error("tagValue is empty")}var imgBuffer=this.options.getImage(tagValue,part.value);var rId=imgManager.addImageRels(this.getNextImageName(),imgBuffer);var sizePixel=this.options.getSize(imgBuffer,tagValue,part.value);return this.getRenderedPart(part,rId,sizePixel)}catch(e){return{value:this.fileTypeConfig.tagTextXml}}}},{key:"getRenderedPart",value:function getRenderedPart(part,rId,sizePixel){if(isNaN(rId)){throw new Error("rId is NaN, aborting")}var size=[DocUtils.convertPixelsToEmus(sizePixel[0]),DocUtils.convertPixelsToEmus(sizePixel[1])];var centered=this.options.centered||part.centered;var newText=void 0;if(this.fileType==="pptx"){newText=this.getRenderedPartPptx(part,rId,size,centered)}else{newText=this.getRenderedPartDocx(rId,size,centered)}return{value:newText}}},{key:"getRenderedPartPptx",value:function getRenderedPartPptx(part,rId,size,centered){var offset={x:part.offset.x,y:part.offset.y};var cellCX=part.ext.cx;var cellCY=part.ext.cy;var imgW=size[0];var imgH=size[1];if(centered){offset.x+=cellCX/2-imgW/2;offset.y+=cellCY/2-imgH/2}return templates.getPptxImageXml(rId,[imgW,imgH],offset)}},{key:"getRenderedPartDocx",value:function getRenderedPartDocx(rId,size,centered){return centered?templates.getImageXmlCentered(rId,size):templates.getImageXml(rId,size)}},{key:"getNextImageName",value:function getNextImageName(){var name="image_generated_"+this.imageNumber+".png";this.imageNumber++;return name}}]);return ImageModule}();module.exports=ImageModule},{"./imgManager":2,"./templates":3,docxtemplater:5,xmldom:23}]},{},[])("/src/js/index.js")});

/***/ }),

/***/ 49590:
/*!*****************************************!*\
  !*** ./js/docxtemplater.v3.0.12.min.js ***!
  \*****************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}var memoize=require("./memoize");var DOMParser=require("xmldom").DOMParser;var XMLSerializer=require("xmldom").XMLSerializer;var Errors=require("./errors");var DocUtils={};function parser(tag){return _defineProperty({},"get",function get(scope){if(tag==="."){return scope}return scope[tag]})}DocUtils.defaults={nullGetter:function nullGetter(part){if(!part.module){return"undefined"}if(part.module==="rawxml"){return""}return""},parser:memoize(parser),delimiters:{start:"{",end:"}"}};DocUtils.mergeObjects=function(){var resObj={};var obj=void 0,keys=void 0;for(var i=0;i<arguments.length;i+=1){obj=arguments[i];keys=Object.keys(obj);for(var j=0;j<keys.length;j+=1){resObj[keys[j]]=obj[keys[j]]}}return resObj};DocUtils.xml2str=function(xmlNode){var a=new XMLSerializer;return a.serializeToString(xmlNode)};DocUtils.decodeUtf8=function(s){try{if(s===undefined){return undefined}return decodeURIComponent(escape(DocUtils.convertSpaces(s)))}catch(e){var err=new Error("End");err.properties.data=s;err.properties.explanation="Could not decode string to UTF8";throw err}};DocUtils.encodeUtf8=function(s){return unescape(encodeURIComponent(s))};DocUtils.str2xml=function(str,errorHandler){var parser=new DOMParser({errorHandler:errorHandler});return parser.parseFromString(str,"text/xml")};DocUtils.charMap={"&":"&amp;","'":"&apos;","<":"&lt;",">":"&gt;"};var regexStripRegexp=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;DocUtils.escapeRegExp=function(str){return str.replace(regexStripRegexp,"\\$&")};DocUtils.charMapRegexes=Object.keys(DocUtils.charMap).map(function(endChar){var startChar=DocUtils.charMap[endChar];return{rstart:new RegExp(DocUtils.escapeRegExp(startChar),"g"),rend:new RegExp(DocUtils.escapeRegExp(endChar),"g"),start:startChar,end:endChar}});DocUtils.wordToUtf8=function(string){var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rstart,r.end)}return string};DocUtils.utf8ToWord=function(string){if(typeof string!=="string"){string=string.toString()}var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rend,r.start)}return string};DocUtils.cloneDeep=function(obj){return JSON.parse(JSON.stringify(obj))};DocUtils.concatArrays=function(arrays){return arrays.reduce(function(result,array){Array.prototype.push.apply(result,array);return result},[])};var spaceRegexp=new RegExp(String.fromCharCode(160),"g");DocUtils.convertSpaces=function(s){return s.replace(spaceRegexp," ")};DocUtils.pregMatchAll=function(regex,content){var matchArray=[];var match=void 0;while((match=regex.exec(content))!=null){matchArray.push({array:match,offset:match.index})}return matchArray};DocUtils.sizeOfObject=function(obj){return Object.keys(obj).length};function throwXmlTagNotFound(options){var err=new Errors.XTTemplateError("No tag '"+options.element+"' was found at the "+options.position);err.properties={id:"no_xml_tag_found_at_"+options.position,explanation:"No tag '"+options.element+"' was found at the "+options.position,parsed:options.parsed,index:options.index,element:options.element};throw err}DocUtils.getRight=function(parsed,element,index){for(var i=index,l=parsed.length;i<l;i++){var part=parsed[i];if(part.value==="</"+element+">"){return i}}throwXmlTagNotFound({position:"right",element:element,parsed:parsed,index:index})};DocUtils.getLeft=function(parsed,element,index){for(var i=index;i>=0;i--){var part=parsed[i];if(part.value.indexOf("<"+element)===0&&[">"," "].indexOf(part.value[element.length+1])!==-1){return i}}throwXmlTagNotFound({position:"left",element:element,parsed:parsed,index:index})};module.exports=DocUtils},{"./errors":2,"./memoize":5,xmldom:19}],2:[function(require,module,exports){"use strict";function XTError(message){this.name="GenericError";this.message=message;this.stack=new Error(message).stack}XTError.prototype=Error.prototype;function XTTemplateError(message){this.name="TemplateError";this.message=message;this.stack=new Error(message).stack}XTTemplateError.prototype=new XTError;function XTScopeParserError(message){this.name="ScopeParserError";this.message=message;this.stack=new Error(message).stack}XTScopeParserError.prototype=new XTError;function XTInternalError(message){this.name="InternalError";this.properties={explanation:"InternalError"};this.message=message;this.stack=new Error(message).stack}XTInternalError.prototype=new XTError;module.exports={XTError:XTError,XTTemplateError:XTTemplateError,XTInternalError:XTInternalError,XTScopeParserError:XTScopeParserError}},{}],3:[function(require,module,exports){"use strict";var loopModule=require("./modules/loop");var spacePreserveModule=require("./modules/space-preserve");var rawXmlModule=require("./modules/rawxml");var expandPairTrait=require("./modules/expand-pair-trait");var render=require("./modules/render");var PptXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["ppt/presentation.xml"])},textPath:"ppt/slides/slide1.xml",tagsXmlTextArray:["a:t","m:t"],tagsXmlLexedArray:["p:sp","a:tc","a:tr","a:table","a:p","a:r"],tagRawXml:"p:sp",tagTextXml:"a:t",baseModules:[render,expandPairTrait,rawXmlModule,loopModule]};var DocXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/word\/(header|footer)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["word/document.xml"])},textPath:"word/document.xml",tagsXmlTextArray:["w:t","m:t"],tagsXmlLexedArray:["w:tc","w:tr","w:table","w:p","w:r"],tagRawXml:"w:p",tagTextXml:"w:t",baseModules:[render,spacePreserveModule,expandPairTrait,rawXmlModule,loopModule]};module.exports={docx:DocXFileTypeConfig,pptx:PptXFileTypeConfig}},{"./modules/expand-pair-trait":8,"./modules/loop":9,"./modules/rawxml":10,"./modules/render":11,"./modules/space-preserve":12}],4:[function(require,module,exports){"use strict";var Errors=require("./errors");var DocUtils=require("./doc-utils");function inRange(range,match){return range[0]<=match.offset&&match.offset<range[1]}function updateInTextTag(part,inTextTag){if(part.type==="tag"&&part.position==="start"&&part.text){if(inTextTag){throw new Error("Malformed xml : Already in text tag")}return true}if(part.type==="tag"&&part.position==="end"&&part.text){if(!inTextTag){throw new Error("Malformed xml : Already not in text tag")}return false}return inTextTag}function offsetSort(a,b){return a.offset-b.offset}function getTag(tag){var start=1;if(tag[1]==="/"){start=2}var index=tag.indexOf(" ");var end=index===-1?tag.length-1:index;return{tag:tag.slice(start,end),position:start===1?"start":"end"}}function tagMatcher(content,textMatchArray,othersMatchArray){var cursor=0;var contentLength=content.length;var allMatches=DocUtils.concatArrays([textMatchArray.map(function(tag){return{tag:tag,text:true}}),othersMatchArray.map(function(tag){return{tag:tag,text:false}})]).reduce(function(allMatches,t){allMatches[t.tag]=t.text;return allMatches},{});var totalMatches=[];while(cursor<contentLength){cursor=content.indexOf("<",cursor);if(cursor===-1){break}var offset=cursor;cursor=content.indexOf(">",cursor);var tagText=content.slice(offset,cursor+1);var _getTag=getTag(tagText),tag=_getTag.tag,position=_getTag.position;var text=allMatches[tag];if(text==null){continue}totalMatches.push({type:"tag",position:position,text:text,offset:offset,value:tagText})}return totalMatches}function throwUnopenedTagException(options){var err=new Errors.XTTemplateError("Unopened tag");err.properties={xtag:options.xtag.split(" ")[0],id:"unopened_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function throwUnclosedTagException(options){var err=new Errors.XTTemplateError("Unclosed tag");err.properties={xtag:options.xtag.split(" ")[0].substr(1),id:"unclosed_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function assertDelimiterOrdered(delimiterMatches,fullText){var inDelimiter=false;var lastDelimiterMatch={offset:0};var xtag=void 0;delimiterMatches.forEach(function(delimiterMatch){xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(delimiterMatch.position==="start"&&inDelimiter||delimiterMatch.position==="end"&&!inDelimiter){if(delimiterMatch.position==="start"){throwUnclosedTagException({xtag:xtag})}else{throwUnopenedTagException({xtag:xtag})}}inDelimiter=!inDelimiter;lastDelimiterMatch=delimiterMatch});var delimiterMatch={offset:fullText.length};xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(inDelimiter){throwUnclosedTagException({xtag:xtag})}}function getAllIndexes(arr,val,position){var indexes=[];var offset=-1;do{offset=arr.indexOf(val,offset+1);if(offset!==-1){indexes.push({offset:offset,position:position})}}while(offset!==-1);return indexes}function Reader(innerContentParts){var _this=this;this.innerContentParts=innerContentParts;this.full="";this.parseDelimiters=function(delimiters){_this.full=_this.innerContentParts.join("");var offset=0;_this.ranges=_this.innerContentParts.map(function(part){offset+=part.length;return offset-part.length});var delimiterMatches=DocUtils.concatArrays([getAllIndexes(_this.full,delimiters.start,"start"),getAllIndexes(_this.full,delimiters.end,"end")]).sort(offsetSort);assertDelimiterOrdered(delimiterMatches,_this.full);var delimiterLength={start:delimiters.start.length,end:delimiters.end.length};var cutNext=0;var delimiterIndex=0;_this.parsed=_this.ranges.map(function(offset,i){var range=[offset,offset+this.innerContentParts[i].length];var partContent=this.innerContentParts[i];var delimitersInOffset=[];while(delimiterIndex<delimiterMatches.length&&inRange(range,delimiterMatches[delimiterIndex])){delimitersInOffset.push(delimiterMatches[delimiterIndex]);delimiterIndex++}var parts=[];var cursor=0;if(cutNext>0){cursor=cutNext;cutNext=0}delimitersInOffset.forEach(function(delimiterInOffset){var value=partContent.substr(cursor,delimiterInOffset.offset-offset-cursor);if(value.length>0){parts.push({type:"content",value:value})}parts.push({type:"delimiter",position:delimiterInOffset.position});cursor=delimiterInOffset.offset-offset+delimiterLength[delimiterInOffset.position]});cutNext=cursor-partContent.length;var value=partContent.substr(cursor);if(value.length>0){parts.push({type:"content",value:value})}return parts},_this)}}module.exports={parse:function parse(xmlparsed,delimiters){var inTextTag=false;var innerContentParts=[];xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(inTextTag&&part.type==="content"){innerContentParts.push(part.value)}});var reader=new Reader(innerContentParts);reader.parseDelimiters(delimiters);var newArray=[];var index=0;xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(part.type==="content"){part.position=inTextTag?"insidetag":"outsidetag"}if(inTextTag&&part.type==="content"){Array.prototype.push.apply(newArray,reader.parsed[index].map(function(p){if(p.type==="content"){p.position="insidetag"}return p}));index++}else{newArray.push(part)}});return newArray},xmlparse:function xmlparse(content,xmltags){var matches=tagMatcher(content,xmltags.text,xmltags.other);var cursor=0;var parsed=matches.reduce(function(parsed,match){var value=content.substr(cursor,match.offset-cursor);if(value.length>0){parsed.push({type:"content",value:value})}cursor=match.offset+match.value.length;delete match.offset;if(match.value.length>0){parsed.push(match)}return parsed},[]);var value=content.substr(cursor);if(value.length>0){parsed.push({type:"content",value:value})}return parsed}}},{"./doc-utils":1,"./errors":2}],5:[function(require,module,exports){"use strict";function memoize(func){var stringifyJson=JSON.stringify,cache={};function cachedfun(){var hash=stringifyJson(arguments);return hash in cache?cache[hash]:cache[hash]=func.apply(this,arguments)}return cachedfun}module.exports=memoize},{}],6:[function(require,module,exports){"use strict";function getMinFromArrays(arrays,state){var minIndex=-1;for(var i=0,l=arrays.length;i<l;i++){if(state[i]>=arrays[i].length){continue}if(minIndex===-1||arrays[i][state[i]].offset<arrays[minIndex][state[minIndex]].offset){minIndex=i}}if(minIndex===-1){throw new Error("minIndex negative")}return minIndex}module.exports=function(arrays){var totalLength=arrays.reduce(function(sum,array){return sum+array.length},0);arrays=arrays.filter(function(array){return array.length>0});var resultArray=new Array(totalLength);var state=arrays.map(function(){return 0});var i=0;while(i<=totalLength-1){var arrayIndex=getMinFromArrays(arrays,state);resultArray[i]=arrays[arrayIndex][state[arrayIndex]];state[arrayIndex]++;i++}return resultArray}},{}],7:[function(require,module,exports){"use strict";function emptyFun(){}function identity(i){return i}module.exports=function(module){var defaults={set:emptyFun,parse:emptyFun,render:emptyFun,getTraits:emptyFun,optionsTransformer:identity,getRenderedMap:identity,postparse:identity};if(Object.keys(defaults).every(function(key){return!module[key]})){throw new Error("This module cannot be wrapped, because it doesn't define any of the necessary functions")}Object.keys(defaults).forEach(function(key){module[key]=module[key]||defaults[key]});return module}},{}],8:[function(require,module,exports){"use strict";var traitName="expandPair";var mergeSort=require("../mergesort");var DocUtils=require("../doc-utils");var wrapper=require("../module-wrapper");var _require=require("../traits"),getExpandToDefault=_require.getExpandToDefault;var Errors=require("../errors");function throwUnmatchedLoopException(options){var location=options.location;var t=location==="start"?"unclosed":"unopened";var T=location==="start"?"Unclosed":"Unopened";var err=new Errors.XTTemplateError(T+" loop");var tag=options.part.value;err.properties={id:t+"_loop",explanation:"The loop with tag "+tag+" is "+t,xtag:tag};throw err}function throwClosingTagNotMatchOpeningTag(options){var tags=options.tags;var err=new Errors.XTTemplateError("Closing tag does not match opening tag");err.properties={id:"closing_tag_does_not_match_opening_tag",explanation:'The tag "'+tags[0].value+'" is closed by the tag "'+tags[1].value+'"',openingtag:tags[0].value,closingtag:tags[1].value};throw err}function getOpenCountChange(part){switch(part.location){case"start":return 1;case"end":return-1;default:throw new Error("Location should be one of 'start' or 'end' (given : "+part.location+")")}}function getPairs(traits){if(traits.length===0){return[]}var countOpen=1;var firstTrait=traits[0];for(var i=1;i<traits.length;i++){var currentTrait=traits[i];countOpen+=getOpenCountChange(currentTrait.part);if(countOpen===0){if(currentTrait.part.value!==firstTrait.part.value&&currentTrait.part.value!==""){throwClosingTagNotMatchOpeningTag({tags:[firstTrait.part,currentTrait.part]})}var outer=getPairs(traits.slice(i+1));return[[firstTrait,currentTrait]].concat(outer)}}var part=firstTrait.part;throwUnmatchedLoopException({part:part,location:part.location})}var expandPairTrait={name:"ExpandPairTrait",postparse:function postparse(parsed,_ref){var getTraits=_ref.getTraits,_postparse=_ref.postparse;var traits=getTraits(traitName,parsed);traits=traits.map(function(trait){return trait||[]});traits=mergeSort(traits);var pairs=getPairs(traits);var expandedPairs=pairs.map(function(pair){var expandTo=pair[0].part.expandTo;if(expandTo==="auto"){expandTo=getExpandToDefault(parsed.slice(pair[0].offset,pair[1].offset))}if(!expandTo){return[pair[0].offset,pair[1].offset]}var left=DocUtils.getLeft(parsed,expandTo,pair[0].offset);var right=DocUtils.getRight(parsed,expandTo,pair[1].offset);return[left,right]});var currentPairIndex=0;var innerParts=void 0;return parsed.reduce(function(newParsed,part,i){var inPair=currentPairIndex<pairs.length&&expandedPairs[currentPairIndex][0]<=i;var pair=pairs[currentPairIndex];var expandedPair=expandedPairs[currentPairIndex];if(!inPair){newParsed.push(part);return newParsed}if(expandedPair[0]===i){innerParts=[]}if(pair[0].offset!==i&&pair[1].offset!==i){innerParts.push(part)}if(expandedPair[1]===i){var basePart=parsed[pair[0].offset];delete basePart.location;delete basePart.expandTo;basePart.subparsed=_postparse(innerParts);newParsed.push(basePart);currentPairIndex++}return newParsed},[])}};module.exports=function(){return wrapper(expandPairTrait)}},{"../doc-utils":1,"../errors":2,"../mergesort":6,"../module-wrapper":7,"../traits":16}],9:[function(require,module,exports){"use strict";var DocUtils=require("../doc-utils");var dashInnerRegex=/^-([^\s]+)\s(.+)$/;var wrapper=require("../module-wrapper");var moduleName="loop";var loopModule={name:"LoopModule",parse:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent[0]==="#"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:false}}if(placeHolderContent[0]==="^"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:true}}if(placeHolderContent[0]==="/"){return{type:type,value:placeHolderContent.substr(1),module:module,location:"end"}}if(placeHolderContent[0]==="-"){var value=placeHolderContent.replace(dashInnerRegex,"$2");var expandTo=placeHolderContent.replace(dashInnerRegex,"$1");return{type:type,value:value,expandTo:expandTo,module:module,location:"start",inverted:false}}return null},getTraits:function getTraits(traitName,parsed){if(traitName!=="expandPair"){return}return parsed.reduce(function(tags,part,offset){if(part.type==="placeholder"&&part.module===moduleName){tags.push({part:part,offset:offset})}return tags},[])},render:function render(part,options){if(!part.type==="placeholder"||part.module!==moduleName){return null}var totalValue=[];function loopOver(scope){var scopeManager=options.scopeManager.createSubScopeManager(scope,part.value);totalValue.push(options.render(DocUtils.mergeObjects({},options,{compiled:part.subparsed,tags:{},scopeManager:scopeManager})))}options.scopeManager.loopOver(part.value,loopOver,part.inverted);return{value:totalValue.join("")}}};module.exports=function(){return wrapper(loopModule)}},{"../doc-utils":1,"../module-wrapper":7}],10:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("../doc-utils");var Errors=require("../errors");var moduleName="rawxml";var wrapper=require("../module-wrapper");function throwRawTagShouldBeOnlyTextInParagraph(options){var err=new Errors.XTTemplateError("Raw tag should be the only text in paragraph");var tag=options.part.value;err.properties={id:"raw_xml_tag_should_be_only_text_in_paragraph",explanation:"The tag "+tag,xtag:options.part.value,paragraphParts:options.paragraphParts};throw err}function getInner(_ref){var part=_ref.part,left=_ref.left,right=_ref.right,postparsed=_ref.postparsed,index=_ref.index;var paragraphParts=postparsed.slice(left+1,right);paragraphParts.forEach(function(p,i){if(i===index-left-1){return}if(p.type==="placeholder"||p.type==="content"&&p.position==="insidetag"){throwRawTagShouldBeOnlyTextInParagraph({paragraphParts:paragraphParts,part:part})}});return part}var RawXmlModule=function(){function RawXmlModule(){_classCallCheck(this,RawXmlModule);this.name="RawXmlModule"}_createClass(RawXmlModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){this.fileTypeConfig=docxtemplater.fileTypeConfig;return options}},{key:"parse",value:function parse(placeHolderContent){var type="placeholder";if(placeHolderContent[0]!=="@"){return null}return{type:type,value:placeHolderContent.substr(1),module:moduleName}}},{key:"postparse",value:function postparse(parsed){return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:this.fileTypeConfig.tagRawXml})}},{key:"render",value:function render(part,options){if(part.module!==moduleName){return null}var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return{value:value}}}]);return RawXmlModule}();module.exports=function(){return wrapper(new RawXmlModule)}},{"../doc-utils":1,"../errors":2,"../module-wrapper":7}],11:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var wrapper=require("../module-wrapper");var Render=function(){function Render(){_classCallCheck(this,Render);this.name="Render"}_createClass(Render,[{key:"set",value:function set(obj){if(obj.compiled){this.compiled=obj.compiled}if(obj.data!=null){this.data=obj.data}}},{key:"getRenderedMap",value:function getRenderedMap(mapper){var _this=this;return Object.keys(this.compiled).reduce(function(mapper,from){mapper[from]={from:from,data:_this.data};return mapper},mapper)}}]);return Render}();module.exports=function(){return wrapper(new Render)}},{"../module-wrapper":7}],12:[function(require,module,exports){"use strict";var wrapper=require("../module-wrapper");var spacePreserve={name:"SpacePreserveModule",postparse:function postparse(parsed){var chunk=[];var inChunk=false;var result=parsed.reduce(function(parsed,part){if(part.type==="tag"&&part.position==="start"&&part.text&&part.value==="<w:t>"){inChunk=true}if(inChunk){if(part.type==="placeholder"&&!part.module){chunk[0].value='<w:t xml:space="preserve">'}chunk.push(part)}else{parsed.push(part)}if(part.type==="tag"&&part.position==="end"&&part.text&&part.value==="</w:t>"){Array.prototype.push.apply(parsed,chunk);inChunk=false;chunk=[]}return parsed},[]);Array.prototype.push.apply(result,chunk);return result}};module.exports=function(){return wrapper(spacePreserve)}},{"../module-wrapper":7}],13:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var parser={postparse:function postparse(parsed,modules){function getTraits(traitName,parsed){return modules.map(function(module){return module.getTraits(traitName,parsed)})}function postparse(parsed){return modules.reduce(function(parsed,module){return module.postparse(parsed,{postparse:postparse,getTraits:getTraits})},parsed)}return postparse(parsed)},parse:function parse(lexed,modules){function moduleParse(placeHolderContent,parsed){var moduleParsed=void 0;for(var i=0,l=modules.length;i<l;i++){var _module=modules[i];moduleParsed=_module.parse(placeHolderContent);if(moduleParsed){parsed.push(moduleParsed);return moduleParsed}}return null}var inPlaceHolder=false;var placeHolderContent=void 0;var tailParts=[];return lexed.reduce(function(parsed,token){if(token.type==="delimiter"){inPlaceHolder=token.position==="start";if(token.position==="end"){placeHolderContent=DocUtils.wordToUtf8(placeHolderContent);if(!moduleParse(placeHolderContent,parsed)){parsed.push({type:"placeholder",value:placeHolderContent})}Array.prototype.push.apply(parsed,tailParts);tailParts=[];return parsed}placeHolderContent="";return parsed}if(inPlaceHolder){if(token.type==="content"&&token.position==="insidetag"){placeHolderContent+=token.value}else{tailParts.push(token)}return parsed}parsed.push(token);return parsed},[])}};module.exports=parser},{"./doc-utils":1}],14:[function(require,module,exports){"use strict";var ScopeManager=require("./scope-manager");var DocUtils=require("./doc-utils");function moduleRender(part,options){var moduleRendered=void 0;for(var i=0,l=options.modules.length;i<l;i++){var _module=options.modules[i];moduleRendered=_module.render(part,options);if(moduleRendered){return moduleRendered}}return false}function render(options){options.render=render;options.modules=options.modules;if(!options.scopeManager){options.scopeManager=ScopeManager.createBaseScopeManager(options)}return options.compiled.map(function(part){var moduleRendered=moduleRender(part,options);if(moduleRendered){return moduleRendered.value}if(part.type==="placeholder"){var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return DocUtils.utf8ToWord(value)}if(part.type==="content"||part.type==="tag"){return part.value}throw new Error('Unimplemented tag type "'+part.type+'"')}).join("")}module.exports=render},{"./doc-utils":1,"./scope-manager":15}],15:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var Errors=require("./errors");var ScopeManager=function(){function ScopeManager(options){_classCallCheck(this,ScopeManager);this.scopePath=options.scopePath;this.scopeList=options.scopeList;this.parser=options.parser}_createClass(ScopeManager,[{key:"loopOver",value:function loopOver(tag,callback,inverted){inverted=inverted||false;return this.loopOverValue(this.getValue(tag),callback,inverted)}},{key:"functorIfInverted",value:function functorIfInverted(inverted,functor,value){if(inverted){functor(value)}}},{key:"isValueFalsy",value:function isValueFalsy(value,type){return value==null||!value||type==="[object Array]"&&value.length===0}},{key:"loopOverValue",value:function loopOverValue(value,functor,inverted){var type=Object.prototype.toString.call(value);var currentValue=this.scopeList[this.num];if(this.isValueFalsy(value,type)){return this.functorIfInverted(inverted,functor,currentValue)}if(type==="[object Array]"){for(var i=0,scope;i<value.length;i++){scope=value[i];this.functorIfInverted(!inverted,functor,scope)}return}if(type==="[object Object]"){return this.functorIfInverted(!inverted,functor,value)}if(value===true){return this.functorIfInverted(!inverted,functor,currentValue)}}},{key:"getValue",value:function getValue(tag,num){this.num=num==null?this.scopeList.length-1:num;var err=void 0;var parser=void 0;var result=void 0;var scope=this.scopeList[this.num];try{parser=this.parser(tag)}catch(error){err=new Errors.XTScopeParserError("Scope parser compilation failed");err.properties={id:"scopeparser_compilation_failed",tag:tag,explanation:"The scope parser for the tag "+tag+" failed to compile",rootError:error};throw err}try{result=parser.get(scope,{num:this.num,scopeList:this.scopeList})}catch(error){err=new Errors.XTScopeParserError("Scope parser execution failed");err.properties={id:"scopeparser_execution_failed",explanation:"The scope parser for the tag "+tag+" failed to execute",scope:scope,tag:tag,rootError:error};throw err}if(result==null&&this.num>0){return this.getValue(tag,this.num-1)}return result}},{key:"createSubScopeManager",value:function createSubScopeManager(scope,tag){var options={scopePath:this.scopePath.slice(0),scopeList:this.scopeList.slice(0)};options.parser=this.parser;options.scopeList=this.scopeList.concat(scope);options.scopePath=this.scopePath.concat(tag);return new ScopeManager(options)}}]);return ScopeManager}();ScopeManager.createBaseScopeManager=function(_ref){var parser=_ref.parser,tags=_ref.tags;var options={parser:parser,tags:tags};options.scopePath=[];options.scopeList=[tags];return new ScopeManager(options)};module.exports=ScopeManager},{"./errors":2}],16:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var Errors=require("./errors");function throwRawTagNotInParagraph(options){var err=new Errors.XTTemplateError("Raw tag not in paragraph");var tag=options.part.value;err.properties={id:"raw_tag_outerxml_invalid",explanation:'The tag "'+tag+'"',rootError:options.rootError,xtag:tag,postparsed:options.postparsed,expandTo:options.expandTo,index:options.index};throw err}function lastTagIsOpenTag(array,tag){if(array.length===0){return false}var lastTag=array[array.length-1];var innerLastTag=lastTag.tag.substr(1);var innerCurrentTag=tag.substr(2,tag.length-3);return innerLastTag.indexOf(innerCurrentTag)===0}function addTag(array,tag){array.push({tag:tag});return array}function getListXmlElements(parts){var tags=parts.filter(function(part){return part.type==="tag"}).map(function(part){return part.value});var result=[];for(var i=0,tag;i<tags.length;i++){tag=tags[i];if(tag[1]==="/"){if(lastTagIsOpenTag(result,tag)){result.pop()}else{result=addTag(result,tag)}}else if(tag[tag.length-1]!=="/"){result=addTag(result,tag)}}return result}function getExpandToDefault(parts){var xmlElements=getListXmlElements(parts);for(var i=0;i<xmlElements.length;i++){var xmlElement=xmlElements[i];if(xmlElement.tag.indexOf("<w:tc")===0){return"w:tr"}if(xmlElement.tag.indexOf("<a:tc")===0){return"a:tr"}}return false}function expandOne(part,postparsed,options){var expandTo=part.expandTo||options.expandTo;var index=postparsed.indexOf(part);if(!expandTo){return postparsed}var right=void 0,left=void 0;try{right=DocUtils.getRight(postparsed,expandTo,index);left=DocUtils.getLeft(postparsed,expandTo,index)}catch(rootError){if(rootError instanceof Errors.XTTemplateError){throwRawTagNotInParagraph({part:part,rootError:rootError,postparsed:postparsed,expandTo:expandTo,index:index})}throw rootError}var leftParts=postparsed.slice(left,index);var rightParts=postparsed.slice(index+1,right+1);var inner=options.getInner({index:index,part:part,leftParts:leftParts,rightParts:rightParts,left:left,right:right,postparsed:postparsed});if(!inner.length){inner.expanded=[leftParts,rightParts];inner=[inner]}return DocUtils.concatArrays([postparsed.slice(0,left),inner,postparsed.slice(right+1)])}function expandToOne(postparsed,options){var expandToElements=postparsed.reduce(function(elements,part){if(part.type==="placeholder"&&part.module===options.moduleName){elements.push(part)}return elements},[]);expandToElements.forEach(function(part){postparsed=expandOne(part,postparsed,options)});return postparsed}module.exports={expandToOne:expandToOne,getExpandToDefault:getExpandToDefault}},{"./doc-utils":1,"./errors":2}],17:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var memoize=require("./memoize");function handleRecursiveCase(res){function replacerUnshift(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.shift();var match=pn.array[0]+pn.array[1];pn.array.unshift(match);pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.first=true;res.matches.unshift(pn);res.charactersAdded.unshift(0);return res.charactersAddedCumulative.unshift(0)}if(res.content.indexOf("<")===-1&&res.content.indexOf(">")===-1){res.content.replace(/^()([^<>]*)$/,replacerUnshift)}var r=new RegExp("^()([^<]+)</(?:"+res.tagsXmlArrayJoined+")>");res.content.replace(r,replacerUnshift);function replacerPush(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.last=true;res.matches.push(pn);res.charactersAdded.push(0);return res.charactersAddedCumulative.push(0)}r=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^>]+)$");res.content.replace(r,replacerPush);return res}function xmlMatcher(content,tagsXmlArray){var res={};res.content=content;res.tagsXmlArray=tagsXmlArray;res.tagsXmlArrayJoined=res.tagsXmlArray.join("|");var regexp=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^<>]*)</(?:"+res.tagsXmlArrayJoined+")>","g");res.matches=DocUtils.pregMatchAll(regexp,res.content);res.charactersAddedCumulative=res.matches.map(function(){return 0});res.charactersAdded=res.matches.map(function(){return 0});return handleRecursiveCase(res)}var memoized=memoize(xmlMatcher);module.exports=function(content,tagsXmlArray){return DocUtils.cloneDeep(memoized(content,tagsXmlArray))}},{"./doc-utils":1,"./memoize":5}],18:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var ScopeManager=require("./scope-manager");var xmlMatcher=require("./xml-matcher");var Errors=require("./errors");var Lexer=require("./lexer");var Parser=require("./parser.js");var _render=require("./render.js");function _getFullText(content,tagsXmlArray){var matcher=xmlMatcher(content,tagsXmlArray);var result=matcher.matches.map(function(match){return match.array[2]});return DocUtils.wordToUtf8(DocUtils.convertSpaces(result.join("")))}module.exports=function(){function XmlTemplater(content,options){_classCallCheck(this,XmlTemplater);this.fromJson(options);this.setModules({inspect:{filePath:this.filePath}});this.load(content)}_createClass(XmlTemplater,[{key:"load",value:function load(content){if(typeof content!=="string"){var err=new Errors.XTInternalError("Content must be a string");err.properties.id="xmltemplater_content_must_be_string";throw err}this.content=content}},{key:"setTags",value:function setTags(tags){this.tags=tags!=null?tags:{};this.scopeManager=ScopeManager.createBaseScopeManager({tags:this.tags,parser:this.parser});return this}},{key:"fromJson",value:function fromJson(options){this.filePath=options.filePath;this.modules=options.modules;this.fileTypeConfig=options.fileTypeConfig;Object.keys(DocUtils.defaults).map(function(key){this[key]=options[key]!=null?options[key]:DocUtils.defaults[key]},this)}},{key:"getFullText",value:function getFullText(){return _getFullText(this.content,this.fileTypeConfig.tagsXmlTextArray)}},{key:"setModules",value:function setModules(obj){this.modules.forEach(function(module){module.set(obj)})}},{key:"parse",value:function parse(){this.xmllexed=Lexer.xmlparse(this.content,{text:this.fileTypeConfig.tagsXmlTextArray,other:this.fileTypeConfig.tagsXmlLexedArray});this.setModules({inspect:{xmllexed:this.xmllexed}});this.lexed=Lexer.parse(this.xmllexed,this.delimiters);this.setModules({inspect:{lexed:this.lexed}});this.parsed=Parser.parse(this.lexed,this.modules);this.setModules({inspect:{parsed:this.parsed}});this.postparsed=Parser.postparse(this.parsed,this.modules);return this}},{key:"render",value:function render(to){this.filePath=to;this.setModules({inspect:{postparsed:this.postparsed}});this.content=_render({compiled:this.postparsed,tags:this.tags,modules:this.modules,parser:this.parser,nullGetter:this.nullGetter,filePath:this.filePath});this.setModules({inspect:{content:this.content}});return this}}]);return XmlTemplater}()},{"./doc-utils":1,"./errors":2,"./lexer":4,"./parser.js":13,"./render.js":14,"./scope-manager":15,"./xml-matcher":17}],19:[function(require,module,exports){function DOMParser(options){this.options=options||{locator:{}}}DOMParser.prototype.parseFromString=function(source,mimeType){var options=this.options;var sax=new XMLReader;var domBuilder=options.domBuilder||new DOMHandler;var errorHandler=options.errorHandler;var locator=options.locator;var defaultNSMap=options.xmlns||{};var entityMap={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"};if(locator){domBuilder.setDocumentLocator(locator)}sax.errorHandler=buildErrorHandler(errorHandler,domBuilder,locator);sax.domBuilder=options.domBuilder||domBuilder;if(/\/x?html?$/.test(mimeType)){entityMap.nbsp=" ";entityMap.copy="©";defaultNSMap[""]="http://www.w3.org/1999/xhtml"}defaultNSMap.xml=defaultNSMap.xml||"http://www.w3.org/XML/1998/namespace";if(source){sax.parse(source,defaultNSMap,entityMap)}else{sax.errorHandler.error("invalid doc source")}return domBuilder.doc};function buildErrorHandler(errorImpl,domBuilder,locator){if(!errorImpl){if(domBuilder instanceof DOMHandler){return domBuilder}errorImpl=domBuilder}var errorHandler={};var isCallback=errorImpl instanceof Function;locator=locator||{};function build(key){var fn=errorImpl[key];if(!fn&&isCallback){fn=errorImpl.length==2?function(msg){errorImpl(key,msg)}:errorImpl}errorHandler[key]=fn&&function(msg){fn("[xmldom "+key+"]\t"+msg+_locator(locator))}||function(){}}build("warning");build("error");build("fatalError");return errorHandler}function DOMHandler(){this.cdata=false}function position(locator,node){node.lineNumber=locator.lineNumber;node.columnNumber=locator.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=(new DOMImplementation).createDocument(null,null,null);if(this.locator){this.doc.documentURI=this.locator.systemId}},startElement:function(namespaceURI,localName,qName,attrs){var doc=this.doc;var el=doc.createElementNS(namespaceURI,qName||localName);var len=attrs.length;appendElement(this,el);this.currentElement=el;this.locator&&position(this.locator,el);for(var i=0;i<len;i++){var namespaceURI=attrs.getURI(i);var value=attrs.getValue(i);var qName=attrs.getQName(i);var attr=doc.createAttributeNS(namespaceURI,qName);this.locator&&position(attrs.getLocator(i),attr);attr.value=attr.nodeValue=value;el.setAttributeNode(attr)}},endElement:function(namespaceURI,localName,qName){var current=this.currentElement;var tagName=current.tagName;this.currentElement=current.parentNode},startPrefixMapping:function(prefix,uri){},endPrefixMapping:function(prefix){},processingInstruction:function(target,data){var ins=this.doc.createProcessingInstruction(target,data);this.locator&&position(this.locator,ins);appendElement(this,ins)},ignorableWhitespace:function(ch,start,length){},characters:function(chars,start,length){chars=_toString.apply(this,arguments);if(chars){if(this.cdata){var charNode=this.doc.createCDATASection(chars)}else{var charNode=this.doc.createTextNode(chars)}if(this.currentElement){this.currentElement.appendChild(charNode)}else if(/^\s*$/.test(chars)){this.doc.appendChild(charNode)}this.locator&&position(this.locator,charNode)}},skippedEntity:function(name){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(locator){if(this.locator=locator){locator.lineNumber=0}},comment:function(chars,start,length){chars=_toString.apply(this,arguments);var comm=this.doc.createComment(chars);this.locator&&position(this.locator,comm);appendElement(this,comm)},startCDATA:function(){this.cdata=true},endCDATA:function(){this.cdata=false},startDTD:function(name,publicId,systemId){var impl=this.doc.implementation;if(impl&&impl.createDocumentType){var dt=impl.createDocumentType(name,publicId,systemId);this.locator&&position(this.locator,dt);appendElement(this,dt)}},warning:function(error){console.warn("[xmldom warning]\t"+error,_locator(this.locator))},error:function(error){console.error("[xmldom error]\t"+error,_locator(this.locator))},fatalError:function(error){console.error("[xmldom fatalError]\t"+error,_locator(this.locator));throw error}};function _locator(l){if(l){return"\n@"+(l.systemId||"")+"#[line:"+l.lineNumber+",col:"+l.columnNumber+"]"}}function _toString(chars,start,length){if(typeof chars=="string"){return chars.substr(start,length)}else{if(chars.length>=start+length||start){return new java.lang.String(chars,start,length)+""}return chars}}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){DOMHandler.prototype[key]=function(){return null}});function appendElement(hander,node){if(!hander.currentElement){hander.doc.appendChild(node)}else{hander.currentElement.appendChild(node)}}var XMLReader=require("./sax").XMLReader;var DOMImplementation=exports.DOMImplementation=require("./dom").DOMImplementation;exports.XMLSerializer=require("./dom").XMLSerializer;exports.DOMParser=DOMParser},{"./dom":20,"./sax":21}],20:[function(require,module,exports){function copy(src,dest){for(var p in src){dest[p]=src[p]}}function _extends(Class,Super){var pt=Class.prototype;if(Object.create){var ppt=Object.create(Super.prototype);pt.__proto__=ppt}if(!(pt instanceof Super)){function t(){}t.prototype=Super.prototype;t=new t;copy(pt,t);Class.prototype=pt=t}if(pt.constructor!=Class){if(typeof Class!="function"){console.error("unknow Class:"+Class)}pt.constructor=Class}}var htmlns="http://www.w3.org/1999/xhtml";var NodeType={};var ELEMENT_NODE=NodeType.ELEMENT_NODE=1;var ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2;var TEXT_NODE=NodeType.TEXT_NODE=3;var CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4;var ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5;var ENTITY_NODE=NodeType.ENTITY_NODE=6;var PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7;var COMMENT_NODE=NodeType.COMMENT_NODE=8;var DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9;var DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10;var DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11;var NOTATION_NODE=NodeType.NOTATION_NODE=12;var ExceptionCode={};var ExceptionMessage={};var INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1);var DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2);var HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3);var WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4);var INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5);var NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6);var NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7);var NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8);var NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9);var INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10);var INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11);var SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12);var INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13);var NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14);var INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(code,message){if(message instanceof Error){var error=message}else{error=this;Error.call(this,ExceptionMessage[code]);this.message=ExceptionMessage[code];if(Error.captureStackTrace)Error.captureStackTrace(this,DOMException)}error.code=code;if(message)this.message=this.message+": "+message;return error}DOMException.prototype=Error.prototype;copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(index){return this[index]||null},toString:function(isHTML,nodeFilter){for(var buf=[],i=0;i<this.length;i++){serializeToString(this[i],buf,isHTML,nodeFilter)}return buf.join("")}};function LiveNodeList(node,refresh){this._node=node;this._refresh=refresh;_updateLiveList(this)}function _updateLiveList(list){var inc=list._node._inc||list._node.ownerDocument._inc;if(list._inc!=inc){var ls=list._refresh(list._node);__set__(list,"length",ls.length);copy(ls,list);list._inc=inc}}LiveNodeList.prototype.item=function(i){_updateLiveList(this);return this[i]};_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(list,node){var i=list.length;while(i--){if(list[i]===node){return i}}}function _addNamedNode(el,list,newAttr,oldAttr){if(oldAttr){list[_findNodeIndex(list,oldAttr)]=newAttr}else{list[list.length++]=newAttr}if(el){newAttr.ownerElement=el;var doc=el.ownerDocument;if(doc){oldAttr&&_onRemoveAttribute(doc,el,oldAttr);_onAddAttribute(doc,el,newAttr)}}}function _removeNamedNode(el,list,attr){var i=_findNodeIndex(list,attr);if(i>=0){var lastIndex=list.length-1;while(i<lastIndex){list[i]=list[++i]}list.length=lastIndex;if(el){var doc=el.ownerDocument;if(doc){_onRemoveAttribute(doc,el,attr);attr.ownerElement=null}}}else{throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+"@"+attr))}}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(key){var i=this.length;while(i--){var attr=this[i];if(attr.nodeName==key){return attr}}},setNamedItem:function(attr){var el=attr.ownerElement;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}var oldAttr=this.getNamedItem(attr.nodeName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},setNamedItemNS:function(attr){var el=attr.ownerElement,oldAttr;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}oldAttr=this.getNamedItemNS(attr.namespaceURI,attr.localName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},removeNamedItem:function(key){var attr=this.getNamedItem(key);_removeNamedNode(this._ownerElement,this,attr);return attr},removeNamedItemNS:function(namespaceURI,localName){var attr=this.getNamedItemNS(namespaceURI,localName);_removeNamedNode(this._ownerElement,this,attr);return attr},getNamedItemNS:function(namespaceURI,localName){var i=this.length;while(i--){var node=this[i];if(node.localName==localName&&node.namespaceURI==namespaceURI){return node}}return null}};function DOMImplementation(features){this._features={};if(features){for(var feature in features){this._features=features[feature]}}}DOMImplementation.prototype={hasFeature:function(feature,version){var versions=this._features[feature.toLowerCase()];if(versions&&(!version||version in versions)){return true}else{return false}},createDocument:function(namespaceURI,qualifiedName,doctype){var doc=new Document;doc.implementation=this;doc.childNodes=new NodeList;doc.doctype=doctype;if(doctype){doc.appendChild(doctype)}if(qualifiedName){var root=doc.createElementNS(namespaceURI,qualifiedName);doc.appendChild(root)}return doc},createDocumentType:function(qualifiedName,publicId,systemId){var node=new DocumentType;node.name=qualifiedName;node.nodeName=qualifiedName;node.publicId=publicId;node.systemId=systemId;return node}};function Node(){}Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(newChild,refChild){return _insertBefore(this,newChild,refChild)},replaceChild:function(newChild,oldChild){this.insertBefore(newChild,oldChild);if(oldChild){this.removeChild(oldChild)}},removeChild:function(oldChild){return _removeChild(this,oldChild)},appendChild:function(newChild){return this.insertBefore(newChild,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(deep){return cloneNode(this.ownerDocument||this,this,deep)},normalize:function(){var child=this.firstChild;while(child){var next=child.nextSibling;if(next&&next.nodeType==TEXT_NODE&&child.nodeType==TEXT_NODE){this.removeChild(next);child.appendData(next.data)}else{child.normalize();child=next}}},isSupported:function(feature,version){return this.ownerDocument.implementation.hasFeature(feature,version)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(namespaceURI){var el=this;while(el){var map=el._nsMap;if(map){for(var n in map){if(map[n]==namespaceURI){return n}}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},lookupNamespaceURI:function(prefix){var el=this;while(el){var map=el._nsMap;if(map){if(prefix in map){return map[prefix]}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},isDefaultNamespace:function(namespaceURI){var prefix=this.lookupPrefix(namespaceURI);return prefix==null}};function _xmlEncoder(c){return c=="<"&&"&lt;"||c==">"&&"&gt;"||c=="&"&&"&amp;"||c=='"'&&"&quot;"||"&#"+c.charCodeAt()+";"}copy(NodeType,Node);copy(NodeType,Node.prototype);function _visitNode(node,callback){if(callback(node)){return true}if(node=node.firstChild){do{if(_visitNode(node,callback)){return true}}while(node=node.nextSibling)}}function Document(){}function _onAddAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){el._nsMap[newAttr.prefix?newAttr.localName:""]=newAttr.value}}function _onRemoveAttribute(doc,el,newAttr,remove){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){delete el._nsMap[newAttr.prefix?newAttr.localName:""]}}function _onUpdateChild(doc,el,newChild){if(doc&&doc._inc){doc._inc++;var cs=el.childNodes;if(newChild){cs[cs.length++]=newChild}else{var child=el.firstChild;var i=0;while(child){cs[i++]=child;child=child.nextSibling}cs.length=i}}}function _removeChild(parentNode,child){var previous=child.previousSibling;var next=child.nextSibling;if(previous){previous.nextSibling=next}else{parentNode.firstChild=next}if(next){next.previousSibling=previous}else{parentNode.lastChild=previous}_onUpdateChild(parentNode.ownerDocument,parentNode);return child}function _insertBefore(parentNode,newChild,nextChild){var cp=newChild.parentNode;if(cp){cp.removeChild(newChild)}if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){var newFirst=newChild.firstChild;if(newFirst==null){return newChild}var newLast=newChild.lastChild}else{newFirst=newLast=newChild}var pre=nextChild?nextChild.previousSibling:parentNode.lastChild;newFirst.previousSibling=pre;newLast.nextSibling=nextChild;if(pre){pre.nextSibling=newFirst}else{parentNode.firstChild=newFirst}if(nextChild==null){parentNode.lastChild=newLast}else{nextChild.previousSibling=newLast}do{newFirst.parentNode=parentNode}while(newFirst!==newLast&&(newFirst=newFirst.nextSibling));_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){newChild.firstChild=newChild.lastChild=null}return newChild}function _appendSingleChild(parentNode,newChild){var cp=newChild.parentNode;if(cp){var pre=parentNode.lastChild;cp.removeChild(newChild);var pre=parentNode.lastChild}var pre=parentNode.lastChild;newChild.parentNode=parentNode;newChild.previousSibling=pre;newChild.nextSibling=null;if(pre){pre.nextSibling=newChild}else{parentNode.firstChild=newChild}parentNode.lastChild=newChild;_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);return newChild}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(newChild,refChild){if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){var child=newChild.firstChild;while(child){var next=child.nextSibling;this.insertBefore(child,refChild);child=next}return newChild}if(this.documentElement==null&&newChild.nodeType==ELEMENT_NODE){this.documentElement=newChild}return _insertBefore(this,newChild,refChild),newChild.ownerDocument=this,newChild},removeChild:function(oldChild){if(this.documentElement==oldChild){this.documentElement=null}return _removeChild(this,oldChild)},importNode:function(importedNode,deep){return importNode(this,importedNode,deep)},getElementById:function(id){var rtv=null;_visitNode(this.documentElement,function(node){if(node.nodeType==ELEMENT_NODE){if(node.getAttribute("id")==id){rtv=node;return true}}});return rtv},createElement:function(tagName){var node=new Element;node.ownerDocument=this;node.nodeName=tagName;node.tagName=tagName;node.childNodes=new NodeList;var attrs=node.attributes=new NamedNodeMap;attrs._ownerElement=node;return node},createDocumentFragment:function(){var node=new DocumentFragment;node.ownerDocument=this;node.childNodes=new NodeList;return node},createTextNode:function(data){var node=new Text;node.ownerDocument=this;node.appendData(data);return node},createComment:function(data){var node=new Comment;node.ownerDocument=this;node.appendData(data);return node},createCDATASection:function(data){var node=new CDATASection;node.ownerDocument=this;node.appendData(data);return node},createProcessingInstruction:function(target,data){var node=new ProcessingInstruction;node.ownerDocument=this;node.tagName=node.target=target;node.nodeValue=node.data=data;return node},createAttribute:function(name){var node=new Attr;node.ownerDocument=this;node.name=name;node.nodeName=name;node.localName=name;node.specified=true;return node},createEntityReference:function(name){var node=new EntityReference;node.ownerDocument=this;node.nodeName=name;return node},createElementNS:function(namespaceURI,qualifiedName){var node=new Element;var pl=qualifiedName.split(":");var attrs=node.attributes=new NamedNodeMap;node.childNodes=new NodeList;node.ownerDocument=this;node.nodeName=qualifiedName;node.tagName=qualifiedName;node.namespaceURI=namespaceURI;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}attrs._ownerElement=node;return node},createAttributeNS:function(namespaceURI,qualifiedName){var node=new Attr;var pl=qualifiedName.split(":");node.ownerDocument=this;node.nodeName=qualifiedName;node.name=qualifiedName;node.namespaceURI=namespaceURI;node.specified=true;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}return node}};_extends(Document,Node);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(name){return this.getAttributeNode(name)!=null},getAttribute:function(name){var attr=this.getAttributeNode(name);return attr&&attr.value||""},getAttributeNode:function(name){return this.attributes.getNamedItem(name)},setAttribute:function(name,value){var attr=this.ownerDocument.createAttribute(name);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},removeAttribute:function(name){var attr=this.getAttributeNode(name);attr&&this.removeAttributeNode(attr)},appendChild:function(newChild){if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){return this.insertBefore(newChild,null)}else{return _appendSingleChild(this,newChild)}},setAttributeNode:function(newAttr){return this.attributes.setNamedItem(newAttr)},setAttributeNodeNS:function(newAttr){return this.attributes.setNamedItemNS(newAttr)},removeAttributeNode:function(oldAttr){return this.attributes.removeNamedItem(oldAttr.nodeName)},removeAttributeNS:function(namespaceURI,localName){var old=this.getAttributeNodeNS(namespaceURI,localName);old&&this.removeAttributeNode(old)},hasAttributeNS:function(namespaceURI,localName){return this.getAttributeNodeNS(namespaceURI,localName)!=null},getAttributeNS:function(namespaceURI,localName){var attr=this.getAttributeNodeNS(namespaceURI,localName);return attr&&attr.value||""},setAttributeNS:function(namespaceURI,qualifiedName,value){var attr=this.ownerDocument.createAttributeNS(namespaceURI,qualifiedName);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},getAttributeNodeNS:function(namespaceURI,localName){return this.attributes.getNamedItemNS(namespaceURI,localName)},getElementsByTagName:function(tagName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType==ELEMENT_NODE&&(tagName==="*"||node.tagName==tagName)){ls.push(node)}});return ls})},getElementsByTagNameNS:function(namespaceURI,localName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType===ELEMENT_NODE&&(namespaceURI==="*"||node.namespaceURI===namespaceURI)&&(localName==="*"||node.localName==localName)){ls.push(node)}});return ls})}};Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName;Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS;_extends(Element,Node);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE;_extends(Attr,Node);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(offset,count){return this.data.substring(offset,offset+count)},appendData:function(text){text=this.data+text;this.nodeValue=this.data=text;this.length=text.length},insertData:function(offset,text){this.replaceData(offset,0,text)},appendChild:function(newChild){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(offset,count){this.replaceData(offset,count,"")},replaceData:function(offset,count,text){var start=this.data.substring(0,offset);var end=this.data.substring(offset+count);text=start+text+end;this.nodeValue=this.data=text;this.length=text.length}};_extends(CharacterData,Node);function Text(){}Text.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(offset){var text=this.data;var newText=text.substring(offset);text=text.substring(0,offset);this.data=this.nodeValue=text;this.length=text.length;var newNode=this.ownerDocument.createTextNode(newText);if(this.parentNode){this.parentNode.insertBefore(newNode,this.nextSibling)}return newNode}};_extends(Text,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE};_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE};_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE;_extends(DocumentType,Node);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE;_extends(Notation,Node);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE;_extends(Entity,Node);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE;_extends(EntityReference,Node);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment";DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE;_extends(DocumentFragment,Node);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE;_extends(ProcessingInstruction,Node);function XMLSerializer(){}XMLSerializer.prototype.serializeToString=function(node,isHtml,nodeFilter){return nodeSerializeToString.call(node,isHtml,nodeFilter)};Node.prototype.toString=nodeSerializeToString;function nodeSerializeToString(isHtml,nodeFilter){var buf=[];var refNode=this.nodeType==9?this.documentElement:this;var prefix=refNode.prefix;var uri=refNode.namespaceURI;if(uri&&prefix==null){var prefix=refNode.lookupPrefix(uri);if(prefix==null){var visibleNamespaces=[{namespace:uri,prefix:null}]}}serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);return buf.join("")}function needNamespaceDefine(node,isHTML,visibleNamespaces){var prefix=node.prefix||"";var uri=node.namespaceURI;if(!prefix&&!uri){return false}if(prefix==="xml"&&uri==="http://www.w3.org/XML/1998/namespace"||uri=="http://www.w3.org/2000/xmlns/"){return false}var i=visibleNamespaces.length;while(i--){var ns=visibleNamespaces[i];if(ns.prefix==prefix){return ns.namespace!=uri}}return true}function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){if(nodeFilter){node=nodeFilter(node);if(node){if(typeof node=="string"){buf.push(node);return}}else{return}}switch(node.nodeType){case ELEMENT_NODE:if(!visibleNamespaces)visibleNamespaces=[];var startVisibleNamespaces=visibleNamespaces.length;var attrs=node.attributes;var len=attrs.length;var child=node.firstChild;var nodeName=node.tagName;isHTML=htmlns===node.namespaceURI||isHTML;buf.push("<",nodeName);for(var i=0;i<len;i++){var attr=attrs.item(i);if(attr.prefix=="xmlns"){visibleNamespaces.push({prefix:attr.localName,namespace:attr.value})}else if(attr.nodeName=="xmlns"){visibleNamespaces.push({prefix:"",namespace:attr.value})}}for(var i=0;i<len;i++){var attr=attrs.item(i);if(needNamespaceDefine(attr,isHTML,visibleNamespaces)){var prefix=attr.prefix||"";var uri=attr.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces)}if(needNamespaceDefine(node,isHTML,visibleNamespaces)){var prefix=node.prefix||"";var uri=node.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}if(child||isHTML&&!/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){buf.push(">");if(isHTML&&/^script$/i.test(nodeName)){while(child){if(child.data){buf.push(child.data)}else{serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces)}child=child.nextSibling}}else{while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}}buf.push("</",nodeName,">")}else{buf.push("/>")}return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var child=node.firstChild;while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}return;case ATTRIBUTE_NODE:return buf.push(" ",node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');case TEXT_NODE:return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));case CDATA_SECTION_NODE:return buf.push("<![CDATA[",node.data,"]]>");case COMMENT_NODE:return buf.push("\x3c!--",node.data,"--\x3e");case DOCUMENT_TYPE_NODE:var pubid=node.publicId;var sysid=node.systemId;buf.push("<!DOCTYPE ",node.name);if(pubid){buf.push(' PUBLIC "',pubid);if(sysid&&sysid!="."){buf.push('" "',sysid)}buf.push('">')}else if(sysid&&sysid!="."){buf.push(' SYSTEM "',sysid,'">')}else{var sub=node.internalSubset;if(sub){buf.push(" [",sub,"]")}buf.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return buf.push("<?",node.target," ",node.data,"?>");case ENTITY_REFERENCE_NODE:return buf.push("&",node.nodeName,";");default:buf.push("??",node.nodeName)}}function importNode(doc,node,deep){var node2;switch(node.nodeType){case ELEMENT_NODE:node2=node.cloneNode(false);node2.ownerDocument=doc;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:deep=true;break}if(!node2){node2=node.cloneNode(false)}node2.ownerDocument=doc;node2.parentNode=null;if(deep){var child=node.firstChild;while(child){node2.appendChild(importNode(doc,child,deep));child=child.nextSibling}}return node2}function cloneNode(doc,node,deep){var node2=new node.constructor;for(var n in node){var v=node[n];if(typeof v!="object"){if(v!=node2[n]){node2[n]=v}}}if(node.childNodes){node2.childNodes=new NodeList}node2.ownerDocument=doc;switch(node2.nodeType){case ELEMENT_NODE:var attrs=node.attributes;var attrs2=node2.attributes=new NamedNodeMap;var len=attrs.length;attrs2._ownerElement=node2;for(var i=0;i<len;i++){node2.setAttributeNode(cloneNode(doc,attrs.item(i),true))}break;case ATTRIBUTE_NODE:deep=true}if(deep){var child=node.firstChild;while(child){node2.appendChild(cloneNode(doc,child,deep));child=child.nextSibling}}return node2}function __set__(object,key,value){object[key]=value}try{if(Object.defineProperty){Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){_updateLiveList(this);return this.$$length}});Object.defineProperty(Node.prototype,"textContent",{get:function(){return getTextContent(this)},set:function(data){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:while(this.firstChild){this.removeChild(this.firstChild)}if(data||String(data)){this.appendChild(this.ownerDocument.createTextNode(data))}break;default:this.data=data;this.value=data;this.nodeValue=data}}});function getTextContent(node){switch(node.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var buf=[];node=node.firstChild;while(node){if(node.nodeType!==7&&node.nodeType!==8){buf.push(getTextContent(node))}node=node.nextSibling}return buf.join("");default:return node.nodeValue}}__set__=function(object,key,value){object["$$"+key]=value}}}catch(e){}exports.DOMImplementation=DOMImplementation;exports.XMLSerializer=XMLSerializer},{}],21:[function(require,module,exports){var nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;var nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");var tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$");var S_TAG=0;var S_ATTR=1;var S_ATTR_SPACE=2;var S_EQ=3;var S_ATTR_NOQUOT_VALUE=4;var S_ATTR_END=5;var S_TAG_SPACE=6;var S_TAG_CLOSE=7;function XMLReader(){}XMLReader.prototype={parse:function(source,defaultNSMap,entityMap){var domBuilder=this.domBuilder;domBuilder.startDocument();_copy(defaultNSMap,defaultNSMap={});parse(source,defaultNSMap,entityMap,domBuilder,this.errorHandler);domBuilder.endDocument()}};function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){function fixedFromCharCode(code){if(code>65535){code-=65536;var surrogate1=55296+(code>>10),surrogate2=56320+(code&1023);return String.fromCharCode(surrogate1,surrogate2)}else{return String.fromCharCode(code)}}function entityReplacer(a){var k=a.slice(1,-1);if(k in entityMap){return entityMap[k]}else if(k.charAt(0)==="#"){return fixedFromCharCode(parseInt(k.substr(1).replace("x","0x")))}else{errorHandler.error("entity not found:"+a);return a}}function appendText(end){if(end>start){var xt=source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);locator&&position(start);domBuilder.characters(xt,0,end-start);start=end}}function position(p,m){while(p>=lineEnd&&(m=linePattern.exec(source))){lineStart=m.index;lineEnd=lineStart+m[0].length;locator.lineNumber++}locator.columnNumber=p-lineStart+1}var lineStart=0;var lineEnd=0;var linePattern=/.*(?:\r\n?|\n)|.*$/g;var locator=domBuilder.locator;var parseStack=[{currentNSMap:defaultNSMapCopy}];var closeMap={};var start=0;while(true){try{var tagStart=source.indexOf("<",start);if(tagStart<0){if(!source.substr(start).match(/^\s*$/)){var doc=domBuilder.doc;var text=doc.createTextNode(source.substr(start));doc.appendChild(text);domBuilder.currentElement=text}return}if(tagStart>start){appendText(tagStart)}switch(source.charAt(tagStart+1)){case"/":var end=source.indexOf(">",tagStart+3);var tagName=source.substring(tagStart+2,end);var config=parseStack.pop();if(end<0){tagName=source.substring(tagStart+2).replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" is not complete:"+config.tagName);end=tagStart+1+tagName.length}else if(tagName.match(/\s</)){tagName=tagName.replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" maybe not complete");end=tagStart+1+tagName.length}var localNSMap=config.localNSMap;var endMatch=config.tagName==tagName;var endIgnoreCaseMach=endMatch||config.tagName&&config.tagName.toLowerCase()==tagName.toLowerCase();if(endIgnoreCaseMach){domBuilder.endElement(config.uri,config.localName,tagName);if(localNSMap){for(var prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}if(!endMatch){errorHandler.fatalError("end tag name: "+tagName+" is not match the current start tagName:"+config.tagName)}}else{parseStack.push(config)}end++;break;case"?":locator&&position(tagStart);end=parseInstruction(source,tagStart,domBuilder);break;case"!":locator&&position(tagStart);end=parseDCC(source,tagStart,domBuilder,errorHandler);break;default:locator&&position(tagStart);var el=new ElementAttributes;var currentNSMap=parseStack[parseStack.length-1].currentNSMap;var end=parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);var len=el.length;if(!el.closed&&fixSelfClosed(source,end,el.tagName,closeMap)){el.closed=true;if(!entityMap.nbsp){errorHandler.warning("unclosed xml attribute")}}if(locator&&len){var locator2=copyLocator(locator,{});for(var i=0;i<len;i++){var a=el[i];position(a.offset);a.locator=copyLocator(locator,{})}domBuilder.locator=locator2;if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}domBuilder.locator=locator}else{if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}}if(el.uri==="http://www.w3.org/1999/xhtml"&&!el.closed){end=parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)}else{end++}}}catch(e){errorHandler.error("element parse error: "+e);end=-1}if(end>start){start=end}else{appendText(Math.max(tagStart,start)+1)}}}function copyLocator(f,t){t.lineNumber=f.lineNumber;t.columnNumber=f.columnNumber;return t}function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){var attrName;var value;var p=++start;var s=S_TAG;while(true){var c=source.charAt(p);switch(c){case"=":if(s===S_ATTR){attrName=source.slice(start,p);s=S_EQ}else if(s===S_ATTR_SPACE){s=S_EQ}else{throw new Error("attribute equal must after attrName")}break;case"'":case'"':if(s===S_EQ||s===S_ATTR){if(s===S_ATTR){errorHandler.warning('attribute value must after "="');attrName=source.slice(start,p)}start=p+1;p=source.indexOf(c,start);if(p>0){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start-1);s=S_ATTR_END}else{throw new Error("attribute value no end '"+c+"' match")}}else if(s==S_ATTR_NOQUOT_VALUE){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start);errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+")!!");start=p+1;s=S_ATTR_END}else{throw new Error('attribute value must after "="')}break;case"/":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:s=S_TAG_CLOSE;el.closed=true;case S_ATTR_NOQUOT_VALUE:case S_ATTR:case S_ATTR_SPACE:break;default:throw new Error("attribute invalid close char('/')")}break;case"":errorHandler.error("unexpected end of input");if(s==S_TAG){el.setTagName(source.slice(start,p))}return p;case">":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:value=source.slice(start,p);if(value.slice(-1)==="/"){el.closed=true;value=value.slice(0,-1)}case S_ATTR_SPACE:if(s===S_ATTR_SPACE){value=attrName}if(s==S_ATTR_NOQUOT_VALUE){errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)}else{if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!value.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')}el.add(value,value,start)}break;case S_EQ:throw new Error("attribute value missed!!")}return p;case"":c=" ";default:if(c<=" "){switch(s){case S_TAG:el.setTagName(source.slice(start,p));s=S_TAG_SPACE;break;case S_ATTR:attrName=source.slice(start,p);s=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value,start);case S_ATTR_END:s=S_TAG_SPACE;break}}else{switch(s){case S_ATTR_SPACE:var tagName=el.tagName;if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!attrName.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')}el.add(attrName,attrName,start);start=p;s=S_ATTR;break;case S_ATTR_END:errorHandler.warning('attribute space is required"'+attrName+'"!!');case S_TAG_SPACE:s=S_ATTR;start=p;break;case S_EQ:s=S_ATTR_NOQUOT_VALUE;start=p;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}}p++}}function appendElement(el,domBuilder,currentNSMap){var tagName=el.tagName;var localNSMap=null;var i=el.length;while(i--){var a=el[i];var qName=a.qName;var value=a.value;var nsp=qName.indexOf(":");if(nsp>0){var prefix=a.prefix=qName.slice(0,nsp);var localName=qName.slice(nsp+1);var nsPrefix=prefix==="xmlns"&&localName}else{localName=qName;prefix=null;nsPrefix=qName==="xmlns"&&""}a.localName=localName;if(nsPrefix!==false){if(localNSMap==null){localNSMap={};_copy(currentNSMap,currentNSMap={})}currentNSMap[nsPrefix]=localNSMap[nsPrefix]=value;a.uri="http://www.w3.org/2000/xmlns/";domBuilder.startPrefixMapping(nsPrefix,value)}}var i=el.length;while(i--){a=el[i];var prefix=a.prefix;if(prefix){if(prefix==="xml"){a.uri="http://www.w3.org/XML/1998/namespace"}if(prefix!=="xmlns"){a.uri=currentNSMap[prefix||""]}}}var nsp=tagName.indexOf(":");if(nsp>0){prefix=el.prefix=tagName.slice(0,nsp);localName=el.localName=tagName.slice(nsp+1)}else{prefix=null;localName=el.localName=tagName}var ns=el.uri=currentNSMap[prefix||""];domBuilder.startElement(ns,localName,tagName,el);if(el.closed){domBuilder.endElement(ns,localName,tagName);if(localNSMap){for(prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}}else{el.currentNSMap=currentNSMap;el.localNSMap=localNSMap;return true}}function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){if(/^(?:script|textarea)$/i.test(tagName)){var elEndStart=source.indexOf("</"+tagName+">",elStartEnd);var text=source.substring(elStartEnd+1,elEndStart);if(/[&<]/.test(text)){if(/^script$/i.test(tagName)){domBuilder.characters(text,0,text.length);return elEndStart}text=text.replace(/&#?\w+;/g,entityReplacer);domBuilder.characters(text,0,text.length);return elEndStart}}return elStartEnd+1}function fixSelfClosed(source,elStartEnd,tagName,closeMap){var pos=closeMap[tagName];if(pos==null){pos=source.lastIndexOf("</"+tagName+">");if(pos<elStartEnd){pos=source.lastIndexOf("</"+tagName)}closeMap[tagName]=pos}return pos<elStartEnd}function _copy(source,target){for(var n in source){target[n]=source[n]}}function parseDCC(source,start,domBuilder,errorHandler){var next=source.charAt(start+2);switch(next){case"-":if(source.charAt(start+3)==="-"){var end=source.indexOf("--\x3e",start+4);if(end>start){domBuilder.comment(source,start+4,end-start-4);return end+3}else{errorHandler.error("Unclosed comment");return-1}}else{return-1}default:if(source.substr(start+3,6)=="CDATA["){var end=source.indexOf("]]>",start+9);domBuilder.startCDATA();domBuilder.characters(source,start+9,end-start-9);domBuilder.endCDATA();return end+3}var matchs=split(source,start);var len=matchs.length;if(len>1&&/!doctype/i.test(matchs[0][0])){var name=matchs[1][0];var pubid=len>3&&/^public$/i.test(matchs[2][0])&&matchs[3][0];var sysid=len>4&&matchs[4][0];var lastMatch=matchs[len-1];domBuilder.startDTD(name,pubid&&pubid.replace(/^(['"])(.*?)\1$/,"$2"),sysid&&sysid.replace(/^(['"])(.*?)\1$/,"$2"));domBuilder.endDTD();return lastMatch.index+lastMatch[0].length}}return-1}function parseInstruction(source,start,domBuilder){var end=source.indexOf("?>",start);if(end){var match=source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(match){var len=match[0].length;domBuilder.processingInstruction(match[1],match[2]);return end+2}else{return-1}}return-1}function ElementAttributes(source){}ElementAttributes.prototype={setTagName:function(tagName){if(!tagNamePattern.test(tagName)){throw new Error("invalid tagName:"+tagName)}this.tagName=tagName},add:function(qName,value,offset){if(!tagNamePattern.test(qName)){throw new Error("invalid attribute:"+qName)}this[this.length++]={qName:qName,value:value,offset:offset}},length:0,getLocalName:function(i){return this[i].localName},getLocator:function(i){return this[i].locator},getQName:function(i){return this[i].qName},getURI:function(i){return this[i].uri},getValue:function(i){return this[i].value}};function _set_proto_(thiz,parent){thiz.__proto__=parent;return thiz}if(!(_set_proto_({},_set_proto_.prototype)instanceof _set_proto_)){_set_proto_=function(thiz,parent){function p(){}p.prototype=parent;p=new p;for(parent in thiz){p[parent]=thiz[parent]}return p}}function split(source,start){var match;var buf=[];var reg=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;reg.lastIndex=start;reg.exec(source);while(match=reg.exec(source)){buf.push(match);if(match[1])return buf}}exports.XMLReader=XMLReader},{}],"/src/js/docxtemplater.js":[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");DocUtils.traits=require("./traits");DocUtils.moduleWrapper=require("./module-wrapper");var wrapper=DocUtils.moduleWrapper;var Docxtemplater=function(){function Docxtemplater(){_classCallCheck(this,Docxtemplater);if(arguments.length>0){throw new Error("The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.")}this.compiled={};this.modules=[];this.setOptions({})}_createClass(Docxtemplater,[{key:"attachModule",value:function attachModule(module){this.modules.push(wrapper(module));return this}},{key:"setOptions",value:function setOptions(options){var _this=this;this.options=options;Object.keys(DocUtils.defaults).forEach(function(key){var defaultValue=DocUtils.defaults[key];_this[key]=_this.options[key]!=null?_this.options[key]:defaultValue});if(this.zip){this.updateFileTypeConfig()}return this}},{key:"loadZip",value:function loadZip(zip){if(zip.loadAsync){throw new Error("Docxtemplater doesn't handle JSZip version >=3, see changelog")}this.zip=zip;this.updateFileTypeConfig();return this}},{key:"compileFile",value:function compileFile(fileName){var currentFile=this.createTemplateClass(fileName);currentFile.parse();this.compiled[fileName]=currentFile}},{key:"compile",value:function compile(){this.templatedFiles=this.fileTypeConfig.getTemplatedFiles(this.zip);return this}},{key:"updateFileTypeConfig",value:function updateFileTypeConfig(){this.fileType=this.zip.files["word/document.xml"]?"docx":"pptx";this.fileTypeConfig=this.options.fileTypeConfig||Docxtemplater.FileTypeConfig[this.fileType];return this}},{key:"render",value:function render(){var _this2=this;this.options.xmlFileNames=[];this.modules=this.fileTypeConfig.baseModules.map(function(moduleFunction){return moduleFunction()}).concat(this.modules);this.options=this.modules.reduce(function(options,module){return module.optionsTransformer(options,_this2)},this.options);this.xmlDocuments=this.options.xmlFileNames.reduce(function(xmlDocuments,fileName){var content=_this2.zip.files[fileName].asText();xmlDocuments[fileName]=DocUtils.str2xml(content);return xmlDocuments},{});this.modules.forEach(function(module){module.set({zip:_this2.zip,xmlDocuments:_this2.xmlDocuments,data:_this2.data})});this.compile();this.modules.forEach(function(module){module.set({compiled:_this2.compiled})});this.templatedFiles.forEach(function(fileName){if(_this2.zip.files[fileName]!=null){_this2.compileFile(fileName)}});this.mapper=this.modules.reduce(function(value,module){return module.getRenderedMap(value)},{});Object.keys(this.mapper).forEach(function(to){var mapped=_this2.mapper[to];var from=mapped.from;var currentFile=_this2.compiled[from];currentFile.setTags(mapped.data);currentFile.render(to);_this2.zip.file(to,currentFile.content)});Object.keys(this.xmlDocuments).forEach(function(fileName){_this2.zip.remove(fileName);var content=DocUtils.xml2str(_this2.xmlDocuments[fileName]);return _this2.zip.file(fileName,content,{})});return this}},{key:"setData",value:function setData(data){this.data=data;return this}},{key:"getZip",value:function getZip(){return this.zip}},{key:"createTemplateClass",value:function createTemplateClass(path){var usedData=this.zip.files[path].asText();return this.createTemplateClassFromContent(usedData,path)}},{key:"createTemplateClassFromContent",value:function createTemplateClassFromContent(content,filePath){var _this3=this;var xmltOptions={filePath:filePath};Object.keys(DocUtils.defaults).forEach(function(key){xmltOptions[key]=_this3[key]});xmltOptions.fileTypeConfig=this.fileTypeConfig;xmltOptions.modules=this.modules;return new Docxtemplater.XmlTemplater(content,xmltOptions)}},{key:"getFullText",value:function getFullText(path){return this.createTemplateClass(path||this.fileTypeConfig.textPath).getFullText()}},{key:"getTemplatedFiles",value:function getTemplatedFiles(){this.compile();return this.templatedFiles}}]);return Docxtemplater}();Docxtemplater.DocUtils=require("./doc-utils");Docxtemplater.Errors=require("./errors");Docxtemplater.XmlTemplater=require("./xml-templater");Docxtemplater.FileTypeConfig=require("./file-type-config");Docxtemplater.XmlMatcher=require("./xml-matcher");module.exports=Docxtemplater},{"./doc-utils":1,"./errors":2,"./file-type-config":3,"./module-wrapper":7,"./traits":16,"./xml-matcher":17,"./xml-templater":18}]},{},[])("/src/js/docxtemplater.js")});

/***/ }),

/***/ 31290:
/*!*************************!*\
  !*** ./js/jszip.min.js ***!
  \*************************/
/***/ ((module) => {

/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if(true)module.exports=a();else { var b; }}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i=undefined;if(!h&&i)return require(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f=undefined,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";function d(a){if(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0;for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}}var e=a("./dataReader");d.prototype=new e,d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6}],2:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a,b){for(var c,e,f,g,h,i,j,k="",l=0;l<a.length;)c=a.charCodeAt(l++),e=a.charCodeAt(l++),f=a.charCodeAt(l++),g=c>>2,h=(3&c)<<4|e>>4,i=(15&e)<<2|f>>6,j=63&f,isNaN(e)?i=j=64:isNaN(f)&&(j=64),k=k+d.charAt(g)+d.charAt(h)+d.charAt(i)+d.charAt(j);return k},c.decode=function(a,b){var c,e,f,g,h,i,j,k="",l=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");l<a.length;)g=d.indexOf(a.charAt(l++)),h=d.indexOf(a.charAt(l++)),i=d.indexOf(a.charAt(l++)),j=d.indexOf(a.charAt(l++)),c=g<<2|h>>4,e=(15&h)<<4|i>>2,f=(3&i)<<6|j,k+=String.fromCharCode(c),64!=i&&(k+=String.fromCharCode(e)),64!=j&&(k+=String.fromCharCode(f));return k}},{}],3:[function(a,b,c){"use strict";function d(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}d.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=d},{}],4:[function(a,b,c){"use strict";c.STORE={magic:"\0\0",compress:function(a,b){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":9}],5:[function(a,b,c){"use strict";var d=a("./utils"),e=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==d.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b^=-1;for(var i=0,j=a.length;i<j;i++)h=c?a[i]:a.charCodeAt(i),g=255&(b^h),f=e[g],b=b>>>8^f;return b^-1}},{"./utils":22}],6:[function(a,b,c){"use strict";function d(a){this.data=null,this.length=0,this.index=0,this.zero=0}var e=a("./utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=d},{"./utils":22}],7:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],8:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":22}],9:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\0",c.compress=function(a,b){return e.deflateRaw(a,{level:b.level||-1})},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:25}],10:[function(a,b,c){"use strict";function d(a,b){return this instanceof d?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new d(a,b)}var e=a("./base64");d.prototype=a("./object"),d.prototype.load=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.utils=a("./deprecatedPublicUtils"),d.base64={encode:function(a){return e.encode(a)},decode:function(a){return e.decode(a)}},d.compressions=a("./compressions"),b.exports=d},{"./base64":2,"./compressions":4,"./defaults":7,"./deprecatedPublicUtils":8,"./load":11,"./object":14,"./support":18}],11:[function(a,b,c){"use strict";var d=a("./base64"),e=a("./utf8"),f=a("./utils"),g=a("./zipEntries");b.exports=function(a,b){var c,h,i,j;for(b=f.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:e.utf8decode}),b.base64&&(a=d.decode(a)),h=new g(a,b),c=h.files,i=0;i<c.length;i++)j=c[i],this.file(j.fileNameStr,j.decompressed,{binary:!0,optimizedBinaryString:!0,date:j.date,dir:j.dir,comment:j.fileCommentStr.length?j.fileCommentStr:null,unixPermissions:j.unixPermissions,dosPermissions:j.dosPermissions,createFolders:b.createFolders});return h.zipComment.length&&(this.comment=h.zipComment),this}},{"./base64":2,"./utf8":21,"./utils":22,"./zipEntries":23}],12:[function(a,b,c){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],13:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0}var e=a("./uint8ArrayReader");d.prototype=new e,d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./uint8ArrayReader":19}],14:[function(a,b,c){"use strict";var d=a("./support"),e=a("./utils"),f=a("./crc32"),g=a("./signature"),h=a("./defaults"),i=a("./base64"),j=a("./compressions"),k=a("./compressedObject"),l=a("./nodeBuffer"),m=a("./utf8"),n=a("./stringWriter"),o=a("./uint8ArrayWriter"),p=function(a){if(a._data instanceof k&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===e.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},q=function(a){var b=p(a),c=e.getTypeOf(b);return"string"===c?!a.options.binary&&d.nodebuffer?l(b,"utf-8"):a.asBinary():b},r=function(a){var b=p(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=i.decode(b)),b=a&&this.options.binary?D.utf8decode(b):e.transformTo("string",b),a||this.options.binary||(b=e.transformTo("string",D.utf8encode(b))),b)},s=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};s.prototype={asText:function(){return r.call(this,!0)},asBinary:function(){return r.call(this,!1)},asNodeBuffer:function(){var a=q(this);return e.transformTo("nodebuffer",a)},asUint8Array:function(){var a=q(this);return e.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var t=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=e.extend(a,h),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var d,f=e.getTypeOf(b);if(c=u(c),"string"==typeof c.unixPermissions&&(c.unixPermissions=parseInt(c.unixPermissions,8)),c.unixPermissions&&16384&c.unixPermissions&&(c.dir=!0),c.dosPermissions&&16&c.dosPermissions&&(c.dir=!0),c.dir&&(a=x(a)),c.createFolders&&(d=w(a))&&y.call(this,d,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null,f=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=e.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof k))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=e.transformTo("uint8array",b))}var g=new s(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a){return"/"!=a.slice(-1)&&(a+="/"),a},y=function(a,b){return b="undefined"!=typeof b&&b,a=x(a),this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},z=function(a,b,c){var d,g=new k;return a._data instanceof k?(g.uncompressedSize=a._data.uncompressedSize,g.crc32=a._data.crc32,0===g.uncompressedSize||a.dir?(b=j.STORE,g.compressedContent="",g.crc32=0):a._data.compressionMethod===b.magic?g.compressedContent=a._data.getCompressedContent():(d=a._data.getContent(),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c))):(d=q(a),d&&0!==d.length&&!a.dir||(b=j.STORE,d=""),g.uncompressedSize=d.length,g.crc32=f(d),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c)),g.compressedSize=g.compressedContent.length,g.compressionMethod=b.magic,g},A=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},B=function(a,b){return 63&(a||0)},C=function(a,b,c,d,h,i){var j,k,l,n,o=(c.compressedContent,i!==m.utf8encode),p=e.transformTo("string",i(b.name)),q=e.transformTo("string",m.utf8encode(b.name)),r=b.comment||"",s=e.transformTo("string",i(r)),u=e.transformTo("string",m.utf8encode(r)),v=q.length!==b.name.length,w=u.length!==r.length,x=b.options,y="",z="",C="";l=b._initialMetadata.dir!==b.dir?b.dir:x.dir,n=b._initialMetadata.date!==b.date?b.date:x.date;var D=0,E=0;l&&(D|=16),"UNIX"===h?(E=798,D|=A(b.unixPermissions,l)):(E=20,D|=B(b.dosPermissions,l)),j=n.getHours(),j<<=6,j|=n.getMinutes(),j<<=5,j|=n.getSeconds()/2,k=n.getFullYear()-1980,k<<=4,k|=n.getMonth()+1,k<<=5,k|=n.getDate(),v&&(z=t(1,1)+t(f(p),4)+q,y+="up"+t(z.length,2)+z),w&&(C=t(1,1)+t(this.crc32(s),4)+u,y+="uc"+t(C.length,2)+C);var F="";F+="\n\0",F+=o||!v&&!w?"\0\0":"\0\b",F+=c.compressionMethod,F+=t(j,2),F+=t(k,2),F+=t(c.crc32,4),F+=t(c.compressedSize,4),F+=t(c.uncompressedSize,4),F+=t(p.length,2),F+=t(y.length,2);var G=g.LOCAL_FILE_HEADER+F+p+y,H=g.CENTRAL_FILE_HEADER+t(E,2)+F+t(s.length,2)+"\0\0\0\0"+t(D,4)+t(d,4)+p+y+s;return{fileRecord:G,dirRecord:H,compressedObject:c}},D={load:function(a,b){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,f,g=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],f=new s(d.name,d._data,e.extend(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,f)&&g.push(f));return g},file:function(a,b,c){if(1===arguments.length){if(e.isRegExp(a)){var d=a;return this.filter(function(a,b){return!b.dir&&d.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(e.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=y.call(this,b),d=this.clone();return d.root=c.name,d},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=e.extend(a||{},{base64:!0,compression:"STORE",compressionOptions:null,type:"base64",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:m.utf8encode}),e.checkSupport(a.type),"darwin"!==a.platform&&"freebsd"!==a.platform&&"linux"!==a.platform&&"sunos"!==a.platform||(a.platform="UNIX"),"win32"===a.platform&&(a.platform="DOS");var b,c,d=[],f=0,h=0,k=e.transformTo("string",a.encodeFileName(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var p=this.files[l],q=p.options.compression||a.compression.toUpperCase(),r=j[q];if(!r)throw new Error(q+" is not a valid compression method !");var s=p.options.compressionOptions||a.compressionOptions||{},u=z.call(this,p,r,s),v=C.call(this,l,p,u,f,a.platform,a.encodeFileName);f+=v.fileRecord.length+u.compressedSize,h+=v.dirRecord.length,d.push(v)}var w="";w=g.CENTRAL_DIRECTORY_END+"\0\0\0\0"+t(d.length,2)+t(d.length,2)+t(h,4)+t(f,4)+t(k.length,2)+k;var x=a.type.toLowerCase();for(b="uint8array"===x||"arraybuffer"===x||"blob"===x||"nodebuffer"===x?new o(f+h+w.length):new n(f+h+w.length),c=0;c<d.length;c++)b.append(d[c].fileRecord),b.append(d[c].compressedObject.compressedContent);for(c=0;c<d.length;c++)b.append(d[c].dirRecord);b.append(w);var y=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return e.transformTo(a.type.toLowerCase(),y);case"blob":return e.arrayBuffer2Blob(e.transformTo("arraybuffer",y),a.mimeType);case"base64":return a.base64?i.encode(y):y;default:return y}},crc32:function(a,b){return f(a,b)},utf8encode:function(a){return e.transformTo("string",m.utf8encode(a))},utf8decode:function(a){return m.utf8decode(a)}};b.exports=D},{"./base64":2,"./compressedObject":3,"./compressions":4,"./crc32":5,"./defaults":7,"./nodeBuffer":12,"./signature":15,"./stringWriter":17,"./support":18,"./uint8ArrayWriter":20,"./utf8":21,"./utils":22}],15:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],16:[function(a,b,c){"use strict";function d(a,b){this.data=a,b||(this.data=f.string2binary(this.data)),this.length=this.data.length,this.index=0,this.zero=0}var e=a("./dataReader"),f=a("./utils");d.prototype=new e,d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6,"./utils":22}],17:[function(a,b,c){"use strict";var d=a("./utils"),e=function(){this.data=[]};e.prototype={append:function(a){a=d.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=e},{"./utils":22}],18:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],19:[function(a,b,c){"use strict";function d(a){a&&(this.data=a,this.length=this.data.length,this.index=0,this.zero=0)}var e=a("./arrayReader");d.prototype=new e,d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./arrayReader":1}],20:[function(a,b,c){"use strict";var d=a("./utils"),e=function(a){this.data=new Uint8Array(a),this.index=0};e.prototype={append:function(a){0!==a.length&&(a=d.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=e},{"./utils":22}],21:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;h<256;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;b<h;)if(e=a[b++],e<128)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&b<h;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:e<65536?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;c<f;){var h=j(a,Math.min(c+g,f));e.uint8array?b.push(k(a.subarray(c,h))):b.push(k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":12,"./support":18,"./utils":22}],22:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;g<e&&b>1;)try{"array"===f||"nodebuffer"===f?d.push(String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e)))):d.push(String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a,b){c.checkSupport("blob"),b=b||"application/zip";try{return new Blob([a],{type:b})}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c}},{"./compressions":4,"./nodeBuffer":12,"./support":18}],23:[function(a,b,c){"use strict";function d(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var e=a("./stringReader"),f=a("./nodeBufferReader"),g=a("./uint8ArrayReader"),h=a("./arrayReader"),i=a("./utils"),j=a("./signature"),k=a("./zipEntry"),l=a("./support");a("./object");d.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+i.pretty(b)+", expected "+i.pretty(a)+")")},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=l.uint8array?"uint8array":"array",c=i.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(j.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===j.CENTRAL_FILE_HEADER;)a=new k({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(j.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,j.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip : can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(j.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,j.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,j.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){var b=i.getTypeOf(a);if(i.checkSupport(b),"string"!==b||l.uint8array)if("nodebuffer"===b)this.reader=new f(a);else if(l.uint8array)this.reader=new g(i.transformTo("uint8array",a));else{if(!l.array)throw new Error("Unexpected error: unsupported type '"+b+"'");this.reader=new h(i.transformTo("array",a))}else this.reader=new e(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./arrayReader":1,"./nodeBufferReader":13,"./object":14,"./signature":15,"./stringReader":16,"./support":18,"./uint8ArrayReader":19,"./utils":22,"./zipEntry":24}],24:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./stringReader"),f=a("./utils"),g=a("./compressedObject"),h=a("./object"),i=a("./support"),j=0,k=3;d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,e){return function(){var a=f.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==e)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize==-1||this.uncompressedSize==-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=f.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");if(this.decompressed=new g,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=f.transformTo("string",this.decompressed.getContent()),h.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch");
},readCentralPart:function(a){if(this.versionMadeBy=a.readInt(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readData(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===j&&(this.dosPermissions=63&this.externalFileAttributes),a===k&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=new e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=i.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=h.utf8decode(this.fileName),this.fileCommentStr=h.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileName)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileComment)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null}},b.exports=d},{"./compressedObject":3,"./object":14,"./stringReader":16,"./support":18,"./utils":22}],25:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":26,"./lib/inflate":27,"./lib/utils/common":28,"./lib/zlib/constants":31}],26:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":28,"./utils/strings":29,"./zlib/deflate":33,"./zlib/messages":38,"./zlib/zstream":40}],27:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":28,"./utils/strings":29,"./zlib/constants":31,"./zlib/gzheader":34,"./zlib/inflate":36,"./zlib/messages":38,"./zlib/zstream":40}],28:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],29:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":28}],30:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],31:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],32:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],33:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./messages":38,"./trees":39}],34:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],35:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],36:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,
n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./inffast":35,"./inftrees":37}],37:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":28}],38:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],39:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":28}],40:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn-bd": 76225,
	"./bn-bd.js": 76225,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-il": 47207,
	"./en-il.js": 47207,
	"./en-in": 44175,
	"./en-in.js": 44175,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./en-sg": 31662,
	"./en-sg.js": 31662,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-mx": 96112,
	"./es-mx.js": 96112,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fil": 42549,
	"./fil.js": 42549,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./ga": 29295,
	"./ga.js": 29295,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-deva": 27884,
	"./gom-deva.js": 27884,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it-ch": 10150,
	"./it-ch.js": 10150,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 12105,
	"./ka.js": 12105,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ku": 1408,
	"./ku.js": 1408,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mn": 5115,
	"./mn.js": 5115,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./oc-lnc": 92135,
	"./oc-lnc.js": 92135,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 79915,
	"./sr-cyrl.js": 79915,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./tg": 27321,
	"./tg.js": 27321,
	"./th": 9041,
	"./th.js": 9041,
	"./tk": 19005,
	"./tk.js": 19005,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./ug-cn": 9288,
	"./ug-cn.js": 9288,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-mo": 99807,
	"./zh-mo.js": 99807,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 32383:
/*!******************************!*\
  !*** ./resources/Account.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);

class Account extends EventEmitter {
   constructor() {
      super();

      this.isAuthenticated = false;
      this._config = null;

      this._listRoles = null;
      // {array}
      // a list of all the Defined Roles in the Tenant's system.

      this._listScopes = null;
      // {array | null}
      // a list of all the Defined Scopes in the Tenant's sytem.

      this._listUsers = null;
      // {array | null}
      // a list of all the Defined Users in the Tenant's system.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var UserConfig = this.AB.Config.userConfig();
      if (UserConfig) {
         this.isAuthenticated = true;
         this._config = UserConfig;
      }

      var MetaConfig = this.AB.Config.metaConfig();
      if (MetaConfig) {
         this._listRoles = MetaConfig.roles || [];
         this._listScopes = MetaConfig.scopes || [];
         this._listUsers = MetaConfig.users || [];
      }

      this.AB.Network.on("account.logout", (context, err, data) => {
         if (err) {
            console.error(err);
            return;
         }
         this.emit("logout", data);
      });

      return Promise.resolve();
   }

   isSystemDesigner() {
      return (
         this.roles((r) => r.uuid === "6cc04894-a61b-4fb5-b3e5-b8c3f78bd331")
            .length > 0
      );
   }

   email() {
      return this._config?.email ?? "";
   }

   language() {
      return this._config?.languageCode ?? "en";
   }

   logout() {
      return this.AB.Network.post(
         {
            url: "/auth/logout",
            data: { tenantUrl: this.AB.Tenant.setting("url") },
         },
         {
            key: "account.logout",
            context: {},
         }
      );
   }

   roles(fn = () => true) {
      return (this._config?.roles || []).filter(fn);
   }
   rolesAll() {
      return this._listRoles;
   }

   scopes() {
      return this._listScopes;
   }

   username() {
      return this._config?.username;
   }

   userList() {
      return this._listUsers;
   }

   uuid() {
      return this._config?.uuid;
   }

   imageID() {
      return this._config?.image_id;
   }

   sendEmailNotifications() {
      return this._config?.sendEmailNotifications;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Account());


/***/ }),

/***/ 50616:
/*!***********************************!*\
  !*** ./resources/Multilingual.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Multilingual
 * manage our multilingual Translations/Labels/etc.
 */

var MLClass = __webpack_require__(/*! ../AppBuilder/platform/ABMLClass */ 97069);

class Multilingual extends MLClass {
   constructor() {
      super([], {});
      // super()
      //    [] = no labels
      //    {} = placeholder ABFactory entry until .init() is called.

      this.isAuthenticated = false;
      this._config = null;

      this._missingLabelID = false;
      this._missingLabels = {};
      this._pluginLabelsMissing = {};
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.labels = this.AB.Config.labelConfig();

      this.pluginLabels = {};

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   currentLanguage() {
      return this.AB.Account.language();
   }

   label(key, altText, values = [], postMissing = true) {
      // part of our transition: L("single string") should start to work:
      if (typeof altText == "undefined" && key) {
         altText = key;
      }

      // other case: L("single string {0}", [])
      if (arguments.length == 2 && Array.isArray(altText)) {
         values = altText;
         altText = key;
      }

      // We need to escape " characters or else they will get added to the the lang.js
      // then we get errors next time we try to parse it as JSON (see appbuilder.label-missing)
      altText = altText.replace(/"/g, '\\"');
      key = key.replace(/"/g, '\\"');

      // NOTE: transition to new Labels
      // currently our code still uses the L(key, altText, values) format, but
      // the labels we get back are in L(altText, values) format.
      //
      // we are going to keep this like this until we have a well functioning
      // UI display of our Apps, which should flesh out most of the missing
      // labels to our files.
      //
      // After that, convert our L(k, t, v) to L(t, v)

      var newKey = altText;
      if (newKey[0] == "*") {
         newKey = newKey.slice(1);
      }
      var label = this.labels[newKey];
      if (!label) {
         if (postMissing) {
            this.postMissingLabel(key, altText);
         }
         label = altText;
      }

      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      label = label.replace(/\\"/g, '"'); // unescape " in the label
      return label;
   }

   labelPlugin(plugin, altText, values = []) {
      // 1st check to see if it is a common label from platform:
      var label = this.label(altText, altText, values, false);
      if (!label) {
         // ok, so check to see if it is a Plugin Label:
         label = this.pluginLabels[plugin][altText];
      }
      if (!label) {
         // !! record it missing.
         this._pluginLabelsMissing[plugin] =
            this._pluginLabelsMissing[plugin] || {};
         this._pluginLabelsMissing[plugin][altText] = altText;
         label = altText;
      }
      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      return label;
   }

   languages() {
      console.error(
         "Multilingual:languages(): Implement Language Storage/Retrieval."
      );
      return [];
   }

   pluginLoadLabels(key, labels) {
      this.pluginLabels[key] = labels;
   }
   pluginLabelReport(key) {
      console.warn("missing labels for plugin: ", key);
      console.warn("current language:", this.currentLanguage());
      var labels = JSON.stringify(this._pluginLabelsMissing[key], null, 3);
      console.warn(labels);
   }

   postMissingLabel(key, altText) {
      if (this._missingLabelID) {
         clearTimeout(this._missingLabelID);
      }
      var batchLength = 50;
      var sendBatch = () => {
         var batchLabels = [];
         let missingLabels = Object.keys(this._missingLabels).map(
            (k) => this._missingLabels[k]
         );
         if (missingLabels.length <= batchLength) {
            batchLabels = missingLabels;
            this._missingLabels = {};
         } else {
            for (var i = 0; i <= batchLength; i++) {
               var l = missingLabels.shift();
               batchLabels.push(l);
               delete this._missingLabels[l.key];
            }
         }
         this.AB.Network.post({
            url: "/multilingual/label-missing",
            data: { labels: JSON.stringify(batchLabels) },
         }).then(() => {
            if (Object.keys(this._missingLabels).length > 0) {
               sendBatch();
            }
         });
      };
      this._missingLabelID = setTimeout(() => {
         sendBatch();
      }, 1000);

      this._missingLabels[key] = { key, altText };
   }
   ///
   /// Disable un-needed ABMLClass functionality
   ///
   /// NOTE: we are mainly Piggybacking on ABMLClass for it's
   /// .translate() and .unTranslate() capabilities. So disable these
   /// for good measure.
   destroy() {
      console.error("Multilingual:destroy(): Should not be called.");
      return Promise.resolve();
   }
   save() {
      console.error("Multilingual:save(): Should not be called.");
      return Promise.resolve();
   }
   toObj() {
      console.error("Multilingual:toObj(): Should not be called.");
      return {};
   }
   toDefinition() {
      console.error("Multilingual:toDefinition(): Should not be called.");
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Multilingual());


/***/ }),

/***/ 66921:
/*!******************************!*\
  !*** ./resources/Network.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NetworkRest */ 59106);
/* harmony import */ var _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRestSocket */ 71204);
/*
 * Network.js
 * A network manager for interfacing with our AppBuilder server.
 */
var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);


// import NetworkRelay from "./NetworkRelay";

class Network extends EventEmitter {
   constructor() {
      super();

      this.setMaxListeners(0);
      // we'll have > 10 for sure!

      this.queueLock = null;
      // {Lock} .queueLock
      // our semaphore for coordinating our access to our local storage.

      this._config = null;
      this._network = null;
      // {NetworkRelay | NetworkRest | NetworkSocket}
      // the underlying Network connection object actually performing the
      // communications with the Server.
      // Which one is specified in the config.appbuilder.networkType setting

      this._queueCount = 0;
      // {int} _queueCount
      // the # of network operations currently queued, pending Network
      // reconnect.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.queueLock = new this.AB.Lock();

      this._config = this.AB.Config.siteConfig();
      if (this._config) {
         switch (this._config.appbuilder.networkType) {
            case "relay":
               // this._network = new NetworkRelay();
               break;

            case "socket":
               this._network = new _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_0__["default"](this);
               break;

            case "rest":
            default:
               this._network = new _NetworkRest__WEBPACK_IMPORTED_MODULE_1__["default"](this);
               break;
         }

         return this._network.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      //
      // Handle reconnections and flushing the Queue:
      //
      if (io && io.socket) {
         // When our Socket reconnects, be sure to flush any pending transactions.
         io.socket.on("connected", () => {
            this.queueFlush();
            if (this.idConnectionCheck) {
               clearTimeout(this.idConnectionCheck);
               this.idConnectionCheck = null;
            }
         });
      } else {
         console.error("!!! Network.init() : Did not find io.socket");
         window.addEventListener("online", () => this.queueFlush());
      }

      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.isRealTime
    * indicates wether or not the current network connection supports
    * RealTime updates.
    * @return {bool}
    */
   get isRealTime() {
      return this._network.isRealTime;
   }

   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(...params) {
      return this._network.get(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * this is a CREATE operation.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(...params) {
      return this._network.post(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * This is for UPDATE/REPLACE operations to data on the server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(...params) {
      return this._network.put(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(...params) {
      return this._network.delete(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   ////
   //// Network Utilities
   ////

   _connectionCheck() {
      // if (!this.idConnectionCheck) {
      if (this.isNetworkConnected()) {
         this.queueFlush().catch(() => {
            // on an error, we are still having connection issues
            this.idConnectionCheck = setTimeout(() => {
               this._connectionCheck();
            }, 250);
         });
         this.idConnectionCheck = null;
      } else {
         this.idConnectionCheck = setTimeout(() => {
            this._connectionCheck();
         }, 250);
      }
      // }
   }

   /**
    * @method networkStatus
    * return the connection type currently registered with the network
    * plugin.
    * @return {string}
    */
   networkStatus() {
      return navigator.connection.type;
   }

   /**
    * @method isNetworkConnected
    * return true/false if the device is currently connected to the
    * internet.
    * @return {bool}
    */
   isNetworkConnected() {
      // if this is a Web Client and using sails.socket.io
      if (io && io.socket && io.socket.isConnected) {
         return io.socket.isConnected();
      }

      // if this isn't a Cordova Plugin, then return navigator data:
      if (typeof Connection == "undefined") {
         // NOTE: this technically only detects if we are connected to a
         // network.  It doesn't guarantee we can communicate across the 'net
         return navigator.onLine;
      }

      // Cordova Plugin:
      return this.networkStatus() != Connection.NONE;
   }

   /**
    * publishResponse()
    * emit the requested response for this network operation.
    * @param {obj} jobResponse
    * @param {obj} error
    * @param {obj} data
    */
   publishResponse(jobResponse, error, data) {
      if (data) {
         data = this.normalizeData(data);
      }
      this.emit(jobResponse.key, jobResponse.context, error, data);
   }

   normalizeData(data) {
      // Data returning from our server is wrapped in an outer layer of
      // information that is for our Networking API.
      // the outer wrapper should be:
      // on success :
      // {
      //   status: "success",
      //   data:{Data For App}
      // }
      // on Error:
      // {
      //   status: "error",
      //   id: {int} error code
      //   ... other data here
      // }

      // we have physically received a data packet from the server,
      // but we are informed that our transaction was problematic
      // (400 level USER problem?)
      if (data.status === "error") {
         // TODO: review Error procedure here
         return data;
      }

      // on success
      // make sure we return the Application Level Data packet:
      return data.data || data;
   }

   ////
   //// Queued Requests
   ////

   /**
    * refQueue()
    * sub classes can override this for their own separate Queue Data
    * @return {string}
    */
   refQueue() {
      return "networkQueue";
   }

   /**
    * queueCount()
    * return the # of messages in the queue.
    * @return {int}
    */
   queueCount() {
      return this._queueCount;
   }

   /**
    * Adds a request to the outgoing queue.
    *
    * @param {object} data
    * @param {object} jobResponse
    * @return {Promise}
    */
   queue(data, jobResponse) {
      var refQueue = this.refQueue();

      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })
            .then((queue) => {
               queue = queue || [];
               queue.push({ data, jobResponse });
               this.AB.log(
                  `:::: ${queue.length} request${
                     queue.length > 1 ? "s" : ""
                  } queued`
               );
               this._queueCount = queue.length;
               return this.AB.Storage.set(refQueue, queue);
            })
            .then(() => {
               this.emit("queued");
               // if we are not already polling the network, start
               if (!this.idConnectionCheck) {
                  this._connectionCheck();
               }
               this.queueLock.release();
               resolve();
            })
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "Error while queueing data",
               });
               this.AB.Analytics.logError(err);
               reject(err);

               this.queueLock.release();
            });
      });
   }

   /**
    * queueFlush()
    * Flush the queue and send the contents to the relay server.
    */
   queueFlush() {
      var refQueue = this.refQueue();

      // if we are not connected, then stop
      if (!this.isNetworkConnected()) {
         var error = new Error("Not connected to the internet.");
         error.code = "E_NOTCONNECTED";
         return Promise.reject(error);
      }

      // otherwise, attempt to flush the queue:
      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()

            //
            // Get queue contents
            //
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })

            //
            // Send off each queued request
            //
            .then((queue) => {
               // default to [] if not found
               queue = queue || [];

               // recursively process each pending queue request
               var processRequest = (cb) => {
                  if (queue.length == 0) {
                     cb();
                  } else {
                     var entry = queue.shift();
                     var params = entry.data;
                     var job = entry.jobResponse;
                     this._network
                        .resend(params, job)
                        .then(() => {
                           processRequest(cb);
                        })
                        .catch((err) => {
                           // if the err was due to a network connection error
                           if (err && err.code == "E_TOMANYRETRIES") {
                              cb(err);
                              return;
                           }
                           // otherwise, try the next
                           processRequest(cb);
                        });
                  }
               };

               return new Promise((res, rej) => {
                  processRequest((err) => {
                     if (err) {
                        rej(err);
                     } else {
                        res();
                     }
                  });
               });
            })

            //
            // Clear queue contents
            //
            .then(() => {
               this._queueCount = 0;
               return this.AB.Storage.set(refQueue, []);
            })

            // release the Lock
            .then(() => {
               this.emit("queue.synced");
               return this.queueLock.release();
            })

            // all done.
            .then(() => {
               resolve();
            })

            // respond to errors:
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "commAPI queueFlush error",
               });
               this.AB.Analytics.logError(err);

               this.queueLock.release().then(() => {
                  reject(err);
               });
            });
      });
   }

   /**
    * Reset credentials to a blank state.
    * @return {Promise}
    */
   reset() {
      return Promise.resolve();
   }

   /**
    * type()
    * return the type of network connection we are using.
    * ["rest", "socket", "relay"]
    * @return {string}
    */
   type() {
      return this._config.appbuilder.networkType;
   }

   // uuid() {
   //    return this.AB.uuid();
   // }

   getTokens() {
      // called in appPage.js : openRelayLoader()
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Network());


/***/ }),

/***/ 59106:
/*!**********************************!*\
  !*** ./resources/NetworkRest.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */

/* global navigator Connection */
// import Account from "./Account";
// import analytics from "./Analytics";
// import EventEmitter from "eventemitter2";
var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);
// import Lock from "./Lock";

// import { storage } from "./Storage";
// import Tenant from "./Tenant";
// import { v4 as uuidv4 } from "uuid";

// Temp placeholders until Resources are implemented:

// End Temp

const Atomic = __webpack_require__(/*! atomicjs/dist/atomic.min.js */ 58459);
// Atomic : a small $.ajax() replacement

var Config = null;
// {} Config
// the site specific configuration information

class NetworkRest extends EventEmitter {
   constructor(parent) {
      // {Network} parent

      super({
         wildcard: true,
         newListener: false,
         maxListeners: 0,
      });

      this.baseURL = null;
      // {string} .baseURL
      // the url of our site.

      this.numRetries = 3;
      // {int} .numRetries
      // the number or times we should attempt to issue a network request.

      this._network = parent;
      // {Network} ._network
      // the Parent Network Resource that the rest of the Platform actually
      // works with.

      this.isRealTime = false;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);
   }

   /**
    * @method init
    * @param {ABFactory} AB
    * @param {object} options
    * @param {string} options.baseURL
    * @return {Promise}
    */
   init(AB, options) {
      this.AB = AB;

      Config = this.AB.Config.siteConfig();
      options = options || {};
      if (options) {
         this.baseURL = options.baseURL || Config.appbuilder.urlCoreServer;
         this.numRetries =
            options.networkNumRetries || Config.appbuilder.networkNumRetries;
      }
      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(params, jobResponse) {
      params.type = params.type || "GET";

      // data sent to params on a "GET" request need to be converted to
      // uri querystring values:
      var data = params.data || params.params;
      if (data) {
         var useThese = ["string", "number", "boolean"];
         var search = Object.keys(data)
            .map(function (key) {
               var val = data[key];
               if (useThese.indexOf(typeof val) == -1) {
                  val = JSON.stringify(val);
               }
               return key + "=" + encodeURIComponent(val);
            })
            .join("&");

         var join = "?";
         if (params.url.indexOf("?") > -1) {
            join = "&";
         }
         params.url = [params.url, search].join(join);
      }

      return this._request(params, jobResponse);
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(params, jobResponse) {
      params.type = params.type || "POST";
      return this._request(params, jobResponse);
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(params, jobResponse) {
      params.type = params.type || "PUT";
      return this._request(params, jobResponse);
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(params, jobResponse) {
      params.type = params.type || "DELETE";
      return this._request(params, jobResponse);
   }

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return this._network.isNetworkConnected();
   }

   salSend(params) {
      return Atomic(params.url, params).then((packet) => {
         // {json} packet
         // the response from Atomic is in format:
         // {data: {…}, xhr: XMLHttpRequest}
         // we just want to send back our { status:"", data:xxx } packet.
         return packet.data;
      });
   }

   /**
    * _request()
    * perform the actual AJAX request for this operation.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   _request(params, jobResponse) {
      // make sure we don't process too many retries:
      params._retry = params._retry || 0;
      if (params._retry >= this.numRetries) {
         var err = new Error(
            `Too many retries (${this.numRetries}) for ${params.url}`
         );
         err.code = "E_TOMANYRETRIES";
         this.AB.notify.developer(err, {
            context: "NetworkRest:_request: Too Many Retries",
         });
         // this.AB.Analytics.logError(err);
         if (jobResponse) {
            this._network.publishResponse(jobResponse, err);
         }

         return Promise.reject(err);
      }

      return new Promise((resolve, reject) => {
         params.url = params.url || "/";
         if (params.url[0] == "/") {
            params.url = this.baseURL + params.url;
         }

         params.headers = params.headers || {};
         if (this.AB.Account.authToken) {
            params.headers.Authorization = this.AB.Account.authToken;
         }
         params.headers["Content-type"] = "application/json";

         var tenantID = this.AB.Tenant.id();
         if (tenantID) {
            params.headers["tenant-token"] = tenantID;
         }

         // params.timeout = params.timeout || 6000;

         if (this.isNetworkConnected()) {
            params.method = params.method || params.type;
            params.timeout = 6000; // ??
            params.data = params.data || params.params;
            delete params.params;

            this.salSend(params)
               .then((packet) => {
                  // TODO: check if packet.status == "error"
                  // and then .publishResponse() as an error

                  //
                  var data = packet;
                  if (jobResponse) {
                     this._network.publishResponse(jobResponse, null, data);
                  }
                  resolve(data);
               })
               .catch((err) => {
                  // err.status
                  // err.statusText
                  // err.responseText
                  // err.message  {socket}
                  // err.stack    {socket}

                  // if this is a network connection error, send the attempt again:
                  if (
                     err.statusText == "Request timeout" ||
                     (err.message && err.message.indexOf("disconnected") > -1)
                  ) {
                     //// Network Error: conneciton refused, access denied, etc...
                     this.AB.Analytics.log(
                        "NetworkRest._request():network connection error detected. Trying again"
                     );

                     params._retry++;

                     // retry the attempt:
                     this._request(params)
                        .then((data) => {
                           // console.log('--- timeout.then():',data);
                           this.AB.warn(
                              "*** NetworkRest._request().then(): attempt resolved."
                           );
                           resolve(data);
                        })
                        .catch((_err) => {
                           this.AB.notify.developer(_err, {
                              message: "*** NetworkRest._request().catch(): retry failed:",
                           });
                           reject(_err);
                        });

                     return;
                  } else {
                     // Else attempt to emit() some common Error types for
                     // additional Platform Handling.
                     if (err.status == 403) {
                        this.emit("error.badAuth", err);
                     } else if (err.status >= 400 && err.status < 500) {
                        this.emit("error.badRequest", err);
                     } else if (err.status >= 500) {
                        this.emit("error.badServer", err);
                     }
                  }

                  var packet = null;
                  if (err.responseText) {
                     try {
                        packet = JSON.parse(err.responseText);
                     } catch (e) {}
                  }
                  // if this is an req.ab.error() response:
                  if (packet && packet.status == "error") {
                     // check if REAUTH Error:
                     if (packet.id == 5 || packet.code == "E_REAUTH") {
                        this._network.emit("reauth");
                        return;
                     }

                     this.AB.notify.developer(packet, {
                        context:
                           "NetworkRest:_request:Error returned from Server (req.ab.error())",
                        data: packet.data,
                     });
                     // this.AB.Analytics.logError(packet.data);
                     // this.AB.error(packet.data);
                     if (jobResponse) {
                        this._network.publishResponse(
                           jobResponse,
                           packet,
                           null
                        );
                     }
                     return reject(packet.data);
                  } else {
                     // unknown/unexpected error:
                     var error = new Error(
                        `${err.status} ${err.statusText || err.message}: ${
                           params.method
                        } ${params.url}`
                     );
                     error.response = err.responseText;
                     error.text = err.statusText;
                     error.err = err;
                     error.url = `${params.method} ${params.url}`;
                     this.AB.notify.developer(error, {
                        context:
                           "NetworkRest:_request:Unknown Error returned from server",
                     });
                     // this.AB.Analytics.logError(error);
                     // this.AB.error(error);
                     if (jobResponse) {
                        this._network.publishResponse(jobResponse, error);
                     }
                     return reject(error);
                  }
               });
         } else {
            // now Queue this request params.
            this.AB.Analytics.log(
               "NetworkRest:_request(): Network is offline. Queuing request."
            );
            this._network
               .queue(params, jobResponse)
               .then(() => {
                  resolve({ status: "queued" });
               })
               .catch(reject);
         }
      });
   }

   /**
    * resend()
    * processes messages that were queued due to network connectivity
    * issues.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   resend(params, jobResponse) {
      // var op = params.type.toLowerCase();
      return this._request(params, jobResponse);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRest);


/***/ }),

/***/ 71204:
/*!****************************************!*\
  !*** ./resources/NetworkRestSocket.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRest */ 59106);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */



const listSocketEvents = [
   // NOTE: ABFactory.definitionXXX() will manage emitting these
   // events internally:
   // "ab.abdefinition.create",
   // "ab.abdefinition.update",
   // "ab.abdefinition.delete",
   "ab.datacollection.create",
   "ab.datacollection.update",
   "ab.datacollection.stale",
   "ab.datacollection.delete",
   "ab.inbox.create",
   // "ab.object.update",
];
// {array}
// The io.socket.* events we are listening for that relate to our datacollection
// maintainence.

class NetworkRestSocket extends _NetworkRest__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super(parent);

      this.isRealTime = true;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);

      // Pass the io.socket.on(*) events to our AB factory.
      listSocketEvents.forEach((ev) => {
         io.socket.on(ev, (data) => {
            // check if the ev contains 'datacollection'
            // and do a single normalizeData() on the incoming data here
            // before sending it off to be processed.
            if (ev.indexOf("ab.datacollection") > -1) {
               let values = data.data;
               if (values) {
                  let obj = this.AB.objectByID(data.objectId);
                  if (obj) {
                     let model = obj.model();
                     if (ev != "ab.datacollection.delete")
                        model.normalizeData(data.data);
                  }
               }
            }
            this.AB.emit(ev, data);
         });
      });
   }

   //
   // Interface API
   //

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return io.socket.isConnected();
   }

   salSend(params) {
      return new Promise((resolve, reject) => {
         params.method = params.method.toLowerCase();

         io.socket.request(params, (data, jwres) => {
            // {json} data
            // the data response from the request
            // {json} jwres
            // A JSON WebSocket Response object.
            //    {json} jwres.headers :  header values
            //    {int}  jwres.statusCode : http response code
            //    {json} jwres.body === resData

            // if this is an  error
            if (jwres.statusCode >= 400) {
               // Our NetworkRest.error( err ) should be in this format:
               // err.status
               // err.statusText
               // err.responseText

               var errStr = jwres.error ? jwres.error.toString() : jwres.body;

               var err = new Error(`Socket Error: ${errStr}`);
               err.status = jwres.statusCode;
               err.statusText = errStr;
               err.responseText = jwres.body;

               // on RequestTimeout:
               // err.statusText == "Request timeout"

               reject(err);
            } else {
               // some errors like socket disconnected return an Error for data
               if (data instanceof Error) {
                  reject(data);
                  return;
               }

               if (typeof data == "string") {
                  data = JSON.parse(data);
               }

               // Got a JSON response but was the service response an error?
               // this would be a strange case where the .statusCode < 400
               if (data.status && data.status == "error") {
                  // make sure to reject an err.responseText = data
                  reject({
                     status: jwres.statusCode,
                     responseText: JSON.Stringify(data),
                  });
               }
               // Success!
               else {
                  resolve(data);
               }
            }
         });
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRestSocket);


/***/ }),

/***/ 53113:
/*!******************************!*\
  !*** ./resources/Storage.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StorageLocal.js */ 33819);
var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);



class Storage extends EventEmitter {
   constructor() {
      super();

      this.tenantStorage = null;
      this._config = null;
      this._storage = null;
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var config = this.AB.Config.siteConfig();
      if (config) {
         if (config.storage && config.storage.encrypted) {
            console.error("TODO: Implement Encrypted Storage");
            // this._storage = StorageEncrypted;
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__["default"];
         } else {
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__["default"];
         }

         return this._storage.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      return Promise.resolve();
   }

   set(...params) {
      return this._storage.set(...params);
   }

   get(...params) {
      return this._storage.get(...params);
   }

   clear(...params) {
      return this._storage.clear(...params);
   }

   clearAll(...params) {
      return this._storage.clearAll(...params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Storage());


/***/ }),

/***/ 33819:
/*!***********************************!*\
  !*** ./resources/StorageLocal.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * StorageLocal
 *
 * An interface for storing and retrieving Client Side data.  Data stored
 * in StorageLoacal is NOT encrypted.
 *
 * This implementation is based upon the webix.storage.local library.
 * See: https://docs.webix.com/api__refs__storage.local.html
 *
 */

var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);

class StorageLocal extends EventEmitter {
   constructor() {
      super();

      this.tenantStorage = null;
      // {Webix.storage} object.
      // We divide the storage data according to the tenant we are working
      // with.  This way Users who can move between different Tenants can
      // keep their local data separated.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var tenantID = this.AB.Tenant.id();
      if (!tenantID) {
         tenantID = "noAuth";
         // "noAuth" is considered the tenant on our Login sequence
         // which should have a minimum of data stored (language maybe?)
      }

      this.tenantStorage = this.AB.Webix.storage.prefix(
         tenantID,
         this.AB.Webix.storage.local
      );

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   set(key, value /* , options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.put(key, value);
      });
   }

   get(key /*, options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.get(key);
      });
   }

   clear(key) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.remove(key);
      });
   }

   clearAll() {
      return Promise.resolve().then(() => {
         return this.tenantStorage.clear();
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StorageLocal());


/***/ }),

/***/ 23325:
/*!*****************************!*\
  !*** ./resources/Tenant.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _config_Config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/Config.js */ 24998);
var EventEmitter = (__webpack_require__(/*! events */ 17187).EventEmitter);



class Tenant extends EventEmitter {
   constructor() {
      super();

      this.text = false;
      this._config = null;
      this.textClickToEnter = null;
   }

   init() {
      var config = _config_Config_js__WEBPACK_IMPORTED_MODULE_0__["default"].tenantConfig();
      if (config) {
         // check if we have options that are stored as a string
         if (
            typeof config.options === "string" ||
            config.options instanceof String
         ) {
            // if we do try to parse them into a JSON object
            try {
               config.options = JSON.parse(config.options);
            } catch (error) {
               console.error(error);
            }
         }
         this._config = config;
         this.textClickToEnter = config.options.textClickToEnter;
      }

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   id() {
      if (this._config.id == "??") {
         return null;
      }
      return this._config.id;
   }

   setting(key, value) {
      if (value) {
         this._config.options[key] = value;
         return;
      }
      return this._config.options[key];
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Tenant());


/***/ }),

/***/ 99391:
/*!***********************************************!*\
  !*** ./webix_custom_components/activelist.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * custom_activelist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomActiveList {
   get key() {
      return "activelist";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.list, webix.ActiveContent);
   }
};


/***/ }),

/***/ 60183:
/*!************************************************!*\
  !*** ./webix_custom_components/countfooter.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * countfooter
 *
 * Add the count footer to the webix's datatable.
 *
 */

module.exports = class ABCountFooter {
   get key() {
      return "countfooter";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {};

      // internal list of Webix IDs to reference our UI components.
      var ids = {};

      // Our webix UI definition:
      var _ui = {};
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix :
      webix.ui.datafilter.countColumn = webix.extend(
         {
            refresh: function (datatable, node, info) {
               var result = 0;

               var rowData = datatable.find({}) || [];
               rowData.forEach((row) => {
                  if (row == null) return;

                  var data =
                     row[info.columnId] || row[info.columnId + "__relation"];

                  // array
                  if (data && Array.isArray(data)) {
                     result += data.length;
                  } else if (
                     data != null &&
                     data != "" &&
                     data != false &&
                     data != "false" &&
                     data != "0"
                  ) {
                     result += 1;
                  }
               });

               node.innerHTML = result;
            },
         },
         webix.ui.datafilter.summColumn
      );
   }
};


/***/ }),

/***/ 12864:
/*!***********************************************************!*\
  !*** ./webix_custom_components/customComponentManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Custom Component Manager
 * Make sure our {ABComponent}s are initialized with our custom
 * Webix Components.
 */

// Import our Custom Components here:
var componentList = [
   __webpack_require__(/*! ./activelist */ 99391),
   __webpack_require__(/*! ./countfooter */ 60183),
   __webpack_require__(/*! ./datetimepicker */ 68362),
   __webpack_require__(/*! ./editlist */ 16944),
   __webpack_require__(/*! ./edittree */ 10511),
   __webpack_require__(/*! ./editunitlist */ 41471),
   __webpack_require__(/*! ./focusableTemplate */ 56562),
   __webpack_require__(/*! ./formioBuilder */ 97272),
   __webpack_require__(/*! ./formioPreview */ 29008),
   __webpack_require__(/*! ./numbertext */ 84756),
   __webpack_require__(/*! ./timepicker */ 17943),
   __webpack_require__(/*! ./totalfooter */ 64603),
   __webpack_require__(/*! ./treesuggest */ 45835),
   // require('./savablelayout')
];

module.exports = class ABCustomComponentManager {
   constructor() {}

   initComponents(App) {
      App.custom = App.custom || {};

      componentList.forEach((Component) => {
         var component = new Component(App);
         App.custom[component.key] = component;
      });

      // Transition to v2:
      App.AB.custom = App.custom;
   }
};


/***/ }),

/***/ 68362:
/*!***************************************************!*\
  !*** ./webix_custom_components/datetimepicker.js ***!
  \***************************************************/
/***/ ((module) => {

/*
 * custom_datetimepicker
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomDateTimePicker {
   //.extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "datetimepicker";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // componentKey {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: App.unique("custom_datetimepicker") // keep this unique for this App instance.
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.editors.$popup.datetime = {
         view: "popup",
         width: 250,
         height: 250,
         padding: 0,
         body: {
            view: "calendar",
            icons: true,
            borderless: true,
            timepicker: true
         }
      };

      webix.editors.datetime = webix.extend(
         {
            popupType: "datetime"
         },
         webix.editors.date
      );
   }
};


/***/ }),

/***/ 16944:
/*!*********************************************!*\
  !*** ./webix_custom_components/editlist.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * custom_editlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "editlist";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.list);
   }
};


/***/ }),

/***/ 10511:
/*!*********************************************!*\
  !*** ./webix_custom_components/edittree.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * custom_edittree
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditTree {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "edittree";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.tree);
   }
};


/***/ }),

/***/ 41471:
/*!*************************************************!*\
  !*** ./webix_custom_components/editunitlist.js ***!
  \*************************************************/
/***/ ((module) => {

/*
 * custom_editunitlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditUnitList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "editunitlist";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);
      /*
      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };
*/
      // Our webix UI definition:
      var _ui = {
         name: this.key,
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.unitlist);
   }
};


/***/ }),

/***/ 56562:
/*!******************************************************!*\
  !*** ./webix_custom_components/focusableTemplate.js ***!
  \******************************************************/
/***/ ((module) => {

/*
 * custom_activelist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomFocusableTemplate {
   get key() {
      return "focusabletemplate";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         focus: function() {
            return false;
         }
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.template, webix.UIManager);
   }
};


/***/ }),

/***/ 97272:
/*!**************************************************!*\
  !*** ./webix_custom_components/formioBuilder.js ***!
  \**************************************************/
/***/ ((module) => {

/*
 * formioBuilder
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomFormIOBuilder {
   get key() {
      return "formiobuilder";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // We need to reference this on the save so lets put it in a global var
      var formBuilder;

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         defaults: {
            css: "scrolly forceOpen",
            hidden: false,
            autofit: true,
         },
         $init: function (config) {
            var comp = _logic.parseDataFields(config.dataFields);
            var formComponents = config.formComponents
               ? config.formComponents
               : {};
            Formio.builder(this.$view, formComponents, {
               builder: {
                  basic: false,
                  advanced: false,
                  // data: false,
                  customBasic: false,
                  premium: false,
                  custom: {
                     title: "Fields",
                     weight: 0,
                     default: true,
                     components: comp,
                  },
                  layout: {
                     components: {
                        table: true,
                     },
                  },
               },
            }).then(function (builder) {
               // now that it is set up we can push it into the global var
               // builder.submission = {
               //     data: {
               //         Name: "James",
               //         "Number Field": 3
               //     }
               // };
               formBuilder = builder;
            });
         },
         // set up a function that can be called to request the form schema
         getFormData: () => {
            return formBuilder.schema;
         },
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {
         /**
          * @method parseDataObjects
          *
          * @param store {webix.TreeCollection}
          * @param elem {Object} the webix element
          * @param parentId {integer - nullable} id of parent id
          */
         parseDataFields: (fields) => {
            var components = {};
            // objects.forEach((obj) => {
            //     var fields = obj.fields();
            //     console.log(fields);
            fields.forEach((entry) => {
               if (!entry.field) return;
               switch (entry.field.key) {
                  case "boolean":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "checkbox",
                           disabled: true,
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                        },
                     };
                     break;
                  case "calculate":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "textfield",
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                           inputType: "text",
                           disabled: true,
                           calculateValue:
                              "value = " +
                              entry.field.settings.formula
                                 .replace(/{/g, "data['")
                                 .replace(/}/g, "']"),
                        },
                     };
                     break;
                  case "connectObject":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "textfield",
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                           inputType: "text",
                           disabled: true,
                           calculateValue: `value = data['${entry.key}.format']`,
                           // ,calculateValue: `value = '${entry.field.settings.textFormula}'`
                        },
                     };
                     break;

                  case "date":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "datetime",
                           disabled: true,
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                           format:
                              entry.field.settings.timeFormat == 1
                                 ? "MMMM d, yyyy"
                                 : "MMMM d, yyyy h:mm a",
                        },
                     };
                     break;
                  case "email":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           disabled: true,
                           type: "email",
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                        },
                     };
                     break;
                  case "file":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "htmlelement",
                           tag: "a",
                           className: "btn btn-primary btn-block",
                           content:
                              "<i class='fa fa-paperclip'></i>  " +
                              "{{JSON.parse(data['" +
                              entry.key +
                              "']).filename}}",
                           attrs: [
                              {
                                 attr: "href",
                                 value:
                                    "/opsportal/file/" +
                                    entry.field.object.application.name +
                                    "/" +
                                    "{{JSON.parse(data['" +
                                    entry.key +
                                    "']).uuid}}",
                              },
                              {
                                 attr: "target",
                                 value: "_blank",
                              },
                           ],
                           refreshOnChange: true,
                           key: entry.key,
                           _key: entry.key,
                           disabled: true,
                           input: false,
                        },
                     };
                     break;
                  case "image":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "htmlelement",
                           tag: "img",
                           className: "img-thumbnail max100",
                           content: "",
                           attrs: [
                              {
                                 attr: "src",
                                 value:
                                    "/opsportal/image/" +
                                    entry.field.object.application.name +
                                    "/" +
                                    "{{data['" +
                                    entry.key +
                                    "']}}",
                              },
                           ],
                           refreshOnChange: true,
                           key: entry.key,
                           _key: entry.key,
                           input: false,
                        },
                     };
                     break;
                  case "list":
                     var vals = [];
                     entry.field.settings.options.forEach((opt) => {
                        vals.push({
                           label: opt.text,
                           value: opt.id,
                        });
                     });
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "select",
                           key: entry.key,
                           _key: entry.key,
                           disabled: true,
                           input: true,
                           data: {
                              values: vals,
                           },
                           multiple: entry.field.settings.isMultiple,
                        },
                     };
                     break;
                  case "LongText":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "textarea",
                           disabled: true,
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                        },
                     };
                     break;
                  case "number":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           disabled: true,
                           type: "number",
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                        },
                     };
                     break;
                  case "TextFormula":
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "textfield",
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                           inputType: "text",
                           disabled: true,
                           calculateValue:
                              "value = '" +
                              entry.field.settings.textFormula +
                              "'",
                        },
                     };
                     break;
                  default:
                     components[entry.key] = {
                        title: entry.label,
                        key: entry.key,
                        icon: entry.field.icon,
                        schema: {
                           abFieldID: entry.field.id,
                           label: entry.field.label,
                           type: "textfield",
                           disabled: true,
                           key: entry.key,
                           _key: entry.key,
                           input: true,
                        },
                     };
                     break;
               }
            });
            // });
            components["approveButton"] = {
               title: "Approve Button",
               key: "approve",
               icon: "check-square",
               schema: {
                  label: "Approve",
                  type: "button",
                  key: "approve",
                  event: "approve",
                  block: true,
                  size: "lg",
                  input: false,
                  leftIcon: "fa fa-thumbs-up",
                  action: "event",
                  theme: "success",
               },
            };
            components["denyButton"] = {
               title: "Deny Button",
               key: "deny",
               icon: "ban",
               schema: {
                  label: "Deny",
                  type: "button",
                  key: "deny",
                  event: "deny",
                  block: true,
                  size: "lg",
                  input: false,
                  leftIcon: "fa fa-thumbs-down",
                  action: "event",
                  theme: "danger",
               },
            };
            components["customButton"] = {
               title: "Custom Action Button",
               key: "custom",
               icon: "cog",
               schema: {
                  label: "Custom Name",
                  type: "button",
                  key: "custom",
                  event: "yourEvent",
                  block: true,
                  size: "lg",
                  input: false,
                  leftIcon: "fa fa-cog",
                  action: "event",
                  theme: "primary",
               },
            };
            return components;
         },
      };
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.popup);
   }
};


/***/ }),

/***/ 29008:
/*!**************************************************!*\
  !*** ./webix_custom_components/formioPreview.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * formioBuilder
 *
 * Create a custom webix component.
 *
 */
var ABEmitter = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter.js */ 73686);
module.exports = class ABCustomFormIOPreview extends ABEmitter {
   get key() {
      return "formiopreview";
   }

   constructor(App) {
      super();

      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var _this = this;
      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         defaults: {
            css: "scrolly",
            borderless: true,
         },
         $init: function (config) {
            var formComponents = config.formComponents
               ? config.formComponents
               : {};
            var formData = config.formData ? config.formData : {};
            // we need to find out when we are passing an array of objects and reduce it down to an array of IDs
            for (var data in formData) {
               if (
                  Array.isArray(formData[data]) &&
                  typeof formData[data][0] == "object"
               ) {
                  var newD = [];
                  formData[data].forEach((item) => {
                     if (item.id) newD.push(item.id);
                  });
                  formData[data] = newD;
               }
            }

            Formio.createForm(this.$view, formComponents, {
               // readOnly: true
               // sanitizeConfig: {
               //     addTags: ["a", "label", "img", "i"],
               //     addAttr: ["src", "href", "class", "target"]
               // }
            }).then(function (form) {
               // now that it is set up we can push it into the global var
               // formBuilder = builder;
               // Provide a default submission.
               form.submission = {
                  data: formData,
               };
               (formComponents.components || []).forEach((comp) => {
                  if (
                     comp.type == "button" &&
                     comp.action == "event" &&
                     comp.event
                  ) {
                     form.once(comp.event, function (click) {
                        config.onButton ? config.onButton(comp.event) : null;
                        // _this.emit("button", comp.event);
                     });
                  }
               });
               // form.submission = {
               //     data: {
               //         Name: "Item #5",
               //         Image: "4f2be24f-6ad0-4687-abbb-1a87ce7bc1d6",
               //         "Long text": "This is a long text field.",
               //         "Number Field": 3,
               //         "Date Field": "2020-02-03",
               //         "Date and Time": "2020-02-19 00:00:00",
               //         "Checkbox field": 1,
               //         "Items to select": 1580782610224,
               //         "Multiple Items": [1580786381276, 1580786381494],
               //         "Email Field": "james@digiserve.org",
               //         "Image Field":
               //             "d5063af3-06b0-44d0-ae9d-c88a74b81e21",
               //         "File Attachment":
               //             '{"uuid":"2d3708eb-d567-483b-9b1e-7cbd6d654866","filename":"2018-01-12 09-44 copy.pdf"}',
               //         "User Field": "James"
               //     }
               // };
            });
         },
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.view);
   }
};


/***/ }),

/***/ 84756:
/*!***********************************************!*\
  !*** ./webix_custom_components/numbertext.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * numbertext
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomNumberText {
   get key() {
      return "numbertext";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,

         defaults: {
            css: "webix_el_text"
         },

         // override this function to return number value type
         $getValue: function() {
            var val = this.getInputNode().value;
            if (val) return JSON.parse(val);
            // Convert to number
            else return "";
         }
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.text);
   }
};


/***/ }),

/***/ 17943:
/*!***********************************************!*\
  !*** ./webix_custom_components/timepicker.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * custom_timepicker
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomTimePicker {
   //.extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "timepicker";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // componentKey {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: App.unique("custom_timepicker") // keep this unique for this App instance.
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.editors.$popup.time = {
         view: "popup",
         body: {
            view: "calendar",
            width: 220,
            height: 200,
            type: "time"
         }
      };

      webix.editors.time = webix.extend(
         {
            popupType: "time"
         },
         webix.editors.date
      );
   }
};


/***/ }),

/***/ 64603:
/*!************************************************!*\
  !*** ./webix_custom_components/totalfooter.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * totalfooter
 *
 * Add the contents of records to show in footer of the webix's datatable.
 *
 */

module.exports = class ABTotalFooter {
   get key() {
      return "totalfooter";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {};

      // internal list of Webix IDs to reference our UI components.
      var ids = {};

      // Our webix UI definition:
      var _ui = {};
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix :
      webix.ui.datafilter.totalColumn = webix.extend(
         {
            refresh: function (datatable, node, info) {
               var result = 0;

               datatable.eachRow(function (row) {
                  var record = datatable.getItem(row);

                  var data = info.field.format(record);

                  // array
                  if (data) {
                     result += parseFloat(data); // we need to use parseFloat because numbers could be decimals
                  }
               });

               node.innerHTML = result;
            },
         },
         webix.ui.datafilter.summColumn
      );
   }
};


/***/ }),

/***/ 45835:
/*!************************************************!*\
  !*** ./webix_custom_components/treesuggest.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * custom_editlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "treesuggest";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {}
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key)
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         defaults: {
            type: "tree",
            width: 0,
            body: {
               borderless: true,
               select: true,
               template: function(obj, common) {
                  return (
                     "<span>" +
                     (obj.$count ? "<b>" + obj.value + "</b>" : obj.value) +
                     "</span>"
                  );
               },
               ready: function() {
                  this.openAll();
               },
               on: {
                  onAfterSelect: function(id, e) {
                     if (this.getItem(id).$count) {
                        this.getParentView().setMasterValue("");
                        this.show(
                           $$(this.getParentView().config.master).getInputNode()
                        );
                     }
                  }
               }
            }
         }
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.suggest);
   }
};


/***/ })

}]);
//# sourceMappingURL=AppBuilder_ABFactory_js-node_modules_moment_locale_sync_recursive_.a11c2b6e7a3627c4045d.js.map