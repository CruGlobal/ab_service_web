{"version":3,"file":"orgchart.orgchart-js_orgchart-webcomponents_js.fd95f78839e4698ddac6.js","mappings":";;;;;;;;;;;;;AAAe;AACf;AACA,eAAe;;AAEf;AACA;AACA,6CAA6C,aAAa;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gCAAgC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA,aAAa;AACb,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,gCAAgC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,kBAAkB,yBAAyB,sBAAsB,QAAQ;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC,UAAU;AACV;AACA;AACA;AACA,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA","sources":["webpack://ab_platform_web/./js/orgchart-webcomponents.js"],"sourcesContent":["export default class OrgChart extends HTMLElement {\n   constructor(options) {\n      super(); // always call super() first in the ctor.\n\n      /* Frankly, I do believe Show DOM has the narrow usage range. */\n      // Attach a shadow root to the element.\n      // let shadowRoot = this.attachShadow({mode: 'open'});\n\n      // shadowRoot.innerHTML = `\n      //   <style> </style>\n      //   <div class=\"container\"> </div>\n      // `;\n\n      Promise.prototype.finally = function (callback) {\n         let P = this.constructor;\n\n         return this.then(\n            (value) => P.resolve(callback()).then(() => value),\n            (reason) =>\n               P.resolve(callback()).then(() => {\n                  throw reason;\n               })\n         );\n      };\n\n      let that = this,\n         defaultOptions = {\n            nodeTitle: \"name\",\n            nodeId: \"id\",\n            toggleSiblingsResp: false,\n            depth: 999,\n            chartClass: \"\",\n            parentNodeSymbol: \"fa-users\",\n            draggable: false,\n            direction: \"t2b\",\n            pan: false,\n            zoom: false,\n         },\n         opts = Object.assign(defaultOptions, options);\n\n      this.options = opts;\n\n      this.addEventListener(\"click\", this._clickChart.bind(this));\n\n      if (opts.pan && opts.chartContainer) {\n         let chartContainer = document.querySelector(opts.chartContainer);\n\n         chartContainer.style.overflow = \"hidden\";\n         this.addEventListener(\"mousedown\", this._onPanStart.bind(this));\n         this.addEventListener(\"touchstart\", this._onPanStart.bind(this));\n         document.body.addEventListener(\"mouseup\", this._onPanEnd.bind(this));\n         document.body.addEventListener(\"touchend\", this._onPanEnd.bind(this));\n      }\n\n      if (opts.zoom && opts.chartContainer) {\n         let chartContainer = document.querySelector(opts.chartContainer);\n\n         chartContainer.addEventListener(\"wheel\", this._onWheeling.bind(this));\n         chartContainer.addEventListener(\n            \"touchstart\",\n            this._onTouchStart.bind(this)\n         );\n         document.body.addEventListener(\n            \"touchmove\",\n            this._onTouchMove.bind(this)\n         );\n         document.body.addEventListener(\n            \"touchend\",\n            this._onTouchEnd.bind(this)\n         );\n      }\n   }\n   connectedCallback() {\n      let that = this,\n         opts = this.options,\n         data = opts.data;\n\n      this.setAttribute(\n         \"class\",\n         \"orgchart\" +\n            (opts.chartClass !== \"\" ? \" \" + opts.chartClass : \"\") +\n            (opts.direction !== \"t2b\" ? \" \" + opts.direction : \"\")\n      );\n      if (typeof data === \"object\") {\n         // local json datasource\n         this.buildHierarchy(\n            this,\n            opts.ajaxURL ? data : this._attachRel(data, \"00\"),\n            0\n         );\n      } else if (typeof data === \"string\" && data.startsWith(\"#\")) {\n         // ul datasource\n         this.buildHierarchy(\n            this,\n            this._buildJsonDS(document.querySelector(data).children[0]),\n            0\n         );\n      } else {\n         // ajax datasource\n         let spinner = document.createElement(\"i\");\n\n         spinner.setAttribute(\"class\", \"fa fa-circle-o-notch fa-spin spinner\");\n         this.appendChild(spinner);\n         this._getJSON(data)\n            .then(function (resp) {\n               that.buildHierarchy(\n                  that,\n                  opts.ajaxURL ? resp : that._attachRel(resp, \"00\"),\n                  0\n               );\n            })\n            .catch(function (err) {\n               console.error(\"failed to fetch datasource for orgchart\", err);\n            })\n            .finally(function () {\n               let spinner = that.querySelector(\".spinner\");\n\n               spinner.parentNode.removeChild(spinner);\n            });\n      }\n   }\n\n   disconnectedCallback() {}\n\n   attributeChangedCallback(attrName, oldVal, newVal) {}\n\n   _closest(el, fn) {\n      return (\n         el && (fn(el) && el !== this ? el : this._closest(el.parentNode, fn))\n      );\n   }\n   _siblings(el, expr) {\n      return Array.from(el.parentNode.children).filter((child) => {\n         if (child !== el) {\n            if (expr) {\n               return el.matches(expr);\n            }\n            return true;\n         }\n         return false;\n      });\n   }\n   _prevAll(el, expr) {\n      let sibs = [],\n         prevSib = el.previousElementSibling;\n\n      while (prevSib) {\n         if (!expr || prevSib.matches(expr)) {\n            sibs.push(prevSib);\n         }\n         prevSib = prevSib.previousElementSibling;\n      }\n      return sibs;\n   }\n   _nextAll(el, expr) {\n      let sibs = [];\n      let nextSib = el.nextElementSibling;\n\n      while (nextSib) {\n         if (!expr || nextSib.matches(expr)) {\n            sibs.push(nextSib);\n         }\n         nextSib = nextSib.nextElementSibling;\n      }\n      return sibs;\n   }\n   _isVisible(el) {\n      return el.offsetParent !== null;\n   }\n   _addClass(elements, classNames) {\n      elements.forEach((el) => {\n         if (classNames.indexOf(\" \") > 0) {\n            classNames\n               .split(\" \")\n               .forEach((className) => el.classList.add(className));\n         } else {\n            el.classList.add(classNames);\n         }\n      });\n   }\n   _removeClass(elements, classNames) {\n      elements.forEach((el) => {\n         if (classNames.indexOf(\" \") > 0) {\n            classNames\n               .split(\" \")\n               .forEach((className) => el.classList.remove(className));\n         } else {\n            el.classList.remove(classNames);\n         }\n      });\n   }\n   _css(elements, prop, val) {\n      elements.forEach((el) => {\n         el.style[prop] = val;\n      });\n   }\n   _removeAttr(elements, attr) {\n      elements.forEach((el) => {\n         el.removeAttribute(attr);\n      });\n   }\n   _one(el, type, listener, self) {\n      let one = function (event) {\n         try {\n            listener.call(self, event);\n         } finally {\n            el.removeEventListener(type, one);\n         }\n      };\n\n      el.addEventListener(type, one);\n   }\n   _getDescElements(ancestors, selector) {\n      let results = [];\n\n      ancestors.forEach((el) => results.push(...el.querySelectorAll(selector)));\n      return results;\n   }\n   _getJSON(url) {\n      return new Promise(function (resolve, reject) {\n         let xhr = new XMLHttpRequest();\n\n         function handler() {\n            if (this.readyState !== 4) {\n               return;\n            }\n            if (this.status === 200) {\n               resolve(JSON.parse(this.response));\n            } else {\n               reject(new Error(this.statusText));\n            }\n         }\n         xhr.open(\"GET\", url);\n         xhr.onreadystatechange = handler;\n         xhr.responseType = \"json\";\n         // xhr.setRequestHeader('Accept', 'application/json');\n         xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n         xhr.send();\n      });\n   }\n   _buildJsonDS(li) {\n      let subObj = {\n         name: li.firstChild.textContent.trim(),\n         relationship:\n            (li.parentNode.parentNode.nodeName === \"LI\" ? \"1\" : \"0\") +\n            (li.parentNode.children.length > 1 ? 1 : 0) +\n            (li.children.length ? 1 : 0),\n      };\n\n      if (li.id) {\n         subObj.id = li.id;\n      }\n      if (li.querySelector(\"ul\")) {\n         Array.from(li.querySelector(\"ul\").children).forEach((el) => {\n            if (!subObj.children) {\n               subObj.children = [];\n            }\n            subObj.children.push(this._buildJsonDS(el));\n         });\n      }\n      return subObj;\n   }\n   _attachRel(data, flags) {\n      data.relationship =\n         flags + (data.children && data.children.length > 0 ? 1 : 0);\n      if (data.children) {\n         for (let item of data.children) {\n            this._attachRel(item, \"1\" + (data.children.length > 1 ? 1 : 0));\n         }\n      }\n      return data;\n   }\n   _repaint(node) {\n      if (node) {\n         node.style.offsetWidth = node.offsetWidth;\n      }\n   }\n   // whether the cursor is hovering over the node\n   _isInAction(node) {\n      return node.querySelector(\":scope > .edge\").className.indexOf(\"fa-\") > -1;\n   }\n   // detect the exist/display state of related node\n   _getNodeState(node, relation) {\n      let criteria,\n         state = { exist: false, visible: false };\n\n      if (relation === \"parent\") {\n         criteria = this._closest(\n            node,\n            (el) => el.classList && el.classList.contains(\"nodes\")\n         );\n         if (criteria) {\n            state.exist = true;\n         }\n         if (state.exist && this._isVisible(criteria.parentNode.children[0])) {\n            state.visible = true;\n         }\n      } else if (relation === \"children\") {\n         criteria = this._closest(\n            node,\n            (el) => el.nodeName === \"TR\"\n         ).nextElementSibling;\n         if (criteria) {\n            state.exist = true;\n         }\n         if (state.exist && this._isVisible(criteria)) {\n            state.visible = true;\n         }\n      } else if (relation === \"siblings\") {\n         criteria = this._siblings(\n            this._closest(node, (el) => el.nodeName === \"TABLE\").parentNode\n         );\n         if (criteria.length) {\n            state.exist = true;\n         }\n         if (state.exist && criteria.some((el) => this._isVisible(el))) {\n            state.visible = true;\n         }\n      }\n\n      return state;\n   }\n   // find the related nodes\n   getRelatedNodes(node, relation) {\n      if (relation === \"parent\") {\n         return this._closest(node, (el) =>\n            el.classList.contains(\"nodes\")\n         ).parentNode.children[0].querySelector(\".node\");\n      } else if (relation === \"children\") {\n         return Array.from(\n            this._closest(node, (el) => el.nodeName === \"TABLE\").lastChild\n               .children\n         ).map((el) => el.querySelector(\".node\"));\n      } else if (relation === \"siblings\") {\n         return this._siblings(\n            this._closest(node, (el) => el.nodeName === \"TABLE\").parentNode\n         ).map((el) => el.querySelector(\".node\"));\n      }\n      return [];\n   }\n   _switchHorizontalArrow(node) {\n      let opts = this.options,\n         leftEdge = node.querySelector(\".leftEdge\"),\n         rightEdge = node.querySelector(\".rightEdge\"),\n         temp = this._closest(node, (el) => el.nodeName === \"TABLE\").parentNode;\n\n      if (\n         opts.toggleSiblingsResp &&\n         (typeof opts.ajaxURL === \"undefined\" ||\n            this._closest(node, (el) => el.classList.contains(\".nodes\")).dataset\n               .siblingsLoaded)\n      ) {\n         let prevSib = temp.previousElementSibling,\n            nextSib = temp.nextElementSibling;\n\n         if (prevSib) {\n            if (prevSib.classList.contains(\"hidden\")) {\n               leftEdge.classList.add(\"fa-chevron-left\");\n               leftEdge.classList.remove(\"fa-chevron-right\");\n            } else {\n               leftEdge.classList.add(\"fa-chevron-right\");\n               leftEdge.classList.remove(\"fa-chevron-left\");\n            }\n         }\n         if (nextSib) {\n            if (nextSib.classList.contains(\"hidden\")) {\n               rightEdge.classList.add(\"fa-chevron-right\");\n               rightEdge.classList.remove(\"fa-chevron-left\");\n            } else {\n               rightEdge.classList.add(\"fa-chevron-left\");\n               rightEdge.classList.remove(\"fa-chevron-right\");\n            }\n         }\n      } else {\n         let sibs = this._siblings(temp),\n            sibsVisible = sibs.length\n               ? !sibs.some((el) => el.classList.contains(\"hidden\"))\n               : false;\n\n         leftEdge.classList.toggle(\"fa-chevron-right\", sibsVisible);\n         leftEdge.classList.toggle(\"fa-chevron-left\", !sibsVisible);\n         rightEdge.classList.toggle(\"fa-chevron-left\", sibsVisible);\n         rightEdge.classList.toggle(\"fa-chevron-right\", !sibsVisible);\n      }\n   }\n   _hoverNode(event) {\n      let node = event.target,\n         flag = false,\n         topEdge = node.querySelector(\":scope > .topEdge\"),\n         bottomEdge = node.querySelector(\":scope > .bottomEdge\"),\n         leftEdge = node.querySelector(\":scope > .leftEdge\");\n\n      if (event.type === \"mouseenter\") {\n         if (topEdge) {\n            flag = this._getNodeState(node, \"parent\").visible;\n            topEdge.classList.toggle(\"fa-chevron-up\", !flag);\n            topEdge.classList.toggle(\"fa-chevron-down\", flag);\n         }\n         if (bottomEdge) {\n            flag = this._getNodeState(node, \"children\").visible;\n            bottomEdge.classList.toggle(\"fa-chevron-down\", !flag);\n            bottomEdge.classList.toggle(\"fa-chevron-up\", flag);\n         }\n         if (leftEdge) {\n            this._switchHorizontalArrow(node);\n         }\n      } else {\n         Array.from(node.querySelectorAll(\":scope > .edge\")).forEach((el) => {\n            el.classList.remove(\n               \"fa-chevron-up\",\n               \"fa-chevron-down\",\n               \"fa-chevron-right\",\n               \"fa-chevron-left\"\n            );\n         });\n      }\n   }\n   // define node click event handler\n   _clickNode(event) {\n      let clickedNode = event.currentTarget,\n         focusedNode = this.querySelector(\".focused\");\n\n      if (focusedNode) {\n         focusedNode.classList.remove(\"focused\");\n      }\n      clickedNode.classList.add(\"focused\");\n   }\n   // build the parent node of specific node\n   _buildParentNode(currentRoot, nodeData, callback) {\n      let that = this,\n         table = document.createElement(\"table\");\n\n      nodeData.relationship = \"001\";\n      this._createNode(nodeData, 0)\n         .then(function (nodeDiv) {\n            nodeDiv.classList.remove(\"slide-up\");\n            nodeDiv.classList.add(\"slide-down\");\n            let parentTr = document.createElement(\"tr\"),\n               superiorLine = document.createElement(\"tr\"),\n               inferiorLine = document.createElement(\"tr\"),\n               childrenTr = document.createElement(\"tr\");\n\n            parentTr.setAttribute(\"class\", \"hidden\");\n            parentTr.innerHTML = `<td colspan=\"2\"></td>`;\n            table.appendChild(parentTr);\n            superiorLine.setAttribute(\"class\", \"lines hidden\");\n            superiorLine.innerHTML = `<td colspan=\"2\"><div class=\"downLine\"></div></td>`;\n            table.appendChild(superiorLine);\n            inferiorLine.setAttribute(\"class\", \"lines hidden\");\n            inferiorLine.innerHTML = `<td class=\"rightLine\">&nbsp;</td><td class=\"leftLine\">&nbsp;</td>`;\n            table.appendChild(inferiorLine);\n            childrenTr.setAttribute(\"class\", \"nodes\");\n            childrenTr.innerHTML = `<td colspan=\"2\"></td>`;\n            table.appendChild(childrenTr);\n            table.querySelector(\"td\").appendChild(nodeDiv);\n            that.insertBefore(table, that.children[0]);\n            table.children[3].children[0].appendChild(that.lastChild);\n            callback();\n         })\n         .catch(function (err) {\n            console.error(\"Failed to create parent node\", err);\n         });\n   }\n   _switchVerticalArrow(arrow) {\n      arrow.classList.toggle(\"fa-chevron-up\");\n      arrow.classList.toggle(\"fa-chevron-down\");\n   }\n   // show the parent node of the specified node\n   showParent(node) {\n      // just show only one superior level\n      let temp = this._prevAll(\n         this._closest(node, (el) => el.classList.contains(\"nodes\"))\n      );\n\n      this._removeClass(temp, \"hidden\");\n      // just show only one line\n      this._addClass(Array(temp[0].children).slice(1, -1), \"hidden\");\n      // show parent node with animation\n      let parent = temp[2].querySelector(\".node\");\n\n      this._one(\n         parent,\n         \"transitionend\",\n         function () {\n            parent.classList.remove(\"slide\");\n            if (this._isInAction(node)) {\n               this._switchVerticalArrow(\n                  node.querySelector(\":scope > .topEdge\")\n               );\n            }\n         },\n         this\n      );\n      this._repaint(parent);\n      parent.classList.add(\"slide\");\n      parent.classList.remove(\"slide-down\");\n   }\n   // show the sibling nodes of the specified node\n   showSiblings(node, direction) {\n      // firstly, show the sibling td tags\n      let siblings = [],\n         temp = this._closest(node, (el) => el.nodeName === \"TABLE\").parentNode;\n\n      if (direction) {\n         siblings =\n            direction === \"left\" ? this._prevAll(temp) : this._nextAll(temp);\n      } else {\n         siblings = this._siblings(temp);\n      }\n      this._removeClass(siblings, \"hidden\");\n      // secondly, show the lines\n      let upperLevel = this._prevAll(\n         this._closest(node, (el) => el.classList.contains(\"nodes\"))\n      );\n\n      temp = Array.from(upperLevel[0].querySelectorAll(\":scope > .hidden\"));\n      if (direction) {\n         this._removeClass(temp.slice(0, siblings.length * 2), \"hidden\");\n      } else {\n         this._removeClass(temp, \"hidden\");\n      }\n      // thirdly, do some cleaning stuff\n      if (!this._getNodeState(node, \"parent\").visible) {\n         this._removeClass(upperLevel, \"hidden\");\n         let parent = upperLevel[2].querySelector(\".node\");\n\n         this._one(\n            parent,\n            \"transitionend\",\n            function (event) {\n               event.target.classList.remove(\"slide\");\n            },\n            this\n         );\n         this._repaint(parent);\n         parent.classList.add(\"slide\");\n         parent.classList.remove(\"slide-down\");\n      }\n      // lastly, show the sibling nodes with animation\n      siblings.forEach((sib) => {\n         Array.from(sib.querySelectorAll(\".node\")).forEach((node) => {\n            if (this._isVisible(node)) {\n               node.classList.add(\"slide\");\n               node.classList.remove(\"slide-left\", \"slide-right\");\n            }\n         });\n      });\n      this._one(\n         siblings[0].querySelector(\".slide\"),\n         \"transitionend\",\n         function () {\n            siblings.forEach((sib) => {\n               this._removeClass(\n                  Array.from(sib.querySelectorAll(\".slide\")),\n                  \"slide\"\n               );\n            });\n            if (this._isInAction(node)) {\n               this._switchHorizontalArrow(node);\n               node.querySelector(\".topEdge\").classList.remove(\"fa-chevron-up\");\n               node.querySelector(\".topEdge\").classList.add(\"fa-chevron-down\");\n            }\n         },\n         this\n      );\n   }\n   // hide the sibling nodes of the specified node\n   hideSiblings(node, direction) {\n      let nodeContainer = this._closest(\n            node,\n            (el) => el.nodeName === \"TABLE\"\n         ).parentNode,\n         siblings = this._siblings(nodeContainer);\n\n      siblings.forEach((sib) => {\n         if (sib.querySelector(\".spinner\")) {\n            this.dataset.inAjax = false;\n         }\n      });\n\n      if (!direction || (direction && direction === \"left\")) {\n         let preSibs = this._prevAll(nodeContainer);\n\n         preSibs.forEach((sib) => {\n            Array.from(sib.querySelectorAll(\".node\")).forEach((node) => {\n               if (this._isVisible(node)) {\n                  node.classList.add(\"slide\", \"slide-right\");\n               }\n            });\n         });\n      }\n      if (!direction || (direction && direction !== \"left\")) {\n         let nextSibs = this._nextAll(nodeContainer);\n\n         nextSibs.forEach((sib) => {\n            Array.from(sib.querySelectorAll(\".node\")).forEach((node) => {\n               if (this._isVisible(node)) {\n                  node.classList.add(\"slide\", \"slide-left\");\n               }\n            });\n         });\n      }\n\n      let animatedNodes = [];\n\n      this._siblings(nodeContainer).forEach((sib) => {\n         Array.prototype.push.apply(\n            animatedNodes,\n            Array.from(sib.querySelectorAll(\".slide\"))\n         );\n      });\n      let lines = [];\n\n      for (let node of animatedNodes) {\n         let temp = this._closest(node, function (el) {\n            return el.classList.contains(\"nodes\");\n         }).previousElementSibling;\n\n         lines.push(temp);\n         lines.push(temp.previousElementSibling);\n      }\n      lines = [...new Set(lines)];\n      lines.forEach(function (line) {\n         line.style.visibility = \"hidden\";\n      });\n\n      this._one(\n         animatedNodes[0],\n         \"transitionend\",\n         function (event) {\n            lines.forEach(function (line) {\n               line.removeAttribute(\"style\");\n            });\n            let sibs = [];\n\n            if (direction) {\n               if (direction === \"left\") {\n                  sibs = this._prevAll(nodeContainer, \":not(.hidden)\");\n               } else {\n                  sibs = this._nextAll(nodeContainer, \":not(.hidden)\");\n               }\n            } else {\n               sibs = this._siblings(nodeContainer);\n            }\n            let temp = Array.from(\n               this._closest(nodeContainer, function (el) {\n                  return el.classList.contains(\"nodes\");\n               }).previousElementSibling.querySelectorAll(\n                  \":scope > :not(.hidden)\"\n               )\n            );\n\n            let someLines = temp.slice(1, direction ? sibs.length * 2 + 1 : -1);\n\n            this._addClass(someLines, \"hidden\");\n            this._removeClass(animatedNodes, \"slide\");\n            sibs.forEach((sib) => {\n               Array.from(sib.querySelectorAll(\".node\"))\n                  .slice(1)\n                  .forEach((node) => {\n                     if (this._isVisible(node)) {\n                        node.classList.remove(\"slide-left\", \"slide-right\");\n                        node.classList.add(\"slide-up\");\n                     }\n                  });\n            });\n            sibs.forEach((sib) => {\n               this._addClass(\n                  Array.from(sib.querySelectorAll(\".lines\")),\n                  \"hidden\"\n               );\n               this._addClass(\n                  Array.from(sib.querySelectorAll(\".nodes\")),\n                  \"hidden\"\n               );\n               this._addClass(\n                  Array.from(sib.querySelectorAll(\".verticalNodes\")),\n                  \"hidden\"\n               );\n            });\n            this._addClass(sibs, \"hidden\");\n\n            if (this._isInAction(node)) {\n               this._switchHorizontalArrow(node);\n            }\n         },\n         this\n      );\n   }\n   // recursively hide the ancestor node and sibling nodes of the specified node\n   hideParent(node) {\n      let temp = Array.from(\n         this._closest(node, function (el) {\n            return el.classList.contains(\"nodes\");\n         }).parentNode.children\n      ).slice(0, 3);\n\n      if (temp[0].querySelector(\".spinner\")) {\n         this.dataset.inAjax = false;\n      }\n      // hide the sibling nodes\n      if (this._getNodeState(node, \"siblings\").visible) {\n         this.hideSiblings(node);\n      }\n      // hide the lines\n      let lines = temp.slice(1);\n\n      this._css(lines, \"visibility\", \"hidden\");\n      // hide the superior nodes with transition\n      let parent = temp[0].querySelector(\".node\"),\n         grandfatherVisible = this._getNodeState(parent, \"parent\").visible;\n\n      if (parent && this._isVisible(parent)) {\n         parent.classList.add(\"slide\", \"slide-down\");\n         this._one(\n            parent,\n            \"transitionend\",\n            function () {\n               parent.classList.remove(\"slide\");\n               this._removeAttr(lines, \"style\");\n               this._addClass(temp, \"hidden\");\n            },\n            this\n         );\n      }\n      // if the current node has the parent node, hide it recursively\n      if (parent && grandfatherVisible) {\n         this.hideParent(parent);\n      }\n   }\n   // exposed method\n   addParent(currentRoot, data) {\n      let that = this;\n\n      this._buildParentNode(currentRoot, data, function () {\n         if (!currentRoot.querySelector(\":scope > .topEdge\")) {\n            let topEdge = document.createElement(\"i\");\n\n            topEdge.setAttribute(\"class\", \"edge verticalEdge topEdge fa\");\n            currentRoot.appendChild(topEdge);\n         }\n         that.showParent(currentRoot);\n      });\n   }\n   // start up loading status for requesting new nodes\n   _startLoading(arrow, node) {\n      let opts = this.options;\n\n      if (\n         typeof this.dataset.inAjax !== \"undefined\" &&\n         this.dataset.inAjax === \"true\"\n      ) {\n         return false;\n      }\n\n      arrow.classList.add(\"hidden\");\n      let spinner = document.createElement(\"i\");\n\n      spinner.setAttribute(\"class\", \"fa fa-circle-o-notch fa-spin spinner\");\n      node.appendChild(spinner);\n      this._addClass(\n         Array.from(node.querySelectorAll(\":scope > *:not(.spinner)\")),\n         \"hazy\"\n      );\n      this.dataset.inAjax = true;\n\n      return true;\n   }\n   // terminate loading status for requesting new nodes\n   _endLoading(arrow, node) {\n      let opts = this.options;\n\n      arrow.classList.remove(\"hidden\");\n      node.querySelector(\":scope > .spinner\").remove();\n      this._removeClass(\n         Array.from(node.querySelectorAll(\":scope > .hazy\")),\n         \"hazy\"\n      );\n      this.dataset.inAjax = false;\n   }\n   // define click event handler for the top edge\n   _clickTopEdge(event) {\n      event.stopPropagation();\n      let that = this,\n         topEdge = event.target,\n         node = topEdge.parentNode,\n         parentState = this._getNodeState(node, \"parent\"),\n         opts = this.options;\n\n      if (parentState.exist) {\n         let temp = this._closest(node, function (el) {\n            return el.classList.contains(\"nodes\");\n         });\n         let parent = temp.parentNode.firstChild.querySelector(\".node\");\n\n         if (parent.classList.contains(\"slide\")) {\n            return;\n         }\n         // hide the ancestor nodes and sibling nodes of the specified node\n         if (parentState.visible) {\n            this.hideParent(node);\n            this._one(\n               parent,\n               \"transitionend\",\n               function () {\n                  if (this._isInAction(node)) {\n                     this._switchVerticalArrow(topEdge);\n                     this._switchHorizontalArrow(node);\n                  }\n               },\n               this\n            );\n         } else {\n            // show the ancestors and siblings\n            this.showParent(node);\n         }\n      } else {\n         // load the new parent node of the specified node by ajax request\n         let nodeId = topEdge.parentNode.id;\n\n         // start up loading status\n         if (this._startLoading(topEdge, node)) {\n            // load new nodes\n            this._getJSON(\n               typeof opts.ajaxURL.parent === \"function\"\n                  ? opts.ajaxURL.parent(node.dataset.source)\n                  : opts.ajaxURL.parent + nodeId\n            )\n               .then(function (resp) {\n                  if (that.dataset.inAjax === \"true\") {\n                     if (Object.keys(resp).length) {\n                        that.addParent(node, resp);\n                     }\n                  }\n               })\n               .catch(function (err) {\n                  console.error(\"Failed to get parent node data.\", err);\n               })\n               .finally(function () {\n                  that._endLoading(topEdge, node);\n               });\n         }\n      }\n   }\n   // recursively hide the descendant nodes of the specified node\n   hideChildren(node) {\n      let that = this,\n         temp = this._nextAll(node.parentNode.parentNode),\n         lastItem = temp[temp.length - 1],\n         lines = [];\n\n      if (lastItem.querySelector(\".spinner\")) {\n         this.dataset.inAjax = false;\n      }\n      let descendants = Array.from(lastItem.querySelectorAll(\".node\")).filter(\n            (el) => that._isVisible(el)\n         ),\n         isVerticalDesc = lastItem.classList.contains(\"verticalNodes\");\n\n      if (!isVerticalDesc) {\n         descendants.forEach((desc) => {\n            Array.prototype.push.apply(\n               lines,\n               that._prevAll(\n                  that._closest(desc, (el) => el.classList.contains(\"nodes\")),\n                  \".lines\"\n               )\n            );\n         });\n         lines = [...new Set(lines)];\n         this._css(lines, \"visibility\", \"hidden\");\n      }\n      this._one(\n         descendants[0],\n         \"transitionend\",\n         function (event) {\n            this._removeClass(descendants, \"slide\");\n            if (isVerticalDesc) {\n               that._addClass(temp, \"hidden\");\n            } else {\n               lines.forEach((el) => {\n                  el.removeAttribute(\"style\");\n                  el.classList.add(\"hidden\");\n                  el.parentNode.lastChild.classList.add(\"hidden\");\n               });\n               this._addClass(\n                  Array.from(lastItem.querySelectorAll(\".verticalNodes\")),\n                  \"hidden\"\n               );\n            }\n            if (this._isInAction(node)) {\n               this._switchVerticalArrow(node.querySelector(\".bottomEdge\"));\n            }\n         },\n         this\n      );\n      this._addClass(descendants, \"slide slide-up\");\n   }\n   // show the children nodes of the specified node\n   showChildren(node) {\n      let that = this,\n         temp = this._nextAll(node.parentNode.parentNode),\n         descendants = [];\n\n      this._removeClass(temp, \"hidden\");\n      if (temp.some((el) => el.classList.contains(\"verticalNodes\"))) {\n         temp.forEach((el) => {\n            Array.prototype.push.apply(\n               descendants,\n               Array.from(el.querySelectorAll(\".node\")).filter((el) => {\n                  return that._isVisible(el);\n               })\n            );\n         });\n      } else {\n         Array.from(temp[2].children).forEach((el) => {\n            Array.prototype.push.apply(\n               descendants,\n               Array.from(\n                  el.querySelector(\"tr\").querySelectorAll(\".node\")\n               ).filter((el) => {\n                  return that._isVisible(el);\n               })\n            );\n         });\n      }\n      // the two following statements are used to enforce browser to repaint\n      this._repaint(descendants[0]);\n      this._one(\n         descendants[0],\n         \"transitionend\",\n         (event) => {\n            this._removeClass(descendants, \"slide\");\n            if (this._isInAction(node)) {\n               this._switchVerticalArrow(node.querySelector(\".bottomEdge\"));\n            }\n         },\n         this\n      );\n      this._addClass(descendants, \"slide\");\n      this._removeClass(descendants, \"slide-up\");\n   }\n   // build the child nodes of specific node\n   _buildChildNode(appendTo, nodeData, callback) {\n      let data = nodeData.children || nodeData.siblings;\n\n      appendTo.querySelector(\"td\").setAttribute(\"colSpan\", data.length * 2);\n      this.buildHierarchy(appendTo, { children: data }, 0, callback);\n   }\n   // exposed method\n   addChildren(node, data) {\n      let that = this,\n         opts = this.options,\n         count = 0;\n\n      this.dataset.inEdit = \"addChildren\";\n      this._buildChildNode.call(\n         this,\n         this._closest(node, (el) => el.nodeName === \"TABLE\"),\n         data,\n         function () {\n            if (++count === data.children.length) {\n               if (!node.querySelector(\".bottomEdge\")) {\n                  let bottomEdge = document.createElement(\"i\");\n\n                  bottomEdge.setAttribute(\n                     \"class\",\n                     \"edge verticalEdge bottomEdge fa\"\n                  );\n                  node.appendChild(bottomEdge);\n               }\n               if (!node.querySelector(\".symbol\")) {\n                  let symbol = document.createElement(\"i\");\n\n                  symbol.setAttribute(\n                     \"class\",\n                     \"fa \" + opts.parentNodeSymbol + \" symbol\"\n                  );\n                  node.querySelector(\":scope > .title\").appendChild(symbol);\n               }\n               that.showChildren(node);\n               that.dataset.inEdit = \"\";\n            }\n         }\n      );\n   }\n   // bind click event handler for the bottom edge\n   _clickBottomEdge(event) {\n      event.stopPropagation();\n      let that = this,\n         opts = this.options,\n         bottomEdge = event.target,\n         node = bottomEdge.parentNode,\n         childrenState = this._getNodeState(node, \"children\");\n\n      if (childrenState.exist) {\n         let temp = this._closest(node, function (el) {\n            return el.nodeName === \"TR\";\n         }).parentNode.lastChild;\n\n         if (\n            Array.from(temp.querySelectorAll(\".node\")).some((node) => {\n               return this._isVisible(node) && node.classList.contains(\"slide\");\n            })\n         ) {\n            return;\n         }\n         // hide the descendant nodes of the specified node\n         if (childrenState.visible) {\n            this.hideChildren(node);\n         } else {\n            // show the descendants\n            this.showChildren(node);\n         }\n      } else {\n         // load the new children nodes of the specified node by ajax request\n         let nodeId = bottomEdge.parentNode.id;\n\n         if (this._startLoading(bottomEdge, node)) {\n            this._getJSON(\n               typeof opts.ajaxURL.children === \"function\"\n                  ? opts.ajaxURL.children(node.dataset.source)\n                  : opts.ajaxURL.children + nodeId\n            )\n               .then(function (resp) {\n                  if (that.dataset.inAjax === \"true\") {\n                     if (resp.children.length) {\n                        that.addChildren(node, resp);\n                     }\n                  }\n               })\n               .catch(function (err) {\n                  console.error(\"Failed to get children nodes data\", err);\n               })\n               .finally(function () {\n                  that._endLoading(bottomEdge, node);\n               });\n         }\n      }\n   }\n   // subsequent processing of build sibling nodes\n   _complementLine(oneSibling, siblingCount, existingSibligCount) {\n      let temp = oneSibling.parentNode.parentNode.children;\n\n      temp[0].children[0].setAttribute(\"colspan\", siblingCount * 2);\n      temp[1].children[0].setAttribute(\"colspan\", siblingCount * 2);\n      for (let i = 0; i < existingSibligCount; i++) {\n         let rightLine = document.createElement(\"td\"),\n            leftLine = document.createElement(\"td\");\n\n         rightLine.setAttribute(\"class\", \"rightLine topLine\");\n         rightLine.innerHTML = \"&nbsp;\";\n         temp[2].insertBefore(rightLine, temp[2].children[1]);\n         leftLine.setAttribute(\"class\", \"leftLine topLine\");\n         leftLine.innerHTML = \"&nbsp;\";\n         temp[2].insertBefore(leftLine, temp[2].children[1]);\n      }\n   }\n   // build the sibling nodes of specific node\n   _buildSiblingNode(nodeChart, nodeData, callback) {\n      let that = this,\n         newSiblingCount = nodeData.siblings\n            ? nodeData.siblings.length\n            : nodeData.children.length,\n         existingSibligCount =\n            nodeChart.parentNode.nodeName === \"TD\"\n               ? this._closest(nodeChart, (el) => {\n                    return el.nodeName === \"TR\";\n                 }).children.length\n               : 1,\n         siblingCount = existingSibligCount + newSiblingCount,\n         insertPostion =\n            siblingCount > 1 ? Math.floor(siblingCount / 2 - 1) : 0;\n\n      // just build the sibling nodes for the specific node\n      if (nodeChart.parentNode.nodeName === \"TD\") {\n         let temp = this._prevAll(nodeChart.parentNode.parentNode);\n\n         temp[0].remove();\n         temp[1].remove();\n         let childCount = 0;\n\n         that._buildChildNode.call(\n            that,\n            that._closest(\n               nodeChart.parentNode,\n               (el) => el.nodeName === \"TABLE\"\n            ),\n            nodeData,\n            () => {\n               if (++childCount === newSiblingCount) {\n                  let siblingTds = Array.from(\n                     that._closest(\n                        nodeChart.parentNode,\n                        (el) => el.nodeName === \"TABLE\"\n                     ).lastChild.children\n                  );\n\n                  if (existingSibligCount > 1) {\n                     let temp = nodeChart.parentNode.parentNode;\n\n                     Array.from(temp.children).forEach((el) => {\n                        siblingTds[0].parentNode.insertBefore(\n                           el,\n                           siblingTds[0]\n                        );\n                     });\n                     temp.remove();\n                     that._complementLine(\n                        siblingTds[0],\n                        siblingCount,\n                        existingSibligCount\n                     );\n                     that._addClass(siblingTds, \"hidden\");\n                     siblingTds.forEach((el) => {\n                        that._addClass(\n                           el.querySelectorAll(\".node\"),\n                           \"slide-left\"\n                        );\n                     });\n                  } else {\n                     let temp = nodeChart.parentNode.parentNode;\n\n                     siblingTds[insertPostion].parentNode.insertBefore(\n                        nodeChart.parentNode,\n                        siblingTds[insertPostion + 1]\n                     );\n                     temp.remove();\n                     that._complementLine(\n                        siblingTds[insertPostion],\n                        siblingCount,\n                        1\n                     );\n                     that._addClass(siblingTds, \"hidden\");\n                     that._addClass(\n                        that._getDescElements(\n                           siblingTds.slice(0, insertPostion + 1),\n                           \".node\"\n                        ),\n                        \"slide-right\"\n                     );\n                     that._addClass(\n                        that._getDescElements(\n                           siblingTds.slice(insertPostion + 1),\n                           \".node\"\n                        ),\n                        \"slide-left\"\n                     );\n                  }\n                  callback();\n               }\n            }\n         );\n      } else {\n         // build the sibling nodes and parent node for the specific ndoe\n         let nodeCount = 0;\n\n         that.buildHierarchy.call(that, that, nodeData, 0, () => {\n            if (++nodeCount === siblingCount) {\n               let temp =\n                     nodeChart.nextElementSibling.children[3].children[\n                        insertPostion\n                     ],\n                  td = document.createElement(\"td\");\n\n               td.setAttribute(\"colspan\", 2);\n               td.appendChild(nodeChart);\n               temp.parentNode.insertBefore(td, temp.nextElementSibling);\n               that._complementLine(temp, siblingCount, 1);\n\n               let temp2 = that._closest(\n                  nodeChart,\n                  (el) => el.classList && el.classList.contains(\"nodes\")\n               ).parentNode.children[0];\n\n               temp2.classList.add(\"hidden\");\n               that._addClass(\n                  Array.from(temp2.querySelectorAll(\".node\")),\n                  \"slide-down\"\n               );\n\n               let temp3 = this._siblings(nodeChart.parentNode);\n\n               that._addClass(temp3, \"hidden\");\n               that._addClass(\n                  that._getDescElements(temp3.slice(0, insertPostion), \".node\"),\n                  \"slide-right\"\n               );\n               that._addClass(\n                  that._getDescElements(temp3.slice(insertPostion), \".node\"),\n                  \"slide-left\"\n               );\n               callback();\n            }\n         });\n      }\n   }\n   addSiblings(node, data) {\n      let that = this;\n\n      this.dataset.inEdit = \"addSiblings\";\n      this._buildSiblingNode.call(\n         this,\n         this._closest(node, (el) => el.nodeName === \"TABLE\"),\n         data,\n         () => {\n            that._closest(\n               node,\n               (el) => el.classList && el.classList.contains(\"nodes\")\n            ).dataset.siblingsLoaded = true;\n            if (!node.querySelector(\".leftEdge\")) {\n               let rightEdge = document.createElement(\"i\"),\n                  leftEdge = document.createElement(\"i\");\n\n               rightEdge.setAttribute(\n                  \"class\",\n                  \"edge horizontalEdge rightEdge fa\"\n               );\n               node.appendChild(rightEdge);\n               leftEdge.setAttribute(\n                  \"class\",\n                  \"edge horizontalEdge leftEdge fa\"\n               );\n               node.appendChild(leftEdge);\n            }\n            that.showSiblings(node);\n            that.dataset.inEdit = \"\";\n         }\n      );\n   }\n   removeNodes(node) {\n      let parent = this._closest(\n            node,\n            (el) => el.nodeName === \"TABLE\"\n         ).parentNode,\n         sibs = this._siblings(parent.parentNode);\n\n      if (parent.nodeName === \"TD\") {\n         if (this._getNodeState(node, \"siblings\").exist) {\n            sibs[2].querySelector(\".topLine\").nextElementSibling.remove();\n            sibs[2].querySelector(\".topLine\").remove();\n            sibs[0].children[0].setAttribute(\n               \"colspan\",\n               sibs[2].children.length\n            );\n            sibs[1].children[0].setAttribute(\n               \"colspan\",\n               sibs[2].children.length\n            );\n            parent.remove();\n         } else {\n            sibs[0].children[0].removeAttribute(\"colspan\");\n            sibs[0].querySelector(\".bottomEdge\").remove();\n            this._siblings(sibs[0]).forEach((el) => el.remove());\n         }\n      } else {\n         Array.from(parent.parentNode.children).forEach((el) => el.remove());\n      }\n   }\n   // bind click event handler for the left and right edges\n   _clickHorizontalEdge(event) {\n      event.stopPropagation();\n      let that = this,\n         opts = this.options,\n         hEdge = event.target,\n         node = hEdge.parentNode,\n         siblingsState = this._getNodeState(node, \"siblings\");\n\n      if (siblingsState.exist) {\n         let temp = this._closest(node, function (el) {\n               return el.nodeName === \"TABLE\";\n            }).parentNode,\n            siblings = this._siblings(temp);\n\n         if (\n            siblings.some((el) => {\n               let node = el.querySelector(\".node\");\n\n               return this._isVisible(node) && node.classList.contains(\"slide\");\n            })\n         ) {\n            return;\n         }\n         if (opts.toggleSiblingsResp) {\n            let prevSib = this._closest(node, (el) => el.nodeName === \"TABLE\")\n                  .parentNode.previousElementSibling,\n               nextSib = this._closest(node, (el) => el.nodeName === \"TABLE\")\n                  .parentNode.nextElementSibling;\n\n            if (hEdge.classList.contains(\"leftEdge\")) {\n               if (prevSib.classList.contains(\"hidden\")) {\n                  this.showSiblings(node, \"left\");\n               } else {\n                  this.hideSiblings(node, \"left\");\n               }\n            } else {\n               if (nextSib.classList.contains(\"hidden\")) {\n                  this.showSiblings(node, \"right\");\n               } else {\n                  this.hideSiblings(node, \"right\");\n               }\n            }\n         } else {\n            if (siblingsState.visible) {\n               this.hideSiblings(node);\n            } else {\n               this.showSiblings(node);\n            }\n         }\n      } else {\n         // load the new sibling nodes of the specified node by ajax request\n         let nodeId = hEdge.parentNode.id,\n            url = this._getNodeState(node, \"parent\").exist\n               ? typeof opts.ajaxURL.siblings === \"function\"\n                  ? opts.ajaxURL.siblings(JSON.parse(node.dataset.source))\n                  : opts.ajaxURL.siblings + nodeId\n               : typeof opts.ajaxURL.families === \"function\"\n               ? opts.ajaxURL.families(JSON.parse(node.dataset.source))\n               : opts.ajaxURL.families + nodeId;\n\n         if (this._startLoading(hEdge, node)) {\n            this._getJSON(url)\n               .then(function (resp) {\n                  if (that.dataset.inAjax === \"true\") {\n                     if (resp.siblings || resp.children) {\n                        that.addSiblings(node, resp);\n                     }\n                  }\n               })\n               .catch(function (err) {\n                  console.error(\"Failed to get sibling nodes data\", err);\n               })\n               .finally(function () {\n                  that._endLoading(hEdge, node);\n               });\n         }\n      }\n   }\n   // event handler for toggle buttons in Hybrid(horizontal + vertical) OrgChart\n   _clickToggleButton(event) {\n      let that = this,\n         toggleBtn = event.target,\n         descWrapper = toggleBtn.parentNode.nextElementSibling,\n         descendants = Array.from(descWrapper.querySelectorAll(\".node\")),\n         children = Array.from(descWrapper.children).map((item) =>\n            item.querySelector(\".node\")\n         );\n\n      if (children.some((item) => item.classList.contains(\"slide\"))) {\n         return;\n      }\n      toggleBtn.classList.toggle(\"fa-plus-square\");\n      toggleBtn.classList.toggle(\"fa-minus-square\");\n      if (descendants[0].classList.contains(\"slide-up\")) {\n         descWrapper.classList.remove(\"hidden\");\n         this._repaint(children[0]);\n         this._addClass(children, \"slide\");\n         this._removeClass(children, \"slide-up\");\n         this._one(children[0], \"transitionend\", () => {\n            that._removeClass(children, \"slide\");\n         });\n      } else {\n         this._addClass(descendants, \"slide slide-up\");\n         this._one(descendants[0], \"transitionend\", () => {\n            that._removeClass(descendants, \"slide\");\n            descendants.forEach((desc) => {\n               let ul = that._closest(desc, function (el) {\n                  return el.nodeName === \"UL\";\n               });\n\n               ul.classList.add(\"hidden\");\n            });\n         });\n\n         descendants.forEach((desc) => {\n            let subTBs = Array.from(desc.querySelectorAll(\".toggleBtn\"));\n\n            that._removeClass(subTBs, \"fa-minus-square\");\n            that._addClass(subTBs, \"fa-plus-square\");\n         });\n      }\n   }\n   _dispatchClickEvent(event) {\n      let classList = event.target.classList;\n\n      if (classList.contains(\"topEdge\")) {\n         this._clickTopEdge(event);\n      } else if (\n         classList.contains(\"rightEdge\") ||\n         classList.contains(\"leftEdge\")\n      ) {\n         this._clickHorizontalEdge(event);\n      } else if (classList.contains(\"bottomEdge\")) {\n         this._clickBottomEdge(event);\n      } else if (classList.contains(\"toggleBtn\")) {\n         this._clickToggleButton(event);\n      } else {\n         this._clickNode(event);\n      }\n   }\n   _onDragStart(event) {\n      let nodeDiv = event.target,\n         opts = this.options,\n         isFirefox = /firefox/.test(window.navigator.userAgent.toLowerCase());\n\n      if (isFirefox) {\n         event.dataTransfer.setData(\"text/html\", \"hack for firefox\");\n      }\n      // if users enable zoom or direction options\n      if (this.style.transform) {\n         let ghostNode, nodeCover;\n\n         if (!document.querySelector(\".ghost-node\")) {\n            ghostNode = document.createElementNS(\n               \"http://www.w3.org/2000/svg\",\n               \"svg\"\n            );\n            ghostNode.classList.add(\"ghost-node\");\n            nodeCover = document.createElementNS(\n               \"http://www.w3.org/2000/svg\",\n               \"rect\"\n            );\n            ghostNode.appendChild(nodeCover);\n            this.appendChild(ghostNode);\n         } else {\n            ghostNode = this.querySelector(\":scope > .ghost-node\");\n            nodeCover = ghostNode.children[0];\n         }\n         let transValues = this.style.transform.split(\",\"),\n            scale = Math.abs(\n               window.parseFloat(\n                  opts.direction === \"t2b\" || opts.direction === \"b2t\"\n                     ? transValues[0].slice(transValues[0].indexOf(\"(\") + 1)\n                     : transValues[1]\n               )\n            );\n\n         ghostNode.setAttribute(\"width\", nodeDiv.offsetWidth);\n         ghostNode.setAttribute(\"height\", nodeDiv.offsetHeight);\n         nodeCover.setAttribute(\"x\", 5 * scale);\n         nodeCover.setAttribute(\"y\", 5 * scale);\n         nodeCover.setAttribute(\"width\", 120 * scale);\n         nodeCover.setAttribute(\"height\", 40 * scale);\n         nodeCover.setAttribute(\"rx\", 4 * scale);\n         nodeCover.setAttribute(\"ry\", 4 * scale);\n         nodeCover.setAttribute(\"stroke-width\", 1 * scale);\n         let xOffset = event.offsetX * scale,\n            yOffset = event.offsetY * scale;\n\n         if (opts.direction === \"l2r\") {\n            xOffset = event.offsetY * scale;\n            yOffset = event.offsetX * scale;\n         } else if (opts.direction === \"r2l\") {\n            xOffset = nodeDiv.offsetWidth - event.offsetY * scale;\n            yOffset = event.offsetX * scale;\n         } else if (opts.direction === \"b2t\") {\n            xOffset = nodeDiv.offsetWidth - event.offsetX * scale;\n            yOffset = nodeDiv.offsetHeight - event.offsetY * scale;\n         }\n         if (isFirefox) {\n            // hack for old version of Firefox(< 48.0)\n            let ghostNodeWrapper = document.createElement(\"img\");\n\n            ghostNodeWrapper.src =\n               \"data:image/svg+xml;utf8,\" +\n               new XMLSerializer().serializeToString(ghostNode);\n            event.dataTransfer.setDragImage(ghostNodeWrapper, xOffset, yOffset);\n            nodeCover.setAttribute(\"fill\", \"rgb(255, 255, 255)\");\n            nodeCover.setAttribute(\"stroke\", \"rgb(191, 0, 0)\");\n         } else {\n            event.dataTransfer.setDragImage(ghostNode, xOffset, yOffset);\n         }\n      }\n      let dragged = event.target,\n         dragZone = this._closest(dragged, (el) => {\n            return el.classList && el.classList.contains(\"nodes\");\n         }).parentNode.children[0].querySelector(\".node\"),\n         dragHier = Array.from(\n            this._closest(dragged, (el) => {\n               return el.nodeName === \"TABLE\";\n            }).querySelectorAll(\".node\")\n         );\n\n      this.dragged = dragged;\n      Array.from(this.querySelectorAll(\".node\")).forEach(function (node) {\n         if (!dragHier.includes(node)) {\n            if (opts.dropCriteria) {\n               if (opts.dropCriteria(dragged, dragZone, node)) {\n                  node.classList.add(\"allowedDrop\");\n               }\n            } else {\n               node.classList.add(\"allowedDrop\");\n            }\n         }\n      });\n   }\n   _onDragOver(event) {\n      event.preventDefault();\n      let dropZone = event.currentTarget;\n\n      if (!dropZone.classList.contains(\"allowedDrop\")) {\n         event.dataTransfer.dropEffect = \"none\";\n      }\n   }\n   _onDragEnd(event) {\n      Array.from(this.querySelectorAll(\".allowedDrop\")).forEach(function (el) {\n         el.classList.remove(\"allowedDrop\");\n      });\n   }\n   _onDrop(event) {\n      let dropZone = event.currentTarget,\n         dragged = this.dragged,\n         dragZone = this._closest(dragged, function (el) {\n            return el.classList && el.classList.contains(\"nodes\");\n         }).parentNode.children[0].children[0];\n\n      this._removeClass(\n         Array.from(this.querySelectorAll(\".allowedDrop\")),\n         \"allowedDrop\"\n      );\n      // firstly, deal with the hierarchy of drop zone\n      if (!dropZone.parentNode.parentNode.nextElementSibling) {\n         // if the drop zone is a leaf node\n         let bottomEdge = document.createElement(\"i\");\n\n         bottomEdge.setAttribute(\"class\", \"edge verticalEdge bottomEdge fa\");\n         dropZone.appendChild(bottomEdge);\n         dropZone.parentNode.setAttribute(\"colspan\", 2);\n         let table = this._closest(dropZone, function (el) {\n               return el.nodeName === \"TABLE\";\n            }),\n            upperTr = document.createElement(\"tr\"),\n            lowerTr = document.createElement(\"tr\"),\n            nodeTr = document.createElement(\"tr\");\n\n         upperTr.setAttribute(\"class\", \"lines\");\n         upperTr.innerHTML = `<td colspan=\"2\"><div class=\"downLine\"></div></td>`;\n         table.appendChild(upperTr);\n         lowerTr.setAttribute(\"class\", \"lines\");\n         lowerTr.innerHTML = `<td class=\"rightLine\">&nbsp;</td><td class=\"leftLine\">&nbsp;</td>`;\n         table.appendChild(lowerTr);\n         nodeTr.setAttribute(\"class\", \"nodes\");\n         table.appendChild(nodeTr);\n         Array.from(dragged.querySelectorAll(\".horizontalEdge\")).forEach(\n            (hEdge) => {\n               dragged.removeChild(hEdge);\n            }\n         );\n         let draggedTd = this._closest(\n            dragged,\n            (el) => el.nodeName === \"TABLE\"\n         ).parentNode;\n\n         nodeTr.appendChild(draggedTd);\n      } else {\n         let dropColspan = window.parseInt(dropZone.parentNode.colSpan) + 2;\n\n         dropZone.parentNode.setAttribute(\"colspan\", dropColspan);\n         dropZone.parentNode.parentNode.nextElementSibling.children[0].setAttribute(\n            \"colspan\",\n            dropColspan\n         );\n         if (!dragged.querySelector(\".horizontalEdge\")) {\n            let rightEdge = document.createElement(\"i\"),\n               leftEdge = document.createElement(\"i\");\n\n            rightEdge.setAttribute(\"class\", \"edge horizontalEdge rightEdge fa\");\n            dragged.appendChild(rightEdge);\n            leftEdge.setAttribute(\"class\", \"edge horizontalEdge leftEdge fa\");\n            dragged.appendChild(leftEdge);\n         }\n         let temp =\n               dropZone.parentNode.parentNode.nextElementSibling\n                  .nextElementSibling,\n            leftline = document.createElement(\"td\"),\n            rightline = document.createElement(\"td\");\n\n         leftline.setAttribute(\"class\", \"leftLine topLine\");\n         leftline.innerHTML = `&nbsp;`;\n         temp.insertBefore(leftline, temp.children[1]);\n         rightline.setAttribute(\"class\", \"rightLine topLine\");\n         rightline.innerHTML = `&nbsp;`;\n         temp.insertBefore(rightline, temp.children[2]);\n         temp.nextElementSibling.appendChild(\n            this._closest(dragged, function (el) {\n               return el.nodeName === \"TABLE\";\n            }).parentNode\n         );\n\n         let dropSibs = this._siblings(\n            this._closest(dragged, function (el) {\n               return el.nodeName === \"TABLE\";\n            }).parentNode\n         ).map((el) => el.querySelector(\".node\"));\n\n         if (dropSibs.length === 1) {\n            let rightEdge = document.createElement(\"i\"),\n               leftEdge = document.createElement(\"i\");\n\n            rightEdge.setAttribute(\"class\", \"edge horizontalEdge rightEdge fa\");\n            dropSibs[0].appendChild(rightEdge);\n            leftEdge.setAttribute(\"class\", \"edge horizontalEdge leftEdge fa\");\n            dropSibs[0].appendChild(leftEdge);\n         }\n      }\n      // secondly, deal with the hierarchy of dragged node\n      let dragColSpan = window.parseInt(dragZone.colSpan);\n\n      if (dragColSpan > 2) {\n         dragZone.setAttribute(\"colspan\", dragColSpan - 2);\n         dragZone.parentNode.nextElementSibling.children[0].setAttribute(\n            \"colspan\",\n            dragColSpan - 2\n         );\n         let temp = dragZone.parentNode.nextElementSibling.nextElementSibling;\n\n         temp.children[1].remove();\n         temp.children[1].remove();\n\n         let dragSibs = Array.from(\n            dragZone.parentNode.parentNode.children[3].children\n         ).map(function (td) {\n            return td.querySelector(\".node\");\n         });\n\n         if (dragSibs.length === 1) {\n            dragSibs[0].querySelector(\".leftEdge\").remove();\n            dragSibs[0].querySelector(\".rightEdge\").remove();\n         }\n      } else {\n         dragZone.removeAttribute(\"colspan\");\n         dragZone\n            .querySelector(\".node\")\n            .removeChild(dragZone.querySelector(\".bottomEdge\"));\n         Array.from(dragZone.parentNode.parentNode.children)\n            .slice(1)\n            .forEach((tr) => tr.remove());\n      }\n      let customE = new CustomEvent(\"nodedropped.orgchart\", {\n         detail: {\n            draggedNode: dragged,\n            dragZone: dragZone.children[0],\n            dropZone: dropZone,\n         },\n      });\n\n      this.dispatchEvent(customE);\n   }\n   // create node\n   _createNode(nodeData, level) {\n      let that = this,\n         opts = this.options;\n\n      return new Promise(function (resolve, reject) {\n         if (nodeData.children) {\n            for (let child of nodeData.children) {\n               child.parentId = nodeData.id;\n            }\n         }\n\n         // construct the content of node\n         let nodeDiv = document.createElement(\"div\");\n\n         delete nodeData.children;\n         nodeDiv.dataset.source = JSON.stringify(nodeData);\n         if (nodeData[opts.nodeId]) {\n            nodeDiv.id = nodeData[opts.nodeId];\n         }\n         let inEdit = that.dataset.inEdit,\n            isHidden;\n\n         if (inEdit) {\n            isHidden = inEdit === \"addChildren\" ? \" slide-up\" : \"\";\n         } else {\n            isHidden = level >= opts.depth ? \" slide-up\" : \"\";\n         }\n         nodeDiv.setAttribute(\n            \"class\",\n            \"node \" + (nodeData.className || \"\") + isHidden\n         );\n         if (opts.draggable) {\n            nodeDiv.setAttribute(\"draggable\", true);\n         }\n         if (nodeData.parentId) {\n            nodeDiv.setAttribute(\"data-parent\", nodeData.parentId);\n         }\n         nodeDiv.innerHTML = `\n        <div class=\"title\">${nodeData[opts.nodeTitle]}</div>\n        ${\n           opts.nodeContent\n              ? `<div class=\"content\">${nodeData[opts.nodeContent]}</div>`\n              : \"\"\n        }\n      `;\n         // append 4 direction arrows or expand/collapse buttons\n         let flags = nodeData.relationship || \"\";\n\n         if (opts.verticalDepth && level + 2 > opts.verticalDepth) {\n            if (level + 1 >= opts.verticalDepth && Number(flags.substr(2, 1))) {\n               let toggleBtn = document.createElement(\"i\"),\n                  icon = level + 1 >= opts.depth ? \"plus\" : \"minus\";\n\n               toggleBtn.setAttribute(\n                  \"class\",\n                  \"toggleBtn fa fa-\" + icon + \"-square\"\n               );\n               nodeDiv.appendChild(toggleBtn);\n            }\n         } else {\n            if (Number(flags.substr(0, 1))) {\n               let topEdge = document.createElement(\"i\");\n\n               topEdge.setAttribute(\"class\", \"edge verticalEdge topEdge fa\");\n               nodeDiv.appendChild(topEdge);\n            }\n            if (Number(flags.substr(1, 1))) {\n               let rightEdge = document.createElement(\"i\"),\n                  leftEdge = document.createElement(\"i\");\n\n               rightEdge.setAttribute(\n                  \"class\",\n                  \"edge horizontalEdge rightEdge fa\"\n               );\n               nodeDiv.appendChild(rightEdge);\n               leftEdge.setAttribute(\n                  \"class\",\n                  \"edge horizontalEdge leftEdge fa\"\n               );\n               nodeDiv.appendChild(leftEdge);\n            }\n            if (Number(flags.substr(2, 1))) {\n               let bottomEdge = document.createElement(\"i\"),\n                  symbol = document.createElement(\"i\"),\n                  title = nodeDiv.querySelector(\":scope > .title\");\n\n               bottomEdge.setAttribute(\n                  \"class\",\n                  \"edge verticalEdge bottomEdge fa\"\n               );\n               nodeDiv.appendChild(bottomEdge);\n               symbol.setAttribute(\n                  \"class\",\n                  \"fa \" + opts.parentNodeSymbol + \" symbol\"\n               );\n               title.insertBefore(symbol, title.children[0]);\n            }\n         }\n\n         nodeDiv.addEventListener(\"mouseenter\", that._hoverNode.bind(that));\n         nodeDiv.addEventListener(\"mouseleave\", that._hoverNode.bind(that));\n         nodeDiv.addEventListener(\"click\", that._dispatchClickEvent.bind(that));\n         if (opts.draggable) {\n            nodeDiv.addEventListener(\"dragstart\", that._onDragStart.bind(that));\n            nodeDiv.addEventListener(\"dragover\", that._onDragOver.bind(that));\n            nodeDiv.addEventListener(\"dragend\", that._onDragEnd.bind(that));\n            nodeDiv.addEventListener(\"drop\", that._onDrop.bind(that));\n         }\n         // allow user to append dom modification after finishing node create of orgchart\n         if (opts.createNode) {\n            opts.createNode(nodeDiv, nodeData);\n         }\n\n         resolve(nodeDiv);\n      });\n   }\n   buildHierarchy(appendTo, nodeData, level, callback) {\n      // Construct the node\n      let that = this,\n         opts = this.options,\n         nodeWrapper,\n         childNodes = nodeData.children,\n         isVerticalNode = opts.verticalDepth && level + 1 >= opts.verticalDepth;\n\n      if (Object.keys(nodeData).length > 1) {\n         // if nodeData has nested structure\n         nodeWrapper = isVerticalNode\n            ? appendTo\n            : document.createElement(\"table\");\n         if (!isVerticalNode) {\n            appendTo.appendChild(nodeWrapper);\n         }\n         this._createNode(nodeData, level)\n            .then(function (nodeDiv) {\n               if (isVerticalNode) {\n                  nodeWrapper.insertBefore(nodeDiv, nodeWrapper.firstChild);\n               } else {\n                  let tr = document.createElement(\"tr\");\n\n                  tr.innerHTML = `\n            <td ${childNodes ? `colspan=\"${childNodes.length * 2}\"` : \"\"}>\n            </td>\n          `;\n                  tr.children[0].appendChild(nodeDiv);\n                  nodeWrapper.insertBefore(\n                     tr,\n                     nodeWrapper.children[0] ? nodeWrapper.children[0] : null\n                  );\n               }\n               if (callback) {\n                  callback();\n               }\n            })\n            .catch(function (err) {\n               console.error(\"Failed to creat node\", err);\n            });\n      }\n      // Construct the inferior nodes and connectiong lines\n      if (childNodes) {\n         if (Object.keys(nodeData).length === 1) {\n            // if nodeData is just an array\n            nodeWrapper = appendTo;\n         }\n         let isHidden,\n            isVerticalLayer =\n               opts.verticalDepth && level + 2 >= opts.verticalDepth,\n            inEdit = that.dataset.inEdit;\n\n         if (inEdit) {\n            isHidden = inEdit === \"addSiblings\" ? \"\" : \" hidden\";\n         } else {\n            isHidden = level + 1 >= opts.depth ? \" hidden\" : \"\";\n         }\n\n         // draw the line close to parent node\n         if (!isVerticalLayer) {\n            let tr = document.createElement(\"tr\");\n\n            tr.setAttribute(\"class\", \"lines\" + isHidden);\n            tr.innerHTML = `\n          <td colspan=\"${childNodes.length * 2}\">\n            <div class=\"downLine\"></div>\n          </td>\n        `;\n            nodeWrapper.appendChild(tr);\n         }\n         // draw the lines close to children nodes\n         let lineLayer = document.createElement(\"tr\");\n\n         lineLayer.setAttribute(\"class\", \"lines\" + isHidden);\n         lineLayer.innerHTML = `\n        <td class=\"rightLine\">&nbsp;</td>\n        ${childNodes\n           .slice(1)\n           .map(\n              () => `\n          <td class=\"leftLine topLine\">&nbsp;</td>\n          <td class=\"rightLine topLine\">&nbsp;</td>\n          `\n           )\n           .join(\"\")}\n        <td class=\"leftLine\">&nbsp;</td>\n      `;\n         let nodeLayer;\n\n         if (isVerticalLayer) {\n            nodeLayer = document.createElement(\"ul\");\n            if (isHidden) {\n               nodeLayer.classList.add(isHidden.trim());\n            }\n            if (level + 2 === opts.verticalDepth) {\n               let tr = document.createElement(\"tr\");\n\n               tr.setAttribute(\"class\", \"verticalNodes\" + isHidden);\n               tr.innerHTML = `<td></td>`;\n               tr.firstChild.appendChild(nodeLayer);\n               nodeWrapper.appendChild(tr);\n            } else {\n               nodeWrapper.appendChild(nodeLayer);\n            }\n         } else {\n            nodeLayer = document.createElement(\"tr\");\n            nodeLayer.setAttribute(\"class\", \"nodes\" + isHidden);\n            nodeWrapper.appendChild(lineLayer);\n            nodeWrapper.appendChild(nodeLayer);\n         }\n         // recurse through children nodes\n         childNodes.forEach((child) => {\n            let nodeCell;\n\n            if (isVerticalLayer) {\n               nodeCell = document.createElement(\"li\");\n            } else {\n               nodeCell = document.createElement(\"td\");\n               nodeCell.setAttribute(\"colspan\", 2);\n            }\n            nodeLayer.appendChild(nodeCell);\n            that.buildHierarchy(nodeCell, child, level + 1, callback);\n         });\n      }\n   }\n   _clickChart(event) {\n      let closestNode = this._closest(event.target, function (el) {\n         return el.classList && el.classList.contains(\"node\");\n      });\n\n      if (!closestNode && this.querySelector(\".node.focused\")) {\n         this.querySelector(\".node.focused\").classList.remove(\"focused\");\n      }\n   }\n   _loopChart(chart) {\n      let subObj = { id: chart.querySelector(\".node\").id };\n\n      if (chart.children[3]) {\n         Array.from(chart.children[3].children).forEach((el) => {\n            if (!subObj.children) {\n               subObj.children = [];\n            }\n            subObj.children.push(this._loopChart(el.firstChild));\n         });\n      }\n      return subObj;\n   }\n   getHierarchy() {\n      if (!this.querySelector(\".node\").id) {\n         return \"Error: Nodes of orghcart to be exported must have id attribute!\";\n      }\n      return this._loopChart(this.querySelector(\"table\"));\n   }\n   _onPanStart(event) {\n      let chart = event.currentTarget;\n\n      if (\n         this._closest(\n            event.target,\n            (el) => el.classList && el.classList.contains(\"node\")\n         ) ||\n         (event.touches && event.touches.length > 1)\n      ) {\n         chart.dataset.panning = false;\n         return;\n      }\n      chart.style.cursor = \"move\";\n      chart.dataset.panning = true;\n\n      let lastX = 0,\n         lastY = 0,\n         lastTf = window.getComputedStyle(chart).transform;\n\n      if (lastTf !== \"none\") {\n         let temp = lastTf.split(\",\");\n\n         if (!lastTf.includes(\"3d\")) {\n            lastX = Number.parseInt(temp[4], 10);\n            lastY = Number.parseInt(temp[5], 10);\n         } else {\n            lastX = Number.parseInt(temp[12], 10);\n            lastY = Number.parseInt(temp[13], 10);\n         }\n      }\n      let startX = 0,\n         startY = 0;\n\n      if (!event.targetTouches) {\n         // pan on desktop\n         startX = event.pageX - lastX;\n         startY = event.pageY - lastY;\n      } else if (event.targetTouches.length === 1) {\n         // pan on mobile device\n         startX = event.targetTouches[0].pageX - lastX;\n         startY = event.targetTouches[0].pageY - lastY;\n      } else if (event.targetTouches.length > 1) {\n         return;\n      }\n      chart.dataset.panStart = JSON.stringify({\n         startX: startX,\n         startY: startY,\n      });\n      chart.addEventListener(\"mousemove\", this._onPanning.bind(this));\n      chart.addEventListener(\"touchmove\", this._onPanning.bind(this));\n   }\n   _onPanning(event) {\n      let chart = event.currentTarget;\n\n      if (chart.dataset.panning === \"false\") {\n         return;\n      }\n      let newX = 0,\n         newY = 0,\n         panStart = JSON.parse(chart.dataset.panStart),\n         startX = panStart.startX,\n         startY = panStart.startY;\n\n      if (!event.targetTouches) {\n         // pand on desktop\n         newX = event.pageX - startX;\n         newY = event.pageY - startY;\n      } else if (event.targetTouches.length === 1) {\n         // pan on mobile device\n         newX = event.targetTouches[0].pageX - startX;\n         newY = event.targetTouches[0].pageY - startY;\n      } else if (event.targetTouches.length > 1) {\n         return;\n      }\n      let lastTf = window.getComputedStyle(chart).transform;\n\n      if (lastTf === \"none\") {\n         if (!lastTf.includes(\"3d\")) {\n            chart.style.transform =\n               \"matrix(1, 0, 0, 1, \" + newX + \", \" + newY + \")\";\n         } else {\n            chart.style.transform =\n               \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, \" +\n               newX +\n               \", \" +\n               newY +\n               \", 0, 1)\";\n         }\n      } else {\n         let matrix = lastTf.split(\",\");\n\n         if (!lastTf.includes(\"3d\")) {\n            matrix[4] = newX;\n            matrix[5] = newY + \")\";\n         } else {\n            matrix[12] = newX;\n            matrix[13] = newY;\n         }\n         chart.style.transform = matrix.join(\",\");\n      }\n   }\n   _onPanEnd(event) {\n      if (this.dataset.panning === \"true\") {\n         this.dataset.panning = false;\n         this.style.cursor = \"default\";\n         document.body.removeEventListener(\"mousemove\", this._onPanning);\n         document.body.removeEventListener(\"touchmove\", this._onPanning);\n      }\n   }\n   _setChartScale(chart, newScale) {\n      let lastTf = window.getComputedStyle(chart).transform;\n\n      if (lastTf === \"none\") {\n         chart.style.transform = \"scale(\" + newScale + \",\" + newScale + \")\";\n      } else {\n         let matrix = lastTf.split(\",\");\n\n         if (!lastTf.includes(\"3d\")) {\n            matrix[0] = \"matrix(\" + newScale;\n            matrix[3] = newScale;\n            chart.style.transform =\n               lastTf + \" scale(\" + newScale + \",\" + newScale + \")\";\n         } else {\n            chart.style.transform =\n               lastTf + \" scale3d(\" + newScale + \",\" + newScale + \", 1)\";\n         }\n      }\n      chart.dataset.scale = newScale;\n   }\n   _onWheeling(event) {\n      event.preventDefault();\n\n      let newScale = event.deltaY > 0 ? 0.8 : 1.2;\n\n      this._setChartScale(this, newScale);\n   }\n   _getPinchDist(event) {\n      return Math.sqrt(\n         (event.touches[0].clientX - event.touches[1].clientX) *\n            (event.touches[0].clientX - event.touches[1].clientX) +\n            (event.touches[0].clientY - event.touches[1].clientY) *\n               (event.touches[0].clientY - event.touches[1].clientY)\n      );\n   }\n   _onTouchStart(event) {\n      if (event.touches && event.touches.length === 2) {\n         let dist = this._getPinchDist(event);\n\n         this.dataset.pinching = true;\n         this.dataset.pinchDistStart = dist;\n      }\n   }\n   _onTouchMove(event) {\n      if (this.dataset.pinching) {\n         let dist = this._getPinchDist(event);\n\n         this.dataset.pinchDistEnd = dist;\n      }\n   }\n   _onTouchEnd(event) {\n      if (this.dataset.pinching) {\n         this.dataset.pinching = false;\n         let diff = this.dataset.pinchDistEnd - this.dataset.pinchDistStart;\n\n         if (diff > 0) {\n            this._setChartScale(this, 1);\n         } else if (diff < 0) {\n            this._setChartScale(this, -1);\n         }\n      }\n   }\n}\n\nwindow.customElements.define(\"org-chart\", OrgChart);\n"],"names":[],"sourceRoot":""}