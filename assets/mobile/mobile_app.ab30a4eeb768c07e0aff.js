(globalThis["webpackChunkappbuilder_pwa"] = globalThis["webpackChunkappbuilder_pwa"] || []).push([["app"],{

/***/ 48644:
/*!**********************************!*\
  !*** ./src/js/views/form.f7.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewForm)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formButton.f7.jsx */ 32864);
/* harmony import */ var _formCheckbox_f7_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formCheckbox.f7.jsx */ 91298);
/* harmony import */ var _formConnect_f7_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formConnect.f7.jsx */ 15210);
/* harmony import */ var _formCustom_f7_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formCustom.f7.jsx */ 79481);
/* harmony import */ var _formDatepicker_f7_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formDatepicker.f7.jsx */ 11487);
/* harmony import */ var _formJSON_f7_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formJSON.f7.jsx */ 959);
/* harmony import */ var _formNumber_f7_jsx__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formNumber.f7.jsx */ 67670);
/* harmony import */ var _formReadonly_f7_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./formReadonly.f7.jsx */ 84572);
/* harmony import */ var _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formSelectMultiple.f7.jsx */ 72124);
/* harmony import */ var _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./formSelectSingle.f7.jsx */ 68220);
/* harmony import */ var _formTextbox_f7_jsx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./formTextbox.f7.jsx */ 14377);
/* harmony import */ var _formTree_f7_jsx__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./formTree.f7.jsx */ 163);
/** @jsx $jsx */













class F7ViewForm {
  #AB;
  #settings;
  constructor(AB, settings) {
    this.#AB = AB;
    this.#settings = settings;
    this.record = null;
    this.isLoading = false;
    const definitions = this.datacollection.datasource.fields().map(f => ({
      id: f.id,
      key: f.formComponent().common().key,
      field: f.columnName,
      fieldType: f.key,
      label: f.label,
      // placeholder: f.placeholder,
      settings: f.settings
    })).concat({
      id: "saveButton",
      key: "button",
      field: null,
      fieldType: null,
      label: "Save"
      // placeholder: null,
    });

    this.views = definitions.map(definition => {
      if (definition.settings) definition.settings.required = 1;
      switch (definition.key) {
        case "button":
          return new _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, this, definition);
        case "checkbox":
          return new _formCheckbox_f7_jsx__WEBPACK_IMPORTED_MODULE_1__["default"](AB, this, definition);
        case "connect":
          return new _formConnect_f7_jsx__WEBPACK_IMPORTED_MODULE_2__["default"](AB, this, definition);
        case "fieldcustom":
          return new _formCustom_f7_jsx__WEBPACK_IMPORTED_MODULE_3__["default"](AB, this, definition);
        case "datepicker":
          return new _formDatepicker_f7_jsx__WEBPACK_IMPORTED_MODULE_4__["default"](AB, this, definition);
        case "json":
          return new _formJSON_f7_jsx__WEBPACK_IMPORTED_MODULE_5__["default"](AB, this, definition);
        case "numberbox":
          return new _formNumber_f7_jsx__WEBPACK_IMPORTED_MODULE_6__["default"](AB, this, definition);
        case "fieldreadonly":
          return new _formReadonly_f7_jsx__WEBPACK_IMPORTED_MODULE_7__["default"](AB, this, definition);
        case "selectmultiple":
          return new _formSelectMultiple_f7_jsx__WEBPACK_IMPORTED_MODULE_8__["default"](AB, this, definition);
        case "selectsingle":
          return new _formSelectSingle_f7_jsx__WEBPACK_IMPORTED_MODULE_9__["default"](AB, this, definition);
        case "formtree":
          return new _formTree_f7_jsx__WEBPACK_IMPORTED_MODULE_11__["default"](AB, this, definition);
        default:
          return new _formTextbox_f7_jsx__WEBPACK_IMPORTED_MODULE_10__["default"](AB, this, definition);
      }
    });
  }
  get id() {
    return this.#settings.id;
  }
  get datacollection() {
    return this.#AB.datacollectionByID(this.#settings.dcID);
  }

  /**
   * @method getFormValues
   *
   * @param {webix form} formView
   * @param {ABObject} obj
   * @param {ABDatacollection} dc
   * @param {ABDatacollection} dcLink [optional]
   */
  /*   getFormValues(formView, obj, dc, dcLink) {
     // get the fields that are on this form
     const visibleFields = ["id"]; // we always want the id so we can udpate records
     formView.getValues(function (obj) {
        visibleFields.push(obj.config.name);
     });
      // only get data passed from form
     const allVals = formView.getValues();
     const formVals = {};
     visibleFields.forEach((val) => {
        formVals[val] = allVals[val];
     });
      // get custom values
     this.fieldComponents(
        (comp) =>
           comp instanceof ABViewFormCustom ||
           comp instanceof ABViewFormConnect ||
           comp instanceof ABViewFormDatepicker ||
           comp instanceof ABViewFormSelectMultiple ||
           (comp instanceof ABViewFormJson && comp.settings.type == "filter")
     ).forEach((f) => {
        const vComponent = this.viewComponents[f.id];
        if (vComponent == null) return;
         const field = f.field();
        if (field) {
           const getValue = vComponent.getValue ?? vComponent.logic.getValue;
           if (getValue)
              formVals[field.columnName] = getValue.call(vComponent, formVals);
        }
     });
      // remove connected fields if they were not on the form and they are present in the formVals because it is a datacollection
     obj.connectFields().forEach((f) => {
        if (
           visibleFields.indexOf(f.columnName) == -1 &&
           formVals[f.columnName]
        ) {
           delete formVals[f.columnName];
           delete formVals[f.relationName()];
        }
     });
      // clear undefined values or empty arrays
     for (const prop in formVals) {
        if (formVals[prop] == null || formVals[prop].length == 0)
           formVals[prop] = "";
     }
      // Add parent's data collection cursor when a connect field does not show
     let linkValues;
      if (dcLink) {
        linkValues = dcLink.getCursor();
     }
      if (linkValues) {
        const objectLink = dcLink.datasource;
         const connectFields = obj.connectFields();
        connectFields.forEach((f) => {
           const formFieldCom = this.fieldComponents(
              (fComp) => fComp?.field?.()?.id === f?.id
           );
            if (
              objectLink.id == f.settings.linkObject &&
              formFieldCom.length < 1 && // check field does not show
              formVals[f.columnName] === undefined
           ) {
              const linkColName = f.indexField
                 ? f.indexField.columnName
                 : objectLink.PK();
               formVals[f.columnName] = {};
              formVals[f.columnName][linkColName] =
                 linkValues[linkColName] ?? linkValues.id;
           }
        });
     }
      // NOTE: need to pull data of current cursor to calculate Calculate & Formula fields
     // .formVals variable does not include data that does not display in the Form widget
     const cursorFormVals = Object.assign(dc.getCursor() ?? {}, formVals);
      // Set value of calculate or formula fields to use in record rule
     obj.fields((f) => f.key == "calculate" || f.key == "formula").forEach(
        (f) => {
           if (formVals[f.columnName] == null) {
              let reCalculate = true;
               // WORKAROUND: If "Formula" field will have Filter conditions,
              // Then it is not able to re-calculate on client side
              // because relational data is not full data so FilterComplex will not have data to check
              if (f.key == "formula" && f.settings?.where?.rules?.length > 0) {
                 reCalculate = false;
              }
               formVals[f.columnName] = f.format(cursorFormVals, reCalculate);
           }
        }
     );
      return formVals;
  }
  */

  async init() {
    const ab = this.#AB;
    const record = this.record = this.datacollection.getCursor();
    if (record == null) return;

    //convert boolean for toggle UI
    const parsedRecord = {};
    this.views.forEach(view => {
      if (view.definition.fieldType == null || view instanceof _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"]) return;
      switch (view.definition.fieldType) {
        case "boolean":
          parsedRecord[view.definition.field] = record[view.definition.field] === 1 ? ["on"] : [];
          break;
        case "date":
          {
            const date = record[view.definition.field];
            parsedRecord[view.definition.field] = `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
          }
          break;
        case "datetime":
          {
            const datetime = new Date(record[view.definition.field]);
            const hours = datetime.getHours();
            const minutes = datetime.getMinutes();
            parsedRecord[view.definition.field] = `${datetime.getMonth() + 1}/${datetime.getDate()}/${datetime.getFullYear()}, ${hours <= 12 ? hours : hours % 12}:${minutes < 10 ? `0${minutes.toString()}` : minutes.toString()} ${hours < 12 ? "AM" : "PM"}`;
          }
          break;
        case "number":
          parsedRecord[view.definition.field] = record[view.definition.field].toString();
          break;
        default:
          parsedRecord[view.definition.field] = record[view.definition.field];
          break;
      }
    });

    //fill in form
    ab.$f7.form.fillFromData(`#${this.id}`, parsedRecord);

    // // listen for when we remove the preloader on the smart select then set the value to the select
    // // this is just a hack to get the value of the smart select set we may be able to take this out
    // if (ab.$f7.$(".smartSelectCountry .item-after .preloader").length) {
    //    ab.$(
    //       ".smartSelectCountry .item-after .preloader"
    //    )[0].addEventListener("DOMNodeRemoved", () => {
    //       ab.$f7
    //          .$(
    //             "select[name='Country'] option[value='" +
    //                this.#record.Country +
    //                "']"
    //          )
    //          .prop("selected", "selected");
    //    });
    // }
  }

  viewHTML() {
    const allResults = [];
    let fields = [];
    this.views.forEach(view => {
      if (view.definition.fieldType == null) {
        if (view instanceof _formButton_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"]) {
          const renderedFieldElements = [...fields];
          if (fields.length > 0) allResults.push(() => (0,framework7__WEBPACK_IMPORTED_MODULE_12__["default"])("ul", null, renderedFieldElements));
          allResults.push(view.html());
          fields = [];
        }
        return;
      }
      switch (view.definition.fieldType) {
        case "LongText":
          fields.push((0,framework7__WEBPACK_IMPORTED_MODULE_12__["default"])("li", {
            class: "align-top"
          }, view.html()()));
          break;
        default:
          fields.push((0,framework7__WEBPACK_IMPORTED_MODULE_12__["default"])("li", null, view.html()()));
          break;
      }
    });
    if (fields.length > 0) allResults.push(() => (0,framework7__WEBPACK_IMPORTED_MODULE_12__["default"])("ul", null, fields.map(r => r())));
    return allResults.map(r => r()); // render each jsx template
  }

  html() {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_12__["default"])("form", {
      class: "list list-inset list-strong-ios list-dividers-ios list-outline-ios",
      id: this.id
    }, this.viewHTML());
  }
}

/***/ }),

/***/ 32864:
/*!****************************************!*\
  !*** ./src/js/views/formButton.f7.jsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormButton)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormButton extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  async #save() {
    const ab = this.#AB;
    const form = this.#form;
    const definition = this.definition;
    ab.$(`#${definition.id}`).addClass("button-loading");
    const formData = ab.$f7.form.convertToData(`#${form.id}`);
    if (!ab.$f7.input.validateInputs(`#${form.id}`)) {
      ab.$(`#${definition.id}`).removeClass("button-loading");
      return;
    }
    const parsedFormData = {};
    form.views.forEach(view => {
      const field = view.definition.field;
      switch (view.definition.fieldType) {
        case "boolean":
          if (formData[field].length === 0) {
            parsedFormData[field] = 0;
            break;
          }
          parsedFormData[field] = 1;
          break;
        case "datetime":
          parsedFormData[field] = new Date(formData[field]).toISOString();
          break;
        case "number":
          parsedFormData[field] = parseInt(formData[field]);
          break;
        default:
          parsedFormData[field] = formData[field];
          break;
      }
    });
    const dc = form.datacollection;
    try {
      if (form.record == null) await dc.model.create(parsedFormData);else await dc.model.update(form.record[dc.datasource.PK()], parsedFormData);

      // on success, go back to list page
      ab.$f7.views.current.router.back();
    } catch (e) {
      console.error(e);

      // TODO: popup here:
      const L = ab.Label();
      let text = L("Save Failed");

      // @TODO: instead of stuffing errors into popup message, find the input controls
      // and set them to invalid markers, and add the message to them if possible.

      if (e.errors) {
        try {
          if ("string" == typeof e.errors) e.errors = JSON.parse(e.errors);
        } catch (e) {
          // ignore
        }
        (e.errors || []).forEach(valError => {
          text = `${text}<br>${valError.name}: ${valError.message}`;
        });
      }
      ab.$f7.toast.create({
        icon: '<i class="material-icons">error</i>',
        text,
        position: "center",
        closeTimeout: 2000
      }).open();
    }
    ab.$(`#${definition.id}`).removeClass("button-loading");

    // this.$store.dispatch("updateRecord", {
    //    dcID: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
    //    recordID: form.record.uuid,
    //    record: parsedFormData,
    // });
    // setTimeout(() => {
    //    this.$("#" + btn).removeClass("button-loading");
    // }, 1000);
  }

  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "block"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      onClick: () => this.#save(),
      id: definition.id,
      class: "button button-large button-fill button-preloader",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "preloader"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", null, definition.label)));
  }
}

/***/ }),

/***/ 91298:
/*!******************************************!*\
  !*** ./src/js/views/formCheckbox.f7.jsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormCheckbox)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormCheckbox extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-after"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("label", {
      class: "toggle toggle-init"
    }, definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "checkbox",
      required: true,
      validate: true
    }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "checkbox"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "toggle-icon"
    })))));
  }
}

/***/ }),

/***/ 15210:
/*!*****************************************!*\
  !*** ./src/js/views/formConnect.f7.jsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormConnect)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormConnect extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const connectedType = "selectsingle" || 0;
    return () => {};
  }
}

/***/ }),

/***/ 79481:
/*!****************************************!*\
  !*** ./src/js/views/formCustom.f7.jsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormCustom)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormCustom extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 11487:
/*!********************************************!*\
  !*** ./src/js/views/formDatepicker.f7.jsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormDatepicker)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormDatepicker extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  viewHTML() {
    const definition = this.definition;
    switch (definition.fieldType) {
      case "datetime":
        return definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-datetime",
          placeholder: definition.placeholder,
          readonly: "readonly",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-datetime",
          placeholder: definition.placeholder,
          readonly: "readonly"
        });
      default:
        return definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-date",
          placeholder: definition.placeholder,
          readonly: "readonly",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "text",
          name: definition.field,
          class: "form-datepicker-date",
          placeholder: definition.placeholder,
          readonly: "readonly"
        });
    }
  }
  html() {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, this.definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, this.viewHTML())));
  }
}

/***/ }),

/***/ 66382:
/*!**************************************!*\
  !*** ./src/js/views/formItem.f7.jsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormItem)
/* harmony export */ });
/** @jsx $jsx */

class F7ViewFormItem {
  #definition;
  constructor(definition) {
    this.#definition = definition;
  }
  get definition() {
    return this.#definition;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 959:
/*!**************************************!*\
  !*** ./src/js/views/formJSON.f7.jsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormJSON)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormJSON extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 67670:
/*!****************************************!*\
  !*** ./src/js/views/formNumber.f7.jsx ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormNumber)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormNumber extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    const errorMessage = this.#AB.Label("Only numbers please!");
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "range-slider range-slider-init",
      "data-label": "true"
    }, definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "range",
      value: "50",
      min: "0",
      max: "100",
      step: "1",
      required: true,
      validate: true,
      pattern: "[0-9]*",
      "data-error-message": errorMessage
    }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
      name: definition.field,
      type: "range",
      value: "50",
      min: "0",
      max: "100",
      step: "1",
      pattern: "[0-9]*",
      "data-error-message": errorMessage
    })))));
  }
}

/***/ }),

/***/ 84572:
/*!******************************************!*\
  !*** ./src/js/views/formReadonly.f7.jsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormReadonly)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormReadonly extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 72124:
/*!************************************************!*\
  !*** ./src/js/views/formSelectMultiple.f7.jsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormSelectMultiple)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormSelectMultiple extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      class: "item-link smart-select smart-select-init"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("select", {
      name: definition.name,
      placeholder: definition.placeholder,
      multiple: true
    }, definition.settings.options.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("option", {
      value: item.id
    }, item.text))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-after"
    }))));
  }
}

/***/ }),

/***/ 68220:
/*!**********************************************!*\
  !*** ./src/js/views/formSelectSingle.f7.jsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormSelectSingle)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormSelectSingle extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("select", {
      name: definition.field
    }, definition.settings.options.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("option", {
      value: item.id
    }, item.text))))));
  }
}

/***/ }),

/***/ 14377:
/*!*****************************************!*\
  !*** ./src/js/views/formTextbox.f7.jsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormTextbox)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormTextbox extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    const definition = this.definition;
    let $inputElement = "";
    switch (definition.fieldType) {
      case "LongText":
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
          name: definition.field,
          placeholder: definition.placeholder,
          class: "resizable",
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("textarea", {
          name: definition.field,
          placeholder: definition.placeholder,
          class: "resizable"
        });
        break;
      case "email":
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "email",
          name: definition.field,
          placeholder: definition.placeholder,
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          type: "email",
          name: definition.field,
          placeholder: definition.placeholder,
          required: true,
          validate: true
        });
        break;
      default:
        $inputElement = definition.settings.required === 1 ? (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          name: definition.field,
          type: "text",
          placeholder: definition.placeholder,
          required: true,
          validate: true
        }) : (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("input", {
          name: definition.field,
          type: "text",
          placeholder: definition.placeholder
        });
        break;
    }
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-title item-label"
    }, definition.label), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "item-input-wrap"
    }, $inputElement)));
  }
}

/***/ }),

/***/ 163:
/*!**************************************!*\
  !*** ./src/js/views/formTree.f7.jsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewFormTree)
/* harmony export */ });
/* harmony import */ var _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formItem.f7.jsx */ 66382);
/** @jsx $jsx */


class F7ViewFormTree extends _formItem_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #AB;
  #form;
  constructor(AB, form, definition) {
    super(definition);
    this.#AB = AB;
    this.#form = form;
  }
  html() {
    return () => {};
  }
}

/***/ }),

/***/ 83186:
/*!**********************************!*\
  !*** ./src/js/views/list.f7.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ F7ViewList)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

class F7ViewList {
  #AB;
  #settings;
  constructor(AB, settings) {
    this.#AB = AB;
    this.#settings = settings;
  }
  get id() {
    return this.#settings.id;
  }
  get datacollection() {
    return this.#AB.datacollectionByID(this.#settings.dcID);
  }
  async init() {}
  itemSelected(item) {
    // if there is a detailPage set, then transition there:
    if (this.#settings.detailPage) {
      this.#AB.$f7.view.main.router.navigate("/form", {
        props: {
          isEditMode: true
        },
        ignoreCache: true
      });
    }

    // Make sure our DC registers which item was just selected.
    const dc = this.datacollection;
    if (dc) {
      dc.setCursor(item[dc.datasource.PK()] || item.id || item.uuid);
    }
  }

  // NOTE: this now means OPEN THIS VIEW.
  openView(data) {
    this.#AB.$f7.view.main.router.navigate("/list", {
      props: {
        data: data
      },
      ignoreCache: true
    });
  }
  loadMore() {
    // if (this.$store.getters[this.#settings.dcID].value.hasMore) {
    if (this.datacollection.hasMore()) {
      this.#AB.$store.dispatch("getAppBuilderData", this.#settings.dcID);
    }
  }
  hasMore() {
    if (this.datacollection.hasMore()) {
      return (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "preloader infinite-scroll-preloader"
      });
    }
  }
  viewHTML() {
    return this.#AB.$store.getters[this.#settings.dcID].value.map(item => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: item.uuid,
      class: "swipeout deleted-callback"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "swipeout-content item-content",
      onClick: () => this.itemSelected(item)
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, item.Name))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "swipeout-actions-right"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "swipeout-delete",
      "data-confirm": "Are you sure want to delete this item?",
      "data-confirm-title": "Delete?"
    }, "Delete"))));
  }
  html() {
    if (this.#AB.$store.getters[this.#settings.dcID].value.length === 0) return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content infinite-scroll-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list links-list list-outline list-strong list-dividers skeleton-text skeleton-effect-fade"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, [...Array(20)].map((x, i) => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#"
    }, "Skeleton text will go here"))))));
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content infinite-scroll-content",
      onInfinite: () => this.loadMore()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list links-list list-outline list-strong list-dividers"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, this.viewHTML())), this.hasMore());
  }
}

/***/ }),

/***/ 22167:
/*!******************************!*\
  !*** ./src/pages/404.f7.jsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-inner sliding"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "link back"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "icon icon-back"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-not-md"
    }, "Back"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "title"
    }, "Not found"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block block-strong inset"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("center", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("h1", null, "Sorry"), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null, "Requested content not found.")))));
  };
});

/***/ }),

/***/ 18388:
/*!******************************!*\
  !*** ./src/pages/app.f7.jsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const Application = AB.applications()[0]; // AB.applicationByID("4b7a489a-5fe5-4044-8565-aaa3654300f2");
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    // Login screen demo data
    // let path = document?.location?.pathname ? document.location.pathname : "/";
    let defaultPath = "/";
    let username = "";
    let password = "";
    let versionNumber = Application.version;
    let showingUpdate = false;
    let apiUrl = document?.location?.origin ?? "http://localhost:8080";
    // process.env.NODE_ENV === "production"
    //    ? "https://design.digiserve.org"
    //    : "http://localhost:8010/proxy";

    $store.dispatch("getVersion");
    $on("pageInit", () => {
      // checkForUpdate();
    });
    document.addEventListener("visibilitychange", e => {
      if (document.visibilityState == "visible") {
        checkForUpdate();
      }
    });
    const updatePassword = e => {
      password = $("#" + e).value();
      $update();
    };
    const close = e => {
      $f7.loginScreen.close("#my-login-screen");
    };
    const logout = () => {
      $f7.loginScreen.open("#my-login-screen");
      // $f7.preloader.show();
      // password = "";
      // $update();
      // fetchJson(Api.urls.logout, { method: 'GET' })
      //   .then(data => {
      //     store.dispatch('addCsrfToken', "");
      //     $f7.loginScreen.open("#my-login-screen");
      //     $f7.preloader.hide();
      //   })
      //   .catch(err => {
      //     console.error("logout failed but pretending it didn't");
      //     store.dispatch('addCsrfToken', "");
      //     $f7.loginScreen.open("#my-login-screen");
      //     $f7.preloader.hide();
      //   });
    };

    const authenticate = async () => {
      $(".button-preloader").addClass("button-loading");
      let tempUser = $("#username").value();
      try {
        var data = await AB.Network.post({
          url: apiUrl + "/auth/login",
          params: {
            email: tempUser,
            password: $("#password").value()
          }
        });
        $store.dispatch("setUser", data.user);
        // $store.dispatch("setUsername", $("#username").value());

        // Now attempt to ensure our cookie is set:
        // var result = await AB.Network.get({
        //    url: `${apiUrl}/__getCookie`,
        // });

        $("#password")[0].value = "";
        $f7.loginScreen.close();
        $(".button-preloader").removeClass("button-loading");
        AB.isInitialized = true;
        await checkForUpdate();

        // NOTE: replace this with:
        // const Page = Application.pageByID(LastViewedPageID);
        // Page.openView();
        $f7.view.main.router.navigate("/list", {
          transition: "f7-fade"
        });
      } catch (err) {
        $f7.toast.create({
          icon: '<i class="material-icons">error</i>',
          text: `Login Failed`,
          position: "center",
          closeTimeout: 2000
        }).open();
        $(".button-preloader").removeClass("button-loading");
      }
    };
    const showPasswordPreview = e => {
      $("#passwordPreviewHolder").show();
      $("#passwordHolder").hide();
      $("#passwordPreview").focus();
    };
    const showPassword = e => {
      $("#passwordHolder").show();
      $("#passwordPreviewHolder").hide();
      $("#password").focus();
    };
    async function checkForUpdate() {
      if (!showingUpdate) {
        let getVersionPath = `${apiUrl}${Application.urlCurrentVersion}`;
        const response = await AB.Network.get({
          url: getVersionPath
        });
        const version = response?.version ?? "0.0.0";
        const currVersion = Application.version;
        console.log("getVersionPath: ", version);
        console.log("getCurrVersion: ", currVersion);
        if (currVersion.trim() != version.trim()) {
          showingUpdate = true;
          if ("serviceWorker" in navigator) {
            $f7.dialog.create({
              title: L(`Update Available`),
              content: L(`There is an app update avaiable, tap "Update" to get the latest version.`),
              buttons: [{
                text: L("Cancel"),
                onClick: function (dialog, e) {
                  showingUpdate = false;
                }
              }, {
                text: L(`Update to version {0}`, [version]),
                bold: true,
                cssClass: "bg-color-primary text-color-white",
                onClick: function (dialog, e) {
                  $f7.progressbar.show();
                  navigator.serviceWorker.getRegistrations().then(function (registrations) {
                    let complete = registrations.length;
                    let index = 0;
                    for (let registration of registrations) {
                      registration.unregister().then(boolean => {
                        index++;
                        if (index == complete) {
                          showingUpdate = false;
                          window.location.reload(true);
                        }
                      });
                    }
                    if (complete == 0) {
                      showingUpdate = false;
                      window.location.reload(true);
                    }
                  });
                }
              }],
              verticalButtons: true
            }).open();
          }
        } else {
          // alert("up to date");
        }
      }
    }
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      id: "app"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "panel panel-left panel-cover dark panel-init"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page bg-color-primary"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "navbar-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "title"
    }, Application.label ?? L("PWA")))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center no-margin-bottom"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "70%",
      class: "sidebar_logo"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null)), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list list-outline list-strong list-dividers list-translucent"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "/list",
      class: "item-link item-content panel-close"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-media"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, L("contacts"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, L("List of People"))))), Application.pages().map(p => {
      return (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
        href: `/${p.route}`,
        class: "item-link item-content panel-close"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-media"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
        class: "material-icons"
      }, p.label)), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-inner"
      }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
        class: "item-title"
      }, p.label))));
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      href: "#",
      class: "item-link item-content",
      onClick: () => logout()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-media"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, L("logout"))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title"
    }, L("Log out"))))))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center",
      style: "position: absolute; width: 100%; margin-bottom: 15px; bottom: 0px;"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("p", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "30%"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("br", null), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "version"
    }, "v", versionNumber))))))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view view-main view-init safe-areas",
      "data-url": defaultPath
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "login-screen",
      id: "my-login-screen"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "view"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page bg-color-primary dark"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page-content login-screen-content bg-color-primary"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block text-align-center no-margin-bottom"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("img", {
      src: "assets/mobile/images/digiServe_logo.png",
      width: "60%",
      class: "sidebar_logo"
    })), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("form", {
      action: "javascript: null;",
      onSubmit: () => authenticate()
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "list"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("ul", null, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("E-mail")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      autocorrect: "off",
      autocomplete: "username",
      spellcheck: "false",
      type: "text",
      id: "username",
      name: "username",
      placeholder: L("Your e-mail address")
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "input-clear-button"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: "passwordHolder",
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("Password")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      onClick: () => showPasswordPreview(),
      style: "color: var(--f7-input-clear-button-color); position: absolute; right: 0; padding: 10px; margin-right: -15px; margin-top: -5px;",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, "visibility_off")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "password",
      id: "password",
      name: "password",
      placeholder: L("Your password"),
      value: password,
      onInput: () => updatePassword("password"),
      autocomplete: "current-password",
      autocorrect: "off",
      spellcheck: "false"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      id: "passwordPreviewHolder",
      style: "display: none;",
      class: "item-content item-input"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-title item-label"
    }, L("Password")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "item-input-wrap"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("a", {
      onClick: () => showPassword(),
      style: "color: var(--f7-input-clear-button-color); position: absolute; right: 0; padding: 10px; margin-right: -15px; margin-top: -5px;",
      href: "#"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("i", {
      class: "material-icons"
    }, "visibility")), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("input", {
      type: "text",
      id: "passwordPreview",
      name: "passwordPreview",
      placeholder: L("Your password"),
      value: password,
      onInput: () => updatePassword("passwordPreview"),
      autocomplete: "current-password",
      autocorrect: "off",
      spellcheck: "false"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("li", {
      class: "item-content item-input"
    }))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("button", {
      class: "button color-primary button-outline button-round bg-color-white button-large login-button button-preloader"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "preloader"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-ios"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-line"
    })), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-md"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("svg", {
      viewBox: "0 0 36 36"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("circle", {
      cx: "18",
      cy: "18",
      r: "16"
    }))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "if-aurora"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {
      class: "preloader-inner-circle"
    })))), (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("span", null, L("Sign In"))))))))));
  };
});

/***/ }),

/***/ 84723:
/*!*******************************!*\
  !*** ./src/pages/form.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _js_views_form_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/views/form.f7.jsx */ 48644);
/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    const title = props.isEditMode ? L("Edit Person") : L("Add Person");

    // // NOTE: Programming Quirk:
    // // We seem to need to access our getters for this Page from
    // // within this PageComponent definition.  (maybe) this is how
    // // it registers the components that need to be redrawn when the
    // // related state is updated.
    // let pageID = "ABPage.id";
    // let Page = AB.pageByID(pageID);
    // let allViews = Page.views();
    // allViews.forEach((v) => {
    //    let dc = v.datacollection;
    //    if (dc) {
    //       allGetters[dc.id] = $store.getters[dc.id];
    //    }
    // })

    const dcGetter = $store.getters["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
    const views = [{
      id: "my-form",
      key: "form",
      dcID: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"
    }];

    // for each view on this Page, do:
    const allViews = [];

    // let views = Page.views();
    // views.forEach((v) => {
    // allViews.push(v.html(...));
    // })
    views.forEach(view => {
      switch (view.key) {
        case "form":
          {
            let form = new _js_views_form_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, view);
            /* new Form(
               view.dcID,
               allDCs,
               $,
               $f7,
               $store,
               person
            ); */
            allViews.push(form);
            break;
          }
        default:
        // code block
      }
    });

    let formDatepickerDate = null;
    let formDatepickerDatetime = null;
    $on("pageInit", async (e, page) => {
      const pendingInit = [];
      allViews.forEach(view => {
        const dc = view.datacollection;
        dc?.init();
        const viewInit = async (view, callback) => {
          await view.init();
          callback();
        };
        const init = () => new Promise(resolve => {
          if (dc && !dc.isDataInitialized) {
            $store.dispatch("getAppBuilderData", dc.id);
            const waitDCInit = setInterval(async () => {
              if (dc.isDataInitialized) {
                clearInterval(waitDCInit);
                await viewInit(view, resolve);
              }
            }, 1000);
            return;
          }
          viewInit(view, resolve);
        });
        pendingInit.push(init());
      });
      await Promise.all(pendingInit);
      formDatepickerDate = $f7.calendar.create({
        inputEl: ".form-datepicker-date"
      });
      formDatepickerDatetime = $f7.calendar.create({
        inputEl: ".form-datepicker-datetime",
        timePicker: true,
        dateFormat: {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        }
      });
    });
    $on("pageBeforeRemove", () => {
      formDatepickerDate.destroy();
      formDatepickerDatetime.destroy();
    });
    function viewHTML() {
      const allHTML = [];
      allViews.forEach(view => {
        allHTML.push(view.html());
      });
      return allHTML.map(r => r()); // render each jsx template
    }

    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page",
      "data-name": "form"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-inner sliding"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      class: "link back"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon icon-back"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("span", {
      class: "if-not-md"
    }, L("Back")))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title"
    }, title))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page-content"
    }, viewHTML()));
  };
});

/***/ }),

/***/ 59289:
/*!*******************************!*\
  !*** ./src/pages/home.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 73449);
/** @jsx $jsx */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const init = async () => {
    if (!AB.isInitialized) {
      try {
        const user = await AB.Network.get({
          url: "/mobile/whoami"
        });
        AB.isInitialized = true;
        AB.$f7.view.main.router.navigate("/list", {
          transition: "f7-fade"
        });
      } catch (e) {
        // NOTE: this will catch errors OTHER than the "Reauth" notification
        // errors.  Those will be caught by listening to the AB.Network object
        AB.$f7.loginScreen.open("#my-login-screen");
      }
    } else {
      console.warn("Why is page(/).onPageInit() still getting called?");
    }
  };
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    AB.$ = $;
    AB.$f7 = $f7;
    AB.$store = $store;
    $on("pageInit", async (e, page) => {
      // var panel = $f7.panel.get(".panel-left");
      // panel.open();
      await init();
    });
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "block no-margin text-align-center vertical-container"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {
      class: "preloader vertical-center"
    })));
  };
});

/***/ }),

/***/ 42767:
/*!*******************************!*\
  !*** ./src/pages/list.f7.jsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework7 */ 73449);
/* harmony import */ var _js_views_list_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/views/list.f7.jsx */ 83186);
/** @jsx $jsx */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB => {
  const L = AB.Label();
  return (props, {
    $,
    $h,
    $f7,
    $on,
    $store,
    $update
  }) => {
    const title = L("List of People");
    let allGetters = {};

    // // NOTE: Programming Quirk:
    // // We seem to need to access our getters for this Page from
    // // within this PageComponent definition.  (maybe) this is how
    // // it registers the components that need to be redrawn when the
    // // related state is updated.
    // let pageID = "ABPage.id";
    // let Page = AB.pageByID(pageID);
    // let allViews = Page.views();
    // allViews.forEach((v) => {
    //    let dc = v.datacollection;
    //    if (dc) {
    //       allGetters[dc.id] = $store.getters[dc.id];
    //    }
    // })
    const dcGetter = $store.getters["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
    const allViews = [];
    $on("pageInit", async (e, page) => {
      const pendingInit = [];
      allViews.forEach(view => {
        const dc = view.datacollection;
        dc?.init();
        const viewInit = async (view, callback) => {
          await view.init();
          callback();
        };
        const init = () => new Promise(resolve => {
          if (dc && !dc.isDataInitialized) {
            $store.dispatch("getAppBuilderData", dc.id);
            const waitDCInit = setInterval(async () => {
              if (dc.isDataInitialized) {
                clearInterval(waitDCInit);
                await viewInit(view, resolve);
              }
            }, 1000);
            return;
          }
          viewInit(view, resolve);
        });
        pendingInit.push(init());
      });
      await Promise.all(pendingInit);
      $(".deleted-callback").on("swipeout:deleted", async function (value) {
        await delItem(this.getAttribute("id"));
      });
    });
    let views = [{
      id: "my-list",
      key: "list",
      dcID: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
      detailPage: "ABPage.id"
    }];
    function viewHTML() {
      const allResults = [];

      // allViews.forEach((v) => {
      //    allResults.push(v.html(...));
      // })

      views.forEach(view => {
        switch (view.key) {
          case "list":
            var list = new _js_views_list_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"](AB, view);
            allResults.push(list.html());
            allViews.push(list);
            break;
          default:
          // code block
        }
      });

      return allResults.map(r => r()); // render each jsx template
    }

    async function delItem(id) {
      let dc = allViews[0].datacollection;
      let item = id ? dc.$dc.getItem(id) : dc.getCursor();
      if (!item) {
        item = dc.getFirstRecord();
      }
      console.log("record to delete:", item);
      try {
        await dc.datasource.model().delete(item[dc.datasource.PK()] || item.id || item.uuid);
      } catch (e) {
        console.error(e);
      }
    }

    //
    return () => (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "page"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-bg"
    }), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "navbar-inner"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "left"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      href: "#",
      "data-panel": ".panel-left",
      class: "link icon-only panel-open"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon material-icons"
    }, "menu"))), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title"
    }, title), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title-large"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "title-large-text"
    }, title)), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("div", {
      class: "right"
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("a", {
      class: "link icon-only",
      href: "#",
      onclick: () => {
        AB.$f7.view.main.router.navigate("/form", {
          props: {
            isEditMode: false
          },
          ignoreCache: true
        });
      }
    }, (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon f7-icons if-not-md"
    }, "plus"), (0,framework7__WEBPACK_IMPORTED_MODULE_1__["default"])("i", {
      class: "icon material-icons md-only"
    }, "add"))))), viewHTML());
  };
});

/***/ }),

/***/ 40453:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/app.less ***!
  \*******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ 94015);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ 23645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Your app custom styles here */\n/* login */\n.md .item-input-focused .item-label,\n.md .item-input-focused .item-floating-label {\n  color: inherit;\n}\n.version {\n  font-family: roboto mono, source code pro, Menlo, Monaco, Consolas,\n\t\tcourier new, monospace;\n  font-size: 10px;\n}\n.list-translucent {\n  background-color: rgba(var(--f7-navbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity)) !important;\n  -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n  backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n}\n.list-translucent ul {\n  background-color: transparent !important;\n}\n/* Change Autocomplete styles in Chrome*/\ninput:autofill,\ninput:-webkit-autofill-strong-password,\ninput:-webkit-autofill-strong-password-viewable,\ninput:-webkit-autofill-and-obscured,\ninput:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ntextarea:-webkit-autofill,\ntextarea:-webkit-autofill:hover,\ntextarea:-webkit-autofill:focus,\nselect:-webkit-autofill,\nselect:-webkit-autofill:hover,\nselect:-webkit-autofill:focus {\n  border: 0;\n  -webkit-text-fill-color: #f0582b;\n  -webkit-box-shadow: 0 0 0px 1000px #366889 inset;\n  -webkit-transition: background-color 5000s ease-in-out 0s;\n  transition: background-color 5000s ease-in-out 0s;\n}\n.vertical-container {\n  position: relative;\n  height: 100vh;\n}\n.vertical-center {\n  margin: 0;\n  position: absolute;\n  top: 50%;\n  -ms-transform: translateY(-50%);\n  transform: translateY(-50%);\n}\n", "",{"version":3,"sources":["webpack://./src/css/app.less"],"names":[],"mappings":"AAAA,gCAAgC;AAChC,UAAU;AACV;;EAEC,cAAA;AACD;AACA;EACC;wBAAA;EAEA,eAAA;AACD;AACA;EACC,iIAAA;EAIA,wFAAA;EAEA,gFAAA;AAHD;AAKA;EACC,wCAAA;AAHD;AACA,wCAAwC;AAKxC;;;;;;;;;;;;;EAaC,SAAA;EACA,gCAAA;EACA,gDAAA;EACA,yDAAA;EACA,iDAAA;AAHD;AAKA;EACC,kBAAA;EACA,aAAA;AAHD;AAKA;EACC,SAAA;EACA,kBAAA;EACA,QAAA;EACA,+BAAA;EACA,2BAAA;AAHD","sourcesContent":["/* Your app custom styles here */\n/* login */\n.md .item-input-focused .item-label,\n.md .item-input-focused .item-floating-label {\n\tcolor: inherit;\n}\n.version {\n\tfont-family: roboto mono, source code pro, Menlo, Monaco, Consolas,\n\t\tcourier new, monospace;\n\tfont-size: 10px;\n}\n.list-translucent {\n\tbackground-color: rgba(\n\t\tvar(--f7-navbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)),\n\t\tvar(--f7-bars-translucent-opacity)\n\t) !important;\n\t-webkit-backdrop-filter: saturate(180%)\n\t\tblur(var(--f7-bars-translucent-blur)) !important;\n\tbackdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur)) !important;\n}\n.list-translucent ul {\n\tbackground-color: transparent !important;\n}\n/* Change Autocomplete styles in Chrome*/\ninput:autofill,\ninput:-webkit-autofill-strong-password,\ninput:-webkit-autofill-strong-password-viewable,\ninput:-webkit-autofill-and-obscured,\ninput:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ntextarea:-webkit-autofill,\ntextarea:-webkit-autofill:hover,\ntextarea:-webkit-autofill:focus,\nselect:-webkit-autofill,\nselect:-webkit-autofill:hover,\nselect:-webkit-autofill:focus {\n\tborder: 0;\n\t-webkit-text-fill-color: #f0582b;\n\t-webkit-box-shadow: 0 0 0px 1000px #366889 inset;\n\t-webkit-transition: background-color 5000s ease-in-out 0s;\n\ttransition: background-color 5000s ease-in-out 0s;\n}\n.vertical-container {\n\tposition: relative;\n\theight: 100vh;\n}\n.vertical-center {\n\tmargin: 0;\n\tposition: absolute;\n\ttop: 50%;\n\t-ms-transform: translateY(-50%);\n\ttransform: translateY(-50%);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 22373:
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js?url=false!./src/css/icons.css ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ 94015);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ 23645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Material Icons Font (for MD theme) */\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Material Icons'), local('MaterialIcons-Regular'),\n    url(/assets/mobile/fonts/material-icons.woff2) format('woff2'),\n    url(/assets/mobile/fonts/material-icons.woff) format('woff');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: 'liga';\n}\n\n/* Framework7 Icons Font (for iOS theme) */\n@font-face {\n  font-family: 'Framework7 Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url('/assets/mobile/fonts/Framework7Icons-Regular.woff2') format('woff2'),\n    url('/assets/mobile/fonts/Framework7Icons-Regular.woff') format('woff');\n}\n.f7-icons {\n  font-family: 'Framework7 Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 28px;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  display: inline-block;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-feature-settings: 'liga';\n  -moz-font-feature-settings: 'liga=1';\n  -moz-font-feature-settings: 'liga';\n  font-feature-settings: 'liga';\n  text-align: center;\n}\n", "",{"version":3,"sources":["webpack://./src/css/icons.css"],"names":[],"mappings":"AAAA,uCAAuC;AACvC;EACE,6BAA6B;EAC7B,kBAAkB;EAClB,gBAAgB;EAChB;;gEAE8D;AAChE;AACA;EACE,6BAA6B;EAC7B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,qBAAqB;EACrB,cAAc;EACd,oBAAoB;EACpB,sBAAsB;EACtB,iBAAiB;EACjB,mBAAmB;EACnB,cAAc;EACd,mCAAmC;EACnC,kCAAkC;EAClC,kCAAkC;EAClC,6BAA6B;AAC/B;;AAEA,0CAA0C;AAC1C;EACE,+BAA+B;EAC/B,kBAAkB;EAClB,gBAAgB;EAChB;2EACyE;AAC3E;AACA;EACE,+BAA+B;EAC/B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,cAAc;EACd,sBAAsB;EACtB,oBAAoB;EACpB,qBAAqB;EACrB,mBAAmB;EACnB,iBAAiB;EACjB,cAAc;EACd,mCAAmC;EACnC,kCAAkC;EAClC,kCAAkC;EAClC,qCAAqC;EACrC,oCAAoC;EACpC,kCAAkC;EAClC,6BAA6B;EAC7B,kBAAkB;AACpB","sourcesContent":["/* Material Icons Font (for MD theme) */\n@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Material Icons'), local('MaterialIcons-Regular'),\n    url(/assets/mobile/fonts/material-icons.woff2) format('woff2'),\n    url(/assets/mobile/fonts/material-icons.woff) format('woff');\n}\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: 'liga';\n}\n\n/* Framework7 Icons Font (for iOS theme) */\n@font-face {\n  font-family: 'Framework7 Icons';\n  font-style: normal;\n  font-weight: 400;\n  src: url('/assets/mobile/fonts/Framework7Icons-Regular.woff2') format('woff2'),\n    url('/assets/mobile/fonts/Framework7Icons-Regular.woff') format('woff');\n}\n.f7-icons {\n  font-family: 'Framework7 Icons';\n  font-weight: normal;\n  font-style: normal;\n  font-size: 28px;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  display: inline-block;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-feature-settings: 'liga';\n  -moz-font-feature-settings: 'liga=1';\n  -moz-font-feature-settings: 'liga';\n  font-feature-settings: 'liga';\n  text-align: center;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn-bd": 76225,
	"./bn-bd.js": 76225,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-il": 47207,
	"./en-il.js": 47207,
	"./en-in": 44175,
	"./en-in.js": 44175,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./en-sg": 31662,
	"./en-sg.js": 31662,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-mx": 96112,
	"./es-mx.js": 96112,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fil": 42549,
	"./fil.js": 42549,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./ga": 29295,
	"./ga.js": 29295,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-deva": 27884,
	"./gom-deva.js": 27884,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it-ch": 10150,
	"./it-ch.js": 10150,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 12105,
	"./ka.js": 12105,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ku": 1408,
	"./ku.js": 1408,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mn": 5115,
	"./mn.js": 5115,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./oc-lnc": 92135,
	"./oc-lnc.js": 92135,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 79915,
	"./sr-cyrl.js": 79915,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./tg": 27321,
	"./tg.js": 27321,
	"./th": 9041,
	"./th.js": 9041,
	"./tk": 19005,
	"./tk.js": 19005,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./ug-cn": 9288,
	"./ug-cn.js": 9288,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-mo": 99807,
	"./zh-mo.js": 99807,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 6120:
/*!**************************!*\
  !*** ./src/css/app.less ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ 93379);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./app.less */ 40453);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_app_less__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ 22254:
/*!***************************!*\
  !*** ./src/css/icons.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ 93379);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js?url=false!./icons.css */ 22373);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_url_false_icons_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ 63133:
/*!****************************************!*\
  !*** ./src/js/AppBuilder/ABFactory.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/ABFactoryCore */ 45800);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ 30381);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! nanoid */ 53416);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ 55877);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./platform/FilterComplex */ 10758);
/* harmony import */ var _definitions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definitions.js */ 49670);
/* harmony import */ var _resources_Config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../resources/Config.js */ 77269);
/* harmony import */ var _resources_Account_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../resources/Account.js */ 12968);
/* harmony import */ var _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../resources/Multilingual.js */ 28917);
/* harmony import */ var _resources_Network_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../resources/Network.js */ 93360);
/* harmony import */ var _resources_Storage_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../resources/Storage.js */ 35397);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/ABViewManagerCore */ 85642);
/* harmony import */ var _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../resources/Tenant.js */ 75342);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__, _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_11__]);
([_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__, _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_11__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// const ABFactoryCore = require("./core/ABFactoryCore");





// @TODO: what is F7 method of working with dates?  can we swap libraries with moment?




// import FilterComplex from "./platform/FilterComplex";




//
// Our Common Resources
//

// Config : responsible for all the configuration/settings of our instance.


// Account : manages the current Logged in User and Account information.

// import ClassUI from "../ui/ClassUI.js";

// import Dialog from "./_factory_utils/Dialog.js";
// // Dialog : common UI dialogs.


// Multilingual: our interface Labels and language options


// Network: our interface for communicating to our server


// Storage: manages our interface for local storage




// Tenant: manages the Tenant information of the current instance

// import UISettings from "./uiSettings/config.js";
// // UISettings: detailed settings for our common UI elements

// import Webix from "../js/webix/webix.js";
// // NOTE: moved to require() because using import with webix_debug.js
// // really messed things up!
// // var Webix = require("../js/webix/webix-debug.js");

class ABValidator {
   constructor(AB) {
      this.AB = AB;
      this.errors = [];
   }

   addError(name, message) {
      this.errors.push({ name: name, message: message });
   }

   pass() {
      return this.errors.length == 0;
   }

   fail() {
      return this.errors.length > 0;
   }

   toValidationObject() {
      var obj = {
         error: "E_VALIDATION",
         invalidAttributes: {},
      };

      var attr = obj.invalidAttributes;

      this.errors.forEach((e) => {
         attr[e.name] = attr[e.name] || [];
         attr[e.name].push(e);
      });

      return obj;
   }

   updateForm(form) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isFormValidationError(vObj, form);
   }

   updateGrid(rowID, grid) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isGridValidationError(vObj, rowID, grid);
   }
}

//
// AppBuilder Objects
//

class ABFactory extends _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(definitions) {
      super(definitions);

      // Common Reference to Configuration Values
      this.Config = _resources_Config_js__WEBPACK_IMPORTED_MODULE_6__["default"];
      let appDiv = document.querySelector("#app");
      this.Config.settingsFromDiv(appDiv);

      //
      // Resources
      //
      this.Account = _resources_Account_js__WEBPACK_IMPORTED_MODULE_7__["default"];
      // this.Dialog = Dialog;
      this.Multilingual = _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_8__["default"];
      this.Network = _resources_Network_js__WEBPACK_IMPORTED_MODULE_9__["default"];
      this.Storage = _resources_Storage_js__WEBPACK_IMPORTED_MODULE_10__["default"];
      this.Tenant = _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_12__["default"];
      // this.Webix = Webix;

      // Plugin Classes
      // this.ClassUI = ClassUI;

      // additional Class definitions
      this.Class.FilterComplex = _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_4__["default"];
      this.Class.ABViewManager = _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_11__["default"];

      // Temp placeholders until Resources are implemented:
      this.Analytics = {
         log: () => {},
         logError: () => {},
      };
      this.Lock = class Lock {
         constructor() {}

         acquire() {
            return Promise.resolve();
         }
         release() {
            return Promise.resolve();
         }
      };

      // this.UISettings = UISettings;

      this.Validation = {
         validator: () => {
            return new ABValidator(this);
         },

         errorSailsCleanup: function (error) {
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               // dig down to sails provided error object:
               if (
                  error.error &&
                  error.error == "E_UNKNOWN" &&
                  error.raw &&
                  error.raw.length > 0
               ) {
                  error = error.raw[0];
               }

               // drill down to the embedded .err object if it exists
               if (error.err) {
                  error = error.err;
               }

               // if this is from our server response:
               if (
                  error.data &&
                  error.data.error &&
                  error.data.error == "E_VALIDATION"
               ) {
                  error = error.data;
               }
            }

            return error;
         },

         /**
          * @function AB.Validation.isFormValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of the form elements.
          *
          * @codestart
          * var form = $$('formID');
          * var values = form.getValues();
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Form.isFormValidationError(err, form)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {obj} error
          *        the error response object
          * @param {obj} form
          *        the webix form instance (or reference)
          * @return {bool}
          *         true if error was about a form element.
          *         false otherwise.
          */
         isFormValidationError: function (error, form) {
            var hasFocused = false;
            // {bool} have we set focus to form component?

            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasForm = false;
                     for (var attr in attrs) {
                        // if this is a field in the form:
                        if (form.elements[attr]) {
                           var errors = attrs[attr];
                           var msg = [];
                           errors.forEach(function (err) {
                              msg.push(err.message);
                           });

                           // set the invalid error message
                           form.markInvalid(attr, msg.join(", "));

                           // set focus to the 1st form element we mark:
                           if (!hasFocused) {
                              form.elements[attr].focus();
                              hasFocused = true;
                           }

                           wasForm = true;
                        }
                     }

                     if (wasForm) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our form with an error
            // this was not a validation error so return false
            return false;
         },

         /**
          * @method AB.Validation.isGridValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of our grid columns.
          *
          * @codestart
          * var grid = $$('myGrid');
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Validation.isGridValidationError(err, editor, grid)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {Error} error
          *        the error response object
          * @param {integer} row
          *        the row id of the Grid to update.
          * @param {webix.datatable} Grid
          *        the webix grid instance (or reference)
          * @return {bool}
          *         true if error was about a grid column.
          *         false otherwise.
          */
         isGridValidationError: function (error, row, Grid) {
            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasGrid = false;
                     for (var attr in attrs) {
                        Grid.addCellCss(row, attr, "webix_invalid");
                        Grid.addCellCss(row, attr, "webix_invalid_cell");

                        var msg = [];
                        attrs[attr].forEach((e) => {
                           msg.push(e.message);
                        });

                        webix.alert({
                           text: attr + ": " + msg.join(", "),
                        });

                        wasGrid = true;
                     }

                     Grid.refresh(row);
                     Grid.clearSelection();

                     if (wasGrid) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our Grid with an error
            // this was not a validation error so return false
            return false;
         },
      };

      // TODO: make sure "error" s are handled and sent to logs
      // this.on("error", ()=>{ Analytics.error })

      this.Definitions = {};
      // {obj} the provided interface for working with the ABDefinition table.
      // NOTE: on the web client, we simply perform web API calls to perform
      // the actions.  These are defined below.

      this.on("error", (err) => {
         // this simply prevents thrown errors if there are no listeners.
         console.error(err);
      });

      this._plugins = [];
      // {array} of loaded Plugin.applications.

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our definitionsXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this.Network.on("definition.create", (context, err, fullDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // this.error(err);
            pending?.reject(err);
            return;
         }

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: fullDef.id,
            data: fullDef,
         };
         this.emit("ab.abdefinition.create", pkt);

         let newDef = this.definitionNew(fullDef);
         pending?.resolve(newDef);
      });

      this.Network.on("definition.update", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            if (err.toString().indexOf("Not Found") > -1) {
               return this.definitionCreate(context.values)
                  .then(pending?.resolve)
                  .catch(pending?.reject);
            }
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         this._definitions[context.id] = serverDef;

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: serverDef.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.update", pkt);

         pending?.resolve(serverDef);
      });

      this.Network.on("definition.delete", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         delete this._definitions[context.id];

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: context.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.delete", pkt);

         pending?.resolve();
      });

      //
      // Rules
      //
      const platformRules = {
         /**
          * @method toDate
          *
          * @param {string} dateText
          * @param {Object} options - {
          *                               format: "string",
          *                               ignoreTime: boolean
          *                            }
          * @return {Date}
          */
         toDate: (dateText = "", options = {}) => {
            if (!dateText) return;

            if (options.ignoreTime) dateText = dateText.replace(/T.*/, "");

            let result = options.format
               ? moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText, options.format)
               : moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText);

            let supportFormats = [
               "YYYY-MM-DD",
               "YYYY/MM/DD",
               "DD/MM/YYYY",
               "MM/DD/YYYY",
               "DD-MM-YYYY",
               "MM-DD-YYYY",
            ];

            supportFormats.forEach((format) => {
               if (!result || !result.isValid())
                  result = moment__WEBPACK_IMPORTED_MODULE_2___default()(dateText, format);
            });

            return new Date(result);
         },

         /**
          * @method toDateFormat
          *
          * @param {Date} date
          * @param {Object} options - {
          *           format: "string",
          *           localeCode: "string"
          *         }
          *
          * @return {string}
          */
         toDateFormat: (date, options) => {
            if (!date) return "";

            let momentObj = moment__WEBPACK_IMPORTED_MODULE_2___default()(date);

            if (options.localeCode) momentObj.locale(options.localeCode);

            return momentObj.format(options.format);
         },

         /**
          * @method subtractDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         subtractDate: (date, number, unit) => {
            return moment__WEBPACK_IMPORTED_MODULE_2___default()(date).subtract(number, unit).toDate();
         },

         /**
          * @method addDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         addDate: (date, number, unit) => {
            return moment__WEBPACK_IMPORTED_MODULE_2___default()(date).add(number, unit).toDate();
         },
      };
      (Object.keys(platformRules) || []).forEach((k) => {
         this.rules[k] = platformRules[k];
      });
   }

   /**
    * init()
    * prepare the ABFactory for operation. This includes parsing the
    * definitions into useable objects, preparing the System Resources, etc.
    * @return {Promise}
    */
   async init() {
      //
      // Prepare our Resources First
      //
      var allInits = [];

      allInits.push(this.Account.init(this));
      allInits.push(this.Multilingual.init(this));
      allInits.push(this.Network.init(this));
      allInits.push(this.Tenant.init(this));

      await Promise.all(allInits);
      await this.Storage.init(this);
      var data = await this.Storage.get("local_settings");
      this._localSettings = data || {};

      //
      // Real Time Update Handlers
      //

      // new ABDefinition created:
      this.on("ab.abdefinition.create", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition

         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("created", pkt.id, pkt.data);
      });

      // ABDefinition updated:
      this.on("ab.abdefinition.update", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("updated", pkt.id, pkt.data);
      });

      // ABDefinition delete:
      this.on("ab.abdefinition.delete", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         delete this._definitions[pkt.id];
         this.definitionSync("destroyed", pkt.id, pkt.data);
      });

      return super.init();

      // return Promise.all(allInits)
      //    .then(() => {
      //       // some Resources depend on the above to be .init() before they can
      //       // .init() themselves.
      //       return this.Storage.init(this).then(() => {
      //          return this.Storage.get("local_settings").then((data) => {
      //             this._localSettings = data || {};
      //          });
      //       });
      //    })
      //    .then(() => {
      //       //
      //       // RealTime Updates of our ABDefinitions
      //       //

      //       // new ABDefinition created:
      //       this.on("ab.abdefinition.create", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition

      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("created", pkt.id, pkt.data);
      //       });

      //       // ABDefinition updated:
      //       this.on("ab.abdefinition.update", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("updated", pkt.id, pkt.data);
      //       });

      //       // ABDefinition delete:
      //       this.on("ab.abdefinition.delete", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          delete this._definitions[pkt.id];
      //          this.definitionSync("destroyed", pkt.id, pkt.data);
      //       });

      //       return super.init();
      //    });
   }

   /**
    * definiitonCreate(def)
    * create a new ABDefinition
    * @param {obj} def
    *        the value hash of the new definition entry
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionCreate(def) {
      // we will set our uuid
      if (typeof def.id == "undefined") {
         def.id = this.uuid();
         def.json.id = def.id;
      }

      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.create",
            context: {
               uuid,
            },
         };
         this.Network.post(
            {
               url: `/definition/create`,
               data: def,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to CREATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to CREATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionCreate()",
               message,
               def,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionDestroy(id)
    * delete an ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @return {Promise}
    */
   async definitionDestroy(id) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.delete",
            context: {
               id,
               uuid,
            },
         };
         this.Network.delete(
            {
               url: `/definition/${id}`,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to DESTROY definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to DELETE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionDestroy()",
               message,
               id,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionUpdate(id, def)
    * update an existing ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to update.
    * @param {obj} values
    *        the value hash of the new definition values
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionUpdate(id, values) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.update",
            context: {
               id,
               uuid,
               values,
            },
         };
         this.Network.put(
            {
               url: `/definition/${id}`,
               data: values,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to UPDATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to UPDATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionUpdate()",
               message,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   // definitionsParse(defs = []) {
   //    if (!Array.isArray(defs)) {
   //       defs = [defs];
   //    }

   //    // store/replace the incoming definitions
   //    // 1st: insert ALL our definitions internally
   //    defs.forEach((d) => {
   //       this._definitions[d.id] = d;
   //    });
   //    // 2nd: Now we can then go through and signal the "updates"
   //    // and the related objects can find their dependent definitions.
   //    defs.forEach((d) => {
   //       this.definitionSync("updated", d.id, d);
   //    });

   //    return Promise.resolve();
   // }

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(domain, error, info) {
      console.error("TODO: ABFactory.notify(): pass error off to analytics");
      console.error(error);
      console.error(info);
   }

   plugins() {
      return this._plugins;
   }
   pluginLoad(p) {
      this._plugins.push(p);
   }

   //
   // Utilities
   //
   alert(options) {
      console.error("ABFactory.alert(): Who is calling this!");
      // Webix.alert(options);
   }

   cloneDeep(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().cloneDeep(value);
   }

   error(message, ...rest) {
      var emitData = {
         message: `ABFactory[${this.Tenant.id()}]:${message.toString()}`,
      };

      console.error(emitData.message);
      if (message instanceof Error) {
         emitData.error = message;
         // this dumps the error.stack
         console.error(message);
      }

      if (rest && rest.length > 0) {
         rest.forEach((r) => {
            if (r instanceof Error) {
               emitData.error = r;
               // this dumps the error.stack
               console.error(r);
            }

            if (typeof r == "object") {
               for (var k in r) {
                  emitData[k] = r[k];
                  console.error(k, r[k]);
               }
            }
         });
      }
      this.emit("error", emitData);
   }

   jobID() {
      return (0,nanoid__WEBPACK_IMPORTED_MODULE_13__.nanoid)();
   }

   Label() {
      return (...params) => {
         return this.Multilingual.labelPlugin("mobile", ...params);
      };
   }

   localSettings(key, value) {
      if (typeof value == "undefined") {
         // this is a getter:
         return this._localSettings[key];
      } else {
         // setting a value:
         this._localSettings[key] = value;
         return this.Storage.set(`local_settings`, this._localSettings);
      }
   }

   log(message, ...rest) {
      console.log(message);
      rest.forEach((r) => {
         console.log(r);
      });
   }

   /**
    * @method rules.isUUID
    * evaluate a given value to see if it matches the format of a uuid
    * @param {string} key
    * @return {boolean}
    */
   isUUID(key) {
      var checker = RegExp(
         "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
         "i"
      );
      return checker.test(key);
   }

   merge(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().merge(...params);
   }

   orderBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().orderBy(...params);
   }

   uniq(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().uniq(...params);
   }

   kebabCase(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().kebabCase(...params);
   }

   sumBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().sumBy(...params);
   }

   meanBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().meanBy(...params);
   }

   maxBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().maxBy(...params);
   }

   minBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().minBy(...params);
   }

   uuid() {
      return (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)();
   }

   warn(message, ...rest) {
      console.warn(message);
      rest.forEach((r) => {
         console.warn(r);
      });
   }

   isString(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_1___default().isString(params);
   }
}
const AB = new ABFactory(_definitions_js__WEBPACK_IMPORTED_MODULE_5__["default"].definitions);
AB.Config.config(Window.__ab_config);
await AB.init();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AB);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 71750:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABApplicationCore.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABApplicationCore)
/* harmony export */ });
/* harmony import */ var _platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABViewManager */ 67348);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__]);
_platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/**
 * ABApplicationCore
 *
 * This is the core ABApplication class that manages the common operations
 * of an ABApplication across platforms.
 *
 * It's primary responsibility is to decode a given set of attributes into
 * a working instance of an ABApplication that can return instances of
 * it's defined sub objects.
 *
 * Platform Specific versions of those objects should be defined in a peer
 * directory named platform. These versions of the objects should override
 * these Core objects with platform specific methods of operation (like
 * .save()).
 *
 * Initially your target application should load your platform/ABApplication.js
 * file, which will include this file and sub class it.
 *
 * However, this file will include the remaining files from your platform/*
 * versions.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
// const ABViewManager = require("../platform/ABViewManager");


// var ABMLClass = require("../platform/ABMLClass");


function toBool(val) {
   if (typeof val == "undefined") {
      return false;
   }

   if (val === "" || val === "false" || val === "0") {
      return false;
   }

   if (val === "true" || val === "1") {
      return true;
   }

   return val;
}

class ABApplicationCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(["label", "description"], AB);

      // attributes should be in format:
      // {
      //    id:##,
      //    json:{},
      //    name:"XYZ"
      // }
      attributes.json = attributes.json || {};

      // ABApplication Attributes
      this.id = attributes.id;
      // {string} uuid

      this.type = attributes.type || "application";
      // {string} .type
      // the ABDefinition.type of this object.

      this.appType = attributes.appType || "web";
      // {string} .appType
      // the kind of Application this is. ["web", "mobile"]

      this.json = attributes.json;
      if (typeof this.json == "string") this.json = JSON.parse(this.json);
      // {obj} .json
      // the full settings of this ABApplication

      this.json["versionData"] = attributes.json?.versionData || {
         versionNumber: "1.0.0",
         changeLog: {
            "1.0.0": {
               author: "N/A",
               version: "1.0.0",
               keepVersion: 0,
               commitMessage: "Initial Version",
               timestamp: new Date().toISOString(),
            },
         },
      };

      if (typeof this.json.versionData == "string")
         this.json.versionData = JSON.parse(this.json.versionData);
      // {obj} .json
      // the full version log data of this ABApplication

      this.name = attributes.name || this.json.name || "";
      // {string} .name
      // the hard coded name of this ABDefinition Object, not to be confused
      // with the .label.  The .name is created at design time and is a text
      // reference for this object.

      this.icon = attributes.icon || "fa-rocket";
      // {string} .icon
      // this is a reference to a font awesome icon including the `fa-`
      // example `fa-child` should be stored for the `child` icon to be used
      // if user wants to get creative they can add more to this field following
      // these examples https://fontawesome.com/v4/examples/

      this.isSystemObject = toBool(attributes.isSystemObject);
      // {bool} .isSystemObject
      // is this one of the integrated System Objects used by our framework?
      // Some ABApplications and ABObjects are central to the running of the
      // AppBuilder site.  They are marked with .isSystemObject = true;  It
      // requires the role "System Designer" in order to edit/modify them.

      this.roleAccess = attributes.roleAccess || [];
      if (!Array.isArray(this.roleAccess)) {
         this.roleAccess = [this.roleAccess];
      }
      this.roleAccess = this.roleAccess.filter((r) => r);
      // {array}
      // the {ABSiteRole.id}s of the roles allowed to work with this
      // ABApplication. (see .isAccessManaged for more info)

      this.isAccessManaged = JSON.parse(attributes.isAccessManaged || false);
      // {bool} .isAccessManaged
      // does this Application imploy the more sophisticated  Access
      // permissions, or the simpler Role access permissions.
      // {true} : allows an administrator to set which role can View|Edit|Delete
      //          elements of an application.
      // {false}: indicates users having one of the .roleAccess values can have
      //          full access to this application

      this.accessManagers = attributes.accessManagers;
      if (typeof this.accessManagers == "string")
         this.accessManagers = JSON.parse(this.accessManagers);
      // {??} .accessManagers
      // if .isAccessManaged == true, then .accessManagers contain the definitions
      // of the detailed access permissions.

      this.isTranslationManaged = JSON.parse(
         attributes.isTranslationManaged || false
      );
      this.translationManagers = attributes.translationManagers;
      if (typeof this.translationManagers == "string")
         this.translationManagers = JSON.parse(this.translationManagers);

      this.isTutorialManaged = JSON.parse(
         attributes.isTutorialManaged || false
      );
      this.tutorialManagers = attributes.tutorialManagers;
      if (typeof this.tutorialManagers == "string")
         this.tutorialManagers = JSON.parse(this.tutorialManagers);

      this.hintIDs = attributes.json.hintIDs || [];
      // {array} .hintIDs
      // All the {ABHint.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABHint}s are included or excluded from
      // this app.

      this.objectIDs = attributes.json.objectIDs || [];
      // {array} .objectIDs
      // All the {ABObject.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObject}s are included or excluded from this app.

      this.queryIDs = attributes.json.queryIDs || [];
      // {array} .queryIDs
      // All the {ABObjectQuery.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObjectQueries}s are included or excluded from
      // this app.

      this.datacollectionIDs = attributes.json.datacollectionIDs || [];
      // {array} .datacollectionIDs
      // All the {ABDataCollection.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABDataCollection}s are included or excluded from
      // this app.

      // import all our {ABViewPage}s
      let newPages = [];
      (attributes.json.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            newPages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.id}] is referenceing an unknown Page[${id}]`,
               {
                  appID: this.id,
                  pageID: id,
               }
            );
            // console.error(
            //    `App[${this.id}] is referenceing an unknown Page[${id}]`
            // );
         }
      });
      this._pages = newPages;
      // {array} ._pages
      // an array of all the {ABViewPages} this ABApplication offers as
      // interfaces for working with our Data.
      // ABViewPages operate within the confines of an ABApplication so
      // they are created/stored/accessed from within an ABApplication

      (attributes.json.processIDs || []).forEach((pID) => {
         var p = this.AB.processByID(pID);
         if (!p) {
            this.emit(
               "warning",
               `Application is referencing an unknown process.`,
               { appID: this.id, processID: pID }
            );
         }
      });

      this.processIDs = attributes.json.processIDs || [];
      // {array} .processIDs
      // an array of all the {ABProcess.id}s referenced by this Application.

      // Object List Settings
      attributes.json.objectListSettings =
         attributes.json.objectListSettings || {};
      this.objectListSettings = this.objectListSettings || {};
      this.objectListSettings.isOpen = JSON.parse(
         attributes.json.objectListSettings.isOpen || false
      );
      this.objectListSettings.searchText =
         attributes.json.objectListSettings.searchText || "";
      this.objectListSettings.sortDirection =
         attributes.json.objectListSettings.sortDirection || "asc";
      this.objectListSettings.isGroup = JSON.parse(
         attributes.json.objectListSettings.isGroup || false
      );

      // let the MLClass now process the translations:
      // transition issues:
      attributes.translations =
         attributes.translations || attributes.json.translations;

      super.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return _platform_ABViewManager__WEBPACK_IMPORTED_MODULE_0__["default"];
   }

   /// ABApplication data methods
   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABApplication is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      // if we are on the basic Role assignments:
      if (!this.isAccessManaged) {
         (roles || []).forEach((r) => {
            if (this.roleAccess.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
         return foundRole;
      }

      // isAccessManaged has been set, so 2 kinds of ppl can
      // see this App
      // 1) an AccessManager
      if (parseInt(this.accessManagers.useRole)) {
         (roles || []).forEach((r) => {
            if (this.accessManagers.role.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
      }

      // stop here if found.
      if (foundRole) return foundRole;

      // 2) someone who has a role that can see one of it's pages.
      // scan each Page of this Application
      (this.pages() || []).forEach((p) => {
         // check to see if that page.isAccessibleForRoles()
         if (p.isAccessibleForRoles(roles)) {
            foundRole = true;
         }
      });
      return foundRole;
   }

   get isWebApp() {
      return this.appType == "web";
   }

   get isMobile() {
      return this.appType == "mobile";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      let versionData = this.json.versionData;

      this.json = super.toObj();

      this.json.name = this.name;

      this.json.versionData = versionData;

      this.json.objectIDs = this.objectIDs;

      this.json.objectListSettings = this.objectListSettings;

      this.json.hintIDs = this.hintIDs;

      this.json.queryIDs = this.queryIDs;

      this.json.datacollectionIDs = this.datacollectionIDs;

      this.json.pageIDs = (this._pages || []).map((p) => p.id);

      this.json.processIDs = this.processIDs || [];

      // // for each MobileApp: compile to json
      // var currApps = [];
      // this._mobileApps.forEach((app) => {
      //    currApps.push(app.toObj())
      // })
      // this.json.mobileApps = currApps;

      return {
         id: this.id,
         type: this.type || "application",
         appType: this.appType || "web",
         name: this.name,
         icon: this.icon,
         isSystemObject: this.isSystemObject,
         json: this.json,
         roleAccess: this.roleAccess,
         translations: this.json.translations,
         isAccessManaged: this.isAccessManaged,
         isTranslationManaged: this.isTranslationManaged,
         isTutorialManaged: this.isTutorialManaged,
         accessManagers: this.accessManagers,
         translationManagers: this.translationManagers,
         tutorialManagers: this.tutorialManagers,
      };
   }

   ///
   /// Mobile Apps
   ///

   ///
   /// Datacollections
   ///

   // datacollectionNew(values) {
   //    return new ABDataCollectionCore(values, this);
   // }

   datacollectionsExcluded(filter = () => true) {
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   datacollectionsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Objects
   ///

   objectsExcluded(filter = () => true) {
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   objectsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Hints
   ///

   hintsExcluded(filter = () => true) {
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) == -1;
      }).filter(filter);
   }

   hintsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   /**
    * @method connectedObjects()
    *
    * return an array of all the connected ABObjects for a given ABObject.
    *
    * @param {string} id
    *        an ID of an ABObject
    * @return {array}   array of options for webix select
    *         [ {id, value}, ... ]
    */
   connectedObjects(id) {
      console.error(
         "ABApplicationCore.connectedObjects(): who is calling this?"
      );

      if (id == "") return [];

      // Determine the object from the ID
      var myObj = this.AB.objectByID(id);

      // Get all the connected Fields for that object
      var connectedFields = myObj.connectFields();
      // Store the related fields associatively inside their related Objects ID
      var connectedObj = {};
      connectedFields.forEach((f) => {
         connectedObj[f.settings.linkObject] = this.AB.objectByID(
            f.settings.linkObject
         );
      });
      // Look up the objects by their ID and push them in an options array
      var linkedObjects = [];
      Object.keys(connectedObj).forEach(function (key /*, index */) {
         linkedObjects.push({
            id: this[key].id,
            value: this[key].label,
         });
      }, connectedObj /* = this. inside fn */);

      return linkedObjects;
   }

   /**
    * @method connectedFields()
    * return an array of all the connected ABFields for a given ABObject
    * @param {string} currObjID
    *        an ID of the current ABObject
    * @param {string} linkedObjectID
    *        an ID of the linked ABObject
    * @return {array}
    *        array of options for webix select
    */
   connectedFields(currObjID, linkedObjectID) {
      console.error("!!! Who is calling this?");

      // Determine the object from the currObjID
      var myObj = this.AB.objectByID(currObjID);

      // Get all the connected Fields for our object that match the linkedObjectID
      var connectedFields = myObj.connectFields(
         (f) => f.settings.linkObject == linkedObjectID
      );
      // Build an arry of options for the webix select
      var linkedFields = [];
      connectedFields.forEach((f) => {
         linkedFields.push({ id: f.columnName, value: f.label });
      });

      return linkedFields;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    * return an array of all the ABViewPages for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABViewPages that this fn
    *        returns true for.
    * @param {boolean} deep
    *        flag to search in sub pages
    * @return {array}
    *        array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      if (!this._pages || this._pages.length < 1) return result;

      // find into sub-pages recursively
      if (filter && deep) {
         result = this._pages.filter(filter);

         if (result.length < 1) {
            this._pages.forEach((p) => {
               var subPages = p.pages(filter, deep);
               if (subPages && subPages.length > 0) {
                  result = subPages;
               }
            });
         }
      }
      // find root pages
      else {
         result = (this._pages || []).filter(filter);
      }

      return result;
   }

   ///
   /// Processes
   ///

   /**
    * @method processes()
    * return an array of all the ABProcesses for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABProcesses that
    *        this fn returns true for.
    * @return {array}
    *        array of ABProcesses
    */
   processes(filter = () => true) {
      return this.AB.processes((p) => {
         return this.processIDs.indexOf(p.id) > -1;
      }).filter(filter);
   }

   hasProcess(process) {
      if (process && process.id) {
         return this.processIDs.indexOf(process.id) > -1;
      } else {
         return false;
      }
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    * return an array of all the Views for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of Views that this fn
    *        returns true for.
    * @return {array}
    *        array of Views
    */
   views(filter) {
      var result = [];
      var views = [];
      var pages = [];

      if (
         (!this._pages || this._pages.length < 1) &&
         (!this._views || this._views.length < 1)
      )
         return result;

      function lookDeep(view) {
         if (view._pages && view._pages.length) {
            view._pages.forEach((p) => {
               // check the page views recusively
               var pageViews = p.views(filter, true);
               // if there was a match store it
               if (pageViews && pageViews.length > 0) {
                  result = pageViews;
               }
               // if no match move on to the subpages
               if (result.length < 1) {
                  // loop through each subpage recursively
                  var subPages = p.pages(filter, true);
                  // if there was a match store it
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
                  if (result.length < 1) {
                     lookDeep(p);
                  }
               }
            });
         }
      }

      // look at views recursively
      if (filter) {
         // look at views recursively (views can have subviews and so on)
         if (this._views) {
            views = this._views.filter(filter);

            if (views.length < 1) {
               this._views.forEach((v) => {
                  var subViews = v.views(filter, true);
                  if (subViews && subViews.length > 0) {
                     views = subViews;
                  }
               });
            }
         }

         // if no views of the root page match now look at the sub pages and their views
         if (views.length) {
            result = views;
         } else {
            // check the first level subpages
            result = this._pages.filter(filter);

            // if no match check each pages views and subpages
            if (result.length < 1) {
               // looping through pages
               lookDeep(this);
            }
         }
      }
      // find all views
      else {
         // recusively gather all views on this view
         if (this._views) {
            views = this._views;
            if (views.length) {
               views.forEach((v) => {
                  var subViews = v.views(() => true, true);
                  if (subViews && subViews.length) {
                     views = views.concat(subViews);
                  }
               });
            }
         }

         // recursively gather all pages and their views
         if (this._pages) {
            pages = this._pages;
            if (pages.length) {
               pages.forEach((p) => {
                  // grab all views on this page
                  var pageViews = p.views(() => true, true);
                  if (pageViews && pageViews.length) {
                     views = views.concat(pageViews);
                  }
                  // grab all subpages on this page
                  var subPages = p.pages(() => true, true);
                  if (subPages && subPages.length) {
                     pages = pages.concat(subPages);
                     subPages.forEach((sub) => {
                        var subViews = sub.views(() => true, true);
                        if (subViews && subViews.length) {
                           views = views.concat(subViews);
                        }
                     });
                  }
               });
            }
         }

         result = result.concat(pages, views);
      }

      return result;
   }

   /**
    * @method viewAll()
    * return a list of all the {ABViewxxx} classes available.
    * @return {array} of ABView objects
    */
   viewAll(fn = () => true) {
      return this.ViewManager.allViews(fn);
   }

   ///
   /// Queries
   ///

   /**
    * queriesExcluded()
    * return a list of ABObjectQuery(s) that are not included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @return {array}
    */
   queriesExcluded(filter = () => true) {
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) == -1;
      }).filter(filter);
   }

   /**
    * queriesIncluded()
    * return a list of ABObjectQuery(s) that are included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @param {fn} [sort] function to sort by, default is .label
    * @return {array}
    */
   queriesIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Roles
   ///

   /**
    * @method roles()
    * return an array of all the ABRole for this ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which roles to return.
    * @return {array}   array of ABRole
    */
   // roles(filter = () => true) {
   //    return (this.role || []).filter(filter);
   // }

   /**
    * @method urlResolve()
    * given an object pointer, return the specific object referenced.
    * pointer must start with a '#', use '/' as delimiters, and either
    * reference an object's .id, or an object's .property.
    * for example:
    * #/_objects   : resolves to the array of ._objects pointed to by this
    *               application.
    * #/_objects/[object.id] : reolved to a specific object
    * #/_objects/[object.id]/_fields/[field.id] : resolves to a specific data field
    *               refereced by object.id.
    *
    * @param {string} pointer : the string url referencing the object you want
    *                       to retrieve.
    * @return {obj}
    */
   urlResolve(pointer) {
      var parts = pointer.split("/");

      var parseStep = (obj, steps) => {
         // we're done.  obj is what we are looking for:
         if (steps.length == 0) {
            return obj;
         }

         // pull the next step key:
         var key = steps.shift();

         // special case, "#" makes sure we are talking about the
         // Application object
         if (key == "#") {
            return parseStep(this, steps);
         }

         // if obj is an [], then key should be an .id reference to
         // lookup:
         if (Array.isArray(obj)) {
            obj = obj.filter(function (o) {
               return o.id == key;
            })[0];
            return parseStep(obj, steps);
         }

         // otherwise obj should be an {} and key a property:
         if (obj && obj[key]) {
            return parseStep(obj[key], steps);
         }

         if (key == "_objects") {
            console.error(new Error("REFACTOR: old objectBy url reference:"));

            // This can be gotten from our AB
            var id = steps.shift();
            return parseStep(this.AB.objectByID(id), steps);
         }

         // if we got here, there is an error!
         // console.error('!!! failed to lookup url:'+pointer);
         console.error("!!! failed to lookup url:" + pointer);
         return null;
      };

      return parseStep(this, parts);
   }

   /**
    * @method urlPointer()
    * return the url pointer for this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      // NOTE: if we need to expand this to search across
      // applications, then add in this application.id here:
      if (acrossApp) return "#/" + this.id + "/";
      else return "#/";
   }

   /**
    * @method urlObject()
    * return the url pointer for objects in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlObject(acrossApp) {
      return this.urlPointer(acrossApp) + "_objects/";
   }

   /**
    * @method urlView()
    * return the url pointer for pages in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPage(acrossApp) {
      return this.urlPointer(acrossApp) + "_pages/";
   }

   /**
    * @method urlQuery()
    * return the url pointer for queries in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlQuery(acrossApp) {
      return this.urlPointer(acrossApp) + "_queries/";
   }

   ///
   ///   Object List Settings
   ///
   get objectlistIsOpen() {
      return this.objectListSettings.isOpen;
   }

   set objectlistIsOpen(isOpen) {
      this.objectListSettings.isOpen = isOpen;
   }

   get objectlistSearchText() {
      return this.objectListSettings.searchText;
   }

   set objectlistSearchText(searchText) {
      this.objectListSettings.searchText = searchText;
   }

   get objectlistSortDirection() {
      return this.objectListSettings.sortDirection;
   }

   set objectlistSortDirection(sortDirection) {
      this.objectListSettings.sortDirection = sortDirection;
   }

   get objectlistIsGroup() {
      return this.objectListSettings.isGroup;
   }

   set objectlistIsGroup(isGroup) {
      this.objectListSettings.isGroup = isGroup;
   }

   ///
   /// Instance generators
   ///

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABApplication.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      // values.key = ABViewPageCore.common().key;
      values.key = "page";

      return this.ViewManager.newView(values, this, null);
   }

   /**
    * @method pageByID()
    * return pages from the given {id}
    * @param {string} id
    *        the uuid of the page to return.
    * @return {ABViewPage}
    */
   pageByID(id) {
      return this.pages((f) => f.id == id)[0];
   }

   get urlCurrentVersion() {
      return `/mobile/version/${this.id}`;
   }

   get version() {
      return this.json.versionData?.versionNumber || "0.0.0";
   }

   /**
    * @method viewNew()
    *
    * return an instance of a new (unsaved) ABView.
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.ViewManager.newView(values, application, parent);
   }

   ///
   /// Utilities
   ///

   cloneDeep(/* object */) {
      var errorDepreciated = new Error(
         "ABApplicationCore.cloneDeep(): Depreciated!  Use AB.cloneDeep() instead."
      );
      throw errorDepreciated;

      // return JSON.parse(JSON.stringify(object));
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 39807:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABApplicationMobileCore.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABApplicationMobileCore)
/* harmony export */ });
/* harmony import */ var _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABApplication */ 10285);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__]);
_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/**
 * ABApplicationMobileCore
 *
 * This is the core ABApplicationMobile class that manages the common operations
 * of a Mobile PWA ABApplication.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
const ABViewManagerMobile = __webpack_require__(/*! ../platform/ABViewManager */ 67348);


class ABApplicationMobileCore extends _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.appType = "mobile"; // Just making sure.
      this.networkType = attributes.networkType;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return ABViewManagerMobile;
   }

   pageNew(def) {
      console.error("TODO: pageNew for ApplicationMobile");
      return null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var json = super.toObj();
      json.appType = "mobile";
      json.networkType = this.networkType;

      return json;
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 47621:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/core/ABDataCollectionCore.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDataCollectionCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/*
 * ABDataCollection
 * Defines a set of data that other parts of the Application can work with.
 * it can point to either an ABObject, or ABObjectQuery, and can have an
 * filter, and sorts defined.
 *
 *
 *
 */
// const ABEmitter = require("../platform/ABEmitter");


// const ABObject = require("../platform/ABObject");
// const ABObjectQuery = require("../platform/ABObjectQuery");
// const RowFilter = require("../platform/RowFilter");

var DefaultValues = {
   id: "uuid",
   label: "", // label
   object: {}, // json of ABObject
   query: {}, // json of ABObjectQuery
   settings: {
      datasourceID: "", // id of ABObject or ABObjectQuery
      linkDatacollectionID: "", // id of ABDatacollection
      linkFieldID: "", // id of ABField
      followDatacollectionID: "", // id of ABDatacollection
      objectWorkspace: {
         filterConditions: {
            // array of filters to apply to the data table
            glue: "and",
            rules: [],
         },
         sortFields: [], // array of columns with their sort configurations
      },
      loadAll: false,
      // preventPopulate: false, depreciating in favour of populate
      populate: true, // true/false or array of columns to populate.
      isQuery: false, // if true it is a query, otherwise it is a object.

      fixSelect: "", // _CurrentUser, _FirstRecord, _FirstRecordDefault or row id

      syncType: 1, // 1 (Server), 2 (Client)
   },
};

const QueuedOperations = [];
// {array} of operations that we want to perform but allow some space
// between operations.
var _queueTimer = null;

function runQueue() {
   // if (!_queueTimer) {
   //    _queueTimer = setInterval(() => {
   //       runQueue();
   //    }, 20);
   // }
   if (QueuedOperations.length == 0) {
      // stop
      // clearInterval(_queueTimer);
      _queueTimer = null;
      return;
   }
   var op = QueuedOperations.shift();
   op.fn();
   _queueTimer = setTimeout(runQueue, op.timeout);
}
function queueOperation(fn, timeout = 20) {
   QueuedOperations.push({ fn, timeout });
   if (!_queueTimer) {
      runQueue();
   }
}

class ABDataCollectionCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      attributes = attributes || {};

      // this.application = application;

      this.fromValues(attributes);

      this.__dataCollection = this._dataCollectionNew([]);
      // {DataCollection}
      // This is a working instance of a DataCollection, not an {ABDatacCollection}
      // On web/mobile this is a webix component.  So keep the creation as part of
      // the platform/ABDataCollection implementation.

      // Set filter value
      this.refreshFilterConditions();

      this.__bindComponentIds = [];
      this.__flexComponentIds = [];

      // refresh a data collection
      // this.init();

      // mark data status does not be initialized
      this._dataStatus = this.dataStatusFlag.notInitial;

      this.__filterCond = null;
      // {QueryCondition}
      // A passed in Query Condition for filtering our DataCollection.
      // This value is ANDed with our normal filter conditions.
   }

   /**
    * contextKey()
    *
    * return a unique key that represents data from/for this type of object.
    *
    * used when creating Network jobs and needing to be notified when a job
    * is complete.  We send a contextKey() to the Network job and then listen
    * for it to know when it is complete.
    * @return {string}
    */
   static contextKey() {
      return "datacollection";
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id;
      // {string} .id
      // the uuid of this ABDataCollection Definition.

      this.name = values.name || null;
      // {string} .name
      // the unchanging name of this ABDataCollection

      this.type = values.type || "datacollection";
      // {string} .type
      // the type of ABDefinition this is.

      values.settings = values.settings || {};
      this.settings = this.settings || {};
      // {obj} .settings
      // the specific operation values for this ABDataCollection

      this.settings.linkDatacollectionID =
         values.settings.linkDatacollectionID ||
         DefaultValues.settings.linkDatacollectionID;
      // {string} .settings.linkDaacollectionID
      // the uuid of another ABDataCollection that provides the link/trigger
      // for filtering the values of this ABDataCollection.

      this.settings.linkFieldID =
         values.settings.linkFieldID || DefaultValues.settings.linkFieldID;
      // {string} .settings.linkFieldID
      // the uuid of the ABDataField of the .linkDatacollection ABObject
      // whose value is the trigger value for this ABDataCollection

      this.settings.followDatacollectionID =
         values.settings.followDatacollectionID ||
         DefaultValues.settings.followDatacollectionID;
      // {string} .settings.followDatacollectionID
      // the uuid of another ABDataCollection that provides the follow cursor data collection

      this.settings.objectWorkspace = values.settings.objectWorkspace || {
         filterConditions:
            DefaultValues.settings.objectWorkspace.filterConditions,
         sortFields: DefaultValues.settings.objectWorkspace.sortFields,
      };
      // {obj} .settings.objectWorkspace
      // the default settings for what is shown in the AppBuilder's
      // DataCollection workspace

      this.settings.fixSelect = values.settings.fixSelect;

      // Convert to boolean
      this.settings.loadAll = JSON.parse(
         values.settings.loadAll || DefaultValues.settings.loadAll
      );
      // {bool} .settings.loadAll
      // do we load all the data at one time? false == load by pages.

      this.settings.isQuery = JSON.parse(
         values.settings.isQuery || DefaultValues.settings.isQuery
      );
      // {bool} .settings.isQuery
      // is the data source for this ABDataCollection based upon an
      // ABObjectQuery?

      this.settings.populate = (() => {
         // First check .populate
         if (values.settings.populate != undefined) {
            return values.settings.populate;
            // Then check legacy .preventPopulate
         } else if (
            values.settings.preventPopulate == true ||
            values.settings.preventPopulate == "1"
         ) {
            return false;
         } else return DefaultValues.settings.populate;
      })();
      // {bool | array} populate
      // Control whcih related connections to populate. Default, true, populates
      // all connections. False loads no connnections. Also accepts an array of
      // column names to load specefic connections.

      // Convert to number
      this.settings.syncType = parseInt(
         values.settings.syncType || DefaultValues.settings.syncType
      );
      // {int} .settings.syncType
      // how is the data between this ABDataCollection and it's
      // .datasource synced?

      this.__datasource = null;
      // {obj} .__datasource
      // the reference to the ABObject/ABObjectQuery that this ABDataCollection
      // is based off of.

      this.settings.datasourceID =
         values.settings.datasourceID || DefaultValues.settings.datasourceID;
      // {string} .settings.datasourceID
      // the uuid of the .__datasource object to use

      // now lookup and reference the proper datasource
      if (this.settings.datasourceID) {
         // check for an ABObject
         var obj = this.AB.objectByID(this.settings.datasourceID);
         if (!obj) {
            // this must be an ABObjectQuery then ...
            obj = this.AB.queryByID(this.settings.datasourceID);
         }

         if (obj) {
            this.__datasource = obj;
            this.settings.isQuery = obj.type === "query";
            if (this.settings.isQuery) {
               if (this.__datasource.isGroup) {
                  if (!this.__treeCollection)
                     this.__treeCollection = this._treeCollectionNew();
                  // {TreeCollection}
                  // This is a webix TreeCollection (or similar)
                  // keep it's implementation as part of the platform

                  this.__isGroup = true;
               }
            }
         } else {
            console.error(
               `ABDataCollection[${this.name}][${this.id}] unable to find datasource [${this.settings.datasourceID}]`
            );
         }
      }

      // // Populate data source: ABObject or ABObjectQuery
      // if (values.query && values.query[0]) {
      //    this.__datasource = new ABObjectQuery(
      //       values.query[0],
      //       this.application
      //    );
      //    this.settings.isQuery = true;

      //    if (this.__datasource.isGroup) {
      //       if (!this.__treeCollection)
      //          this.__treeCollection = this._treeCollectionNew();

      //       this.__isGroup = true;
      //    }
      // } else if (values.object && values.object[0]) {
      //    this.__datasource = new ABObject(values.object[0], this.application);
      //    this.settings.isQuery = false;
      // }

      // let the MLClass now process the translations:
      super.fromValues(values);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj(); // untranslate the object

      return {
         id: this.id,
         name: this.name || this.label,
         type: this.type || "datacollection",
         settings: this.AB.cloneDeep(this.settings || {}),
         translations: obj.translations,
      };
   }

   /**
    * @method save()
    *
    * persist this instance of ABDatacollection with it's parent
    *
    *
    * @return {Promise}
    *      .resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      return this;
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABDatacollection
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      var removeFromApplications = () => {
         return new Promise((next, err) => {
            // this.AB.applications().then((apps) => {

            const apps = this.AB.applications();
            // NOTE: apps is a webix datacollection

            var allRemoves = [];

            var appsWithObject = apps.filter((a) => {
               return a.datacollectionsIncluded((o) => o.id == this.id);
            });
            appsWithObject.forEach((app) => {
               allRemoves.push(app.datacollectionRemove(this));
            });

            return Promise.all(allRemoves).then(next).catch(err);
            // });
         });
      };

      return Promise.resolve()
         .then(() => {
            return removeFromApplications();
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @property $dc
    * return the underlying webix datacollection
    * @return {webix.datacollection}
    */
   get $dc() {
      return this.__dataCollection;
   }

   /**
    * @property datasource
    * return a object of this component.
    *
    * @return {ABObject|ABObjectQuery}
    */
   get datasource() {
      if (!this.__datasource) {
         if (this.id && this.name) {
            // occassionally we have blank DCs (without .id or .name)
            // and I don't want to see errors for those
            var err = new Error(
               `DataCollection[${this.name}][${this.id}] missing reference datasource`
            );
            this.AB.notify("builder", err, { datacollection: this.toObj() });
         }
         return null;
      }
      var obj = this.AB.objectByID(this.__datasource.id);
      if (!obj) {
         obj = this.AB.queryByID(this.__datasource.id);
      }
      return obj;
   }

   /**
    * @property datasource
    * set a object to data collection
    *
    * @param {ABObject|ABObjectQuery} object
    */
   set datasource(object) {
      this.__datasource = object;

      this.refreshFilterConditions();
   }

   /**
    * @property sourceType
    * return type of source.
    *
    * @return {string} - 'object' or 'query'
    */
   get sourceType() {
      return this.settings.isQuery ? "query" : "object";
   }

   /**
    * @method datacollectionLink
    * return a ABDatacollection that link of this.
    *
    * @return {ABDatacollection}
    */
   get datacollectionLink() {
      if (!this.AB) return null;

      return this.AB.datacollectionByID(this.settings.linkDatacollectionID);
   }

   /**
    * @property fieldLink
    * return a ABFieldConnect field that link of this.
    *
    * @return {ABFieldConnect}
    */
   get fieldLink() {
      let object = this.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.linkFieldID);
   }

   /**
    * @property model
    * return a source model
    *
    * @return ABModel
    */
   get model() {
      let object = this.datasource; // already notified

      return object ? object.model() : null;
   }

   get dataStatusFlag() {
      return {
         notInitial: 0,
         initializing: 1,
         initialized: 2,
      };
   }

   get dataStatus() {
      return this._dataStatus;
   }

   get isDataInitialized() {
      return this.dataStatus == this.dataStatusFlag.initialized;
   }

   dataInitialized() {
      this.dataStatus = this.dataStatusFlag.initialized;
   }

   ///
   /// Cursor
   ///

   setCursor(itemId) {
      // If the static cursor is set, then this DC could not set cursor to other rows
      if (
         this.settings.fixSelect &&
         (this.settings.fixSelect != "_FirstRecordDefault" ||
            this.settings.fixSelect == itemId)
      )
         return;

      if (this.__treeCollection) {
         // set cursor of tree collection
         this.setCursorTree(itemId);

         // pull current row id
         let currTreeId = this.__treeCollection.getCursor();
         if (currTreeId) {
            let currTreeItem = this.__treeCollection.getItem(currTreeId);
            if (currTreeItem) itemId = currTreeItem._itemId;
         }
      }

      let dc = this.__dataCollection;
      if (dc) {
         // clear cursor
         if (itemId == null) {
            dc.setCursor(null);
         }
         // If set rowId equal current cursor, it will not trigger .onAfterCursorChange event
         else if (dc.getCursor() == itemId) {
            this.emit("changeCursor", this.getCursor());
         }
         // set new cursor
         else if (dc.exists(itemId)) {
            dc.setCursor(itemId);
         }
      }
   }

   /**
    *
    * @param {string|number} itemId - Id of item or Id of row data
    */
   setCursorTree(itemId) {
      let tc = this.__treeCollection;
      if (tc && tc.getCursor() != itemId) {
         // If it is id of tree collection, then find row id of data
         let treeCursor = tc.find({ id: itemId }, true);
         if (treeCursor) {
            tc.setCursor(itemId);
         }
         // If it is not id of tree collection, then find/set root of data
         else {
            let treeItem = tc.find({ _itemId: itemId, $parent: 0 }, true);
            if (treeItem) tc.setCursor(treeItem.id);
            else tc.setCursor(null);
         }
      }
   }

   getCursor(treeCursor = false) {
      // Cursor of tree collection
      if (treeCursor && this.__treeCollection) {
         let currId = this.__treeCollection.getCursor();
         if (currId) {
            let currItem = this.__treeCollection.getItem(currId);

            // filter current id for serialize
            this.__treeCollection.filter(
               (item) => item._itemId == currItem._itemId
            );

            // pull item with child items
            let currItemAndChilds =
               this.__treeCollection.serialize()[0] || null;

            // refresh filter
            this.refreshLinkCursor();

            return currItemAndChilds;
         }
      }

      let dc = this.__dataCollection;
      if (dc == null) return null;

      let currId = dc.getCursor();
      let currItem = dc.getItem(currId);

      return currItem;
   }

   getFirstRecord() {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getFirstId();
      var currItem = dc.getItem(currId);

      return currItem;
   }

   getNextRecord(record) {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getNextId(record.id);
      var currItem = dc.getItem(currId);

      return currItem;
   }

   /**
    * @method refreshLinkCursor
    *    If the data collection is bound to another and it is the child connection
    *    it finds it's parents current set cursor and then filters its data
    *    based off of the cursor.
    */
   refreshLinkCursor() {
      // do not set the filter unless this dc is initialized "dataStatusFlag==2"
      // if (this.dataStatus != this.dataStatusFlag.initialized) return;

      // filter the data in the data collection
      // using its parents current cursor because all the data in this child
      // data collection has been loaded and the frontend can decide what is
      // seen or not seen
      let linkCursor;
      let dvLink = this.datacollectionLink;
      if (dvLink) {
         linkCursor = dvLink.getCursor();
      }

      let filterData = (rowData) => {
         // if link dc cursor is null, then show all data
         if (linkCursor == null) return true;
         else return this.isParentFilterValid(rowData);
      };

      if (this.__dataCollection) this.__dataCollection.filter(filterData);
      if (this.__treeCollection) this.__treeCollection.filter(filterData);
   }

   setStaticCursor() {
      if (this.settings.fixSelect) {
         // set cursor to the current user
         if (this.settings.fixSelect == "_CurrentUser") {
            var username = this.currentUserUsername();
            var userFields = this.datasource.fields((f) => f.key == "user");

            // find a row that contains the current user
            var row = this.__dataCollection.find((r) => {
               var found = false;

               userFields.forEach((f) => {
                  if (found || r[f.columnName] == null) return;

                  if (r[f.columnName].filter) {
                     // Array - isMultiple
                     found =
                        r[f.columnName].filter((data) => data.id == username)
                           .length > 0;
                  } else if (r[f.columnName] == username) {
                     found = true;
                  }
               });

               return found;
            }, true);

            // set a first row of current user to cursor
            if (row) {
               this.__dataCollection.setCursor(row.id);

               this.setCursorTree(row.id);
            }
         } else if (
            this.settings.fixSelect == "_FirstRecord" ||
            this.settings.fixSelect == "_FirstRecordDefault"
         ) {
            // // find a row that contains the current user
            // var row = this.__dataCollection.find((r) => {

            //  var found = false;
            //  if (!found) {
            //    found = true;
            //    return true; // just give us the first record
            //  }

            // }, true);

            // // set a first row of current user to cursor
            // if (row)
            //  this.__dataCollection.setCursor(row.id);

            let currRowId = this.__dataCollection.getCursor();
            if (
               !currRowId ||
               (currRowId && !this.__dataCollection.exists(currRowId))
            ) {
               // If current cursor is filtered by parent DC, then select new cursor

               // set a first row to cursor
               let rowId = this.__dataCollection.getFirstId();
               // if (rowId) {
               this.__dataCollection.setCursor(rowId || null);

               this.setCursorTree(rowId);
               // }
            }
         } else {
            this.__dataCollection.setCursor(this.settings.fixSelect);

            this.setCursorTree(this.settings.fixSelect);
         }
      }

      // Set the cursor to the first row
      if (this.isCursorFollow) {
         const rowId = this.__dataCollection.getFirstId();
         this.setCursor(rowId || null);
         this.setCursorTree(rowId || null);
      }
   }

   ///
   /// Data
   ///

   /**
    * @method filterCondition()
    * Provide a temporary filter condition to modify the data we are returning.
    * Used by User search criterias.
    * @param {json} cond
    *        A valid QueryCondition to filter the response.
    */
   filterCondition(cond = null) {
      this.__filterCond = cond;
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      this.initialized = true;

      if (!this.__dataCollection.___AD.onAfterCursorChange) {
         this.__dataCollection.___AD.onAfterCursorChange =
            this.__dataCollection.attachEvent("onAfterCursorChange", () => {
               // debugger;
               var currData = this.getCursor();

               this.emit("changeCursor", currData);
            });
      }

      // relate data functions
      let isRelated = (relateData, rowId, PK = "id") => {
         if (Array.isArray(relateData)) {
            return relateData.filter((v) => (v[PK] || v) == rowId).length > 0;
         } else {
            return relateData && (relateData[PK] || relateData) == rowId;
         }
      };

      // events
      this.on("ab.datacollection.create", (data) => {
         // If this DC is following cursor for other DC, then it should not add the new item to their list.
         if (this.isCursorFollow) return;

         let obj = this.datasource;
         if (!obj) return;

         if (!data || !data.data) return;

         let needAdd = false;
         let updatedVals = [];

         Promise.resolve()
            .then(() => {
               return new Promise((next, bad) => {
                  // Query
                  if (obj instanceof this.AB.Class.ABObjectQuery) {
                     let objList =
                        obj.objects((o) => o.id == data.objectId) || [];

                     needAdd = objList.length > 0;

                     if (!needAdd) return next();

                     let where = {
                        glue: "or",
                        rules: [],
                     };

                     objList.forEach((o) => {
                        let newDataId = data.data[`${o.PK()}`];
                        if (!newDataId) return;

                        where.rules.push({
                           key: `${o.alias || obj.objectAlias(o.id)}.${o.PK()}`,
                           rule: "equals",
                           value: newDataId,
                        });
                     });

                     obj.model()
                        .findAll({
                           where: where,
                        })
                        .then((newQueryData) => {
                           updatedVals = newQueryData.data || [];
                           updatedVals.forEach((v) => {
                              delete v.id;
                           });

                           next();
                        })
                        .catch(bad);
                  }
                  // Object
                  else {
                     needAdd = obj.id == data.objectId;
                     updatedVals = [data.data];
                     next();
                  }
               });
            })
            .then(() => {
               if (needAdd) {
                  // normalize data before add to data collection
                  var model = obj.model();

                  // UPDATE: this should already have happened in NetworkRestSocket
                  // when the initial data is received.
                  //model.normalizeData(updatedVals);

                  (updatedVals || []).forEach((updatedV) => {
                     // filter condition before add
                     if (!this.isValidData(updatedV)) return;

                     // check to see if item already exisits in data collection
                     // and check to see that we are not loading the data serverside from cursor
                     if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        !this.__reloadWheres
                     ) {
                        this.__dataCollection.add(updatedV, 0);
                        this.emit("create", updatedV);
                        // this.__dataCollection.setCursor(rowData.id);
                     } else if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        this.__reloadWheres
                     ) {
                        // debugger;
                        if (this.isParentFilterValid(updatedV)) {
                           // we track bound components and flexlayout components
                           var attachedComponents =
                              this.__bindComponentIds.concat(
                                 this.__flexComponentIds
                              );
                           attachedComponents.forEach((bcids) => {
                              // if the reload button already exisits move on
                              if ($$(bcids + "_reloadView")) {
                                 return false;
                              }

                              // find the position of the data view
                              var pos = 0;
                              var parent = $$(bcids).getParentView();
                              if ($$(bcids).getParentView().index) {
                                 pos = $$(bcids)
                                    .getParentView()
                                    .index($$(bcids));
                              } else if (
                                 $$(bcids).getParentView().getParentView().index
                              ) {
                                 // this is a data view and it is inside a
                                 // scroll view that is inside an accodion
                                 // so we need to go deeper to add the button
                                 parent = $$(bcids)
                                    .getParentView()
                                    .getParentView();
                                 pos = $$(bcids)
                                    .getParentView()
                                    .getParentView()
                                    .index($$(bcids).getParentView());
                              }

                              // store the datacollection so we can pass it to the button later
                              var DC = this;
                              // add a button that reloads the view when clicked
                              if (parent.addView) {
                                 var L = this.AB.Label();
                                 parent.addView(
                                    {
                                       id: bcids + "_reloadView",
                                       view: "button",
                                       value: L(
                                          "New data available. Click to reload."
                                       ),
                                       css: "webix_primary webix_warn",
                                       click: function (id, event) {
                                          DC.reloadData();
                                          $$(id).getParentView().removeView(id);
                                       },
                                    },
                                    pos
                                 );
                              }
                           });
                           // this.emit("create", updatedV);
                        }
                     }
                  });

                  if (
                     this.__treeCollection // && this.__treeCollection.exists(updatedVals.id)
                  ) {
                     this.parseTreeCollection({
                        data: updatedVals,
                     });
                  }
               }

               // ABObject only
               if (!(obj instanceof this.AB.Class.ABObjectQuery)) {
                  // if it is a linked object
                  let connectedFields = this.datasource.connectFields(
                     (f) =>
                        f.datasourceLink && f.datasourceLink.id == data.objectId
                  );

                  // It should always be only one item for ABObject
                  updatedVals = updatedVals[0];

                  // update relation data
                  if (
                     updatedVals &&
                     connectedFields &&
                     connectedFields.length > 0
                  ) {
                     // various PK name
                     let PK = connectedFields[0].object.PK();
                     if (!updatedVals.id && PK != "id")
                        updatedVals.id = updatedVals[PK];

                     this.__dataCollection.find({}).forEach((d) => {
                        let updateItemData = {};

                        connectedFields.forEach((f) => {
                           var updateRelateVal = {};
                           if (f && f.fieldLink) {
                              updateRelateVal =
                                 updatedVals[f.fieldLink.relationName()] || {};
                           }

                           let rowRelateVal = d[f.relationName()] || {};

                           let valIsRelated = isRelated(
                              updateRelateVal,
                              d.id,
                              PK
                           );

                           // Relate data
                           if (
                              Array.isArray(rowRelateVal) &&
                              rowRelateVal.filter(
                                 (v) =>
                                    v == updatedVals.id ||
                                    v.id == updatedVals.id ||
                                    v[PK] == updatedVals.id
                              ).length < 1 &&
                              valIsRelated
                           ) {
                              rowRelateVal.push(updatedVals);

                              updateItemData[f.relationName()] = rowRelateVal;
                              updateItemData[f.columnName] = updateItemData[
                                 f.relationName()
                              ].map((v) => v.id || v[PK] || v);
                           } else if (
                              !Array.isArray(rowRelateVal) &&
                              (rowRelateVal != updatedVals.id ||
                                 rowRelateVal.id != updatedVals.id ||
                                 rowRelateVal[PK] != updatedVals.id) &&
                              valIsRelated
                           ) {
                              updateItemData[f.relationName()] = updatedVals;
                              updateItemData[f.columnName] =
                                 updatedVals.id || updatedVals;
                           }
                        });

                        // If this item needs to update
                        if (Object.keys(updateItemData).length > 0) {
                           // normalize data before add to data collection
                           var model = obj.model();

                           // UPDATE: this should already have happened in NetworkRestSocket
                           // when the initial data is received.
                           // model.normalizeData(updateItemData);

                           this.__dataCollection.updateItem(
                              d.id,
                              updateItemData
                           );

                           if (this.__treeCollection)
                              this.__treeCollection.updateItem(
                                 d.id,
                                 updateItemData
                              );

                           this.emit(
                              "update",
                              this.__dataCollection.getItem(d.id)
                           );
                        }
                     });
                  }
               }

               // filter link data collection's cursor
               this.refreshLinkCursor();
               this.setStaticCursor();
            });
      });

      this.on("ab.datacollection.update", (data) => {
         // {json} data
         // incoming socket payload:
         // data.objectId {string} uuid of the ABObject that was updated
         // data.data {json} the new updated value of that row entry.

         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         // updated values
         let values = data.data;
         if (!values) return;

         // DC who is following cursor should update only current cursor.
         if (
            this.isCursorFollow &&
            this.getCursor()?.id != (values[obj.PK()] ?? values.id)
         ) {
            return;
         }

         let needUpdate = false;
         let isExists = false;
         let updatedIds = [];
         // {array}
         // an array of the row indexs in our DataCollection that have values
         // that need to be updated.

         let updatedTreeIds = [];
         let updatedVals = {};

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needUpdate = objList.length > 0;
            if (needUpdate) {
               (objList || []).forEach((o) => {
                  updatedIds = updatedIds.concat(
                     this.__dataCollection
                        .find((item) => {
                           return (
                              item[
                                 `${this.datasource.objectAlias(
                                    o.id
                                 )}.${o.PK()}`
                              ] == (values[o.PK()] || values.id)
                           );
                        })
                        .map((o) => o.id) || []
                  );

                  // grouped queries
                  if (this.__treeCollection) {
                     updatedTreeIds = updatedTreeIds.concat(
                        this.__treeCollection
                           .find((item) => {
                              return (
                                 item[
                                    `${this.datasource.objectAlias(
                                       o.id
                                    )}.${o.PK()}`
                                 ] == (values[o.PK()] || values.id)
                              );
                           })
                           .map((o) => o.id) || []
                     );
                  }
               });

               isExists = updatedIds.length > 0;

               updatedVals = this._queryUpdateData(objList, values);
            }
         }
         // Object
         else {
            needUpdate = obj.id == data.objectId;
            if (needUpdate) {
               // various PK name
               if (!values.id && obj.PK() != "id") values.id = values[obj.PK()];

               updatedIds.push(values.id);

               isExists = this.__dataCollection.exists(values.id);
               updatedVals = values;
            }
         }

         // if it is the source object
         if (needUpdate) {
            if (isExists) {
               if (this.isValidData(updatedVals)) {
                  // NOTE: this is now done in NetworkRestSocket before
                  // we start the update events.
                  // normalize data before update data collection
                  // var model = obj.model();
                  // model.normalizeData(updatedVals);

                  if (this.__dataCollection) {
                     updatedIds = this.AB.uniq(updatedIds);
                     updatedIds.forEach((itemId) => {
                        this.__dataCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  if (this.__treeCollection) {
                     // update data in tree
                     updatedTreeIds = this.AB.uniq(updatedTreeIds);
                     updatedTreeIds.forEach((itemId) => {
                        this.__treeCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  this.emit("update", updatedVals);

                  // If the update item is current cursor, then should tell components to update.
                  let currData = this.getCursor();
                  if (currData && currData.id == updatedVals.id) {
                     this.emit("changeCursor", currData);
                  }
               } else {
                  // Johnny: Here we are simply removing the DataCollection Entries that are
                  // no longer valid.
                  // Just cycle through the collected updatedIds and remove them.
                  updatedIds.forEach((id) => {
                     // If the item is current cursor, then the current cursor should be cleared.
                     let currData = this.getCursor();
                     if (currData && currData.id == id)
                        this.emit("changeCursor", null);

                     this.__dataCollection.remove(id);

                     // TODO: update tree list
                     // if (this.__treeCollection) {
                     //  this.__treeCollection.remove(id);
                     // }

                     this.emit("delete", id);
                  });
               }
            }
            // filter before add new record
            else if (this.isValidData(updatedVals)) {
               // this means the updated record was not loaded yet so we are adding it to the top of the grid
               // the placement will probably change on the next load of the data
               this.__dataCollection.add(updatedVals, 0);

               if (this.__treeCollection)
                  this.parseTreeCollection({
                     data: [updatedVals],
                  });

               this.emit("create", updatedVals);
            }
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();
            if (!values.id && PK != "id") values.id = values[PK];

            if (this.__dataCollection.count() > 0) {
               this.__dataCollection.find({}).forEach((d) => {
                  let updateItemData = {
                     id: d.id,
                  };

                  connectedFields.forEach((f) => {
                     if (!f) return;

                     let updateRelateVal = {};
                     let rowRelateVal = d[f.relationName()] || {};

                     if (f.fieldLink)
                        updateRelateVal =
                           values[f.fieldLink.relationName()] || {};

                     let valIsRelated = isRelated(updateRelateVal, d.id, PK);

                     // Unrelate data
                     if (
                        Array.isArray(rowRelateVal) &&
                        rowRelateVal.filter(
                           (v) =>
                              v == values.id ||
                              v.id == values.id ||
                              v[PK] == values.id
                        ).length > 0 &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = rowRelateVal.filter(
                           (v) => (v.id || v[PK] || v) != values.id
                        );
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal == values.id ||
                           rowRelateVal.id == values.id ||
                           rowRelateVal[PK] == values.id) &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = null;
                        updateItemData[f.columnName] = null;
                     }

                     // Relate data or Update
                     if (Array.isArray(rowRelateVal) && valIsRelated) {
                        // update relate data
                        if (
                           rowRelateVal.filter(
                              (v) =>
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                           ).length > 0
                        ) {
                           rowRelateVal.forEach((v, index) => {
                              if (
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                              )
                                 rowRelateVal[index] = values;
                           });
                        }
                        // add new relate
                        else {
                           rowRelateVal.push(values);
                        }

                        updateItemData[f.relationName()] = rowRelateVal;
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal != values.id ||
                           rowRelateVal.id != values.id ||
                           rowRelateVal[PK] != values.id) &&
                        valIsRelated
                     ) {
                        updateItemData[f.relationName()] = values;
                        updateItemData[f.columnName] = values.id || values;
                     }
                  });

                  // If this item needs to update
                  if (Object.keys(updateItemData).length > 0) {
                     // normalize data before add to data collection
                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.

                     // NOTE: We could not normalize relational data because they are not full data
                     // Merge update data to exists data instead

                     if (this.__treeCollection?.exists(d.id)) {
                        const treeItem = Object.assign(
                           this.__treeCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__treeCollection.updateItem(d.id, treeItem);
                     }

                     if (this.__dataCollection?.exists(d.id)) {
                        const dcItem = Object.assign(
                           this.__dataCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__dataCollection.updateItem(d.id, dcItem);
                        this.emit(
                           "update",
                           this.__dataCollection.getItem(d.id)
                        );
                     }
                  }
               });
            }
         }

         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      // We are subscribing to notifications from the server that an item may be stale and needs updating
      // We will improve this later and verify that it needs updating before attempting the update on the client side
      this.on("ab.datacollection.stale", (data) => {
         // debugger;
         // if we don't have a datasource or model, there is nothing we can do here:
         // Verify the datasource has the object we are listening for if not just stop here
         if (
            !this.datasource ||
            !this.model ||
            this.datasource.id != data.objectId
         ) {
            return;
         }

         // updated values
         var values = data.data;

         if (!values) return;

         // use the Object's defined Primary Key:
         var PK = this.model.object.PK();
         if (!values[PK]) {
            PK = "id";
         }

         // DC who is following cursor should update only current cursor.
         if (
            this.isCursorFollow &&
            this.getCursor()?.[PK] != (values[PK] ?? values.id)
         ) {
            return;
         }

         if (values) {
            if (this.__dataCollection.exists(values[PK])) {
               var cond = { where: {} };
               cond.where[PK] = values[PK];
               // this data collection has the record so we need to query the server to find out what it's latest data is so we can update all instances
               this.model.staleRefresh(cond).then((res) => {
                  // check to make sure there is data to work with
                  if (Array.isArray(res.data) && res.data.length) {
                     // debugger;
                     let obj = this.datasource;
                     if (!obj) return;
                     // normalize data before add to data collection

                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.
                     //var model = obj.model();
                     // model.normalizeData(res.data[0]);

                     // tell the webix data collection to update using their API with the row id (values.id) and content (res.data[0])
                     if (this.__dataCollection.exists(values[PK])) {
                        this.__dataCollection.updateItem(
                           values[PK],
                           res.data[0]
                        );
                     }

                     // If the update item is current cursor, then should tell components to update.
                     var currData = this.getCursor();
                     if (currData && currData[PK] == values[PK]) {
                        this.emit("changeCursor", currData);
                     }
                  } else {
                     // If there is no data in the object then it was deleted...lets clean things up
                     // If the deleted item is current cursor, then the current cursor should be cleared.
                     var currId = this.getCursor();
                     if (currId == values[PK]) this.emit("changeCursor", null);

                     this.__dataCollection.remove(values[PK]);
                     this.emit("delete", values[PK]);
                  }
               });
            }
         }

         // filter link data collection's cursor
         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      this.on("ab.datacollection.delete", (data) => {
         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         let deleteId = data.data;
         let needDelete = false;
         let deletedIds = [];
         let deletedTreeIds = [];

         if (this.isCursorFollow && this.getCursor()?.id != deleteId) {
            return;
         }

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needDelete = objList.length > 0;
            if (needDelete) {
               (objList || []).forEach((o) => {
                  deletedIds =
                     this.__dataCollection
                        .find((item) => {
                           return item[`${o.alias}.${o.PK()}`] == deleteId;
                        })
                        .map((o) => o.id) || [];

                  // grouped queries
                  if (this.__treeCollection) {
                     deletedTreeIds =
                        this.__treeCollection
                           .find((item) => {
                              return item[`${o.alias}.${o.PK()}`] == deleteId;
                           })
                           .map((o) => o.id) || [];
                  }
               });
            }
         }
         // Object
         else {
            needDelete = obj.id == data.objectId;
            if (needDelete) {
               deletedIds.push(deleteId);
            }
         }

         // if it is the source object
         if (needDelete) {
            // If the deleted item is current cursor, then the current cursor should be cleared.
            var currData = this.getCursor();

            deletedIds.forEach((delId) => {
               if (currData && currData[obj.PK()] == delId)
                  this.emit("changeCursor", null);

               if (this.__dataCollection.exists(delId))
                  this.__dataCollection.remove(delId);
            });

            if (this.__treeCollection) {
               deletedTreeIds.forEach((delId) => {
                  if (this.__treeCollection.exists(delId))
                     this.__treeCollection.remove(delId);
               });
            }

            if (deletedIds[0]) this.emit("delete", deletedIds[0]);
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();

            this.__dataCollection.find({}).forEach((d) => {
               let updateRelateVals = {};

               connectedFields.forEach((f) => {
                  let relateVal = d[f.relationName()];
                  if (relateVal == null) return;

                  if (
                     Array.isArray(relateVal)
                     // JOHNNY: for speed improvements, don't make this check:
                     // just do it and that will reduce 1x through the array.
                     // &&
                     // relateVal.filter(
                     //    (v) =>
                     //       v == deleteId ||
                     //       v.id == deleteId ||
                     //       v[PK] == deleteId
                     // ).length > 0
                  ) {
                     updateRelateVals[f.relationName()] = relateVal.filter(
                        (v) => (v.id || v[PK] || v) != deleteId
                     );
                     updateRelateVals[f.columnName] = updateRelateVals[
                        f.relationName()
                     ].map((v) => v.id || v[PK] || v);
                  } else if (
                     relateVal == deleteId ||
                     relateVal.id == deleteId ||
                     relateVal[PK] == deleteId
                  ) {
                     updateRelateVals[f.relationName()] = null;
                     updateRelateVals[f.columnName] = null;
                  }
               });

               // If this item needs to update
               if (Object.keys(updateRelateVals).length > 0) {
                  // normalize data before add to data collection

                  // var model = obj.model();
                  // model.normalizeData(updateRelateVals);

                  this.__dataCollection.updateItem(d.id, updateRelateVals);

                  if (this.__treeCollection)
                     this.__treeCollection.updateItem(d.id, updateRelateVals);

                  this.emit("update", this.__dataCollection.getItem(d.id));
               }
            });
         }
      });

      // add listeners when cursor of link data collection is changed
      let linkDv = this.datacollectionLink;
      if (linkDv && this.settings.loadAll) {
         this.eventAdd({
            emitter: linkDv,
            eventName: "changeCursor",
            listener: () => {
               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });
      }

      // add listeners when cursor of the followed data collection is changed
      const followDC = this.datacollectionFollow;
      if (followDC) {
         this.eventAdd({
            emitter: followDC,
            eventName: "changeCursor",
            listener: () => {
               this.clearAll();
               this.loadData();
            },
         });
      }
   }

   /*
    * waitForDataCollectionToInitialize()
    * there are certain situations where this datacollection shouldn't
    * load until another one has loaded.  In those cases, the fn()
    * will wait for the required datacollection to emit "initializedData"
    * before continuing on.
    * @param {ABViewDataCollection} DC
    *      the DC this datacollection depends on.
    * @returns {Promise}
    */
   waitForDataCollectionToInitialize(DC, msg) {
      return new Promise((resolve, reject) => {
         switch (DC.dataStatus) {
            // if that DC hasn't started initializing yet, start it!
            case DC.dataStatusFlag.notInitial:
               DC.loadData().catch(reject);
            // no break;

            // once in the process of initializing
            /* eslint-disable no-fallthrough*/
            case DC.dataStatusFlag.initializing:
               /* eslint-enable no-fallthrough*/
               // listen for "initializedData" event from the DC
               // then we can continue.
               this.eventAdd({
                  emitter: DC,
                  eventName: "initializedData",
                  listener: () => {
                     // go next
                     resolve();
                  },
               });
               break;

            // if it is already initialized, we can continue:
            case DC.dataStatusFlag.initialized:
               resolve();
               break;

            // just in case, if the status is not known, just continue
            default:
               resolve();
               break;
         }
      });
   }

   loadData(start, limit) {
      // mark data status is initializing
      if (this._dataStatus == this.dataStatusFlag.notInitial) {
         this._dataStatus = this.dataStatusFlag.initializing;
         this.emit("initializingData", {});
      }

      var obj = this.datasource;
      if (obj == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      var model = obj.model();
      if (model == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      // pull the defined sort values
      var sorts = this.settings.objectWorkspace.sortFields || [];

      // pull filter conditions
      let wheres = this.AB.cloneDeep(
         this.settings.objectWorkspace.filterConditions ?? null
      );
      // if we pass new wheres with a reload use them instead
      if (this.__reloadWheres) {
         wheres = this.__reloadWheres;
      }

      const __additionalWheres = {
         glue: "and",
         rules: [],
      };

      if (this.__filterCond) {
         __additionalWheres.rules.push(this.__filterCond);
      }

      // Filter by a selected cursor of a link DC
      const dataCollectionLink = this.datacollectionLink;
      const fieldLink = this.fieldLink;
      if (!this.settings.loadAll && dataCollectionLink && fieldLink) {
         const linkCursorId = dataCollectionLink?.getCursor()?.id;
         if (linkCursorId) {
            __additionalWheres.rules.push({
               alias: fieldLink.alias, // ABObjectQuery
               key: fieldLink.id,
               rule: fieldLink.alias ? "contains" : "equals", // NOTE: If object is query, then use "contains" because ABOBjectQuery return JSON
               value: fieldLink.getRelationValue(
                  dataCollectionLink.__dataCollection.getItem(linkCursorId)
               ),
            });
         }
      }
      // pull data rows following the follow data collection
      else if (this.datacollectionFollow) {
         const followCursor = this.datacollectionFollow.getCursor();
         // store the PK as a variable
         let PK = this.datasource.PK();
         // if the datacollection we are following is a query
         // add "BASE_OBJECT." to the PK so we can select the
         // right value to report the cursor change to
         if (this.datacollectionFollow.settings.isQuery) {
            PK = "BASE_OBJECT." + PK;
         }
         if (followCursor) {
            start = 0;
            limit = null;
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: followCursor[PK],
                  },
               ],
            };
         }
         // Set no return rows
         else {
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: "NO RESULT ROW",
                  },
               ],
            };
         }
      }

      // Combine setting & program filters
      if (__additionalWheres.rules.length) {
         __additionalWheres.rules.unshift(wheres);
         wheres = __additionalWheres;
      }

      // remove any null in the .rules
      if (wheres?.rules?.filter) wheres.rules = wheres.rules.filter((r) => r);

      // set query condition
      var cond = {
         where: wheres || {},
         // limit: limit || 20,
         skip: start || 0,
         sort: sorts,
         populate:
            this.settings.populate ??
            (this.settings.preventPopulate ? false : true),
      };

      //// NOTE: we no longer set a default limit on loadData() but
      //// require the platform.loadData() to pass in a default limit.
      if (limit != null) {
         cond.limit = limit;
      }

      // if settings specify loadAll, then remove the limit
      if (this.settings.loadAll && !this.isCursorFollow) {
         delete cond.limit;
      }

      return (
         Promise.resolve()
            //
            // Step 1: make sure any DataCollections we are linked to are
            // initialized first.  Then proceed with our initialization.
            //
            .then(() => {
               // If we are linked to another datacollection then wait for it
               let linkDc = this.datacollectionLink;
               if (!linkDc) return Promise.resolve(); // TODO: refactor in v2

               return this.waitForDataCollectionToInitialize(linkDc);
            })
            //
            // Step 2: if we have any filter rules that depend on other DataCollections,
            // then wait for them to be initialized first.
            // eg: "(not_)in_data_collection" rule filters
            .then(() => {
               return new Promise((resolve, reject) => {
                  if (
                     wheres == null ||
                     wheres.rules == null ||
                     !wheres.rules.length
                  )
                     return resolve();

                  var dcFilters = [];

                  wheres.rules.forEach((rule) => {
                     // if this collection is filtered by data collections we need to load them in case we need to validate from them later
                     if (
                        rule.rule == "in_data_collection" ||
                        rule.rule == "not_in_data_collection"
                     ) {
                        var dv = this.AB.datacollectionByID(rule.value);
                        if (dv) {
                           dcFilters.push(
                              this.waitForDataCollectionToInitialize(dv)
                           );
                        }
                     }
                  });

                  Promise.all(dcFilters)
                     .then(() => {
                        resolve();
                     })
                     .catch(reject);
               });
            })

            // pull data to data collection
            .then(() => {
               return new Promise((resolve, reject) => {
                  // we will keep track of the resolve, reject for this
                  // operation.
                  // the actual resolve() should happen in the
                  // .processIncomingData() after the  data is processed.
                  this._pendingLoadDataResolve = {
                     resolve: resolve,
                     reject: reject,
                  };

                  this.platformFind(model, cond).catch((err) => {
                     reject(err);
                  });
               });
            })
      );
   }

   platformFind(model, cond) {
      //// Core Migration Note:
      //// the ABViewDataCollectionCore now manages data in a different way:
      //// local data  vs  Remote Data
      //// this will need to be updated to reflect that management:
      //// (and also explains why we refactored things into .processIncomingData())
      return model.findAll(cond).then((data) => {
         console.error("TODO: parse returned data and figure out paging");
         console.error(data);
         // parse out the total and figure out if we need to track loading more:
         return this.processIncomingData(data);
      });
   }

   /**
    * @method queuedParse()
    * This is an attempt at loading very large datasets into a Webix DC without locking up
    * the display.
    * @param {array} data
    *        The data to load into the __dataCollection
    * @param {callback} cb
    *        A callback to call when the data has been fully loaded.
    */
   async queuedParse(incomingData, cb) {
      const data = incomingData?.data || incomingData;
      if (!data?.length) {
         cb?.();
         return Promise.resolve();
      }

      const total_count = incomingData.total_count;

      let nextData;
      if (data.length > 250) {
         let pos = this.__dataCollection.count();
         let remain = data.splice(250);
         nextData = {
            data: remain,
            pos: pos + data.length,
            total_count,
         };
      }

      const parsedData = {
         data,
         pos: incomingData.pos,
         total_count,
      };
      this.__dataCollection.parse(parsedData);

      return new Promise((resolve) => {
         setTimeout(async () => {
            await this.queuedParse(nextData);
            cb?.();
            resolve();
         }, 15);
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      return Promise.resolve().then(() => {
         // store total count
         this.__totalCount = data.total_count;

         // Need to .parse it the first time
         if (!this.__dataCollection?.find({}).length) {
            this.__dataCollection?.clearAll();
            // this.__dataCollection?.parse(data);
         }

         if (this.__throttleIncoming) clearTimeout(this.__throttleIncoming);
         this.__throttleIncoming = setTimeout(async () => {
            // using queuedParse() to responsively handle large datasets.
            await this.queuedParse(data);

            // In order to get the total_count updated I had to use .load()
            this.__dataCollection.load(async () => {
               if (this.settings.loadAll) {
                  setTimeout(() => {
                     this.refreshLinkCursor();
                  }, 250);
               }

               return {
                  // NOTE: return a empty array to prevent render items in DataTable twice. (Items are rendered in .queuedParse function)
                  data: [],
                  pos: data.pos,
                  total_count: data.total_count,
               };
            });

            // this does nothing???
            this.parseTreeCollection(data);

            // if we are linked, then refresh our cursor
            var linkDv = this.datacollectionLink;
            if (linkDv) {
               // filter data by match link data collection
               this.refreshLinkCursor();
               this.setStaticCursor();
            } else {
               // set static cursor
               this.setStaticCursor();
            }

            // now we close out our .loadData() promise.resolve() :
            if (this._pendingLoadDataResolve) {
               this._pendingLoadDataResolve.resolve();

               // after we call .resolve() stop tracking this:
               this._pendingLoadDataResolve = null;
            }

            // If dc set load all, then it will not trigger .loadData in dc at
            // .onAfterLoad event
            if (this.settings.loadAll) {
               this.emit("loadData", {});
            }

            // mark initialized data
            if (this._dataStatus != this.dataStatusFlag.initialized) {
               this._dataStatus = this.dataStatusFlag.initialized;
               this.emit("initializedData", {});
            }
         }, 100);
      });
   }

   /**
    * @method reloadData()
    * Trigger the DataCollection to reload its data from the server.
    * @param {int} start
    *        Start position of where we want the data to load.
    * @param {int} limit
    *        How many entries to load at a time.
    * @return {Promise}
    */
   reloadData(start, limit) {
      // var waitForDataCollectionToInitialize = (DC) => {
      //    return new Promise((resolve, reject) => {
      //       switch (DC.dataStatus) {
      //          // if that DC hasn't started initializing yet, start it!
      //          case DC.dataStatusFlag.notInitial:
      //             DC.loadData().catch(reject);
      //          // no break;

      //          // once in the process of initializing
      //          /* eslint-disable no-fallthrough*/
      //          case DC.dataStatusFlag.initializing:
      //             /* eslint-enable no-fallthrough*/
      //             // listen for "initializedData" event from the DC
      //             // then we can continue.
      //             this.eventAdd({
      //                emitter: DC,
      //                eventName: "initializedData",
      //                listener: () => {
      //                   // go next
      //                   resolve();
      //                },
      //             });
      //             break;

      //          // if it is already initialized, we can continue:
      //          case DC.dataStatusFlag.initialized:
      //             resolve();
      //             break;

      //          // just in case, if the status is not known, just continue
      //          default:
      //             resolve();
      //             break;
      //       }
      //    });
      // };

      return Promise.resolve().then(() => {
         // check if we are currently waiting for more data requests on this datacollection before continuing
         if (this.reloadTimer) {
            // if we are already waiting delete the current timer
            clearTimeout(this.reloadTimer);
            delete this.reloadTimer;
         }

         // return a promise
         if (!this.reloadPromise) {
            this.reloadPromise = new Promise((resolve, reject) => {
               this.reloadPromise__resolve = resolve;
               this.reloadPromise__reject = reject;
            });
         }

         // then create a new timeout to delete current timeout, clear data
         // and load new
         this.reloadTimer = setTimeout(() => {
            // clear the data from the dataCollection,
            this.clearAll();
            // then loads new data from the server
            return this.loadData(start, limit)
               .then(() => {
                  if (this.reloadPromise) {
                     this.reloadPromise__resolve();
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }

                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               })
               .catch((err) => {
                  if (this.reloadPromise) {
                     this.reloadPromise__reject(err);
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }
                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               });
         }, 50);
         // setting to 50ms because right now we do not see many
         // concurrent calls,  we need to increase this if we begin to

         return this.reloadPromise;
      });
   }

   /**
    * reloadWheres()
    * stores the child data collections filters for subsequent loads.
    * It is called from bindParentDc() when child data collections that are not
    * marked to load all data are initializing. To do this we use webix
    * server side binding by setting the param of "dataFeed".
    * @param {obj} wheres  the new filters for the data collection
    *        This is a combination of any exisiting filters the data collection
    *        alreay had as well as the filter for the current cursor set by the
    *        master data collection. We store this in __reloadWheres for when
    *        the data needs to be updated.
    *        The format of the wheres is our Query Builder Format
    *        ex: {
    *              "glue": "and",
    *              "rules": [{
    *                "key": "33ba8957-6b9c-4ddb-9533-c46b13878ae1",
    *                "rule": "contains",
    *                "value": "1594176994894"
    *              }]
    *            }
    */
   reloadWheres(wheres) {
      this.__reloadWheres = wheres;
   }

   getData(filter) {
      var dc = this.__dataCollection;
      if (dc) {
         return dc.find((row) => {
            let isValid = true;

            // data collection filter
            // isValid = this.isValidData(row);

            // NOTE: data are filtered from the server side (webix.dataFeed)
            // parent dc filter
            let linkDv = this.datacollectionLink;
            if (linkDv && this.settings.loadAll && isValid) {
               isValid = this.isParentFilterValid(row);
            }

            // addition filter
            if (isValid && filter) {
               isValid = filter(row);
            }

            return isValid;
         });
      } else {
         return [];
      }
   }

   isParentFilterValid(rowData) {
      // data is empty
      if (rowData == null) return false;

      var linkDv = this.datacollectionLink;
      if (linkDv == null) return true;

      const linkObj = linkDv.datasource;
      if (linkObj == null) return true;

      var fieldLink = this.fieldLink;
      if (fieldLink == null) return true;

      // if the parent's cursor is not set we have not filted this collection
      // yet so the data that comes back should be valid
      var linkCursor = linkDv.getCursor();
      if (linkCursor == null) {
         return true;
      }

      var linkVal = rowData[fieldLink.relationName()];
      if (linkVal == null) {
         // try to get relation value(id) again
         if (rowData[fieldLink.columnName]) {
            linkVal = rowData[fieldLink.columnName];
         } else {
            return false;
         }
      }

      let PK = fieldLink.object.PK();

      // array - 1:M , M:N
      if (linkVal.filter) {
         return (
            linkVal.filter(
               (val) =>
                  (val[PK] || val.id || val) ==
                  (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
            ).length > 0
         );
      } else {
         return (
            (linkVal[PK] || linkVal.id || linkVal) ==
            (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
         );
      }
   }

   clearAll() {
      if (this.__dataCollection) this.__dataCollection.clearAll();

      if (this.__treeCollection) this.__treeCollection.clearAll();

      this._dataStatus = this.dataStatusFlag.notInitial;
   }

   get totalCount() {
      return this.__totalCount || 0;
   }

   ///
   /// Components
   ///

   /**
    * @method bind
    * @param {Object} component - a webix element instance
    */
   bind(/* component */) {
      console.error("Platform.ABDataCollection.bind() Not implemented");
   }

   unbind(/* component */) {
      console.error("Platform.ABDataCollection.unbind() Not implemented");
   }

   removeComponent(comId) {
      // get index
      let index = this.__bindComponentIds.indexOf(comId);

      // delete
      this.__bindComponentIds.splice(index, 1);
   }

   /**
    * @method refreshFilterConditions()
    * This is called in two primary cases:
    *    - on initialization of a DC to setup our filters.
    *    - in the operation of the ABDesigner when using a DC to display data
    *      in the Work_object_grid and the datacollection_work(?)
    * In the case of the ABDesigner, new temporary where conditions are provided
    * from the possible filters we can set, and those need to effect the data
    * we display.
    * @param {ABRowFilter.where} wheres
    *        The filter condition from the ABRowFilter values we are storing.
    */
   refreshFilterConditions(wheres = null) {
      // There are 3 Filters that help us know if our data is Valid:
      // 1) A filter for any ABObjectQuery we are managing.
      // 2) A filter for our own filter condition
      // 3) A filter that represents what our scopes allows

      // Set filter of ABObject
      if (this.__filterDatasource == null)
         this.__filterDatasource = this.AB.filterComplexNew(
            `${this.id}_filterDatasource`
         );

      if (this.datasource) {
         // this.__filterDatasource.applicationLoad(this.datasource.application);
         this.__filterDatasource.fieldsLoad(this.datasource.fields());

         let filterConditions;

         // Query
         if (this.datasource instanceof this.AB.Class.ABObjectQuery) {
            filterConditions = this.datasource.where;
         }
         // Apr 29, 2021 Removed this because we do not want Object filters to
         // effect validation of DataCollections
         // Object

         // else if (this.datasource instanceof ABObject) {
         //    let currentView = this.datasource.currentView();
         //    if (currentView && currentView.filterConditions)
         //       filterConditions = currentView.filterConditions;
         // }

         if (filterConditions)
            this.__filterDatasource.setValue(filterConditions);
         else this.__filterDatasource.setValue({});
      } else {
         this.__filterDatasource.fieldsLoad([]);
         this.__filterDatasource.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of data view
      // Apr 29, 2021 Added this code back to validate with DataCollection Filters
      if (this.__filterDatacollection == null)
         this.__filterDatacollection = this.AB.filterComplexNew(
            `${this.id}_filterDatacollection`
         );

      // this.__filterDatacollection.applicationLoad(
      //    this.datasource ? this.datasource.application : null
      // );
      this.__filterDatacollection.fieldsLoad(
         this.datasource ? this.datasource.fields() : []
      );

      if (wheres) this.settings.objectWorkspace.filterConditions = wheres;

      if (
         this.settings &&
         this.settings.objectWorkspace &&
         this.settings.objectWorkspace.filterConditions
      ) {
         this.__filterDatacollection.setValue(
            this.settings.objectWorkspace.filterConditions
         );
      } else {
         this.__filterDatacollection.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of user's scope
      if (this.__filterScope == null)
         this.__filterScope = this.AB.filterComplexNew(
            `${this.id}_filterScope`
         );

      if (this.datasource) {
         let scopeList = (this.userScopes || []).filter(
            (s) =>
               !s.allowAll &&
               (s.objectIds || []).indexOf(this.datasource.id) > -1
         );
         if (scopeList && scopeList.length > 0) {
            // this.__filterScope.applicationLoad(this.datasource.application);
            this.__filterScope.fieldsLoad(this.datasource.fields() || []);

            // concat all rules of scopes
            let scopeRules = [];
            scopeList
               .filter(
                  (s) => s.filter && s.filter.rules && s.filter.rules.length
               )
               .forEach((s) => {
                  let sRules = (s.filter.rules || []).filter(
                     (r) =>
                        this.datasource.fields((f) => f.id == r.key).length > 0
                  );

                  scopeRules = scopeRules.concat(sRules);
               });

            let scopeWhere = {
               glue: "or",
               rules: scopeRules,
            };
            this.__filterScope.setValue(scopeWhere);
         }
      }
   }

   get isGroup() {
      return this.__isGroup || false;
   }

   ///
   /// Sync type
   ///

   get syncTypeFlag() {
      return {
         server: 1,
         client: 2,
      };
   }

   get syncType() {
      return this.settings.syncType || DefaultValues.syncType;
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(/*data*/) {
      var error = new Error(
         "the platform.ABDataCollection._dataCollectionNew() is expected to return a proper DataCollection!"
      );
      console.error(error);
      return null;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      console.error(
         "the platform.ABDataCollection._treeCollectionNew() is expected to return a proper TreeCollection!"
      );
      return null;
   }

   parseTreeCollection(data = {}) {
      // TODO all this does is log "is missing?"
      if (data === {}) {
         console.log(
            "Platform.ABDataCollection.parseTreeCollection() missing!"
         );
      }
   }
   // parseTreeCollection(data = {}) {

   //  if (!(this.__datasource instanceof ABObjectQuery) ||
   //    !this.__datasource.isGroup ||
   //    !this.__treeCollection)
   //    return;

   //  let addRowToTree = (join = {}, parentAlias = null) => {

   //    let alias = join.alias;

   //    (data.data || []).forEach(row => {

   //      let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
   //      if (!dataId) return;

   //      // find parent nodes
   //      let parentItemIds = [];
   //      let parentId = row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
   //      if (parentId) {
   //        parentItemIds = this.__treeCollection
   //          .find(item => item._alias == parentAlias && item._dataId == parentId)
   //          .map(item => item.id);
   //      }

   //      // check exists
   //      let exists = this.__treeCollection.find(item => {
   //        return item._alias == alias &&
   //          item._dataId == dataId &&
   //          (parentItemIds.length == 0 || parentItemIds.indexOf(item.$parent) > -1);
   //      }, true);
   //      if (exists) return;

   //      let treeNode = {};
   //      treeNode._alias = alias;
   //      treeNode._dataId = dataId;
   //      treeNode._itemId = row.id; // Keep row id for set cursor to data collection

   //      Object.keys(row).forEach(propName => {

   //        // Pull value from alias
   //        if (propName.indexOf(`${alias}.`) == 0) {
   //          treeNode[propName] = row[propName];
   //        }

   //      });

   //      if (row.translations)
   //        treeNode.translations = row.translations;

   //      // child nodes
   //      if (parentItemIds.length > 0)
   //        parentItemIds.forEach(parentItemId => {
   //          this.__treeCollection.add(treeNode, null, parentItemId);
   //        });
   //      // root node
   //      else
   //        this.__treeCollection.add(treeNode, null);

   //    });

   //    // Sub-joins
   //    (join.links || []).forEach(link => {
   //      addRowToTree(link, alias);
   //    });

   //  };

   //  // Show loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.showProgress)
   //      boundComp.showProgress({ type: "icon" });

   //  });

   //  addRowToTree(this.__datasource.joins());

   //  // Hide loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.hideProgress)
   //      boundComp.hideProgress();

   //  })
   // }

   /**
    * @method _queryUpdateData
    *
    * @param {Array} objList - List of ABObject
    * @param {Object} values
    */
   _queryUpdateData(objList, values) {
      let updatedVals = {};

      // Add alias to properties of update data
      Object.keys(values).forEach((key) => {
         objList.forEach((oItem) => {
            let alias = this.datasource.objectAlias(oItem.id);

            updatedVals[`${alias}.${key}`] = values[key];

            // Add alias to properties of .translations
            if (
               key == "translations" &&
               values["translations"] &&
               values["translations"].length
            ) {
               updatedVals.translations = [];

               values["translations"].forEach((tran) => {
                  let updatedTran = {};

                  Object.keys(tran).forEach((tranKey) => {
                     if (tranKey == "language_code")
                        updatedTran["language_code"] = tran["language_code"];
                     else updatedTran[`${alias}.${tranKey}`] = tran[tranKey];
                  });

                  updatedVals.translations.push(updatedTran);
               });
            }
         });
      });

      return updatedVals;
   }

   isValidData(rowData) {
      let result = true;

      // NOTE: should we use filter of the current view of object to filter
      //        if yes, update .wheres condition in .loadData too
      if (this.__filterDatasource)
         result = result && this.__filterDatasource.isValid(rowData);

      if (this.__filterDatacollection)
         result = result && this.__filterDatacollection.isValid(rowData);

      if (result && this.__filterScope)
         result = result && this.__filterScope.isValid(rowData);

      return result;
   }

   // Clone

   clone(settings) {
      settings = settings || this.toObj();
      var clonedDatacollection = new this.constructor(settings, this.AB);
      clonedDatacollection.__datasource = this.__datasource;
      clonedDatacollection._dataStatus = this._dataStatus;

      // clonedDatacollection.__dataCollection = this.__dataCollection.copy();
      clonedDatacollection.__filterDatacollection.setValue(
         settings.settings.objectWorkspace.filterConditions
      );

      var parseMe = () => {
         if (clonedDatacollection.__dataCollection) {
            clonedDatacollection.__dataCollection.parse(
               this.__dataCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
         if (clonedDatacollection.__treeCollection) {
            clonedDatacollection.__treeCollection.parse(
               this.__treeCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
      };

      parseMe();

      // return new Promise((resolve, reject) => {
      //    // load the data
      //    clonedDatacollection
      //       .loadData()
      //       .then(() => {

      // set the cursor
      clonedDatacollection.setStaticCursor();

      var cursorID = this.getCursor();
      if (cursorID) {
         // NOTE: webix documentation issue: .getCursor() is supposed to return
         // the .id of the item.  However it seems to be returning the {obj}
         if (cursorID.id) cursorID = cursorID.id;

         clonedDatacollection.setCursor(cursorID);
      }

      return clonedDatacollection;

      // resolve(clonedDatacollection);
      //       })
      //       .catch(reject);
      // });
   }

   filteredClone(filters) {
      var obj = this.toObj();

      // check to see that filters are set (this is sometimes helpful to select the first record without doing so at the data collection level)
      if (filters?.rules?.length) {
         if (obj.settings.objectWorkspace.filterConditions?.rules?.length) {
            obj.settings.objectWorkspace.filterConditions.rules =
               obj.settings.objectWorkspace.filterConditions.rules.concat(
                  filters.rules
               );
         } else {
            obj.settings.objectWorkspace.filterConditions = filters;
         }
      }
      let clonedDC = this.clone(obj);
      return clonedDC; // new ABViewDataCollection(settings, this.application, this.parent);
   }

   //
   // Event handles
   //

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    *              emitter: object,
    *              eventName: string,
    *              listener: function
    *            }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      this.__events = this.__events || [];

      let exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    */
   eventClear() {
      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   get userScopes() {
      return [];
   }

   get isCursorFollow() {
      return (
         this.settings.followDatacollectionID &&
         (!this.settings.linkDatacollectionID || !this.settings.linkFieldID)
      );
   }

   get datacollectionFollow() {
      if (!this.isCursorFollow) return null;

      return (this.AB ?? AB).datacollectionByID(
         this.settings.followDatacollectionID
      );
   }
}


/***/ }),

/***/ 17953:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABDefinitionCore.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDefinitionCore)
/* harmony export */ });
// import ABApplication from "./ABApplication"

class ABDefinitionCore {
   constructor(attributes, AB) {
      this.AB = AB;
      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			type: 'xxxxx',
			json: "{json}"
		}
		*/
      if (attributes.id) {
         this.id = attributes.id;
      }
      this.name =
         attributes?.name ||
         attributes?.json?.name ||
         attributes?.json?.label ||
         attributes?.json?.translations?.[0]?.label ||
         "";
      if (!this.name) {
         this.AB.notify.builder(
            new Error("Attributes for definition had no 'name'"),
            {
               context: "ABDefinitionCore.fromValues()",
               attributes,
            }
         );
      }
      this.type = attributes.type || attributes?.json?.type || "";
      this.json = attributes.json || null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      return {
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.json,
      };
   }

   /**
    * @method destroy()
    * destroy the current instance of ABDefinition
    * Also remove it from our parent application
    * @return {Promise}
    */
   destroy() {
      return this.AB.definitionDestroy(this.id);
   }

   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    *         .resolve( {this} )
    */
   async save() {
      if (this.id) {
         return this.AB.definitionUpdate(this.id, this.toObj());
      } else {
         return this.AB.definitionCreate(this.toObj());
      }
   }
}


/***/ }),

/***/ 45800:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABFactoryCore.js ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABApplication */ 10285);
/* harmony import */ var _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABApplicationMobile */ 38094);
/* harmony import */ var _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/ABDefinition */ 34802);
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);
/* harmony import */ var _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ABFieldManager */ 96408);
/* harmony import */ var _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/ABIndex */ 32711);
/* harmony import */ var _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/ABObject */ 83311);
/* harmony import */ var _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../platform/ABObjectExternal */ 18700);
/* harmony import */ var _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../platform/ABObjectImport */ 94910);
/* harmony import */ var _platform_ABDataCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/ABDataCollection */ 98383);
/* harmony import */ var _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../platform/ABObjectQuery */ 59545);
/* harmony import */ var _platform_ABHint__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../platform/ABHint */ 5701);
/* harmony import */ var _platform_ABProcess__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../platform/ABProcess */ 33046);
/* harmony import */ var _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../platform/process/ABProcessParticipant */ 74843);
/* harmony import */ var _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../platform/process/ABProcessLane */ 23479);
/* harmony import */ var _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./process/ABProcessTaskManager */ 83316);
/* harmony import */ var _platform_ABStep__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../platform/ABStep */ 81410);
/* harmony import */ var _platform_views_ABViewDetailItem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../platform/views/ABViewDetailItem */ 48172);
/* harmony import */ var _platform_views_ABViewFormItem__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../platform/views/ABViewFormItem */ 9247);
/* harmony import */ var _platform_RowFilter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../platform/RowFilter */ 84470);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../platform/FilterComplex */ 10758);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/* harmony import */ var _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../platform/ABEmitter */ 4025);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__, _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__, _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__, _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__]);
([_platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__, _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__, _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__, _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/*
 * ABFactoryCore
 * an object that contains the definitions and references for a single tenant.
 * It is expected that an instance of this should be returned from an
 * ABBootstrap.init(req).then((AB)=>{}) call.
 */

// const _ = require("lodash");
// const uuidv4 = require("uuid");

// const ABApplication = require("../platform/ABApplication");




// const ABDefinition = require("../platform/ABDefinition");


// const ABComponent = require("../platform/ABComponent");


// const ABFieldManager = require("./ABFieldManager");


// const ABIndex = require("../platform/ABIndex");


// const ABObject = require("../platform/ABObject");


// const ABObjectExternal = require("../platform/ABObjectExternal");

// const ABObjectImport = require("../platform/ABObjectImport");

// const ABDataCollection = require("../platform/ABDataCollection");

// const ABObjectQuery = require("../platform/ABObjectQuery");


// const ABHint = require("../platform/ABHint");


// const ABProcess = require("../platform/ABProcess");


// const ABProcessParticipant = require("../platform/process/ABProcessParticipant");


// const ABProcessLane = require("../platform/process/ABProcessLane");


// const ABProcessTaskManager = require("./process/ABProcessTaskManager");


// const ABStep = require("../platform/ABStep");


// const ABViewDetailItem = require("../platform/views/ABViewDetailItem");


// const ABViewFormItem = require("../platform/views/ABViewFormItem");


// const ABObjectWorkspaceViewGrid = require("../platform/workspaceViews/ABObjectWorkspaceViewGrid");
// const ABObjectWorkspaceViewKanban = require("../platform/workspaceViews/ABObjectWorkspaceViewKanban");
// const ABObjectWorkspaceViewGantt = require("../platform/workspaceViews/ABObjectWorkspaceViewGantt");

// const RowFilter = require("../platform/RowFilter");


// const FilterComplex = require("../platform/FilterComplex");


// const ABMLClass = require("../platform/ABMLClass");


// const EventEmitter = require("../platform/ABEmitter");


class ABFactory extends _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_22__["default"] {
   constructor(definitions) {
      /**
       * @param {hash} definitions
       *        { ABDefinition.id : {ABDefinition} }
       *        of all the definitions defined for the current Tenant
       */

      super();
      this.setMaxListeners(0);

      this._definitions = definitions || {};
      // {hash}  { ABDefinition.id : {ABDefinition} }
      // ensure ._definitions is a HASH{ ID : {ABDefinition}}
      if (Array.isArray(definitions)) {
         var hash = {};
         definitions.forEach((d) => {
            hash[d.id] = d;
         });
         this._definitions = hash;
      }

      //
      //
      // Manage our working objects
      //

      this._allApplications = [];
      // {array} of all the ABApplication(s) in our site.

      this._allObjects = [];
      // {array} of all the ABObject(s) in our site.

      this._allHints = [];
      // {array} of all the ABHint(s) in our site.

      this._allProcesses = [];
      // {array} of all the ABProcess(s) in our site.

      this._allQueries = [];
      // {array} of all the ABObjectQuery(s) in our site.

      this._allSteps = [];
      // {array} of all the ABStep(s) in our site.

      this._allDatacollections = [];
      // {array} of all the ABDataCollection(s) in our site.

      //
      // Class References
      //
      this.Class = {
         ABApplication: _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__["default"],
         ABComponent: _platform_ABComponent__WEBPACK_IMPORTED_MODULE_3__["default"],
         ABDefinition: _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__["default"],
         ABFieldManager: _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__["default"],
         ABIndex: _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__["default"],
         ABMLClass: _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_21__["default"],
         ABObject: _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__["default"],
         ABObjectExternal: _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__["default"],
         ABObjectImport: _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__["default"],
         ABObjectQuery: _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_10__["default"],
         ABProcessParticipant: _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_13__["default"],
         // ABRole      // Do we need this anymore?

         // ABObjectWorkspaceViewGrid,
         // ABObjectWorkspaceViewKanban,
         // ABObjectWorkspaceViewGantt,

         ABProcessTaskManager: _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__["default"],

         ABViewDetailItem: _platform_views_ABViewDetailItem__WEBPACK_IMPORTED_MODULE_17__["default"],
         ABViewFormItem: _platform_views_ABViewFormItem__WEBPACK_IMPORTED_MODULE_18__["default"],
      };

      //
      // Rules
      // These are a common set of "rules" for all platforms.
      //
      this.rules = {
         /**
          * @method AB.rules.isUUID
          * evaluate a given value to see if it matches the format of a uuid
          * @param {string} key
          * @return {boolean}
          */
         isUUID: function (key) {
            var checker = RegExp(
               "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
               "i"
            );
            return checker.test(key);
         },

         /**
          * @method AB.rules.nameFilter()
          * return a properly formatted name for an AppBuilder object.
          * @param {string} name
          *        The name of the object we are conditioning.
          * @return {string}
          */
         nameFilter: function (name) {
            return String(name).replace(/[^a-z0-9_.]/gi, "");
         },

         /**
          * @method AB.rules.toApplicationNameFormat()
          * return a properly formatted Application Name
          * @param {string} name
          *        The name of the Application we are conditioning.
          * @return {string}
          */
         toApplicationNameFormat: function (name) {
            return "AB_" + this.nameFilter(name);
         },

         /**
          * @method AB.rules.toFieldRelationFormat()
          * This function uses for define relation name of Knex Objection
          * return a relation name of column
          * @param {string} colName
          *        The name of the Column
          * @return {string}
          */
         toFieldRelationFormat: function (colName) {
            return this.nameFilter(colName) + "__relation";
         },

         /**
          * @method AB.rules.toJunctionTableFK()
          * return foriegnkey (FK) column name for a junction table name
          * @param {string} objectName
          *        The name of the Object with a connection
          * @param {string} columnName
          *        The name of the connection columnName.
          * @return {string}
          */
         toJunctionTableFK: function (objectName, columnName) {
            var fkName = objectName + "_" + columnName;

            if (fkName.length > 64) fkName = fkName.substring(0, 64);

            return fkName;
         },

         /**
          * @method AB.rules.toJunctionTableNameFormat()
          * return many-to-many junction table name
          * @param {string} appName
          *        The name of the Application for this object
          * @param {string} sourceTableName
          *        The name of the source object we are conditioning.
          * @param {string} targetTableName
          *        The name of the target object we are conditioning.
          * @param {string} colName
          * @return {string}
          */
         toJunctionTableNameFormat: function (
            appName,
            sourceTableName,
            targetTableName,
            colName
         ) {
            // The maximum length of a table name in MySql is 64 characters
            appName = this.toApplicationNameFormat(appName);
            if (appName.length > 17) appName = appName.substring(0, 17);

            if (sourceTableName.length > 15)
               sourceTableName = sourceTableName.substring(0, 15);

            if (targetTableName.length > 15)
               targetTableName = targetTableName.substring(0, 15);

            colName = this.nameFilter(colName);
            if (colName.length > 14) colName = colName.substring(0, 14);

            return "{appName}_{sourceName}_{targetName}_{colName}"
               .replace("{appName}", appName)
               .replace("{sourceName}", sourceTableName)
               .replace("{targetName}", targetTableName)
               .replace("{colName}", colName);
         },

         /**
          * @method AB.rules.toObjectNameFormat
          * return a properly formatted Object/Table Name
          * @param {string} objectName
          *        The {ABObject}.name of the Object we are conditioning.
          * @return {string}
          */
         toObjectNameFormat: function (objectName) {
            return `AB_${this.nameFilter(objectName)}`;
         },
      };

      // Notify Helpers
      this.notify.builder = (...params) => {
         this.notify("builder", ...params);
      };

      this.notify.developer = (...params) => {
         this.notify("developer", ...params);
      };
   }

   /**
    * @method definitionClean()
    * make sure the provided ABDefinition values are properly formatted
    * @param {ABDefinition} d
    *        The json settings of an ABDefinition object.
    */
   definitionClean(d) {
      if (typeof d.json == "string") {
         try {
            d.json = JSON.parse(d.json);
         } catch (e) {
            console.log(e);
            console.error(` Error on definition id[${d.id}]`);
         }
      }
   }

   init() {
      let allDefinitions = Object.keys(this._definitions).map(
         (k) => this._definitions[k]
      );
      // {array} all our definitions in an Array format.

      // make sure our definitions.json field is an {} and not string
      allDefinitions.forEach((d) => {
         this.definitionClean(d);
      });

      // perform these in order:
      [
         "object",
         "query",
         "datacollection",
         "process",
         "hint",
         "step",
         "application",
      ].forEach((type) => {
         var objTypes = allDefinitions.filter((d) => d.type == type);
         objTypes.forEach((def) => {
            let { keyList, keyFn } = this.objectKeysByDef(def);
            if (keyList) {
               this[keyList].push(this[keyFn](def.json));
            }
         });
      });

      this.emit("init.objects_ready");
      return Promise.resolve();
   }

   /**
    * @method objectKeysByDef()
    * Analyze the provided ABDefinition json and return which set of list and
    * functions are used to create a new instance of this definition.
    * @param {json} def
    *        the ABDefinition json of the definition we are evaluating
    * @return { keyList, keyFn }
    *        keyList: {string}  which of our internal lists to store this new
    *                 object.
    *        keyFn: {string} which of our methods to call with the def.json
    *               as the param that will create the new object.
    *
    *        ex:  this[keyList].push( this[keyFn](def.json));
    *
    *        if this def is not one of the types we track,
    *        keyList = keyFn = null;
    */
   objectKeysByDef(def) {
      switch (def.type) {
         case "application":
            return { keyList: "_allApplications", keyFn: "applicationNew" };

         case "datacollection":
            return {
               keyList: "_allDatacollections",
               keyFn: "datacollectionNew",
            };

         case "hint":
            return { keyList: "_allHints", keyFn: "hintNew" };

         case "steps":
            return { keyList: "_allSteps", keyFn: "stepNew" };

         case "object":
            return { keyList: "_allObjects", keyFn: "objectNew" };

         case "process":
            return { keyList: "_allProcesses", keyFn: "processNew" };

         case "query":
            return { keyList: "_allQueries", keyFn: "queryNew" };

         default:
            // we don't manage any other
            return { keyList: null, keyFn: null };
      }
   }

   //
   // Definitions
   //

   /**
    * definitionByID(id)
    * return an ABDefinition.json value ready for our objects to use.
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @param {bool} isRaw
    *        indicates if we want the full ABDefinition, or the .json param
    *        true : returns full ABDefinition value.
    *        false: returns the .json parameter used by most ABObjects.
    * @return {Promise}
    */
   definitionByID(id, isRaw = false) {
      if (this._definitions[id]) {
         if (isRaw) {
            return this._definitions[id];
         } else {
            return this._definitions[id].json;
         }
      }
      return null;
   }

   /**
    * definitionNew(values)
    * return an ABDefinition object tied to this Tenant.
    * @param {obj} values
    *        The value hash of the ABDefinition object to create.
    * @return {ABDefinition}
    */
   definitionNew(values) {
      return new _platform_ABDefinition__WEBPACK_IMPORTED_MODULE_2__["default"](values, this);
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   definitionsParse(defs = []) {
      if (!Array.isArray(defs)) {
         defs = [defs];
      }

      // store/replace the incoming definitions
      // 1st: insert ALL our definitions internally
      defs.forEach((d) => {
         this.definitionClean(d);
         this._definitions[d.id] = d;
      });
      // 2nd: Now we can then go through and signal the "updates"
      // and the related objects can find their dependent definitions.
      defs.forEach((d) => {
         this.definitionSync("updated", d.id, d);
      });

      return Promise.resolve();
   }

   /**
    * definitionSync()
    * Synchronize an individual definition into our repository of definitions.
    * @param {string} op
    *        the type of synchronization this is
    *        [ "created", "updated", "destroyed"]
    * @param {uuid} id
    *        the definition.id of the definition we are synchronizing
    * @param {json} def
    *        the ABDefinition attributes we are storing.
    */
   definitionSync(op, id, def) {
      var { keyList, keyFn } = this.objectKeysByDef(def);
      if (keyList) {
         var curr;
         switch (op) {
            case "created":
               this[keyList].push(this[keyFn](def.json));
               this.emit("definition.created", def.json);
               break;

            case "updated":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);

               // remove from list
               this[keyList] = this[keyList].filter((d) => d.id != id);
               // add new one:
               this[keyList].push(this[keyFn](def.json));

               // signal this object needs to be updated:
               // NOTE: if this is one of the objects we are tracking,
               // we don't need to this.emit() the message.
               if (curr) {
                  curr.emit("definition.updated", def.json);
               } else {
                  this.emit("definition.updated", def.json);
               }
               break;

            case "destroyed":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);
               if (curr) {
                  // remove from list
                  this[keyList] = this[keyList].filter((d) => d.id != id);

                  // signal this object needs to be updated:
                  curr.emit("definition.deleted", def.json);

                  this.emit("definition.deleted", def.json);
               }
               break;
         }
      }
   }

   //
   // ABObjects
   //
   /**
    * @method applications()
    * return all the ABApplications that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABApplications.
    *        Must return true to include the entry.
    * @return {array}
    */
   applications(fn = () => true) {
      return (this._allApplications || []).filter(fn);
   }

   /**
    * @method applicationByID()
    * returns a single ABApplication that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABApplication we are searching
    *        for.
    * @return {ABApplication}
    *        the matching ABApplication object if found
    *        {null} if not found.
    */
   applicationByID(ID) {
      return this.applications((a) => a.id == ID)[0];
   }

   /**
    * @method applicationNew()
    * Return a new instance of an ABApplication object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplication object we are
    *        creating.
    * @return {ABApplication}
    */
   applicationNew(values) {
      // just in case we got here by mistake:
      if (values.appType == "mobile") {
         return this.applicationMobileNew(values);
      }

      return new _platform_ABApplication__WEBPACK_IMPORTED_MODULE_0__["default"](values, this);
   }

   /**
    * @method applicationMobileNew()
    * Return a new instance of an ABApplicationMobile object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplicationMobile object we are
    *        creating.
    * @return {ABApplicationMobile}
    */
   applicationMobileNew(values) {
      return new _platform_ABApplicationMobile__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }

   /**
    * @method datacollections()
    * return an array of all the ABDataCollection for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABDataCollection that
    *        this fn returns true for.
    * @return {array}
    *        array of ABDataCollection
    */
   datacollections(filter = () => true) {
      return (this._allDatacollections || []).filter(filter);
   }

   /**
    * @method datacollectionByID()
    * returns a single ABDatacollection that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABDatacollection we are searching
    *        for.
    * @return {ABDatacollection}
    *        the matching ABDatacollection object if found
    *        {null} if not found.
    */
   datacollectionByID(ID) {
      // an undefined or null ID should not match any DC.
      if (!ID) return null;

      return this.datacollections((dc) => {
         return dc.id == ID || dc.name == ID || dc.label == ID;
      })[0];
   }

   /**
    * @method datacollectionNew()
    * create a new instance of ABDataCollection
    * @param {obj} values
    *        the initial values for the DC
    * @return {ABDatacollection}
    */
   datacollectionNew(values) {
      var dc = new _platform_ABDataCollection__WEBPACK_IMPORTED_MODULE_9__["default"](values, this);
      dc.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allDatacollections = this._allDatacollections.filter(
            (d) => d.id != dc.id
         );
      });
      return dc;
   }

   /**
    * @method fieldNew()
    * return an instance of a new (unsaved) ABField that is tied to a given
    * ABObject.
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    * @param {obj} values  the initial values for this field.
    *                - { key:'{string}'} is required
    * @param {ABObject} object  the parent object this field belongs to.
    * @return {ABField}
    */
   fieldNew(values, object) {
      // NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
      return _ABFieldManager__WEBPACK_IMPORTED_MODULE_4__["default"].newField(values, object);
   }

   /**
    * @method indexNew()
    * return an instance of a new (unsaved) ABIndex.
    * @return {ABIndex}
    */
   indexNew(values, object) {
      return new _platform_ABIndex__WEBPACK_IMPORTED_MODULE_5__["default"](values, object);
   }

   /**
    * @method Label()
    * a simple label factory.
    * It is expected to be called like this:
    * @codestart
    *    var L = AB.Label();
    *    var outputText = L("Hello World");
    *    var o2 = L("I'm {0} years old", [5]);
    * @codeend
    * @return {fn}
    */
   Label() {
      return (key, altText, values = []) => {
         var label = key;
         if (altText) {
            if (Array.isArray(altText)) {
               values = altText;
            } else {
               label = altText;
            }
         }

         values.forEach((v, i) => {
            var sub = `{${i}}`;
            label = label.replaceAll(sub, v);
         });

         return label;
      };
   }

   /**
    * @method objects()
    * return an array of all the ABObjects for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABObjects that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObject
    */
   objects(filter = () => true) {
      return (this._allObjects || []).filter(filter);
   }

   /**
    * @method objectByID()
    * return the specific object requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   objectByID(ID) {
      return this.objects((o) => {
         return o.id == ID || o.name == ID || o.label == ID;
      })[0];
   }

   /**
    * @method objectNew()
    * return an instance of a new (unsaved) ABObject that is tied to this
    * ABApplication.
    * NOTE: this new object is not included in our this.objects until a .save()
    * is performed on the object.
    * @return {ABObject}
    */
   objectNew(values) {
      var newObj = null;

      if (values.isExternal == true)
         newObj = new _platform_ABObjectExternal__WEBPACK_IMPORTED_MODULE_7__["default"](values, this);
      else if (values.isImported == true)
         newObj = new _platform_ABObjectImport__WEBPACK_IMPORTED_MODULE_8__["default"](values, this);
      else newObj = new _platform_ABObject__WEBPACK_IMPORTED_MODULE_6__["default"](values, this);

      /*
      // IS THIS CORRECT?
      newObj.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allObjects = this._allObjects.filter((o) => o.id != newObj.id);
      });
      */

      return newObj;
   }

   objectFile() {
      return this.objectByID("4a9d89c9-f4eb-41af-91e4-909eff389f3e");
   }

   objectLanguage() {
      return this.objectByID("d84cd351-d96c-490f-9afb-2a0b880ca0ec");
   }

   objectProcessForm() {
      return this.objectByID("d36ae4c8-edef-48d8-bd9c-79a0edcaa067");
   }

   objectProcessInstance() {
      return this.objectByID("2ba85be0-78db-4eda-ba43-c2c4e3831849");
   }

   objectRole() {
      return this.objectByID("c33692f3-26b7-4af3-a02e-139fb519296d");
   }

   objectScope() {
      return this.objectByID("af10e37c-9b3a-4dc6-a52a-85d52320b659");
   }

   objectToken() {
      return this.objectByID("08826ac7-4b33-4745-a3d7-f7831ca4ff59");
   }

   objectUser() {
      return this.objectByID("228e3d91-5e42-49ec-b37c-59323ae433a1");
   }

   //
   // Hints
   //
   /**
    * @method hints()
    * return all the ABHints that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABHints.
    *        Must return true to include the entry.
    * @return {array}
    */
   hints(filter = () => true) {
      return (this._allHints || []).filter(filter);
   }

   /**
    * @method hintByID()
    * return the specific hint requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   hintID(ID) {
      return this.hints((h) => {
         return h.id == ID || h.name == ID || h.label == ID;
      })[0];
   }

   /**
    * @method hintNew()
    * return an instance of a new (unsaved) ABHint that is tied to this
    * ABApplication.
    * NOTE: this new hint is not included in our this.hints until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   hintNew(values) {
      var newHint = new _platform_ABHint__WEBPACK_IMPORTED_MODULE_11__["default"](values, this);

      return newHint;
   }

   //
   // Steps
   //
   /**
    * @method steps()
    * return all the ABSteps that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABSteps.
    *        Must return true to include the entry.
    * @return {array}
    */
   steps(filter = () => true) {
      return (this._allSteps || []).filter(filter);
   }

   /**
    * @method stepByID()
    * return the specific step requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   stepID(ID) {
      return this.steps((s) => {
         return s.id == ID || s.name == ID || s.label == ID;
      })[0];
   }

   /**
    * @method stepNew()
    * return an instance of a new (unsaved) ABStep that is tied to this
    * ABApplication.
    * NOTE: this new step is not included in our this.steps until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   stepNew(id, hintID) {
      var stepDef = this.definitionByID(id);
      if (stepDef) {
         var getStep = new _platform_ABStep__WEBPACK_IMPORTED_MODULE_16__["default"](stepDef, this);
         return getStep;
      } else {
         var params = {
            settings: {
               hint: hintID,
            },
         };
         var newStep = new _platform_ABStep__WEBPACK_IMPORTED_MODULE_16__["default"](params, this);
         return newStep;
      }
   }

   //
   // Processes
   //
   /**
    * @method processes()
    * return all the ABProcess that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABProcess.
    *        Must return true to include the entry.
    * @return {array}
    */
   processes(filter = () => true) {
      return (this._allProcesses || []).filter(filter);
   }

   /**
    * @method processByID()
    * return the specific process requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   processByID(ID) {
      return this.processes((p) => {
         return p.id == ID || p.name == ID || p.label == ID;
      })[0];
   }

   /**
    * @method processNew()
    * Return a new instance of an ABProcess object.
    * @param {json} values
    *        the ABDefinition.json of the ABProcess object we are
    *        creating.
    * @return {ABProcess}
    */
   processNew(values) {
      return new _platform_ABProcess__WEBPACK_IMPORTED_MODULE_12__["default"](values, this);
   }

   /**
    * @method processElementNew(id)
    * return an instance of a new ABProcessOBJ that is tied to a given
    * ABProcess.
    * @param {string} id
    *        the ABDefinition.id of the element we are creating
    * @param {ABProcess} process
    *        the process this task is a part of.
    * @return {ABProcessTask}
    */
   processElementNew(id, process) {
      var taskDef = this.definitionByID(id);
      if (taskDef) {
         switch (taskDef.type) {
            case _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_13__["default"].defaults().type:
               return new _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_13__["default"](taskDef, process, this);
            // break;

            case _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_14__["default"].defaults().type:
               return new _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_14__["default"](taskDef, process, this);
            // break;

            default:
               // default to a Task
               return _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__["default"].newTask(taskDef, process, this);
            // break;
         }
      }
      return null;
   }

   /**
    * @method processElementNewForModelDefinition(def)
    *
    * return an instance of a new ABProcess[OBJ] that is tied to the given
    * BPMI:Element definition.
    *
    * @param {BPMI:Element} element the element definition from our BPMI
    *              modler.
    * @return {ABProcess[OBJ]}
    */
   processElementNewForModelDefinition(element, process) {
      var newElement = null;

      switch (element.type) {
         case "bpmn:Participant":
            newElement = new _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_13__["default"]({}, process, this);
            break;

         case "bpmn:Lane":
            newElement = new _platform_process_ABProcessLane__WEBPACK_IMPORTED_MODULE_14__["default"]({}, process, this);
            break;

         default:
            var defaultDef = _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__["default"].definitionForElement(element);
            if (defaultDef) {
               newElement = _process_ABProcessTaskManager__WEBPACK_IMPORTED_MODULE_15__["default"].newTask(
                  defaultDef,
                  process,
                  this
               );
            }
            break;
      }

      // now make sure this new Obj pulls any relevant info from the
      // diagram element
      if (newElement) {
         newElement.fromElement(element);
      }
      return newElement;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery(s).
    * @param {fn} filter
    *        a filter fn to return a set of ABObjectQuery(s) that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObjectQuery
    */
   queries(filter = () => true) {
      return (this._allQueries || []).filter(filter);
   }
   // queriesAll() {
   //    console.error(
   //       "ABFactory.queriesAll() Depreciated! Use .queries() instead. "
   //    );
   //    return this.queries();
   // }

   /**
    * @method queryByID()
    * return the specific query requested by the provided id.
    * NOTE: this method has been extended to allow .name and .label
    * as possible lookup values.
    * @param {string} ID
    * @return {ABObjectQuery}
    */
   queryByID(ID) {
      return this.queries((q) => {
         return q.id == ID || q.name == ID || q.label == ID;
      })[0];
   }

   /**
    * @method queryNew()
    * return an instance of a new (unsaved) ABObjectQuery that is tied to this
    * ABFactory.
    * @return {ABObjectQuery}
    */
   queryNew(values) {
      return new _platform_ABObjectQuery__WEBPACK_IMPORTED_MODULE_10__["default"](values, this);
   }

   /**
    * @method rowfilterNew()
    * return an instance of a new RowFilter that is tied to this
    * ABFactory.
    * @return {RowFilter}
    */
   rowfilterNew(App, idBase) {
      if (App) {
         console.error("!! Who is calling this with an App?");
      }
      return new _platform_RowFilter__WEBPACK_IMPORTED_MODULE_19__["default"](App || this._App, idBase, this);
   }

   /**
    * @method filterComplexNew()
    * return an instance of a new FilterComplex that is tied to this
    * ABFactory.
    * @return {FilterComplex}
    */
   filterComplexNew(idBase, options = {}) {
      return new _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_20__["default"](idBase, this, options);
   }

   /**
    * @method viewNewDetatched()
    * Return an instance of a View that is NOT attached to an ABApplication.
    * @return {ABViewXXX}
    */
   viewNewDetatched(values) {
      if (!this._mockApp) {
         this._mockApp = this.applicationNew({});
      }
      return this._mockApp.viewNew(values, this._mockApp);
   }

   //
   // Utilities
   //

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(/* ...params */) {
      console.error(
         "ABFactory.notify() is expected to be overwritten by the platform!"
      );
   }

   /**
    * notifyInfo()
    * a common routine to parse the info parameter provided to .notify() into
    * a more detailed set of data.
    * @param {json} info
    * @return {json}
    */
   _notifyInfo(info) {
      var moreInfo = {};

      if (info) {
         Object.keys(info).forEach((k) => {
            switch (k) {
               case "field":
                  moreInfo.objectID = info[k].object?.id;
                  moreInfo.objectName = info[k].object?.name;
                  moreInfo.fieldID = info[k].id;
                  moreInfo.fieldName = info[k].label || info[k].name;
                  break;

               case "object":
                  moreInfo.objectID = info[k].id;
                  moreInfo.objectName = info[k].name;
                  break;

               case "datacollection":
                  moreInfo.datacollectionID = info[k].id;
                  moreInfo.datacollectionName = info[k].label || info[k].name;
                  var ds = info[k].datasource;
                  if (ds) {
                     moreInfo.datacollectionDSID = ds.id;
                     moreInfo.datacollectionDSName = ds.name;
                  }
                  break;

               case "process":
                  moreInfo.processID = info[k].id;
                  moreInfo.processName = info[k].label || info[k].name;
                  break;

               case "req":
                  moreInfo.req = {
                     jobID: info[k].jobID,
                     tenantID: info[k]._tenantID,
                     user: info[k]._user,
                  };
                  break;

               case "task":
                  if (info[k].process) {
                     moreInfo.processID = info[k].process.id;
                     moreInfo.processName =
                        info[k].process.label || info[k].process.name;
                  }
                  moreInfo.taskID = info[k].id;
                  moreInfo.taskName = info[k].label || info[k].name;
                  break;

               case "view":
                  if (info[k].application) {
                     moreInfo.applicationID = info[k].application.id;
                     moreInfo.applicationName =
                        info[k].application.label || info[k].application.name;
                  }
                  moreInfo.viewID = info[k].id;
                  moreInfo.viewName = info[k].label || info[k].name;
                  moreInfo.viewKey = info[k].key;
                  break;
               default:
                  moreInfo[k] = info[k];
                  break;
            }
         });
      }

      return moreInfo;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABFactory);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 96408:
/*!**************************************************!*\
  !*** ./src/js/AppBuilder/core/ABFieldManager.js ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABFieldManager)
/* harmony export */ });
/*
 * ABFieldManager
 *
 * An interface for managing the different ABFields available in our AppBuilder.
 *
 */

/*
 * Fields
 * A name => ABField  hash of the different ABFields available.
 */
var Fields = {};

var AllFieldClasses = [
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldString_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldString */ 56675)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldLongText_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldLongText */ 33482)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldNumber_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldNumber */ 66242)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_core_dataFields_ABFieldDateCore_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldDate_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldDate */ 42405)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_core_dataFields_ABFieldDateCore_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldDateTime_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldDateTime */ 68246)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldBoolean_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldBoolean */ 23126)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldList_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldList */ 23122)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldSelectivity_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldTree_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldTree */ 32001)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldEmail_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldEmail */ 19387)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldFile_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldFile */ 5833)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldImage_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldImage */ 34688)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldConnect_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldUser_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldUser */ 21391)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldConnect_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldConnect */ 30289)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldCalculate_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldCalculate */ 15308)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldTextFormula_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldTextFormula */ 62817)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldFormula_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldFormula */ 54953)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldAutoIndex_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldAutoIndex */ 99341)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldJson_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldJson */ 7101)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldCombine_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldCombine */ 71331)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldSelectivity_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/dataFields/ABFieldSelectivity */ 55522)),
];

AllFieldClasses.forEach((FIELD) => {
   FIELD = FIELD.default;
   Fields[FIELD.defaults().key] = FIELD;
});

class ABFieldManager {
   /*
    * @function allFields
    * return all the currently defined ABFields in an array.
    * @return [{ABField},...]
    */
   static allFields() {
      var fields = [];
      for (var f in Fields) {
         fields.push(Fields[f]);
      }
      return fields;
   }

   /**
    * @function fieldByKey()
    * Return a specific ABField that matches the given key
    * @param {string} key
    *        The ABField.key value we are looking for.
    * @return {ABFieldXXX || undefined}
    */
   static fieldByKey(key) {
      return Fields[key];
   }

   /*
    * @function newField
    * return an instance of an ABField based upon the values.key value.
    * @return {ABField}
    */
   static newField(values, object) {
      if (values.key) {
         try {
            return new Fields[values.key](values, object);
         } catch (err) {
            console.log("Error", err);
            console.log("Available fields", Fields);
            console.log("Requested field", values.key);
         }
      } else {
         console.log("-------");
         console.log("values:");
         console.error(values);
         console.log();
         console.error("object:");
         console.error(object);
         console.log("-------");
         throw new Error(
            `ABFieldManager.newField(): Unknown Field Key [${values.name}][${values.key}] for object[${object.name}]`
         );
         //// TODO: what to do here?
      }
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 36717:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ABHintCore.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABHintCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
// import ABApplication from "./ABApplication"


// const _concat = require("lodash/concat");

class ABHintCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["name", "description"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      description: 'description',
      type: 'hint',
      settings: {
         active: {boolean},
         view: uuid
      }
    }
    */
      let active = attributes?.settings?.active ?? "1";

      this.id = attributes?.id || "";
      this.name = attributes?.name || "New Tutorial";
      this.description = attributes?.description || "";
      this.type = attributes?.type || "hint";
      this.settings = {};
      this.settings.active = active;
      this.settings.transition = attributes?.settings?.transition;
      this.settings.showIntroStep = attributes?.settings?.showIntroStep;
      this.settings.view = attributes?.settings?.view || "";
      this.stepIDs = attributes?.stepIDs || [];

      let currSteps = this?._steps || {};
      this._steps = {};
      (attributes?.stepIDs || []).forEach((sID) => {
         if (!sID) return;
         var ele = this.AB.stepNew(sID, this.id);
         if (ele) {
            this._steps[sID] = ele;
         }
      });
      if (attributes) super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["type", "settings", "stepIDs", "id", "name"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * steps()
    * return an array of steps that match the given filter (or all steps
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABStep]}
    */
   steps(fn = () => true) {
      var allSteps = Object.keys(this._steps).map((e) => {
         return this._steps[e];
      });
      return allSteps.filter(fn);
   }

   /**
    * stepAdd()
    * insert a step to be added to this hint.
    * @param {ABStep} element
    *        the full instance of an ABStep to track.
    */
   stepAdd(step) {
      this._steps[step.id] = step;
   }

   /**
    * stepByID()
    * return the {ABStep} that has the given .id
    * @param {string} id
    * @return {ABStep[OBJ]}
    */
   stepByID(id) {
      return this._steps[id] ?? null;
   }

   /**
    * stepRemove()
    * remove a step from being displayed by this hint.
    * @param {id} ABStep ID
    *        an ID of a step
    *        to remove.
    */
   stepRemove(id) {
      // remove from stepIDs array
      let stepIndex = this.stepIDs.indexOf(id);
      if (stepIndex > -1) {
         this.stepIDs.splice(stepIndex, 1);
      }
      // remove from _steps definitions
      delete this._steps[id];
   }
}


/***/ }),

/***/ 59815:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/core/ABIndexCore.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABIndexCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);


class ABIndexCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, object) {
      super(["label"], object.AB);
      this.object = object;

      this.fromValues(attributes);
   }

   fromValues(attributes) {
      /*
      {
        id: uuid(),
        name: 'name',
        fields:[
            {ABDataField.id}
        ],
        unique: {boolean}
      }
      */
      this.id = attributes.id;
      this.type = "index";
      this.name = attributes.name;
      this.unique = JSON.parse(attributes.unique || false);

      // Convert to an array
      if (attributes.fieldIDs && !Array.isArray(attributes.fieldIDs)) {
         attributes.fieldIDs = [attributes.fieldIDs];
      }

      this._unknownFieldIDs = [];
      this.fields = (attributes.fieldIDs || [])
         .map((f) => {
            let field = this.object.fieldByID(f);
            if (!field) {
               this._unknownFieldIDs.push(f);
               let err = new Error(
                  `Index[${this.name}][${this.id}] is referencing an unknown field[${f}]`
               );
               this.AB.notify.developer(err, {
                  index: this.id,
                  field: f,
               });
            }
            return field;
         })
         .filter((fId) => fId);

      if (this.fields.length == 0) {
         let err = new Error(
            `Index[${this.name}][${this.id}] is not referencing any fields`
         );
         this.AB.notify.developer(err, {
            index: this.id,
            attributeFieldIDs: attributes.fieldIDs || [],
         });
      }

      // let the MLClass process the Translations
      super.fromValues(attributes);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let result = super.toObj();

      result.id = this.id;
      result.type = "index";
      result.name = this.name;
      result.unique = this.unique;

      // Convert to an array
      if (this.fields && !Array.isArray(this.fields)) {
         this.fields = [this.fields];
      }

      result.fieldIDs = (this.fields || [])
         .map((f) => {
            // Convert to the id of field
            return f.id || f;
         })
         .filter((fId) => fId);

      // carry along the unknown Field IDs so a
      // developer/builder can come along and trace
      // what happened.
      this._unknownFieldIDs.forEach((f) => {
         result.fieldIDs.push(f);
      });

      return result;
   }

   get indexName() {
      let tableName = this.object.dbTableName();

      // Maximum 64 characters long
      return `${tableName}_${this.name}`.replace(/ /g, "").substring(0, 64);
   }

   get uniqueName() {
      let indexName = this.indexName.substring(0, 57);

      return `${indexName}_unique`;
   }
}


/***/ }),

/***/ 90477:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABMLClassCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMLClassCore)
/* harmony export */ });
/* harmony import */ var _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABEmitter */ 4025);
/**
 * ABMLClassCore
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This core ABMLClass will internally track the multilingual fields
 * (this.mlFields) and auto
 */

class ABMLClassCore extends _platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(fieldList, AB) {
      super();
      this.mlFields = fieldList || ["label"];
      // {array}
      // field names of values that are multilingual

      this.AB = AB;
      // {ABFactory}
      // our common source of references for other AB objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * @method fromValues
    * called during the .fromValues() work chain.  Should be called
    * AFTER all the current data is already populated.
    */
   fromValues(attributes) {
      this.translations = attributes.translations;

      // if translations were provided
      if (this.translations) {
         // multilingual fields: label, description
         this.translate();
      } else {
         // maybe this came from a form that has ML values in the attributes, but
         // no .translations[] yet:
         // check for mlFields in attributes and record them here:
         (this.mlFields || []).forEach((field) => {
            if (attributes[field]) {
               this[field] = attributes[field];
            }
         });
      }
   }

   /**
    * @function defaultTranslations()
    * return an initial .translations entry to initialize the
    * translations values of a given translateable object.
    * @param {array} fields  the multilingual fields this obj manages.
    * @param {json}  values  a default set of values for this object.
    * @return {array}  of translation entries.
    */
   defaultTranslations(fields, values) {
      values = values || {};

      var entry = {
         // Question: should this be this.AB.Multilingual.currentLanguage() || "en"
         // currently since the defaults are sent in programattically, we are
         // expecting the labels to be in "en"
         language_code: "en",
      };

      fields.forEach((f) => {
         entry[f] = values[f] || f;
      });

      return [entry];
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return "en";
   }

   /**
    * @method toObj()
    * called during the .toObj() work chain.  Should be called
    * BEFORE the current data is populated.
    */
   toObj() {
      this.unTranslate();

      return {
         translations: this.translations,
      };
   }

   /**
    * @method toDefinition()
    * convert this instance into an ABDefinition object.
    * @return {ABDefinition}
    */
   toDefinition() {
      return this.AB.definitionNew({
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.toObj(),
      });
   }

   /**
    * @method translate
    * Given a set of json data, pull out any multilingual translations
    * and flatten those values to the base object.
    * @param {obj} obj  The instance of the object being translated
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull to
    *                       the obj[field] value.
    */
   translate(obj, json, fields, languageCode = null) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      if (typeof json.translations == "string") {
         json.translations = JSON.parse(json.translations);
      }

      var currLanguage = languageCode || this.languageDefault();

      if (fields && fields.length > 0) {
         // [fix] if no matching translation is in our json.translations
         //       object, then just use the 1st one.
         var first = null; // the first translation entry encountered
         var found = false; // did we find a matching translation?

         json.translations.forEach(function (t) {
            if (!first) first = t;

            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               found = true;

               // copy each field to the root object
               fields.forEach(function (f) {
                  if (t[f] != null) obj[f] = t[f];

                  obj[f] = t[f] || ""; // default to '' if not found.
               });
            }
         });

         // if !found, then use the 1st entry we did find.  prepend desired
         // [language_code] to each of the fields.
         if (!found && first) {
            // copy each field to the root object
            fields.forEach(function (f) {
               if (first[f] != null && first[f] != "")
                  obj[f] = `[${currLanguage}]${first[f]}`;
               else obj[f] = ""; // default to '' if not found.
            });
         }
      }
   }

   /**
    * @method unTranslate
    * Take the multilingual information in the base obj, and push that
    * down into the json.translations data.
    * @param {obj} obj  The instance of the object with the translation
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull from
    *                       the obj[field] value.
    */
   unTranslate(obj, json, fields) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      var currLanguage = this.languageDefault();

      if (fields && fields.length > 0) {
         var foundOne = false;

         json.translations.forEach(function (t) {
            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               // copy each field to the root object
               fields.forEach(function (f) {
                  // verify obj[f] is defined
                  // --> DONT erase the existing translation
                  if (obj[f] != null) {
                     t[f] = obj[f];
                  }
               });

               foundOne = true;
            }
         });

         // if we didn't update an existing translation
         if (!foundOne) {
            // create a translation entry:
            var trans = {};

            // assume current languageCode:
            trans.language_code = currLanguage;

            fields.forEach(function (field) {
               if (obj[field] != null) {
                  trans[field] = obj[field];
               }
            });

            json.translations.push(trans);
         }
      }
   }
}


/***/ }),

/***/ 312:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/core/ABModelCore.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelCore)
/* harmony export */ });
//
// ABModelCore
//
// Represents the Data interface for an ABObject data.
//
// to use an ABModel to load a DataTable:
// Method 1:
//  gather all the data externally and send to the DataTable
//    Model.findAll()
//    .then((data)=>{
//      DataTable.parse(data);
//    })
//

class ABModelCore {
   constructor(object) {
      // link me to my ABObject
      this.object = object;
      this.AB = object.AB;

      this._where = null;
      this._sort = null;
      this._skip = null;
      this._limit = null;

      this.staleRefreshInProcess = false;
      this.staleRefreshMap = {
         /* id : Promise */
      };
      this.staleRefreshPending = [];
      this.staleRefreshTimerID = null;

      // include this
      this.responseContext = { key: "--", context: {} };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   contextKey(key) {
      this.responseContext.key = key || "--";
   }

   contextValues(values) {
      this.responseContext.context = values || {};
   }

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      console.error(
         "!!! ABModelCore.request() should be overridden by platform."
      );
      return Promise.resolve();
   }

   // /**
   //  * @method create
   //  * update model values on the server.
   //  */
   // create(values) {

   //   this.prepareMultilingualData(values);

   //   var params = {
   //     url: this.object.urlRest(),
   //     params: values
   //   }
   //   return this.request('post', params)
   //     .then((data) => {

   //       this.normalizeData(data);

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a create event
   //       // triggerEvent('create', this.object, data);

   //     })
   //     .catch(reject);

   // }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer} id  the .id of the instance to remove.
    * @return {Promise}
    */
   // delete(id) {

   //   var params = {
   //     url: this.object.urlRestItem(id)
   //   }
   //   return this.request('delete', params)
   //     .then((data) => {

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a delete event
   //       // triggerEvent('delete', this.object, id);

   //     })
   // }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   //   findAll(cond) {

   //     cond = cond || {};

   //     var params = {
   //       url: this.object.urlRest(),
   //       params: cond
   //     }
   //     return this.request('get', params)
   //       .then((data) => {

   //         this.normalizeData(data.data);

   //         resolve(data);
   //       })
   //       .catch((err) => {
   // /// TODO: this should be done in platform/ABModel:
   //         // if (err && err.code) {
   //         //  switch(err.code) {
   //         //    case "ER_PARSE_ERROR":
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Parse Error with provided condition', { error: err, condition:cond })
   //         //      break;

   //         //    default:
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Unknown Error with provided condition', { error: err, condition:cond })
   //         //      break;
   //         //  }

   //         // }
   // console.error(err);
   //       })

   //   }

   urlParamsCreate(values) {
      return {
         url: this.object.urlRest(),
         params: values,
      };
   }

   urlParamsDelete(id) {
      return {
         url: this.object.urlRestItem(id),
      };
   }

   urlParamsFind(cond) {
      return {
         url: this.object.urlRest(),
         params: cond || {},
      };
   }

   urlParamsUpdate(id, values) {
      return {
         url: this.object.urlRestItem(id),
         params: values,
      };
   }

   /**
    * @method count
    * count a data find with the provided condition.
    */
   count(cond) {
      cond = cond || {};

      var params = {
         url: this.object.urlRestCount(),
         params: cond,
      };
      return this.request("get", params)
         .then((numberOfRows) => {
            resolve(numberOfRows);
         })
         .catch((err) => {
            // TODO: this should be done in platform/ABModel

            // OP.Error.log('AppBuilder:ABModel:count(): Parse Error with provided condition', { error: err, condition:cond })

            // reject(err);
            console.error(err);
         });
   }

   /**
    * @method staleRefresh
    * Process a request to refresh the data for a given entry.
    * This method is called from a ABDataview when it receives
    * a 'ab.datacollection.stale' message.
    * This method will try to queue similar reqeusts and then issue 1 large
    * request, rather than numerous individual ones.
    * @param {obj} cond  the condition of the entry we are requesting.
    * @return {Promise}
    */
   staleRefresh(cond) {
      // cond should be { where:{ id: X } } format.
      var PK = this.object.PK();

      var currID = cond[PK]; // just in case we get a { id: X }
      if (cond.where) {
         currID = cond.where[PK];
      }

      return new Promise((resolve, reject) => {
         if (!currID) {
            var Err = new Error(
               "Model.staleRefresh(): could not resolve ." + PK
            );
            Err.cond = cond;
            reject(Err);
            return;
         }

         // convert to PK : Promise object:
         var entry = {
            resolve: resolve,
            reject: reject,
         };
         entry[PK] = currID;

         // queue up refresh condition
         this.staleRefreshPending.push(entry);

         // if ! staleRefreshInProcess
         if (!this.staleRefreshInProcess) {
            // set timeout to another 200ms wait after LAST staleRefresh()
            if (this.staleRefreshTimerID) {
               clearTimeout(this.staleRefreshTimerID);
            }
            this.staleRefreshTimerID = setTimeout(() => {
               this.staleRefreshProcess();
            }, 200);
         }
      });
   }

   /**
    * @method staleRefreshProcess
    * Actually process the current pending requests.
    */
   staleRefreshProcess() {
      this.staleRefreshInProcess = true;
      var currentEntries = this.staleRefreshPending;
      this.staleRefreshPending = [];
      var PK = this.object.PK();

      var responseHash = {
         /* id : [{entry}] */
      };
      var cond = { where: {} };
      cond.where[PK] = [];

      console.log(
         "Model.staleRefreshProcess(): buffered " +
            currentEntries.length +
            " requests"
      );
      currentEntries.forEach((e) => {
         responseHash[e[PK]] = responseHash[e[PK]] || [];
         responseHash[e[PK]].push(e);
      });

      cond.where[PK] = Object.keys(responseHash);

      this.findAll(cond).then((res) => {
         // for each entry we got back
         if (Array.isArray(res.data) && res.data.length) {
            res.data.forEach((data) => {
               // find it's matching request:
               if (responseHash[data[PK]]) {
                  // respond to the pending promise
                  // and remove these entries from responseHash
                  var entries = responseHash[data[PK]];
                  entries.forEach((entry) => {
                     var resolve = entry.resolve;
                     resolve({ data: [data] });
                  });

                  delete responseHash[data[PK]];
               } else {
                  console.error(
                     "Model.staleRefreshProcess(): returned entry was not in our responseHash:",
                     data,
                     responseHash
                  );
               }
            });
         }

         // now if there are any entries left in responseHash,
         // respond with an empty entry:
         var allKeys = Object.keys(responseHash);
         if (allKeys.length > 0) {
            console.warn(
               "Model.staleRefreshProcess(): " +
                  allKeys.length +
                  " entries with no responses. "
            );
         }
         allKeys.forEach((key) => {
            var resolve = responseHash[key].resolve;
            resolve({ data: [] });
            delete responseHash[key];
         });

         // now check to see if there are any more pending requests:
         if (this.staleRefreshPending.length > 0) {
            // process them:
            this.staleRefreshProcess();
         } else {
            // mark we are no longer processing stale requests.
            this.staleRefreshInProcess = false;
         }
      });
   }

   /**
     * @method findConnected
     * return the connected data associated with an instance of this model.
     *
     * to limit the result to only a single connected column:
     *    model.findConnected( 'col1', {data})
     *    then ((data) => {
     *      // data = [{obj1}, {obj2}, ... {objN}]
     *    })
     *
     * To find >1 connected field data:
     *    model.findConnected( ['col1', 'col2'], {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     col1 : [{obj1}, {obj2}, ... {objN}],
     *      //     col2 : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })
     *
     * To find all connected field data:
     *    model.findConnected( {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     connectedColName1 : [{obj1}, {obj2}, ... {objN}],
     *      //     connectedColName2 : [{obj1}, {obj2}, ... {objN}],
     *      //    ...
     *      //     connectedColNameN : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })

     * @param {string/array} fields  [optional] an array of connected fields you want to return.
     * @param {obj} data  the current object instance (data) to lookup
     * @return {Promise}
     */
   findConnected(fields, data) {
      if (typeof data == "undefined") {
         if (!Array.isArray(fields) && typeof fields == "object") {
            data = fields;
            fields = []; // return all fields
         }
      }

      if (typeof fields == "string") {
         fields = [fields]; // convert to an array of values
      }

      return new Promise((resolve, reject) => {
         // sanity checking:
         if (!data.id) {
            // I can't find any connected items, if I can't find this one:
            resolve(null);
            return;
         }

         let cond = {};
         cond[this.object.PK()] = data.id;
         this.findAll({ where: cond, populate: true })
            .then((results) => {
               if (
                  !results.data ||
                  !Array.isArray(results.data) ||
                  results.data.length == 0
               ) {
                  resolve([]); // no data to return.
                  return;
               }

               // work with the first object.
               var myObj = results.data[0];

               // if only 1 field requested, then return that
               if (fields.length == 1) {
                  let data =
                     myObj[
                        fields[0].replace(/[^a-z0-9\.]/gi, "") + "__relation"
                     ];
                  if (!data) return resolve([]);

                  if (!Array.isArray(data)) data = [data];

                  resolve(data);
                  return;
               }

               // if no fields requested, return them all:
               if (fields.length == 0) {
                  var allFields = this.object.fields((f) => {
                     return f.settings.linkType;
                  });
                  allFields.forEach((f) => {
                     fields.push(f.columnName);
                  });
               }

               var returnData = {};
               fields.forEach((colName) => {
                  returnData[colName] =
                     myObj[colName.replace(/[^a-z0-9\.]/gi, "") + "__relation"];
               });

               resolve(returnData);
            })
            .catch((err) => {
               console.error("!!! error with findConnected() attempt:", err);
               reject(err);
            });
      });
   }

   // /**
   //  * @method loadInto
   //  * loads the current values into the provided Webix DataTable
   //  * @param {DataTable} DT  A Webix component that can dynamically load data.
   //  */
   // loadInto(DT) {

   //   // if a limit was applied, then this component should be loading dynamically
   //   if (this._limit) {

   //     DT.define('datafetch', this._limit);
   //     DT.define('datathrottle', 250);  // 250ms???

   //     // catch the event where data is requested:
   //     // here we will do our own findAll() so we can persist
   //     // the provided .where condition.

   //     // oh yeah, and make sure to remove any existing event handler when we
   //     // perform a new .loadInto()
   //     DT.___AD = DT.___AD || {};
   //     if (DT.___AD.onDataRequestEvent) {
   //       DT.detachEvent(DT.___AD.onDataRequestEvent);
   //     }
   //     DT.___AD.onDataRequestEvent = DT.attachEvent("onDataRequest", (start, count) => {

   //       var cond = {
   //         where: this._where,
   //         sort: this._sort,
   //         limit: count,
   //         skip: start
   //       }

   //       if (DT.showProgress)
   //         DT.showProgress({ type: "icon" });

   //       this.findAll(cond)
   //         .then((data) => {
   //           data.data.forEach((item) => {
   //             if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //               item.$height = parseInt(item.properties.height);
   //             } else if (parseInt(this._where.height) > 0) {
   //               item.$height = parseInt(this._where.height)
   //             }
   //           });
   //           DT.parse(data);

   //           if (DT.hideProgress)
   //             DT.hideProgress();

   //         })

   //       return false; // <-- prevent the default "onDataRequest"
   //     });

   //     DT.refresh();
   //   }

   //   // else just load it all at once:
   //   var cond = {};
   //   if (this._where) cond.where = this._where;
   //   if (this._sort) cond.sort = this._sort;
   //   if (this._limit != null) cond.limit = this._limit;
   //   if (this._skip != null) cond.skip = this._skip;

   //   if (DT.showProgress)
   //     DT.showProgress({ type: "icon" });

   //   this.findAll(cond)
   //     .then((data) => {
   //       data.data.forEach((item) => {
   //         if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //           item.$height = parseInt(item.properties.height);
   //         } else if (parseInt(this._where.height) > 0) {
   //           item.$height = parseInt(this._where.height)
   //         }
   //       });
   //       DT.parse(data);

   //       if (DT.hideProgress)
   //         DT.hideProgress();

   //     })
   //     .catch((err) => {
   //       console.error('!!!!!', err);
   //     })

   // }

   // /**
   //  * @method limit
   //  * set the limit value for this set of data
   //  * @param {integer} limit  the number or elements to return in this call
   //  * @return {ABModel} this object that is chainable.
   //  */
   // limit(limit) {
   //   this._limit = limit;
   //   return this;
   // }

   // /**
   //  * @method skip
   //  * set the skip value for this set of data
   //  * @param {integer} skip  the number or elements to skip
   //  * @return {ABModel} this object that is chainable.
   //  */
   // skip(skip) {
   //   this._skip = skip;
   //   return this;
   // }

   //   /**
   //    * @method update
   //    * update model values on the server.
   //    */
   //   update(id, values) {

   //     this.prepareMultilingualData(values);

   //     // remove empty properties
   //     for (var key in values) {
   //       if (values[key] == null)
   //         delete values[key];
   //     }

   //     var params = {
   //       url: this.object.urlRestItem(id),
   //       params: values
   //     }
   //     return this.request('put', params)
   //       .then((data) => {

   //         // .data is an empty object ??

   //         this.normalizeData(data);

   //         return data;

   //         // FIX: now with sockets, the triggers are fired from socket updates.
   //         // trigger a update event
   //         // triggerEvent('update', this.object, data);

   //       })
   //       .catch((err)=>{
   // console.error(err);
   //       });

   //   }

   /**
    * @method upsert
    * upsert model values on the server.
    */
   upsert(values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      var params = {
         url: this.object.urlRest(),
         params: values,
      };
      return this.request("put", params)
         .then((data) => {
            // .data is an empty object ??

            this.normalizeData(data);

            return data;

            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a update event
            // triggerEvent('update', this.object, data);
         })
         .catch((err) => {
            console.error(err);
         });
   }

   /**
    * @method where
    * set the where condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   where(cond) {
      this._where = cond;
      return this;
   }

   /**
    * @method where
    * set the sort condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   sort(cond) {
      this._sort = cond;
      return this;
   }

   /**
    * @method refresh
    * refresh model definition on the server.
    */
   refresh() {
      console.error("!!! Depreciated: where is this being called from?");
      return Promise.resolve();

      // var params = {
      //    url: this.object.urlRestRefresh(),
      // };
      // return this.request("put", params);
   }

   normalizeData(data) {
      // convert to array
      if (!(data instanceof Array)) data = [data];

      // find all connected fields
      var connectedFields = this.object.connectFields();

      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();

      // if this object has some date fields, convert the data to date object:
      var dateFields =
         this.object.fields(function (f) {
            return f.key == "date" || f.key == "datetime";
         }) || [];

      // calculate fields
      var calculatedFields = this.object.fields((f) => f.key == "calculate");

      data.forEach((d) => {
         if (d == null) return;

         // various PK name
         if (!d.id && this.object.PK() != "id") d.id = d[this.object.PK()];

         // loop through data's connected fields
         connectedFields.forEach((c) => {
            // get the relation name so we can change the original object
            var relationName = c.relationName();

            // if (d[c.columnName] == null)
            //  d[c.columnName] = '';

            // if there is no data we can exit now
            if (d[relationName] == null) return;

            // if relation data is still a string and isn't empty
            if (
               typeof d[relationName] == "string" &&
               d[relationName].length > 0
            ) {
               // parse the string into an object
               d[relationName] = JSON.parse(d[relationName]);
            }

            // if the data is an array we need to loop through it
            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((r) => {
                  // if translations are present and they are still a string
                  if (r.translations && typeof r.translations == "string") {
                     // parse the string into an object
                     r.translations = JSON.parse(r.translations);
                  }
               });
               // if the data is not an array it is a single item...check that has translations and it is a string
            } else if (
               d[relationName].translations &&
               typeof d[relationName].translations == "string"
            ) {
               // if so parse the string into an object
               d[relationName].translations = JSON.parse(
                  d[relationName].translations
               );
            }

            // set .id to relation columns
            let objectLink = c.datasourceLink;
            let olPK = objectLink.PK();
            var relatedMlFields = objectLink.multilingualFields();

            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((subData) => {
                  // update .id values
                  // if (olPK != "id" && subData[olPK]) subData.id = subData[olPK];
                  const relationValue = c.getRelationValue(subData);
                  if (olPK != "id") subData.id = relationValue;

                  // perform Translation
                  if (relatedMlFields.length) {
                     objectLink.translate(subData, subData, relatedMlFields);
                  }
               });
            } else {
               // update .id value
               // if (d[relationName][olPK]) {
               //    d[relationName].id = d[relationName][olPK];
               // }
               const relationValue = c.getRelationValue(d[relationName]);
               if (relationValue) {
                  d[relationName].id = relationValue;
               }

               // perform Translation
               if (relatedMlFields.length) {
                  objectLink.translate(
                     d[relationName],
                     d[relationName],
                     relatedMlFields
                  );
               }
            }

            // if (
            //    objectLink &&
            //    olPK != "id" &&
            //    d[relationName] &&
            //    !d[relationName].id
            // ) {
            //    // is array
            //    if (d[relationName].forEach) {
            //       d[relationName].forEach((subData) => {
            //          if (subData[olPK]) subData.id = subData[olPK];
            //       });
            //    } else if (d[relationName][olPK]) {
            //       d[relationName].id = d[relationName][olPK];
            //    }
            // }

            // if (relatedMlFields.length) {
            //    d[relationName];
            //    objectLink.translate(
            //       d[relationName],
            //       d[relationName],
            //       relatedMlFields
            //    );
            // }

            // Change property name of connected field
            if (!d[c.columnName]) {
               if (c.linkType() == "one") {
                  if (d[relationName]) {
                     // d[c.columnName] = d[relationName][olPK];
                     d[c.columnName] = c.getRelationValue(d[relationName]);
                  } else {
                     d[c.columnName] = null;
                  }
               } else {
                  if (d[relationName]) {
                     if (Array.isArray(d[relationName])) {
                        try {
                           d[c.columnName] = (d[relationName] || []).map(
                              // (i) => i[olPK]
                              (i) => c.getRelationValue(i)
                           );
                        } catch (e) {
                           console.log("+++++++++++++++");
                           console.log(`ID:[${c.id}]`);
                           console.log(`ColumnName:[${c.label}]`);
                           console.log(`relationName:[${relationName}]`);
                           console.log(`linkType:[${c.linkType()}]`);
                           console.log("data:");
                           console.log(JSON.stringify(d[relationName]));
                           console.log("+++++++++++++++");
                        }
                     } else {
                        // this is strange: supposed to be "many" but coming in
                        // as "one"
                        console.log("+++++++++++++++");
                        console.log(`ID:[${c.id}]`);
                        console.log(`ColumnName:[${c.label}]`);
                        console.log(`relationName:[${relationName}]`);
                        console.log(`linkType:[${c.linkType()}]`);
                        console.log("data:");
                        console.log(JSON.stringify(d[relationName]));
                        console.log("+++++++++++++++");
                        // d[c.columnName] = [d[relationName][olPK]];
                        d[c.columnName] = [c.getRelationValue(d[relationName])];
                     }
                  } else {
                     d[c.columnName] = [];
                  }
               }
            }
         });

         if (mlFields.length) {
            this.object.translate(d, d, mlFields);
         }

         // convert the data to date object
         dateFields.forEach((date) => {
            if (d && d[date.columnName] != null) {
               // check to see if data has already been converted to a date object
               if (typeof d[date.columnName] == "string") {
                  if (date.key == "date") {
                     // if we are ignoring the time it means we ignore timezone as well
                     // so lets trim that off when creating the date so it can be a simple date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName],
                        {
                           format: "MM/DD/YYYY",
                           ignoreTime: true,
                        }
                     );
                  } else {
                     // Convert UTC to Date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName]
                     );
                     // d[date.columnName] = new Date(moment(d[date.columnName]));
                  }
               }
            }
         });

         calculatedFields.forEach((calField) => {
            d[calField.columnName] = calField.format(d);
         });
      });
   }
}


/***/ }),

/***/ 92741:
/*!************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectCore.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectCore)
/* harmony export */ });
/* harmony import */ var _platform_ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABModel */ 41637);
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/**
 * ABObjectCore
 *
 * Manage the loading of specific ABObject data into useable objects
 * that can instantiate themselves and provide field and model resources.
 */




class ABObjectCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      /*
{
	id: uuid(),
	connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
	name: 'name',
	labelFormat: 'xxxxx',
	labelSettings: Object,
	isImported: 1/0,
	isExternal: 1/0,
	tableName:'string',  // NOTE: store table name of import object to ignore async
	primaryColumnName: 'string', // NOTE: store column name of PK
	transColumnName: 'string', // NOTE: store column name of translations table
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:	 ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],
	fields:[
		{ABDataField}
   ],
   indexes: [
      {ABIndex}
   ]
}
*/

      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object. These methods are not dependent
   /// on the instance values of the Application.
   ///

   static contextKey() {
      return "object";
   }

   ///
   /// Instance Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
            name: 'name',
            labelFormat: 'xxxxx',
            labelSettings: Object,
            isImported: 1/0,
            isExternal: 1/0,
            tableName:'string',  // NOTE: store table name of import object to ignore async
            primaryColumnName: 'string', // NOTE: store column name of PK
            transColumnName: 'string', // NOTE: store column name of translations table
            urlPath:'string',
            importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
                                        // to get other object:  ABApplication.objectFromRef(obj.importFromObject);
            translations:[
                {}
            ],
            fields:[
                {ABDataField}
            ],
            indexes: [
               {ABIndex}
            ]
        }
        */

      this.id = attributes.id;
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = attributes.type || "object";
      // {string} .type
      // the type of ABDefinition this is.

      this.connName = attributes.connName || undefined; // undefined == 'appBuilder'
      // {string} .connName
      // the sails.config.connections[connName] configuration reference.
      // if not set ({undefined}), then our default "appBuilder" config is used

      this.name = attributes.name || "";
      // {string} .name
      // A name reference for this ABObject. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      this.labelFormat = attributes.labelFormat || "";
      // {string} .labelFormat
      // A string template for how to display an entry for this ABObject in
      // common UI elements like grids, lists, etc...

      this.labelSettings = attributes.labelSettings || {};
      // {Object} .labelSettings

      this.labelSettings.isNoLabelDisplay = parseInt(
         this.labelSettings.isNoLabelDisplay || 0
      );
      // {bool} .isNoLabelDisplay

      this.isImported = parseInt(attributes.isImported || 0);
      // {depreciated}
      // {bool} .isImported
      // previously used to mark ABObjects that were created in other
      // ABApplicaitons.  No longer relevant with Global ABObjects

      this.isExternal = parseInt(attributes.isExternal || 0);
      // {bool} .isExternal
      // Marks this ABObject as referencing a pre-existing table in the DB that
      // we are treating as an ABObject.
      // These objects are not allowed to create/update/destroy the db table
      // nor can we add/remove fields.
      // However we are able to customize the Field definitions to change the
      // column names, hidden attributes, Object label, etc...
      // We can update our Defintion attributes, but not any actual DB changes.

      this.tableName = attributes.tableName || ""; // NOTE: store table name of import object to ignore async
      // {string} .tableName
      // the `{database}.{tableName}` of the db table that this ABObject's data
      // is stored in.
      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.tableName = this.tableName.replace(/[^a-zA-Z0-9_ ]/gi, "");

      this.primaryColumnName = attributes.primaryColumnName || ""; // NOTE: store column name of PK
      // {string} .primaryColumnName
      // is the col_name of which key is the primary key.  By default it is
      // "uuid", but in some external objects this might be something else
      // ("id", "ren_id", etc...).

      this.transColumnName = attributes.transColumnName || ""; // NOTE: store column name of translations table
      // {string} .transColumnName
      // this is a workaround to include hris_ren_data and hris_ren_trans data

      this.urlPath = attributes.urlPath || "";

      // this.importFromObject = attributes.importFromObject || "";

      this.isSystemObject = attributes.isSystemObject;
      // {bool} .isSystemObject
      // We are now storing some of our System Required Data as ABObjects as well.
      // These Objects should not be allowed to be modified by typical AppBuilder
      // designer.  However we can enable a mode for AB Designer to then expand these
      // ABObjects, and eventually we can use the AppBuilder to Create the AppBuilder.
      if (
         typeof this.isSystemObject == "undefined" ||
         this.isSystemObject == "false"
      ) {
         this.isSystemObject = false;
      }

      this.createdInAppID = attributes.createdInAppID;
      // {string} .createdInAppID
      // the .id of the ABApplication that originally created this ABObject.

      // if attributes.objectWorkspace DOES exist, make sure it is fully
      // populated.
      if (typeof attributes.objectWorkspace != "undefined") {
         if (typeof attributes.objectWorkspace.sortFields == "undefined")
            attributes.objectWorkspace.sortFields = [];
         if (typeof attributes.objectWorkspace.filterConditions == "undefined")
            attributes.objectWorkspace.filterConditions = [];
         if (typeof attributes.objectWorkspace.frozenColumnID == "undefined")
            attributes.objectWorkspace.frozenColumnID = "";
         if (typeof attributes.objectWorkspace.hiddenFields == "undefined")
            attributes.objectWorkspace.hiddenFields = [];
      }
      this.objectWorkspace = attributes.objectWorkspace || {
         sortFields: [], // array of columns with their sort configurations
         filterConditions: [], // array of filters to apply to the data table
         frozenColumnID: "", // id of column you want to stop freezing
         hiddenFields: [], // array of [ids] to add hidden:true to
      };
      // {obj} .objectWorkspace
      // When in the ABObject editor in the AppBuilder Designer, different
      // views of the information can be created.  These views are stored here
      // and are avaiable to other users in the Designer.

      // pull in field definitions:
      var fields = [];
      this.fieldIDs = attributes.fieldIDs || [];
      // {array}  [ ABField.id, ... ]
      // this is a collection of ALL the ABFields this object references.
      // This will include ABFields that were directly created for this object
      // and will include ABFields that were imported.

      this.importedFieldIDs = attributes.importedFieldIDs || [];
      // {array} [ ABField.id, ... ]
      // this is a collection of the ABFields in our .fieldIDs that were
      // IMPORTED.

      this._unknownFieldIDs = [];
      this.fieldIDs.forEach((id) => {
         if (!id) return;

         var def = this.AB.definitionByID(id);
         if (def) {
            fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._fields = fields;

      // pull in index definitions:
      this.importIndexes(attributes.indexIDs);

      // let the MLClass now process the translations:
      super.fromValues(attributes);
   }

   /**
    * @method importIndexes
    * instantiate a set of indexes from the given ids.
    * @param {array} indexIDs The different ABDefinition IDs for each index
    *        [ "uuid11", "uuid2", ... "uuidN" ]
    */
   importIndexes(indexIDs) {
      this._unknownIndex = [];
      var indexes = [];
      (indexIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            indexes.push(this.AB.indexNew(def, this));
         } else {
            this._unknownIndex.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown index id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._indexes = indexes;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   // exportFields() {
   //     var currFields = [];
   //     this._fields.forEach((obj) => {
   //         currFields.push(obj.toObj());
   //     });
   //     return currFields;
   // }

   // /**
   //  * @method exportFields
   //  * convert our array of fields into a settings object for saving to disk.
   //  * @return {array}
   //  */
   // exportIndexes() {
   //    var currIndexes = [];
   //    this._indexes.forEach((idx) => {
   //       currIndexes.push(idx.toObj());
   //    });
   //    return currIndexes;
   // }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      // track the field .ids of our fields
      var fieldIDs = this.fields().map((f) => f.id);
      (this._unknownFieldIDs || []).forEach((id) => {
         fieldIDs.push(id);
      });
      // NOTE: we keep the ._unknownFieldIDs so a developer/builder
      // can come back and track down what happened to the missing
      // ids.

      // track the index .ids of our indexes
      var indexIDs = this.indexes().map((f) => f.id);
      (this._unknownIndex || []).forEach((id) => {
         indexIDs.push(id);
      });

      return {
         id: this.id,
         type: this.type || "object",
         connName: this.connName,
         name: this.name,
         labelFormat: this.labelFormat,
         labelSettings: this.labelSettings || {},
         isImported: this.isImported,
         isExternal: this.isExternal,
         tableName: this.tableName,
         // NOTE: store table name of import object to ignore async
         primaryColumnName: this.primaryColumnName,
         // NOTE: store column name of PK
         transColumnName: this.transColumnName,
         // NOTE: store column name of translations table
         urlPath: this.urlPath,
         // importFromObject: this.importFromObject,
         objectWorkspace: this.objectWorkspace,
         isSystemObject: this.isSystemObject,

         translations: obj.translations,
         fieldIDs: fieldIDs,
         importedFieldIDs: this.importedFieldIDs,
         indexIDs: indexIDs,
         createdInAppID: this.createdInAppID,
      };
   }

   ///
   /// Objects
   ///

   /**
    * @method objectLinks()
    *
    *  return an array of ABObject that's connected.
    *
    * @param {object} filter
    * @return {array} - An array of ABObject
    */
   objectLinks(/* filter */) {
      var connectFields = this.connectFields();

      return connectFields.map((f) => f.datasourceLink);
   }

   ///
   /// Fields
   ///

   /**
    * @method fields()
    * return an array of all the ABFields for this ABObject.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array[ABFieldxxx]}
    */
   fields(fn = () => true) {
      return this._fields.filter(fn);
   }

   /**
    * @method fieldByID()
    * return the object's field from the given {ABField.id}
    * @param {string} id
    *        the uuid of the field to return.
    * @return {ABFieldxxx}
    */
   fieldByID(id) {
      return this.fields((f) => f?.id == id)[0];
   }

   /**
    * @method connectFields()
    *
    * return an array of the ABFieldConnect that is connect object fields.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   connectFields(fn = () => true) {
      return this.fields((f) => f && f.isConnection).filter(fn);
   }

   /**
    * @method fieldImport
    * register the given ABField.id as an imported field for this ABObject.
    * The ABField definition should be available before making this call.
    * After this call, the ABField is included in the ABObject, but the ABObject
    * has NOT been saved.
    * @param {ABField} fieldID The ABDefinition.id for a field that is imported
    *        into this object.
    */
   fieldImport(id) {
      if (!id) return;

      if (this.importedFieldIDs.indexOf(id) == -1) {
         this.importedFieldIDs.push(id);
      }

      // just to be safe:
      var isThere = this._fields.find((f) => f.id == id);
      if (!isThere) {
         var def = this.AB.definitionByID(id);
         if (def) {
            this._fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs = this._unknownFieldIDs || [];
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is importing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      }
   }

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @return {ABField}
    */
   fieldNew(values) {
      return this.AB.fieldNew(values, this);
   }

   /**
    * @method fieldRemove()
    *
    * remove the given ABField from our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldRemove(field) {
      var origLen = this._fields.length;
      this._fields = this.fields(function (o) {
         return o.id != field.id;
      });

      // be sure to remove this from our imported ids if it was
      // listed there.
      this.importedFieldIDs = this.importedFieldIDs.filter(
         (fid) => fid != field.id
      );

      if (this._fields.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method fieldReorder()
    *
    * reorder the fields in our object
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldReorder(sourceId, targetId) {
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == sourceId) {
            itemMoved = this._fields[i];
            this._fields.splice(i, 1);
            oPos = i;
            break;
         }
      }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (var j = 0; j < this._fields.length; j++) {
         if (this._fields[j].columnName == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) {
               j++;
            }
            this._fields.splice(j, 0, itemMoved);
            break;
         }
      }

      return this.save();
   }

   /**
    * @method fieldSave()
    *
    * save the given ABField in our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldSave(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         this._fields.push(field);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method fieldAdd()
    *
    * save the given ABField in our ._fields array and persist the current
    * values if they changed.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldAdd(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._fields.push(field);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method imageFields()
    *
    * return an array of the ABFieldImage fields this object has.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   imageFields(fn = () => true) {
      return this.fields((f) => f && f.key == "image").filter(fn);
   }

   /**
    * @method multilingualFields()
    *
    * return an array of columnnames that are multilingual.
    *
    * @return {array}
    */
   multilingualFields() {
      return this.fields((f) => f && f.isMultilingual).map((f) => f.columnName);
   }

   /**
    * @method indexes()
    *
    * return an array of all the ABIndex for this ABObject.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   indexes(filter = () => true) {
      return this._indexes.filter(filter);
   }

   /**
    * @method indexByID()
    * return the object's index from the given {ABIndex.id}
    * @param {string} id
    *        the id of the ABIndex to return.
    * @return {ABIndex}
    */
   indexByID(id) {
      return this.indexes((f) => f.id == id)[0];
   }

   /**
    * @method indexRemove()
    * remove the given ABIndex from our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexRemove(index) {
      var origLen = this._indexes.length;
      this._indexes = this.indexes(function (idx) {
         return idx.id != index.id;
      });

      // persist our changes if something changed.
      if (origLen != this._indexes.length) {
         return this.save();
      }

      // nothing was removed, so continue on.
      return Promise.resolve();
   }

   /**
    * @method indexSave()
    * save the given ABIndex in our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexSave(index) {
      var isIncluded = this.indexByID(index.id);
      if (!isIncluded) {
         this._indexes.push(index);
         return this.save();
      }

      return Promise.resolve();
   }

   ///
   /// Working with data from server
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObject.
    */
   model() {
      var model = new _platform_ABModel__WEBPACK_IMPORTED_MODULE_0__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(ABObjectCore.contextKey());
      model.contextValues({ id: this.id });

      return model;
   }

   ///
   /// URL
   ///

   /**
    * @method urlRest
    * return the url to access the data for this object.
    * @return {string}
    */
   urlRest() {
      return `/app_builder/model/${this.id}`;
   }

   /**
    * @method urlRestBatch
    * return the url to use for batch creates for this object
    * @return {string}
    */
   urlRestBatch() {
      return `/app_builder/batch/model/${this.id}`;
   }

   /**
    * @method urlRestItem
    * return the url to access the data for an instance of this object.
    * @return {string}
    */
   urlRestItem(id) {
      return `/app_builder/model/${this.id}/${id}`;
   }

   /**
    * @method urlRestLog
    * return the url to access the logs for this ABObject.
    * @return {string}
    */
   urlRestLog() {
      return `/app_builder/object/${this.id}/track`;
   }

   /**
    * @method urlRestRefresh
    * return the url to signal a refresh for this object.
    * @return {string}
    */
   urlRestRefresh() {
      return `/app_builder/model/refreshobject/${this.id}`;
   }

   /**
    * @method urlCount
    * return the url to count of data for this object.
    * @return {string}
    */
   urlRestCount() {
      return `/app_builder/model/count/${this.id}`;
   }

   ///
   ///	Object Workspace Settings
   ///
   get workspaceSortFields() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.sortFields;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.sortFields;
      }
   }

   set workspaceSortFields(fields) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.sortFields = fields;
      }
      // old version
      else {
         this.objectWorkspace.sortFields = fields;
      }
   }

   get workspaceFilterConditions() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.filterConditions;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.filterConditions;
      }
   }

   set workspaceFilterConditions(filterConditions) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.filterConditions = filterConditions;
      }
      // old version
      else {
         this.objectWorkspace.filterConditions = filterConditions;
      }
   }

   get workspaceFrozenColumnID() {
      return this.objectWorkspace.frozenColumnID;
   }

   set workspaceFrozenColumnID(id) {
      this.objectWorkspace.frozenColumnID = id;
   }

   get workspaceHiddenFields() {
      return this.objectWorkspace.hiddenFields || [];
   }

   set workspaceHiddenFields(fields) {
      this.objectWorkspace.hiddenFields = fields;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return this.isImported || this.isExternal;
   }

   /**
    * @method defaultValues
    * Collect a hash of key=>value pairs that represent the default values
    * from each of our fields.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   defaultValues() {
      var values = {};
      this.fields().forEach((f) => {
         f.defaultValue(values);
      });

      return values;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(/* data */) {
      // NOTE: the platform needs to define a way to verify the data
      console.warn("Platform.ABObject.isValidData() missing");
      return true;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error("Who is calling this?");

      if (this.application == null) return null;

      return this.application.urlObject(acrossApp) + this.id;
   }

   /**
    * @method urlField
    * return a string pointer to this object's fields
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlField(acrossApp) {
      console.error("Who is calling this?");

      return this.urlPointer(acrossApp) + "/_fields/";
   }

   /**
    * @method PK
    * return a string of the primary column name
    *
    * @return {string}
    */
   PK() {
      return this.primaryColumnName || "uuid";
   }

   remoteCreate(data) {
      console.log(
         "object[" + this.name + "] received a remoteCreate() with data:",
         data
      );
   }

   /**
    * @method clone
    * return a clone of ABObject
    *
    * @return {ABObjectBase}
    */
   clone() {
      // ignore properties who're spend much performance
      // NOTE: do not clone them. Just copy reference
      let ignoreProps = ["application", "_fields"];

      let cloneOne = JSON.parse(JSON.stringify(this));

      ignoreProps.forEach((prop) => {
         cloneOne[prop] = this[prop];
      });

      return cloneOne;
   }

   /**
    * @method minRelationData()
    * return an array of ABField.columnNames that make up
    * the minimum fields required to display this objects __RELATION
    * data in our UI widgets.
    */
   minRelationData() {
      var fields = [this.PK()];

      if (this.multilingualFields().length > 0) {
         fields.push("translations");
      }

      var labelData = this.labelFormat || "";

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            fields.push(field.columnName);
         });
      }

      // System requires to include number field values
      // because they are used on Formula/Calculate fields on client side
      fields = fields.concat(
         this.fields((f) => f.key == "number").map((f) => f.columnName)
      );

      return fields;
   }

   // Display data with label format of object
   displayData(rowData) {
      let L = this.AB.Label();
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = "{" + defaultField.id + "}";
         else {
            // if label is empty, then show .id
            if (!labelData.trim()) {
               let labelSettings = this.labelSettings || {};
               if (labelSettings && labelSettings.isNoLabelDisplay) {
                  labelData = L(labelSettings.noLabelText || "[No Label]");
               } else {
                  // show id of row
                  labelData = `${
                     this.AB.rules.isUUID(rowData.id) ? "ID: " : ""
                  }${rowData.id}`;
               }
            }
         }
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.rules.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }
}


/***/ }),

/***/ 20391:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABObjectQueryCore.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectQueryCore)
/* harmony export */ });
/* harmony import */ var _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABObject */ 83311);
/* harmony import */ var _platform_ABModelQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/ABModelQuery */ 56972);
//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//




class ABObjectQueryCore extends _platform_ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      /*
{
	id: uuid(),
	name: 'name',
	labelFormat: 'xxxxx',
	isImported: 1/0,
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],



	// ABOBjectQuery Specific Changes
	// we store a list of fields by their urls:
	fields:[
		{
			alias: "",
			fieldURL:'#/url/to/field',
		}
	],


	// we store a list of joins:
	joins:{
		alias: "",							// the alias name of table - use in SQL command
		objectURL:"#/...",					// the base object of the join
		links: [
			{
				alias: "",							// the alias name of table - use in SQL command
				fieldID: "uuid",					// the connection field of the object we are joining with.
				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
				links: [
					...
				]
			}
		]

	},


	where: { QBWhere }
}
*/
      this.isQuery = true;
      // {bool}
      // a property to mark the difference between an ABObject and ABObjectQuery.

      this.__missingObject = this.__missingObject ?? [];
      // {array} fieldInfo
      // the field info that defined an object we can't find.

      this.__missingFields = this.__missingFields ?? [];
      // {array} [ { objID, fieldID }, ... ]
      // a list of field definitions that we are unable to resolve.

      this.__cantFilter = [];
      // {array} [ {field, fieldInfo}, ... ]
      // a list of field that were assigned but can't be used for filtering.

      this.__duplicateFields = [];
      // {array} [ {fieldInfo}, ... ]
      // a list of duplicate field definitions.

      this.__linkProblems = [];
      // {array} [ { message, data }, ...]
      // a list of warning messages related to link objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * contextKey()
    * returns a unique key that represents a query in
    * our networking job resolutions.
    * @return {string}
    */
   static contextKey() {
      return "query";
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.type = "query";

      // populate connection objects
      // this._objects = {};
      // this.obj2Alias = attributes.obj2Alias || {};

      this.alias2Obj = {}; // this gets built in the .importJoins()
      // { "alias" : object.id }
      // this is a lookup hash of a referenced alias to the Object it
      // references.

      this.objectIDs = [];
      // {array}  of ABObject.id s that are referenced by this query.
      // this is how we limit our searches on objects.
      // this gets built in the .importJoins();

      this.viewName = attributes.viewName || "";
      // {string}
      // this is the SQL tablename of where our Query will store it's
      // view data.

      // import all our ABObjects
      this.importJoins(attributes.joins || {});

      // import fields after joins are imported
      this._fields = null;
      this.importFields(attributes.fields || []);
      // {array} [ { alias, field}, {},... ]
      // an array of field definition structures that mark what fields this
      // query is interested in pulling data from.
      //    .alias : {string} matches the alias of the ABObject that the field
      //             is from
      //    .field : {ABFieldXXX} the link to the actual ABField instance

      // Import our Where condition
      this.where = attributes.where || {}; // .workspaceFilterConditions
      // Fix default where.glue value
      if (
         this.where &&
         !this.where.glue &&
         this.where.rules &&
         this.where.rules.length > 0
      )
         this.where.glue = "and";

      this._objectWorkspaceViews = attributes.objectWorkspaceViews || {};

      this.settings = this.settings || {};

      if (attributes && attributes.settings) {
         // convert from "0" => true/false
         this.settings.grouping = JSON.parse(
            attributes.settings.grouping || false
         );
         this.settings.hidePrefix = JSON.parse(
            attributes.settings.hidePrefix || false
         );
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.viewName = this.viewName;

      result.joins = this.exportJoins();
      result.fields = this.exportFields();
      result.where = this.where; // .workspaceFilterConditions

      result.settings = this.settings;

      return result;
   }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    */
   importFields(fieldSettings) {
      var newFields = [];
      (fieldSettings || []).forEach((fieldInfo) => {
         if (fieldInfo == null) return;

         // pull object by alias name
         let object = this.objectByAlias(fieldInfo.alias);

         // Pull object from .AB
         if (!object && this.AB) {
            object = this.AB.objectByID(fieldInfo.objectID);

            // keep
            if (object) {
               this._objects = this._objects || {};
               this._objects[fieldInfo.alias] = object;
            }
         }

         if (!object) {
            this.__missingObject = this.__missingObject ?? [];
            this.__missingObject.push(fieldInfo);
            return;
         }

         let field = object.fieldByID(fieldInfo.fieldID);
         if (!field) {
            this.__missingFields = this.__missingFields ?? [];
            this.__missingFields.push({
               objID: object.id,
               fieldID: fieldInfo.fieldID,
               fieldInfo,
            });
            return;
         }

         if (!this.canFilterField(field)) {
            this.__cantFilter = this.__cantFilter ?? [];
            this.__cantFilter.push({ field, fieldInfo });
         }

         // check duplicate
         let isNew =
            newFields.filter(
               (f) =>
                  f.alias == fieldInfo.alias && f.field.id == fieldInfo.fieldID
            ).length < 1;

         if (!isNew) {
            this.__duplicateFields = this.__duplicateFields ?? [];
            this.__duplicateFields.push({ fieldInfo });
         }

         // should be a field of base/join objects
         if (field && this.canFilterField(field) && isNew) {
            // add alias to field
            // create new instance of this field:
            var def = field.toObj();
            let clonedField = new field.constructor(def, field.object);

            clonedField.alias = fieldInfo.alias;

            let alias = fieldInfo.alias;
            if (Array.isArray(this.joins())) {
               // NOTE: query v1
               alias = field.object.name;
            }

            newFields.push({
               alias: alias,
               field: clonedField,
            });
         }
      });
      this._fields = newFields;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   exportFields() {
      var currFields = [];
      this._fields.forEach((fieldInfo) => {
         currFields.push({
            alias: fieldInfo.alias,
            objectID: fieldInfo.field.object.id,
            fieldID: fieldInfo.field.id,
         });
      });

      // let's persist the faulty settings so a developer or builder can
      // review and fix it by hand.
      (this.__missingObject || []).forEach((f) => {
         currFields.push(f);
      });

      (this.__cantFilter || []).forEach((f) => {
         currFields.push(f.fieldInfo);
      });

      return currFields;
   }

   /**
    * @method fields()
    *
    * Support the ABObject api by returning a list of fields relevant
    * to this ABObjectQuery.
    *
    * @return {array}
    */
   fields(fn = () => true) {
      if (!fn) fn = () => true;
      return this._fields.map((f) => f.field).filter(fn);
   }

   ///
   /// Joins & Objects
   ///

   /**
    * @method joins()
    *
    * return an object of joins for this Query.
    *
    * @return {Object}
    */
   joins() {
      return this._joins || {};
   }

   /**
    * @method objects()
    *
    * return an array of all the relevant ABObjects for this Query.
    *
    * @return {array}
    */
   objects(fn = () => true) {
      // FOR proper expected operation, this fn must only return object
      // matches for which this ABQuery is managing objects:

      return this.AB.objects((o) => this.objectIDs.indexOf(o.id) > -1).filter(
         fn
      );
   }

   /**
    * @method objectAlias()
    *
    * return alias of of ABObjects.
    *
    * @return {string}
    */
   objectAlias(objectId) {
      let result = null;

      Object.keys(this.alias2Obj || {}).forEach((alias) => {
         if (!result && this.alias2Obj[alias] == objectId) {
            result = alias;
         }
      });

      return result;
   }

   /**
    * @method objectBase
    * return the origin object
    *
    * @return {ABObject}
    */
   objectBase() {
      if (!this._joins.objectID) return null;

      return this.AB.objectByID(this._joins.objectID) || null;
   }

   /**
    * @method objectByAlias()
    * return ABObject search by alias name
    *
    * @param {string} - alias name
    * @return {ABClassObject}
    */
   objectByAlias(alias) {
      var objID = this.alias2Obj[alias];
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method objectByID()
    * return ABObject search by ID
    * @param {string} objID
    *        The requested {ABObject}.id of the object to return.
    * @return {ABObject} | null
    */
   objectByID(objID) {
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method links()
    *
    * return an array of links for this Query.
    *
    * @return {array}
    */
   links(filter = () => true) {
      return (this._links || []).filter(filter);
   }

   /**
    * @method importJoins
    * instantiate a set of joins from the given attributes.
    * Our joins contain a set of ABObject URLs that should already be created in our Application.
    * @param {Object} settings The different field urls for each field
    *					{ }
    */
   importJoins(settings) {
      // copy join settings
      this._joins = this.AB.cloneDeep(settings);

      var uniqueObjectIDs = {};
      // { obj.id : obj.id }
      // a hash of object.ids for all the relevant ABObjects necessary for this
      // ABObjectQuery

      var newLinks = [];
      // {array} of link definitions
      // build the operating values for this._links

      let storeObject = (object, alias) => {
         if (!object) return;

         // var inThere = newObjects.filter(obj => obj.id == object.id && obj.alias == alias ).length > 0;
         // if (!inThere) {
         // newObjects[alias] = object;
         // this.obj2Alias[object.id] = alias;
         this.alias2Obj[alias] = object.id;
         uniqueObjectIDs[object.id] = object.id;
         // newObjects.push({
         // 	alias: alias,
         // 	object: object
         // });
         // }
      };

      let storeLinks = (links) => {
         (links || []).forEach((link) => {
            // var inThere = newLinks.filter(l => l.fieldID == link.fieldID).length > 0;
            // if (!inThere) {
            newLinks.push(link);
            // }
         });
      };

      let processJoin = (baseObject, joins) => {
         if (!baseObject) return;

         this.__linkProblems = this.__linkProblems ?? [];

         (joins || []).forEach((link) => {
            // Convert our saved settings:
            //	{
            //		alias: "",							// the alias name of table - use in SQL command
            //		objectID: "uuid",					// id of the connection object
            //		links: [
            //			{
            //				alias: "",							// the alias name of table - use in SQL command
            //				fieldID: "uuid",					// uhe connection field of the object we are joining with.
            //				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
            //						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
            //				links: [
            //					...
            //				]
            //			}
            //		]
            //	},

            var linkField = baseObject.fieldByID(link.fieldID);
            if (!linkField) {
               this.__linkProblems.push({
                  message: `could not resolve our linkField[${link.fieldID}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            // track our linked object
            var linkObject = this.AB.objectByID(linkField.settings.linkObject);
            if (!linkObject) {
               this.__linkProblems.push({
                  message: `could not resolve our linked field -> linkObject[${linkField.settings.linkObject}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            storeObject(linkObject, link.alias);

            storeLinks(link.links);

            processJoin(linkObject, link.links);
         });
      };

      // if (!this._joins.objectURL)
      // 	// TODO: this is old query version
      // 	return;

      // store the root object
      var rootObject = this.objectBase();
      if (!rootObject) {
         // this._objects = newObjects;
         this.__linkProblems.push({
            message: "could not resolve our base object",
            data: {
               objectID: this._joins?.objectID,
            },
         });
         return;
      }

      storeObject(rootObject, "BASE_OBJECT");

      storeLinks(settings.links);

      processJoin(rootObject, settings.links);

      // this._objects = newObjects;
      this._links = newLinks;
      this.objectIDs = Object.keys(uniqueObjectIDs);
   }

   /**
    * @method exportJoins
    * save our list of objects into our format for persisting on the server
    * @param {array} settings
    */
   exportJoins() {
      return this.AB.cloneDeep(this._joins || {});
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new _platform_ABModelQuery__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @method canFilterObject
    * evaluate the provided object to see if it can directly be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterObject(object) {
      if (!object) return false;

      // I can filter this object if it is one of the objects in my joins
      return (
         this.objects((obj) => {
            return obj.id == object.id;
         }).length > 0
      );
   }

   /**
    * @method canFilterField
    * evaluate the provided field to see if it can be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterField(field) {
      if (!field) return false;

      // I can filter a field if it's object OR the object it links to can be filtered:
      let object = field.object;
      // Transition:
      // let linkedObject = this.objects(
      //    (obj) => obj.id == field.settings.linkObject
      // )[0];
      var linkedObject = field.datasourceLink;

      return this.canFilterObject(object) || this.canFilterObject(linkedObject);
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.AB.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error(
         "ABQueryCore.urlPointer(): Depreciated: Where is this being called?"
      );
      return this.application.urlQuery(acrossApp) + this.id;
   }

   /**
    * @method isGroup
    *
    * @return {boolean}
    */
   get isGroup() {
      return this.settings.grouping || false;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return true;
   }

   /**
    * @method isDisabled()
    * check this contains removed objects or fields
    *
    * @return {boolean}
    */
   isDisabled() {
      return this.disabled || false;
   }

   get workspaceFilterConditions() {
      let filterConditions = super.workspaceFilterConditions;
      if (
         filterConditions == null ||
         filterConditions.rules == null ||
         !filterConditions.rules.length
      ) {
         filterConditions = this.where;
      }

      return filterConditions;
   }
}


/***/ }),

/***/ 44166:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/ABProcessCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _platform_process_tasks_ABProcessTaskSubProcess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/process/tasks/ABProcessTaskSubProcess */ 75175);
// import ABApplication from "./ABApplication"



// const _concat = require("lodash/concat");
const _concat = lodash__WEBPACK_IMPORTED_MODULE_1__.concat;



class ABProcessCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["label"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      this.elements().forEach((e) => {
         e.onProcessReady();
      });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process";
      this.xmlDefinition = attributes.xmlDefinition || null;

      // this.json = attributes.json || null;
      let currElements = this._elements || {};
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         var ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this.emit(
                  "warning",
                  `P[${this.name}] is referencing an unknown process element id[${eID}]`,
                  { process: this.id, eID }
               );
            }
         }
      });

      this._connections = attributes.connections || {};

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "xmlDefinition"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      data.elementIDs = [];
      for (var e in this._elements) {
         // NOTE: when a task is initially created, it doesn't have an .id
         // so we need to reference it by it's .diagramID
         data.elementIDs.push(
            this._elements[e].id ?? this._elements[e].diagramID
         );
      }

      data.connections = this._connections;

      // data.participantIDs = [];
      // for (var p in this._participants) {
      //     data.participantIDs.push(this._participants[p].id);
      // }

      return data;
   }

   //
   // XML Model
   //

   /**
    * modelDefinition()
    * return the current xml definition for this process
    * @return {string}
    */
   modelDefinition() {
      return this.xmlDefinition;
   }

   /**
    * modelNew()
    * initialze our xml definition to a new state.
    * @return {string}
    */
   modelNew() {
      this.xmlDefinition = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="process-def-${this.id}" targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn2:process id="Process_1" isExecutable="true">
    <bpmn2:startEvent id="StartEvent_1"/>
  </bpmn2:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn2:definitions>`;

      //// TODO: create a default Start Task here??
   }

   /**
    * modelUpdate()
    * update our xml definition from the provided description.
    * @param {string} xml  bpmn2 xml definition from our modeler.
    * @return {string}
    */
   modelUpdate(xml) {
      this.xmlDefinition = xml;
   }

   //
   // Diagram Elements
   //

   /**
    * connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn = () => true) {
      var allConnections = Object.keys(this._connections).map((e) => {
         return this._connections[e];
      });

      // If parent, merge connections
      if (this.process && this.key === "SubProcess") {
         allConnections = allConnections.concat(this.process.connections());
      }

      return allConnections.filter(fn);
   }

   /**
    * connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      return this.connections((t) => {
         return t.id == dID;
      })[0];
   }

   /**
    * connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      return this.connections((c) => {
         return c.to == dID;
      });
   }

   /**
    * connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      return this.connections((c) => {
         return c.from == dID;
      });
   }

   /**
    * connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      delete this._connections[element.id];
   }

   /**
    * connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      var bo = element.businessObject;
      var from = null;
      if (bo.sourceRef) {
         from = bo.sourceRef.id;
      }

      var to = null;
      if (bo.targetRef) {
         to = bo.targetRef.id;
      }

      var connection = {
         id: element.id,
         type: element.type,
         from: from,
         to: to,
      };
      return connection;
   }

   /**
    * connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      var simpleConn = this.connectionSimplyElement(element);
      if (simpleConn.from && simpleConn.to && element.parent) {
         this._connections[simpleConn.id] = simpleConn;
      } else {
         // this connection is no longer connecting anything thing.
         // it is being removed.
         this.connectionRemove(element);
      }
   }

   /**
    * elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      var allElements = Object.keys(this._elements).map((e) => {
         return this._elements[e];
      });
      return allElements.filter(fn);
   }

   /**
    * elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      this._elements[element.id || element.diagramID] = element;
   }

   /**
    * elementByID()
    * return the {ABProcessElement} that has the given .id
    * @param {string} id
    * @return {ABProcess[OBJ]}
    */
   elementByID(id) {
      return this._elements[id] ?? null;
   }

   /**
    * elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      return this.elements((t) => {
         return t.diagramID == dID;
      })[0];
   }

   /**
    * elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      delete this._elements[def.id || def.diagramID];
   }

   /**
    * isTriggeredBy()
    * scan our tasks and see if we have a "trigger" task that responds to
    * the provided key.
    * @param {string} key the trigger key
    * @return {bool}
    */
   isTriggeredBy(key) {
      return this.taskForTriggerKey(key) != null;
   }

   /**
    * connectionNextTask()
    * return the ABProcessElement(s) that are after the given Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionNextTask(currElement) {
      var elements = [];
      var nextConnections = this.connections((c) => {
         return c.from == currElement.diagramID;
      });
      nextConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.to;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      var elements = [];
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      prevConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.from;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      // var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      // return values.length > 0
      //    ? values.length > 1
      //       ? values
      //       : values[0]
      //    : null;

      var tasksToAsk = this.allPreviousTasks(currElement)
      var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      return values.length > 0
         ? values.length > 1
            ? values
            : values[0]
         : null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      var tasksToAsk = this.allPreviousTasks(currElement);
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataFields",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * allPreviousConnections()
    * walk through the current graph and return all the previous connections
    * leading up to the given {ProcessElement}
    * @param {Connection} conn
    * @param {hash} hashConn
    *        { connection.id : connection }
    * @return {array}
    */
   allPreviousConnectionsForConnection(conn, hashConn) {
      var prevConnections = this.connections((c) => {
         return c.to == conn.from;
      });

      prevConnections.forEach((c) => {
         if (!hashConn[c.id]) {
            hashConn[c.id] = c;
            this.allPreviousConnectionsForConnection(c, hashConn);
         }
      });
   }
   allPreviousConnectionsForElement(currElement) {
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      var hashConn = {
         /* connection.id : connection */
      };
      // hashConn will contains the final collection of connections.

      prevConnections.forEach((c) => {
         hashConn[c.id] = c;
         this.allPreviousConnectionsForConnection(c, hashConn);
      });

      // TODO: detect circle backs and remove connections that
      // resolve back to currElement

      // convert our hash into an array
      return Object.keys(hashConn).map((k) => hashConn[k]);
   }

   allPreviousTasks(currElement) {
      var prevTasks = {}; /* task.id : task */
      var allPreviousConnections =
         this.allPreviousConnectionsForElement(currElement);
      var task;
      allPreviousConnections.forEach((conn) => {
         // each conn has a .to and a .from => grab both tasks
         task = this.elementForDiagramID(conn.to);
         if (task) prevTasks[task.id] = task;

         task = this.elementForDiagramID(conn.from);
         if (task) prevTasks[task.id] = task;
      });

      var tasksToAsk = Object.keys(prevTasks)
         .map((k) => prevTasks[k])
         .filter((t) => t.id != currElement.id);

      return tasksToAsk;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataObjects(currElement) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataObjects",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * taskForTriggerKey()
    * return one or more tasks that respond to the given trigger key
    * @param {string} key a trigger key
    * @return {[ABProcessTask,...]}
    */
   taskForTriggerKey(key) {
      var trigger = this.elements((t) => {
         return t.triggerKey == key;
      })[0];
      if (trigger) {
         return trigger;
      } else {
         return null;
      }
   }

   //
   // Participants
   //

   // /**
   //  * participants()
   //  * return an array of participants that match the given filter (or all tasks
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided participants
   //  *                should be returned.
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participants(fn) {
   //     if (!fn)
   //         fn = () => {
   //             return true;
   //         };
   //     var all = Object.keys(this._participants).map((p) => {
   //         return this._participants[p];
   //     });
   //     return all.filter(fn);
   // }

   // /**
   //  * participantsForDiagramID()
   //  * return the participant(s) that are tied to the given xml diagram ID.
   //  * @param {string} dID the diagram ID
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participantsForDiagramID(dID) {
   //     return this.participants((p) => {
   //         return p.diagramID == dID;
   //     });
   // }
}

var queryPreviousTasks = (
   list,
   method,
   param,
   process,
   responses,
   processedIDs
) => {
   // recursive fn() to step through our graph and compile
   // results.
   if (typeof responses == "undefined") {
      responses = [];
   }
   if (typeof processedIDs == "undefined") {
      processedIDs = [];
   }
   if (list.length == 0) {
      return responses;
   } else {
      // get next task
      const task = list.shift();

      // if we haven't already done task:
      if (processedIDs.indexOf(task.diagramID) == -1) {
         // mark this task as having been processed
         processedIDs.push(task.diagramID);

         let value = null;

         // get any field's it provides
         if (!(task instanceof _platform_process_tasks_ABProcessTaskSubProcess__WEBPACK_IMPORTED_MODULE_2__["default"]))
            value = task[method].apply(task, param);

         // value = task[method].apply(task, param);

         if (value === null) value = [];
         responses = _concat(responses, value);

         // add any previous tasks to our list
         list = _concat(list, process.connectionPreviousTask(task));
      }

      // process next Task
      return queryPreviousTasks(
         list,
         method,
         param,
         process,
         responses,
         processedIDs
      );
   }
};


/***/ }),

/***/ 53618:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/core/ABStepCore.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABStepCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABMLClass */ 46148);
// import ABApplication from "./ABApplication"



class ABStepCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(["name", "text"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "New Step";
      this.type = attributes.type || "step";
      this.text = attributes.text || "";
      this.settings = attributes.settings || {};
      this.settings.event = attributes?.settings?.event || "click";
      this.settings.el = attributes?.settings?.el || "";
      // this.xmlDefinition = attributes.xmlDefinition || null;

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // debugger;
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "settings", "type"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   // /**
   //  * steps()
   //  * return an array of steps that match the given filter (or all steps
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided element
   //  *                should be returned.
   //  * @return {[ABStep]}
   //  */
   // steps(fn = () => true) {
   //    var allSteps = Object.keys(this._steps).map((e) => {
   //       return this._steps[e];
   //    });
   //    return allSteps.filter(fn);
   // }

   // /**
   //  * stepAdd()
   //  * insert a step to be added to this hint.
   //  * @param {ABStep} element
   //  *        the full instance of an ABStep to track.
   //  */
   // stepAdd(step) {
   //    this._steps[step.id] = step;
   // }

   // /**
   //  * stepByID()
   //  * return the {ABStep} that has the given .id
   //  * @param {string} id
   //  * @return {ABStep[OBJ]}
   //  */
   // stepByID(id) {
   //    return this._step[id] ?? null;
   // }

   // /**
   //  * stepRemove()
   //  * remove a step from being displayed by this hint.
   //  * @param {obj|ABStep} def
   //  *        a definition of, or full Object instance of the ABStep
   //  *        to remove.
   //  */
   // stepRemove(def) {
   //    delete this._steps[def.id];
   // }
}


/***/ }),

/***/ 85642:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/ABViewManagerCore.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewManagerCore)
/* harmony export */ });
/*
 * ABViewManager
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

var AllViews = [
   // require("../platform/views/ABView"),
   /////
   ///// LEFT OFF HERRE:
   /////
   /// TODO: test this out:
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../platform/views/ABView */ 69459)),
   // require("../platform/views/ABViewCarousel"),
   // require("../platform/views/ABViewChart"),
   // require("../platform/views/ABViewChartArea"),
   // require("../platform/views/ABViewChartBar"),
   // require("../platform/views/ABViewChartLine"),
   // require("../platform/views/ABViewChartPie"),
   // require("../platform/views/ABViewComment"),
   // require("../platform/views/ABViewConditionalContainer"),
   // require("../platform/views/ABViewConnectDataFilter"),
   // require("../platform/views/ABViewContainer"),
   // require("../platform/views/ABViewCSVExporter"),
   // require("../platform/views/ABViewCSVImporter"),
   // require("../platform/views/ABViewDataFilter"),
   // require("../platform/views/ABViewDataview"),
   // require("../platform/views/ABViewDocxBuilder"),
   // require("../platform/views/ABViewGrid"),
   // require("../platform/views/ABViewImage"),
   // require("../platform/views/ABViewLabel"),
   // require("../platform/views/ABViewLayout"),
   // require("../platform/views/ABViewList"),
   // require("../platform/views/ABViewMenu"),
   // require("../platform/views/ABViewPage"),
   // require("../platform/views/ABViewPDFImporter"),
   // require("../platform/views/ABViewPivot"),
   // require("../platform/views/ABViewTab"),
   // require("../platform/views/ABViewText"),

   // //
   // // Special Editors
   // //
   // require("../platform/views/ABViewGantt"),
   // require("../platform/views/ABViewKanban"),
   // require("../platform/views/ABViewReportsManager"),
   // require("../platform/views/ABViewScheduler"),

   // //
   // // Detail Components
   // //
   // require("../platform/views/ABViewDetail"),
   // require("../platform/views/ABViewDetailCheckbox"),
   // require("../platform/views/ABViewDetailConnect"),
   // require("../platform/views/ABViewDetailCustom"),
   // require("../platform/views/ABViewDetailImage"),
   // // require("../platform/views/ABViewDetailSelectivity"),
   // require("../platform/views/ABViewDetailText"),
   // require("../platform/views/ABViewDetailTree"),

   // //
   // // Form Components
   // //
   // require("../platform/views/ABViewForm"),
   // require("../platform/views/ABViewFormButton"),
   // require("../platform/views/ABViewFormCheckbox"),
   // require("../platform/views/ABViewFormConnect"),
   // require("../platform/views/ABViewFormCustom"),
   // require("../platform/views/ABViewFormDatepicker"),
   // require("../platform/views/ABViewFormJson"),
   // require("../platform/views/ABViewFormNumber"),
   // require("../platform/views/ABViewFormReadonly"),
   // require("../platform/views/ABViewFormSelectMultiple"),
   // require("../platform/views/ABViewFormSelectSingle"),
   // require("../platform/views/ABViewFormTextbox"),
   // require("../platform/views/ABViewFormTree"),
];

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
AllViews.forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            console.error(
               "!! View[" +
                  values.key +
                  "] not yet defined.  Have an ABView instead:"
            );
            return new Views["view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 89391:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/core/FilterComplexCore.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilterComplexCore)
/* harmony export */ });
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);

// const ABObjectQuery = require("../platform/ABObjectQuery");

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field) {
   if (!field) return null;
   if (!field.columnName) return null;
   const columnName = field.columnName;

   let value = null;

   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName];
   } else {
      value = rowData[columnName];
   }

   if (value != null && !isNaN(value)) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (const k in rowData) {
      const key = k.split(".")[1];
      if (key && key == field.id) {
         value = rowData[k];
      }
   }

   if (
      (value == null || (typeof value == "number" && isNaN(value))) &&
      field.format
   )
      value = field.format(rowData);

   return value;
}

function getConnectFieldValue(rowData, field) {
   let connectedVal = "";

   if (rowData) {
      let relationName = field.relationName();
      if (rowData[relationName]) {
         connectedVal =
            (field.indexField
               ? rowData[relationName][field.indexField.columnName]
               : null) ?? // custom index
            (field.indexField2
               ? rowData[relationName][field.indexField2.columnName]
               : null) ?? // custom index 2
            rowData[relationName].id ??
            rowData[relationName];
      } else {
         let fieldVal = getFieldVal(rowData, field);
         if (fieldVal != null) {
            connectedVal = fieldVal;
         }
      }
   }
   return connectedVal;
}

class FilterComplexCore extends _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB) {
      idBase = idBase || "ab_filter_complex";

      if (typeof AB === "undefined") {
         console.error("FilterComplexCore(): being called without an AB!");
      }

      super(null, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.condition = {};
      // const batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      const _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options = {}) {
      this._settings = options;
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      // If conditions but no data return false
      if (condition?.rules?.length && rowData == null) return false;

      // If no conditions, then return true
      if (!condition?.rules?.length || rowData == null) return true;

      let result = condition.glue === "and" ? true : false;

      condition.rules.forEach((filter) => {
         // Nested filters
         if (filter?.rules?.length) {
            if (condition.glue === "or")
               result = result || this.isValid(rowData, filter);
            else result = result && this.isValid(rowData, filter);
            return;
         }
         // Skip incomplete filter condition
         else if (!filter.key || !filter.rule) return;

         const fieldInfo = (this._Fields || []).filter(
            (f) => f.id == filter.key || f.columnName == filter.key
         )[0];

         if (!fieldInfo) return;

         let condResult = null;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         let ruleFieldType = fieldInfo.key;

         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         let value = null;

         if (fieldInfo.relationName) {
            value = getConnectFieldValue(rowData, fieldInfo);
         } else {
            value = getFieldVal(rowData, fieldInfo);
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               if (value == null) value = "";

               condResult = this.textValid(value, filter.rule, filter.value);
               break;
            case "date":
            case "datetime":
               condResult = this.dateValid(value, filter.rule, filter.value);
               break;
            case "number":
            case "calculate":
            case "formula":
               condResult = this.numberValid(value, filter.rule, filter.value);
               break;
            case "list":
               condResult = this.listValid(value, filter.rule, filter.value);
               break;
            case "boolean":
               condResult = this.booleanValid(value, filter.rule, filter.value);
               break;
            case "user":
               condResult = this.userValid(value, filter.rule, filter.value);
               break;
            case "connectField":
            case "connectObject":
               condResult = this.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = this.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (condition.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   textValid(value, rule, compareValue) {
      let result = false;

      value = value.trim().toLowerCase();
      value = this._logic.removeHtmlTags(value); // remove html tags - rich text editor

      compareValue = compareValue.trim().toLowerCase().replace(/  +/g, " ");

      // support "john smith" => "john" OR/AND "smith"
      const compareArray = compareValue.split(" ");

      switch (rule) {
         case "contains":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value.indexOf(val) > -1;
            });
            break;
         case "not_contains":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value.indexOf(val) < 0;
            });
            break;
         case "equals":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value == val;
            });
            break;
         case "not_equal":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value != val;
            });
            break;
         case "is_empty":
            result = value == "" || value == null;
            break;
         case "is_not_empty":
            result = value != "" && value != null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   dateValid(value, rule, compareValue) {
      let result = false;

      if (!(value instanceof Date)) value = new Date(value);

      if (!(compareValue instanceof Date))
         compareValue = new Date(compareValue);

      switch (rule) {
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   numberValid(value, rule, compareValue) {
      let result = false;

      value = Number(value);
      compareValue = Number(compareValue);

      switch (rule) {
         case "equal":
         case "equals":
            result = value == compareValue;
            break;
         case "not_equal":
            result = value != compareValue;
            break;
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   listValid(value, rule, compareValue) {
      let result = false;

      // compareValue = compareValue.toLowerCase();

      if (!Array.isArray(compareValue)) compareValue = [compareValue];

      switch (rule) {
         case "equals":
            if (value) result = compareValue.indexOf(value) > -1;
            break;
         case "not_equal":
            if (value) result = compareValue.indexOf(value) < 0;
            else result = true;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   booleanValid(value, rule, compareValue) {
      let result = false;

      switch (rule) {
         case "equals":
            result = value == compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   userValid(value, rule, compareValue) {
      if (!value) return false;
      let result = false;

      // if (Array.isArray(value)) value = [value];

      switch (rule) {
         case "is_current_user":
            result = value == this.Account.username;
            break;
         case "is_not_current_user":
            result = value != this.Account.username;
            break;
         case "contain_current_user":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == this.Account.username)
                  .length > 0;
            break;
         case "not_contain_current_user":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == this.Account.username)
                  .length < 1;
            break;
         case "equals":
            result = value.indexOf(compareValue) > -1;
            break;
         case "not_equal":
            result = value.indexOf(compareValue) < 0;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   queryFieldValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      // queryId:fieldId
      const queryId = compareValue.split(":")[0],
         fieldId = compareValue.split(":")[1];

      // if no query
      const query = this.AB.queries((q) => q.id == queryId)[0];
      if (!query) return result;

      // if no field
      const field = query.fields((f) => f.id == fieldId)[0];
      if (!field) return result;

      let qIdBase = "{idBase}-query-field-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFieldFilter = new this.constructor(qIdBase, this.AB);
      inQueryFieldFilter.Account = this.Account;
      inQueryFieldFilter.fieldsLoad(query.fields());
      inQueryFieldFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query_field":
            result = inQueryFieldFilter.isValid(rowData);
            break;
         case "not_in_query_field":
            result = !inQueryFieldFilter.isValid(rowData);
            break;
      }

      return result;
   }

   inQueryValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue || !this.AB) return result;

      // if no query
      let query = this.AB.queries((q) => q.id == compareValue)[0];
      if (!query) return result;

      let qIdBase = "{idBase}-query-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFilter = new this.constructor(qIdBase, this.AB);
      inQueryFilter.Account = this.Account;
      inQueryFilter.fieldsLoad(query.fields());
      inQueryFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query":
            result = inQueryFilter.isValid(rowData);
            break;
         case "not_in_query":
            result = !inQueryFilter.isValid(rowData);
            break;
      }

      return result;
   }

   dataCollectionValid(value, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      let dc = this.AB.datacollections((d) => d.id == compareValue)[0];

      switch (rule) {
         case "in_data_collection":
            if (!dc) return false;

            result = dc.getData((d) => d.id == value.id).length > 0;
            break;
         case "not_in_data_collection":
            if (!dc) return true;

            result = dc.getData((d) => d.id == value.id).length < 1;
            break;
      }

      return result;
   }

   connectFieldValid(rowData, field, rule, compareValue) {
      let relationName = field.relationName();

      let connectedVal = "";

      if (rowData) {
         if (rowData[relationName]) {
            connectedVal = (
               (field.indexField
                  ? rowData[relationName][field.indexField.columnName]
                  : null) ?? // custom index
               (field.indexField2
                  ? rowData[relationName][field.indexField2.columnName]
                  : null) ?? // custom index 2
               rowData[relationName].id ??
               rowData[relationName]
            )
               .toString()
               .toLowerCase();
         } else {
            let fieldVal = getFieldVal(rowData, field);
            if (fieldVal != null) {
               connectedVal = fieldVal;
            }
         }
      }

      // If value will be the connected object, then pull value (string)
      if (typeof connectedVal == "object") {
         connectedVal =
            connectedVal[field.indexField.columnName] ??
            connectedVal[field.indexField2.columnName] ??
            connectedVal[field.columnName] ??
            connectedVal;
      }

      let compareValueLowercase = (compareValue || "").toLowerCase();

      switch (rule) {
         case "contains":
            return connectedVal.toString().indexOf(compareValueLowercase) > -1;
         case "not_contains":
            return connectedVal.toString().indexOf(compareValueLowercase) == -1;
         case "equals":
            return connectedVal == compareValueLowercase;
         case "not_equal":
            return connectedVal != compareValueLowercase;
         case "in_query":
         case "not_in_query":
            return this.inQueryValid(rowData[relationName], rule, compareValue);
         case "is_current_user":
         case "is_not_current_user":
         case "contain_current_user":
         case "not_contain_current_user":
            return this.userValid(connectedVal, rule, compareValue);
         case "is_empty":
            return (
               rowData[relationName] == null ||
               rowData[relationName].length < 1 ||
               rowData[relationName] == ""
            );
         case "is_not_empty":
            return (
               rowData[relationName] != null &&
               ((Array.isArray(rowData[relationName]) &&
                  rowData[relationName].length > 0) ||
                  rowData[relationName] != "")
            );
         case "in_data_collection":
         case "not_in_data_collection":
            return this.dataCollectionValid(connectedVal, rule, compareValue);
      }
   }

   thisObjectValid(rowData, rule, compareValue) {
      let result = false;
      let query = null;
      let listThisObjects = null;
      let alias = null;
      let newRowData = null;

      switch (rule) {
         // if in_query condition
         case "in_query":
         case "not_in_query":
            if (!this._Object) return result;

            // if > 1 copy of this object in query ==> Error!
            query = this.AB.queries((q) => q.id == compareValue)[0];

            if (!query) return result;

            listThisObjects = query.objects((o) => {
               return o.id == this._Object.id;
            });

            if (listThisObjects.length > 1) {
               // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
               // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
               // this object as part of the query.

               console.error(
                  "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
               );

               return true;
            }

            // get this object's alias from the query
            alias = query.objectAlias(this._Object.id);

            // make sure all my columns in rowData are prefixed by "alias".columnName
            newRowData = {};

            Object.keys(rowData).forEach((key) => {
               newRowData[`${alias}.${key}`] = rowData[key];
            });

            // then pass this on to the _logic.queryValid();
            return this.inQueryValid(newRowData, rule, compareValue);

         // if in_datacollection condition
         case "in_data_collection":
         case "not_in_data_collection":
            // send rowData, null to datacollectionValid()
            return this.dataCollectionValid(rowData, rule, compareValue);
      }
   }

   processFieldsLoad(processFields = []) {
      if (processFields && !Array.isArray(processFields)) {
         processFields = [processFields];
      }
      this._ProcessFields = processFields;

      this.uiInit();
   }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param array {ABField}
    * @param object {ABObject} [optional]
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter(
         (f) => f && f.fieldIsFilterable && f.fieldIsFilterable()
      );
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         // insert our uuid in addition to the rest of our fields
         let thisObjOption = {
            id: "this_object",
            label: object.label,
            key: "uuid",
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         // NOTE: Could not reference ABObjectQuery because recursive looping reference
         // if (object instanceof ABObjectQuery) {
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   fieldsToQB() {
      /*
      let mapTypes = {
         LongText: "string",
         email: "string",
         datetime: "date",
         connectField: "connectObject"
      };

      const fields = this._Fields.map((f) => {
         // Label
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         // Type
         let type = f.key || f.type;
         if (mapTypes[type]) type = mapTypes[type];

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return { id: f.columnName, value: label, type: type };
      });
      return fields;
      */

      let fields = (this._Fields || []).map((f) => {
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         let type = "text"; // "text", "number", "date"
         let conditions = [];
         let processFieldKeys = [];
         let hasQueryField = true;

         if (!this._settings.isProcessParticipant)
            switch (f.key) {
               case "boolean":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersBoolean(f)
                  );
                  processFieldKeys = ["boolean"];

                  break;

               case "connectObject":
                  conditions = this.fieldsAddFiltersConnectObject(f);

                  // Add filter options to Custom index
                  if (
                     f.settings.isCustomFK &&
                     // 1:M
                     ((f.settings.linkType == "one" &&
                        f.settings.linkViaType == "many") ||
                        // 1:1 isSource = true
                        (f.settings.linkType == "one" &&
                           f.settings.linkViaType == "one" &&
                           f.settings.isSource))
                  ) {
                     const stringResults = this.fieldsAddFiltersString(f);

                     conditions = stringResults.concat(conditions);
                  }

                  hasQueryField = false;
                  processFieldKeys = ["connectObject"];

                  break;

               case "date":
               case "datetime":
                  type = "date";
                  conditions = conditions.concat(this.fieldsAddFiltersDate(f));
                  processFieldKeys = ["date", "datetime"];

                  break;

               case "calculate":
               case "formula":
               case "number":
                  type = "number";
                  conditions = conditions.concat(
                     this.fieldsAddFiltersNumber(f)
                  );
                  processFieldKeys = ["calculate", "formula", "number"];

                  break;

               case "string":
               case "LongText":
               case "email":
               case "AutoIndex":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersString(f)
                  );
                  processFieldKeys = [
                     "string",
                     "LongText",
                     "email",
                     "AutoIndex",
                  ];

                  break;

               case "list":
                  conditions = conditions.concat(this.fieldsAddFiltersList(f));

                  break;

               case "user":
                  conditions = conditions.concat(this.fieldsAddFiltersUser(f));
                  processFieldKeys = ["user"];

                  break;

               case "uuid":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersThisObject(f)
                  );
                  hasQueryField = false;

                  break;
               default:
                  break;
            }
         else
            switch (f.key) {
               case "connectObject":
               case "uuid":
                  hasQueryField = false;

                  break;
            }

         conditions = conditions.concat(
            this.fieldsAddFiltersQuery(f, hasQueryField)
         );

         if (this._settings.isRecordRule) {
            conditions = conditions.concat(this.fieldsAddFiltersRecordRule(f));
         }

         let isProcessField =
            (this._ProcessFields || []).filter((processField) => {
               if (!processField) return false;

               if (processField.field) {
                  return processFieldKeys.includes(processField.field.key);
               } else if (processField.key) {
                  // uuid
                  let processFieldId = processField.key.split(".").pop();
                  return processFieldId == f.id || processFieldId == f.key;
               }
            }).length > 0;

         if (isProcessField) {
            conditions = conditions.concat(this.fieldsAddFiltersContext(f));
         }

         conditions = conditions.concat(this.fieldsAddFiltersCustom(f));

         // let type = f.id; // the default unique identifier for our filter types
         // if (f.id == "this_object") {
         //    // if this happens to be our special "this_object" field, then our
         //    // type needs to be the "uuid" type in the definition:
         //    type = f.type;
         // }

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return {
            id: f.id,
            value: label,
            type: type,
            conditions: conditions,
            // format: () => {},
         };
      });

      // !!! Process Fields of ABProcess
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L636
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L564
      // (this._ProcessFields || [])
      //    // if there is no .field, it is probably an embedded special field
      //    .filter((pField) => pField.field == null)
      //    .forEach((pField) => {
      //       // like: .uuid
      //       let key = pField.key.split(".").pop();
      //       if (key == "uuid" && this._Object) {
      //          fields.unshift({
      //             id: pField.key,
      //             value: this._Object.label,
      //             type: "text",
      //             conditions: this.fieldsAddFiltersContext(),
      //          });
      //       }
      //    });

      return fields;
   }

   fieldsAddFiltersDate(field) {
      let dateConditions = {
         less: this.labels.component.beforeCondition,
         greater: this.labels.component.afterCondition,
         less_or_equal: this.labels.component.onOrBeforeCondition,
         greater_or_equal: this.labels.component.onOrAfterCondition,
         less_current: this.labels.component.beforeCurrentCondition,
         greater_current: this.labels.component.afterCurrentCondition,
         less_or_equal_current:
            this.labels.component.onOrBeforeCurrentCondition,
         greater_or_equal_current:
            this.labels.component.onOrAfterCurrentCondition,
         last_days: this.labels.component.onLastDaysCondition,
         next_days: this.labels.component.onNextDaysCondition,
      };

      let result = [];

      for (let condKey in dateConditions) {
         result.push({
            id: condKey,
            value: dateConditions[condKey],
            batch: "datepicker",
            handler: (a, b) => this.dateValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersString(field) {
      let stringConditions = {
         contains: {
            batch: "text",
            label: this.labels.component.containsCondition,
         },
         not_contains: {
            batch: "text",
            label: this.labels.component.notContainsCondition,
         },
         equals: {
            batch: "text",
            label: this.labels.component.isCondition,
         },
         not_equal: {
            batch: "text",
            label: this.labels.component.isNotCondition,
         },
         is_empty: {
            batch: "none",
            label: this.labels.component.isEmpty,
         },
         is_not_empty: {
            batch: "none",
            label: this.labels.component.isNotEmpty,
         },
      };

      let result = [];

      for (let condKey in stringConditions) {
         result.push({
            id: condKey,
            value: stringConditions[condKey].label,
            batch: stringConditions[condKey].batch,
            handler: (a, b) => this.textValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersNumber(field) {
      let numberConditions = {
         equals: this.labels.component.equalCondition,
         not_equal: this.labels.component.notEqualCondition,
         less: this.labels.component.lessThanCondition,
         greater: this.labels.component.moreThanCondition,
         less_or_equal: this.labels.component.lessThanOrEqualCondition,
         greater_or_equal: this.labels.component.moreThanOrEqualCondition,
      };

      let result = [];

      for (let condKey in numberConditions) {
         result.push({
            id: condKey,
            value: numberConditions[condKey],
            batch: "text",
            handler: (a, b) => this.numberValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersList(field) {
      let listConditions = {
         equals: this.labels.component.equalListCondition,
         not_equal: this.labels.component.notEqualListCondition,
      };

      let result = [];

      for (let condKey in listConditions) {
         result.push({
            id: condKey,
            value: listConditions[condKey],
            batch: "list",
            handler: (a, b) => this.listValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersBoolean(field) {
      let booleanConditions = {
         equals: this.labels.component.equalListCondition,
      };

      let result = [];

      for (let condKey in booleanConditions) {
         result.push({
            id: condKey,
            value: booleanConditions[condKey],
            batch: "boolean",
            handler: (a, b) => this.booleanValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersUser(field) {
      let userConditions = {
         is_current_user: {
            batch: "none",
            label: this.labels.component.isCurrentUserCondition,
         },
         is_not_current_user: {
            batch: "none",
            label: this.labels.component.isNotCurrentUserCondition,
         },
         contain_current_user: {
            batch: "none",
            label: this.labels.component.containsCurrentUserCondition,
         },
         not_contain_current_user: {
            batch: "none",
            label: this.labels.component.notContainsCurrentUserCondition,
         },
         equals: {
            batch: "user",
            label: this.labels.component.equalListCondition,
         },
         not_equal: {
            batch: "user",
            label: this.labels.component.notEqualListCondition,
         },
      };

      let result = [];

      for (let condKey in userConditions) {
         result.push({
            id: condKey,
            value: userConditions[condKey].label,
            batch: userConditions[condKey].batch,
            handler: (a, b) => this.userValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersConnectObject(field) {
      const connectConditions = {
         same_as_user: {
            batch: "user",
            label: this.labels.component.sameAsUser,
            handler: (a, b) => this.userValid(a, "same_as_user", b),
         },
         not_same_as_user: {
            batch: "user",
            label: this.labels.component.notSameAsUser,
            handler: (a, b) => this.userValid(a, "not_same_as_user", b),
         },
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "in_data_collection", b),
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "not_in_data_collection", b),
         },
         // TODO
         // contains: this.labels.component.containsCondition,
         // not_contains: this.labels.component.notContainCondition,
         // equals: this.labels.component.isCondition,
         // not_equal: this.labels.component.isNotCondition
      };

      const result = [];

      for (let condKey in connectConditions) {
         result.push({
            id: condKey,
            value: connectConditions[condKey].label,
            batch: connectConditions[condKey].batch,
            handler: connectConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersQuery(field, hasQueryField = false) {
      const queryConditions = hasQueryField
         ? {
              in_query_field: {
                 label: this.labels.component.inQueryField,
                 batch: "queryField",
              },
              not_in_query_field: {
                 label: this.labels.component.notInQueryField,
                 batch: "queryField",
              },
           }
         : {
              in_query: {
                 label: this.labels.component.inQuery,
                 batch: "query",
              },
              not_in_query: {
                 label: this.labels.component.notInQuery,
                 batch: "query",
              },
           };

      const result = [];

      for (const condKey in queryConditions) {
         result.push({
            id: condKey,
            value: queryConditions[condKey].label,
            batch: queryConditions[condKey].batch,
            handler: (a, b) => this.queryFieldValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersThisObject(field) {
      let thisObjectConditions = {
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
         },
      };

      let result = [];

      for (let condKey in thisObjectConditions) {
         result.push({
            id: condKey,
            value: thisObjectConditions[condKey].label,
            batch: thisObjectConditions[condKey].batch,
            handler: (a, b) => this.thisObjectValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersRecordRule(field) {
      let recordRuleConditions = {
         same_as_field: this.labels.component.sameAsField,
         not_same_as_field: this.labels.component.notSameAsField,
      };

      let result = [];

      for (let condKey in recordRuleConditions) {
         result.push({
            id: condKey,
            value: recordRuleConditions[condKey],
            batch: "recordRule",
            handler: (a, b) => true, // TODO: record rule validation
         });
      }

      return result;
   }

   fieldsAddFiltersContext(field) {
      let contextConditions = {
         context_equals: {
            batch: "context",
            label: this.labels.component.equalsProcessValue,
            handler: (a, b) => a == b,
         },
         context_not_equal: {
            batch: "context",
            label: this.labels.component.notEqualsProcessValueCondition,
            handler: (a, b) => a != b,
         },
         context_in: {
            batch: "context",
            label: this.labels.component.inProcessValueCondition,
            handler: (a, b) => a.indexOf(b) > -1,
         },
         context_not_in: {
            batch: "context",
            label: this.labels.component.notInProcessValueCondition,
            handler: (a, b) => a.indexOf(b) == -1,
         },
      };

      let result = [];

      for (let condKey in contextConditions) {
         result.push({
            id: condKey,
            value: contextConditions[condKey].label,
            batch: contextConditions[condKey].batch,
            handler: contextConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersCustom(field) {
      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id || field] ?? {};
      return options.conditions ?? [];
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    *
    * return an array of all the ABObjectQuery.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   queries(filter = () => true) {
      const queryList = this._Queries ?? this.AB?.queries?.() ?? [];

      return queryList.filter((q) => filter(q));
   }

   setValue(settings) {
      this.condition = settings || {};

      this.condition.rules = this.condition.rules || [];
   }

   /**
    * @method getValue
    * return the current condition of the filter.
    * @return {JSON} -
    * {
    * 	glue: '', // 'and', 'or'
    *		rules: [
    *			{
    *				key:	'uuid',
    *				rule:	'rule',
    *				value:	'value'
    *			}
    *		]
    * }
    */
   getValue() {
      // When asked for a value before a condition is set, default the
      // unset glue to "and";
      if (typeof this.condition.glue == "undefined") {
         this.condition.glue = "and";
      }
      return this.condition;
   }

   isComplete() {
      let result = true;

      const noValueRules = [
         "is_current_user",
         "is_not_current_user",
         "contain_current_user",
         "not_contain_current_user",
         "same_as_user",
         "not_same_as_user",
      ];

      const isCompleteRules = (rules = []) => {
         if (result == false) return;

         rules.forEach((r) => {
            if (r?.rules && Array.isArray(r?.rules)) {
               isCompleteRules(r?.rules);
            } else {
               result =
                  result &&
                  r?.key != null &&
                  r?.key != "" &&
                  r?.rule != null &&
                  r?.rule != "" &&
                  ((r?.value != null && r?.value != "") ||
                     noValueRules.indexOf(r?.rule) > -1);
            }
         });
      };

      isCompleteRules(this.condition?.rules);

      return result;
   }
}


/***/ }),

/***/ 51509:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/core/RowFilterCore.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RowFilterCore)
/* harmony export */ });
/* harmony import */ var _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/ABComponent */ 64971);


/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field, returnSingular = true) {
   if (!field) return null;
   if (!field.columnName) return null;
   // if rowData is an array, then pull the first element to get value
   if (rowData && rowData[0]) rowData = rowData[0];

   let columnId = field.id;
   let columnName = field.columnName;

   let value = null;
   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName] || rowData[columnId];
   } else {
      value = rowData[columnName] || rowData[columnId];
   }

   if (value) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (var k in rowData) {
      var key = k.split(".")[1];
      if (key && (key == columnId || key == columnName)) {
         value = rowData[k];
      }
   }

   // if value is an array, filter empty item
   if (value && Array.isArray(value)) {
      value = value.filter((v) => v != null);
      if (returnSingular) value = value[0];
   }

   return value;
}

class RowFilterCore extends _platform_ABComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, AB) {
      idBase = idBase || "ab_row_filter";

      super(App, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.config_settings = {};
      // var batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         /**
          * @method getValue
          *
          * @return {JSON} -
          * {
          * 		glue: '', // 'and', 'or'
          *		rules: [
          *			{
          *				key:	'column name',
          *				rule:	'rule',
          *				value:	'value'
          *			}
          *		]
          * }
          */
         getValue: () => {
            return this.config_settings;
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },

         textValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value == null) value = "";

            value = value.toString().trim().toLowerCase();
            value = _logic.removeHtmlTags(value); // remove html tags - rich text editor

            compareValue = compareValue
               .toString()
               .trim()
               .toLowerCase()
               .replace(/  +/g, " ");

            // support "john smith" => "john" OR/AND "smith"
            var compareArray = compareValue.split(" ");

            switch (rule) {
               case "contains":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value.indexOf(val) > -1;
                  });
                  break;
               case "not_contains":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value.indexOf(val) < 0;
                  });
                  break;
               case "equals":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value == val;
                  });
                  break;
               case "not_equal":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value != val;
                  });
                  break;
               case "is_empty":
                  result = value == null || value == "";
                  break;
               case "is_not_empty":
                  result = value != null && value != "";
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         dateValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (!(value instanceof Date)) value = new Date(value);

            if (!(compareValue instanceof Date))
               compareValue = new Date(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         numberValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            value = Number(value);
            compareValue = Number(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         listValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value && value.toLowerCase) value = value.toLowerCase();

            compareValue = compareValue.toLowerCase();

            if (!Array.isArray(compareValue)) compareValue = [compareValue];

            switch (rule) {
               case "equals":
                  if (value) result = compareValue.indexOf(value) > -1;
                  break;
               case "not_equal":
                  if (value) result = compareValue.indexOf(value) < 0;
                  else result = true;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         booleanValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);

            // default value should be false
            if (value == null) value = false;

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         userValid: (rowData, field, rule, compareValue) => {
            var result = false;

            var value = getFieldVal(rowData, field);

            // if (Array.isArray(value)) value = [value];

            switch (rule) {
               case "is_current_user":
                  result = value == this.Account.username;
                  break;
               case "is_not_current_user":
                  result = value != this.Account.username;
                  break;
               case "contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length > 0;
                  break;
               case "not_contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length == 0;
                  break;
               case "equals":
                  result = value.indexOf(compareValue) > -1;
                  break;
               case "not_equal":
                  result = value.indexOf(compareValue) < 0;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         queryValid: (rowData, rule, compareValue) => {
            var result = false;

            if (!this.AB || !compareValue) return result;

            // queryId:fieldId
            var queryId = compareValue.split(":")[0],
               fieldId = compareValue.split(":")[1];

            // if no query
            var query = this.queries((q) => q.id == queryId)[0];
            if (!query) return result;

            // if no field
            var field = query.fields((f) => f.id == fieldId)[0];
            if (!field) return result;

            let qIdBase = "{idBase}-query-field-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFieldFilter = new this.constructor(this.App, qIdBase);
            inQueryFieldFilter.Account = this.Account;
            // inQueryFieldFilter.applicationLoad(this._Application);
            inQueryFieldFilter.fieldsLoad(query.fields());
            inQueryFieldFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query_field":
                  result = inQueryFieldFilter.isValid(rowData);
                  break;
               case "not_in_query_field":
                  result = !inQueryFieldFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         inQueryValid: (rowData, columnName, rule, compareValue) => {
            let result = false;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            if (!compareValue || !this.AB) return result;

            // if no query
            let query = this.queries((q) => q.id == compareValue)[0];
            if (!query) return result;

            let qIdBase = "{idBase}-query-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFilter = new this.constructor(this.App, qIdBase);
            inQueryFilter.Account = this.Account;
            // inQueryFilter.applicationLoad(this._Application);
            inQueryFilter.fieldsLoad(query.fields());
            inQueryFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query":
                  result = inQueryFilter.isValid(rowData);
                  break;
               case "not_in_query":
                  result = !inQueryFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         dataCollectionValid: (rowData, columnName, rule, compareValue) => {
            var result = false;

            if (!compareValue || !this.AB) return result;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            let dc = this.AB.datacollectionByID(compareValue);

            switch (rule) {
               case "in_data_collection":
                  if (!dc) return false;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length > 0;
                  break;
               case "not_in_data_collection":
                  if (!dc) return true;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length < 1;
                  break;
            }

            return result;
         },

         connectFieldValid: function (rowData, field, rule, compareValue) {
            let relationName = field.relationName();

            let connectedVal = "";

            if (rowData) {
               if (rowData[relationName]) {
                  connectedVal = (
                     (field.indexField
                        ? rowData[relationName][field.indexField.columnName]
                        : false) || // custom index
                     (field.indexField2
                        ? rowData[relationName][field.indexField2.columnName]
                        : false) || // custom index 2
                     rowData[relationName].id ||
                     rowData[relationName]
                  )
                     .toString()
                     .toLowerCase();
               } else {
                  let fieldVal = getFieldVal(rowData, field);
                  if (fieldVal != null) {
                     connectedVal = fieldVal;

                     // an Object to a String
                     if (typeof connectedVal == "object") {
                        connectedVal =
                           field.datasourceLink.displayData(connectedVal);
                     }
                  }
               }
            }

            let compareValueLowercase = (compareValue || "").toLowerCase();

            switch (rule) {
               case "contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) > -1
                  );
               case "not_contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) ==
                     -1
                  );
               case "equals":
                  return connectedVal == compareValueLowercase;
               case "not_equal":
                  return connectedVal != compareValueLowercase;
               case "in_query":
               case "not_in_query":
                  return _logic.inQueryValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
                  return _logic.userValid(rowData, field, rule, compareValue);
               case "is_empty":
                  return (
                     rowData[relationName] == null ||
                     rowData[relationName].length < 1 ||
                     rowData[relationName] == ""
                  );
               case "is_not_empty":
                  return (
                     rowData[relationName] != null &&
                     ((Array.isArray(rowData[relationName]) &&
                        rowData[relationName].length > 0) ||
                        rowData[relationName] != "")
                  );
               case "in_data_collection":
               case "not_in_data_collection":
                  return _logic.dataCollectionValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
            }
         },

         thisObjectValid: (rowData, rule, compareValue) => {
            let result = false;

            switch (rule) {
               // if in_query condition
               case "in_query":
               case "not_in_query":
                  if (!this.AB || !this._Object) return result;

                  // if > 1 copy of this object in query ==> Error!
                  var query = this.queries((q) => q.id == compareValue)[0];
                  if (!query) return result;

                  var listThisObjects = query.objects((o) => {
                     return o.id == this._Object.id;
                  });
                  if (listThisObjects.length > 1) {
                     // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
                     // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
                     // this object as part of the query.

                     console.error(
                        "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
                     );
                     return true;
                  }

                  // get this object's alias from the query
                  var alias = query.objectAlias(this._Object.id);

                  // make sure all my columns in rowData are prefixed by "alias".columnName
                  var newRowData = {};
                  Object.keys(rowData).forEach((key) => {
                     newRowData[`${alias}.${key}`] = rowData[key];
                  });

                  // then pass this on to the _logic.queryValid();
                  return _logic.inQueryValid(
                     newRowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */

               // if in_datacollection condition
               case "in_data_collection":
               case "not_in_data_collection":
                  // send rowData, null to datacollectionValid()
                  return _logic.dataCollectionValid(
                     rowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */
            }
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      this.getValue = _logic.getValue;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options) {
      if (options.showObjectName) {
         this._settings.showObjectName = options.showObjectName;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      var config_settings = this.config_settings;
      var _logic = this._logic;

      // If no conditions, then return true
      if (
         config_settings == null ||
         config_settings.rules == null ||
         config_settings.rules.length == 0
      )
         return true;

      if (rowData == null) return false;

      var result = config_settings.glue === "and" ? true : false;

      config_settings.rules.forEach((filter) => {
         if (!filter?.key || !filter?.rule) return;

         var fieldInfo = this._Fields.filter((f) => f.id == filter.key)[0];
         if (!fieldInfo) return;

         var condResult;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         var ruleFieldType = fieldInfo.key;
         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               condResult = _logic.textValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "date":
            case "datetime":
               condResult = _logic.dateValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "number":
            case "formula":
               condResult = _logic.numberValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "list":
               condResult = _logic.listValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "boolean":
               condResult = _logic.booleanValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "user":
               condResult = _logic.userValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "connectField":
            case "connectObject":
               condResult = _logic.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = _logic.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (config_settings.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   /**
    * @method applicationLoad
    * set application
    *
    * @param application {ABApplication}
    */
   // applicationLoad(application) {
   //    this._Application = application;
   // }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param {array} fields
    *        an array of fields used in this Query
    * @param {ABObject} object [optional]
    *        (optional) ABObject reference if this Filter should support
    *        the "this object" conditions.
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter((f) => f?.fieldIsFilterable?.());
      // NOTE: User fields are now Connections, but we want to treat them
      // differently.
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         let thisObjOption = {
            id: "this_object",
            label: object.label,
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery.
    * @param {fn} filter
    * @return {array}
    */
   queries(filter = () => true) {
      let result = [];

      if (this.AB) {
         result = result.concat(this.AB.queries(filter));
      }

      if (this._Queries) {
         result = result.concat(
            (this._Queries || []).filter(
               (q) => filter(q) && result.filter((r) => r.id == q.id).length < 1
            )
         );
      }

      return result;
   }

   setValue(settings) {
      this.config_settings = settings || {};
      this.config_settings.rules = this.config_settings.rules || [];
   }
}


/***/ }),

/***/ 30654:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobilePageCore.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobilePageCore)
/* harmony export */ });
/* harmony import */ var _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 53349);
/*
 * ABMobilePageCore
 *
 * An view that represents a "Page" on the Mobile Device.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */


// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABMobilePageDefaults = {
   key: "mobile-page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-' )
};

const ABPropertyComponentDefaults = {
   type: "page",
   // {string}
   // What type of "Page" this is: ['page', 'popup', 'reportPage']
};

class ABMobilePageCore extends _platform_mobile_ABMobileView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABMobilePageDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABMobilePage, but has
      // different implications ... so we default an ABMobilePage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABMobilePageDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABMobilePage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;
      obj.route = this.route;

      obj.myAppID = this.myAppID;

      obj.menuType = this.menuType;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.route = values.route || this.name.replaceAll(" ", "_");

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      this.menuType = values.menuType || "menu";
      // {string}  ["menu", "tab"]
      // indicates if this Page was added as a Mobile App's "menu" or "Tab"

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.AB.error(
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      // this.settings.columns = this.settings.columns || 1;
      // this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABMobilePage
            // be sure to remove any of it's ABMobilePage as well
            // This cleans out any dangling ABDefinitions

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });
   }

   /**
    * @method save()
    * persist this instance of ABMobilePage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABMobilePages for this ABMobilePage.
    *
    * @param {fn} filter		a filter fn to return a set of ABMobilePages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABMobilePages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         if (this._pages && this._pages.length > 0) {
            result = this._pages.filter(filter);

            if (result.length < 1) {
               this._pages.forEach((p) => {
                  var subPages = p.pages(filter, deep);
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
               });
            }
         }
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABMobilePage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABMobilePage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABMobilePage that is tied to this
    * ABMobilePage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABMobilePage}
    */
   pageNew(values) {
      // make sure this is an ABMobilePage description
      values.key = ABMobilePageDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABMobilePage from our ._pages array and persist the current
    * values.
    *
    * @param {ABMobilePage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages((p) => p.id != page.id);

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABMobilePageDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABMobilePage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABMobilePage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
}


/***/ }),

/***/ 69999:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/core/mobile/ABMobileViewCore.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileViewCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */



const ABMobileViewDefaults = {
   key: "mobile-view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

class ABMobileViewCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABMobileViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABMobileViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || this.viewKey(),
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         // accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || this.viewKey();
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      // this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label = this.parent.label + "." + this.defaults.key;
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   // isAccessibleForRoles(roles) {
   //    var foundRole = false;

   //    var accessibleRoles = Object.keys(this.accessLevels) || [];
   //    (roles || []).forEach((r) => {
   //       if (accessibleRoles.indexOf(r.uuid || r) > -1) {
   //          foundRole = true;
   //       }
   //    });

   //    return foundRole;
   // }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   // getUserAccess() {
   //    // by default everyone has no access
   //    var accessLevel = 0;

   //    if (this.application.isAccessManaged) {
   //       // check to see if the current users is the access manager
   //       var isAccessManager = false;
   //       // first check if manager is defined by their role
   //       if (parseInt(this.application.accessManagers.useRole) == 1) {
   //          // if so check if any of the user's role match the managers
   //          this.AB.Account.roles().forEach((role) => {
   //             if (
   //                this.application.accessManagers.role.indexOf(
   //                   role.id || role.uuid
   //                ) > -1
   //             ) {
   //                // if so set the access level to full access
   //                isAccessManager = true;
   //                accessLevel = 2;
   //             }
   //          });
   //       }
   //       // if the user isn't already set as the manager and the manager is defined by their account
   //       if (
   //          !isAccessManager &&
   //          parseInt(this.application.accessManagers.useAccount) == 1
   //       ) {
   //          // check if the user's account matches the managers
   //          if (
   //             this.application.accessManagers.account.indexOf(
   //                this.AB.Account.uuid() + ""
   //             ) > -1
   //          ) {
   //             // if so set the access level to full access
   //             isAccessManager = true;
   //             accessLevel = 2;
   //          }
   //       }

   //       // if the user is not the manager check if the page has access levels defined for roles
   //       if (
   //          this.accessLevels &&
   //          Object.keys(this.accessLevels).length > 0 &&
   //          !isAccessManager
   //       ) {
   //          // check to see if the user's roles matches one of the roles defined
   //          this.AB.Account.roles().forEach((role) => {
   //             var currentRole = this.accessLevels[role.id || role.uuid];
   //             if (currentRole && parseInt(currentRole) > accessLevel)
   //                // if the access level is higher than a previous role set to the new level
   //                accessLevel = parseInt(currentRole);
   //          });
   //       }
   //    } else {
   //       accessLevel = 2;
   //    }

   //    return accessLevel;
   // }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            ["form", "grid", "line", "area", "bar", "gantt", "kanban"].indexOf(
               this.key
            ) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               ["button", "label", "page", "tab", "viewcontainer"].indexOf(
                  this.key
               ) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `MobileView[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   // updateAccessLevels(roleId, accessLevel) {
   //    if (parseInt(accessLevel) == 0) {
   //       if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
   //    } else {
   //       this.accessLevels[roleId] = accessLevel;
   //    }

   //    return this.save(false, false);
   // }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         result = result.concat(this._views.filter(filter));

         this._views.forEach((v) => {
            var subViews = v.views(filter, deep);
            if (subViews && subViews.length > 0) {
               result = result.concat(subViews);
            }
         });
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewNew()
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   // viewDestroy(view) {
   //    console.error("DEPRECIATED: where is this called?");
   //    return this.viewRemove(view);
   // }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
}


/***/ }),

/***/ 46446:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessLaneCore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessLaneCore)
/* harmony export */ });
/* harmony import */ var _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/process/ABProcessParticipant */ 74843);
/**
 * ABProcessLane
 * manages the lanes in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */


const ABProcessLaneDefaults = {
   type: "process.lane",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key"
   // {string} .icon
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

class ABProcessLaneCore extends _platform_process_ABProcessParticipant__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessLaneDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.type = attributes.type || ABProcessLaneDefaults.type;
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   // toObj() {
   //     // default label value
   //     if (!this.label && this.name && this.name != "") {
   //         this.label = this.name;
   //     }

   //     // untranslate this object:
   //     var data = super.toObj();

   //     var fieldsToSave = [
   //         "id",
   //         "name",
   //         "type",
   //         "processID",
   //         "diagramID",
   //         "where"
   //     ];
   //     fieldsToSave.forEach((f) => {
   //         data[f] = this[f];
   //     });

   //     return data;
   // }
}


/***/ }),

/***/ 71206:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessParticipantCore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessParticipantCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system, and provide a way to lookup a SiteUser.
 */


const ABProcessParticipantDefaults = {
   type: "process.participant",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key" // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

class ABProcessParticipantCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      super(["label"], AB);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }

      this.fromValues(attributes);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessParticipantDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // These Values are needed By ABDefinition:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || ABProcessParticipantDefaults.type;
      this.key = attributes.key || ABProcessParticipantDefaults.type;

      // Process Values:
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneIDs = attributes.laneIDs || [];
      this.stashed = false;
      if (attributes.stashed && attributes.stashed != "") {
         this.stashed = attributes.stashed;
      }

      function validChecker(attribute) {
         return typeof attribute != "undefined" && attribute != null;
      }

      this.useRole = 0;
      if (validChecker(attributes.useRole)) {
         this.useRole = parseInt(attributes.useRole);
      }

      this.role = 0;
      if (validChecker(attributes.role)) {
         this.role = attributes.role;
      }

      this.useAccount = 0;
      if (validChecker(attributes.useAccount)) {
         this.useAccount = parseInt(attributes.useAccount);
      }

      this.account = 0;
      if (validChecker(attributes.account)) {
         this.account = attributes.account;
      }

      this.useField = 0;
      if (validChecker(attributes.useField)) {
         this.useField = parseInt(attributes.useField);
      }

      this.userField = [];
      if (validChecker(attributes.userField)) {
         this.userField = attributes.userField;
      }

      // depreciated
      this.fields = [];
      if (validChecker(attributes.fields)) {
         this.fields = attributes.fields;
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneIDs",
         "where",
         "useRole",
         "role",
         "useAccount",
         "account",
         "useField",
         "userField",
         "fields",
         "stashed",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * @method onProcessReady()
    * perform any tasks/checks necessary after the parent Process is
    * setup and ready.
    */
   onProcessReady() {}
}


/***/ }),

/***/ 83316:
/*!****************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/ABProcessTaskManager.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * ABProcessTaskManager
 *
 * An interface for managing the different ABProcessTasks in AppBuilder.
 *
 */

/*
 * Tasks
 * A name => ABProcessElement hash of the different ABProcessElements available.
 */
var Tasks = {};

/*
 * DEFINITIONTYPES
 * a hash of BPMN:Element.type to Default values
 * for each of our Process Objects.
 *
 * NOTE: For Tasks, the key should be target.type,
 * for Triggers or End elements, the key should be
 * the target.eventDefinitionType
 */
var DEFINITIONTYPES = {};

var AllProcessElements = [
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessEnd_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessEnd */ 76975)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessGatewayExclusive_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessGatewayExclusive */ 33401)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskEmail_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskEmail */ 21297)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskService_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskService */ 66859)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceAccountingBatchProcessing_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing */ 55048)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceAccountingFPClose_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPClose */ 29084)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceAccountingFPYearClose_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose */ 26575)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceAccountingJEArchive_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceAccountingJEArchive */ 87512)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceCalculate_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceCalculate */ 77855)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceInsertRecord_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceInsertRecord */ 22641)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceQuery_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceQuery */ 76061)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskServiceGetResetPasswordUrl_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl */ 47995)),
   await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskSubProcess */ 75175)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskUser_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUser */ 67429)),
   await Promise.all(/*! import() */[__webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABField_js"), __webpack_require__.e("src_js_AppBuilder_platform_dataFields_ABFieldList_js"), __webpack_require__.e("src_js_AppBuilder_platform_process_tasks_ABProcessTaskUserApproval_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUserApproval */ 70852)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTaskUserExternal_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTaskUserExternal */ 82659)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTrigger_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTrigger */ 50135)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTriggerLifecycle_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTriggerLifecycle */ 82712)),
   await __webpack_require__.e(/*! import() */ "src_js_AppBuilder_platform_process_tasks_ABProcessTriggerTimer_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../platform/process/tasks/ABProcessTriggerTimer */ 63807)),
];

AllProcessElements.forEach((ELEMENT) => {
   ELEMENT = ELEMENT.default;
   Tasks[ELEMENT.defaults().key] = ELEMENT;

   switch (ELEMENT.defaults().category) {
      case "start":
      case "end":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.eventDefinitionType] =
            ELEMENT.defaults();
         break;

      case "gateway":
      case "task":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.type] =
            ELEMENT.defaults();
         break;
   }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   /*
    * @function allTasks
    * return all the currently defined ABProcessTasks in an array.
    * @return [{ABProcessTask},...]
    */
   allTasks: function () {
      var tasks = [];
      for (var t in Tasks) {
         tasks.push(Tasks[t]);
      }
      return tasks;
   },

   /*
    * @function newTask
    * return an instance of an ABProcessTask based upon the values.type value.
    * @return {ABProcessTask}
    */
   newTask: function (values, process, AB) {
      if (values.key) {
         return new Tasks[values.key](values, process, AB);
      } else {
         //// TODO: what to do here?
      }
   },

   DiagramReplaceDefinitionsForType: function (type) {
      var definitions = AllProcessElements.filter((e) => {
         return e.defaults().category == type;
      }).map((e) => {
         return e.DiagramReplace();
      });
      return definitions;
   },

   StartEvents: function () {
      return this.DiagramReplaceDefinitionsForType("start");
   },

   Gateways: function () {
      return this.DiagramReplaceDefinitionsForType("gateway");
   },

   Tasks: function () {
      return this.DiagramReplaceDefinitionsForType("task");
   },

   EndEvents: function () {
      return this.DiagramReplaceDefinitionsForType("end");
   },

   definitionForElement: function (element) {
      // pull the key from the embedded .eventDefinition
      // if there is one
      var key = null;
      if (element.businessObject.eventDefinitions) {
         var def = element.businessObject.eventDefinitions[0];
         if (def) {
            key = def.$type;
         }
      }

      // if not, then just use the base .type
      if (!key) {
         key = element.type;
      }

      return DEFINITIONTYPES[key];
   },
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 72935:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessElementCore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessTaskCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/ABMLClass */ 46148);


class ABProcessTaskCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB, defaultValues) {
      super(["label"], AB);

      this.defaults = defaultValues || { key: "core", icon: "core" };
      // {obj} .defaults
      // a value hash of default values for an ABProcessTask
      // NOTE: needs to be set before .fromValues()

      this.fromValues(attributes);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }
      // {ABProcess} .process
      // The parent ABProcess this process element is a part of.

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
      this.state = null;
   }

   ///
   /// Static Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // ABDefinition Related fields:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process.task.unknown";

      // ABProcess related fields:
      this.key = attributes.key || this.defaults.key || "?key?";
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneDiagramID = attributes.laneDiagramID || "?laneID?";
      // laneDiagramID : connects to the parent object that defines any
      //      default User information for the Task.  In our case, it
      //      might be a {ABProcessParticipant} object, or a {ABProcessLane}
      //      object.  by default, a diagram's Participant obj doesn't define
      //      any lanes, and therefore can provide that info.  Once a lane
      //      is added, however, an object is assigned to it, and the
      //      Lane will provide that info.

      // initialize any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            if (typeof attributes[s] == "undefined") this[s] = null;
            else this[s] = attributes[s];
         });
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneDiagramID",
         "key",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      // save any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            data[s] = this[s];
         });
      }

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * errorConfig()
    * Respond with an error when expected configuration parameters do not
    * pull data.
    * @param {obj} instance
    *        the instance data of this task
    * @param {string} msg
    *        the display message for this error.
    * @param {array[string]} fields
    *        an array of parameter keys that should be included in the error
    *        for additional information.
    * @return {Promise.reject(error)}
    */
   errorConfig(instance, msg, fields = []) {
      this.log(instance, msg);
      var error = new Error(`${this.type}: ${msg}`);
      var info = { task: this };
      if (!Array.isArray(fields)) fields = [fields];
      fields.forEach((field) => {
         info[field] = this[field];
      });
      this.AB.notify.builder(error, info);
      return Promise.reject(error);
   }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context
    *        the context data of the process instance
    * @param {obj} defaults
    *        any values to include from our child classes
    * @param {obj} val
    *        any values to override the default state
    */
   initState(context, defaults, val) {
      defaults = defaults || {};
      if (!val) {
         val = defaults;
         defaults = {};

         // in this case, then auto initi blank instanceValues:
         if (this.defaults && this.defaults.instanceValues) {
            this.defaults.instanceValues.forEach((v) => {
               defaults[v] = null;
            });
         }
      }

      context.taskState = context.taskState || {};

      // don't overwrite your settings if they already exist:
      if (!context.taskState[this.diagramID]) {
         context.taskState[this.diagramID] = {
            initialized: true,
            status: "initialized",
         };
         for (var d in defaults) {
            context.taskState[this.diagramID][d] = defaults[d];
         }
         for (var v in val) {
            context.taskState[this.diagramID][v] = val[v];
         }
      }
   }

   /*
    * @function isEndTask
    * return true if the current type of task is an End task. False otherwise.
    * @return {bool}
    */
   isEndTask() {
      return false;
   }

   /**
    * log()
    * enter a log in the current process instance
    * @param {obj} instance  the current ABProcessInstance
    * @param {...} ...allArgs the remaining parameters sent to the log
    */
   log(instance, ...allArgs) {
      var text = `${this.diagramID} : ${
         this.name ? this.name : this.key
      } : ${allArgs.join(" ")}`;
      instance.log.push(text);
   }

   /**
    * myLane()
    * return the ABProcessParticipant | ABProcessLane element we are
    * in.
    * @return {ABProcessParticipant|ABProcessLane}
    */
   myLane() {
      return this.process.elementForDiagramID(this.laneDiagramID);
   }

   /**
    * myState()
    * return the current state values for this ABProcessTask
    * @param {obj} instance  the current ABProcessInstance
    * @return {obj}
    */
   myState(instance) {
      return instance.context.taskState[this.diagramID];
   }

   /**
    * nextTasks()
    * follow the current instance diagram and return the next task(s)
    * after this task.
    * @param {obj} instance  the current ABProcessInstance
    * @return {array}  [ABProcessTask, ...] or {null} if an error
    */
   nextTasks(instance) {
      var nextTasks = [];

      var myDiagramObj = instance.hashDiagramObjects[this.diagramID];
      if (!myDiagramObj) {
         let error = new Error(
            `Configuration Error: Did not find my definition for dID[${this.diagramID}]`
         );
         this.onError(instance, error);
         return null;
      }

      // myDiagramObj :
      // {
      //     "bpmn2:outgoing": [{"_text": "SequenceFlow_00fbxm3"} ...],
      //     "_attributes": {id: "StartEvent_1"},
      //     "_type": "start"
      // }

      // find my possible exits:
      var exitFlows = myDiagramObj["bpmn2:outgoing"];
      if (!exitFlows) {
         let error = new Error(
            `Configuration Error: Did not find any outgoing flows for dID[${this.diagramID}]`
         );
         this.AB.notify.builder(error, { task: this });
         this.onError(instance, error);
         return null;
      }

      if (!Array.isArray(exitFlows)) {
         exitFlows = [exitFlows];
      }

      var tasksFromFlow = (flow) => {
         // follow a flow and grab each of it's exit tasks
         // place them into nextTasks[];

         var flowObj = instance.hashDiagramObjects[flow["_text"]];
         if (!flowObj) return;

         var targetIDs = flowObj["_attributes"]["targetRef"];
         if (!targetIDs) return;

         if (!Array.isArray(targetIDs)) {
            targetIDs = [targetIDs];
         }

         targetIDs.forEach((tid) => {
            var targetTask = this.process.elementForDiagramID(tid);
            if (targetTask) {
               if (nextTasks) {
                  nextTasks.push(targetTask);
               }
            } else {
               var error = new Error(
                  `Configuration Error: No ProcessTask instance for diagramID[${tid}]`
               );
               this.AB.notify.builder(error, { task: this });
               this.onError(instance, error);
               nextTasks = null;
            }
         });
      };

      exitFlows.forEach((f) => {
         tasksFromFlow(f);
      });

      return nextTasks;
   }

   /**
    * onError()
    * perform the following actions (log it) on an error.
    * @param {obj} instance  the current ABProcessInstance
    * @param {Error} error
    */
   onError(instance, error) {
      if (error) {
         var text = `${error.toString()}`;
         this.log(instance, text);
      }
      var myState = this.myState(instance);
      myState.status = "error";
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return null;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      return null;
   }

   /**
    * hashProcessDataValues()
    * return a hash of live Process Data Values
    * @param {obj} instance
    * @return {array} | null
    */
   hashProcessDataValues(instance) {
      var listDataFields = this.process.processDataFields(this);
      var currentProcessValues = {};
      listDataFields.forEach((f) => {
         currentProcessValues[f.key] = this.process.processData(this, [
            instance,
            f.key,
         ]);
      });
      return currentProcessValues;
   }

   /**
    * reset()
    * prepare this task to run again if it was already completed.
    *
    * This might happen in a process where a loop is formed and tasks
    * are repeated until a certain outcome.
    *
    * @param {obj} instance  the current ABProcessInstance
    */
   reset(instance) {
      // a task wants to run me.  Possibly again.
      var myState = this.myState(instance);

      // if I haven't setup my state (why?) then just
      // do that again:
      if (!myState) {
         this.initState(instance.context);
      } else {
         // if I have already "completed" and we are being
         // asked to run again (it's possible)
         if (myState.status == "completed" || myState.status == "error") {
            // remove my current state
            delete instance.context.taskState[this.diagramID];

            // store a new state in the context
            this.initState(instance.context);

            // remember our previous state
            var newState = this.myState(instance);
            newState._prevState = myState;
            this.log(instance, " Reset() called. Running again. ");
         }
      }
   }

   /**
    * stateCompleted()
    * mark this task has having completed.
    * @param {obj} instance  the current ABProcessInstance
    */
   stateCompleted(instance) {
      var myState = this.myState(instance);
      myState.status = "completed";
   }

   /**
    * stateUpdate()
    * update my state values with the given values data
    * @param {obj} instance  the current ABProcessInstance
    * @param {obj} values    the new state values
    */
   stateUpdate(instance, values) {
      values = values || {};
      var myState = this.myState(instance);
      for (var v in values) {
         myState[v] = values[v];
      }
   }

   /**
    * wantToDoSomething()
    * determine if this task still has something to do.
    * @param {obj} instance  the instance data of the process we are working on
    * @return {bool} true if there is still pending actions
    */
   wantToDoSomething(instance) {
      var state = this.myState(instance);
      if (state) {
         return state.status != "completed" && state.status != "error";
      } else {
         // my state wasn't defined?
         console.warn(
            "ABProcessTaskCore:wantToDoSomething(): called without having initialized our state first.",
            instance
         );
         // initialize our state and try again
         this.initState(instance.context);
         return this.wantToDoSomething(instance);
      }
   }

   /**
    * @method onProcessReady()
    * Perform any setup actions after the parent process has indicated it is "ready"
    */
   onProcessReady() {}

   get startElements() {
      let startElems =
         this.process.elements(
            (elem) =>
               elem && elem.defaults && elem.defaults.category === "start"
         ) || [];
      return startElems;
   }

   get previousElements() {
      return this.process.connectionPreviousTask(this);
   }

   get objectOfStartElement() {
      const startElem = this.startElements[0];
      if (!startElem) return null;

      return this.AB.objectByID(startElem.objectID);
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElements[0];
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }
}


/***/ }),

/***/ 76987:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/core/process/tasks/ABProcessTaskSubProcessCore.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubProcessCore)
/* harmony export */ });
/* harmony import */ var _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 50138);


let SubProcessDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "object-group", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "SubProcess",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "isEnable",
      "parameterId",
      "connectionAttrs",
      "elementIDs",
      "loopType",
   ],
};

const NOSPAM = {
   /*message : bool */
};
// prevent sending the same message over and over.

class SubProcessCore extends _platform_process_tasks_ABProcessElement_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.subProcess";
      super(attributes, process, AB, SubProcessDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return SubProcessDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "Sub Process",
         actionName: "replace-with-subprocess",
         className: "bpmn-icon-subprocess-expanded",
         target: {
            type: "bpmn:SubProcess",
            isExpanded: true,
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Convert string to boolean
      this.isEnable = this.isEnable == null ? true : JSON.parse(this.isEnable);

      let currElements = this._elements || {};
      this._unknownElementIDs = [];
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         let ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this._unknownElementIDs.push(eID);
            }
         }
      });

      this._unknownElementIDs.forEach((eID) => {
         let key = `Process[${this.processID}] Task[${this.label}] is referencing an unknown element id:[${eID}]`;
         if (!NOSPAM[key]) {
            let err = new Error(key);
            this.AB.notify.builder(err, { processTask: this.id, eID });
            NOSPAM[key] = true;
         }
      });

      this._connections = attributes.connectionAttrs || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let data = super.toObj();

      data.elementIDs = [];
      for (let e in this._elements) {
         data.elementIDs.push(this._elements[e].id);
      }

      data.connectionAttrs = this._connections;

      return data;
   }

   /**
    * @method processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      if (this.parameterId == null) return [];

      // only call processDataFields once, filter it to get the different queries
      let dataFieldsAll = this.process.processDataFields(this) || [];

      // get the subtask data
      let dataFieldOpt = dataFieldsAll.filter(
         (opt) => opt.key === this.parameterId
      )[0];

      // get data from insert tasks
      let dataFieldsAllInserted = dataFieldsAll.filter(
         (opt) => (opt?.field?.key ?? opt?.field) === "InsertedRecord"
      );

      if (dataFieldOpt == null) return [];

      let result = [];

      // Connect field type
      if (
         dataFieldOpt.field &&
         dataFieldOpt.field.key == "connectObject" &&
         dataFieldOpt.field.datasourceLink &&
         dataFieldOpt.field.datasourceLink.fields
      ) {
         result.push({
            key: `${this.id}.uuid`,
            label: `${this.label}->Repeat Data.ID`,
            object: dataFieldOpt.field.datasourceLink,
         });

         dataFieldOpt.field.datasourceLink.fields().forEach((f) => {
            result.push({
               key: `${this.id}.${f.id}`,
               label: `${this.label}->Repeat Data.${f.label}`,
               field: f,
               object: f.object,
            });
         });
      }
      // Other field types
      else {
         result.push({
            key: dataFieldOpt.field
               ? `${this.id}.${dataFieldOpt.field.id}`
               : `${this.id}.subProcess`,
            label: `${this.label}->Repeat Data`,
            field: dataFieldOpt.field,
            object: dataFieldOpt.object,
         });
      }

      dataFieldsAllInserted.forEach((opt) => {
         result.push({
            key: `${opt.key || opt.id}`,
            label: `Parent Process Data->${opt.label}`,
            field: opt.field,
            object: opt.object,
         });
      });

      // Get any tasks that exist inside the subprocess
      let previousFields = this.process.processDataFields.call(
         this,
         currElement
      );
      if (previousFields && previousFields.length > 0) {
         result = result.concat(previousFields);
      }

      return result;
   }

   /**
    * @method processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      let instance = params[0];
      let key = params[1];
      let data;

      if (instance && key?.startsWith?.(this.id)) {
         let fieldId = key.split(".")[1];
         let myState = this.myState(instance);
         let stateData = myState ? myState.data : null;
         data = stateData;

         if (stateData && fieldId) {
            let dataFieldOpt = (
               this.process.processDataFields(this) || []
            ).filter((opt) => opt.key == this.parameterId)[0];

            if (dataFieldOpt?.field?.key == "connectObject") {
               if (!Array.isArray(stateData)) stateData = [stateData];

               // Extract data
               data = stateData.map((item) => {
                  if (fieldId == "uuid" || fieldId == "id") {
                     return item.uuid || item.id || item;
                  } else if (dataFieldOpt.field.datasourceLink) {
                     let returnField = dataFieldOpt.field.datasourceLink.fields(
                        (f) => f.id == fieldId
                     )[0];
                     if (returnField) return item[returnField.columnName];
                     else return item;
                  }
               });
            }
         }
      }

      // Filter none data items
      if (Array.isArray(data)) data = data.filter((d) => d != null);

      if (data == null || !data.length)
         data = this.process.processData.call(this, currElement, params);

      if (data == null || !data.length)
         data = this.process.processData(this, params);

      return data;
   }

   allPreviousTasks(...params) {
      return this.process.allPreviousTasks.call(this, ...params);
   }

   allPreviousConnectionsForElement(...params) {
      return this.process.allPreviousConnectionsForElement.call(
         this,
         ...params
      );
   }

   allPreviousConnectionsForConnection(...params) {
      return this.process.allPreviousConnectionsForConnection.call(
         this,
         ...params
      );
   }

   //
   // Diagram Elements
   //

   /**
    * @method connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn) {
      return this.process.connections.call(this, fn);
   }

   /**
    * @method connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      if (!dID) return;

      return this.process.connectionForDiagramID.call(this, dID);
   }

   /**
    * @method connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      if (!dID) return;

      return this.process.connectionsIncoming.call(this, dID);
   }

   /**
    * @method connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      if (!dID) return;

      return this.process.connectionsOutgoing.call(this, dID);
   }

   /**
    * @method connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      if (!element) return;

      this.process.connectionRemove.call(this, element);
   }

   /**
    * @method connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      if (!element) return;

      return this.process.connectionSimplyElement.call(this, element);
   }

   /**
    * @method connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      if (!element) return;

      this.process.connectionUpsert.call(this, element);
   }

   /**
    * @method connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      if (!currElement) return;

      return this.process.connectionPreviousTask.call(this, currElement);
   }

   /**
    * @method elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      return this.process.elements.call(this, fn);
   }

   /**
    * @method elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      if (!element) return;

      this.process.elementAdd.call(this, element);
   }

   /**
    * @method elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      if (!dID) return null;

      return this.process.elementForDiagramID.call(this, dID);
   }

   /**
    * @method elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      if (!def) return;

      this.process.elementRemove.call(this, def);
   }
}


/***/ }),

/***/ 93997:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewContainerCore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainerCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);
/*
 * ABViewContainerCore
 *
 * An ABViewContainerCore defines a UI display component.
 *
 * A container might have multiple columns of display info.
 *
 */



// function L(key, altText) {
// 	return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "viewcontainer", // {string} unique key for this view
   icon: "braille", // {string} fa-[icon] reference for this view
   labelKey: "Container", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columns: 1,
   gravity: 1,
   movable: true,
   removable: true,
};

class ABViewContainerCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columns = parseInt(
         this.settings.columns || ABPropertyComponentDefaults.columns
      );

      if (typeof this.settings.gravity != "undefined") {
         this.settings.gravity.map(function (gravity) {
            return parseInt(gravity);
         });
      }

      if (this.settings.removable != null) {
         this.settings.removable = JSON.parse(this.settings.removable); // convert to boolean
      } else {
         this.settings.removable = ABPropertyComponentDefaults.removable;
      }

      if (this.settings.movable != null) {
         this.settings.movable = JSON.parse(this.settings.movable); // convert to boolean
      } else {
         this.settings.movable = ABPropertyComponentDefaults.movable;
      }
   }

   viewsSortByPosition() {
      // Sort views from y, x positions
      return this.views().sort((a, b) => {
         if (a.position.y == b.position.y) return a.position.x - b.position.x;
         else return a.position.y - b.position.y;
      });
   }

   // saveReorder() {
   //    return this.application.viewReorder(this);
   // }
}


/***/ }),

/***/ 7852:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewCore.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCore)
/* harmony export */ });
/* harmony import */ var _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/ABMLClass */ 46148);
/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */



const ABViewDefaults = {
   key: "view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

class ABViewCore extends _platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // // NOTE: ensure we have a uuid() set:
      // if (!this.id) {
      //    this.id = this.application.uuid();
      // }

      // this.application.unTranslate(this, this, ["label"]);

      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || "view",
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || "view";
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label = this.parent.label + "." + this.defaults.key;
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      // convert from "0" => 0
      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      var accessibleRoles = Object.keys(this.accessLevels) || [];
      (roles || []).forEach((r) => {
         if (accessibleRoles.indexOf(r.uuid || r) > -1) {
            foundRole = true;
         }
      });

      return foundRole;
   }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   getUserAccess() {
      // by default everyone has no access
      var accessLevel = 0;

      if (this.application.isAccessManaged) {
         // check to see if the current users is the access manager
         var isAccessManager = false;
         // first check if manager is defined by their role
         if (parseInt(this.application.accessManagers.useRole) == 1) {
            // if so check if any of the user's role match the managers
            this.AB.Account.roles().forEach((role) => {
               if (
                  this.application.accessManagers.role.indexOf(
                     role.id || role.uuid
                  ) > -1
               ) {
                  // if so set the access level to full access
                  isAccessManager = true;
                  accessLevel = 2;
               }
            });
         }
         // if the user isn't already set as the manager and the manager is defined by their account
         if (
            !isAccessManager &&
            parseInt(this.application.accessManagers.useAccount) == 1
         ) {
            // check if the user's account matches the managers
            if (
               this.application.accessManagers.account.indexOf(
                  this.AB.Account.uuid() + ""
               ) > -1
            ) {
               // if so set the access level to full access
               isAccessManager = true;
               accessLevel = 2;
            }
         }

         // if the user is not the manager check if the page has access levels defined for roles
         if (
            this.accessLevels &&
            Object.keys(this.accessLevels).length > 0 &&
            !isAccessManager
         ) {
            // check to see if the user's roles matches one of the roles defined
            this.AB.Account.roles().forEach((role) => {
               var currentRole = this.accessLevels[role.id || role.uuid];
               if (currentRole && parseInt(currentRole) > accessLevel)
                  // if the access level is higher than a previous role set to the new level
                  accessLevel = parseInt(currentRole);
            });
         }
      } else {
         accessLevel = 2;
      }

      return accessLevel;
   }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlView() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   /**
    * @method urlView
    * return a string pointer to this object's views.
    * @return {string}
    */
   urlView() {
      return this.urlPointer() + "/_views/";
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            ["form", "grid", "line", "area", "bar", "gantt", "kanban"].indexOf(
               this.key
            ) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               ["button", "label", "page", "tab", "viewcontainer"].indexOf(
                  this.key
               ) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `View[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   updateAccessLevels(roleId, accessLevel) {
      if (parseInt(accessLevel) == 0) {
         if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
      } else {
         this.accessLevels[roleId] = accessLevel;
      }

      return this.save(false, false);
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         result = result.concat(this._views.filter(filter));

         this._views.forEach((v) => {
            var subViews = v.views(filter, deep);
            if (subViews && subViews.length > 0) {
               result = result.concat(subViews);
            }
         });
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewNew()
    *
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewDestroy(view) {
      console.error("DEPRECIATED: where is this called?");
      return this.viewRemove(view);
   }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
}


/***/ }),

/***/ 63255:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewDetailItemCore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDetailItemCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABViewWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 79562);


class ABViewDetailItemCore extends _platform_views_ABViewWidget__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   detailComponent() {
      let detailView = null;

      let curr = this;
      while (
         !curr.isRoot() &&
         curr.parent &&
         curr.key != "detail" &&
         curr.key != "dataview"
      ) {
         curr = curr.parent;
      }

      if (curr.key == "detail" || curr.key == "dataview") {
         detailView = curr;
      }

      return detailView;
   }

   field() {
      let detailComponent = this.detailComponent();
      if (detailComponent == null) return null;

      let datacollection = detailComponent.datacollection;
      if (datacollection == null) return null;

      let object = datacollection.datasource;
      if (object == null) return null;

      let field = object.fields((v) => v.id == this.settings.fieldId)[0];

      // set .alias to support queries that contains alias name
      // [aliasName].[columnName]
      if (field && this.settings.alias) {
         field.alias = this.settings.alias;
      }

      return field;
   }

   getCurrentData() {
      let detailCom = this.detailComponent();
      if (!detailCom) return null;

      let dv = detailCom.datacollection;
      if (!dv) return null;

      let field = this.field();
      if (!field) return null;

      let currData = dv.getCursor();
      if (currData) return currData[field.columnName];
      else return null;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }
}


/***/ }),

/***/ 95484:
/*!************************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewFormItemCore.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewFormComponentCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);


const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

class ABViewFormComponentCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      let form = this.parentFormComponent();
      if (form == null) return null;

      let datacollection = form.datacollection;
      if (datacollection == null) return null;

      return datacollection;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
}


/***/ }),

/***/ 16605:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewPageCore.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPageCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABViewContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 90669);
/*
 * ABViewPage
 *
 * An ABView that represents a "Page" in the system.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */


// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-' )
};

const ABPropertyComponentDefaults = {
   type: "page", // 'page', 'popup' or 'reportPage'
   popupWidth: 700,
   popupHeight: 450,
   pageWidth: null,
   fixedPageWidth: 0,
   pageBackground: "ab-background-default",
};

class ABViewPageCore extends _platform_views_ABViewContainer__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABViewPage, but has
      // different implications ... so we default an ABViewPage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   static getPageActionKey(view) {
      return [
         "opstools",
         "AB_" + String(view.application.name).replace(/[^a-z0-9]/gi, ""),
         String(view.name)
            .replace(/[^a-z0-9]/gi, "")
            .toLowerCase(),
         "view",
      ].join(".");
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewPage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;

      obj.myAppID = this.myAppID;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.AB.error(
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      this.settings.columns = this.settings.columns || 1;
      this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABViewPage
            // be sure to remove any of it's ABViewPages as well
            // This cleans out any dangling ABDefinitions and cleans up the
            // OpsPortal Permissions:

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });

      // return new Promise((resolve, reject) => {
      //    // verify we have been .save() before:
      //    if (this.id) {
      //       this.application
      //          .viewDestroy(this)
      //          .then(() => {
      //             // remove the page in list
      //             var parent = this.parent || this.application;
      //             var remainingPages = parent.pages((p) => {
      //                return p.id != this.id;
      //             });
      //             parent._pages = remainingPages;

      //             resolve();
      //          })
      //          .catch(reject);
      //    } else {
      //       resolve(); // nothing to do really
      //    }
      // });
   }

   /**
    * @method save()
    * persist this instance of ABViewPage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABViewPages for this ABViewPage.
    *
    * @param {fn} filter		a filter fn to return a set of ABViewPages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         if (this._pages && this._pages.length > 0) {
            result = this._pages.filter(filter);

            if (result.length < 1) {
               this._pages.forEach((p) => {
                  var subPages = p.pages(filter, deep);
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
               });
            }
         }
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABViewPage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABViewPage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABViewPage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      values.key = ABViewDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABViewPage from our ._pages array and persist the current
    * values.
    *
    * @param {ABViewPage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method urlView()
    * return the url pointer for views in this application.
    * @return {string}
    */
   urlPage() {
      return this.urlPointer() + "/_pages/";
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlPage() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABViewDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABViewPage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABViewPage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
}


/***/ }),

/***/ 82218:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/core/views/ABViewWidgetCore.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewWidgetCore)
/* harmony export */ });
/* harmony import */ var _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../platform/views/ABView */ 69459);


const ABViewDefaults = {
   key: "viewwidget", // {string} unique key for this view
   icon: "circle-o-notch ", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.widget", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columnSpan: 1,
   rowSpan: 1,
};

class ABViewWidgetCore extends _platform_views_ABView__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columnSpan = parseInt(
         this.settings.columnSpan || ABPropertyComponentDefaults.columnSpan
      );
      this.settings.rowSpan = parseInt(
         this.settings.rowSpan || ABPropertyComponentDefaults.rowSpan
      );
   }
}


/***/ }),

/***/ 10285:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABApplication.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABClassApplication)
/* harmony export */ });
/* harmony import */ var _core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABApplicationCore.js */ 71750);
/* harmony import */ var _views_ABViewPage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/ABViewPage */ 22305);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// const _ = require("lodash");

// prettier-ignore
// const ABApplicationCore = require("../core/ABApplicationCore.js");


// const ABViewPage = require("./views/ABViewPage");


// const ABViewManager = require("./ABViewManager");
// import ABViewManager from "./ABViewManager";

class ABClassApplication extends _core_ABApplicationCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // now listen for any updates to our managed objects
      this._handler_page_updated = (definition) => {
         var currPage = this._pages.find((p) => p.id === definition.id);
         if (currPage) {
            this._pages = this._pages.filter((p) => p.id != currPage.id);
            this._pages.push(currPage.refreshInstance());
         }
      };
      this._pages.forEach((p) => {
         p.on("definition.updated", this._handler_page_updated);
      });
   }

   static applications(/*fn = () => true*/) {
      console.error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      return null;
   }
   static applicationForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   static definitionForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.definitionForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   areaKey() {
      return this.AB.kebabCase(`ab-${this.name}`);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABApplication.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.applicationByID(this.id);

      // remove my listeners
      this._pages.forEach((p) => {
         p.removeListener("definition.updated", this._handler_page_updated);
      });

      return newObj;
   }

   ///
   /// Definition
   ///

   /**
    * @method _listInsert()
    * save the given entity into our desired list:
    * @param {varid} entity
    * @param {string} key
    *        the key of the list we are managing
    * @return {Promise}
    */
   async _listInsert(entity, key) {
      var isIncluded = this[key].indexOf(entity.id) != -1;
      if (!isIncluded) {
         this[key].push(entity.id);
         await this.save();
      }
   }

   async _listRemove(entity, key) {
      var begLen = this[key].length;
      this[key] = this[key].filter((id) => {
         return id != entity.id;
      });
      // if there was a change then save this.
      if (begLen != this[key].length) {
         await this.save();
      }
   }

   /**
    * @method datacollectionInsert()
    * persist the current ABDataCollection in our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionInsert(dc) {
      return this._listInsert(dc, "datacollectionIDs");
   }

   /**
    * @method datacollectionRemove()
    * remove the given ABDataCollection from our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionRemove(dc) {
      return this._listRemove(dc, "datacollectionIDs");
   }

   /**
    * @method objectInsert()
    * persist the current ABObject in our list of .objectIDs.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectInsert(object) {
      return this._listInsert(object, "objectIDs");
   }

   /**
    * @method objectRemove()
    * remove the current ABObject from our list of .objectIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectRemove(object) {
      return this._listRemove(object, "objectIDs");
   }

   /**
    * @method processInsert()
    * persist the current ABProcess in our list of .processIDs.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processInsert(process) {
      return this._listInsert(process, "processIDs");
   }

   /**
    * @method processRemove()
    * remove the current ABProcess from our list of .processIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processRemove(process) {
      return this._listRemove(process, "processIDs");
   }

   /**
    * @method queryInsert()
    * persist the current ABObjectQuery in our list of .queryIDs.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryInsert(query) {
      return this._listInsert(query, "queryIDs");
   }

   /**
    * @method queryRemove()
    * remove the current ABObjectQuery from our list of .queryIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryRemove(query) {
      return this._listRemove(query, "queryIDs");
   }

   /**
    * @method exportIDs()
    * export any relevant .ids for the necessary operation of this application.
    * @param {array} ids
    *         the array of ids to insert any relevant .ids into
    */
   exportIDs(ids) {
      // make sure we don't get into an infinite loop:
      if (ids.indexOf(this.id) > -1) return;

      ids.push(this.id);

      // start with Objects:
      this.objectsIncluded().forEach((o) => {
         o.exportIDs(ids);
      });

      // get all Hints
      this.hintsIncluded().forEach((h) => {
         h.exportIDs(ids);
      });

      // Queries
      this.queriesIncluded().forEach((q) => {
         q.exportIDs(ids);
      });

      // Datacollections
      // NOTE: currently the server doesn't make instances of DataCollections
      // so we manually parse the related info here:
      this.datacollectionIDs.forEach((dID) => {
         if (ids.indexOf(dID) > -1) return;

         var def = this.AB.definitionByID(dID);
         if (def) {
            ids.push(dID);
            if (def.settings.datasourceID) {
               var object = this.AB.objectByID(def.settings.datasourceID);
               if (object) {
                  object.exportIDs(ids);
               }
            }
         }
      });

      // Processes
      this.processes().forEach((p) => {
         p.exportIDs(ids);
      });

      // Pages
      // NOTE: currently the server doesn't make instances of ABViews
      // so we manually parse the object data here:
      var parseView = (view) => {
         if (ids.indexOf(view.id) > -1) return;
         ids.push(view.id);
         (view.pageIDs || []).forEach((pid) => {
            var pdef = this.AB.definitionByID(pid);
            if (pdef) {
               parseView(pdef);
            }
         });

         (view.viewIDs || []).forEach((vid) => {
            var vdef = this.AB.definitionByID(vid);
            if (vdef) {
               parseView(vdef);
            }
         });
      };

      var pageIDs = this._pages.map((p) => p.id);
      (pageIDs || []).forEach((pid) => {
         var pdef = this.AB.definitionByID(pid);
         if (pdef) {
            parseView(pdef);
         }
      });

      // return only unique entries:
      ids = this.AB.uniq(ids);
   }

   /**
    * @method pageNew()
    * return a new instance of an ABViewPage
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPage}
    */
   pageNew(values) {
      return new _views_ABViewPage__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }

   /**
    * @method pageInsert()
    * Insert a new ABViewPage into this Application.
    * @param {ABViewPage} page
    *        The instance of the page to save.
    * @return {Promise}
    */
   async pageInsert(page) {
      // var isIncluded = this.pageByID(page.id);
      var isIncluded = this._pages.filter((p) => p.id == page.id)[0];
      if (!isIncluded) {
         this._pages.push(page);
         // Save our own Info:
         return this.save();
      }
   }

   /**
    * @method pageRemove()
    * remove the current ABViewPage from our list of pages.
    * @param {ABViewPage} page
    * @return {Promise}
    */
   async pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
   }

   save() {
      // if someone just changed the name of our ABApplication, reflect that
      // in our Def.Name
      if (this.name != this.label) {
         this.name = this.label;
      }
      return super.save();
   }

   warningsEval() {
      super.warningsEval();

      //
      // check for valid object references:
      //
      var checks = {
         objectIDs: "object",
         queryIDs: "query",
         datacollectionIDs: "datacollection",
      };

      Object.keys(checks).forEach((k) => {
         this[k].forEach((id) => {
            var def = this.AB.definitionByID(id);
            if (!def) {
               this.warningsMessage(` is referencing a missing ${checks[k]}`, {
                  appID: this.id,
                  id,
               });
            }
         });
      });

      //
      // Make sure there is some way to access this Application:
      //
      if (this.roleAccess.length == 0 && !this.isAccessManaged) {
         this.warningsMessage(" has no Role assigned, and is unaccessible.");
      }

      // do our Role references exist?
      var allRoles = this.AB.Account.rolesAll().map((r) => r.id);
      this.roleAccess.forEach((r) => {
         if (allRoles.indexOf(r) == -1) {
            this.warningsMessage(
               `Specified Role Access [${r}] does not exist in this system`,
               { role: r }
            );
         }
      });

      // Make sure all our Pages perform a new warningsEval();
      this.pages().forEach((p) => {
         p.warningsEval();
      });
   }

   warningsAll() {
      var warnings = [].concat(this._warnings);
      [
         "objectsIncluded",
         "queriesIncluded",
         "datacollectionsIncluded",
         "processes",
         "pages",
         "views",
      ].forEach((k) => {
         this[k]().forEach((o) => {
            warnings = warnings.concat(o.warningsAll());
         });
      });

      return warnings;
   }

   warningsMessage(msg, data = {}) {
      let message = `Application[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   /**
    * @method mobileAppNew()
    *
    * return an instance of a new (unsaved) ABMobileApp that is tied to this
    * ABApplication.
    *
    * @return {ABMobileApp}
    */
   // mobileAppNew(values) {
   //    return new ABMobileApp(values, this);
   // }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 38094:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABApplicationMobile.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABClassApplicationMobile)
/* harmony export */ });
/* harmony import */ var _core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABApplicationMobileCore.js */ 39807);
/* harmony import */ var _mobile_ABMobilePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mobile/ABMobilePage */ 77831);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
const _ = __webpack_require__(/*! lodash */ 96486);

// prettier-ignore



const ABViewManager = __webpack_require__(/*! ./ABViewManager */ 67348);

class ABClassApplicationMobile extends _core_ABApplicationMobileCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
   }

   ///
   /// Definition
   ///

   /**
    * @method pageNew()
    * return a new instance of an ABViewPageMobile
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPageMobile}
    */
   pageNew(values) {
      return new _mobile_ABMobilePage__WEBPACK_IMPORTED_MODULE_1__["default"](values, this);
   }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 64971:
/*!***************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABComponent.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABComponent)
/* harmony export */ });
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABEmitter */ 4025);


// const CustomComponentManager = require("../../webix_custom_components/customComponentManager");

// let L = (...params) => AB.Multilingual.label(...params);

class ABComponent extends _ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, AB) {
      super();

      // Transition Code:
      // make sure we have an this.AB
      if (App && App.AB) {
         this.AB = App.AB;
      }

      // passed in AB will override
      if (AB) {
         this.AB = AB;
         // {ABFactory} AB
      }

      if (!App) {
         if (AB._App) {
            App = AB._App;
         } else {
            App = {
               uuid: AB.jobID(),

               /*
                * AB
                * the {ABFactory} for our interface.
                */
               AB: AB,

               /*
                * actions:
                * a hash of exposed application methods that are shared among our
                * components, so one component can invoke an action that updates
                * another component.
                */
               actions: {},

               /*
                * config
                * webix configuration settings for our current browser
                */
               config: {}, // AB.UISettings.config(),

               /*
                * custom
                * a collection of custom components for this App Instance.
                */
               custom: null,

               /*
                * Icons
                * this will provide you with the list of avaialbe font awesome 4.7.0 icons to use in interface building
                */
               icons: {}, // AB.UISettings.icons,

               Label: AB.Label(),

               /*
                * labels
                * a collection of labels that are common for the Application.
                */
               labels: {
                  // add: L("Add"),
                  // create: L("Create"),
                  // delete: L("Delete"),
                  // edit: L("Edit"),
                  // export: L("Export"),
                  // formName: L("Name"),
                  // import: L("Import"),
                  // rename: L("Rename"),
                  // ok: L("Ok"),
                  // cancel: L("Cancel"),
                  // save: L("Save"),
                  // yes: L("Yes"),
                  // no: L("No"),
                  // none: L("None"),
                  // close: L("Close"),
                  // default: L("Default"),
                  // defaultPlaceholder: L("Enter default value"),
                  // disable: L("Disable"),
                  // required: L("Required"),
                  // unique: L("Unique"),
                  // invalidMessage: {
                  //    required: L("This field is required"),
                  // },
                  // createErrorMessage: L("System could not create <b>{0}</b>."),
                  // createSuccessMessage: L("<b>{0}</b> is created."),
                  // updateErrorMessage: L("System could not update <b>{0}</b>."),
                  // updateSucessMessage: L("<b>{0}</b> is updated."),
                  // deleteErrorMessage: L("System could not delete <b>{0}</b>."),
                  // deleteSuccessMessage: L("<b>{0}</b> is deleted."),
                  // renameErrorMessage: L("System could not rename <b>{0}</b>."),
                  // renameSuccessMessage: L("<b>{0}</b> is renamed."),
                  // // Data Field  common Property labels:
                  // dataFieldHeaderLabel: L("Section Title"),
                  // dataFieldHeaderLabelPlaceholder: L("Section Name"),
                  // dataFieldLabel: L("Label"),
                  // dataFieldLabelPlaceholder: L("Label"),
                  // dataFieldColumnName: L("Field Name"),
                  // dataFieldColumnNamePlaceholder: L("Database field name"),
                  // dataFieldShowIcon: L("show icon?"),
                  // componentDropZone: L("add widgets here"),
               },

               /*
                * unique()
                * A function that returns a globally unique Key.
                * @param {string} key   The key to modify and return.
                * @return {string}
                */
               unique: function (key) {
                  return `${key}${this.uuid}`;
               },
            };
            AB._App = App;
         }
      }

      // if (!App.custom) {
      //    if (!AB.custom) {
      //       var componentManager = new CustomComponentManager();
      //       componentManager.initComponents(App);
      //    } else {
      //       App.custom = AB.custom;
      //    }
      // }

      this.App = App;

      this.idBase = idBase || "?idbase?";
   }

   actions(_actions) {
      console.error("!!! REFACTOR out .actions()");
      if (_actions) {
         for (var a in _actions) {
            this.App.actions[a] = _actions[a];
         }
      }
   }

   Label() {
      return (...params) => {
         // console.error("!! App.label() depreciated.");
         return this.AB.Multilingual.label(...params);
      };
   }

   unique(key) {
      return this.App.unique(`${this.idBase}_${key}`);
   }
}


/***/ }),

/***/ 98383:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABDataCollection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDataCollection)
/* harmony export */ });
/* harmony import */ var _ABObjectQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObjectQuery */ 59545);
/* harmony import */ var _core_ABDataCollectionCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ABDataCollectionCore */ 47621);
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ABEmitter */ 4025);
/* harmony import */ var _ABMobileDC__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ABMobileDC */ 79464);






class DC extends _ABEmitter__WEBPACK_IMPORTED_MODULE_2__["default"] {
   constructor(attributes, AB) {
      super();
      // this.setMaxListeners(0);
      this.AB = AB;
   }
}

class ABDataCollection extends _core_ABDataCollectionCore__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.setMaxListeners(0);

      this.$state = null;
      // {Framework7.store} The shared F7 data store
   }

   ///
   /// Cursor
   ///

   /**
    * currentUserUsername
    * must return the proper value for the current user that would match a "user" field
    * in an object.
    * This is platform dependent, so must be implemented by a child object.
    * @return {string}
    */
   currentUserUsername() {
      return this.AB.Account.username();
   }

   ///
   /// Data
   ///

   setState(state) {
      this.$state = state;
   }

   hasMore() {
      // if we are not yet initialized:
      if (!this.isDataInitialized) {
         return true;
      }

      return (this.__totalCount || 0) > this.$state[this.id].length;
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      // this.initialized = true;  // <<---- DO NOT SET THIS HERE, it goes in CORE

      super.init();

      //// Now connect our platform hub to our Object Triggers:

      // events
      this.AB.on("ab.datacollection.create", (data) => {
         // debugger;
         this.emit("ab.datacollection.create", data);
      });

      this.AB.on("ab.datacollection.update", (data) => {
         // debugger;
         this.emit("ab.datacollection.update", data);
      });

      // We are subscribing to notifications from the server that an item may
      // be stale and needs updating
      // We will improve this later and verify that it needs updating before
      // attempting the update on the client side
      this.AB.on("ab.datacollection.stale", (data) => {
         // debugger;
         this.emit("ab.datacollection.stale", data);
      });

      this.AB.on("ab.datacollection.delete", (data) => {
         // debugger;
         this.emit("ab.datacollection.delete", data);
      });

      this.bindParentDc();
   }

   bindParentDc() {
      // if we pass the master datacollection and the field it is linked to
      // we want to bind it with that field as second param so dataFeed is
      // used on the slave datacollection
      let dataCollectionLink = this.datacollectionLink;
      let fieldLink = this.fieldLink;
      if (!this.settings.loadAll && dataCollectionLink && fieldLink) {
         let dc = this.__dataCollection;
         // the second param is the field id we bind the data to the master with
         dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
         // defining dataFeed allows us to query the database when the table is scrolled
         dc.define("dataFeed", (value, params) => {
            let cursorUpdated = false;
            // check if the current cursor was updated
            if (this?.datacollectionLink?.getCursor()?.id == value) {
               cursorUpdated = true;
            }

            // this is the same item that was already bound...don't reload data
            if (cursorUpdated) {
               // now that we have the modified wheres the dataCollections wheres
               // need to be modified for subsequent loads on scroll so lets set them
               // this.reloadWheres(wheres);

               // reload data
               this.reloadData(0, 20);
            }
         });
      }
   }

   loadData(start, limit = 20) {
      return super.loadData(start, limit).catch((err) => {
         // hideProgressOfComponents() is a platform specific action.
         this.hideProgressOfComponents();

         // propagate the error here:
         if (err) {
            throw err;
         }
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      // Web Platform:

      // data check:
      if (data.data && !Array.isArray(data.data)) {
         data.data = [data.data];
      }

      // standardize the heights

      /*
       // In v2: we move the row height calculation into the Interface designer.
       //

      // calculate default value of $height of rows
      let obj = this.datasource;
      let defaultHeight = 0;
      let minHeight = 0;
      let imageFields = obj.fields((f) => f.key == "image");
      let hiddenFields = obj.objectWorkspace.hiddenFields;
      imageFields.forEach(function (f) {
         if (hiddenFields.indexOf(f.columnName) == -1) {
            if (
               parseInt(f.settings.useHeight) == 1 &&
               parseInt(f.settings.imageHeight) > minHeight
            ) {
               minHeight = parseInt(f.settings.imageHeight) + 20;
            } else {
               minHeight = 100;
            }
         }
      });
      if (minHeight > 0) {
         defaultHeight = minHeight;
      }

      (data.data || []).forEach((d) => {
         // define $height of rows to render in webix elements
         if (
            d.properties != null &&
            d.properties.height != "undefined" &&
            parseInt(d.properties.height) > 0
         ) {
            d.$height = parseInt(d.properties.height);
         } else if (defaultHeight > 0) {
            d.$height = defaultHeight;
         }
      });
      */

      return super.processIncomingData(data).then(() => {
         // Web Platform:
         // when that is done:
         this.hideProgressOfComponents();
      });
   }

   ///
   /// Components
   ///

   /**
    * @method attachFlexlayout
    *
    *
    * @param {Object} component - a webix flexlayout element instance
    */
   attachFlexlayout(component) {
      var dc = this.__dataCollection;

      // prevent attach many times
      if (this.__flexComponentIds.indexOf(component.config.id) > -1) {
         return;
      } else {
         // keep component id to an array
         this.__flexComponentIds.push(component.config.id);
      }
   }

   /**
    * @method bind
    *
    *
    * @param {Object} component - a webix element instance
    */
   bind(component) {
      console.error("ABDataCollection.bind()!: Who is calling this?");
      var dc = this.__dataCollection;

      // prevent bind many times
      if (
         this.__bindComponentIds.indexOf(component.config.id) > -1 &&
         $$(component.config.id).data &&
         $$(component.config.id).data.find &&
         $$(component.config.id).data.find({}).length > 0
      )
         return;
      // keep component id to an array
      else this.__bindComponentIds.push(component.config.id);

      if (
         component.config.view == "datatable" ||
         component.config.view == "dataview" ||
         component.config.view == "treetable" ||
         component.config.view == "kanban"
      ) {
         if (dc) {
            var items = dc.count();
            if (
               items == 0 &&
               (this._dataStatus == this.dataStatusFlag.notInitial ||
                  this._dataStatus == this.dataStatusFlag.initializing) &&
               component.showProgress
            ) {
               component.showProgress({ type: "icon" });
            }

            component.define("datafetch", 20);
            component.define("datathrottle", 500);

            // initial data of treetable
            if (component.config.view == "treetable") {
               if (
                  this.datasource &&
                  this.datasource.isGroup &&
                  this.__treeCollection
               ) {
                  component.define("data", this.__treeCollection);
                  component.refresh();
               } else {
                  // NOTE: tree data does not support dynamic loading when scrolling
                  // https://forum.webix.com/discussion/3078/dynamic-loading-in-treetable
                  component.define("data", []);
                  component.parse(dc.find({}));
               }
            } else {
               component.data.sync(dc);
            }

            // Implement .onDataRequest for paging loading
            if (!this.settings.loadAll) {
               component.___AD = component.___AD || {};
               // if (component.___AD.onDataRequestEvent) component.detachEvent(component.___AD.onDataRequestEvent);
               if (!component.___AD.onDataRequestEvent) {
                  component.___AD.onDataRequestEvent = component.attachEvent(
                     "onDataRequest",
                     (start, count) => {
                        if (component.showProgress)
                           component.showProgress({ type: "icon" });

                        // load more data to the data collection
                        dc.loadNext(count, start);

                        return false; // <-- prevent the default "onDataRequest"
                     }
                  );
               }

               // // NOTE : treetable should use .parse or TreeCollection
               // // https://forum.webix.com/discussion/1694/tree-and-treetable-using-data-from-datacollection
               // if (
               //    component.config.view == "treetable" &&
               //    !this.datasource.isGroup
               // ) {
               //    component.___AD = component.___AD || {};
               //    if (!component.___AD.onDcLoadData) {
               //       component.___AD.onDcLoadData = () => {
               //          component.parse(dc.find({}));
               //       };

               //       this.on("loadData", component.___AD.onDcLoadData);
               //    }
               // }
            }
         } else {
            component.data.unsync();
         }
      } else if (component.bind) {
         if (dc) {
            // Do I need to check if there is any data in the collection before binding?
            component.bind(dc);
         } else {
            component.unbind();
         }

         if (component.refresh) component.refresh();
      }
   }

   unbind(component) {
      if (!component) return;

      component.detachEvent("onDataRequest");
      if (component.___AD) {
         if (component.___AD.onDataRequestEvent)
            delete component.___AD.onDataRequestEvent;

         if (component.___AD.onDcLoadData) {
            if (this.off) this.off("loadData", component.___AD.onDcLoadData);
            delete component.___AD.onDcLoadData;
         }
      }

      if (component.data && component.data.unsync) {
         component.data.unsync();
         component.define("data", []);
      }

      if (component.unbind) component.unbind();

      if (component.refresh) component.refresh();

      // remove from array
      this.__bindComponentIds = (this.__bindComponentIds || []).filter(
         (id) => id != component.config.id
      );
   }

   hideProgressOfComponents() {
      this.__bindComponentIds.forEach((comId) => {
         if ($$(comId) && $$(comId).hideProgress) $$(comId).hideProgress();
      });
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(data) {
      // debugger;

      // get a webix data collection
      let dc = new _ABMobileDC__WEBPACK_IMPORTED_MODULE_3__["default"]({
         data: data || [],
         DC: this,
      });

      this._extendCollection(dc);

      return dc;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      // get a webix data collection
      let treeStore = new webix.TreeCollection();

      this._extendCollection(treeStore);

      return treeStore;
   }

   _extendCollection(dataStore) {
      console.error(
         "TODO: ABDataCollection._extendCollection(): remove this call!"
      );
      return;

      // Apply this data collection to support multi-selection
      // https://docs.webix.com/api__refs__selectionmodel.html
      webix.extend(dataStore, webix.SelectionModel);

      dataStore.___AD = dataStore.___AD || {};

      // Implement .onDataRequest for paging loading
      if (!this.settings.loadAll) {
         if (!dataStore.___AD.onDataRequestEvent) {
            dataStore.___AD.onDataRequestEvent = dataStore.attachEvent(
               "onDataRequest",
               (start, count) => {
                  if (start < 0) start = 0;

                  // load more data to the data collection
                  this.loadData(start, count);

                  return false; // <-- prevent the default "onDataRequest"
               }
            );
         }

         if (!dataStore.___AD.onAfterLoadEvent) {
            dataStore.___AD.onAfterLoadEvent = dataStore.attachEvent(
               "onAfterLoad",
               () => {
                  this.emit("loadData", {});
               }
            );
         }
      }

      // override unused functions of selection model
      dataStore.addCss = function () {};
      dataStore.removeCss = function () {};
      dataStore.render = function () {};

      if (!dataStore.___AD.onAfterLoad) {
         dataStore.___AD.onAfterLoad = dataStore.attachEvent(
            "onAfterLoad",
            () => {
               this.hideProgressOfComponents();
            }
         );
      }
   }

   parseTreeCollection(data = {}) {
      if (
         !(this.__datasource instanceof _ABObjectQuery__WEBPACK_IMPORTED_MODULE_0__["default"]) ||
         !this.__datasource.isGroup ||
         !this.__treeCollection
      )
         return;

      let addRowToTree = (join = {}, parentAlias = null) => {
         let alias = join.alias;

         (data.data || []).forEach((row) => {
            let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
            if (!dataId) return;

            // find parent nodes
            let parentItemIds = [];
            let parentId =
               row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
            if (parentId) {
               parentItemIds = this.__treeCollection
                  .find(
                     (item) =>
                        item._alias == parentAlias && item._dataId == parentId
                  )
                  .map((item) => item.id);
            }

            // check exists
            let exists = this.__treeCollection.find((item) => {
               return (
                  item._alias == alias &&
                  item._dataId == dataId &&
                  (parentItemIds.length == 0 ||
                     parentItemIds.indexOf(item.$parent) > -1)
               );
            }, true);
            if (exists) return;

            let treeNode = {};
            treeNode._alias = alias;
            treeNode._dataId = dataId;
            treeNode._itemId = row.id; // Keep row id for set cursor to data collection

            Object.keys(row).forEach((propName) => {
               // Pull value from alias
               if (propName.indexOf(`${alias}.`) == 0) {
                  treeNode[propName] = row[propName];
               }
            });

            if (row.translations) treeNode.translations = row.translations;

            // child nodes
            if (parentItemIds.length > 0)
               parentItemIds.forEach((parentItemId) => {
                  this.__treeCollection.add(treeNode, null, parentItemId);
               });
            // root node
            else this.__treeCollection.add(treeNode, null);
         });

         // Sub-joins
         (join.links || []).forEach((link) => {
            addRowToTree(link, alias);
         });
      };

      // Show loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         //// Webix Command here:
         let boundComp = $$(comId);
         if (boundComp && boundComp.showProgress)
            boundComp.showProgress({ type: "icon" });

         if (boundComp.data && boundComp.data.unsync) boundComp.data.unsync();
      });

      addRowToTree(this.__datasource.joins());

      // Hide loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         let boundComp = $$(comId);
         if (boundComp && boundComp.hideProgress) boundComp.hideProgress();
         boundComp.define("data", this.__treeCollection);
      });
   }

   warningsEval() {
      super.warningsEval();

      if (!this.datasource) {
         this.warningsMessage(`doesn't have a datasource.`);
      } else if (this.linkDatacollectionID) {
         const linkDC = this.AB.datacollectionById(this.linkDatacollectionID);

         if (!linkDC)
            this.warningsMessage(
               `can't resolve linkDatacollectionID[${this.linkDatacollectionID}]`
            );
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `Datacollection[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   get userScopes() {
      return this.AB.Account.scopes();
   }
}


/***/ }),

/***/ 34802:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABDefinition.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABDefinition)
/* harmony export */ });
/* harmony import */ var _core_ABDefinitionCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABDefinitionCore */ 17953);


class ABDefinition extends _core_ABDefinitionCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, AB) {
   //    super(attributes, AB);
   // }
}


/***/ }),

/***/ 4025:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABEmitter.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABEmitter)
/* harmony export */ });
/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter2 */ 56387);
/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_0__);
/**
 * ABEmitter
 *
 * This is the platform dependent implementation of an Emitter object.
 *
 */



class ABEmitter extends (eventemitter2__WEBPACK_IMPORTED_MODULE_0___default()) {
   constructor() {
      super(/*{ maxListeners: 0 }*/);
   }
}


/***/ }),

/***/ 5701:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABHint.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABHint)
/* harmony export */ });
/* harmony import */ var _core_ABHintCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABHintCore */ 36717);


class ABHint extends _core_ABHintCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy(App) {
      let L = this.AB.Label();
      // remove all my Elements
      var allSteps = this.steps();
      var allDestroy = [];
      allSteps.forEach((e) => {
         allDestroy.push(e.destroy());
      });
      // remove reference on App and View
      let hintIndex = App.hintIDs.indexOf(this.id);
      if (hintIndex > -1) {
         App.hintIDs.splice(hintIndex, 1);
         App.save();
      }

      let view = App.views((v) => {
         return v.id == this.settings.view;
      })[0];

      if (view) {
         delete view.settings.hintID;
         view.save();
      }

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  webix.message({
                     text: L("Tutorial Deleted"),
                     type: "success",
                     expire: 3000,
                  });
                  resolve();
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }

   createHintUI() {
      // if already loaded skip
      if ($$(this.id)) return;

      let L = this.AB.Label();
      let steps = [];
      let next = 0;
      let display = webix.storage.cookie.get(this.id);
      if (display?.hide) return;
      let dontShow = `<label class="dontShow">
                        <input onclick="webix.storage.cookie.put(this.dataset.hintId, {'hide': this.checked});" data-hint-id="${
                           this.id
                        }" type="checkbox"> 
                        ${L("Don't show this again.")}
                     </label>`;
      this.stepIDs.forEach((step) => {
         next++;
         let newStep = {};
         newStep.id = this._steps[step].id;
         newStep.el = this._steps[step].settings.el;
         newStep.event = this._steps[step].settings.event;
         newStep.title = this._steps[step].name;
         newStep.text = this._steps[step].text + dontShow;
         if (this.stepIDs[next]) {
            newStep.nextEl = this._steps[this.stepIDs[next]].settings.el;
            if (newStep.nextEl) {
               newStep.hintId = this.id;
               newStep.eventEl = "button"; // added this so we do not trigger a second advance on the hint when triggering the click below
               newStep.next = function (event) {
                  let nextEl = this.nextEl;
                  let theNextEl = document.querySelector(nextEl);
                  if (theNextEl && theNextEl.checkVisibility()) {
                     return false;
                  } else {
                     document.querySelector(this.el).click();
                     return false;
                  }
               };
            }
         }
         if (newStep.el) steps.push(newStep);
      });

      let ui = {
         view: "hint",
         id: this.id,
         steps: steps,
         on: {
            onNext: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
            onPrevious: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
         },
      };

      webix.delay(
         () => {
            webix.ui(ui).start();
         },
         null,
         null,
         2000
      );

      // $$(this.id);
   }
}


/***/ }),

/***/ 32711:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABIndex)
/* harmony export */ });
/* harmony import */ var _core_ABIndexCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABIndexCore */ 59815);


class ABIndex extends _core_ABIndexCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, object) {
   //    super(attributes, object);
   // }

   /**
    * @method save()
    * persist this instance of ABIndex with it's parent ABObject
    * @return {Promise}
    */
   save() {
      return super
         .save()
         .then(() => this.object.indexSave(this))
         .then(() => this.migrateCreate());
   }

   /**
    * @method destroy()
    * destroy the current instance of ABIndex
    * also remove it from our parent ABObject
    * @return {Promise}
    */
   destroy() {
      return new Promise((resolve, reject) => {
         if (this.id) {
            this.migrateDrop()
               .then(() => {
                  return super.destroy();
               })
               .then(() => this.object.indexRemove(this))
               .then(resolve)
               .catch(reject);
         } else {
            resolve();
         }
      });
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      if (this.fields.length == 0) {
         this.warningsMessage(`is not referencing any fields`);
      }
   }

   /**
    * @method warningsMessage()
    * generate a commonly formatted warning message for this ABField.
    * This is expected to be called from within a .warningsEval()
    * method when generating warnings.
    * @param {string} msg
    *        the warning string to display
    * @param {json} data
    *        any relevant additional information for a developer to refer to.
    */
   warningsMessage(msg, data = {}) {
      let message = `Index[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
         // data: this.toObj(),
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
      });
   }
}


/***/ }),

/***/ 46148:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABMLClass.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMLClass)
/* harmony export */ });
/* harmony import */ var _core_ABMLClassCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABMLClassCore */ 90477);
/**
 * ABMLClass
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This platform ABMLClass will define 2 methods that allow for the translation
 * untranslation of this data.
 */
// var ABMLClassCore = require("../core/ABMLClassCore");


class ABMLClass extends _core_ABMLClassCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(fieldList, AB) {
      super(fieldList, AB);

      this._warnings = [];
      // {array}
      // an array of warning messages for this object.
      // each warning entry should be in the format:
      // WarningMessage: {
      //    message: {string} "message to display"
      //    data: {json} additional debugging information
      // }
   }

   // fromValues(attributes) {
   //    super.fromValues(attributes);
   // }

   /**
    * @method warnings()
    * returns the stored warnings for this ONE object.
    * @return {array} WarningMessage
    */
   warnings() {
      return this._warnings;
   }

   /**
    * @method warningsEval()
    * This method causes an object to re-evaluate it's settings to see if there
    * are any potential errors.
    */
   warningsEval() {
      this._warnings = [];
   }

   /**
    * @method warningsAll()
    * returns all relevant warnings for the current Object. This includes any
    * sub fields, links, views, etc...
    * @return {array} warning structures
    *          [ {WarningMessage}, ... ]
    */
   warningsAll() {
      return this.warnings();
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return this.AB.Account.language() || "en";
   }

   /**
    * @method destroy()
    * remove this definition.
    * @return {Promise}
    */
   async destroy() {
      var def = this.toDefinition();
      if (def.id) {
         return def.destroy().catch((err) => {
            if (err.toString().indexOf("No record found") > -1) {
               // this is weird, but not breaking:
               console.log(
                  `ABMLClass.destroy(): could not find record for id[${def.id}]`
               );
               console.log(def);
               return;
            }
            throw err;
         });
      }
      return Promise.resolve();
   }

   /**
    * @method save()
    * persist this definition of our {ABxxx} Object
    * @return {Promise}
    */
   async save() {
      var def = this.toDefinition();
      // if not name, try to use our label as the name
      def.name = def.name || this.name || this.label || "name";
      var data = await def.save();
      if (!this.id) {
         this.id = data.id;
      }
   }
}


/***/ }),

/***/ 79464:
/*!**************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABMobileDC.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileDC)
/* harmony export */ });
/* harmony import */ var _ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABEmitter */ 4025);
/**
 * ABMobileDC
 *
 * This is the platform dependent implementation of our DataCollection object.
 *
 * The ABDataCollection objects are designed around working with an instance
 * of a Webix Datacollection to manage getting the data into the various UI
 * elements.
 *
 * Now on Framework7 we have to work with F7 stores.  This object is designed
 * to follow our existing Object API, while working with F7 Stores to update
 * the UI.
 *
 * GOAL: we will implement an object that mimics the Webix.DataCollection
 * features that are used in our CORE part of the codebase.  And then recode
 * our PLATFORM.DataCollection to approach things more in line with F7
 *
 */



class ABMobileDC extends _ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(Options) {
      super(/*{ maxListeners: 0 }*/);

      this.data = Options.data || [];
      this.DC = Options.DC;

      this.cursorID = null;

      // Mock the ABDataCollectionCore.init(): initialization of the
      // "changeCursor" event:
      this.___AD = { onAfterCursorChange: () => true };
   }

   //
   // 1) We need to connect our DC to a parent DC that we are linked to.
   // Once the Parent DC is selected, we need to pull the current selection
   // and then perform another reload() based upon
   bind(DC, id) {}

   // 2) continuous Scrolling:
   //    Implemented at the level of the UI component:
   //    <div onInfinite={ this.loadMore() }
   //    loadMore() {
   //       if (this.DC.hasMore()) {
   //          this.DC.loadMore(); // <<-- DC will update the $store
   //       }
   //    }
   /*

 dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
// defining dataFeed allows us to query the database when the table is scrolled
dc.define("dataFeed", (value, params) => {
   let cursorUpdated = false;
   // check if the current cursor was updated
   if (this?.datacollectionLink?.getCursor()?.id == value) {
      cursorUpdated = true;
   }

   // this is the same item that was already bound...don't reload data
   if (cursorUpdated) {
      // now that we have the modified wheres the dataCollections wheres
      // need to be modified for subsequent loads on scroll so lets set them
      // this.reloadWheres(wheres);

      // reload data
      this.reloadData(0, 20);
   }
});

*/

   get PK() {
      return this.DC.datasource.PK();
   }

   stateValues() {
      if (!this.DC.$state) return [];
      return this.DC.$state[this.DC.id];
   }

   add(value, indx) {
      if (!Array.isArray(value)) {
         value = [value];
      }
      let allValues = this.stateValues();
      allValues.splice(indx, 0, ...value);
      this.setValues(allValues);
   }

   clearAll() {
      this.setValues([]);
      this.cursorID = null;
   }

   count() {
      return this.stateValues().length();
   }

   exists(ID) {
      let allValues = this.stateValues();
      let found = allValues.find((v) => ID == this.id(v));
      return "undefined" !== typeof found;
   }

   /**
    * filter(fn)
    * Apply a filter to the current data set.
    */
   filter(fn) {
      this.__unfilteredData = this.stateValues();

      if (typeof fn == "undefined") {
         this.setValues(this.__unfilteredData);
         delete this.__unfilteredData;
         return;
      }

      this.setValues(this.__unfilteredData.filter(fn));
   }

   find(fn = () => true) {
      if (typeof fn != "function") {
         if (typeof fn == "object") {
            if (Object.keys(fn).length == 0) {
               fn = () => true;
            } else {
               throw new Error("Improper parameter to .find():", fn);
            }
         }
      }
      return this.stateValues().filter(fn);
   }

   /**
    * @method getCursor()
    * returns the ID of the item the cursor is set to.
    * @return {string}
    */
   getCursor() {
      return this.cursorID;
   }

   getFirstId() {
      var allValues = this.stateValues();
      if (allValues.length == 0) return null;
      return this.id(allValues[0]);
   }

   getNextId(id) {
      var idxFound = -1;
      var PK = this.PK;
      var allValues = this.stateValues();
      for (var i = 0, val_len = allValues.length; i < val_len; i++) {
         if (this.id(allValues[i]) == id) {
            idxFound = i;
            break;
         }
      }

      if (idxFound == -1) {
         return null;
      }

      return this.id(allValues[idxFound + 1]);
   }

   id(value) {
      return value[this.PK] || value.id || value.uuid;
   }

   getItem(id) {
      var PK = this.PK;
      var allValues = this.stateValues();
      return allValues.find((v) => this.id(v) == id);
   }

   /**
    * @method load()
    * can be called with a
    * - data
    */
   load(fn) {
      if ("function" == typeof fn) {
         var result = fn();
         // did the fn() return a Promise?
         // if so, then wait for the result and pass to .parse()
         if (result?.then) {
            result.then((data) => {
               if (data) this.parse(data);
            });
         } else {
            // pass the result on to .parse()
            if (result) this.parse(result);
         }
      } else {
         this.parse(fn);
      }
   }

   /**
    * @method parse()
    * take the provided data response from the server and store the
    * data into our $store.
    * data format could be the response packet:
    *    {data: [], total_count: 11, pos: 0, offset: 0, limit: 20}
    * or just the array of data to store: []
    */
   parse(data) {
      // check to see if data is in expanded format:
      // { data, pos, total_count, }

      let dataIn = data.data || data;
      let pos = data.pos || 0;
      let tc = data.total_count || 0;

      if (Array.isArray(dataIn) && dataIn.length == 0) return;

      if (pos == 0) {
         this.setValues(dataIn);
      } else {
         let allValues = this.stateValues();
         allValues.splice(pos, 0, ...dataIn);
         this.setValues(allValues);
      }

      // remove any stored filter
      delete this.__unfilteredData;
   }

   remove(id) {
      var PK = this.PK;
      var allValues = this.stateValues();
      this.setValues(allValues.filter((v) => this.id(v) != id));

      if (this.__unfilteredData) {
         this.__unfilteredData = this.__unfilteredData.filter(
            (v) => this.id(v) != id
         );
      }

      if (this.cursorID == id) this.cursorID = null;
   }

   setCursor(ID) {
      this.cursorID = ID;
      this.emit("onAfterCursorChange");

      // ABDataCollectionCore.init() : attempts to set up this dynamic,
      // but we are initializing this here instead:
      let currCursorItem = this.getItem(ID);
      this.DC.emit("changeCursor", currCursorItem);
   }

   setValues(data) {
      // this.DC.dataInitialized();
      this.DC.$state[this.DC.id] = data;
   }

   updateItem(ID, data) {
      let item = this.getItem(ID);
      for (var p in data) {
         if (data.hasOwnProperty(p)) {
            item[p] = data[p];
         }
      }

      var allValues = this.stateValues().map((v) => {
         if ((v.id || v.uuid) == (data.id || data.uuid)) {
            return item;
         } else {
            return v;
         }
      });

      this.setValues(allValues);
   }

   // DataCollectionCore.setCursor()
   /*

   attachEvent(str, fn() ) // onAfterCursorChange
   
   updateItem(d.id,updateItemData);

   loadNext(count, start);
*/
}


/***/ }),

/***/ 41637:
/*!***********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModel.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModel)
/* harmony export */ });
/* harmony import */ var _core_ABModelCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABModelCore */ 312);


//
// ABModel
//
// Represents the Data interface for an ABObject data.
//
// 2 ways to use an ABModel to load a DataTable:
// 	Method 1:
// 	gather all the data externally and send to the DataTable
//		Model.findAll()
//		.then((data)=>{
//			DataTable.parse(data);
//		})
//
// 	Method 2:
// 	Set the Model object with a condition / skip / limit, then
// 	use it to load the DataTable:
//		Model.where({})
//		.skip(XX)
//		.limit(XX)
//		.loadInto(DataTable);

function errorPopup(error) {
   // Show the pop up
   if (error && error.data && error.data.error == "READONLY") {
      webix.alert({
         title: "Your action is blocked",
         ok: "Ok",
         text: error.data.message || "",
         type: "alert-warning",
      });
   }
}

/*
 * @function no_socket_trigger()
 * a common routine to trigger an update.
 * In the case where our AB.Network.type() isn't a socket implementation
 * we need to manually trigger the expected socket events ourselves.
 * This fn() attempts to simulate the socket responses in such a case.
 * @param {ABModel} model
 *        The ABModel currently processing the network transaction.
 * @param {string} key
 *        The socket update trigger we are simulating.
 * @param {json} data
 *        The relevant response from our network transaction.
 */
function no_socket_trigger(model, key, data) {
   // If we do not have socket updates available, then trigger an
   // update event with this data.
   if (model.AB.Network.type() != "socket") {
      model.AB.emit(key, {
         objectId: model.object.id,
         data,
      });
   }
}

class ABModel extends _core_ABModelCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(object) {
      super(object);

      this.handler_create = (...params) => {
         this.handler_common("ab.datacollection.create", ...params);
      };

      this.handler_delete = (...params) => {
         this.handler_common("ab.datacollection.delete", ...params);
      };

      this.handler_findAll = (...params) => {
         this.handler_common(null, ...params);
      };

      this.handler_logs = (context, err, data) => {
         if (err) {
            context.reject?.(err);
            return;
         }
         context.resolve?.(data);
      };

      this.handler_update = (...params) => {
         this.handler_common("ab.datacollection.update", ...params);
      };

      this.handler_common = (key, context, err, data) => {
         // key: {string} the relevant socket event key
         //      can be null if not relevant.
         // context : {obj} any provided context data provided on the
         //           this.AB.Network.get() call.
         // err: {Error} any returned error message from api
         // data: {obj} returned data from the model-get api in format:
         //       {data: [], total_count: 1, pos: 0, offset: 0, limit: 0}
         if (err) {
            context.reject?.(err);
            return;
         }
         if (key) {
            // on "update" & "create" we want to normalizeData()
            if (key.indexOf("delete") == -1) {
               this.normalizeData(data);
            } else {
               data = data.data || context.id;
            }
         } else {
            // on a findAll we normalize data.data
            this.normalizeData(data.data);
         }

         context.resolve?.(data);

         if (key) {
            no_socket_trigger(this, key, data);
         }
      };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      return this.AB.Network[method](params);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      values.batch.map((vals) => {
         return this.prepareMultilingualData(vals.data);
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err, data) => {
            if (err) {
               reject(err);
               return;
            }
            this.normalizeData(data);
            resolve(data);
            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a create event
            // triggerEvent('create', this.object, data);
         });

         this.AB.Network.post(
            {
               url: this.object.urlRestBatch(),
               params: values,
            },
            {
               key: jobID,
               context: {},
            }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // FIX: now with sockets, the triggers are fired from socket updates.
            //    // trigger a create event
            //    // triggerEvent('create', this.object, data);
            // })
            .catch(reject);
      });
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      this.prepareMultilingualData(values);

      // add default values record if no value is passed for column
      this.object.fields().forEach((f) => {
         if (values[f.columnName] === undefined) {
            f.defaultValue(values);
         }
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_create);
         this.AB.Network.post(
            {
               url: this.object.urlRest(),
               params: values,
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_delete);
         this.AB.Network["delete"](
            {
               url: this.object.urlRestItem(id),
            },
            {
               key: jobID,
               context: { resolve, reject, id },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      });
   }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   async findAll(cond) {
      cond = cond || {};

      // 		// prepare our condition:
      // 		var newCond = {};

      // 		// if the provided cond looks like our { where:{}, skip:xx, limit:xx } format,
      // 		// just use this one.
      // 		if (cond.where) {
      // 			newCond = cond;
      // 		} else {

      // 			// else, assume the provided condition is the .where clause.
      // 			newCond.where = cond;
      // 		}

      // /// if this is our depreciated format:
      // if (newCond.where.where) {
      // 	OP.Error.log('Depreciated Embedded .where condition.');
      // }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_findAll);
         this.AB.Network.get(
            {
               url: this.object.urlRest(),
               params: cond,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         )
            // .then((data) => {
            //    this.normalizeData(data.data);

            //    resolve(data);
            // })
            .catch((err) => {
               if (err && err.code) {
                  switch (err.code) {
                     case "ER_PARSE_ERROR":
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Parse Error with provided condition",
                           condition: cond,
                        });
                        break;

                     default:
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Unknown Error with provided condition",
                           condition: cond,
                        });
                        break;
                  }
               }
               reject(err);
            });
      });
   }

   /**
    * @method loadInto
    * loads the current values into the provided Webix DataTable
    * @param {DataTable} DT  A Webix component that can dynamically load data.
    */
   loadInto(DT) {
      // if a limit was applied, then this component should be loading dynamically
      if (this._limit) {
         DT.define("datafetch", this._limit);
         DT.define("datathrottle", 250); // 250ms???

         // catch the event where data is requested:
         // here we will do our own findAll() so we can persist
         // the provided .where condition.

         // oh yeah, and make sure to remove any existing event handler when we
         // perform a new .loadInto()
         DT.___AD = DT.___AD || {};
         if (DT.___AD.onDataRequestEvent) {
            DT.detachEvent(DT.___AD.onDataRequestEvent);
         }
         DT.___AD.onDataRequestEvent = DT.attachEvent(
            "onDataRequest",
            (start, count) => {
               var cond = {
                  where: this._where,
                  sort: this._sort,
                  limit: count,
                  skip: start,
               };

               if (DT.showProgress) DT.showProgress({ type: "icon" });

               this.findAll(cond).then((data) => {
                  /*
                   // In V2: we move the row height processing into 
                   // the interface designer 

                  data.data.forEach((item) => {
                     if (
                        item.properties != null &&
                        item.properties.height != "undefined" &&
                        parseInt(item.properties.height) > 0
                     ) {
                        item.$height = parseInt(item.properties.height);
                     } else if (parseInt(this._where.height) > 0) {
                        item.$height = parseInt(this._where.height);
                     }
                  });
                  */
                  DT.parse(data);

                  if (DT.hideProgress) DT.hideProgress();
               });

               return false; // <-- prevent the default "onDataRequest"
            }
         );

         DT.refresh();
      }

      // else just load it all at once:
      var cond = {};
      if (this._where) cond.where = this._where;
      if (this._sort) cond.sort = this._sort;
      if (this._limit != null) cond.limit = this._limit;
      if (this._skip != null) cond.skip = this._skip;

      if (DT.showProgress) DT.showProgress({ type: "icon" });

      this.findAll(cond)
         .then((data) => {
            // v2: we no longer process item $height
            /*
            data.data.forEach((item) => {
               if (
                  item.properties != null &&
                  item.properties.height != "undefined" &&
                  parseInt(item.properties.height) > 0
               ) {
                  item.$height = parseInt(item.properties.height);
               } else if (parseInt(this._where.height) > 0) {
                  item.$height = parseInt(this._where.height);
               }
            });
            */

            DT.parse(data);

            if (DT.hideProgress) DT.hideProgress();
         })
         .catch((err) => {
            console.error("!!!!!", err);
         });
   }

   /**
    * @method logs()
    * return the log history related to this model's ABObject.
    * @param {hash} options
    *        a key=>value hash of optional search criteria
    *        .rowId {string} the uuid of the individual entry we are querying
    *        .levelName {string} the type of entry ["insert", "update", "delete"]
    *        .username {string} the entries associated with the given user
    *        .startDate {date} entries that happened ON or AFTER this date
    *        .endDate {date} entries that happened ON or BEFORE this date
    *        .start {integer} paging control: how many entries to skip
    *        .limit {integer} paging control: only return this # entries
    * @return {Promise}
    */
   logs(options) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_logs);
         this.AB.Network.get(
            {
               url: this.object.urlRestLog(),
               params: options,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            if (err && err.code) {
               this.AB.notify.developer(err, {
                  context: "AppBuilder:ABModel:logs(): Error",
                  options,
               });
            }
            reject(err);
         });
      });
   }

   /**
    * @method limit
    * set the limit value for this set of data
    * @param {integer} limit  the number or elements to return in this call
    * @return {ABModel} this object that is chainable.
    */
   limit(limit) {
      this._limit = limit;
      return this;
   }

   /**
    * @method skip
    * set the skip value for this set of data
    * @param {integer} skip  the number or elements to skip
    * @return {ABModel} this object that is chainable.
    */
   skip(skip) {
      this._skip = skip;
      return this;
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_update);
         this.AB.Network.put(
            {
               url: this.object.urlRestItem(id),
               params: values,
            },
            { key: jobID, context: { resolve, reject } }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // If we do not have socket updates available, then trigger an
            //    // update event with this data.
            //    if (this.AB.Network.type() != "socket") {
            //       this.AB.emit("ab.datacollection.update", {
            //          objectId: this.object.id,
            //          data,
            //       });
            //    }
            // })
            .catch((err) => {
               errorPopup(err);
               reject(err);
            });
      });
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err /*, data */) => {
            if (err) {
               reject(err);
               return;
            }
            // this.normalizeData(data);
            resolve(true);
            // what about checking for socket updates?
         });
         this.AB.Network.put(
            {
               url: this.object.urlRestBatch(),
               params: {
                  rowIds,
                  values,
               },
            },
            { key: jobID, context: {} }
         )
            // .then(() => {
            //    resolve(true);
            // })
            .catch(reject);
      });
   }
}


/***/ }),

/***/ 56972:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABModelQuery.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABModelQuery)
/* harmony export */ });
/* harmony import */ var _ABModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABModel */ 41637);
//
// ABModelQuery
//
// Represents the Data interface for an ABObjectQuery data.



class ABModelQuery extends _ABModel__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ///
   /// Instance Methods
   ///

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchCreate() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.create() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.delete() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.update() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchUpdate() should not be called."
      );
      return Promise.reject(error);
   }
}


/***/ }),

/***/ 83311:
/*!************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObject.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObject)
/* harmony export */ });
/* harmony import */ var _core_ABObjectCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectCore */ 92741);

// import ABObjectWorkspaceViewCollection from "./workspaceViews/ABObjectWorkspaceViewCollection";

var L = null;

// NOTE: this has been moved to NetworkRestSocket:
//
// // Start listening for server events for object updates and call triggerEvent as the callback
// if (typeof io != "undefined") {
//    io.socket.on("ab.object.update", function (msg) {
//       AB.emit("ab.object.update", {
//          objectId: msg.objectId,
//          data: msg.data,
//       });
//    });
// } else {
//    console.error("TODO: ABObject: configure Socket.io");
// }

// io.socket.on("ab.object.delete", function (msg) {
// });

class ABObject extends _core_ABObjectCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      if (!L) L = AB.Label();
      super(attributes, AB);

      // this.workspaceViews = new ABObjectWorkspaceViewCollection(
      //    attributes,
      //    this,
      //    AB
      // );

      // listen for our ABFields."definition.updated"
      this.fields().forEach((f) => {
         f.on("definition.updated", (field) => {
            // create a new Field with the updated def
            var def = this.AB.definitionByID(field.id);
            if (!def) return;

            var newField = this.AB.fieldNew(def, this);

            // we want to keep the same fieldID order:
            var newFields = [];
            this.fields().forEach((f) => {
               if (f.id === field.id) {
                  newFields.push(newField);
                  return;
               }
               newFields.push(f);
            });

            this._fields = newFields;
         });
      });

      // listen
      // this.AB.on("ab.object.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our migrateXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this._handler_object_migrate = (context, err, response) => {
         // NOTE:
         var pending = this._pendingNetworkRequests?.[context.uuid];
         if (err) {
            pending?.reject(err);
            return;
         }
         pending?.resolve(response);
      };
      this.AB.Network.on("object.migrate", this._handler_object_migrate);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABObject.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.objectByID(this.id);

      // prevent doing this multiple times:
      if (this._pendingNetworkRequests) {
         // remove object.migrate listener
         this.AB.Network.removeListener(
            "object.migrate",
            this._handler_object_migrate
         );

         // transfer the pending network requests
         newObj._pendingNetworkRequests = this._pendingNetworkRequests;
         this._pendingNetworkRequests = null;
      }

      return newObj;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			labelFormat: 'xxxxx',
			isImported: 1/0,
			isExternal: 1/0,
			urlPath:'string',
			importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
										// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
			translations:[
				{}
			],
			fields:[
				{ABDataField}
			]
		}
		*/

      super.fromValues(attributes);

      if (this.workspaceViews) this.workspaceViews.fromObj(attributes);
   }

   //// TODO: Refactor isValid() to ignore op and not error if duplicateName is own .id

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.objects((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Object name must be unique ("{0}" already in use)', [this.name])
         );
      }

      // Check the common validations:
      // TODO:
      // if (!inputValidator.validate(values.label)) {
      // 	_logic.buttonSaveEnable();
      // 	return false;
      // }

      return validator;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(data) {
      var validator = this.AB.Validation.validator();
      this.fields().forEach((f) => {
         // check if value was passed, if so validate it
         if (data.hasOwnProperty(f.columnName)) f.isValidData(data, validator);
      });

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @param {obj} values  the initial values for this field.
    *						{ key:'{string}'} is required
    * @return {ABField}
    */
   // fieldNew ( values ) {
   // 	// NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
   // 	return ABFieldManager.newField( values, this );
   // }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   async destroy() {
      /*
        return new Promise((resolve, reject) => {
            // Remove the import object, then its model will not be destroyed
            if (this.isImported) {
                this.application
                    .objectDestroy(this)
                    .catch(reject)
                    .then(() => {
                        resolve();
                    });

                return;
            }

            // OK, some of our Fields have special follow up actions that need to be
            // considered when they no longer exist, so before we simply drop this
            // object/table, drop each of our fields and give them a chance to clean up
            // what needs cleaning up.

            // ==> More work, but safer.
            var fieldDrops = [];
            this.fields().forEach((f) => {
                fieldDrops.push(f.destroy());
            });

            Promise.all(fieldDrops)
                .then(() => {
                    return new Promise((next, err) => {
                        // now drop our table
                        // NOTE: our .migrateXXX() routines expect the object to currently exist
                        // in the DB before we perform the DB operations.  So we need to
                        // .migrateDrop()  before we actually .objectDestroy() this.
                        this.migrateDrop()
                            .then(() => {
                                // finally remove us from the application storage
                                return this.application.objectDestroy(this);
                            })
                            .then(next)
                            .catch(err);
                    });
                })

                // flag .disable to queries who contains this removed object
                .then(() => {
                    return new Promise((next, err) => {
                        this.application
                            .queries(
                                (q) =>
                                    q.objects((o) => o.id == this.id).length > 0
                            )
                            .forEach((q) => {
                                q._objects = q.objects((o) => o.id != this.id);

                                q.disabled = true;
                            });

                        next();
                    });
                })
                .then(resolve)
                .catch(reject);
        });
 */

      var removeFromApplications = () => {
         var allRemoves = [];
         this.AB.applications().forEach((app) => {
            allRemoves.push(app.objectRemove(this));
         });
         return Promise.all(allRemoves);
      };

      var disableRelatedQueries = () => {
         return new Promise((next /*, err */) => {
            this.AB.queries(
               (q) => q.objects((o) => o.id == this.id).length > 0
            ).forEach((q) => {
               // q._objects = q.objects((o) => o.id != this.id);

               q.disabled = true;
            });

            next();
         });
      };

      try {
         // 1) remove us from all Application:
         await removeFromApplications();

         // 2) disable any connected Queries
         await disableRelatedQueries();

         // if an imported Object (FederatedTable, Existing Table, etc...)
         // then skip this step
         if (this.isImported) {
            return Promise.resolve();
         }

         // time to remove my table:
         // NOTE: our .migrateXXX() routines expect the object to currently exist
         // in the DB before we perform the DB operations.  So we need to
         // .migrateDrop()  before we actually .destroy() this.
         await this.migrateDrop();

         // now remove my definition

         // start with my fields:
         var fieldDrops = [];

         // Only ABObjects should attempt any fieldDrops.
         // ABObjectQueries can safely skip this step:
         if (this.type == "object") {
            var allFields = this.fields();
            this._fields = []; // clear our field counter so we don't retrigger
            // this.save() on each field.destroy();

            allFields.forEach((f) => {
               fieldDrops.push(f.destroy());
            });
         }
         await Promise.all(fieldDrops);

         await super.destroy();
         this.emit("destroyed");
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.destroy(): error destroying object.",
         });
      }

      // return Promise.resolve()
      //    .then(() => {
      //       // 1) remove us from all Application:
      //       return removeFromApplications();
      //    })
      //    .then(() => {
      //       // 2) disable any connected Queries
      //       return disableRelatedQueries();
      //    })
      //    .then(() => {
      //       // if an imported Object (FederatedTable, Existing Table, etc...)
      //       // then skip this step
      //       if (this.isImported) {
      //          return Promise.resolve();
      //       }

      //       // time to remove my table:
      //       // NOTE: our .migrateXXX() routines expect the object to currently exist
      //       // in the DB before we perform the DB operations.  So we need to
      //       // .migrateDrop()  before we actually .destroy() this.
      //       return this.migrateDrop();
      //    })
      //    .then(() => {
      //       // now remove my definition

      //       // start with my fields:
      //       var fieldDrops = [];

      //       // Only ABObjects should attempt any fieldDrops.
      //       // ABObjectQueries can safely skip this step:
      //       if (this.type == "object") {
      //          var allFields = this.fields();
      //          this._fields = []; // clear our field counter so we don't retrigger
      //          // this.save() on each field.destroy();

      //          allFields.forEach((f) => {
      //             fieldDrops.push(f.destroy());
      //          });
      //       }

      //       return Promise.all(fieldDrops)
      //          .then(() => {
      //             // now me.
      //             return super.destroy();
      //          })
      //          .then(() => {
      //             this.emit("destroyed");
      //          });
      //    });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      var isAdd = false;

      // if this is our initial save()
      if (!this.id) {
         this.label = this.label || this.name;
         isAdd = true;
      }

      try {
         await super.save();
         if (isAdd) {
            await this.migrateCreate();
         }
         return this;
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.save()",
            obj: this.toObj(),
         });
         throw err;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      // result.objectWorkspaceViews = this.workspaceViews.toObj();

      return result;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network.post(
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   migrateDrop() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network["delete"](
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth /*, oldWidth */) {
      var fieldID = null;
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == columnName) {
            fieldID = this._fields[i].id;
            break;
            // this._fields[i].settings.width = newWidth;
         }
      }

      // Johnny: This is better but still not right.  the ABObject should not be
      // storing sizes for field widths.  That is a function of the UI and which
      // Grid is being displayed.  THAT GRID should be storing a column width
      // locally.
      // TODO: once we have v2 in place.

      var fieldSettings = this.AB.localSettings(fieldID);
      fieldSettings = fieldSettings || {};
      fieldSettings.width = newWidth;

      return this.AB.localSettings(fieldID, fieldSettings);
      // return this.save();
   }

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      summaryColumns = summaryColumns || [];
      countColumns = countColumns || [];

      var headers = [];
      // var columnNameLookup = {};

      // get the header for each of our fields:
      this.fields().forEach((f) => {
         var header = f.columnHeader({
            isObjectWorkspace: isObjectWorkspace,
            editable: isEditable,
         });

         if (isEditable) {
            header.validationRules = f.settings.validationRules;
         }

         header.alias = f.alias || undefined; // query type
         header.fieldID = f.id;
         // header.fieldURL = f.urlPointer();

         // if the field specifies a width
         if (f.settings.width != 0) {
            header.width = f.settings.width;
         }

         // if the User has already updated a local width for this
         var fieldSettings = this.AB.localSettings(f.id);
         if (fieldSettings && fieldSettings.width) {
            if (!header.width || fieldSettings.width > header.width) {
               // set column width to the customized width
               header.width = fieldSettings.width;
            }
         }

         if (!header.width) {
            // set column width to adjust:true by default;
            header.adjust = true;
         }

         // add the summary footer
         if (summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula") {
               header.footer = { content: "totalColumn", field: f };
            } else {
               header.footer = { content: "summColumn" };
            }
         }
         // add the count footer
         else if (countColumns.indexOf(f.id) > -1)
            header.footer = { content: "countColumn" };

         headers.push(header);
         // columnNameLookup[header.id] = f.columnName; // name => id
      });

      // update our headers with any settings applied in the Object Workspace
      /*
      // In v2: this is handled by the ABDesigner
      //
      if (isObjectWorkspace) {
         let hiddenFieldList = [];

         if (hiddenFieldNames && hiddenFieldNames.length > 0)
            hiddenFieldList = hiddenFieldNames;
         // else if (this.workspaceHiddenFields)
         //    hiddenFieldList = this.workspaceHiddenFields;

         if (hiddenFieldList.length > 0) {
            hiddenFieldList.forEach((hfID) => {
               headers.forEach((h) => {
                  if (columnNameLookup[h.id] == hfID) {
                     h.hidden = true;
                  }
               });
            });
         }
      }
      */

      return headers;
   }

   // after a component has rendered, tell each of our fields to perform
   // any custom display operations
   // @param {Webix.DataStore} data a webix datastore of all the rows effected
   //        by the render.
   customDisplays(data, App, DataTable, rowIds, isEditable) {
      if (!data || !data.getFirstId) return;

      // var fields = this.fields(f => this.workspaceHiddenFields.indexOf(f.columnName) < 0);
      let fields = [];
      DataTable.eachColumn((columnName) => {
         let field = this.fields((f) => f.columnName == columnName)[0];
         if (field) fields.push(field);
      });

      if (rowIds != null) {
         rowIds.forEach((id) => {
            let row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  let node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
         });
      } else {
         let id = data.getFirstId();
         while (id) {
            var row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  var node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
            id = data.getNextId(id);
         }
      }
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = `{${defaultField.id}}`;
         else
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`; // show id of row
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   currentView() {
      console.error("ABObject.currentView(): who is calling this?");
      return null;
      // return this.workspaceViews.getCurrentView();
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.fields().forEach((f) => {
         allWarnings = allWarnings.concat(f.warnings());
      });

      this.indexes().forEach((i) => {
         allWarnings = allWarnings.concat(i.warnings());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allFields = this.fields();

      if (allFields.length == 0) {
         this.warningsMessage("has no fields");
      }

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      (this._unknownIndex || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown index id[${id}]`);
      });

      allFields.forEach((f) => {
         f.warningsEval();
      });

      this.indexes().forEach((i) => {
         i.warningsEval();
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Object[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
      // this.emit("warning", warnMsg, data);
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
}


/***/ }),

/***/ 18700:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectExternal.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectExternal)
/* harmony export */ });
/* harmony import */ var _ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObject */ 83311);


/**
 * ABObjectExternal
 * These are ABObjects that ... (might need to be refactored out?)
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectExternal extends _ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 94910:
/*!******************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectImport.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectImport)
/* harmony export */ });
/* harmony import */ var _ABObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABObject */ 83311);


/**
 * ABObjectImport
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
class ABObjectImport extends _ABObject__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ 59545:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABObjectQuery.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABObjectQuery)
/* harmony export */ });
/* harmony import */ var _core_ABObjectQueryCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABObjectQueryCore */ 20391);
//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//



var ABFactory = null;
if (typeof io != "undefined") {
   io.socket.on("ab.query.update", function (msg) {
      if (ABFactory) {
         ABFactory.emit("ab.query.update", {
            queryId: msg.queryId,
            data: msg.data,
         });
      } else {
         console.error(
            "ABObjectQuery:: received io.socket msg before ABFactory is defined"
         );
         console.error("TODO: move this to ABFactory!");
      }
   });
} else {
   console.error("TODO: install socket.io client for sails updates.");
}

// io.socket.on("ab.query.delete", function (msg) {
// });

class ABObjectQuery extends _core_ABObjectQueryCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      if (!ABFactory) {
         ABFactory = AB;
      }
      // listen
      this.AB.on("ab.query.update", (data) => {
         if (this.id == data.queryId) this.fromValues(data.data);
      });

      // .fromValues() should already have been called in super()
      // so now add in our conditionScan()
      // NOTE: this can be folded into the Core once filterComplex
      // is fully implemented and not on Platform only.

      // now scan our conditions to make sure they are
      // 1) reference fields that exist in our Query
      // 2) completely filled out conditions.
      this.conditionScan(this.where);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObjectQuery
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   // destroy() {
   //    return super.destroy().then(() => {
   //       console.error("Move .queryRemove() to Appbuilder Designer.");
   //       // return this.AB.queryRemove(this);
   //    });
   // }

   /**
    * @method save()
    *
    * persist this instance of ABObjectQuery with it's parent ABApplication
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   // async save() {
   //    try {
   //       await super.save();
   //       return this;
   //    } catch (err) {
   //       this.AB.notify.developer(err, {
   //          context: "ABObjectQuery.save()",
   //          query: this.toObj(),
   //       });
   //       throw err;
   //    }
   // }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    *             { }
    * @param {bool} shouldAliasColumn
    *        should we add the object alias to the columnNames?
    *        this is primarily used on the web client
    */
   importFields(fieldSettings) {
      super.importFields(fieldSettings);

      this._fields.forEach((fieldEntry) => {
         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         fieldEntry.field.columnName = `${fieldEntry.alias}.${fieldEntry.field.columnName}`;
      });
   }

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth, oldWidth) {
      let field = this.fields((f) => f.columnName == columnName)[0];
      if (field) {
         field.settings.width = newWidth;

         return this.save();
      } else {
         return Promise.resolve();
      }
   }

   ///
   /// Working with Client Components:
   ///

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      var headers = super.columnHeaders(
         isObjectWorkspace,
         isEditable,
         summaryColumns,
         countColumns,
         hiddenFieldNames
      );

      headers.forEach((h) => {
         // pull object by alias
         let object = this.objectByAlias(h.alias);
         if (!object) return;

         let field = object.fieldByID(h.fieldID);
         if (!field) return;

         // NOTE: query v1
         let alias = "";
         if (Array.isArray(this.joins())) {
            alias = field.object.name;
         } else {
            alias = h.alias;
         }

         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         h.id = `${alias}.${field.columnName}`;

         // label
         if (this.settings && this.settings.hidePrefix) {
            h.header = `${field.label || ""}`;
         } else {
            h.header = `${field.object.label || ""}.${field.label || ""}`;
         }

         // icon
         if (field.settings && field.settings.showIcon) {
            h.header = `<span class="webix_icon fa fa-${field.fieldIcon()}"></span>${
               h.header
            }`;
         }

         // If this query supports grouping, then add folder icon to display in grid
         if (this.isGroup) {
            let originTemplate = h.template;

            h.template = (item, common) => {
               if (item[h.id])
                  return (
                     common.icon(item, common) +
                     (originTemplate
                        ? originTemplate(item, common, item[h.id])
                        : item[h.id])
                  );
               else return "";
            };
         }

         h.adjust = true;
         h.minWidth = 220;
      });

      return headers;
   }

   /**
    * @method conditionScan()
    * Scan the provided condition object and determine if there are any
    * configuration issues.
    * @param {obj} rule
    *        the QueryBuilder rule that we are scanning.
    * @param {array} listWarnings
    *        An array of warnings that we should add our notices to.
    */
   conditionScan(rule) {
      if (!rule) {
         return;
      }

      if (rule.glue) {
         (rule.rules || []).forEach((r) => {
            this.conditionScan(r);
         });
         return;
      }

      // 1) we need to have any key as one of our fields.
      let field = this.fieldByID(rule.key);
      if (!field && rule.key != "this_object") {
         this.warningsMessage(
            "condition does not reference one of our fields",
            {
               rule,
            }
         );
      }

      // 2) completely filled out conditions.
      if (!this._conditionCheck) {
         this._conditionCheck = this.AB.filterComplexNew(
            `${this.id}_conditionCheck`
         );
         // {FilterComplex} ._conditionCheck
         // has our .isConditionComplete() method.
      }
      if (!this._conditionCheck.isConditionComplete(rule)) {
         this.warningsMessage("incomplete condition definition", {
            rule,
         });
      }
   }

   warningsEval() {
      super.warningsEval();

      this.conditionScan(this.where);

      /// include importFields() warnings:
      this.__missingObject.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: could not resolve object[${
               f.objectID
            }] for fieldSetting ${JSON.stringify(f)}`,
            {
               fieldInfo: f,
            }
         );
      });

      this.__missingFields.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: Object[${f.objID}] could not find field[${
               f.fieldID
            }] for fieldSetting ${JSON.stringify(f.fieldInfo)}`,
            {
               object: f.objID,
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__cantFilter.forEach((f) => {
         this.warningsMessage(
            `Field[${f.field.id}] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] did not pass .canFilterField`,
            {
               field: f.field.toObj(),
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__duplicateFields.forEach((f) => {
         this.warningsMessage(
            `Field[${
               f.fieldInfo.fieldID
            }] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] is a duplicate`,
            {
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__linkProblems.forEach((f) => {
         this.warningsMessage(f.message, f.data);
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Query[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
}


/***/ }),

/***/ 33046:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABProcess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcess)
/* harmony export */ });
/* harmony import */ var _core_ABProcessCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABProcessCore */ 44166);


class ABProcess extends _core_ABProcessCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      this._unknownShapes = [];
      // {array} [ BPMN:Shape, ... ]
      // Generic Shapes that are added to the Process are registered here.
      // We will list these as warnings to the ABDesigner.

      // listen
      this.AB.on("ab.abprocess.update", (data) => {
         if (this.id == data.objectId) this.fromValues(data.data);
      });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // remove all my Elements
      var allElements = this.elements();
      var allDestroy = [];
      allElements.forEach((e) => {
         allDestroy.push(e.destroy());
      });

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  // allow normal processing to contine now:
                  resolve();
               })
               .then(() => {
                  // in the background
                  // remove this reference from ALL Applications that link
                  // to me:
                  console.error(
                     "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
                  );
                  var appsWithProcess = this.AB.applications().find((a) => {
                     return a.hasProcess(this);
                  });
                  if (appsWithProcess.length > 0) {
                     appsWithProcess.forEach((a) => {
                        a.processRemove(this);
                     });
                  }
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // if this is an update:
      // if (this.id) {
      // 	return ABDefinition.update(this.id, this.toDefinition());
      // } else {

      // 	return ABDefinition.create(this.toDefinition());
      // }

      // make sure all our tasks have save()ed.
      var allSaves = [];
      var allTasks = this.elements();
      allTasks.forEach((t) => {
         allSaves.push(t.save());
      });
      return Promise.all(allSaves).then(() => {
         // now we can save our Process definition
         return this.toDefinition()
            .save()
            .then((data) => {
               // if I didn't have an .id then this was a create()
               // and I need to update my data with the generated .id

               if (!this.id) {
                  this.id = data.id;
               }

               // Also, our embedded elements now all have .ids
               // where they might not have before.  So now
               // rebuild our this._elements hash with all id
               var _new = {};
               let _old = this._elements;
               Object.keys(this._elements).forEach((k) => {
                  _new[this._elements[k].id] = this._elements[k];
               });
               this._elements = _new;

               // check to see if an update happened and then make
               // sure we have that saved.
               let needSave = false;
               Object.keys(_new).forEach((k) => {
                  if (!_old[k]) {
                     needSave = true;
                  }
               });

               if (needSave) {
                  return this.save();
               }
            });
      });
   }

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.processes((o) => {
            return o.name.toLowerCase() == this.name.toLowerCase();
         }).length == 0;
      if (!isNameUnique) {
         let L = this.AB.Label();
         validator.addError(
            "name",
            L(`Process name must be unique ("{0}" already in use)`, [this.name])
         );
      }

      return validator;
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcess[OBJ]}
    */
   elementNewForModelDefinition(element) {
      var task = this.AB.processElementNewForModelDefinition(element, this);
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   /**
    * @method unknownShape()
    * store a reference to a BPMN Shape that is in our XML diagram,
    * but we don't have an element for.
    * @param {BPMN:Shape} shape
    */
   unknownShape(shape) {
      this.unknownShapeRemove(shape);
      this._unknownShapes.push(shape);
   }

   /**
    * @method unknownShapeRemove()
    * make sure we no longer track the provided BPMN Shape as an unknown shape.
    * @param {BPMN:Shape} shape
    */
   unknownShapeRemove(shape) {
      this._unknownShapes = this._unknownShapes.filter((s) => s.id != shape.id);
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = [].concat(this._warnings);
      this.elements().forEach((e) => {
         e.warningsEval();
         allWarnings = allWarnings.concat(e.warnings());
      });

      if (this.elements().length == 0) {
         allWarnings.push({ message: "No process Tasks defined.", data: {} });
      }

      // perform a check of our xml document to see if we have any unknown
      // shapes
      if (!this._DOMParser) {
         if (window.DOMParser) {
            // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
            this._DOMParser = function (xmlStr) {
               return new window.DOMParser().parseFromString(
                  xmlStr,
                  "text/xml"
               );
            };
         } else if (
            typeof window.ActiveXObject != "undefined" &&
            new window.ActiveXObject("Microsoft.XMLDOM")
         ) {
            this._DOMParser = function (xmlStr) {
               var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
               xmlDoc.async = "false";
               xmlDoc.loadXML(xmlStr);
               return xmlDoc;
            };
         } else {
            throw new Error("No XML parser found");
         }
      }

      // find any references to our generic shapes
      let xml = this._DOMParser(this.xmlDefinition);
      const genericShapes = [
         "bpmn2:startEvent",
         "bpmn2:task",
         "bpmn2:endEvent",
      ];
      genericShapes.forEach((s) => {
         let allElements = xml.getElementsByTagName(s);
         for (let x = 0; x < allElements.length; x++) {
            // if we don't know about this shape
            let ele = allElements[x];
            let myEle = this.elementForDiagramID(allElements[x].id);
            if (!myEle) {
               this.unknownShape(allElements[x]);
            }
         }
      });

      // if any unknown shapes have been reported:
      if (this._unknownShapes.length) {
         allWarnings.push({
            message: "Generic Tasks still undefined.",
            data: {},
         });
      }

      return allWarnings;
   }
}


/***/ }),

/***/ 81410:
/*!**********************************************!*\
  !*** ./src/js/AppBuilder/platform/ABStep.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABStep)
/* harmony export */ });
/* harmony import */ var _core_ABStepCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABStepCore */ 53618);


// let L = (...params) => AB.Multilingual.label(...params);

class ABStep extends _core_ABStepCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // debugger;

      return new Promise((resolve, reject) => {
         this.toDefinition()
            .destroy()
            .then(() => {
               resolve();
            })
            .catch((err) => {
               reject(err);
            });
      });

      // remove all my Elements
      // var allElements = this.elements();
      // var allDestroy = [];
      // allElements.forEach((e) => {
      //    allDestroy.push(e.destroy());
      // });

      // return Promise.all(allDestroy).then(() => {
      //    // now remove myself
      //    return new Promise((resolve, reject) => {
      //       this.toDefinition()
      //          .destroy()
      //          .then(() => {
      //             // allow normal processing to contine now:
      //             resolve();
      //          })
      //          .then(() => {
      //             // in the background
      //             // remove this reference from ALL Applications that link
      //             // to me:
      //             console.error(
      //                "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
      //             );
      //             var appsWithProcess = this.AB.applications().find((a) => {
      //                return a.hasProcess(this);
      //             });
      //             if (appsWithProcess.length > 0) {
      //                appsWithProcess.forEach((a) => {
      //                   a.processRemove(this);
      //                });
      //             }
      //          })
      //          .catch((err) => {
      //             reject(err);
      //          });
      //    });
      // });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      // debugger;
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }
}


/***/ }),

/***/ 67348:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/ABViewManager.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewManager)
/* harmony export */ });
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ABViewManagerCore */ 85642);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__]);
_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


class ABViewManager extends _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_0__["default"] {}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 10758:
/*!*****************************************************!*\
  !*** ./src/js/AppBuilder/platform/FilterComplex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilterComplex)
/* harmony export */ });
/* harmony import */ var _core_FilterComplexCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/FilterComplexCore */ 89391);


/**
 * @function _toInternal()
 * translate our external QB conditions into our internal format that
 * makes the cond.rule unique by adding the field.id to the rule.
 * @param {obj} cond - {
 *                         rules: [
 *                            {
 *                               alias: string || undefined,
 *                               key: uuid,
 *                               rule: string,
 *                               value: object,
 *                            }
 *                         ]
 *                      }
 *        the QB condition format we use exernally in our AB system.
 */
function _toInternal(cond, fields = []) {
   if (!cond) return;
   if (cond.key) {
      // Convert to format
      // {
      //    glue: "and",
      //    rules: [
      //       {
      //          field: "test_col",
      //          condition: { type: "greater", filter: 100 },
      //       },
      //    ],
      // }
      const field = fields.filter((f) => f.id == cond.key)[0];
      cond.field = field?.id;

      cond.condition = {
         type: cond.rule,
         filter: cond.value,
      };

      if (Array.isArray(cond.value)) cond.includes = cond.value;
      else cond.includes = (cond.value ?? "").split(",");

      if (field?.key == "date" || field?.key == "datetime") {
         cond.condition.filter = cond.condition.filter
            ? AB.rules.toDate(cond.condition.filter)
            : null;

         cond.includes = cond.includes.map((v) => AB.rules.toDate(v));
      }

      delete cond.key;
      delete cond.rule;
      delete cond.value;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toInternal(r, fields);
      });
   }
}

/**
 * @function _toExternal()
 * translate our internal QB conditions into our external format that
 * where the cond.rule no longer has the field.id.
 * @param {obj} cond - {
 *                         glue: "and",
 *                         rules: [
 *                            {
 *                               field: "test_col",
 *                               condition: { type: "greater", filter: 100 },
 *                            },
 *                         ],
 *                      }
 *        the QB condition format we use internally
 */
function _toExternal(cond, fields = []) {
   if (!cond) return;
   if (cond.field) {
      let field = fields.filter((f) => f.id == cond.field)[0];
      // cond.alias = alias || undefined;
      cond.key = field?.id ?? cond.field;
      cond.condition = cond.condition ?? {};
      cond.rule = cond.condition.type;

      let values =
         cond.includes.map((v) => (v instanceof Date ? v.toISOString() : v)) ??
         [];

      // Convert multi-values to a string
      if (cond.condition.filter) {
         if (cond.condition.filter instanceof Date) {
            if (values.indexOf(cond.condition.filter.toISOString()) < 0) {
               values.push(cond.condition.filter);
            }
         } else if (values.indexOf(cond.condition.filter) < 0)
            values.push(cond.condition.filter);
      }

      cond.value = values
         .map((v) => {
            // Convert date format
            if (field && (field.key == "date" || field.key == "datetime"))
               return field.exportValue(new Date(v));

            return v;
         })
         .join(",");

      delete cond.field;
      delete cond.type;
      delete cond.includes;
      delete cond.condition;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toExternal(r, fields);
      });
   }
}

class FilterComplex extends _core_FilterComplexCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB, options = {}) {
      idBase = idBase ?? "ab_filterComplex";

      super(idBase, AB);

      let L = this.AB.Label();

      this._options = options ?? {};

      this._initComplete = false;
      // {bool}
      // trying to prevent multiple .init() from being called due to
      // various ways of initializing the component.

      this.observing = false;
      // {bool}
      // try to prevent multiple observers generating >1 "changed"
      // event.

      let labels = (this.labels = {
         common: (AB._App ?? {}).labels,
         component: {
            // and: L("And"),
            // or: L("Or"),
            // thisObject: L("This Object"),
            // inQuery: L("In Query"),
            // notInQuery: L("Not In Query"),
            // inQueryField: L("By Query Field"),
            // notInQueryField: L("Not By Query Field"),
            // inQueryFieldQueryPlaceholder: L("Choose a Query"),
            // inQueryFieldFieldPlaceholder: L("Choose a Field"),
            // sameAsUser: L("Same As User"),
            // notSameAsUser: L("Not Same As User"),
            // sameAsField: L("Same As Field"),
            // notSameAsField: L("Not Field"),
            // inDataCollection: L("In Data Collection"),
            // notInDataCollection: L("Not In Data Collection"),
            // containsCondition: L("contains"),
            // notContainsCondition: L("doesn't contain"),
            // isCondition: L("is"),
            // isNotCondition: L("is not"),
            // isEmpty: L("is empty"),
            // isNotEmpty: L("is not empty"),
            // beforeCondition: L("is before"),
            // afterCondition: L("is after"),
            // onOrBeforeCondition: L("is on or before"),
            // onOrAfterCondition: L("is on or after"),
            // beforeCurrentCondition: L("is before current date"),
            // afterCurrentCondition: L("is after current date"),
            // onOrBeforeCurrentCondition: L("is on or before current date"),
            // onOrAfterCurrentCondition: L("is on or after current date"),
            // onLastDaysCondition: L("last ... days"),
            // onNextDaysCondition: L("next ... days"),
            // equalCondition: L(":"),
            // notEqualCondition: L("≠"),
            // lessThanCondition: L("<"),
            // moreThanCondition: L(">"),
            // lessThanOrEqualCondition: L("≤"),
            // moreThanOrEqualCondition: L("≥"),
            // equalListCondition: L("equals"),
            // notEqualListCondition: L("does not equal"),
            // checkedCondition: L("is checked"),
            // notCheckedCondition: L("is not checked"),
            // isCurrentUserCondition: L("is current user"),
            // isNotCurrentUserCondition: L("is not current user"),
            // containsCurrentUserCondition: L("contains current user"),
            // notContainsCurrentUserCondition: L("does not contain current user"),
            // contextDefaultOption: L("choose option"),
            // equalsProcessValue: L("equals process value"),
            // notEqualsProcessValueCondition: L("not equals process value"),
            // inProcessValueCondition: L("in process value"),
            // notInProcessValueCondition: L("not in process value"),
         },
      });

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         popup: this.unique(`${idBase}_popup`),
         querybuilder: this.unique(`${idBase}_querybuilder`),
         save: this.unique(`${idBase}_save`),
      });

      // Set current username
      this.Account.username = this.AB.Account.username();

      this._settings.recordRuleFieldOptions = [];

      // webix UI definition:
      // this.ui = {
      //    rows: [
      //       {
      //          view: "layout",
      //          type: "clean",
      //          borderless: this._options.borderless ?? true,
      //          rows: [
      //             {
      //                id: ids.querybuilder,
      //                view: "query",
      //                data: () => [],
      //                // data: async (field) => await this.pullOptions(field),
      //                fields: [],
      //                disabled: true,
      //                height: this._options.height,
      //             },
      //          ],
      //       },
      //       {
      //          id: ids.save,
      //          view: "button",
      //          css: "webix_primary",
      //          value: L("Save"),
      //          hidden: this._options.isSaveHidden ?? false,
      //          click: () => {
      //             if (this.myPopup) this.myPopup.hide();
      //             this.emit("save", this.getValue());
      //          },
      //       },
      //    ],
      // };
   }

   // setting up UI
   init(options) {
      if (this._initComplete) return;

      super.init(options);

      const el = $$(this.ids.querybuilder);

      if (el) {
         if (!this.observing) {
            this.__blockOnChange = true;
            el.getState().$observe("value", (v) => {
               if (this.__blockOnChange) return false;

               this.emit("changed", this.getValue());
            });
            this.__blockOnChange = false;

            // HACK!! The process of setting the $observe() is actually
            // calling the cb() when set.  This is clearing our .condition
            // if we call init() after we have setValues(). which can happen
            // when using the popUp() method.
            let _cond = this.condition;
            this.condition = _cond;
            this.observing = true;
         }
         this._initComplete = true;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      // let helper = () => true;

      // let $query = $$(this.ids.querybuilder);
      // if ($query) {
      //    helper = $query.getFilterFunction();
      //    return helper(rowData);
      // } else {
      return super.isValid(rowData, condition);
      // }
   }

   /**
    * @method isConditionComplete()
    * Check a given condition entry and indicate if it is fully
    * filled out.
    * @param {obj} cond
    *        The Condition object we are checking.  If a Macro
    *        condition if provided: { glue:"and", rules:[] } then
    *        this method will return True/False if All rules are
    *        complete.
    *        If an individual rule is provided, then it evaluates
    *        the completness of that rule. { key, rule, value }
    * @return {bool}
    */
   isConditionComplete(cond) {
      if (!cond) return false;

      let isComplete = true;
      // start optimistically.

      if (cond.glue) {
         (cond.rules ?? []).forEach((r) => {
            isComplete = isComplete && this.isConditionComplete(r);
         });
      } else {
         // every condition needs a .key & .rule
         if (!cond.key || cond.key == "") {
            isComplete = false;
         }

         if (!cond.rule || cond.rule == "") {
            isComplete = false;
         }

         if (isComplete) {
            switch (cond.rule) {
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
               case "same_as_user":
               case "not_same_as_user":
               case "less_current":
               case "greater_current":
               case "less_or_equal_current":
               case "greater_or_equal_current":
               case "is_empty":
               case "is_not_empty":
                  // There are only a few rules that don't need a
                  // value
                  break;

               default:
                  // The rest do need a .value
                  if (!cond.value || cond.value == "") {
                     isComplete = false;
                  }
                  break;
            }
         }
      }

      return isComplete;
   }

   setValue(settings) {
      super.setValue(settings);
      this.condition = settings;

      // const el = $$(this.ids.querybuilder);
      // if (el) {
      //    if (!settings) {
      //       // Clear settings value of webix.query
      //       el.define("value", {
      //          glue: "and",
      //          rules: [],
      //       });
      //       return;
      //    }

      //    let qbSettings = this.AB.cloneDeep(settings);

      //    // Settings should match a condition built upon our QB format:
      //    // {
      //    //    glue:"and",
      //    //    rules:[
      //    //       {
      //    //          key:"uuid",
      //    //          rule:"",
      //    //          value:""
      //    //       }
      //    //    ]
      //    // }
      //    // externally our key should be the field.id and the rules should be
      //    // the "contains", "not_contains", "equal" ... keywords.
      //    // However, internally, we convert these rules into .ids that are
      //    // unique for each field (see uiInit()).  So when we bring in settings
      //    // we need to translate them into our internal format:

      //    _toInternal(qbSettings, this._Fields);

      //    this.__blockOnChange = true;
      //    el.define("value", qbSettings);
      //    this.__blockOnChange = false;
      // }
   }

   getValue() {
      // if ($$(this.ids.querybuilder)) {
      //    let settings = this.AB.cloneDeep(
      //       $$(this.ids.querybuilder).getState().value ?? {}
      //    );

      //    // what we pull out of the QB will have .rules in our internal format:
      //    // {field.id}_{rule}  (see uiInit() )
      //    // But we need to store them in our generic QB format for use outside
      //    // our FilterComplex widget.
      //    _toExternal(settings, this._Fields);
      //    this.condition = settings;
      // }

      return super.getValue();
   }

   fieldsLoad(fields = [], object = null) {
      super.fieldsLoad(fields, object);
      console.log("TODO: How to handle FilterComplex's dependence on webix?");
      // this.uiInit();
   }

   toShortHand() {
      return "Add Filters";
   }

   uiInit() {
      this.uiQueryCustomValue();

      let el = $$(this.ids.querybuilder);
      if (el) {
         // Clear fields
         while (el.config.fields.length > 0) {
            el.config.fields.pop();
         }
         // Set fields
         (this.fieldsToQB() ?? []).forEach((f) => {
            el.config.fields.push(f);
         });
         if (el.config.fields.length) {
            el.enable();
         } else {
            this.setValue("");
            el.disable();
         }
      }
   }

   // HACK: have to overwrite Webix Query's function to support our custom input requirement.
   // HooWoo
   uiQueryCustomValue() {
      const $el = $$(this.ids.querybuilder);
      if (!$el) return;

      // window.query.views.filter.prototype.CreateFilter = (
      $el.$app.require("jet-views", "filter").prototype.CreateFilter = (
         field,
         type,
         format,
         conditions,
         place
      ) => {
         let inputs = this.uiValue(field);

         let ui = {
            id: place.config.id,
            view: "filter",
            localId: "filter",
            conditions: conditions,
            field: field,
            mode: type,
            template: function (o) {
               let str = o[field];
               let parser =
                  format ?? (type == "date" ? webix.i18n.dateFormatStr : null);
               if (parser) str = parser(str);
               return str;
            },
            inputs: inputs,
            margin: 6,
         };

         let filter = webix.ui(ui, place);

         // let data = [];
         // const $query = $$(this.ids.querybuilder);
         // if ($query) {
         //    data = $query.app.getService("backend").data(field);
         // }
         // filter.parse(data);

         return filter;
      };
   }

   uiValue(fieldColumnName) {
      let result;

      // Special case: this_object
      if (fieldColumnName == "this_object") {
         return []
            .concat(this.uiQueryValue("this_object"))
            .concat(this.uiDataCollectionValue("this_object"))
            .concat(this.uiCustomValue("this_object"))
            .concat(this.uiContextValue("this_object", "uuid"));
      }

      let field = (this._Fields ?? []).filter(
         (f) => f.id == fieldColumnName
      )[0];

      switch (field?.key) {
         case "boolean":
            result = this.uiBooleanValue(field);
            break;
         case "connectObject":
            result = []
               .concat(this.uiQueryValue(field))
               .concat(this.uiUserValue(field))
               .concat(this.uiDataCollectionValue(field))
               .concat(this.uiContextValue(field))
               .concat(this.uiNoneValue());
            break;
         case "date":
         case "datetime":
            result = ["datepicker", "daterangepicker"];
            break;
         case "list":
            result = this.uiListValue(field);
            break;
         case "user":
            result = []
               .concat(this.uiNoneValue())
               .concat(this.uiUserValue(field));
            break;
         // case "number":
         //    result = ["text"];
         //    break;
         case "string":
         case "LongText":
         case "email":
            result = this.uiNoneValue();
            break;
      }

      // Add filter options to Custom index
      const LinkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      if (
         field?.settings?.isCustomFK &&
         // 1:M
         (LinkType == "one:many" ||
            // 1:1 isSource = true
            (LinkType == "one:one" && field?.settings?.isSource))
      ) {
         result = (result ?? []).concat(this.uiTextValue(field));
      } else if (field?.key != "connectObject") {
         result = (result ?? [])
            .concat(this.uiTextValue(field))
            .concat(this.uiQueryFieldValue(field))
            .concat(this.uiContextValue(field));
      }
      // Special case: from Process builder
      // .processFieldsLoad()
      else if (fieldColumnName.indexOf("uuid") > -1) {
         result = this.uiContextValue(null, fieldColumnName);
      }

      if (this._settings.isRecordRule) {
         result = (result ?? []).concat(this.uiRecordRuleValue(field));
      }

      result = (result ?? []).concat(this.uiCustomValue(field));

      return result;
   }

   uiNoneValue() {
      return [
         {
            batch: "none",
            borderless: true,
            view: "template",
            template: "",
         },
      ];
   }

   uiBooleanValue(field) {
      return [
         {
            batch: "boolean",
            view: "checkbox",
         },
      ];
   }

   uiTextValue(field) {
      return [
         {
            batch: "text",
            view: "text",
            on: {
               onAfterRender: function () {
                  // HACK: focus on webix.text and webix.textarea
                  // Why!! If the parent layout has zIndex lower than 101,
                  // then is not able to focus to webix.text and webix.textarea
                  let $layout =
                     this.queryView(function (a) {
                        return !a.getParentView();
                     }, "parent") ?? this;
                  $layout.$view.style.zIndex = 202;
               },
            },
         },
      ];
   }

   uiQueryValue(field) {
      let options = [];

      let isQueryField =
         this._QueryFields?.filter((f) => f.id == field.id).length > 0;

      // populate the list of Queries for this_object:
      if (field == "this_object" && this._Object) {
         options = this.queries((q) => q.canFilterObject(this._Object));
      }
      // populate the list of Queries for a query field
      else if (isQueryField) {
         options = this.queries(
            (q) =>
               (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
               q.canFilterObject(field.datasourceLink)
         );
      }

      options?.forEach((q) => {
         options.push({
            id: q.id,
            value: q.label,
         });
      });

      return [
         {
            batch: "query",
            view: "combo",
            options: options ?? [],
         },
      ];
   }

   uiListValue(field) {
      return [
         {
            batch: "list",
            view: "combo",
            options: field?.settings?.options?.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            }),
         },
      ];
   }

   uiUserValue(field) {
      return [
         {
            batch: "user",
            view: "combo",
            options: this.AB.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            }),
         },
      ];
   }

   uiDataCollectionValue(field) {
      let linkObjectId;
      if (field == "this_object" && this._Object) {
         linkObjectId = this._Object.id;
      } else {
         linkObjectId = field?.settings?.linkObject;
      }

      return [
         {
            batch: "datacollection",
            view: "combo",
            options: linkObjectId
               ? this.AB.datacollections(
                    (dc) => dc?.datasource?.id == linkObjectId
                 ).map((dc) => {
                    return {
                       id: dc.id,
                       value: dc.label,
                    };
                 })
               : [],
         },
      ];
   }

   uiQueryFieldValue(field) {
      return [
         {
            batch: "queryField",
            view: "combo",
            placeholder: this.labels.component.inQueryFieldQueryPlaceholder,
            options: this.queries(
               (q) => this._Object == null || q.id != this._Object.id
            ).map((q) => {
               return {
                  id: q.id,
                  value: q.label,
               };
            }),
         },
      ];
   }

   uiRecordRuleValue(field) {
      return [
         {
            batch: "recordRule",
            view: "select",
            options: this._settings.recordRuleFieldOptions ?? [],
         },
      ];
   }

   uiContextValue(field, processFieldKey = null) {
      let L = this.AB.Label();
      const processFields = (this._ProcessFields ?? [])
         .filter((pField) => {
            if (!pField) return false;

            let result = false;
            switch (field) {
               case "this_object":
                  result =
                     this._Object.id === pField.object?.id && !pField.field;

                  break;

               default:
                  switch (field.key) {
                     case "boolean":
                        result = ["boolean"].includes(pField.field?.key);

                        break;

                     case "connectObject":
                        result =
                           field.settings.linkObject ===
                           (pField.field?.object.id ?? pField.object.id);

                        if (!field.settings.isCustomFK) {
                           result = result && !pField.field;

                           break;
                        }

                        result =
                           result &&
                           (field.settings.indexField ||
                              field.settings.indexField2) === pField.field?.id;

                        break;

                     case "date":
                     case "datetime":
                        result = ["date", "datetime"].includes(
                           pField.field?.key
                        );

                        break;

                     case "calculate":
                     case "formula":
                     case "number":
                        result = ["calculate", "formula", "number"].includes(
                           pField.field?.key
                        );

                        break;

                     case "string":
                     case "LongText":
                     case "email":
                     case "AutoIndex":
                     case "list":
                        result = [
                           "string",
                           "LongText",
                           "email",
                           "AutoIndex",
                           "list",
                        ].includes(pField.field?.key);

                        break;

                     case "user":
                        result = ["user"].includes(pField.field?.key);

                        break;

                     default:
                        if (pField.key) {
                           // uuid
                           const processFieldId = pField.key.split(".").pop();

                           result =
                              processFieldId === field.id ||
                              processFieldId === field.key ||
                              processFieldId === processFieldKey ||
                              pField.key === processFieldKey;
                        }

                        break;
                  }

                  break;
            }

            return result;
         })
         .map((e) => {
            return {
               id: e.key,
               value: L("context({0})", [e.label]),
            };
         });

      if (!processFields) return [];

      return [
         {
            batch: "context",
            view: "select",
            options: [
               {
                  id: "empty",
                  value: this.labels.component.contextDefaultOption,
               },
               ...processFields,
            ],
         },
      ];
   }

   uiCustomValue(field) {
      if (!field) return [];

      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id ?? field] ?? {};
      return options.values ?? [];
   }

   popUp(...options) {
      const condition = Object.assign({}, this.condition);

      if (!this.myPopup) {
         let ui = {
            id: this.ids.popup,
            view: "popup",
            height: 400,
            width: 800,
            body: this.ui,
         };

         if (!$$(this.ids.popup)) {
            this.myPopup = webix.ui(ui);
            this.init(this._settings);
            if (this._Fields) {
               this.fieldsLoad(this._Fields, this._Object);
            }

            // NOTE: do this, before the .setValue() operation, as we need to have
            // our fields and filters defined BEFORE a setValue() is performed.
            // this.uiInit();

            if (condition) {
               this.setValue(condition);
            }

            this.myPopup.show(...options);
         } else {
            $$(this.ids.popup).show(...options);
         }
      } else {
         this.myPopup.show(...options);
      }
   }

   /**
    * @method addCustomOption
    *
    * @param {string|uuid} fieldId
    * @param {Object} options - {
    *                               conditions: [],
    *                               values: []
    *                           }
    */
   addCustomOption(fieldId, options = {}) {
      this._customOptions = this._customOptions ?? {};
      this._customOptions[fieldId] = options;
   }
}


/***/ }),

/***/ 84470:
/*!*************************************************!*\
  !*** ./src/js/AppBuilder/platform/RowFilter.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RowFilter)
/* harmony export */ });
/* harmony import */ var _core_RowFilterCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/RowFilterCore */ 51509);


class RowFilter extends _core_RowFilterCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(App, idBase, AB) {
      super(App, idBase, AB);

      console.error("TODO: Switch RowFilter => FilterComplex");

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         component: this.unique(`${idBase}_rowFilter`),
         filterForm: this.unique(`${idBase}_rowFilter_form`),
         addNewFilter: this.unique(`${idBase}_rowFilter_addNewFilter`),

         glue: this.unique(`${idBase}_rowFilter_glue`),
         field: this.unique(`${idBase}_rowFilter_field`),
         rule: this.unique(`${idBase}_rowFilter_rule`),
         inputValue: this.unique(`${idBase}_rowFilter_inputValue`),

         queryCombo: this.unique(`${idBase}_rowFilter_queryCombo`),
         queryFieldCombo: this.unique(`${idBase}_rowFilter_queryFieldCombo`),
         queryFieldComboQuery: this.unique(
            `${idBase}_rowFilter_queryFieldComboQuery`
         ),
         queryFieldComboField: this.unique(
            `${idBase}_rowFilter_queryFieldComboField`
         ),
         fieldMatch: this.unique(`${idBase}_rowFilter_fieldMatchCombo`),

         dataCollection: this.unique(`${idBase}_rowFilter_dataCollection`),

         listOptions: this.unique(`${idBase}_rowFilter_listOptions`),

         datePicker: this.unique(`${idBase}_rowFilter_datePicker`),
      });

      // Set current username
      // this.Account.username = this.AB.Account.username();

      var batchName; // we need to revert to this default when switching away from a in/by query field

      let L = this.AB.Label();

      // Default options list to push to all fields
      this.queryFieldOptions = [
         {
            value: L("By Query Field"),
            id: "in_query_field",
         },
         {
            value: L("Not In Query"),
            id: "not_in_query_field",
         },
      ];

      this.recordRuleOptions = [];
      this.recordRuleFieldOptions = [];

      let _logic = this._logic || {};

      /**
       * @method getFieldList
       * return field list to render options
       */
      _logic.getFieldList = () => {
         return (this._Fields || []).map((f) => {
            let label = f.label;

            // include object's name to options
            if (this._settings.showObjectName && f.object) {
               label = f.object.label + "." + f.label;
            }

            return {
               id: f.id,
               value: label,
               alias: f.alias || undefined, // ABObjectQuery
            };
         });
      };

      _logic.getFilterUI = () => {
         let instance = this;
         let config_settings = this.config_settings || {};

         return {
            id: "f" + webix.uid(),
            isolate: true,
            cols: [
               {
                  // Add / Or
                  view: "combo",
                  id: ids.glue,
                  width: 80,
                  value: config_settings.glue || "and",
                  options: [
                     {
                        value: L("And"),
                        id: "and",
                     },
                     {
                        value: L("Or"),
                        id: "or",
                     },
                  ],
                  on: {
                     onChange: function (newVal, oldVal) {
                        _logic.selectCombineCondition(newVal);
                     },
                  },
               },
               {
                  // Field list
                  view: "combo",
                  id: ids.field,
                  suggest: {
                     on: {
                        onBeforeShow: function () {
                           this.define("width", 400);
                           this.resize();
                        },
                     },
                     data: _logic.getFieldList(),
                  },
                  on: {
                     onChange: function (columnId) {
                        var $viewCond = this.getParentView();
                        _logic.selectField(columnId, $viewCond);
                     },
                  },
               },
               // Comparer
               {
                  id: ids.rule,
                  width: 220,
                  cells: [
                     {},
                     // Query
                     {
                        batch: "query",
                        view: "combo",
                        value: "in_query",
                        options: [
                           {
                              value: L("In Query"),
                              id: "in_query",
                           },
                           {
                              value: L("Not In Query"),
                              id: "not_in_query",
                           },
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                           {
                              value: L("is empty"),
                              id: "is_empty",
                           },
                           {
                              value: L("is not empty"),
                              id: "is_not_empty",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                           {
                              value: L("In Data Collection"),
                              id: "in_data_collection",
                           },
                           {
                              value: L("Not In Data Collection"),
                              id: "not_in_data_collection",
                           },
                        ].concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },

                     // Date
                     {
                        batch: "date",
                        view: "combo",
                        value: "less",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("is before"),
                              id: "less",
                           },
                           {
                              value: L("is after"),
                              id: "greater",
                           },
                           {
                              value: L("is on or before"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("is on or after"),
                              id: "greater_or_equal",
                           },
                           {
                              value: L("is before current date"),
                              id: "less_current",
                           },
                           {
                              value: L("is after current date"),
                              id: "greater_current",
                           },
                           {
                              value: L("is on or before current date"),
                              id: "less_or_equal_current",
                           },
                           {
                              value: L("is on or after current date"),
                              id: "greater_or_equal_current",
                           },
                           {
                              value: L("last ... days"),
                              id: "last_days",
                           },
                           {
                              value: L("next ... days"),
                              id: "next_days",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L(":"),
                              id: "equals",
                           },
                           {
                              value: L("≠"),
                              id: "not_equal",
                           },
                           {
                              value: L("<"),
                              id: "less",
                           },
                           {
                              value: L(">"),
                              id: "greater",
                           },
                           {
                              value: L("≤"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("≥"),
                              id: "greater_or_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        value: "is_current_user",
                        options: [
                           {
                              value: L("is current user"),
                              id: "is_current_user",
                           },
                           {
                              value: L("is not current user"),
                              id: "is_not_current_user",
                           },
                           {
                              value: L("contains current user"),
                              id: "contain_current_user",
                           },
                           {
                              value: L("does not contain current user"),
                              id: "not_contain_current_user",
                           },
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               // Value
               {
                  id: ids.inputValue,
                  isolate: true,
                  cells: [
                     {
                        batch: "empty",
                     },

                     // Query
                     {
                        id: ids.queryCombo,

                        batch: "query",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Query Field
                     {
                        id: ids.queryFieldCombo,
                        batch: "queryField",
                        rows: [
                           {
                              id: ids.queryFieldComboQuery,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Query"),
                              on: {
                                 onChange: function (value) {
                                    var $viewComparer = this.getParentView();
                                    var $viewCond = $viewComparer
                                       .getParentView()
                                       .getParentView();
                                    _logic.onChangeQueryFieldCombo(
                                       value,
                                       $viewCond
                                    );

                                    _logic.onChange();
                                 },
                              },
                           },
                           {
                              id: ids.queryFieldComboField,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Field"),
                              on: {
                                 onChange: _logic.onChange,
                              },
                           },
                        ],
                     },

                     // Field match
                     {
                        id: ids.fieldMatch,
                        batch: "fieldMatch",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Data collection
                     {
                        id: ids.dataCollection,
                        batch: "dataCollection",
                        view: "richselect",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Date
                     {
                        // inputView.format = field.getDateFormat();
                        batch: "date",
                        id: ids.datePicker,
                        view: "datepicker",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "text",
                        validate: webix.rules.isNumber,
                        on: {
                           onTimedKeyPress: function () {
                              if (this.validate()) _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        id: ids.listOptions,
                        view: "combo",
                        options: [],
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "checkbox",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        options: this.AB.Account.userList().map((u) => {
                           return {
                              id: u.username,
                              value: u.username,
                           };
                        }),
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewForm = this.getFormView();

                     var indexView = $viewForm.index(this.getParentView());

                     _logic.addNewFilter(indexView + 1);
                  },
               },
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewCond = this.getParentView();

                     _logic.removeNewFilter($viewCond);
                  },
               },
            ],
         };
      };

      _logic.getAddButtonUI = () => {
         return {
            view: "button",
            id: ids.addNewFilter,
            css: "webix_primary",
            type: "form",
            label: L("Add a filter"),
            click: () => {
               _logic.addNewFilter();
            },
         };
      };

      _logic.addNewFilter = (index, fieldId) => {
         var viewId;
         var ui = _logic.getFilterUI();

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            viewId = $viewForm.addView(ui, index);

            _logic.toggleAddNewButton();

            // select a option of field
            if (fieldId) _logic.selectField(fieldId, $$(viewId), true);
         }

         return viewId;
      };

      _logic.removeNewFilter = function ($viewCond) {
         var $viewForm = $$(ids.filterForm);

         $viewForm.removeView($viewCond);

         _logic.toggleAddNewButton();

         _logic.onChange();
      };

      _logic.toggleAddNewButton = function () {
         if (!$$(ids.filterForm)) return;

         // Show "Add new filter" button
         if ($$(ids.filterForm).getChildViews().length < 1) {
            $$(ids.filterForm).hide();
            $$(ids.addNewFilter).show();
         }
         // Hide "Add new filter" button
         else {
            $$(ids.filterForm).show();
            $$(ids.addNewFilter).hide();
         }
      };

      _logic.selectCombineCondition = (val, ignoreNotify) => {
         // define combine value to configuration
         this.config_settings.glue = val;

         // update value of every combine conditions
         var $viewConds = $$(ids.filterForm).getChildViews();
         $viewConds.forEach((v) => {
            if (v.$$ && v.$$(ids.glue)) v.$$(ids.glue).setValue(val);
         });

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.selectField = (columnId, $viewCond, ignoreNotify) => {
         if (!this._Fields) return;

         var field = this._Fields.filter((f) => f.id == columnId)[0];
         if (!field) return;

         // switch view
         batchName = field.key;
         if (field.id == "this_object") batchName = "query";
         // Special this object query
         else if (batchName == "LongText" || batchName == "combined")
            batchName = "string";
         else if (field.key == "formula") batchName = "number";
         var isQueryField =
            this._QueryFields.filter((f) => {
               return f.id == field.id;
            }).length > 0;
         if (isQueryField) {
            // we chose a connectField which is now a Query type
            batchName = "query";
         }
         $viewCond.$$(ids.rule).showBatch(batchName);
         $viewCond.$$(ids.inputValue).showBatch(batchName);

         let options = [];
         let Queries = [];

         // populate the list of Queries for this_object:
         if (field.id == "this_object" && this._Object) {
            Queries = this.queries((q) => q.canFilterObject(this._Object));
         }
         // populate the list of Queries for a query field
         else if (isQueryField) {
            Queries = this.queries((q) => {
               return (
                  (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
                  q.canFilterObject(field.datasourceLink)
               );
            });
         }

         Queries.forEach((q) => {
            options.push({
               id: q.id,
               value: q.label,
            });
         });
         $viewCond
            .$$(ids.inputValue)
            .$$(ids.queryCombo)
            .define("options", options);
         $viewCond.$$(ids.inputValue).$$(ids.queryCombo).refresh();

         // populate options of list
         if (field.key == "list") {
            let listOptions = field.settings.options.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.listOptions)
               .define("options", listOptions);
            $viewCond.$$(ids.inputValue).$$(ids.listOptions).refresh();
         }
         // set format of datepicker
         else if (field.key == "date") {
            $viewCond
               .$$(ids.inputValue)
               .$$(ids.datePicker)
               .define("format", field.getFormat());
            $viewCond.$$(ids.inputValue).$$(ids.datePicker).refresh();
         }

         var rule = null,
            ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.getList) {
            let defaultOpt = ($viewComparer.getList().config.data || [])[0];
            if (defaultOpt) {
               $viewComparer.setValue(defaultOpt.id);
            }

            // rule = $viewComparer.getValue();
            // if (rule == "in_query_field" || rule == "not_in_query_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("queryField");
            // } else if (rule == "same_as_field" || rule == "not_same_as_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("fieldMatch");
            // }
         }

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.onChangeRule = (rule, $viewCond, notify = false) => {
         switch (rule) {
            case "contains":
            case "not_contains":
            case "equals":
            case "not_equal":
               // For "connect_fields" search by CUSTOM index value
               if (batchName == "query") {
                  $viewCond.$$(ids.inputValue).showBatch("string");
               }
               // If want to call notify or call .onChange(), then pass notify is true.
               // _logic.onChange();
               break;

            case "is_current_user":
            case "is_not_current_user":
            case "contain_current_user":
            case "not_contain_current_user":
            case "same_as_user":
            case "not_same_as_user":
            case "less_current":
            case "greater_current":
            case "less_or_equal_current":
            case "greater_or_equal_current":
            case "is_empty":
            case "is_not_empty":
               // clear and disable the value field
               $viewCond.$$(ids.inputValue).showBatch("empty");
               _logic.onChange();
               break;

            case "last_days":
            case "next_days":
               // Show the number input
               $viewCond.$$(ids.inputValue).showBatch("number");
               break;

            case "in_query_field":
            case "not_in_query_field":
               // populate the list of Queries for this_object:
               var options = [];

               // Get all application's queries
               this.queries(
                  (q) => this._Object == null || q.id != this._Object.id
               ).forEach((q) => {
                  options.push({
                     id: q.id,
                     value: q.label,
                  });
               });

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .define("options", options);
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("queryField");
               break;

            case "same_as_field":
            case "not_same_as_field":
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.fieldMatch)
                  .define("options", this.recordRuleFieldOptions);
               $viewCond.$$(ids.inputValue).$$(ids.fieldMatch).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("fieldMatch");
               break;

            case "in_data_collection":
            case "not_in_data_collection": {
               let dcOptions = [];

               // pull data collection list

               // get id of the link object
               let linkObjectId,
                  columnId = $viewCond.$$(ids.field).getValue();
               if (columnId == "this_object" && this._Object) {
                  linkObjectId = this._Object.id;
               } else {
                  let field = this._Fields.filter((f) => f.id == columnId)[0];
                  if (field) linkObjectId = field.settings.linkObject;
               }

               if (this._Application && linkObjectId) {
                  this._Application
                     .datacollections(
                        (dc) =>
                           dc.datasource && dc.datasource.id == linkObjectId
                     )
                     .forEach((dc) => {
                        dcOptions.push({
                           id: dc.id,
                           value: dc.label,
                        });
                     });
               }

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.dataCollection)
                  .define("options", dcOptions);
               $viewCond.$$(ids.inputValue).$$(ids.dataCollection).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("dataCollection");
               break;
            }

            default:
               // Show the default value inputs
               $viewCond.$$(ids.inputValue).showBatch(batchName);

               if (notify) _logic.onChange();

               break;
         }
      };

      _logic.onChangeQueryFieldCombo = (value, $viewCond) => {
         // populate the list of Queries for this_object:
         let options = [];
         // Get all queries fields
         let Query = this.queries((q) => {
            return q.id == value;
         })[0];
         if (Query) {
            Query.fields((f) => {
               return !f.isConnection;
            }).forEach((q) => {
               options.push({
                  id: q.id,
                  value: q.object.label + "." + q.label,
               });
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.queryFieldComboField)
               .define("options", options);
            $viewCond.$$(ids.inputValue).$$(ids.queryFieldComboField).refresh();
         }

         // _logic.onChange();
      };

      _logic.onChange = () => {
         if (!this.__blockOnChange) {
            // refresh config settings before notify
            _logic.getValue();

            console.warn("convert RowFilter.callback.onChange() to .emit()");
            _logic.callbacks.onChange();
            this.emit("change");
         }

         return false;
      };

      _logic.blockOnChange = () => {
         this.__blockOnChange = true;
      };

      _logic.unblockOnChange = () => {
         this.__blockOnChange = false;
      };

      /**
       * @method getValue
       *
       * @return {JSON} -
       * {
       * 		glue: '', // 'and', 'or'
       *		rules: [
       *			{
       *				key:	'column name',
       *				rule:	'rule',
       *				value:	'value'
       *			}
       *		]
       * }
       */
      _logic.getValue = () => {
         let config_settings = {
            glue: "and",
            rules: [],
         };

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            $viewForm.getChildViews().forEach(($viewCond, index) => {
               if (index == 0) {
                  config_settings.glue = $viewCond.$$(ids.glue).getValue();
               }

               var $fieldElem = $viewCond.$$(ids.field);
               if (!$fieldElem) return;

               /* field id */
               var fieldId = $fieldElem.getValue();
               if (!fieldId) return;

               /* alias */
               var alias;
               var selectedOpt = $viewCond
                  .$$(ids.field)
                  .getPopup()
                  .config.body.data.filter((opt) => opt.id == fieldId)[0];
               if (selectedOpt) alias = selectedOpt.alias || undefined;

               /* rule */
               var rule = null,
                  ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
                  $viewComparer = $viewCond
                     .$$(ids.rule)
                     .queryView({ id: ruleViewId });
               if ($viewComparer && $viewComparer.getValue)
                  rule = $viewComparer.getValue();

               /* value */
               var value = null,
                  valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
                  $viewConditionValue = $viewCond
                     .$$(ids.inputValue)
                     .queryView({ id: valueViewId });
               if ($viewConditionValue && $viewConditionValue.getValue) {
                  value = $viewConditionValue.getValue();
               } else if (
                  $viewConditionValue &&
                  $viewConditionValue.getChildViews()
               ) {
                  var vals = [];
                  $viewConditionValue.getChildViews().forEach((element) => {
                     vals.push($$(element).getValue());
                  });
                  value = vals.join(":");
               }

               // Convert date format
               if (value instanceof Date) {
                  let dateField = this._Fields.filter(
                     (f) => f.id == fieldId
                  )[0];
                  if (dateField) {
                     value = dateField.exportValue(value);
                  } else {
                     value = value.toISOString();
                  }
               }

               config_settings.rules.push({
                  alias: alias || undefined,
                  key: fieldId,
                  rule: rule,
                  value: value,
               });
            });
         }

         this.config_settings = config_settings;

         return this.config_settings;
      };

      // webix UI definition:
      this.ui = {
         id: ids.component,
         rows: [
            {
               view: "form",
               id: ids.filterForm,
               hidden: true,
               elements: [],
            },
            _logic.getAddButtonUI(),
         ],
      };
   }

   // setting up UI
   init(options = {}) {
      super.init(options);
      let L = this.AB.Label();

      // register our callbacks:
      for (var c in this._logic.callbacks) {
         this._logic.callbacks[c] = options[c] || this._logic.callbacks[c];
      }

      if (options.showObjectName)
         this._settings.showObjectName = options.showObjectName;

      if (options.isRecordRule) {
         this.recordRuleOptions = [
            {
               value: L("Same As Field"),
               id: "same_as_field",
            },
            {
               value: L("Not Field"),
               id: "not_same_as_field",
            },
         ];
         this.recordRuleFieldOptions = options.fieldOptions;
      }
   }

   setValue(settings) {
      settings = settings || {};

      super.setValue(settings);

      let ids = this.ids;
      let logic = this._logic;

      // block .onChange event
      logic.blockOnChange();

      let config_settings = this.AB.cloneDeep(settings);
      config_settings.rules = config_settings.rules || [];

      // Redraw form with no elements
      var $viewForm = $$(ids.filterForm);
      if ($viewForm) webix.ui([], $viewForm);

      // Add "new filter" button
      if (config_settings.rules.length == 0) {
         logic.toggleAddNewButton();
      }

      config_settings.rules.forEach((f) => {
         var viewId = logic.addNewFilter(),
            $viewCond = $$(viewId);

         if ($viewCond == null) return;

         var field = this._Fields.filter((col) => col.id == f.key)[0];

         // "and" "or"
         $viewCond.$$(ids.glue).define("value", config_settings.glue);
         $viewCond.$$(ids.glue).refresh();

         // Select Field
         $viewCond.$$(ids.field).define("value", f.key);
         $viewCond.$$(ids.field).refresh();
         logic.selectField(f.key, $viewCond, true);

         // Comparer
         var ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.setValue) {
            $viewComparer.define("value", f.rule);
            $viewComparer.refresh();
         }

         // if (f.rule == "in_query_field" || f.rule == "not_in_query_field" || f.rule == "same_as_field" || f.rule == "not_same_as_field") {
         $viewCond.blockEvent();
         logic.onChangeRule(f.rule, $viewCond);
         $viewCond.unblockEvent();
         // }

         // Input
         var valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
            $viewConditionValue = $viewCond
               .$$(ids.inputValue)
               .queryView({ id: valueViewId });
         if ($viewConditionValue && $viewConditionValue.setValue) {
            // convert to Date object
            if (
               field &&
               field.key == "date" &&
               f.value &&
               (f.rule == "less" ||
                  f.rule == "greater" ||
                  f.rule == "less_or_equal" ||
                  f.rule == "greater_or_equal")
            ) {
               $viewConditionValue.define("value", new Date(f.value));
            } else {
               $viewConditionValue.define("value", f.value);
            }

            $viewConditionValue.refresh();
         } else if (
            $viewConditionValue &&
            $viewConditionValue.getChildViews()
         ) {
            let vals = (f.value || "").split(":");
            let index = 0;
            $viewConditionValue.getChildViews().forEach((element) => {
               $$(element).blockEvent();
               $$(element).setValue(vals[index]);
               if (index == 0) {
                  logic.onChangeQueryFieldCombo(vals[index], $viewCond);
               }
               $$(element).unblockEvent();
               // $$(element).refresh();
               index++;
            });
         }

         if (field && field.key == "user") {
            $viewCond.blockEvent();
            logic.onChangeRule(f.rule, $viewCond);
            $viewCond.blockEvent();
         }
      });

      // unblock .onChange event
      logic.unblockOnChange();
   }

   /**
    * @method isComplete()
    * returns a truthy value representing whether or not our current condition
    * expression is fully completed.  Then externally checks can be made to
    * verify if the data is complete.
    * @return {bool}
    */
   isComplete() {
      if (!this._completeConditions) {
         this._completeConditions = this.AB.filterComplexNew(
            `${this.ids.component}_iscomplete`
         );
      }

      return this._completeConditions.isConditionComplete(this.getValue());
   }
}


/***/ }),

/***/ 77831:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobilePage.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobilePage)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobilePageCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobilePageCore */ 30654);


class ABMobilePage extends _core_mobile_ABMobilePageCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }
   // warningsEval() {
   //    super.warningsEval();
   //    let allViews = this.views();
   //    if (allViews.length == 0) {
   //       this.warningsMessage("has no sub views");
   //    }
   //    (this.pages() || []).forEach((p) => {
   //       p.warningsEval();
   //    });
   // }

   routeComponent() {
      return {
         path: `/${this.route}`,
         component: (props, { $, $h, $f7, $on, $store, $update }) => {
            const title = this.label;
            let allGetters = {};

            // NOTE: Programming Quirk:
            // We seem to need to access our getters for this Page from
            // within this PageComponent definition.  (maybe) this is how
            // it registers the components that need to be redrawn when the
            // related state is updated.
            let allViews = this.views();
            allViews.forEach((v) => {
               let dc = v.datacollection;
               if (dc) {
                  dc.init();
                  allGetters[dc.id] = $store.getters[dc.id];
               }
            });

            $on("pageInit", async (e, page) => {
               const pendingInit = [];
               allViews.forEach((v) => {
                  let dc = v.datacollection;
                  // dc?.init();

                  const viewInit = async (v, callback) => {
                     await v.init();

                     callback();
                  };
                  const init = () =>
                     new Promise((resolve) => {
                        if (dc && !dc.isDataInitialized) {
                           $store.dispatch("getAppBuilderData", dc.id);

                           const waitDCInit = setInterval(async () => {
                              if (dc.isDataInitialized) {
                                 clearInterval(waitDCInit);

                                 await viewInit(v, resolve);
                              }
                           }, 500);

                           return;
                        }

                        viewInit(v, resolve);
                     });

                  pendingInit.push(init());
               });

               await Promise.all(pendingInit);

               // $("#add-data-form-submit").on("click", async () => {
               //    const formData = $f7.form.convertToData("#add-data-form");

               //    console.log(formData);
               //    // await addItem(formData)
               // });

               // $(".deleted-callback").on(
               //    "swipeout:deleted",
               //    async function (value) {
               //       await delItem(this.getAttribute("id"));
               //    }
               // );
            });

            // let views = [
            //    {
            //       key: "list",
            //       dcID: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
            //       detailPage: "ABPage.id",
            //    },
            // ];
            function viewHTML() {
               let allResults = [];

               allViews.forEach((v) => {
                  allResults.push(v.html());
               });

               // views.forEach((view) => {
               //    switch (view.key) {
               //       case "list":
               //          var list = new List(view, { Application }, AB);
               //          allResults.push(list.html());
               //          allViews.push(list);
               //          break;
               //       default:
               //       // code block
               //    }
               // });

               return allResults.map((r) => r()); // render each jsx template
            }

            // async function addItem() {
            //    let DC = allViews[0].datacollection;
            //    let firstItem = DC.getFirstRecord();
            //    console.log(firstItem);
            //    let removeThese = ["uuid", "created_at", "updated_at", "id"];
            //    let newItem = {};
            //    Object.keys(firstItem).forEach((k) => {
            //       if (removeThese.indexOf(k) == -1) {
            //          newItem[k] = firstItem[k];
            //       }
            //    });

            //    newItem.Name = `${newItem.Name}-${AB.jobID()}`;
            //    console.log(newItem);

            //    try {
            //       await DC.datasource.model().create(newItem);
            //    } catch (e) {
            //       console.error(e);
            //    }
            // }

            // async function delItem(id) {
            //    let DC = allViews[0].datacollection;
            //    let item = id ? DC.$dc.getItem(id) : DC.getCursor();
            //    if (!item) {
            //       item = DC.getFirstRecord();
            //    }

            //    console.log("record to delete:", item);
            //    try {
            //       await DC.datasource
            //          .model()
            //          .delete(item[DC.datasource.PK()] || item.id || item.uuid);
            //    } catch (e) {
            //       console.error(e);
            //    }
            // }

            //
            return () => $h`
         <div class="page">
            <div class="navbar">
               <div class="navbar-bg"></div>
               <div class="navbar-inner">
                  <div class="left">
                     <a
                        href="#"
                        data-panel=".panel-left"
                        class="link icon-only panel-open"
                     >
                        <i class="icon material-icons">menu</i>
                     </a>
                  </div>
                  <div class="title">${title}</div>
                  <div class="title-large">
                     <div class="title-large-text">${title}</div>
                  </div>
                  <div class="right">
                     <a
                        href="#"
                        data-panel=".panel-right"
                        class="link icon-only panel-open"
                     >
                        <i class="icon f7-icons if-not-md">plus</i>
                        <i class="icon material-icons md-only">add</i>
                     </a>
                  </div>
               </div>
            </div>
            ${viewHTML()}
         </div>
      `;
         },
      };
   }
}


/***/ }),

/***/ 53349:
/*!***********************************************************!*\
  !*** ./src/js/AppBuilder/platform/mobile/ABMobileView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABMobileView)
/* harmony export */ });
/* harmony import */ var _core_mobile_ABMobileViewCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/mobile/ABMobileViewCore.js */ 69999);


class ABMobileView extends _core_mobile_ABMobileViewCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**


   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         // "view",
         // "page",
         // "formpanel",
         // "viewcontainer",
         // // not allowed Detail's widgets
         // "detailcheckbox",
         // "detailcustom",
         // "detailconnect",
         // "detailimage",
         // "detailselectivity",
         // "detailtext",
         // "detailtree",
         // // not allowed Form's widgets
         // "button",
         // "checkbox",
         // "connect",
         // "datepicker",
         // "fieldcustom",
         // "textbox",
         // "numberbox",
         // "selectsingle",
         // "selectmultiple",
         // "formtree",
         // "fieldreadonly",
         // // not allowed Chart's Widgets
         // "pie",
         // "bar",
         // "line",
         // "area",
         // // not allowed Report page
         // "report",
         // "reportPage",
         // "reportPanel",
      ];

      var allComponents = this.application.viewAll();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our sub views
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 23479:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/ABProcessLane.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessLane)
/* harmony export */ });
/* harmony import */ var _core_process_ABProcessLaneCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/process/ABProcessLaneCore */ 46446);
/**
 * ABProcessLane
 * manages a lane in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */


class ABProcessLane extends _core_process_ABProcessLaneCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, application) {
   //    super(attributes, process, application);
   // }

   ////
   //// Modeler Instance Methods
   ////

   transferParticipantWhereToMe(id) {
      var myParticipant = this.process.elementForDiagramID(id);
      if (myParticipant) {
         // if I haven't already set my where clause, and my Participant
         // has one, then take it:
         if (!this.stashed && myParticipant.stashed) {
            var copyParams = [
               "stashed",
               "useRole",
               "role",
               "useAccount",
               "account",
            ];
            copyParams.forEach((p) => {
               var swap = this[p];
               this[p] = myParticipant[p];
               myParticipant[p] = swap; // ?? do this ??
            });
         }
      }
   }

   /**
    * fromElement()
    * initialize this Lane's values from the given BPMN:Lane
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;

      // on creation, if I have child objects, then move the .where definition
      // from my parent Participant to ME
      if (element.children && element.children.length > 0) {
         if (element.parent && element.parent.type == "bpmn:Participant") {
            this.transferParticipantWhereToMe(element.parent.id);
         }
      } else {
         // this info might just reside in the .parent.children[]
         if (
            element.parent &&
            element.parent.children &&
            element.parent.children.length > 0
         ) {
            element.parent.children.forEach((child) => {
               if (child.type != "bpmn:Lane") {
                  // if child has lanes
                  if (
                     child.businessObject.lanes &&
                     child.businessObject.lanes.length > 0
                  ) {
                     // if lane is me
                     var myLane = child.businessObject.lanes.find((l) => {
                        return l.id == this.diagramID;
                     });
                     if (myLane) {
                        this.transferParticipantWhereToMe(element.parent.id);

                        // tell child I'm it's lane:
                        var objChild = this.process.elementForDiagramID(
                           child.id
                        );
                        if (objChild) {
                           objChild.setLane(this);
                        }
                     }
                  }
               }
            });
         }
      }

      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Lane with information that was relevant
    * from the provided BPMN:Lane
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // if I picked up a new task, inform it I am it's lane:
   }
}


/***/ }),

/***/ 74843:
/*!********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/ABProcessParticipant.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessParticipant)
/* harmony export */ });
/* harmony import */ var _core_process_ABProcessParticipantCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/process/ABProcessParticipantCore */ 71206);
/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system (when there are no lanes defined)
 * and provide a way to lookup a SiteUser.
 */


class ABProcessParticipant extends _core_process_ABProcessParticipantCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, AB) {
   //    super(attributes, process, AB);
   // }

   ////
   //// Modeler Instance Methods
   ////

   /**
    * fromElement()
    * initialize this Participant's values from the given BPMN:Participant
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Participant with information that was relevant
    * from the provided BPMN:Participant
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      if (defElement.children) {
         var laneIDs = [];
         defElement.children.forEach((c) => {
            if (c.type == "bpmn:Lane") {
               laneIDs.push(c.id);
            }
         });
         this.laneIDs = laneIDs;
      }
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this objec.
    * @return {json}
    */
   diagramProperties() {
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
   }
}


/***/ }),

/***/ 50138:
/*!**********************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessElement.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABProcessElement)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessElementCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessElementCore.js */ 72935);


class ABProcessElement extends _core_process_tasks_ABProcessElementCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, process, AB, defaultValues) {
   //    super(attributes, process, AB, defaultValues);

   //    // listen
   // }

   /**
    * @method destroy()
    * remove this task definition.
    * @return {Promise}
    */
   destroy() {
      ////
      //// TODO: once our core conversion is complete, this .save() can be
      //// moved to ABProcessTaskCore, and our ABDefinition.save() can take
      //// care of the proper method to save depending on the current Platform.
      ////
      // return this.toDefinition()
      //     .destroy()

      return super.destroy().then(() => {
         return this.process.elementRemove(this);
      });
   }

   isValid() {
      /*
        var validator = OP.Validation.validator();

        // label/name must be unique:
        var isNameUnique =
            this.AB.processes((o) => {
                return o.name.toLowerCase() == this.name.toLowerCase();
            }).length == 0;
        if (!isNameUnique) {
            validator.addError(
                "name",
                L(
                    "ab.validation.object.name.unique",
                    `Process name must be unique ("${this.name}"" already used in this Application)`
                )
            );
        }

        return validator;
        */

      // var isValid =
      //     this.AB.processes((o) => {
      //         return o.name.toLowerCase() == this.name.toLowerCase();
      //     }).length == 0;
      // return isValid;

      return true;
   }

   ////
   //// Modeler Instance Methods
   ////

   findLane(curr, cb) {
      if (!curr) {
         cb(null, null);
         return;
      }

      // if current object has a LANE definition, use that one:
      if (curr.lanes && curr.lanes.length > 0) {
         cb(null, curr.lanes[0]);
      } else if (curr.$type == "bpmn:Participant") {
         // if the current is a Participant, take that one
         cb(null, curr);
      } else {
         // else move upwards and check again:
         curr = curr.$parent;
         this.findLane(curr, cb);
      }
   }

   setLane(Lane) {
      this.laneDiagramID = Lane.diagramID;
   }

   /**
    * fromElement()
    * initialize this Task's values from the given BPMN:Element
    * @param {BPMNElement}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Task_08j07ni",
                "width": 100,
                "height": 80,
                "type": "bpmn:SendTask",
                "x": 20,
                "y": -2130,
                "order": {
                    "level": 5
                },
                "businessObject": {
                    "$type": "bpmn:SendTask",
                    "id": "Task_08j07ni",
                    "name": "ffff",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": 20,
                            "y": -2130,
                            "width": 100,
                            "height": 80
                        },
                        "id": "SendTask_0iidv6o_di"
                    }

                    // Some elements (like EndEvents) have:
                    .eventDefinitions: [
                        {
                            $type: "actual bpmn:ElementType",
                            ...
                        }
                    ]
                },
                "incoming":[],
                "outgoing":[]
            }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // our lane may have changed:
      var currObj = defElement.businessObject;
      this.findLane(currObj, (err, obj) => {
         if (obj) {
            this.laneDiagramID = obj.id;
         } else {
            // if my parent shape is a Participant, then use that:
            if (
               defElement.parent &&
               defElement.parent.type == "bpmn:Participant"
            ) {
               this.laneDiagramID = defElement.parent.id;
            } else {
               this.laneDiagramID = null;
            }
         }
      });
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      const warnings = this.warnings();
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
            warn: warnings.length ? warnings : null,
         },
      ];
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let L = this.AB.Label();
      var ui = {
         id: id,
         view: "label",
         label: L("this task has not implement properties yet..."),
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {}

   /**
    * property()
    * return the specific property value if it exists.
    * @return {mixed} | undefined
    */
   property(id) {
      if ($$(id)) {
         return $$(id).getValue();
      }
   }

   /**
    * switchTo()
    * replace this object with an instance of one of our child classes:
    * @param {ABProcessTask*} child
    *        an instance of the new Process Task we are replaced with.
    * @param {string} propertiesID
    *        the webix ui.id container for the properties panel.
    */
   switchTo(child, propertiesID) {
      // remove myself from our containing process's elements
      this.process.elementRemove(this);

      // add the new Process WITH the same id
      this.process.elementAdd(child);

      // show the child properties:
      child.propertiesShow(propertiesID);

      this.emit("switchTo", child);
   }

   /**
    * @method warningsEval()
    * re-evaluate our warnings for this Process Task.
    * Most of our ProcessTasks need to also verify data related to
    * other available tasks, so we need to call the onProcessReady()
    * so we can access those values.
    */
   warningsEval() {
      super.warningsEval();
      this.onProcessReady();

      // if this isn't an end type of task, then there must be
      // > 0 next tasks
      if (!this.isEndTask()) {
         const myOutgoingConnections = this.process.connectionsOutgoing(
            this.diagramID
         );
         if (myOutgoingConnections.length < 1) {
            this.warningMessage("should have another task after this one");
         }
      }
   }

   /**
    * @method warningMessage(message)
    * Save a warning message in a common format for our ProcessTasks.
    */
   warningMessage(msg, data = {}) {
      let message = `${this.defaults.key}[${
         this.label ? this.label : this.name
      }]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 75175:
/*!*****************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/process/tasks/ABProcessTaskSubProcess.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubProcess)
/* harmony export */ });
/* harmony import */ var _core_process_tasks_ABProcessTaskSubProcessCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskSubProcessCore.js */ 76987);


class SubProcess extends _core_process_tasks_ABProcessTaskSubProcessCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   ////
   //// Process Instance Methods
   ////

   /*
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         isEnable: `${id}_isEnable`,
         parameterId: `${id}_parameterId`,
      };
   }

   /**
    * @method propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      // Pull query tasks option list
      let parameterOptions = (this.process.processDataFields(this) || []).map(
         (item) => {
            return {
               id: item.key,
               value: item.label,
            };
         }
      );

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 120,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.isEnable,
               view: "switch",
               label: L("Enable"),
               value: this.isEnable,
            },
            {
               id: ids.parameterId,
               view: "richselect",
               label: L("Repeat for"),
               options: parameterOptions,
               value: this.parameterId,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * @method propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.isEnable = this.property(ids.isEnable);
      this.parameterId = this.property(ids.parameterId);
   }
   */

   /**
    * @method diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties(bpmnModeler) {
      let props = super.diagramProperties();
      props = props || [{}];
      props[0].def = props[0].def || {};

      if (this.parameterId != null) {
         props[0].def = props[0].def || {};
         props[0].def.loopCharacteristics = bpmnModeler
            .get("moddle")
            .create("bpmn:MultiInstanceLoopCharacteristics");
         props[0].def.loopCharacteristics.isSequential = true;
      }

      return props;
   }

   /**
    * @method onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      let loopCharacteristics =
         defElement.loopCharacteristics ||
         defElement.businessObject.loopCharacteristics ||
         {};

      switch (loopCharacteristics.$type) {
         case "bpmn:MultiInstanceLoopCharacteristics":
            this.loopType = loopCharacteristics.isSequential
               ? "sequential"
               : "parallel";
            break;
         case "bpmn:StandardLoopCharacteristics":
            this.loopType = "looping";
            break;
      }
   }

   /**
    * @method destroy()
    * destroy this sub process and inside tasks
    *
    * @return {Promise}
    */
   destroy() {
      // reuse .destroy function of ABProcess
      // to clear tasks within this sub process
      return this.process.destroy.call(this);
   }

   /**
    * @method save()
    * persist this sub process
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // reuse .save function of ABProcess
      // to update tasks within this sub process
      return this.process.save.call(this);
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcessParticipant|ABProcessLane|ABProcessElement}
    *
    */
   elementNewForModelDefinition(element) {
      let task = this.AB.processElementNewForModelDefinition(element, this);

      // Add a new task to this sub process
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownElementIDs || []).forEach((eID) => {
         this.warningMessage(
            `is referencing an unknown process element id[${eID}]`,
            { process: this.id, eID }
         );
      });
   }
}


/***/ }),

/***/ 69459:
/*!****************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABView.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABView)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewCore.js */ 7852);
/* harmony import */ var _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewComponent */ 9162);



class ABView extends _core_views_ABViewCore_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         "view",
         "page",
         "formpanel",
         "viewcontainer",
         // not allowed Detail's widgets
         "detailcheckbox",
         "detailcustom",
         "detailconnect",
         "detailimage",
         "detailselectivity",
         "detailtext",
         "detailtree",
         // not allowed Form's widgets
         "button",
         "checkbox",
         "connect",
         "datepicker",
         "fieldcustom",
         "textbox",
         "numberbox",
         "selectsingle",
         "selectmultiple",
         "formtree",
         "fieldreadonly",
         // not allowed Chart's Widgets
         "pie",
         "bar",
         "line",
         "area",
         // not allowed Report page
         "report",
         "reportPage",
         "reportPanel",
      ];

      var allComponents = this.application.viewAll(); // ABViewManager.allViews();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   changePage(pageId) {
      this.emit("changePage", pageId);
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
}


/***/ }),

/***/ 90669:
/*!*************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewContainer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainer)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewContainerCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewContainerCore */ 93997);
/* harmony import */ var _viewComponent_ABViewContainerComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewContainerComponent */ 77191);



class ABViewContainer extends _core_views_ABViewContainerCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewContainerComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no content");
      }

      // NOTE: this is done in ABView:
      // (allViews || []).forEach((v) => {
      //    v.warningsEval();
      // });
   }
}


/***/ }),

/***/ 48172:
/*!**************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewDetailItem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDetailItem)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewDetailItemCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewDetailItemCore */ 63255);

// const ABViewDetailItemComponent = require("./viewComponent/ABViewDetailItemComponent");

class ABViewDetailItem extends _core_views_ABViewDetailItemCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      console.error(
         "DEPRECIATED: ABViewDetailItem.component():  Who is calling this?"
      );
      return null;
      // return new ABViewDetailItemComponent(this);
   }
}


/***/ }),

/***/ 9247:
/*!************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewFormItem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewFormItem)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewFormItemCore */ 95484);

// const ABViewFormItemComponent = require("./viewComponent/ABViewFormItemComponent");

// const ABViewFormFieldPropertyComponentDefaults =
//    ABViewFormItemCore.defaultValues();

class ABViewFormItem extends _core_views_ABViewFormItemCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static get componentUI() {
      console.error(
         "DEPRECIATED: ABViewFormItem.componentUI(): who is calling this?"
      );
      return null;

      // return ABViewFormItemComponent;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      console.error(
         "DEPRECIATED: ABViewFormItem.component(): who is calling this?"
      );
      return null;

      // return new ABViewFormItemComponent(this);
   }

   /**
    * @method parentFormUniqueID
    * return a unique ID based upon the closest form object this component is on.
    * @param {string} key  The basic id string we will try to make unique
    * @return {string}
    */
   parentFormUniqueID(key) {
      var form = this.parentFormComponent();
      var uniqueInstanceID;
      if (form) {
         uniqueInstanceID = form.uniqueInstanceID;
      } else {
         uniqueInstanceID = webix.uid();
      }

      return key + uniqueInstanceID;
   }
}


/***/ }),

/***/ 22305:
/*!********************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewPage.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPage)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewPageCore */ 16605);


const ABPropertyComponentDefaults = _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__["default"].defaultValues();

class ABViewPage extends _core_views_ABViewPageCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} v1App
    * @return {obj} UI component
    */
   component(v1App = false) {
      var component = super.component();

      component._ui = component.ui();

      // wrap our ABViewContainer in our Page scrollview
      component.ui = () => {
         return {
            view: "scrollview",
            borderless: true,
            css:
               this.settings.pageBackground ||
               ABPropertyComponentDefaults.pageBackground,
            body: component._ui,
         };
      };

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               accessLevel = accessLevel ?? this.getUserAccess();
               return newComponent.init(this.AB, accessLevel, options);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no sub views");
      }

      (this.pages() || []).forEach((p) => {
         p.warningsEval();
      });
   }
}


/***/ }),

/***/ 79562:
/*!**********************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/ABViewWidget.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewWidget)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewWidgetCore */ 82218);


const ABPropertyComponentDefaults = _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__["default"].defaultValues();

class ABViewWidget extends _core_views_ABViewWidgetCore__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let base = super.component(App);

      base.onShow = (viewId) => {
         let dv = this.datacollection; // get from a function or a (get) property
         if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }
      };

      return base;
   }
}


/***/ }),

/***/ 9162:
/*!***************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/viewComponent/ABViewComponent.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewComponent)
/* harmony export */ });
/**
 * ABViewComponent
 * A common UI component class for our UI widgets.
 */
// import ClassUI from "../../../../ui/ClassUI";

class ABViewComponent /* extends ClassUI */ {
   constructor(baseView, idBase, ids) {
      // super(idBase || `ABView_${baseView.id}`, ids);

      this.view = baseView;
      this.settings = baseView.settings;
      this.AB = baseView.AB;
      this.datacollection = baseView.datacollections || baseView.datacollection;

      this.__events = [];
      // {array}
      // A collection of any listeners we are managing.
      // {
      //   emitter:   {EventEmitter} the object we are listening on
      //   eventName: {string} the event key we are listening for
      //   listener:  {fn} the function to call on
      // }

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.CurrentDatacollectionID = null;
      // {string}
      // the ABDataCollection.id of the DC we are working with
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }
   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      return this.AB.datacollectionByID(this.CurrentDatacollectionID);
   }

   ui(uiComponents = []) {
      // an ABView is a collection of rows:
      const _ui = {
         id: this.ids.component,
         view: "layout",
         type: "space",
         rows: uiComponents,
      };

      // if this form is empty, then force a minimal row height
      // so the component isn't completely hidden on the screen.
      // (important in the editor so we don't loose the ability to edit the
      // component)
      if (!_ui.rows.length) _ui.height = 30;

      return _ui;
   }

   async init(AB) {
      this.AB = AB;
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      this.CurrentDatacollectionID = datacollection?.id;
   }

   objectLoad(object) {
      this.CurrentObjectID = object?.id;
   }

   /**
    * @method eventAdd()
    * Create a new listener on an object. Note, this will prevent multiple
    * listeners being applied to the same Object.
    * @param {object} evt
    *        The definition of the event we are adding:
    *        {
    *           emitter:   {EventEmitter} the object we are listening on
    *           eventName: {string} the event key we are listening for
    *           listener:   {fn} the function to call on
    *        }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      // make sure we haven't done this before:
      const __events = this.__events;
      const exists = __events.filter(
         (e) => e.emitter === evt.emitter && e.eventName === evt.eventName
         // && e.listener === evt.listener
      );

      if (!exists.length) {
         // add to array
         __events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventsClear()
    * Remove all the attached event listeners and reset our tracking.
    */
   eventsClear() {
      this.__events.forEach((evt) => {
         evt.emitter.removeListener(evt.eventName, evt.listener);
      });

      this.__events = [];
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      // check if tab has a hint
      if (this?.view?.settings?.hintID) {
         // fetch the steps for the hint
         let hint = this.AB.hintID(this.view.settings.hintID);
         if (hint.settings.active) {
            hint.createHintUI();
         }
      }
      // if we manage a datacollection, then make sure it has started
      // loading it's data when we are showing our component.
      const dc = this.datacollection;

      if (!dc) return;

      if (dc.dataStatus === dc.dataStatusFlag.notInitial)
         // load data when a widget is showing
         dc.loadData();
   }
}


/***/ }),

/***/ 77191:
/*!************************************************************************************!*\
  !*** ./src/js/AppBuilder/platform/views/viewComponent/ABViewContainerComponent.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewContainerComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 9162);


class ABViewContainerComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewContainer_${baseView.id}`, ids);

      this.options = null;

      this.viewComponents = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child views that we manage

      this.viewComponentIDs = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child.ui().ids of the views we manage

      this._handlerChangePage = (pageId) => {
         baseView.changePage(pageId);
      };
   }

   ui(uiComponents) {
      // Generate rows & cols of views to .layout
      const views = this.view.viewsSortByPosition();
      const rowViews = this.getElements(views);
      const _ui = super.ui(uiComponents || rowViews);

      delete _ui.type;

      return _ui;
   }

   // make sure each of our child views get .init() called
   async init(AB, accessLevel = 0, options = {}) {
      await super.init(AB);

      this.options = options;

      const allInits = [];

      // // register our callbacks:
      // if (options) {
      //    for (var c in _logic.callbacks) {
      //       _logic.callbacks[c] = options[c] || _logic.callbacks[c];
      //    }
      // }

      // see access by CSS class
      $$(this.ids.component)?.define("css", `accessLevel-${accessLevel}`);

      const viewComponents = this.viewComponents;

      // attach all the .UI views:
      for (const key in viewComponents) {
         // skip when the view is removed.
         if (
            !viewComponents[key] ??
            !this.view.views((v) => v.id === key).length
         )
            continue;

         // Initial component along with options in case there are callbacks we need to listen for
         if (accessLevel) {
            allInits.push(viewComponents[key].init(AB, accessLevel, options));

            continue;
         }

         $$(this.viewComponentIDs[key]).hide();
      }

      await Promise.all(allInits);
   }

   getElements(views) {
      const rows = [];
      const componentMap = {};

      let curRowIndex;
      let curColIndex;

      const settings = this.settings;
      const defaultSettings = this.view.constructor.defaultValues();

      views.forEach((v) => {
         // let component = v.component(/* App, idPrefix */);
         // NOTE: PONG - Just temporary to be compatible old & new versions
         let component;

         try {
            component = v.component();
            // make sure any existing handlers for changePage are removed.
            v.removeAllListeners("changePage");
         } catch (err) {
            component = v.component(this.AB._App);

            const ui = component.ui;

            component.ui = (() => ui).bind(component);
         }

         this.viewComponents[v.id] = component;

         ////
         //// TODO: figure out the embedded Callbacks => emit()
         ////
         // if key == "form" or "button" register the callbacks to the parent
         // NOTE this will only work on the last form of a page!
         // if (v.key == "form" && v._logic.callbacks) {
         //    _logic.callbacks = v._logic.callbacks;
         // }

         // Create a new row
         if (v.position.y == null || v.position.y !== curRowIndex) {
            curRowIndex = v.position.y || rows.length;
            curColIndex = 0;

            const rowNew = {
               cols: [],
            };

            // Create columns following setting value
            const colNumber = settings.columns || defaultSettings.columns;

            for (let i = 0; i < colNumber; i++)
               rowNew.cols.push({
                  gravity: settings.gravity?.[i]
                     ? parseInt(settings.gravity[i])
                     : defaultSettings.gravity,
               });

            rows.push(rowNew);
         }

         // Get the last row
         const rowIndx = rows.length - 1;
         const curRow = rows[rowIndx];
         const newPos = v.position.x ?? 0;
         const mapKey = `${rowIndx}-${newPos}`;

         let getGrav = 1;

         if (componentMap[mapKey])
            console.error(
               `Component[${component?.ids?.component}] is overwriting component[${componentMap[mapKey].ids?.component}]. <-- Reorder them to fix.`
            );

         componentMap[mapKey] = component;

         if (curRow.cols[newPos]?.gravity)
            getGrav = curRow.cols[newPos].gravity;

         const _ui = component.ui();

         this.viewComponentIDs[v.id] = _ui.id;
         _ui.gravity = getGrav;

         // Add ui of sub-view to column
         curRow.cols[newPos] = _ui;

         // Trigger 'changePage' event to parent
         this.eventAdd({
            emitter: v,
            eventName: "changePage",
            listener: this._handlerChangePage,
         });

         curColIndex++;
      });

      return rows;
   }

   onShow() {
      super.onShow();

      // calll .onShow in child components
      Object.values(this.viewComponents).forEach((val) => {
         val.onShow?.();
      });
   }
}


/***/ }),

/***/ 62107:
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var framework7_bundle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framework7/bundle */ 17942);
/* harmony import */ var framework7_css_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7/css/bundle */ 81565);
/* harmony import */ var _css_icons_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/icons.css */ 22254);
/* harmony import */ var _css_app_less__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/app.less */ 6120);
/* harmony import */ var _routes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./routes.js */ 43183);
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./store.js */ 40659);
/* harmony import */ var _pages_app_f7_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pages/app.f7.jsx */ 18388);
/* harmony import */ var _AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AppBuilder/ABFactory */ 63133);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__]);
_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



// Import Global Resources
// import "./atomic.polyfills.min.js";
var atomic = __webpack_require__(/*! ./atomic.polyfills.min.js */ 69170);
var sails = __webpack_require__(/*! ./sails.io.js */ 55730);
Window.atomic = atomic;

// Import F7 Styles


// Import Icons and App Custom Styles



// Import Routes

// Import Store


// Import main app component


// AB Factory


let version = "0.0.9";

var app = new framework7_bundle__WEBPACK_IMPORTED_MODULE_7__["default"]({
   name: "AppBuilder PWA", // App name
   theme: "auto", // Automatic theme detection
   darkMode: "auto",
   colors: {
      primary: "#366989",
   },

   el: "#app", // App root element
   component: (0,_pages_app_f7_jsx__WEBPACK_IMPORTED_MODULE_5__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]), // App main component
   // App store
   store: (0,_store_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]),
   // App routes
   routes: (0,_routes_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_AppBuilder_ABFactory__WEBPACK_IMPORTED_MODULE_6__["default"]),
   version: version,

   // Register service worker (only on production build)
   serviceWorker:
       false
         ? 0
         : {},
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 69170:
/*!****************************************!*\
  !*** ./src/js/atomic.polyfills.min.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! atomicjs v4.4.1 | (c) 2020 Chris Ferdinandi | MIT License | https://github.com/cferdinandi/atomic */
!(function(t,e){ true?module.exports=e():0})(this,(function(){"use strict";function t(t){return"function"==typeof t}var e=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},n=0,r=void 0,o=void 0,i=function(t,e){h[n]=t,h[n+1]=e,2===(n+=2)&&(o?o(p):m())};var s="undefined"!=typeof window?window:void 0,u=s||{},a=u.MutationObserver||u.WebKitMutationObserver,c="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),f="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function l(){var t=setTimeout;return function(){return t(p,1)}}var h=new Array(1e3);function p(){for(var t=0;t<n;t+=2){(0,h[t])(h[t+1]),h[t]=void 0,h[t+1]=void 0}n=0}var d,v,y,_,m=void 0;function w(t,e){var n=this,r=new this.constructor(A);void 0===r[g]&&J(r);var o=n._state;if(o){var s=arguments[o-1];i((function(){return N(o,r,s,n._result)}))}else R(n,r,t,e);return r}function b(t){if(t&&"object"==typeof t&&t.constructor===this)return t;var e=new this(A);return P(e,t),e}c?m=function(){return process.nextTick(p)}:a?(v=0,y=new a(p),_=document.createTextNode(""),y.observe(_,{characterData:!0}),m=function(){_.data=v=++v%2}):f?((d=new MessageChannel).port1.onmessage=p,m=function(){return d.port2.postMessage(0)}):m=void 0===s&&"function"=="function"?(function(){try{var t=Function("return this")().require("vertx");return void 0!==(r=t.runOnLoop||t.runOnContext)?function(){r(p)}:l()}catch(t){return l()}})():l();var g=Math.random().toString(36).substring(2);function A(){}var T=void 0,j=1,x=2,S={error:null};function O(t){try{return t.then}catch(t){return S.error=t,S}}function C(e,n,r){n.constructor===e.constructor&&r===w&&n.constructor.resolve===b?(function(t,e){e._state===j?M(t,e._result):e._state===x?q(t,e._result):R(e,void 0,(function(e){return P(t,e)}),(function(e){return q(t,e)}))})(e,n):r===S?(q(e,S.error),S.error=null):void 0===r?M(e,n):t(r)?(function(t,e,n){i((function(t){var r=!1,o=(function(t,e,n,r){try{t.call(e,n,r)}catch(t){return t}})(n,e,(function(n){r||(r=!0,e!==n?P(t,n):M(t,n))}),(function(e){r||(r=!0,q(t,e))}),t._label);!r&&o&&(r=!0,q(t,o))}),t)})(e,n,r):M(e,n)}function P(t,e){var n,r;t===e?q(t,new TypeError("You cannot resolve a promise with itself")):(r=typeof(n=e),null===n||"object"!==r&&"function"!==r?M(t,e):C(t,e,O(e)))}function E(t){t._onerror&&t._onerror(t._result),F(t)}function M(t,e){t._state===T&&(t._result=e,t._state=j,0!==t._subscribers.length&&i(F,t))}function q(t,e){t._state===T&&(t._state=x,t._result=e,i(E,t))}function R(t,e,n,r){var o=t._subscribers,s=o.length;t._onerror=null,o[s]=e,o[s+j]=n,o[s+x]=r,0===s&&t._state&&i(F,t)}function F(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?N(n,r,o,i):o(i);t._subscribers.length=0}}function N(e,n,r,o){var i=t(r),s=void 0,u=void 0,a=void 0,c=void 0;if(i){if((s=(function(t,e){try{return t(e)}catch(t){return S.error=t,S}})(r,o))===S?(c=!0,u=s.error,s.error=null):a=!0,n===s)return void q(n,new TypeError("A promises callback cannot return that same promise."))}else s=o,a=!0;n._state!==T||(i&&a?P(n,s):c?q(n,u):e===j?M(n,s):e===x&&q(n,s))}var H=0;function J(t){t[g]=H++,t._state=void 0,t._result=void 0,t._subscribers=[]}var L=(function(){function t(t,n){this._instanceConstructor=t,this.promise=new t(A),this.promise[g]||J(this.promise),e(n)?(this.length=n.length,this._remaining=n.length,this._result=new Array(this.length),0===this.length?M(this.promise,this._result):(this.length=this.length||0,this._enumerate(n),0===this._remaining&&M(this.promise,this._result))):q(this.promise,new Error("Array Methods must be provided an Array"))}return t.prototype._enumerate=function(t){for(var e=0;this._state===T&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===b){var o=O(t);if(o===w&&t._state!==T)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===U){var i=new n(A);C(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===T&&(this._remaining--,t===x?q(r,n):this._result[e]=n),0===this._remaining&&M(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;R(t,void 0,(function(t){return n._settledAt(j,e,t)}),(function(t){return n._settledAt(x,e,t)}))},t})();var U=(function(){function t(e){this[g]=H++,this._result=this._state=void 0,this._subscribers=[],A!==e&&("function"!=typeof e&&(function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")})(),this instanceof t?(function(t,e){try{e((function(e){P(t,e)}),(function(e){q(t,e)}))}catch(e){q(t,e)}})(this,e):(function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")})())}return t.prototype.catch=function(t){return this.then(null,t)},t.prototype.finally=function(t){var e=this.constructor;return this.then((function(n){return e.resolve(t()).then((function(){return n}))}),(function(n){return e.resolve(t()).then((function(){throw n}))}))},t})();return U.prototype.then=w,U.all=function(t){return new L(this,t).promise},U.race=function(t){var n=this;return e(t)?new n(function(e,r){for(var o=t.length,i=0;i<o;i++)n.resolve(t[i]).then(e,r)}):new n(function(t,e){return e(new TypeError("You must pass an array to race."))})},U.resolve=b,U.reject=function(t){var e=new this(A);return q(e,t),e},U._setScheduler=function(t){o=t},U._setAsap=function(t){i=t},U._asap=i,U.polyfill=function(){var t=void 0;if("undefined"!=typeof __webpack_require__.g)t=__webpack_require__.g;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(t){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;if(e){var n=null;try{n=Object.prototype.toString.call(e.resolve())}catch(t){}if("[object Promise]"===n&&!e.cast)return}t.Promise=U},U.Promise=U,U})),(function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return e(t)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})("undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof window?window:this,(function(t){"use strict";var e,n={method:"GET",username:null,password:null,data:{},headers:{"Content-type":"application/x-www-form-urlencoded"},responseType:"text",timeout:null,withCredentials:!1},r=function(){for(var t={},e=function(e){for(var n in e)e.hasOwnProperty(n)&&("[object Object]"===Object.prototype.toString.call(e[n])?t[n]=r(t[n],e[n]):t[n]=e[n])},n=0;n<arguments.length;n++){e(arguments[n])}return t},o=function(t){var n=new XMLHttpRequest,r=new Promise(function(r,o){for(var i in n.onreadystatechange=function(){4===n.readyState&&n.status&&(n.status>=200&&n.status<300?r(function(t){var n;if("text"!==e.responseType&&""!==e.responseType)return{data:t.response,xhr:t};try{n=JSON.parse(t.responseText)}catch(e){n=t.responseText}return{data:n,xhr:t}}(n)):o({status:n.status,statusText:n.statusText,responseText:n.responseText}))},n.open(e.method,t,!0,e.username,e.password),n.responseType=e.responseType,e.headers)e.headers.hasOwnProperty(i)&&n.setRequestHeader(i,e.headers[i]);e.timeout&&(n.timeout=e.timeout,n.ontimeout=function(t){o({status:408,statusText:"Request timeout"})}),e.withCredentials&&(n.withCredentials=!0),n.send(function(t){if("string"==typeof t||"[object FormData]"===Object.prototype.toString.call(t))return t;if(/application\/json/i.test(e.headers["Content-type"])||"[object Array]"===Object.prototype.toString.call(t))return JSON.stringify(t);var n=[];for(var r in t)t.hasOwnProperty(r)&&n.push(encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return n.join("&")}(e.data))});return r.cancel=function(){n.abort()},r};return function(i,s){if(!("XMLHttpRequest"in t&&"JSON"in t&&"Promise"in t))throw"Atomic: This browser does not support the methods used in this plugin.";return e=r(n,s||{}),o(i)}}));

/***/ }),

/***/ 49670:
/*!*******************************!*\
  !*** ./src/js/definitions.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	abVersion: "0.0.0",
	filename: "app_AppBuilder_PWA_20230519",
	date: "20230519",
	definitions: [
		{
			id: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
			name: "AppBuilder PWA",
			type: "application",
			json: {
				id: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
				type: "application",
				name: "AppBuilder PWA",
				icon: "fa-android",
				isSystemObject: 0,
				json: {
					translations: [
						{
							language_code: "en",
							label: "AppBuilder PWA",
							description:
								"Application to test new AppBuilder PWA framework.",
						},
					],
					name: "AppBuilder PWA",
					versionData: {
						versionNumber: "1.0.0",
						changeLog: {
							"1.0.0": {
								author: "N/A",
								version: "1.0.0",
								keepVersion: 0,
								commitMessage: "Initial Version",
								timestamp: "2023-05-18T09:55:09.456Z",
								versionNumber: "1.0.0",
							},
						},
					},
					objectIDs: ["faa9905e-dea8-4c7f-8eb4-98f1e6e66506"],
					objectListSettings: {
						isOpen: false,
						searchText: "",
						sortDirection: "asc",
						isGroup: false,
					},
					hintIDs: [],
					queryIDs: [],
					datacollectionIDs: ["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"],
					pageIDs: [],
					processIDs: [],
				},
				roleAccess: [
					"dd6c2d34-0982-48b7-bc44-2456474edbea",
					"e1be4d22-1d00-4c34-b205-ef84b8334b19",
					"6cc04894-a61b-4fb5-b3e5-b8c3f78bd331",
				],
				translations: [
					{
						language_code: "en",
						label: "AppBuilder PWA",
						description:
							"Application to test new AppBuilder PWA framework.",
					},
				],
				isAccessManaged: false,
				isTranslationManaged: false,
				isTutorialManaged: false,
				accessManagers: {
					useRole: 0,
					role: null,
					useAccount: 0,
					account: null,
				},
				translationManagers: {
					useRole: 0,
					role: null,
					useAccount: 0,
					account: null,
				},
			},
			createdAt: "2023-05-18T09:55:09.000Z",
			updatedAt: "2023-05-18T10:18:01.000Z",
		},
		{
			id: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
			name: "Person - PWA",
			type: "object",
			json: {
				id: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
				type: "object",
				name: "Person - PWA",
				labelFormat: "",
				labelSettings: { isNoLabelDisplay: 0 },
				isImported: 0,
				isExternal: 0,
				tableName: "AB_AppBuilderPWA_PersonPWA",
				primaryColumnName: "uuid",
				transColumnName: "",
				urlPath: "",
				objectWorkspace: {
					sortFields: [],
					filterConditions: [],
					frozenColumnID: "",
					hiddenFields: [],
				},
				isSystemObject: 0,
				translations: [{ language_code: "en", label: "Person - PWA" }],
				fieldIDs: [
					"c6268631-bc80-4a72-a3f2-55e5721f47a2",
					"657ca7ef-75ce-4b07-a7d5-5b95ad775767",
					"3a212114-385d-40bf-bf7e-a24b7da0c7e7",
					"2d08298f-cfda-44d2-aa19-683316f578a9",
					"4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
					"b83daff6-8624-469b-9a30-d02f68be9e29",
					"2bfc9604-8011-41ef-9985-a22de0258413",
					"032f3208-4ae8-400e-8bbe-3edde4dae5d7",
					"0b52730f-1e1e-476a-95ef-2824ed87da13",
				],
				importedFieldIDs: [],
				indexIDs: [],
				createdInAppID: "4b7a489a-5fe5-4044-8565-aaa3654300f2",
				objectWorkspaceViews: {
					currentViewID: "bdcf1b76-9684-4349-8a07-588da87287cf",
					list: [
						{
							id: "bdcf1b76-9684-4349-8a07-588da87287cf",
							translations: [
								{ language_code: "en", label: "grid" },
							],
							isDefaultView: true,
							name: "Default Grid",
							sortFields: [],
							filterConditions: [],
							frozenColumnID: "",
							hiddenFields: ["salt", "password"],
							type: "grid",
						},
					],
				},
			},
			createdAt: "2023-05-18T09:56:18.000Z",
			updatedAt: "2023-05-18T10:06:58.000Z",
		},
		{
			id: "c6268631-bc80-4a72-a3f2-55e5721f47a2",
			name: "Person - PWA->Name",
			type: "field",
			json: {
				id: "c6268631-bc80-4a72-a3f2-55e5721f47a2",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "Name",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Name" }],
			},
			createdAt: "2023-05-18T09:56:32.000Z",
			updatedAt: "2023-05-18T09:56:32.000Z",
		},
		{
			id: "657ca7ef-75ce-4b07-a7d5-5b95ad775767",
			name: "Person - PWA->Email",
			type: "field",
			json: {
				id: "657ca7ef-75ce-4b07-a7d5-5b95ad775767",
				type: "field",
				key: "email",
				icon: "envelope",
				isImported: 0,
				columnName: "Email",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					width: 100,
					defaultCheckbox: 0,
				},
				translations: [{ language_code: "en", label: "Email" }],
			},
			createdAt: "2023-05-18T09:56:40.000Z",
			updatedAt: "2023-05-18T09:56:40.000Z",
		},
		{
			id: "3a212114-385d-40bf-bf7e-a24b7da0c7e7",
			name: "Person - PWA->URL",
			type: "field",
			json: {
				id: "3a212114-385d-40bf-bf7e-a24b7da0c7e7",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "URL",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "URL" }],
			},
			createdAt: "2023-05-18T09:56:59.000Z",
			updatedAt: "2023-05-18T09:56:59.000Z",
		},
		{
			id: "2d08298f-cfda-44d2-aa19-683316f578a9",
			name: "Person - PWA->Phone",
			type: "field",
			json: {
				id: "2d08298f-cfda-44d2-aa19-683316f578a9",
				type: "field",
				key: "string",
				icon: "font",
				isImported: 0,
				columnName: "Phone",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Phone" }],
			},
			createdAt: "2023-05-18T09:57:25.000Z",
			updatedAt: "2023-05-18T09:57:25.000Z",
		},
		{
			id: "4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
			name: "Person - PWA->Gender",
			type: "field",
			json: {
				id: "4998a2eb-b04b-4a8b-9d1d-f3d839c9e920",
				type: "field",
				key: "list",
				icon: "th-list",
				isImported: 0,
				columnName: "Gender",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					isMultiple: 0,
					hasColors: 1,
					default: "1684401575798",
					multipleDefault: [],
					options: [
						{
							id: "Male",
							text: "Male",
							hex: "#03A9F4",
							translations: [
								{ language_code: "en", text: "Male" },
							],
						},
						{
							id: "Female",
							text: "Female",
							hex: "#E91E63",
							translations: [
								{ language_code: "en", text: "Female" },
							],
						},
					],
					width: 100,
				},
				translations: [{ language_code: "en", label: "Gender" }],
			},
			createdAt: "2023-05-18T09:58:24.000Z",
			updatedAt: "2023-05-18T10:08:39.000Z",
		},
		{
			id: "b83daff6-8624-469b-9a30-d02f68be9e29",
			name: "Person - PWA->Birthday",
			type: "field",
			json: {
				id: "b83daff6-8624-469b-9a30-d02f68be9e29",
				type: "field",
				key: "date",
				icon: "calendar",
				isImported: 0,
				columnName: "Birthday",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					dateFormat: 2,
					defaultDate: 1,
					defaultDateValue: null,
					validateCondition: "none",
					validateRangeUnit: "",
					validateRangeBefore: 0,
					validateRangeAfter: 0,
					validateStartDate: null,
					validateEndDate: null,
					width: 120,
					timeFormat: 2,
					defaultTime: 1,
					defaultTimeValue: null,
				},
				translations: [{ language_code: "en", label: "Birthday" }],
			},
			createdAt: "2023-05-18T09:58:55.000Z",
			updatedAt: "2023-05-18T09:58:55.000Z",
		},
		{
			id: "2bfc9604-8011-41ef-9985-a22de0258413",
			name: "Person - PWA->Toggle",
			type: "field",
			json: {
				id: "2bfc9604-8011-41ef-9985-a22de0258413",
				type: "field",
				key: "boolean",
				icon: "check-square-o",
				isImported: 0,
				columnName: "Toggle",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Toggle" }],
			},
			createdAt: "2023-05-18T09:59:14.000Z",
			updatedAt: "2023-05-18T09:59:14.000Z",
		},
		{
			id: "032f3208-4ae8-400e-8bbe-3edde4dae5d7",
			name: "Person - PWA->Slider",
			type: "field",
			json: {
				id: "032f3208-4ae8-400e-8bbe-3edde4dae5d7",
				type: "field",
				key: "number",
				icon: "hashtag",
				isImported: 0,
				columnName: "Slider",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "50",
					typeFormat: "none",
					typeDecimals: "none",
					typeDecimalPlaces: 0,
					typeRounding: "none",
					typeThousands: "none",
					validation: 0,
					validateMinimum: "",
					validateMaximum: "",
					width: 100,
				},
				translations: [{ language_code: "en", label: "Slider" }],
			},
			createdAt: "2023-05-18T09:59:51.000Z",
			updatedAt: "2023-05-18T09:59:51.000Z",
		},
		{
			id: "0b52730f-1e1e-476a-95ef-2824ed87da13",
			name: "Person - PWA->Bio",
			type: "field",
			json: {
				id: "0b52730f-1e1e-476a-95ef-2824ed87da13",
				type: "field",
				key: "LongText",
				icon: "align-right",
				isImported: 0,
				columnName: "Bio",
				settings: {
					showIcon: 1,
					required: 0,
					unique: 0,
					validationRules: "[]",
					default: "",
					supportMultilingual: 0,
					width: 100,
				},
				translations: [{ language_code: "en", label: "Bio" }],
			},
			createdAt: "2023-05-18T10:06:57.000Z",
			updatedAt: "2023-05-18T10:06:57.000Z",
		},
		{
			id: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
			name: "Person",
			type: "datacollection",
			json: {
				id: "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322",
				name: "Person",
				type: "datacollection",
				settings: {
					linkDatacollectionID: "",
					linkFieldID: "",
					followDatacollectionID: "",
					objectWorkspace: {
						filterConditions: { glue: "and", rules: [] },
						sortFields: [],
					},
					loadAll: false,
					isQuery: false,
					populate: true,
					syncType: 1,
					datasourceID: "faa9905e-dea8-4c7f-8eb4-98f1e6e66506",
				},
				translations: [{ language_code: "en", label: "Person" }],
			},
			createdAt: "2023-05-18T10:18:01.000Z",
			updatedAt: "2023-05-18T10:18:01.000Z",
		},
	],
	siteObjectConnections: {},
	roles: [],
});


/***/ }),

/***/ 12968:
/*!*************************************!*\
  !*** ./src/js/resources/Account.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
// var EventEmitter = require("events").EventEmitter;
// import { EventEmitter } from "events";


class Account extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.isAuthenticated = false;
      this._config = null;

      this._listRoles = null;
      // {array}
      // a list of all the Defined Roles in the Tenant's system.

      this._listScopes = null;
      // {array | null}
      // a list of all the Defined Scopes in the Tenant's sytem.

      this._listUsers = null;
      // {array | null}
      // a list of all the Defined Users in the Tenant's system.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var UserConfig = this.AB.Config.userConfig();
      if (UserConfig) {
         this.isAuthenticated = true;
         this._config = UserConfig;
      }

      var MetaConfig = this.AB.Config.metaConfig();
      if (MetaConfig) {
         this._listRoles = MetaConfig.roles || [];
         this._listScopes = MetaConfig.scopes || [];
         this._listUsers = MetaConfig.users || [];
      }

      this.AB.Network.on("account.logout", (context, err, data) => {
         if (err) {
            console.error(err);
            return;
         }
         this.emit("logout", data);
      });

      return Promise.resolve();
   }

   canSwitcheroo() {
      return (
         this.roles((r) => r.uuid === "320ef94a-73b5-476e-9db4-c08130c64bb8")
            .length > 0
      );
   }

   isSwitcherood() {
      return this.AB.Config.userReal();
   }

   isSystemDesigner() {
      return (
         this.roles((r) => r.uuid === "6cc04894-a61b-4fb5-b3e5-b8c3f78bd331")
            .length > 0
      );
   }

   email() {
      return this._config?.email ?? "";
   }

   language() {
      return this._config?.languageCode ?? "en";
   }

   logout() {
      return this.AB.Network.post(
         {
            url: "/auth/logout",
            data: { tenantUrl: this.AB.Tenant.setting("url") },
         },
         {
            key: "account.logout",
            context: {},
         }
      );
   }

   roles(fn = () => true) {
      return (this._config?.roles || []).filter(fn);
   }
   rolesAll() {
      return this._listRoles;
   }

   scopes() {
      return this._listScopes;
   }

   username() {
      return this._config?.username;
   }

   userList() {
      return this._listUsers;
   }

   uuid() {
      return this._config?.uuid;
   }

   imageID() {
      return this._config?.image_id;
   }

   sendEmailNotifications() {
      return this._config?.sendEmailNotifications;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Account());


/***/ }),

/***/ 77269:
/*!************************************!*\
  !*** ./src/js/resources/Config.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ 96486);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
// import ConfigDesktop from "./configDesktop";
// import ConfigMobile from "./configMobile";

// var EventEmitter = require("events").EventEmitter;


const settingsDefault = {
   "appbuilder-portal-autoenter": true,
   // {bool} autoenter
   // open up the portal as soon as we load.
   //   false : just displays a link that will load the portal

   "appbuilder-portal-fullscreen": true,
   // {bool} fullscreen
   // take up the full browser window?
   //   false : only take up the area the current div is

   "appbuilder-tenant": null,
   // {string} tenant
   // the tenant uuid for this AppBuilder instance.

   "appbuilder-view": "work",
   // {string} view
   // the default view to display to the current user.

   "appbuilder-tenant-prefix": null,
   // TESTING! Remove this
};

const configDefaults = {
   site: {
      appbuilder: {
         networkType: "rest", // "socket",
         // options: ["rest", "relay", "socket"]
         // Note: "socket" is required for realtime updates across devices.

         networkNumRetries: 3,
         // the number of times we will retry sending a network request
         // when we receive a timeout error.

         urlCoreServer: window.location.origin,
         // on the web client, just record the current URL by default.
         // the site config can override this if they want.
      },
      storage: {
         encrypted: false,
         // {bool} should we encrypt our data in the local browser storage?
      },
   },
};
class Config {
   constructor() {
      // this.setMaxListeners(0);
      this._config = null;
      // {obj} _config
      // these are the configuration settings returned from the server. These
      // are more detailed configuration settings for the running of the site.

      this._settings = {};
      // {obj} _settings
      // settings are the configuration parameters found on the base <div>
      // these settings are the minimum needed to successfully pull up the
      // portal popup and perform the initial config request
   }

   config(json) {
      this._config = json;
      (0,lodash__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep)(this._config, configDefaults);
   }

   setting(key, value) {
      if (value) {
         this._settings[key] = value;
         return;
      }
      return this._settings[key];
   }

   settingsFromDiv(div) {
      Object.keys(settingsDefault).forEach((d) => {
         var val = div.getAttribute(d);
         if (!val) {
            val = settingsDefault[d];
         }
         if (val === "false") val = false;
         if (val === "true") val = true;

         var key = d.split("-").pop();
         this.setting(key, val);
      });
   }

   settings(json = {}) {
      for (let key in settingsDefault) {
         const val = json[key] ?? settingsDefault[key];
         this.setting(key.split("-").pop(), val);
      }
   }

   /**
    * definitions()
    * return the ABDefinition(s) required to manage the interface.
    * @return {obj}
    *          { ABDefinition.id : {ABDefinition} }  hash of definitions.
    */
   definitions() {
      debugger;
      return window.definitions;
   }

   error(/* ...args */) {
      console.error("Who is calling this? -> move to AB.error() instead.");
      // this.emit("ab.error", args);
   }

   labelConfig() {
      if (this._config && this._config.labels) {
         return this._config.labels;
      }
      console.error("No Label config found.");
      return {};
   }

   languageConfig() {
      if (this._config && this._config.languages) {
         return this._config.languages;
      }
      console.error("No Language config found.");
      return {};
   }

   metaConfig() {
      if (this._config && this._config.meta) {
         return this._config.meta;
      }
      console.error("No Meta config found.");
      return {};
   }

   plugins() {
      // TODO: Pull from this._config.plugins
      return ["ABDesigner.js"];
      // return [];
   }

   inboxConfig() {
      if (this._config && this._config.inbox) {
         return this._config.inbox;
      }
      return null;
   }

   inboxMetaConfig() {
      if (this._config && this._config.inboxMeta) {
         return this._config.inboxMeta;
      }
      return null;
   }

   siteConfig() {
      if (this._config && this._config.site) {
         return this._config.site;
      }
      return configDefaults.site;
   }

   tenantConfig() {
      if (this._config && this._config.tenant) {
         return this._config.tenant;
      }
      return null;
   }

   uiSettings() {
      if (window.innerWidth < 768) {
         return ConfigMobile;
      }
      return ConfigDesktop;
   }

   userConfig() {
      if (this._config && this._config.user) {
         return this._config.user;
      }
      return null;
   }

   userReal() {
      return this._config?.userReal ?? false;
   }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Config());


/***/ }),

/***/ 28917:
/*!******************************************!*\
  !*** ./src/js/resources/Multilingual.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABMLClass */ 46148);
/*
 * Multilingual
 * manage our multilingual Translations/Labels/etc.
 */



class Multilingual extends _AppBuilder_platform_ABMLClass__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super([], {});
      // super()
      //    [] = no labels
      //    {} = placeholder ABFactory entry until .init() is called.

      this.isAuthenticated = false;
      this._config = null;

      this._missingLabelID = false;
      this._missingLabels = {};
      this._pluginLabelsMissing = {};
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.labels = this.AB.Config.labelConfig();
      this._languages = this.AB.Config.languageConfig();

      this.pluginLabels = {};

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   currentLanguage() {
      return this.AB.Account.language();
   }

   label(key, altText, values = [], postMissing = true) {
      // part of our transition: L("single string") should start to work:
      if (typeof altText == "undefined" && key) {
         altText = key;
      }

      // other case: L("single string {0}", [])
      if (arguments.length == 2 && Array.isArray(altText)) {
         values = altText;
         altText = key;
      }

      // We need to escape " characters or else they will get added to the the lang.js
      // then we get errors next time we try to parse it as JSON (see appbuilder.label-missing)
      altText = altText.replace(/"/g, '\\"');
      key = key.replace(/"/g, '\\"');

      // NOTE: transition to new Labels
      // currently our code still uses the L(key, altText, values) format, but
      // the labels we get back are in L(altText, values) format.
      //
      // we are going to keep this like this until we have a well functioning
      // UI display of our Apps, which should flesh out most of the missing
      // labels to our files.
      //
      // After that, convert our L(k, t, v) to L(t, v)

      var newKey = altText;
      if (newKey[0] == "*") {
         newKey = newKey.slice(1);
      }
      var label = this.labels[newKey];
      if (!label) {
         if (postMissing) {
            this.postMissingLabel(key, altText);
         }
         label = altText;
      }

      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      label = label.replace(/\\"/g, '"'); // unescape " in the label
      return label;
   }

   labelPlugin(plugin, altText, values = []) {
      // 1st check to see if it is a common label from platform:
      var label = this.label(altText, altText, values, false);
      if (!label) {
         // ok, so check to see if it is a Plugin Label:
         label = this.pluginLabels[plugin][altText];
      }
      if (!label) {
         // !! record it missing.
         this._pluginLabelsMissing[plugin] =
            this._pluginLabelsMissing[plugin] || {};
         this._pluginLabelsMissing[plugin][altText] = altText;
         label = altText;
      }
      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      return label;
   }

   languages() {
      return this._languages;

      // console.error(
      //    "Multilingual:languages(): Implement Language Storage/Retrieval."
      // );
      // return [];
   }

   pluginLoadLabels(key, labels) {
      this.pluginLabels[key] = labels;
   }
   pluginLabelReport(key) {
      console.warn("missing labels for plugin: ", key);
      console.warn("current language:", this.currentLanguage());
      var labels = JSON.stringify(this._pluginLabelsMissing[key], null, 3);
      console.warn(labels);
   }

   postMissingLabel(key, altText) {
      if (this._missingLabelID) {
         clearTimeout(this._missingLabelID);
      }
      var batchLength = 50;
      var sendBatch = () => {
         var batchLabels = [];
         let missingLabels = Object.keys(this._missingLabels).map(
            (k) => this._missingLabels[k]
         );
         if (missingLabels.length <= batchLength) {
            batchLabels = missingLabels;
            this._missingLabels = {};
         } else {
            for (var i = 0; i <= batchLength; i++) {
               var l = missingLabels.shift();
               batchLabels.push(l);
               delete this._missingLabels[l.key];
            }
         }
         this.AB.Network.post({
            url: "/multilingual/label-missing",
            data: { labels: JSON.stringify(batchLabels) },
         })
            .then(() => {
               if (Object.keys(this._missingLabels).length > 0) {
                  sendBatch();
               }
            })
            .catch((err) => {
               const strErr = err.toString();
               if (strErr.indexOf("unable to get") > -1) {
                  console.error(
                     "Missing language file for :" + this.currentLanguage()
                  );
               }
            });
      };
      this._missingLabelID = setTimeout(() => {
         sendBatch();
      }, 1000);

      this._missingLabels[key] = { key, altText };
   }
   ///
   /// Disable un-needed ABMLClass functionality
   ///
   /// NOTE: we are mainly Piggybacking on ABMLClass for it's
   /// .translate() and .unTranslate() capabilities. So disable these
   /// for good measure.
   destroy() {
      console.error("Multilingual:destroy(): Should not be called.");
      return Promise.resolve();
   }
   save() {
      console.error("Multilingual:save(): Should not be called.");
      return Promise.resolve();
   }
   toObj() {
      console.error("Multilingual:toObj(): Should not be called.");
      return {};
   }
   toDefinition() {
      console.error("Multilingual:toDefinition(): Should not be called.");
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Multilingual());


/***/ }),

/***/ 93360:
/*!*************************************!*\
  !*** ./src/js/resources/Network.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NetworkRest */ 84292);
/* harmony import */ var _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetworkRestSocket */ 27299);
/*
 * Network.js
 * A network manager for interfacing with our AppBuilder server.
 */



// import NetworkRelay from "./NetworkRelay";

class Network extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.setMaxListeners(0);
      // we'll have > 10 for sure!

      this.queueLock = null;
      // {Lock} .queueLock
      // our semaphore for coordinating our access to our local storage.

      this._config = null;
      this._network = null;
      // {NetworkRelay | NetworkRest | NetworkSocket}
      // the underlying Network connection object actually performing the
      // communications with the Server.
      // Which one is specified in the config.appbuilder.networkType setting

      this._queueCount = 0;
      // {int} _queueCount
      // the # of network operations currently queued, pending Network
      // reconnect.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.queueLock = new this.AB.Lock();

      this._config = this.AB.Config.siteConfig();
      if (this._config) {
         switch (this._config.appbuilder.networkType) {
            case "relay":
               // this._network = new NetworkRelay();
               break;

            case "socket":
               this._network = new _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_2__["default"](this);
               break;

            case "rest":
            default:
               this._network = new _NetworkRest__WEBPACK_IMPORTED_MODULE_1__["default"](this);
               break;
         }

         return this._network.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      //
      // Handle reconnections and flushing the Queue:
      //
      if (io && io.socket) {
         // When our Socket reconnects, be sure to flush any pending transactions.
         io.socket.on("connected", () => {
            this.queueFlush();
            if (this.idConnectionCheck) {
               clearTimeout(this.idConnectionCheck);
               this.idConnectionCheck = null;
            }
         });
      } else {
         console.error("!!! Network.init() : Did not find io.socket");
         window.addEventListener("online", () => this.queueFlush());
      }

      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.isRealTime
    * indicates wether or not the current network connection supports
    * RealTime updates.
    * @return {bool}
    */
   get isRealTime() {
      return this._network.isRealTime;
   }

   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(...params) {
      return this._network.get(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * this is a CREATE operation.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(...params) {
      return this._network.post(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * This is for UPDATE/REPLACE operations to data on the server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(...params) {
      return this._network.put(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(...params) {
      return this._network.delete(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   ////
   //// Network Utilities
   ////

   _connectionCheck() {
      // if (!this.idConnectionCheck) {
      if (this.isNetworkConnected()) {
         this.queueFlush().catch(() => {
            // on an error, we are still having connection issues
            this.idConnectionCheck = setTimeout(() => {
               this._connectionCheck();
            }, 250);
         });
         this.idConnectionCheck = null;
      } else {
         this.idConnectionCheck = setTimeout(() => {
            this._connectionCheck();
         }, 250);
      }
      // }
   }

   /**
    * @method networkStatus
    * return the connection type currently registered with the network
    * plugin.
    * @return {string}
    */
   networkStatus() {
      return navigator.connection.type;
   }

   /**
    * @method isNetworkConnected
    * return true/false if the device is currently connected to the
    * internet.
    * @return {bool}
    */
   isNetworkConnected() {
      console.log(
         "TODO: Network.isNetworkConnected(): replace online check to expected order."
      );
      // if this isn't a Cordova Plugin, then return navigator data:
      if (typeof Connection == "undefined") {
         // NOTE: this technically only detects if we are connected to a
         // network.  It doesn't guarantee we can communicate across the 'net
         return navigator.onLine;
      }

      // if this is a Web Client and using sails.socket.io
      if (io && io.socket && io.socket.isConnected) {
         return io.socket.isConnected();
      }

      // if this isn't a Cordova Plugin, then return navigator data:
      if (typeof Connection == "undefined") {
         // NOTE: this technically only detects if we are connected to a
         // network.  It doesn't guarantee we can communicate across the 'net
         return navigator.onLine;
      }

      // Cordova Plugin:
      return this.networkStatus() != Connection.NONE;
   }

   /**
    * publishResponse()
    * emit the requested response for this network operation.
    * @param {obj} jobResponse
    * @param {obj} error
    * @param {obj} data
    */
   publishResponse(jobResponse, error, data) {
      if (data) {
         data = this.normalizeData(data);
      }
      this.emit(jobResponse.key, jobResponse.context, error, data);
   }

   normalizeData(data) {
      // Data returning from our server is wrapped in an outer layer of
      // information that is for our Networking API.
      // the outer wrapper should be:
      // on success :
      // {
      //   status: "success",
      //   data:{Data For App}
      // }
      // on Error:
      // {
      //   status: "error",
      //   id: {int} error code
      //   ... other data here
      // }

      // we have physically received a data packet from the server,
      // but we are informed that our transaction was problematic
      // (400 level USER problem?)
      if (data.status === "error") {
         // TODO: review Error procedure here
         return data;
      }

      // on success
      // make sure we return the Application Level Data packet:
      return data.data || data;
   }

   ////
   //// Queued Requests
   ////

   /**
    * refQueue()
    * sub classes can override this for their own separate Queue Data
    * @return {string}
    */
   refQueue() {
      return "networkQueue";
   }

   /**
    * queueCount()
    * return the # of messages in the queue.
    * @return {int}
    */
   queueCount() {
      return this._queueCount;
   }

   /**
    * Adds a request to the outgoing queue.
    *
    * @param {object} data
    * @param {object} jobResponse
    * @return {Promise}
    */
   queue(data, jobResponse) {
      var refQueue = this.refQueue();

      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })
            .then((queue) => {
               queue = queue || [];
               queue.push({ data, jobResponse });
               this.AB.log(
                  `:::: ${queue.length} request${
                     queue.length > 1 ? "s" : ""
                  } queued`
               );
               this._queueCount = queue.length;
               return this.AB.Storage.set(refQueue, queue);
            })
            .then(() => {
               this.emit("queued");
               // if we are not already polling the network, start
               if (!this.idConnectionCheck) {
                  this._connectionCheck();
               }
               this.queueLock.release();
               resolve();
            })
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "Error while queueing data",
               });
               this.AB.Analytics.logError(err);
               reject(err);

               this.queueLock.release();
            });
      });
   }

   /**
    * queueFlush()
    * Flush the queue and send the contents to the relay server.
    */
   queueFlush() {
      var refQueue = this.refQueue();

      // if we are not connected, then stop
      if (!this.isNetworkConnected()) {
         var error = new Error("Not connected to the internet.");
         error.code = "E_NOTCONNECTED";
         return Promise.reject(error);
      }

      // otherwise, attempt to flush the queue:
      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()

            //
            // Get queue contents
            //
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })

            //
            // Send off each queued request
            //
            .then((queue) => {
               // default to [] if not found
               queue = queue || [];

               // recursively process each pending queue request
               var processRequest = (cb) => {
                  if (queue.length == 0) {
                     cb();
                  } else {
                     var entry = queue.shift();
                     var params = entry.data;
                     var job = entry.jobResponse;
                     this._network
                        .resend(params, job)
                        .then(() => {
                           processRequest(cb);
                        })
                        .catch((err) => {
                           // if the err was due to a network connection error
                           if (err && err.code == "E_TOMANYRETRIES") {
                              cb(err);
                              return;
                           }
                           // otherwise, try the next
                           processRequest(cb);
                        });
                  }
               };

               return new Promise((res, rej) => {
                  processRequest((err) => {
                     if (err) {
                        rej(err);
                     } else {
                        res();
                     }
                  });
               });
            })

            //
            // Clear queue contents
            //
            .then(() => {
               this._queueCount = 0;
               return this.AB.Storage.set(refQueue, []);
            })

            // release the Lock
            .then(() => {
               this.emit("queue.synced");
               return this.queueLock.release();
            })

            // all done.
            .then(() => {
               resolve();
            })

            // respond to errors:
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "commAPI queueFlush error",
               });
               this.AB.Analytics.logError(err);

               this.queueLock.release().then(() => {
                  reject(err);
               });
            });
      });
   }

   /**
    * Reset credentials to a blank state.
    * @return {Promise}
    */
   reset() {
      return Promise.resolve();
   }

   /**
    * type()
    * return the type of network connection we are using.
    * ["rest", "socket", "relay"]
    * @return {string}
    */
   type() {
      return this._config.appbuilder.networkType;
   }

   // uuid() {
   //    return this.AB.uuid();
   // }

   getTokens() {
      // called in appPage.js : openRelayLoader()
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Network());


/***/ }),

/***/ 84292:
/*!*****************************************!*\
  !*** ./src/js/resources/NetworkRest.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */

/* global navigator Connection */
// import Account from "./Account";
// import analytics from "./Analytics";
// import EventEmitter from "eventemitter2";

// import Lock from "./Lock";

// import { storage } from "./Storage";
// import Tenant from "./Tenant";
// import { v4 as uuidv4 } from "uuid";

// Temp placeholders until Resources are implemented:

// End Temp
// var Atomic = Window.atomic;
// import Atomic from "../../../node_modules/atomicjs/dist/atomic.polyfills.js";
// Atomic : a small $.ajax() replacement

var Config = null;
// {} Config
// the site specific configuration information

class NetworkRest extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super({
         wildcard: true,
         newListener: false,
         maxListeners: 0,
      });

      this.baseURL = null;
      // {string} .baseURL
      // the url of our site.

      this.numRetries = 3;
      // {int} .numRetries
      // the number or times we should attempt to issue a network request.

      this._network = parent;
      // {Network} ._network
      // the Parent Network Resource that the rest of the Platform actually
      // works with.

      this.isRealTime = false;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);
   }

   /**
    * @method init
    * @param {ABFactory} AB
    * @param {object} options
    * @param {string} options.baseURL
    * @return {Promise}
    */
   init(AB, options) {
      this.AB = AB;

      Config = this.AB.Config.siteConfig();
      options = options || {};
      if (options) {
         this.baseURL = options.baseURL || Config.appbuilder.urlCoreServer;
         this.numRetries =
            options.networkNumRetries || Config.appbuilder.networkNumRetries;
      }
      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(params, jobResponse) {
      params.type = params.type || "GET";

      // data sent to params on a "GET" request need to be converted to
      // uri querystring values:
      var data = params.data || params.params;
      if (data) {
         var useThese = ["string", "number", "boolean"];
         var search = Object.keys(data)
            .map(function (key) {
               var val = data[key];
               if (useThese.indexOf(typeof val) == -1) {
                  val = JSON.stringify(val);
               }
               return key + "=" + encodeURIComponent(val);
            })
            .join("&");

         var join = "?";
         if (params.url.indexOf("?") > -1) {
            join = "&";
         }
         params.url = [params.url, search].join(join);
      }

      return this._request(params, jobResponse);
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(params, jobResponse) {
      params.type = params.type || "POST";
      return this._request(params, jobResponse);
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(params, jobResponse) {
      params.type = params.type || "PUT";
      return this._request(params, jobResponse);
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(params, jobResponse) {
      params.type = params.type || "DELETE";
      return this._request(params, jobResponse);
   }

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return this._network.isNetworkConnected();
   }

   salSend(params) {
      return Window.atomic(params.url, params).then((packet) => {
         // {json} packet
         // the response from Atomic is in format:
         // {data: {…}, xhr: XMLHttpRequest}
         // we just want to send back our { status:"", data:xxx } packet.
         return packet.data;
      });
   }

   /**
    * _request()
    * perform the actual AJAX request for this operation.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   _request(params, jobResponse) {
      // make sure we don't process too many retries:
      params._retry = params._retry || 0;
      if (params._retry >= this.numRetries) {
         var err = new Error(
            `Too many retries (${this.numRetries}) for ${params.url}`
         );
         err.code = "E_TOMANYRETRIES";
         this.AB.notify.developer(err, {
            context: "NetworkRest:_request: Too Many Retries",
         });
         // this.AB.Analytics.logError(err);
         if (jobResponse) {
            this._network.publishResponse(jobResponse, err);
         }

         return Promise.reject(err);
      }

      return new Promise((resolve, reject) => {
         params.withCredentials = true;
         params.url = params.url || "/";
         if (params.url[0] == "/") {
            params.url = this.baseURL + params.url;
         }

         params.headers = params.headers || {};
         if (this.AB.Account.authToken) {
            params.headers.Authorization = this.AB.Account.authToken;
         }
         params.headers["Content-type"] = "application/json";

         var tenantID = this.AB.Tenant.id();
         if (tenantID) {
            params.headers["tenant-token"] = tenantID;
         }

         // params.timeout = params.timeout || 6000;

         if (this.isNetworkConnected()) {
            params.method = params.method || params.type;
            params.timeout = 6000; // ??
            params.data = params.data || params.params;
            delete params.params;

            this.salSend(params)
               .then((packet) => {
                  // TODO: check if packet.status == "error"
                  // and then .publishResponse() as an error

                  //
                  var data = packet;
                  if (jobResponse) {
                     this._network.publishResponse(jobResponse, null, data);
                  }
                  resolve(data);
               })
               .catch((err) => {
                  // err.status
                  // err.statusText
                  // err.responseText
                  // err.message  {socket}
                  // err.stack    {socket}

                  // if this is a network connection error, send the attempt again:
                  if (
                     err.statusText == "Request timeout" ||
                     (err.message && err.message.indexOf("disconnected") > -1)
                  ) {
                     //// Network Error: conneciton refused, access denied, etc...
                     this.AB.Analytics.log(
                        "NetworkRest._request():network connection error detected. Trying again"
                     );

                     params._retry++;

                     // retry the attempt:
                     this._request(params)
                        .then((data) => {
                           // console.log('--- timeout.then():',data);
                           this.AB.warn(
                              "*** NetworkRest._request().then(): attempt resolved."
                           );
                           resolve(data);
                        })
                        .catch((_err) => {
                           this.AB.notify.developer(_err, {
                              message:
                                 "*** NetworkRest._request().catch(): retry failed:",
                           });
                           reject(_err);
                        });

                     return;
                  } else {
                     // Else attempt to emit() some common Error types for
                     // additional Platform Handling.
                     if (err.status == 403) {
                        this.emit("error.badAuth", err);
                     } else if (err.status >= 400 && err.status < 500) {
                        this.emit("error.badRequest", err);
                     } else if (err.status >= 500) {
                        this.emit("error.badServer", err);
                     }
                  }

                  var packet = null;
                  if (err.responseText) {
                     try {
                        packet = JSON.parse(err.responseText);
                     } catch (e) {}
                  }
                  // if this is an req.ab.error() response:
                  if (packet && packet.status == "error") {
                     // check if REAUTH Error:
                     if (packet.id == 5 || packet.code == "E_REAUTH") {
                        this._network.emit("reauth");
                        return;
                     }

                     this.AB.notify.developer(packet, {
                        context:
                           "NetworkRest:_request:Error returned from Server (req.ab.error())",
                        data: packet.data,
                     });
                     // this.AB.Analytics.logError(packet.data);
                     // this.AB.error(packet.data);
                     if (jobResponse) {
                        this._network.publishResponse(
                           jobResponse,
                           packet,
                           null
                        );
                     }
                     return reject(packet.data);
                  } else {
                     // unknown/unexpected error:
                     var error = new Error(
                        `${err.status} ${err.statusText || err.message}: ${
                           params.method
                        } ${params.url}`
                     );
                     error.response = err.responseText;
                     error.text = err.statusText;
                     error.err = err;
                     error.url = `${params.method} ${params.url}`;
                     this.AB.notify.developer(error, {
                        context:
                           "NetworkRest:_request:Unknown Error returned from server",
                     });
                     // this.AB.Analytics.logError(error);
                     // this.AB.error(error);
                     if (jobResponse) {
                        this._network.publishResponse(jobResponse, error);
                     }
                     return reject(error);
                  }
               });
         } else {
            // now Queue this request params.
            this.AB.Analytics.log(
               "NetworkRest:_request(): Network is offline. Queuing request."
            );
            this._network
               .queue(params, jobResponse)
               .then(() => {
                  resolve({ status: "queued" });
               })
               .catch(reject);
         }
      });
   }

   /**
    * resend()
    * processes messages that were queued due to network connectivity
    * issues.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   resend(params, jobResponse) {
      // var op = params.type.toLowerCase();
      return this._request(params, jobResponse);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRest);


/***/ }),

/***/ 27299:
/*!***********************************************!*\
  !*** ./src/js/resources/NetworkRestSocket.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRest */ 84292);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */



const listSocketEvents = [
   // NOTE: ABFactory.definitionXXX() will manage emitting these
   // events internally:
   // "ab.abdefinition.create",
   // "ab.abdefinition.update",
   // "ab.abdefinition.delete",
   "ab.datacollection.create",
   "ab.datacollection.update",
   "ab.datacollection.stale",
   "ab.datacollection.delete",
   "ab.inbox.create",
   "ab.inbox.update",
   // "ab.object.update",
];
// {array}
// The io.socket.* events we are listening for that relate to our datacollection
// maintainence.

class NetworkRestSocket extends _NetworkRest__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super(parent);

      this.isRealTime = true;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);

      // Pass the io.socket.on(*) events to our AB factory.
      listSocketEvents.forEach((ev) => {
         io.socket.on(ev, (data) => {
            // check if the ev contains 'datacollection'
            // and do a single normalizeData() on the incoming data here
            // before sending it off to be processed.
            if (ev.indexOf("ab.datacollection") > -1) {
               let values = data.data;
               if (values) {
                  let obj = this.AB.objectByID(data.objectId);
                  if (obj) {
                     let model = obj.model();
                     if (ev != "ab.datacollection.delete") {
                        let jobID = this.AB.jobID();
                        console.log(`${jobID} : ${ev}:normalization begin`);
                        let timeFrom = performance.now();
                        model.normalizeData(data.data);
                        let timeTo = performance.now();
                        console.log(
                           `${jobID} : ${ev}:normalization end:  ${
                              timeTo - timeFrom
                           }ms`
                        );
                     }
                  }
               }
            }
            this.AB.emit(ev, data);
         });
      });
   }

   //
   // Interface API
   //

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return io.socket.isConnected();
   }

   salSend(params) {
      return new Promise((resolve, reject) => {
         params.method = params.method.toLowerCase();

         io.socket.request(params, (data, jwres) => {
            // {json} data
            // the data response from the request
            // {json} jwres
            // A JSON WebSocket Response object.
            //    {json} jwres.headers :  header values
            //    {int}  jwres.statusCode : http response code
            //    {json} jwres.body === resData

            // if this is an  error
            if (jwres.statusCode >= 400) {
               // Our NetworkRest.error( err ) should be in this format:
               // err.status
               // err.statusText
               // err.responseText

               var errStr = jwres.error ? jwres.error.toString() : jwres.body;

               var err = new Error(`Socket Error: ${errStr}`);
               err.status = jwres.statusCode;
               err.statusText = errStr;
               err.responseText = jwres.body;

               // on RequestTimeout:
               // err.statusText == "Request timeout"

               reject(err);
            } else {
               // some errors like socket disconnected return an Error for data
               if (data instanceof Error) {
                  reject(data);
                  return;
               }

               if (typeof data == "string") {
                  data = JSON.parse(data);
               }

               // Got a JSON response but was the service response an error?
               // this would be a strange case where the .statusCode < 400
               if (data.status && data.status == "error") {
                  // make sure to reject an err.responseText = data
                  reject({
                     status: jwres.statusCode,
                     responseText: JSON.Stringify(data),
                  });
               }
               // Success!
               else {
                  resolve(data);
               }
            }
         });
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRestSocket);


/***/ }),

/***/ 35397:
/*!*************************************!*\
  !*** ./src/js/resources/Storage.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StorageLocal.js */ 20813);




class Storage extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.tenantStorage = null;
      this._config = null;
      this._storage = null;
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var config = this.AB.Config.siteConfig();
      if (config) {
         if (config.storage && config.storage.encrypted) {
            console.error("TODO: Implement Encrypted Storage");
            // this._storage = StorageEncrypted;
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__["default"];
         } else {
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_1__["default"];
         }

         return this._storage.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      return Promise.resolve();
   }

   set(...params) {
      return this._storage.set(...params);
   }

   get(...params) {
      return this._storage.get(...params);
   }

   clear(...params) {
      return this._storage.clear(...params);
   }

   clearAll(...params) {
      return this._storage.clearAll(...params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Storage());


/***/ }),

/***/ 20813:
/*!******************************************!*\
  !*** ./src/js/resources/StorageLocal.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/*
 * StorageLocal
 *
 * An interface for storing and retrieving Client Side data.  Data stored
 * in StorageLoacal is NOT encrypted.
 *
 * This implementation is based upon the webix.storage.local library.
 * See: https://docs.webix.com/api__refs__storage.local.html
 *
 */



class StorageLocal extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.tenantStorage = null;
      // {Webix.storage} object.
      // We divide the storage data according to the tenant we are working
      // with.  This way Users who can move between different Tenants can
      // keep their local data separated.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      this.tenantID = this.AB.Tenant.id();
      if (!this.tenantID) {
         this.tenantID = "noAuth";
         // "noAuth" is considered the tenant on our Login sequence
         // which should have a minimum of data stored (language maybe?)
      }

      this.tenantStorage = JSON.parse(
         window.localStorage.getItem(this.tenantID) || "{}"
      );

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   _save() {
      return Promise.resolve(
         localStorage.setItem(this.tenantID, JSON.stringify(this.tenantStorage))
      );
   }

   set(key, value /* , options = {} */) {
      return Promise.resolve().then(() => {
         this.tenantStorage[key] = value;
         return this._save();
      });
   }

   get(key /*, options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage[key];
      });
   }

   clear(key) {
      return Promise.resolve().then(() => {
         delete this.tenantStorage[key];
         return this._save();
      });
   }

   clearAll() {
      return Promise.resolve().then(() => {
         this.tenantStorage = {};
         return this._save();
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StorageLocal());


/***/ }),

/***/ 75342:
/*!************************************!*\
  !*** ./src/js/resources/Tenant.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter */ 4025);
/* harmony import */ var _Config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config.js */ 77269);



class Tenant extends _AppBuilder_platform_ABEmitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor() {
      super();

      this.text = false;
      this._config = null;
      this.textClickToEnter = null;
   }

   init() {
      var config = _Config_js__WEBPACK_IMPORTED_MODULE_1__["default"].tenantConfig();
      if (config) {
         // check if we have options that are stored as a string
         if (
            typeof config.options === "string" ||
            config.options instanceof String
         ) {
            // if we do try to parse them into a JSON object
            try {
               config.options = JSON.parse(config.options);
            } catch (error) {
               console.error(error);
            }
         }
         this._config = config;
         this.textClickToEnter = config.options.textClickToEnter;
      }

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   id() {
      if (!this._config || this._config.id == "??") {
         return _Config_js__WEBPACK_IMPORTED_MODULE_1__["default"].setting("tenant");
      }
      return this._config.id;
   }

   setting(key, value) {
      if (this._config) {
         if (value) {
            this._config.options[key] = value;
            return;
         }
         return this._config.options[key];
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Tenant());


/***/ }),

/***/ 43183:
/*!**************************!*\
  !*** ./src/js/routes.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pages_404_f7_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pages/404.f7.jsx */ 22167);
/* harmony import */ var _pages_form_f7_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pages/form.f7.jsx */ 84723);
/* harmony import */ var _pages_home_f7_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pages/home.f7.jsx */ 59289);
/* harmony import */ var _pages_list_f7_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pages/list.f7.jsx */ 42767);





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((AB) => {
   const Application = AB.applications()[0]; // AB.applicationByID("4b7a489a-5fe5-4044-8565-aaa3654300f2");

   AB.isInitialized = false;

   AB.Network.on("reauth", () => {
      AB.isInitialized = false;
      AB.$f7.loginScreen.open("#my-login-screen");
   });

   const routes = [
      {
         path: "/",
         component: (0,_pages_home_f7_jsx__WEBPACK_IMPORTED_MODULE_2__["default"])(AB),
      },
      {
         path: "/form",
         component: (0,_pages_form_f7_jsx__WEBPACK_IMPORTED_MODULE_1__["default"])(AB),
      },
      {
         path: "/list",
         component: (0,_pages_list_f7_jsx__WEBPACK_IMPORTED_MODULE_3__["default"])(AB),
      },
      {
         path: "(.*)",
         component: (0,_pages_404_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"])(AB),
      },
   ];

   const listPages = Application.pages();

   listPages.forEach((Page) => {
      routes.push(Page.routeComponent());
   });

   // Now add the final NotFoundPage for all other references:
   routes.push({
      path: "(.*)",
      component: (0,_pages_404_f7_jsx__WEBPACK_IMPORTED_MODULE_0__["default"])(AB),
   });

   return routes;
});


/***/ }),

/***/ 55730:
/*!****************************!*\
  !*** ./src/js/sails.io.js ***!
  \****************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */

/**
 * To use sails.io.js in an AMD environment (e.g. with require.js),
 * replace this file with the sails.io.js file from the root of:
 * https://github.com/balderdashy/sails.io.js
 * and download a standalone copy of socket.io-client from:
 * https://github.com/socketio/socket.io-client
 * then follow the instructions at:
 * https://github.com/balderdashy/sails.io.js#requirejsamd-usage
 */

// socket.io-client version 2.0.3
// https://github.com/socketio/socket.io-client

!(function(a, b) {
   true
    ? (module.exports = b())
    : 0;
})(this, function() {
  return (function(a) {
    function b(d) {
      if (c[d]) return c[d].exports;
      var e = (c[d] = { exports: {}, id: d, loaded: !1 });
      return a[d].call(e.exports, e, e.exports, b), (e.loaded = !0), e.exports;
    }
    var c = {};
    return (b.m = a), (b.c = c), (b.p = ""), b(0);
  })([
    function(a, b, c) {
      "use strict";
      function d(a, b) {
        "object" === ("undefined" == typeof a ? "undefined" : e(a)) &&
          ((b = a), (a = void 0)),
          (b = b || {});
        var c,
          d = f(a),
          g = d.source,
          k = d.id,
          l = d.path,
          m = j[k] && l in j[k].nsps,
          n =
            b.forceNew || b["force new connection"] || !1 === b.multiplex || m;
        return (
          n
            ? (i("ignoring socket cache for %s", g), (c = h(g, b)))
            : (j[k] || (i("new io instance for %s", g), (j[k] = h(g, b))),
              (c = j[k])),
          d.query && !b.query && (b.query = d.query),
          c.socket(d.path, b)
        );
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(1),
        g = c(7),
        h = c(13),
        i = c(3)("socket.io-client");
      a.exports = b = d;
      var j = (b.managers = {});
      (b.protocol = g.protocol),
        (b.connect = d),
        (b.Manager = c(13)),
        (b.Socket = c(39));
    },
    function(a, b, c) {
      (function(b) {
        "use strict";
        function d(a, c) {
          var d = a;
          (c = c || b.location),
            null == a && (a = c.protocol + "//" + c.host),
            "string" == typeof a &&
              ("/" === a.charAt(0) &&
                (a = "/" === a.charAt(1) ? c.protocol + a : c.host + a),
              /^(https?|wss?):\/\//.test(a) ||
                (f("protocol-less url %s", a),
                (a =
                  "undefined" != typeof c
                    ? c.protocol + "//" + a
                    : "https://" + a)),
              f("parse %s", a),
              (d = e(a))),
            d.port ||
              (/^(http|ws)$/.test(d.protocol)
                ? (d.port = "80")
                : /^(http|ws)s$/.test(d.protocol) && (d.port = "443")),
            (d.path = d.path || "/");
          var g = d.host.indexOf(":") !== -1,
            h = g ? "[" + d.host + "]" : d.host;
          return (
            (d.id = d.protocol + "://" + h + ":" + d.port),
            (d.href =
              d.protocol +
              "://" +
              h +
              (c && c.port === d.port ? "" : ":" + d.port)),
            d
          );
        }
        var e = c(2),
          f = c(3)("socket.io-client:url");
        a.exports = d;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      var c = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        d = [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ];
      a.exports = function(a) {
        var b = a,
          e = a.indexOf("["),
          f = a.indexOf("]");
        e != -1 &&
          f != -1 &&
          (a =
            a.substring(0, e) +
            a.substring(e, f).replace(/:/g, ";") +
            a.substring(f, a.length));
        for (var g = c.exec(a || ""), h = {}, i = 14; i--; )
          h[d[i]] = g[i] || "";
        return (
          e != -1 &&
            f != -1 &&
            ((h.source = b),
            (h.host = h.host
              .substring(1, h.host.length - 1)
              .replace(/;/g, ":")),
            (h.authority = h.authority
              .replace("[", "")
              .replace("]", "")
              .replace(/;/g, ":")),
            (h.ipv6uri = !0)),
          h
        );
      };
    },
    function(a, b, c) {
      (function(d) {
        function e() {
          return (
            !(
              "undefined" == typeof window ||
              !window.process ||
              "renderer" !== window.process.type
            ) ||
            ("undefined" != typeof document &&
              document.documentElement &&
              document.documentElement.style &&
              document.documentElement.style.WebkitAppearance) ||
            ("undefined" != typeof window &&
              window.console &&
              (window.console.firebug ||
                (window.console.exception && window.console.table))) ||
            ("undefined" != typeof navigator &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
              parseInt(RegExp.$1, 10) >= 31) ||
            ("undefined" != typeof navigator &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
          );
        }
        function f(a) {
          var c = this.useColors;
          if (
            ((a[0] =
              (c ? "%c" : "") +
              this.namespace +
              (c ? " %c" : " ") +
              a[0] +
              (c ? "%c " : " ") +
              "+" +
              b.humanize(this.diff)),
            c)
          ) {
            var d = "color: " + this.color;
            a.splice(1, 0, d, "color: inherit");
            var e = 0,
              f = 0;
            a[0].replace(/%[a-zA-Z%]/g, function(a) {
              "%%" !== a && (e++, "%c" === a && (f = e));
            }),
              a.splice(f, 0, d);
          }
        }
        function g() {
          return (
            "object" == typeof console &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function h(a) {
          try {
            null == a ? b.storage.removeItem("debug") : (b.storage.debug = a);
          } catch (c) {}
        }
        function i() {
          var a;
          try {
            a = b.storage.debug;
          } catch (c) {}
          return (
            !a && "undefined" != typeof d && "env" in d && (a = d.env.DEBUG), a
          );
        }
        function j() {
          try {
            return window.localStorage;
          } catch (a) {}
        }
        (b = a.exports = c(5)),
          (b.log = g),
          (b.formatArgs = f),
          (b.save = h),
          (b.load = i),
          (b.useColors = e),
          (b.storage =
            "undefined" != typeof chrome && "undefined" != typeof chrome.storage
              ? chrome.storage.local
              : j()),
          (b.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson"
          ]),
          (b.formatters.j = function(a) {
            try {
              return JSON.stringify(a);
            } catch (b) {
              return "[UnexpectedJSONParseError]: " + b.message;
            }
          }),
          b.enable(i());
      }.call(b, c(4)));
    },
    function(a, b) {
      function c() {
        throw new Error("setTimeout has not been defined");
      }
      function d() {
        throw new Error("clearTimeout has not been defined");
      }
      function e(a) {
        if (k === setTimeout) return setTimeout(a, 0);
        if ((k === c || !k) && setTimeout)
          return (k = setTimeout), setTimeout(a, 0);
        try {
          return k(a, 0);
        } catch (b) {
          try {
            return k.call(null, a, 0);
          } catch (b) {
            return k.call(this, a, 0);
          }
        }
      }
      function f(a) {
        if (l === clearTimeout) return clearTimeout(a);
        if ((l === d || !l) && clearTimeout)
          return (l = clearTimeout), clearTimeout(a);
        try {
          return l(a);
        } catch (b) {
          try {
            return l.call(null, a);
          } catch (b) {
            return l.call(this, a);
          }
        }
      }
      function g() {
        p &&
          n &&
          ((p = !1), n.length ? (o = n.concat(o)) : (q = -1), o.length && h());
      }
      function h() {
        if (!p) {
          var a = e(g);
          p = !0;
          for (var b = o.length; b; ) {
            for (n = o, o = []; ++q < b; ) n && n[q].run();
            (q = -1), (b = o.length);
          }
          (n = null), (p = !1), f(a);
        }
      }
      function i(a, b) {
        (this.fun = a), (this.array = b);
      }
      function j() {}
      var k,
        l,
        m = (a.exports = {});
      !(function() {
        try {
          k = "function" == typeof setTimeout ? setTimeout : c;
        } catch (a) {
          k = c;
        }
        try {
          l = "function" == typeof clearTimeout ? clearTimeout : d;
        } catch (a) {
          l = d;
        }
      })();
      var n,
        o = [],
        p = !1,
        q = -1;
      (m.nextTick = function(a) {
        var b = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
        o.push(new i(a, b)), 1 !== o.length || p || e(h);
      }),
        (i.prototype.run = function() {
          this.fun.apply(null, this.array);
        }),
        (m.title = "browser"),
        (m.browser = !0),
        (m.env = {}),
        (m.argv = []),
        (m.version = ""),
        (m.versions = {}),
        (m.on = j),
        (m.addListener = j),
        (m.once = j),
        (m.off = j),
        (m.removeListener = j),
        (m.removeAllListeners = j),
        (m.emit = j),
        (m.prependListener = j),
        (m.prependOnceListener = j),
        (m.listeners = function(a) {
          return [];
        }),
        (m.binding = function(a) {
          throw new Error("process.binding is not supported");
        }),
        (m.cwd = function() {
          return "/";
        }),
        (m.chdir = function(a) {
          throw new Error("process.chdir is not supported");
        }),
        (m.umask = function() {
          return 0;
        });
    },
    function(a, b, c) {
      function d(a) {
        var c,
          d = 0;
        for (c in a) (d = (d << 5) - d + a.charCodeAt(c)), (d |= 0);
        return b.colors[Math.abs(d) % b.colors.length];
      }
      function e(a) {
        function c() {
          if (c.enabled) {
            var a = c,
              d = +new Date(),
              e = d - (j || d);
            (a.diff = e), (a.prev = j), (a.curr = d), (j = d);
            for (var f = new Array(arguments.length), g = 0; g < f.length; g++)
              f[g] = arguments[g];
            (f[0] = b.coerce(f[0])), "string" != typeof f[0] && f.unshift("%O");
            var h = 0;
            (f[0] = f[0].replace(/%([a-zA-Z%])/g, function(c, d) {
              if ("%%" === c) return c;
              h++;
              var e = b.formatters[d];
              if ("function" == typeof e) {
                var g = f[h];
                (c = e.call(a, g)), f.splice(h, 1), h--;
              }
              return c;
            })),
              b.formatArgs.call(a, f);
            var i = c.log || b.log || console.log.bind(console);
            i.apply(a, f);
          }
        }
        return (
          (c.namespace = a),
          (c.enabled = b.enabled(a)),
          (c.useColors = b.useColors()),
          (c.color = d(a)),
          "function" == typeof b.init && b.init(c),
          c
        );
      }
      function f(a) {
        b.save(a), (b.names = []), (b.skips = []);
        for (
          var c = ("string" == typeof a ? a : "").split(/[\s,]+/),
            d = c.length,
            e = 0;
          e < d;
          e++
        )
          c[e] &&
            ((a = c[e].replace(/\*/g, ".*?")),
            "-" === a[0]
              ? b.skips.push(new RegExp("^" + a.substr(1) + "$"))
              : b.names.push(new RegExp("^" + a + "$")));
      }
      function g() {
        b.enable("");
      }
      function h(a) {
        var c, d;
        for (c = 0, d = b.skips.length; c < d; c++)
          if (b.skips[c].test(a)) return !1;
        for (c = 0, d = b.names.length; c < d; c++)
          if (b.names[c].test(a)) return !0;
        return !1;
      }
      function i(a) {
        return a instanceof Error ? a.stack || a.message : a;
      }
      (b = a.exports = e.debug = e["default"] = e),
        (b.coerce = i),
        (b.disable = g),
        (b.enable = f),
        (b.enabled = h),
        (b.humanize = c(6)),
        (b.names = []),
        (b.skips = []),
        (b.formatters = {});
      var j;
    },
    function(a, b) {
      function c(a) {
        if (((a = String(a)), !(a.length > 100))) {
          var b = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
            a
          );
          if (b) {
            var c = parseFloat(b[1]),
              d = (b[2] || "ms").toLowerCase();
            switch (d) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return c * k;
              case "days":
              case "day":
              case "d":
                return c * j;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return c * i;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return c * h;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return c * g;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return c;
              default:
                return;
            }
          }
        }
      }
      function d(a) {
        return a >= j
          ? Math.round(a / j) + "d"
          : a >= i
          ? Math.round(a / i) + "h"
          : a >= h
          ? Math.round(a / h) + "m"
          : a >= g
          ? Math.round(a / g) + "s"
          : a + "ms";
      }
      function e(a) {
        return (
          f(a, j, "day") ||
          f(a, i, "hour") ||
          f(a, h, "minute") ||
          f(a, g, "second") ||
          a + " ms"
        );
      }
      function f(a, b, c) {
        if (!(a < b))
          return a < 1.5 * b
            ? Math.floor(a / b) + " " + c
            : Math.ceil(a / b) + " " + c + "s";
      }
      var g = 1e3,
        h = 60 * g,
        i = 60 * h,
        j = 24 * i,
        k = 365.25 * j;
      a.exports = function(a, b) {
        b = b || {};
        var f = typeof a;
        if ("string" === f && a.length > 0) return c(a);
        if ("number" === f && isNaN(a) === !1) return b["long"] ? e(a) : d(a);
        throw new Error(
          "val is not a non-empty string or a valid number. val=" +
            JSON.stringify(a)
        );
      };
    },
    function(a, b, c) {
      function d() {}
      function e(a) {
        var c = "" + a.type;
        return (
          (b.BINARY_EVENT !== a.type && b.BINARY_ACK !== a.type) ||
            (c += a.attachments + "-"),
          a.nsp && "/" !== a.nsp && (c += a.nsp + ","),
          null != a.id && (c += a.id),
          null != a.data && (c += JSON.stringify(a.data)),
          l("encoded %j as %s", a, c),
          c
        );
      }
      function f(a, b) {
        function c(a) {
          var c = o.deconstructPacket(a),
            d = e(c.packet),
            f = c.buffers;
          f.unshift(d), b(f);
        }
        o.removeBlobs(a, c);
      }
      function g() {
        this.reconstructor = null;
      }
      function h(a) {
        var c = 0,
          d = { type: Number(a.charAt(0)) };
        if (null == b.types[d.type]) return k();
        if (b.BINARY_EVENT === d.type || b.BINARY_ACK === d.type) {
          for (
            var e = "";
            "-" !== a.charAt(++c) && ((e += a.charAt(c)), c != a.length);

          );
          if (e != Number(e) || "-" !== a.charAt(c))
            throw new Error("Illegal attachments");
          d.attachments = Number(e);
        }
        if ("/" === a.charAt(c + 1))
          for (d.nsp = ""; ++c; ) {
            var f = a.charAt(c);
            if ("," === f) break;
            if (((d.nsp += f), c === a.length)) break;
          }
        else d.nsp = "/";
        var g = a.charAt(c + 1);
        if ("" !== g && Number(g) == g) {
          for (d.id = ""; ++c; ) {
            var f = a.charAt(c);
            if (null == f || Number(f) != f) {
              --c;
              break;
            }
            if (((d.id += a.charAt(c)), c === a.length)) break;
          }
          d.id = Number(d.id);
        }
        return (
          a.charAt(++c) && (d = i(d, a.substr(c))),
          l("decoded %s as %j", a, d),
          d
        );
      }
      function i(a, b) {
        try {
          a.data = JSON.parse(b);
        } catch (c) {
          return k();
        }
        return a;
      }
      function j(a) {
        (this.reconPack = a), (this.buffers = []);
      }
      function k() {
        return { type: b.ERROR, data: "parser error" };
      }
      var l = c(3)("socket.io-parser"),
        m = c(8),
        n = c(9),
        o = c(11),
        p = c(12);
      (b.protocol = 4),
        (b.types = [
          "CONNECT",
          "DISCONNECT",
          "EVENT",
          "ACK",
          "ERROR",
          "BINARY_EVENT",
          "BINARY_ACK"
        ]),
        (b.CONNECT = 0),
        (b.DISCONNECT = 1),
        (b.EVENT = 2),
        (b.ACK = 3),
        (b.ERROR = 4),
        (b.BINARY_EVENT = 5),
        (b.BINARY_ACK = 6),
        (b.Encoder = d),
        (b.Decoder = g),
        (d.prototype.encode = function(a, c) {
          if (
            ((a.type !== b.EVENT && a.type !== b.ACK) ||
              !n(a.data) ||
              (a.type = a.type === b.EVENT ? b.BINARY_EVENT : b.BINARY_ACK),
            l("encoding packet %j", a),
            b.BINARY_EVENT === a.type || b.BINARY_ACK === a.type)
          )
            f(a, c);
          else {
            var d = e(a);
            c([d]);
          }
        }),
        m(g.prototype),
        (g.prototype.add = function(a) {
          var c;
          if ("string" == typeof a)
            (c = h(a)),
              b.BINARY_EVENT === c.type || b.BINARY_ACK === c.type
                ? ((this.reconstructor = new j(c)),
                  0 === this.reconstructor.reconPack.attachments &&
                    this.emit("decoded", c))
                : this.emit("decoded", c);
          else {
            if (!p(a) && !a.base64) throw new Error("Unknown type: " + a);
            if (!this.reconstructor)
              throw new Error(
                "got binary data when not reconstructing a packet"
              );
            (c = this.reconstructor.takeBinaryData(a)),
              c && ((this.reconstructor = null), this.emit("decoded", c));
          }
        }),
        (g.prototype.destroy = function() {
          this.reconstructor && this.reconstructor.finishedReconstruction();
        }),
        (j.prototype.takeBinaryData = function(a) {
          if (
            (this.buffers.push(a),
            this.buffers.length === this.reconPack.attachments)
          ) {
            var b = o.reconstructPacket(this.reconPack, this.buffers);
            return this.finishedReconstruction(), b;
          }
          return null;
        }),
        (j.prototype.finishedReconstruction = function() {
          (this.reconPack = null), (this.buffers = []);
        });
    },
    function(a, b, c) {
      function d(a) {
        if (a) return e(a);
      }
      function e(a) {
        for (var b in d.prototype) a[b] = d.prototype[b];
        return a;
      }
      (a.exports = d),
        (d.prototype.on = d.prototype.addEventListener = function(a, b) {
          return (
            (this._callbacks = this._callbacks || {}),
            (this._callbacks["$" + a] = this._callbacks["$" + a] || []).push(b),
            this
          );
        }),
        (d.prototype.once = function(a, b) {
          function c() {
            this.off(a, c), b.apply(this, arguments);
          }
          return (c.fn = b), this.on(a, c), this;
        }),
        (d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function(
          a,
          b
        ) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this;
          var c = this._callbacks["$" + a];
          if (!c) return this;
          if (1 == arguments.length)
            return delete this._callbacks["$" + a], this;
          for (var d, e = 0; e < c.length; e++)
            if (((d = c[e]), d === b || d.fn === b)) {
              c.splice(e, 1);
              break;
            }
          return this;
        }),
        (d.prototype.emit = function(a) {
          this._callbacks = this._callbacks || {};
          var b = [].slice.call(arguments, 1),
            c = this._callbacks["$" + a];
          if (c) {
            c = c.slice(0);
            for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b);
          }
          return this;
        }),
        (d.prototype.listeners = function(a) {
          return (
            (this._callbacks = this._callbacks || {}),
            this._callbacks["$" + a] || []
          );
        }),
        (d.prototype.hasListeners = function(a) {
          return !!this.listeners(a).length;
        });
    },
    function(a, b, c) {
      (function(b) {
        function d(a) {
          if (!a || "object" != typeof a) return !1;
          if (e(a)) {
            for (var c = 0, f = a.length; c < f; c++) if (d(a[c])) return !0;
            return !1;
          }
          if (
            ("function" == typeof b.Buffer &&
              b.Buffer.isBuffer &&
              b.Buffer.isBuffer(a)) ||
            ("function" == typeof b.ArrayBuffer && a instanceof ArrayBuffer) ||
            (g && a instanceof Blob) ||
            (h && a instanceof File)
          )
            return !0;
          if (
            a.toJSON &&
            "function" == typeof a.toJSON &&
            1 === arguments.length
          )
            return d(a.toJSON(), !0);
          for (var i in a)
            if (Object.prototype.hasOwnProperty.call(a, i) && d(a[i]))
              return !0;
          return !1;
        }
        var e = c(10),
          f = Object.prototype.toString,
          g =
            "function" == typeof b.Blob ||
            "[object BlobConstructor]" === f.call(b.Blob),
          h =
            "function" == typeof b.File ||
            "[object FileConstructor]" === f.call(b.File);
        a.exports = d;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      var c = {}.toString;
      a.exports =
        Array.isArray ||
        function(a) {
          return "[object Array]" == c.call(a);
        };
    },
    function(a, b, c) {
      (function(a) {
        function d(a, b) {
          if (!a) return a;
          if (g(a)) {
            var c = { _placeholder: !0, num: b.length };
            return b.push(a), c;
          }
          if (f(a)) {
            for (var e = new Array(a.length), h = 0; h < a.length; h++)
              e[h] = d(a[h], b);
            return e;
          }
          if ("object" == typeof a && !(a instanceof Date)) {
            var e = {};
            for (var i in a) e[i] = d(a[i], b);
            return e;
          }
          return a;
        }
        function e(a, b) {
          if (!a) return a;
          if (a && a._placeholder) return b[a.num];
          if (f(a)) for (var c = 0; c < a.length; c++) a[c] = e(a[c], b);
          else if ("object" == typeof a) for (var d in a) a[d] = e(a[d], b);
          return a;
        }
        var f = c(10),
          g = c(12),
          h = Object.prototype.toString,
          i =
            "function" == typeof a.Blob ||
            "[object BlobConstructor]" === h.call(a.Blob),
          j =
            "function" == typeof a.File ||
            "[object FileConstructor]" === h.call(a.File);
        (b.deconstructPacket = function(a) {
          var b = [],
            c = a.data,
            e = a;
          return (
            (e.data = d(c, b)),
            (e.attachments = b.length),
            { packet: e, buffers: b }
          );
        }),
          (b.reconstructPacket = function(a, b) {
            return (a.data = e(a.data, b)), (a.attachments = void 0), a;
          }),
          (b.removeBlobs = function(a, b) {
            function c(a, h, k) {
              if (!a) return a;
              if ((i && a instanceof Blob) || (j && a instanceof File)) {
                d++;
                var l = new FileReader();
                (l.onload = function() {
                  k ? (k[h] = this.result) : (e = this.result), --d || b(e);
                }),
                  l.readAsArrayBuffer(a);
              } else if (f(a)) for (var m = 0; m < a.length; m++) c(a[m], m, a);
              else if ("object" == typeof a && !g(a))
                for (var n in a) c(a[n], n, a);
            }
            var d = 0,
              e = a;
            c(e), d || b(e);
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      (function(b) {
        function c(a) {
          return (
            (b.Buffer && b.Buffer.isBuffer(a)) ||
            (b.ArrayBuffer && a instanceof ArrayBuffer)
          );
        }
        a.exports = c;
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      "use strict";
      function d(a, b) {
        if (!(this instanceof d)) return new d(a, b);
        a &&
          "object" === ("undefined" == typeof a ? "undefined" : e(a)) &&
          ((b = a), (a = void 0)),
          (b = b || {}),
          (b.path = b.path || "/socket.io"),
          (this.nsps = {}),
          (this.subs = []),
          (this.opts = b),
          this.reconnection(b.reconnection !== !1),
          this.reconnectionAttempts(b.reconnectionAttempts || 1 / 0),
          this.reconnectionDelay(b.reconnectionDelay || 1e3),
          this.reconnectionDelayMax(b.reconnectionDelayMax || 5e3),
          this.randomizationFactor(b.randomizationFactor || 0.5),
          (this.backoff = new n({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          })),
          this.timeout(null == b.timeout ? 2e4 : b.timeout),
          (this.readyState = "closed"),
          (this.uri = a),
          (this.connecting = []),
          (this.lastPing = null),
          (this.encoding = !1),
          (this.packetBuffer = []);
        var c = b.parser || i;
        (this.encoder = new c.Encoder()),
          (this.decoder = new c.Decoder()),
          (this.autoConnect = b.autoConnect !== !1),
          this.autoConnect && this.open();
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(14),
        g = c(39),
        h = c(8),
        i = c(7),
        j = c(41),
        k = c(42),
        l = c(3)("socket.io-client:manager"),
        m = c(37),
        n = c(43),
        o = Object.prototype.hasOwnProperty;
      (a.exports = d),
        (d.prototype.emitAll = function() {
          this.emit.apply(this, arguments);
          for (var a in this.nsps)
            o.call(this.nsps, a) &&
              this.nsps[a].emit.apply(this.nsps[a], arguments);
        }),
        (d.prototype.updateSocketIds = function() {
          for (var a in this.nsps)
            o.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a));
        }),
        (d.prototype.generateId = function(a) {
          return ("/" === a ? "" : a + "#") + this.engine.id;
        }),
        h(d.prototype),
        (d.prototype.reconnection = function(a) {
          return arguments.length
            ? ((this._reconnection = !!a), this)
            : this._reconnection;
        }),
        (d.prototype.reconnectionAttempts = function(a) {
          return arguments.length
            ? ((this._reconnectionAttempts = a), this)
            : this._reconnectionAttempts;
        }),
        (d.prototype.reconnectionDelay = function(a) {
          return arguments.length
            ? ((this._reconnectionDelay = a),
              this.backoff && this.backoff.setMin(a),
              this)
            : this._reconnectionDelay;
        }),
        (d.prototype.randomizationFactor = function(a) {
          return arguments.length
            ? ((this._randomizationFactor = a),
              this.backoff && this.backoff.setJitter(a),
              this)
            : this._randomizationFactor;
        }),
        (d.prototype.reconnectionDelayMax = function(a) {
          return arguments.length
            ? ((this._reconnectionDelayMax = a),
              this.backoff && this.backoff.setMax(a),
              this)
            : this._reconnectionDelayMax;
        }),
        (d.prototype.timeout = function(a) {
          return arguments.length ? ((this._timeout = a), this) : this._timeout;
        }),
        (d.prototype.maybeReconnectOnOpen = function() {
          !this.reconnecting &&
            this._reconnection &&
            0 === this.backoff.attempts &&
            this.reconnect();
        }),
        (d.prototype.open = d.prototype.connect = function(a, b) {
          if (
            (l("readyState %s", this.readyState),
            ~this.readyState.indexOf("open"))
          )
            return this;
          l("opening %s", this.uri), (this.engine = f(this.uri, this.opts));
          var c = this.engine,
            d = this;
          (this.readyState = "opening"), (this.skipReconnect = !1);
          var e = j(c, "open", function() {
              d.onopen(), a && a();
            }),
            g = j(c, "error", function(b) {
              if (
                (l("connect_error"),
                d.cleanup(),
                (d.readyState = "closed"),
                d.emitAll("connect_error", b),
                a)
              ) {
                var c = new Error("Connection error");
                (c.data = b), a(c);
              } else d.maybeReconnectOnOpen();
            });
          if (!1 !== this._timeout) {
            var h = this._timeout;
            l("connect attempt will timeout after %d", h);
            var i = setTimeout(function() {
              l("connect attempt timed out after %d", h),
                e.destroy(),
                c.close(),
                c.emit("error", "timeout"),
                d.emitAll("connect_timeout", h);
            }, h);
            this.subs.push({
              destroy: function() {
                clearTimeout(i);
              }
            });
          }
          return this.subs.push(e), this.subs.push(g), this;
        }),
        (d.prototype.onopen = function() {
          l("open"),
            this.cleanup(),
            (this.readyState = "open"),
            this.emit("open");
          var a = this.engine;
          this.subs.push(j(a, "data", k(this, "ondata"))),
            this.subs.push(j(a, "ping", k(this, "onping"))),
            this.subs.push(j(a, "pong", k(this, "onpong"))),
            this.subs.push(j(a, "error", k(this, "onerror"))),
            this.subs.push(j(a, "close", k(this, "onclose"))),
            this.subs.push(j(this.decoder, "decoded", k(this, "ondecoded")));
        }),
        (d.prototype.onping = function() {
          (this.lastPing = new Date()), this.emitAll("ping");
        }),
        (d.prototype.onpong = function() {
          this.emitAll("pong", new Date() - this.lastPing);
        }),
        (d.prototype.ondata = function(a) {
          this.decoder.add(a);
        }),
        (d.prototype.ondecoded = function(a) {
          this.emit("packet", a);
        }),
        (d.prototype.onerror = function(a) {
          l("error", a), this.emitAll("error", a);
        }),
        (d.prototype.socket = function(a, b) {
          function c() {
            ~m(e.connecting, d) || e.connecting.push(d);
          }
          var d = this.nsps[a];
          if (!d) {
            (d = new g(this, a, b)), (this.nsps[a] = d);
            var e = this;
            d.on("connecting", c),
              d.on("connect", function() {
                d.id = e.generateId(a);
              }),
              this.autoConnect && c();
          }
          return d;
        }),
        (d.prototype.destroy = function(a) {
          var b = m(this.connecting, a);
          ~b && this.connecting.splice(b, 1),
            this.connecting.length || this.close();
        }),
        (d.prototype.packet = function(a) {
          l("writing packet %j", a);
          var b = this;
          a.query && 0 === a.type && (a.nsp += "?" + a.query),
            b.encoding
              ? b.packetBuffer.push(a)
              : ((b.encoding = !0),
                this.encoder.encode(a, function(c) {
                  for (var d = 0; d < c.length; d++)
                    b.engine.write(c[d], a.options);
                  (b.encoding = !1), b.processPacketQueue();
                }));
        }),
        (d.prototype.processPacketQueue = function() {
          if (this.packetBuffer.length > 0 && !this.encoding) {
            var a = this.packetBuffer.shift();
            this.packet(a);
          }
        }),
        (d.prototype.cleanup = function() {
          l("cleanup");
          for (var a = this.subs.length, b = 0; b < a; b++) {
            var c = this.subs.shift();
            c.destroy();
          }
          (this.packetBuffer = []),
            (this.encoding = !1),
            (this.lastPing = null),
            this.decoder.destroy();
        }),
        (d.prototype.close = d.prototype.disconnect = function() {
          l("disconnect"),
            (this.skipReconnect = !0),
            (this.reconnecting = !1),
            "opening" === this.readyState && this.cleanup(),
            this.backoff.reset(),
            (this.readyState = "closed"),
            this.engine && this.engine.close();
        }),
        (d.prototype.onclose = function(a) {
          l("onclose"),
            this.cleanup(),
            this.backoff.reset(),
            (this.readyState = "closed"),
            this.emit("close", a),
            this._reconnection && !this.skipReconnect && this.reconnect();
        }),
        (d.prototype.reconnect = function() {
          if (this.reconnecting || this.skipReconnect) return this;
          var a = this;
          if (this.backoff.attempts >= this._reconnectionAttempts)
            l("reconnect failed"),
              this.backoff.reset(),
              this.emitAll("reconnect_failed"),
              (this.reconnecting = !1);
          else {
            var b = this.backoff.duration();
            l("will wait %dms before reconnect attempt", b),
              (this.reconnecting = !0);
            var c = setTimeout(function() {
              a.skipReconnect ||
                (l("attempting reconnect"),
                a.emitAll("reconnect_attempt", a.backoff.attempts),
                a.emitAll("reconnecting", a.backoff.attempts),
                a.skipReconnect ||
                  a.open(function(b) {
                    b
                      ? (l("reconnect attempt error"),
                        (a.reconnecting = !1),
                        a.reconnect(),
                        a.emitAll("reconnect_error", b.data))
                      : (l("reconnect success"), a.onreconnect());
                  }));
            }, b);
            this.subs.push({
              destroy: function() {
                clearTimeout(c);
              }
            });
          }
        }),
        (d.prototype.onreconnect = function() {
          var a = this.backoff.attempts;
          (this.reconnecting = !1),
            this.backoff.reset(),
            this.updateSocketIds(),
            this.emitAll("reconnect", a);
        });
    },
    function(a, b, c) {
      a.exports = c(15);
    },
    function(a, b, c) {
      (a.exports = c(16)), (a.exports.parser = c(23));
    },
    function(a, b, c) {
      (function(b) {
        function d(a, c) {
          if (!(this instanceof d)) return new d(a, c);
          (c = c || {}),
            a && "object" == typeof a && ((c = a), (a = null)),
            a
              ? ((a = k(a)),
                (c.hostname = a.host),
                (c.secure = "https" === a.protocol || "wss" === a.protocol),
                (c.port = a.port),
                a.query && (c.query = a.query))
              : c.host && (c.hostname = k(c.host).host),
            (this.secure =
              null != c.secure
                ? c.secure
                : b.location && "https:" === location.protocol),
            c.hostname && !c.port && (c.port = this.secure ? "443" : "80"),
            (this.agent = c.agent || !1),
            (this.hostname =
              c.hostname || (b.location ? location.hostname : "localhost")),
            (this.port =
              c.port ||
              (b.location && location.port
                ? location.port
                : this.secure
                ? 443
                : 80)),
            (this.query = c.query || {}),
            "string" == typeof this.query &&
              (this.query = m.decode(this.query)),
            (this.upgrade = !1 !== c.upgrade),
            (this.path = (c.path || "/engine.io").replace(/\/$/, "") + "/"),
            (this.forceJSONP = !!c.forceJSONP),
            (this.jsonp = !1 !== c.jsonp),
            (this.forceBase64 = !!c.forceBase64),
            (this.enablesXDR = !!c.enablesXDR),
            (this.timestampParam = c.timestampParam || "t"),
            (this.timestampRequests = c.timestampRequests),
            (this.transports = c.transports || ["polling", "websocket"]),
            (this.transportOptions = c.transportOptions || {}),
            (this.readyState = ""),
            (this.writeBuffer = []),
            (this.prevBufferLen = 0),
            (this.policyPort = c.policyPort || 843),
            (this.rememberUpgrade = c.rememberUpgrade || !1),
            (this.binaryType = null),
            (this.onlyBinaryUpgrades = c.onlyBinaryUpgrades),
            (this.perMessageDeflate =
              !1 !== c.perMessageDeflate && (c.perMessageDeflate || {})),
            !0 === this.perMessageDeflate && (this.perMessageDeflate = {}),
            this.perMessageDeflate &&
              null == this.perMessageDeflate.threshold &&
              (this.perMessageDeflate.threshold = 1024),
            (this.pfx = c.pfx || null),
            (this.key = c.key || null),
            (this.passphrase = c.passphrase || null),
            (this.cert = c.cert || null),
            (this.ca = c.ca || null),
            (this.ciphers = c.ciphers || null),
            (this.rejectUnauthorized =
              void 0 === c.rejectUnauthorized || c.rejectUnauthorized),
            (this.forceNode = !!c.forceNode);
          var e = "object" == typeof b && b;
          e.global === e &&
            (c.extraHeaders &&
              Object.keys(c.extraHeaders).length > 0 &&
              (this.extraHeaders = c.extraHeaders),
            c.localAddress && (this.localAddress = c.localAddress)),
            (this.id = null),
            (this.upgrades = null),
            (this.pingInterval = null),
            (this.pingTimeout = null),
            (this.pingIntervalTimer = null),
            (this.pingTimeoutTimer = null),
            this.open();
        }
        function e(a) {
          var b = {};
          for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
          return b;
        }
        var f = c(17),
          g = c(8),
          h = c(3)("engine.io-client:socket"),
          i = c(37),
          j = c(23),
          k = c(2),
          l = c(38),
          m = c(31);
        (a.exports = d),
          (d.priorWebsocketSuccess = !1),
          g(d.prototype),
          (d.protocol = j.protocol),
          (d.Socket = d),
          (d.Transport = c(22)),
          (d.transports = c(17)),
          (d.parser = c(23)),
          (d.prototype.createTransport = function(a) {
            h('creating transport "%s"', a);
            var b = e(this.query);
            (b.EIO = j.protocol), (b.transport = a);
            var c = this.transportOptions[a] || {};
            this.id && (b.sid = this.id);
            var d = new f[a]({
              query: b,
              socket: this,
              agent: c.agent || this.agent,
              hostname: c.hostname || this.hostname,
              port: c.port || this.port,
              secure: c.secure || this.secure,
              path: c.path || this.path,
              forceJSONP: c.forceJSONP || this.forceJSONP,
              jsonp: c.jsonp || this.jsonp,
              forceBase64: c.forceBase64 || this.forceBase64,
              enablesXDR: c.enablesXDR || this.enablesXDR,
              timestampRequests: c.timestampRequests || this.timestampRequests,
              timestampParam: c.timestampParam || this.timestampParam,
              policyPort: c.policyPort || this.policyPort,
              pfx: c.pfx || this.pfx,
              key: c.key || this.key,
              passphrase: c.passphrase || this.passphrase,
              cert: c.cert || this.cert,
              ca: c.ca || this.ca,
              ciphers: c.ciphers || this.ciphers,
              rejectUnauthorized:
                c.rejectUnauthorized || this.rejectUnauthorized,
              perMessageDeflate: c.perMessageDeflate || this.perMessageDeflate,
              extraHeaders: c.extraHeaders || this.extraHeaders,
              forceNode: c.forceNode || this.forceNode,
              localAddress: c.localAddress || this.localAddress,
              requestTimeout: c.requestTimeout || this.requestTimeout,
              protocols: c.protocols || void 0
            });
            return d;
          }),
          (d.prototype.open = function() {
            var a;
            if (
              this.rememberUpgrade &&
              d.priorWebsocketSuccess &&
              this.transports.indexOf("websocket") !== -1
            )
              a = "websocket";
            else {
              if (0 === this.transports.length) {
                var b = this;
                return void setTimeout(function() {
                  b.emit("error", "No transports available");
                }, 0);
              }
              a = this.transports[0];
            }
            this.readyState = "opening";
            try {
              a = this.createTransport(a);
            } catch (c) {
              return this.transports.shift(), void this.open();
            }
            a.open(), this.setTransport(a);
          }),
          (d.prototype.setTransport = function(a) {
            h("setting transport %s", a.name);
            var b = this;
            this.transport &&
              (h("clearing existing transport %s", this.transport.name),
              this.transport.removeAllListeners()),
              (this.transport = a),
              a
                .on("drain", function() {
                  b.onDrain();
                })
                .on("packet", function(a) {
                  b.onPacket(a);
                })
                .on("error", function(a) {
                  b.onError(a);
                })
                .on("close", function() {
                  b.onClose("transport close");
                });
          }),
          (d.prototype.probe = function(a) {
            function b() {
              if (m.onlyBinaryUpgrades) {
                var b = !this.supportsBinary && m.transport.supportsBinary;
                l = l || b;
              }
              l ||
                (h('probe transport "%s" opened', a),
                k.send([{ type: "ping", data: "probe" }]),
                k.once("packet", function(b) {
                  if (!l)
                    if ("pong" === b.type && "probe" === b.data) {
                      if (
                        (h('probe transport "%s" pong', a),
                        (m.upgrading = !0),
                        m.emit("upgrading", k),
                        !k)
                      )
                        return;
                      (d.priorWebsocketSuccess = "websocket" === k.name),
                        h('pausing current transport "%s"', m.transport.name),
                        m.transport.pause(function() {
                          l ||
                            ("closed" !== m.readyState &&
                              (h(
                                "changing transport and sending upgrade packet"
                              ),
                              j(),
                              m.setTransport(k),
                              k.send([{ type: "upgrade" }]),
                              m.emit("upgrade", k),
                              (k = null),
                              (m.upgrading = !1),
                              m.flush()));
                        });
                    } else {
                      h('probe transport "%s" failed', a);
                      var c = new Error("probe error");
                      (c.transport = k.name), m.emit("upgradeError", c);
                    }
                }));
            }
            function c() {
              l || ((l = !0), j(), k.close(), (k = null));
            }
            function e(b) {
              var d = new Error("probe error: " + b);
              (d.transport = k.name),
                c(),
                h('probe transport "%s" failed because of error: %s', a, b),
                m.emit("upgradeError", d);
            }
            function f() {
              e("transport closed");
            }
            function g() {
              e("socket closed");
            }
            function i(a) {
              k &&
                a.name !== k.name &&
                (h('"%s" works - aborting "%s"', a.name, k.name), c());
            }
            function j() {
              k.removeListener("open", b),
                k.removeListener("error", e),
                k.removeListener("close", f),
                m.removeListener("close", g),
                m.removeListener("upgrading", i);
            }
            h('probing transport "%s"', a);
            var k = this.createTransport(a, { probe: 1 }),
              l = !1,
              m = this;
            (d.priorWebsocketSuccess = !1),
              k.once("open", b),
              k.once("error", e),
              k.once("close", f),
              this.once("close", g),
              this.once("upgrading", i),
              k.open();
          }),
          (d.prototype.onOpen = function() {
            if (
              (h("socket open"),
              (this.readyState = "open"),
              (d.priorWebsocketSuccess = "websocket" === this.transport.name),
              this.emit("open"),
              this.flush(),
              "open" === this.readyState &&
                this.upgrade &&
                this.transport.pause)
            ) {
              h("starting upgrade probes");
              for (var a = 0, b = this.upgrades.length; a < b; a++)
                this.probe(this.upgrades[a]);
            }
          }),
          (d.prototype.onPacket = function(a) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            )
              switch (
                (h('socket receive: type "%s", data "%s"', a.type, a.data),
                this.emit("packet", a),
                this.emit("heartbeat"),
                a.type)
              ) {
                case "open":
                  this.onHandshake(l(a.data));
                  break;
                case "pong":
                  this.setPing(), this.emit("pong");
                  break;
                case "error":
                  var b = new Error("server error");
                  (b.code = a.data), this.onError(b);
                  break;
                case "message":
                  this.emit("data", a.data), this.emit("message", a.data);
              }
            else
              h('packet received with socket readyState "%s"', this.readyState);
          }),
          (d.prototype.onHandshake = function(a) {
            this.emit("handshake", a),
              (this.id = a.sid),
              (this.transport.query.sid = a.sid),
              (this.upgrades = this.filterUpgrades(a.upgrades)),
              (this.pingInterval = a.pingInterval),
              (this.pingTimeout = a.pingTimeout),
              this.onOpen(),
              "closed" !== this.readyState &&
                (this.setPing(),
                this.removeListener("heartbeat", this.onHeartbeat),
                this.on("heartbeat", this.onHeartbeat));
          }),
          (d.prototype.onHeartbeat = function(a) {
            clearTimeout(this.pingTimeoutTimer);
            var b = this;
            b.pingTimeoutTimer = setTimeout(function() {
              "closed" !== b.readyState && b.onClose("ping timeout");
            }, a || b.pingInterval + b.pingTimeout);
          }),
          (d.prototype.setPing = function() {
            var a = this;
            clearTimeout(a.pingIntervalTimer),
              (a.pingIntervalTimer = setTimeout(function() {
                h(
                  "writing ping packet - expecting pong within %sms",
                  a.pingTimeout
                ),
                  a.ping(),
                  a.onHeartbeat(a.pingTimeout);
              }, a.pingInterval));
          }),
          (d.prototype.ping = function() {
            var a = this;
            this.sendPacket("ping", function() {
              a.emit("ping");
            });
          }),
          (d.prototype.onDrain = function() {
            this.writeBuffer.splice(0, this.prevBufferLen),
              (this.prevBufferLen = 0),
              0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
          }),
          (d.prototype.flush = function() {
            "closed" !== this.readyState &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length &&
              (h("flushing %d packets in socket", this.writeBuffer.length),
              this.transport.send(this.writeBuffer),
              (this.prevBufferLen = this.writeBuffer.length),
              this.emit("flush"));
          }),
          (d.prototype.write = d.prototype.send = function(a, b, c) {
            return this.sendPacket("message", a, b, c), this;
          }),
          (d.prototype.sendPacket = function(a, b, c, d) {
            if (
              ("function" == typeof b && ((d = b), (b = void 0)),
              "function" == typeof c && ((d = c), (c = null)),
              "closing" !== this.readyState && "closed" !== this.readyState)
            ) {
              (c = c || {}), (c.compress = !1 !== c.compress);
              var e = { type: a, data: b, options: c };
              this.emit("packetCreate", e),
                this.writeBuffer.push(e),
                d && this.once("flush", d),
                this.flush();
            }
          }),
          (d.prototype.close = function() {
            function a() {
              d.onClose("forced close"),
                h("socket closing - telling transport to close"),
                d.transport.close();
            }
            function b() {
              d.removeListener("upgrade", b),
                d.removeListener("upgradeError", b),
                a();
            }
            function c() {
              d.once("upgrade", b), d.once("upgradeError", b);
            }
            if ("opening" === this.readyState || "open" === this.readyState) {
              this.readyState = "closing";
              var d = this;
              this.writeBuffer.length
                ? this.once("drain", function() {
                    this.upgrading ? c() : a();
                  })
                : this.upgrading
                ? c()
                : a();
            }
            return this;
          }),
          (d.prototype.onError = function(a) {
            h("socket error %j", a),
              (d.priorWebsocketSuccess = !1),
              this.emit("error", a),
              this.onClose("transport error", a);
          }),
          (d.prototype.onClose = function(a, b) {
            if (
              "opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState
            ) {
              h('socket close with reason: "%s"', a);
              var c = this;
              clearTimeout(this.pingIntervalTimer),
                clearTimeout(this.pingTimeoutTimer),
                this.transport.removeAllListeners("close"),
                this.transport.close(),
                this.transport.removeAllListeners(),
                (this.readyState = "closed"),
                (this.id = null),
                this.emit("close", a, b),
                (c.writeBuffer = []),
                (c.prevBufferLen = 0);
            }
          }),
          (d.prototype.filterUpgrades = function(a) {
            for (var b = [], c = 0, d = a.length; c < d; c++)
              ~i(this.transports, a[c]) && b.push(a[c]);
            return b;
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(a) {
        function d(b) {
          var c,
            d = !1,
            h = !1,
            i = !1 !== b.jsonp;
          if (a.location) {
            var j = "https:" === location.protocol,
              k = location.port;
            k || (k = j ? 443 : 80),
              (d = b.hostname !== location.hostname || k !== b.port),
              (h = b.secure !== j);
          }
          if (
            ((b.xdomain = d),
            (b.xscheme = h),
            (c = new e(b)),
            "open" in c && !b.forceJSONP)
          )
            return new f(b);
          if (!i) throw new Error("JSONP disabled");
          return new g(b);
        }
        var e = c(18),
          f = c(20),
          g = c(34),
          h = c(35);
        (b.polling = d), (b.websocket = h);
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(b) {
        var d = c(19);
        a.exports = function(a) {
          var c = a.xdomain,
            e = a.xscheme,
            f = a.enablesXDR;
          try {
            if ("undefined" != typeof XMLHttpRequest && (!c || d))
              return new XMLHttpRequest();
          } catch (g) {}
          try {
            if ("undefined" != typeof XDomainRequest && !e && f)
              return new XDomainRequest();
          } catch (g) {}
          if (!c)
            try {
              return new b[(["Active"].concat("Object").join("X"))](
                "Microsoft.XMLHTTP"
              );
            } catch (g) {}
        };
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      try {
        a.exports =
          "undefined" != typeof XMLHttpRequest &&
          "withCredentials" in new XMLHttpRequest();
      } catch (c) {
        a.exports = !1;
      }
    },
    function(a, b, c) {
      (function(b) {
        function d() {}
        function e(a) {
          if (
            (i.call(this, a),
            (this.requestTimeout = a.requestTimeout),
            (this.extraHeaders = a.extraHeaders),
            b.location)
          ) {
            var c = "https:" === location.protocol,
              d = location.port;
            d || (d = c ? 443 : 80),
              (this.xd = a.hostname !== b.location.hostname || d !== a.port),
              (this.xs = a.secure !== c);
          }
        }
        function f(a) {
          (this.method = a.method || "GET"),
            (this.uri = a.uri),
            (this.xd = !!a.xd),
            (this.xs = !!a.xs),
            (this.async = !1 !== a.async),
            (this.data = void 0 !== a.data ? a.data : null),
            (this.agent = a.agent),
            (this.isBinary = a.isBinary),
            (this.supportsBinary = a.supportsBinary),
            (this.enablesXDR = a.enablesXDR),
            (this.requestTimeout = a.requestTimeout),
            (this.pfx = a.pfx),
            (this.key = a.key),
            (this.passphrase = a.passphrase),
            (this.cert = a.cert),
            (this.ca = a.ca),
            (this.ciphers = a.ciphers),
            (this.rejectUnauthorized = a.rejectUnauthorized),
            (this.extraHeaders = a.extraHeaders),
            this.create();
        }
        function g() {
          for (var a in f.requests)
            f.requests.hasOwnProperty(a) && f.requests[a].abort();
        }
        var h = c(18),
          i = c(21),
          j = c(8),
          k = c(32),
          l = c(3)("engine.io-client:polling-xhr");
        (a.exports = e),
          (a.exports.Request = f),
          k(e, i),
          (e.prototype.supportsBinary = !0),
          (e.prototype.request = function(a) {
            return (
              (a = a || {}),
              (a.uri = this.uri()),
              (a.xd = this.xd),
              (a.xs = this.xs),
              (a.agent = this.agent || !1),
              (a.supportsBinary = this.supportsBinary),
              (a.enablesXDR = this.enablesXDR),
              (a.pfx = this.pfx),
              (a.key = this.key),
              (a.passphrase = this.passphrase),
              (a.cert = this.cert),
              (a.ca = this.ca),
              (a.ciphers = this.ciphers),
              (a.rejectUnauthorized = this.rejectUnauthorized),
              (a.requestTimeout = this.requestTimeout),
              (a.extraHeaders = this.extraHeaders),
              new f(a)
            );
          }),
          (e.prototype.doWrite = function(a, b) {
            var c = "string" != typeof a && void 0 !== a,
              d = this.request({ method: "POST", data: a, isBinary: c }),
              e = this;
            d.on("success", b),
              d.on("error", function(a) {
                e.onError("xhr post error", a);
              }),
              (this.sendXhr = d);
          }),
          (e.prototype.doPoll = function() {
            l("xhr poll");
            var a = this.request(),
              b = this;
            a.on("data", function(a) {
              b.onData(a);
            }),
              a.on("error", function(a) {
                b.onError("xhr poll error", a);
              }),
              (this.pollXhr = a);
          }),
          j(f.prototype),
          (f.prototype.create = function() {
            var a = {
              agent: this.agent,
              xdomain: this.xd,
              xscheme: this.xs,
              enablesXDR: this.enablesXDR
            };
            (a.pfx = this.pfx),
              (a.key = this.key),
              (a.passphrase = this.passphrase),
              (a.cert = this.cert),
              (a.ca = this.ca),
              (a.ciphers = this.ciphers),
              (a.rejectUnauthorized = this.rejectUnauthorized);
            var c = (this.xhr = new h(a)),
              d = this;
            try {
              l("xhr open %s: %s", this.method, this.uri),
                c.open(this.method, this.uri, this.async);
              try {
                if (this.extraHeaders) {
                  c.setDisableHeaderCheck && c.setDisableHeaderCheck(!0);
                  for (var e in this.extraHeaders)
                    this.extraHeaders.hasOwnProperty(e) &&
                      c.setRequestHeader(e, this.extraHeaders[e]);
                }
              } catch (g) {}
              if ("POST" === this.method)
                try {
                  this.isBinary
                    ? c.setRequestHeader(
                        "Content-type",
                        "application/octet-stream"
                      )
                    : c.setRequestHeader(
                        "Content-type",
                        "text/plain;charset=UTF-8"
                      );
                } catch (g) {}
              try {
                c.setRequestHeader("Accept", "*/*");
              } catch (g) {}
              "withCredentials" in c && (c.withCredentials = !0),
                this.requestTimeout && (c.timeout = this.requestTimeout),
                this.hasXDR()
                  ? ((c.onload = function() {
                      d.onLoad();
                    }),
                    (c.onerror = function() {
                      d.onError(c.responseText);
                    }))
                  : (c.onreadystatechange = function() {
                      if (2 === c.readyState) {
                        var a;
                        try {
                          a = c.getResponseHeader("Content-Type");
                        } catch (b) {}
                        "application/octet-stream" === a &&
                          (c.responseType = "arraybuffer");
                      }
                      4 === c.readyState &&
                        (200 === c.status || 1223 === c.status
                          ? d.onLoad()
                          : setTimeout(function() {
                              d.onError(c.status);
                            }, 0));
                    }),
                l("xhr data %s", this.data),
                c.send(this.data);
            } catch (g) {
              return void setTimeout(function() {
                d.onError(g);
              }, 0);
            }
            b.document &&
              ((this.index = f.requestsCount++),
              (f.requests[this.index] = this));
          }),
          (f.prototype.onSuccess = function() {
            this.emit("success"), this.cleanup();
          }),
          (f.prototype.onData = function(a) {
            this.emit("data", a), this.onSuccess();
          }),
          (f.prototype.onError = function(a) {
            this.emit("error", a), this.cleanup(!0);
          }),
          (f.prototype.cleanup = function(a) {
            if ("undefined" != typeof this.xhr && null !== this.xhr) {
              if (
                (this.hasXDR()
                  ? (this.xhr.onload = this.xhr.onerror = d)
                  : (this.xhr.onreadystatechange = d),
                a)
              )
                try {
                  this.xhr.abort();
                } catch (c) {}
              b.document && delete f.requests[this.index], (this.xhr = null);
            }
          }),
          (f.prototype.onLoad = function() {
            var a;
            try {
              var b;
              try {
                b = this.xhr.getResponseHeader("Content-Type");
              } catch (c) {}
              a =
                "application/octet-stream" === b
                  ? this.xhr.response || this.xhr.responseText
                  : this.xhr.responseText;
            } catch (c) {
              this.onError(c);
            }
            null != a && this.onData(a);
          }),
          (f.prototype.hasXDR = function() {
            return (
              "undefined" != typeof b.XDomainRequest &&
              !this.xs &&
              this.enablesXDR
            );
          }),
          (f.prototype.abort = function() {
            this.cleanup();
          }),
          (f.requestsCount = 0),
          (f.requests = {}),
          b.document &&
            (b.attachEvent
              ? b.attachEvent("onunload", g)
              : b.addEventListener &&
                b.addEventListener("beforeunload", g, !1));
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      function d(a) {
        var b = a && a.forceBase64;
        (k && !b) || (this.supportsBinary = !1), e.call(this, a);
      }
      var e = c(22),
        f = c(31),
        g = c(23),
        h = c(32),
        i = c(33),
        j = c(3)("engine.io-client:polling");
      a.exports = d;
      var k = (function() {
        var a = c(18),
          b = new a({ xdomain: !1 });
        return null != b.responseType;
      })();
      h(d, e),
        (d.prototype.name = "polling"),
        (d.prototype.doOpen = function() {
          this.poll();
        }),
        (d.prototype.pause = function(a) {
          function b() {
            j("paused"), (c.readyState = "paused"), a();
          }
          var c = this;
          if (((this.readyState = "pausing"), this.polling || !this.writable)) {
            var d = 0;
            this.polling &&
              (j("we are currently polling - waiting to pause"),
              d++,
              this.once("pollComplete", function() {
                j("pre-pause polling complete"), --d || b();
              })),
              this.writable ||
                (j("we are currently writing - waiting to pause"),
                d++,
                this.once("drain", function() {
                  j("pre-pause writing complete"), --d || b();
                }));
          } else b();
        }),
        (d.prototype.poll = function() {
          j("polling"), (this.polling = !0), this.doPoll(), this.emit("poll");
        }),
        (d.prototype.onData = function(a) {
          var b = this;
          j("polling got data %s", a);
          var c = function(a, c, d) {
            return (
              "opening" === b.readyState && b.onOpen(),
              "close" === a.type ? (b.onClose(), !1) : void b.onPacket(a)
            );
          };
          g.decodePayload(a, this.socket.binaryType, c),
            "closed" !== this.readyState &&
              ((this.polling = !1),
              this.emit("pollComplete"),
              "open" === this.readyState
                ? this.poll()
                : j('ignoring poll - transport state "%s"', this.readyState));
        }),
        (d.prototype.doClose = function() {
          function a() {
            j("writing close packet"), b.write([{ type: "close" }]);
          }
          var b = this;
          "open" === this.readyState
            ? (j("transport open - closing"), a())
            : (j("transport not open - deferring close"), this.once("open", a));
        }),
        (d.prototype.write = function(a) {
          var b = this;
          this.writable = !1;
          var c = function() {
            (b.writable = !0), b.emit("drain");
          };
          g.encodePayload(a, this.supportsBinary, function(a) {
            b.doWrite(a, c);
          });
        }),
        (d.prototype.uri = function() {
          var a = this.query || {},
            b = this.secure ? "https" : "http",
            c = "";
          !1 !== this.timestampRequests && (a[this.timestampParam] = i()),
            this.supportsBinary || a.sid || (a.b64 = 1),
            (a = f.encode(a)),
            this.port &&
              (("https" === b && 443 !== Number(this.port)) ||
                ("http" === b && 80 !== Number(this.port))) &&
              (c = ":" + this.port),
            a.length && (a = "?" + a);
          var d = this.hostname.indexOf(":") !== -1;
          return (
            b +
            "://" +
            (d ? "[" + this.hostname + "]" : this.hostname) +
            c +
            this.path +
            a
          );
        });
    },
    function(a, b, c) {
      function d(a) {
        (this.path = a.path),
          (this.hostname = a.hostname),
          (this.port = a.port),
          (this.secure = a.secure),
          (this.query = a.query),
          (this.timestampParam = a.timestampParam),
          (this.timestampRequests = a.timestampRequests),
          (this.readyState = ""),
          (this.agent = a.agent || !1),
          (this.socket = a.socket),
          (this.enablesXDR = a.enablesXDR),
          (this.pfx = a.pfx),
          (this.key = a.key),
          (this.passphrase = a.passphrase),
          (this.cert = a.cert),
          (this.ca = a.ca),
          (this.ciphers = a.ciphers),
          (this.rejectUnauthorized = a.rejectUnauthorized),
          (this.forceNode = a.forceNode),
          (this.extraHeaders = a.extraHeaders),
          (this.localAddress = a.localAddress);
      }
      var e = c(23),
        f = c(8);
      (a.exports = d),
        f(d.prototype),
        (d.prototype.onError = function(a, b) {
          var c = new Error(a);
          return (
            (c.type = "TransportError"),
            (c.description = b),
            this.emit("error", c),
            this
          );
        }),
        (d.prototype.open = function() {
          return (
            ("closed" !== this.readyState && "" !== this.readyState) ||
              ((this.readyState = "opening"), this.doOpen()),
            this
          );
        }),
        (d.prototype.close = function() {
          return (
            ("opening" !== this.readyState && "open" !== this.readyState) ||
              (this.doClose(), this.onClose()),
            this
          );
        }),
        (d.prototype.send = function(a) {
          if ("open" !== this.readyState) throw new Error("Transport not open");
          this.write(a);
        }),
        (d.prototype.onOpen = function() {
          (this.readyState = "open"), (this.writable = !0), this.emit("open");
        }),
        (d.prototype.onData = function(a) {
          var b = e.decodePacket(a, this.socket.binaryType);
          this.onPacket(b);
        }),
        (d.prototype.onPacket = function(a) {
          this.emit("packet", a);
        }),
        (d.prototype.onClose = function() {
          (this.readyState = "closed"), this.emit("close");
        });
    },
    function(a, b, c) {
      (function(a) {
        function d(a, c) {
          var d = "b" + b.packets[a.type] + a.data.data;
          return c(d);
        }
        function e(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          var e = a.data,
            f = new Uint8Array(e),
            g = new Uint8Array(1 + e.byteLength);
          g[0] = s[a.type];
          for (var h = 0; h < f.length; h++) g[h + 1] = f[h];
          return d(g.buffer);
        }
        function f(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          var e = new FileReader();
          return (
            (e.onload = function() {
              (a.data = e.result), b.encodePacket(a, c, !0, d);
            }),
            e.readAsArrayBuffer(a.data)
          );
        }
        function g(a, c, d) {
          if (!c) return b.encodeBase64Packet(a, d);
          if (r) return f(a, c, d);
          var e = new Uint8Array(1);
          e[0] = s[a.type];
          var g = new v([e.buffer, a.data]);
          return d(g);
        }
        function h(a) {
          try {
            a = o.decode(a, { strict: !1 });
          } catch (b) {
            return !1;
          }
          return a;
        }
        function i(a, b, c) {
          for (
            var d = new Array(a.length),
              e = n(a.length, c),
              f = function(a, c, e) {
                b(c, function(b, c) {
                  (d[a] = c), e(b, d);
                });
              },
              g = 0;
            g < a.length;
            g++
          )
            f(g, a[g], e);
        }
        var j,
          k = c(24),
          l = c(9),
          m = c(25),
          n = c(26),
          o = c(27);
        a && a.ArrayBuffer && (j = c(29));
        var p =
            "undefined" != typeof navigator &&
            /Android/i.test(navigator.userAgent),
          q =
            "undefined" != typeof navigator &&
            /PhantomJS/i.test(navigator.userAgent),
          r = p || q;
        b.protocol = 3;
        var s = (b.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
          }),
          t = k(s),
          u = { type: "error", data: "parser error" },
          v = c(30);
        (b.encodePacket = function(b, c, f, h) {
          "function" == typeof c && ((h = c), (c = !1)),
            "function" == typeof f && ((h = f), (f = null));
          var i = void 0 === b.data ? void 0 : b.data.buffer || b.data;
          if (a.ArrayBuffer && i instanceof ArrayBuffer) return e(b, c, h);
          if (v && i instanceof a.Blob) return g(b, c, h);
          if (i && i.base64) return d(b, h);
          var j = s[b.type];
          return (
            void 0 !== b.data &&
              (j += f
                ? o.encode(String(b.data), { strict: !1 })
                : String(b.data)),
            h("" + j)
          );
        }),
          (b.encodeBase64Packet = function(c, d) {
            var e = "b" + b.packets[c.type];
            if (v && c.data instanceof a.Blob) {
              var f = new FileReader();
              return (
                (f.onload = function() {
                  var a = f.result.split(",")[1];
                  d(e + a);
                }),
                f.readAsDataURL(c.data)
              );
            }
            var g;
            try {
              g = String.fromCharCode.apply(null, new Uint8Array(c.data));
            } catch (h) {
              for (
                var i = new Uint8Array(c.data), j = new Array(i.length), k = 0;
                k < i.length;
                k++
              )
                j[k] = i[k];
              g = String.fromCharCode.apply(null, j);
            }
            return (e += a.btoa(g)), d(e);
          }),
          (b.decodePacket = function(a, c, d) {
            if (void 0 === a) return u;
            if ("string" == typeof a) {
              if ("b" === a.charAt(0))
                return b.decodeBase64Packet(a.substr(1), c);
              if (d && ((a = h(a)), a === !1)) return u;
              var e = a.charAt(0);
              return Number(e) == e && t[e]
                ? a.length > 1
                  ? { type: t[e], data: a.substring(1) }
                  : { type: t[e] }
                : u;
            }
            var f = new Uint8Array(a),
              e = f[0],
              g = m(a, 1);
            return (
              v && "blob" === c && (g = new v([g])), { type: t[e], data: g }
            );
          }),
          (b.decodeBase64Packet = function(a, b) {
            var c = t[a.charAt(0)];
            if (!j) return { type: c, data: { base64: !0, data: a.substr(1) } };
            var d = j.decode(a.substr(1));
            return "blob" === b && v && (d = new v([d])), { type: c, data: d };
          }),
          (b.encodePayload = function(a, c, d) {
            function e(a) {
              return a.length + ":" + a;
            }
            function f(a, d) {
              b.encodePacket(a, !!g && c, !1, function(a) {
                d(null, e(a));
              });
            }
            "function" == typeof c && ((d = c), (c = null));
            var g = l(a);
            return c && g
              ? v && !r
                ? b.encodePayloadAsBlob(a, d)
                : b.encodePayloadAsArrayBuffer(a, d)
              : a.length
              ? void i(a, f, function(a, b) {
                  return d(b.join(""));
                })
              : d("0:");
          }),
          (b.decodePayload = function(a, c, d) {
            if ("string" != typeof a) return b.decodePayloadAsBinary(a, c, d);
            "function" == typeof c && ((d = c), (c = null));
            var e;
            if ("" === a) return d(u, 0, 1);
            for (var f, g, h = "", i = 0, j = a.length; i < j; i++) {
              var k = a.charAt(i);
              if (":" === k) {
                if ("" === h || h != (f = Number(h))) return d(u, 0, 1);
                if (((g = a.substr(i + 1, f)), h != g.length))
                  return d(u, 0, 1);
                if (g.length) {
                  if (
                    ((e = b.decodePacket(g, c, !1)),
                    u.type === e.type && u.data === e.data)
                  )
                    return d(u, 0, 1);
                  var l = d(e, i + f, j);
                  if (!1 === l) return;
                }
                (i += f), (h = "");
              } else h += k;
            }
            return "" !== h ? d(u, 0, 1) : void 0;
          }),
          (b.encodePayloadAsArrayBuffer = function(a, c) {
            function d(a, c) {
              b.encodePacket(a, !0, !0, function(a) {
                return c(null, a);
              });
            }
            return a.length
              ? void i(a, d, function(a, b) {
                  var d = b.reduce(function(a, b) {
                      var c;
                      return (
                        (c = "string" == typeof b ? b.length : b.byteLength),
                        a + c.toString().length + c + 2
                      );
                    }, 0),
                    e = new Uint8Array(d),
                    f = 0;
                  return (
                    b.forEach(function(a) {
                      var b = "string" == typeof a,
                        c = a;
                      if (b) {
                        for (
                          var d = new Uint8Array(a.length), g = 0;
                          g < a.length;
                          g++
                        )
                          d[g] = a.charCodeAt(g);
                        c = d.buffer;
                      }
                      b ? (e[f++] = 0) : (e[f++] = 1);
                      for (
                        var h = c.byteLength.toString(), g = 0;
                        g < h.length;
                        g++
                      )
                        e[f++] = parseInt(h[g]);
                      e[f++] = 255;
                      for (var d = new Uint8Array(c), g = 0; g < d.length; g++)
                        e[f++] = d[g];
                    }),
                    c(e.buffer)
                  );
                })
              : c(new ArrayBuffer(0));
          }),
          (b.encodePayloadAsBlob = function(a, c) {
            function d(a, c) {
              b.encodePacket(a, !0, !0, function(a) {
                var b = new Uint8Array(1);
                if (((b[0] = 1), "string" == typeof a)) {
                  for (
                    var d = new Uint8Array(a.length), e = 0;
                    e < a.length;
                    e++
                  )
                    d[e] = a.charCodeAt(e);
                  (a = d.buffer), (b[0] = 0);
                }
                for (
                  var f = a instanceof ArrayBuffer ? a.byteLength : a.size,
                    g = f.toString(),
                    h = new Uint8Array(g.length + 1),
                    e = 0;
                  e < g.length;
                  e++
                )
                  h[e] = parseInt(g[e]);
                if (((h[g.length] = 255), v)) {
                  var i = new v([b.buffer, h.buffer, a]);
                  c(null, i);
                }
              });
            }
            i(a, d, function(a, b) {
              return c(new v(b));
            });
          }),
          (b.decodePayloadAsBinary = function(a, c, d) {
            "function" == typeof c && ((d = c), (c = null));
            for (var e = a, f = []; e.byteLength > 0; ) {
              for (
                var g = new Uint8Array(e), h = 0 === g[0], i = "", j = 1;
                255 !== g[j];
                j++
              ) {
                if (i.length > 310) return d(u, 0, 1);
                i += g[j];
              }
              (e = m(e, 2 + i.length)), (i = parseInt(i));
              var k = m(e, 0, i);
              if (h)
                try {
                  k = String.fromCharCode.apply(null, new Uint8Array(k));
                } catch (l) {
                  var n = new Uint8Array(k);
                  k = "";
                  for (var j = 0; j < n.length; j++)
                    k += String.fromCharCode(n[j]);
                }
              f.push(k), (e = m(e, i));
            }
            var o = f.length;
            f.forEach(function(a, e) {
              d(b.decodePacket(a, c, !0), e, o);
            });
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      a.exports =
        Object.keys ||
        function(a) {
          var b = [],
            c = Object.prototype.hasOwnProperty;
          for (var d in a) c.call(a, d) && b.push(d);
          return b;
        };
    },
    function(a, b) {
      a.exports = function(a, b, c) {
        var d = a.byteLength;
        if (((b = b || 0), (c = c || d), a.slice)) return a.slice(b, c);
        if (
          (b < 0 && (b += d),
          c < 0 && (c += d),
          c > d && (c = d),
          b >= d || b >= c || 0 === d)
        )
          return new ArrayBuffer(0);
        for (
          var e = new Uint8Array(a), f = new Uint8Array(c - b), g = b, h = 0;
          g < c;
          g++, h++
        )
          f[h] = e[g];
        return f.buffer;
      };
    },
    function(a, b) {
      function c(a, b, c) {
        function e(a, d) {
          if (e.count <= 0) throw new Error("after called too many times");
          --e.count,
            a ? ((f = !0), b(a), (b = c)) : 0 !== e.count || f || b(null, d);
        }
        var f = !1;
        return (c = c || d), (e.count = a), 0 === a ? b() : e;
      }
      function d() {}
      a.exports = c;
    },
    function(a, b, c) {
      var d;
      (function(a, e) {
        !(function(f) {
          function g(a) {
            for (var b, c, d = [], e = 0, f = a.length; e < f; )
              (b = a.charCodeAt(e++)),
                b >= 55296 && b <= 56319 && e < f
                  ? ((c = a.charCodeAt(e++)),
                    56320 == (64512 & c)
                      ? d.push(((1023 & b) << 10) + (1023 & c) + 65536)
                      : (d.push(b), e--))
                  : d.push(b);
            return d;
          }
          function h(a) {
            for (var b, c = a.length, d = -1, e = ""; ++d < c; )
              (b = a[d]),
                b > 65535 &&
                  ((b -= 65536),
                  (e += u(((b >>> 10) & 1023) | 55296)),
                  (b = 56320 | (1023 & b))),
                (e += u(b));
            return e;
          }
          function i(a, b) {
            if (a >= 55296 && a <= 57343) {
              if (b)
                throw Error(
                  "Lone surrogate U+" +
                    a.toString(16).toUpperCase() +
                    " is not a scalar value"
                );
              return !1;
            }
            return !0;
          }
          function j(a, b) {
            return u(((a >> b) & 63) | 128);
          }
          function k(a, b) {
            if (0 == (4294967168 & a)) return u(a);
            var c = "";
            return (
              0 == (4294965248 & a)
                ? (c = u(((a >> 6) & 31) | 192))
                : 0 == (4294901760 & a)
                ? (i(a, b) || (a = 65533),
                  (c = u(((a >> 12) & 15) | 224)),
                  (c += j(a, 6)))
                : 0 == (4292870144 & a) &&
                  ((c = u(((a >> 18) & 7) | 240)),
                  (c += j(a, 12)),
                  (c += j(a, 6))),
              (c += u((63 & a) | 128))
            );
          }
          function l(a, b) {
            b = b || {};
            for (
              var c,
                d = !1 !== b.strict,
                e = g(a),
                f = e.length,
                h = -1,
                i = "";
              ++h < f;

            )
              (c = e[h]), (i += k(c, d));
            return i;
          }
          function m() {
            if (t >= s) throw Error("Invalid byte index");
            var a = 255 & r[t];
            if ((t++, 128 == (192 & a))) return 63 & a;
            throw Error("Invalid continuation byte");
          }
          function n(a) {
            var b, c, d, e, f;
            if (t > s) throw Error("Invalid byte index");
            if (t == s) return !1;
            if (((b = 255 & r[t]), t++, 0 == (128 & b))) return b;
            if (192 == (224 & b)) {
              if (((c = m()), (f = ((31 & b) << 6) | c), f >= 128)) return f;
              throw Error("Invalid continuation byte");
            }
            if (224 == (240 & b)) {
              if (
                ((c = m()),
                (d = m()),
                (f = ((15 & b) << 12) | (c << 6) | d),
                f >= 2048)
              )
                return i(f, a) ? f : 65533;
              throw Error("Invalid continuation byte");
            }
            if (
              240 == (248 & b) &&
              ((c = m()),
              (d = m()),
              (e = m()),
              (f = ((7 & b) << 18) | (c << 12) | (d << 6) | e),
              f >= 65536 && f <= 1114111)
            )
              return f;
            throw Error("Invalid UTF-8 detected");
          }
          function o(a, b) {
            b = b || {};
            var c = !1 !== b.strict;
            (r = g(a)), (s = r.length), (t = 0);
            for (var d, e = []; (d = n(c)) !== !1; ) e.push(d);
            return h(e);
          }
          var p = "object" == typeof b && b,
            q = ("object" == typeof a && a && a.exports == p && a,
            "object" == typeof e && e);
          (q.global !== q && q.window !== q) || (f = q);
          var r,
            s,
            t,
            u = String.fromCharCode,
            v = { version: "2.1.2", encode: l, decode: o };
          (d = function() {
            return v;
          }.call(b, c, b, a)),
            !(void 0 !== d && (a.exports = d));
        })(this);
      }.call(
        b,
        c(28)(a),
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      a.exports = function(a) {
        return (
          a.webpackPolyfill ||
            ((a.deprecate = function() {}),
            (a.paths = []),
            (a.children = []),
            (a.webpackPolyfill = 1)),
          a
        );
      };
    },
    function(a, b) {
      !(function() {
        "use strict";
        for (
          var a =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            c = new Uint8Array(256),
            d = 0;
          d < a.length;
          d++
        )
          c[a.charCodeAt(d)] = d;
        (b.encode = function(b) {
          var c,
            d = new Uint8Array(b),
            e = d.length,
            f = "";
          for (c = 0; c < e; c += 3)
            (f += a[d[c] >> 2]),
              (f += a[((3 & d[c]) << 4) | (d[c + 1] >> 4)]),
              (f += a[((15 & d[c + 1]) << 2) | (d[c + 2] >> 6)]),
              (f += a[63 & d[c + 2]]);
          return (
            e % 3 === 2
              ? (f = f.substring(0, f.length - 1) + "=")
              : e % 3 === 1 && (f = f.substring(0, f.length - 2) + "=="),
            f
          );
        }),
          (b.decode = function(a) {
            var b,
              d,
              e,
              f,
              g,
              h = 0.75 * a.length,
              i = a.length,
              j = 0;
            "=" === a[a.length - 1] && (h--, "=" === a[a.length - 2] && h--);
            var k = new ArrayBuffer(h),
              l = new Uint8Array(k);
            for (b = 0; b < i; b += 4)
              (d = c[a.charCodeAt(b)]),
                (e = c[a.charCodeAt(b + 1)]),
                (f = c[a.charCodeAt(b + 2)]),
                (g = c[a.charCodeAt(b + 3)]),
                (l[j++] = (d << 2) | (e >> 4)),
                (l[j++] = ((15 & e) << 4) | (f >> 2)),
                (l[j++] = ((3 & f) << 6) | (63 & g));
            return k;
          });
      })();
    },
    function(a, b) {
      (function(b) {
        function c(a) {
          for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (c.buffer instanceof ArrayBuffer) {
              var d = c.buffer;
              if (c.byteLength !== d.byteLength) {
                var e = new Uint8Array(c.byteLength);
                e.set(new Uint8Array(d, c.byteOffset, c.byteLength)),
                  (d = e.buffer);
              }
              a[b] = d;
            }
          }
        }
        function d(a, b) {
          b = b || {};
          var d = new f();
          c(a);
          for (var e = 0; e < a.length; e++) d.append(a[e]);
          return b.type ? d.getBlob(b.type) : d.getBlob();
        }
        function e(a, b) {
          return c(a), new Blob(a, b || {});
        }
        var f =
            b.BlobBuilder ||
            b.WebKitBlobBuilder ||
            b.MSBlobBuilder ||
            b.MozBlobBuilder,
          g = (function() {
            try {
              var a = new Blob(["hi"]);
              return 2 === a.size;
            } catch (b) {
              return !1;
            }
          })(),
          h =
            g &&
            (function() {
              try {
                var a = new Blob([new Uint8Array([1, 2])]);
                return 2 === a.size;
              } catch (b) {
                return !1;
              }
            })(),
          i = f && f.prototype.append && f.prototype.getBlob;
        a.exports = (function() {
          return g ? (h ? b.Blob : e) : i ? d : void 0;
        })();
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {
      (b.encode = function(a) {
        var b = "";
        for (var c in a)
          a.hasOwnProperty(c) &&
            (b.length && (b += "&"),
            (b += encodeURIComponent(c) + "=" + encodeURIComponent(a[c])));
        return b;
      }),
        (b.decode = function(a) {
          for (var b = {}, c = a.split("&"), d = 0, e = c.length; d < e; d++) {
            var f = c[d].split("=");
            b[decodeURIComponent(f[0])] = decodeURIComponent(f[1]);
          }
          return b;
        });
    },
    function(a, b) {
      a.exports = function(a, b) {
        var c = function() {};
        (c.prototype = b.prototype),
          (a.prototype = new c()),
          (a.prototype.constructor = a);
      };
    },
    function(a, b) {
      "use strict";
      function c(a) {
        var b = "";
        do (b = g[a % h] + b), (a = Math.floor(a / h));
        while (a > 0);
        return b;
      }
      function d(a) {
        var b = 0;
        for (k = 0; k < a.length; k++) b = b * h + i[a.charAt(k)];
        return b;
      }
      function e() {
        var a = c(+new Date());
        return a !== f ? ((j = 0), (f = a)) : a + "." + c(j++);
      }
      for (
        var f,
          g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
            ""
          ),
          h = 64,
          i = {},
          j = 0,
          k = 0;
        k < h;
        k++
      )
        i[g[k]] = k;
      (e.encode = c), (e.decode = d), (a.exports = e);
    },
    function(a, b, c) {
      (function(b) {
        function d() {}
        function e(a) {
          f.call(this, a),
            (this.query = this.query || {}),
            h || (b.___eio || (b.___eio = []), (h = b.___eio)),
            (this.index = h.length);
          var c = this;
          h.push(function(a) {
            c.onData(a);
          }),
            (this.query.j = this.index),
            b.document &&
              b.addEventListener &&
              b.addEventListener(
                "beforeunload",
                function() {
                  c.script && (c.script.onerror = d);
                },
                !1
              );
        }
        var f = c(21),
          g = c(32);
        a.exports = e;
        var h,
          i = /\n/g,
          j = /\\n/g;
        g(e, f),
          (e.prototype.supportsBinary = !1),
          (e.prototype.doClose = function() {
            this.script &&
              (this.script.parentNode.removeChild(this.script),
              (this.script = null)),
              this.form &&
                (this.form.parentNode.removeChild(this.form),
                (this.form = null),
                (this.iframe = null)),
              f.prototype.doClose.call(this);
          }),
          (e.prototype.doPoll = function() {
            var a = this,
              b = document.createElement("script");
            this.script &&
              (this.script.parentNode.removeChild(this.script),
              (this.script = null)),
              (b.async = !0),
              (b.src = this.uri()),
              (b.onerror = function(b) {
                a.onError("jsonp poll error", b);
              });
            var c = document.getElementsByTagName("script")[0];
            c
              ? c.parentNode.insertBefore(b, c)
              : (document.head || document.body).appendChild(b),
              (this.script = b);
            var d =
              "undefined" != typeof navigator &&
              /gecko/i.test(navigator.userAgent);
            d &&
              setTimeout(function() {
                var a = document.createElement("iframe");
                document.body.appendChild(a), document.body.removeChild(a);
              }, 100);
          }),
          (e.prototype.doWrite = function(a, b) {
            function c() {
              d(), b();
            }
            function d() {
              if (e.iframe)
                try {
                  e.form.removeChild(e.iframe);
                } catch (a) {
                  e.onError("jsonp polling iframe removal error", a);
                }
              try {
                var b = '<iframe src="javascript:0" name="' + e.iframeId + '">';
                f = document.createElement(b);
              } catch (a) {
                (f = document.createElement("iframe")),
                  (f.name = e.iframeId),
                  (f.src = "javascript:0");
              }
              (f.id = e.iframeId), e.form.appendChild(f), (e.iframe = f);
            }
            var e = this;
            if (!this.form) {
              var f,
                g = document.createElement("form"),
                h = document.createElement("textarea"),
                k = (this.iframeId = "eio_iframe_" + this.index);
              (g.className = "socketio"),
                (g.style.position = "absolute"),
                (g.style.top = "-1000px"),
                (g.style.left = "-1000px"),
                (g.target = k),
                (g.method = "POST"),
                g.setAttribute("accept-charset", "utf-8"),
                (h.name = "d"),
                g.appendChild(h),
                document.body.appendChild(g),
                (this.form = g),
                (this.area = h);
            }
            (this.form.action = this.uri()),
              d(),
              (a = a.replace(j, "\\\n")),
              (this.area.value = a.replace(i, "\\n"));
            try {
              this.form.submit();
            } catch (l) {}
            this.iframe.attachEvent
              ? (this.iframe.onreadystatechange = function() {
                  "complete" === e.iframe.readyState && c();
                })
              : (this.iframe.onload = c);
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      (function(b) {
        function d(a) {
          var b = a && a.forceBase64;
          b && (this.supportsBinary = !1),
            (this.perMessageDeflate = a.perMessageDeflate),
            (this.usingBrowserWebSocket = l && !a.forceNode),
            (this.protocols = a.protocols),
            this.usingBrowserWebSocket || (n = e),
            f.call(this, a);
        }
        var e,
          f = c(22),
          g = c(23),
          h = c(31),
          i = c(32),
          j = c(33),
          k = c(3)("engine.io-client:websocket"),
          l = b.WebSocket || b.MozWebSocket;
        if ("undefined" == typeof window)
          try {
            e = c(36);
          } catch (m) {}
        var n = l;
        n || "undefined" != typeof window || (n = e),
          (a.exports = d),
          i(d, f),
          (d.prototype.name = "websocket"),
          (d.prototype.supportsBinary = !0),
          (d.prototype.doOpen = function() {
            if (this.check()) {
              var a = this.uri(),
                b = this.protocols,
                c = {
                  agent: this.agent,
                  perMessageDeflate: this.perMessageDeflate
                };
              (c.pfx = this.pfx),
                (c.key = this.key),
                (c.passphrase = this.passphrase),
                (c.cert = this.cert),
                (c.ca = this.ca),
                (c.ciphers = this.ciphers),
                (c.rejectUnauthorized = this.rejectUnauthorized),
                this.extraHeaders && (c.headers = this.extraHeaders),
                this.localAddress && (c.localAddress = this.localAddress);
              try {
                this.ws = this.usingBrowserWebSocket
                  ? b
                    ? new n(a, b)
                    : new n(a)
                  : new n(a, b, c);
              } catch (d) {
                return this.emit("error", d);
              }
              void 0 === this.ws.binaryType && (this.supportsBinary = !1),
                this.ws.supports && this.ws.supports.binary
                  ? ((this.supportsBinary = !0),
                    (this.ws.binaryType = "nodebuffer"))
                  : (this.ws.binaryType = "arraybuffer"),
                this.addEventListeners();
            }
          }),
          (d.prototype.addEventListeners = function() {
            var a = this;
            (this.ws.onopen = function() {
              a.onOpen();
            }),
              (this.ws.onclose = function() {
                a.onClose();
              }),
              (this.ws.onmessage = function(b) {
                a.onData(b.data);
              }),
              (this.ws.onerror = function(b) {
                a.onError("websocket error", b);
              });
          }),
          (d.prototype.write = function(a) {
            function c() {
              d.emit("flush"),
                setTimeout(function() {
                  (d.writable = !0), d.emit("drain");
                }, 0);
            }
            var d = this;
            this.writable = !1;
            for (var e = a.length, f = 0, h = e; f < h; f++)
              !(function(a) {
                g.encodePacket(a, d.supportsBinary, function(f) {
                  if (!d.usingBrowserWebSocket) {
                    var g = {};
                    if (
                      (a.options && (g.compress = a.options.compress),
                      d.perMessageDeflate)
                    ) {
                      var h =
                        "string" == typeof f
                          ? b.Buffer.byteLength(f)
                          : f.length;
                      h < d.perMessageDeflate.threshold && (g.compress = !1);
                    }
                  }
                  try {
                    d.usingBrowserWebSocket ? d.ws.send(f) : d.ws.send(f, g);
                  } catch (i) {
                    k("websocket closed before onclose event");
                  }
                  --e || c();
                });
              })(a[f]);
          }),
          (d.prototype.onClose = function() {
            f.prototype.onClose.call(this);
          }),
          (d.prototype.doClose = function() {
            "undefined" != typeof this.ws && this.ws.close();
          }),
          (d.prototype.uri = function() {
            var a = this.query || {},
              b = this.secure ? "wss" : "ws",
              c = "";
            this.port &&
              (("wss" === b && 443 !== Number(this.port)) ||
                ("ws" === b && 80 !== Number(this.port))) &&
              (c = ":" + this.port),
              this.timestampRequests && (a[this.timestampParam] = j()),
              this.supportsBinary || (a.b64 = 1),
              (a = h.encode(a)),
              a.length && (a = "?" + a);
            var d = this.hostname.indexOf(":") !== -1;
            return (
              b +
              "://" +
              (d ? "[" + this.hostname + "]" : this.hostname) +
              c +
              this.path +
              a
            );
          }),
          (d.prototype.check = function() {
            return !(
              !n ||
              ("__initialize" in n && this.name === d.prototype.name)
            );
          });
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b) {},
    function(a, b) {
      var c = [].indexOf;
      a.exports = function(a, b) {
        if (c) return a.indexOf(b);
        for (var d = 0; d < a.length; ++d) if (a[d] === b) return d;
        return -1;
      };
    },
    function(a, b) {
      (function(b) {
        var c = /^[\],:{}\s]*$/,
          d = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
          e = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
          f = /(?:^|:|,)(?:\s*\[)+/g,
          g = /^\s+/,
          h = /\s+$/;
        a.exports = function(a) {
          return "string" == typeof a && a
            ? ((a = a.replace(g, "").replace(h, "")),
              b.JSON && JSON.parse
                ? JSON.parse(a)
                : c.test(
                    a
                      .replace(d, "@")
                      .replace(e, "]")
                      .replace(f, "")
                  )
                ? new Function("return " + a)()
                : void 0)
            : null;
        };
      }.call(
        b,
        (function() {
          return this;
        })()
      ));
    },
    function(a, b, c) {
      "use strict";
      function d(a, b, c) {
        (this.io = a),
          (this.nsp = b),
          (this.json = this),
          (this.ids = 0),
          (this.acks = {}),
          (this.receiveBuffer = []),
          (this.sendBuffer = []),
          (this.connected = !1),
          (this.disconnected = !0),
          c && c.query && (this.query = c.query),
          this.io.autoConnect && this.open();
      }
      var e =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function(a) {
                return typeof a;
              }
            : function(a) {
                return a &&
                  "function" == typeof Symbol &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a;
              },
        f = c(7),
        g = c(8),
        h = c(40),
        i = c(41),
        j = c(42),
        k = c(3)("socket.io-client:socket"),
        l = c(31);
      a.exports = b = d;
      var m = {
          connect: 1,
          connect_error: 1,
          connect_timeout: 1,
          connecting: 1,
          disconnect: 1,
          error: 1,
          reconnect: 1,
          reconnect_attempt: 1,
          reconnect_failed: 1,
          reconnect_error: 1,
          reconnecting: 1,
          ping: 1,
          pong: 1
        },
        n = g.prototype.emit;
      g(d.prototype),
        (d.prototype.subEvents = function() {
          if (!this.subs) {
            var a = this.io;
            this.subs = [
              i(a, "open", j(this, "onopen")),
              i(a, "packet", j(this, "onpacket")),
              i(a, "close", j(this, "onclose"))
            ];
          }
        }),
        (d.prototype.open = d.prototype.connect = function() {
          return this.connected
            ? this
            : (this.subEvents(),
              this.io.open(),
              "open" === this.io.readyState && this.onopen(),
              this.emit("connecting"),
              this);
        }),
        (d.prototype.send = function() {
          var a = h(arguments);
          return a.unshift("message"), this.emit.apply(this, a), this;
        }),
        (d.prototype.emit = function(a) {
          if (m.hasOwnProperty(a)) return n.apply(this, arguments), this;
          var b = h(arguments),
            c = { type: f.EVENT, data: b };
          return (
            (c.options = {}),
            (c.options.compress = !this.flags || !1 !== this.flags.compress),
            "function" == typeof b[b.length - 1] &&
              (k("emitting packet with ack id %d", this.ids),
              (this.acks[this.ids] = b.pop()),
              (c.id = this.ids++)),
            this.connected ? this.packet(c) : this.sendBuffer.push(c),
            delete this.flags,
            this
          );
        }),
        (d.prototype.packet = function(a) {
          (a.nsp = this.nsp), this.io.packet(a);
        }),
        (d.prototype.onopen = function() {
          if ((k("transport is open - connecting"), "/" !== this.nsp))
            if (this.query) {
              var a =
                "object" === e(this.query) ? l.encode(this.query) : this.query;
              k("sending connect packet with query %s", a),
                this.packet({ type: f.CONNECT, query: a });
            } else this.packet({ type: f.CONNECT });
        }),
        (d.prototype.onclose = function(a) {
          k("close (%s)", a),
            (this.connected = !1),
            (this.disconnected = !0),
            delete this.id,
            this.emit("disconnect", a);
        }),
        (d.prototype.onpacket = function(a) {
          if (a.nsp === this.nsp)
            switch (a.type) {
              case f.CONNECT:
                this.onconnect();
                break;
              case f.EVENT:
                this.onevent(a);
                break;
              case f.BINARY_EVENT:
                this.onevent(a);
                break;
              case f.ACK:
                this.onack(a);
                break;
              case f.BINARY_ACK:
                this.onack(a);
                break;
              case f.DISCONNECT:
                this.ondisconnect();
                break;
              case f.ERROR:
                this.emit("error", a.data);
            }
        }),
        (d.prototype.onevent = function(a) {
          var b = a.data || [];
          k("emitting event %j", b),
            null != a.id &&
              (k("attaching ack callback to event"), b.push(this.ack(a.id))),
            this.connected ? n.apply(this, b) : this.receiveBuffer.push(b);
        }),
        (d.prototype.ack = function(a) {
          var b = this,
            c = !1;
          return function() {
            if (!c) {
              c = !0;
              var d = h(arguments);
              k("sending ack %j", d), b.packet({ type: f.ACK, id: a, data: d });
            }
          };
        }),
        (d.prototype.onack = function(a) {
          var b = this.acks[a.id];
          "function" == typeof b
            ? (k("calling ack %s with %j", a.id, a.data),
              b.apply(this, a.data),
              delete this.acks[a.id])
            : k("bad ack %s", a.id);
        }),
        (d.prototype.onconnect = function() {
          (this.connected = !0),
            (this.disconnected = !1),
            this.emit("connect"),
            this.emitBuffered();
        }),
        (d.prototype.emitBuffered = function() {
          var a;
          for (a = 0; a < this.receiveBuffer.length; a++)
            n.apply(this, this.receiveBuffer[a]);
          for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++)
            this.packet(this.sendBuffer[a]);
          this.sendBuffer = [];
        }),
        (d.prototype.ondisconnect = function() {
          k("server disconnect (%s)", this.nsp),
            this.destroy(),
            this.onclose("io server disconnect");
        }),
        (d.prototype.destroy = function() {
          if (this.subs) {
            for (var a = 0; a < this.subs.length; a++) this.subs[a].destroy();
            this.subs = null;
          }
          this.io.destroy(this);
        }),
        (d.prototype.close = d.prototype.disconnect = function() {
          return (
            this.connected &&
              (k("performing disconnect (%s)", this.nsp),
              this.packet({ type: f.DISCONNECT })),
            this.destroy(),
            this.connected && this.onclose("io client disconnect"),
            this
          );
        }),
        (d.prototype.compress = function(a) {
          return (
            (this.flags = this.flags || {}), (this.flags.compress = a), this
          );
        });
    },
    function(a, b) {
      function c(a, b) {
        var c = [];
        b = b || 0;
        for (var d = b || 0; d < a.length; d++) c[d - b] = a[d];
        return c;
      }
      a.exports = c;
    },
    function(a, b) {
      "use strict";
      function c(a, b, c) {
        return (
          a.on(b, c),
          {
            destroy: function() {
              a.removeListener(b, c);
            }
          }
        );
      }
      a.exports = c;
    },
    function(a, b) {
      var c = [].slice;
      a.exports = function(a, b) {
        if (("string" == typeof b && (b = a[b]), "function" != typeof b))
          throw new Error("bind() requires a function");
        var d = c.call(arguments, 2);
        return function() {
          return b.apply(a, d.concat(c.call(arguments)));
        };
      };
    },
    function(a, b) {
      function c(a) {
        (a = a || {}),
          (this.ms = a.min || 100),
          (this.max = a.max || 1e4),
          (this.factor = a.factor || 2),
          (this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0),
          (this.attempts = 0);
      }
      (a.exports = c),
        (c.prototype.duration = function() {
          var a = this.ms * Math.pow(this.factor, this.attempts++);
          if (this.jitter) {
            var b = Math.random(),
              c = Math.floor(b * this.jitter * a);
            a = 0 == (1 & Math.floor(10 * b)) ? a - c : a + c;
          }
          return 0 | Math.min(a, this.max);
        }),
        (c.prototype.reset = function() {
          this.attempts = 0;
        }),
        (c.prototype.setMin = function(a) {
          this.ms = a;
        }),
        (c.prototype.setMax = function(a) {
          this.max = a;
        }),
        (c.prototype.setJitter = function(a) {
          this.jitter = a;
        });
    }
  ]);
});

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//  ███████╗ █████╗ ██╗██╗     ███████╗   ██╗ ██████╗         ██╗███████╗         //
//  ██╔════╝██╔══██╗██║██║     ██╔════╝   ██║██╔═══██╗        ██║██╔════╝         //
//  ███████╗███████║██║██║     ███████╗   ██║██║   ██║        ██║███████╗         //
//  ╚════██║██╔══██║██║██║     ╚════██║   ██║██║   ██║   ██   ██║╚════██║         //
//  ███████║██║  ██║██║███████╗███████║██╗██║╚██████╔╝██╗╚█████╔╝███████║         //
//  ╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚══════╝╚═╝╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝         //
//                                                                                //
//   ╦╔═╗╦  ╦╔═╗╔═╗╔═╗╦═╗╦╔═╗╔╦╗  ╔═╗╦  ╦╔═╗╔╗╔╔╦╗  ╔═╗╔╦╗╦╔═                     //
//   ║╠═╣╚╗╔╝╠═╣╚═╗║  ╠╦╝║╠═╝ ║   ║  ║  ║║╣ ║║║ ║   ╚═╗ ║║╠╩╗                     //
//  ╚╝╩ ╩ ╚╝ ╩ ╩╚═╝╚═╝╩╚═╩╩   ╩   ╚═╝╩═╝╩╚═╝╝╚╝ ╩   ╚═╝═╩╝╩ ╩                     //
//  ┌─┐┌─┐┬─┐  ┌┐┌┌─┐┌┬┐┌─┐  ┬┌─┐  ┌─┐┌┐┌┌┬┐  ┌┬┐┬ ┬┌─┐  ┌┐ ┬─┐┌─┐┬ ┬┌─┐┌─┐┬─┐    //
//  ├┤ │ │├┬┘  ││││ │ ││├┤   │└─┐  ├─┤│││ ││   │ ├─┤├┤   ├┴┐├┬┘│ ││││└─┐├┤ ├┬┘    //
//  └  └─┘┴└─  ┘└┘└─┘─┴┘└─┘o└┘└─┘  ┴ ┴┘└┘─┴┘   ┴ ┴ ┴└─┘  └─┘┴└─└─┘└┴┘└─┘└─┘┴└─    //
//                                                                                //
//////////////////////////////////////////////////////////////////////////////////////

/**
 * sails.io.js
 * v1.2.1
 * ------------------------------------------------------------------------
 * JavaScript Client (SDK) for communicating with Sails.
 *
 * Note that this script is completely optional, but it is handy if you're
 * using WebSockets from the browser to talk to your Sails server.
 *
 * For tips and documentation, visit:
 * http://sailsjs.com/documentation/reference/web-sockets/socket-client
 * ------------------------------------------------------------------------
 *
 * This file allows you to send and receive socket.io messages to & from Sails
 * by simulating a REST client interface on top of socket.io. It models its API
 * after the $.ajax pattern from jQuery you might already be familiar with.
 *
 * So if you're switching from using AJAX to sockets, instead of:
 *    `$.post( url, [data], [cb] )`
 *
 * You would use:
 *    `socket.post( url, [data], [cb] )`
 */

(function() {
  //   ██████╗ ██████╗ ███╗   ██╗███████╗████████╗ █████╗ ███╗   ██╗████████╗███████╗
  //  ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔══██╗████╗  ██║╚══██╔══╝██╔════╝
  //  ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████║██╔██╗ ██║   ██║   ███████╗
  //  ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║╚██╗██║   ██║   ╚════██║
  //  ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ██║  ██║██║ ╚████║   ██║   ███████║
  //   ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
  //

  /**
   * Constant containing the names of all available options
   * for individual sockets.
   *
   * @type {Array}
   */
  var SOCKET_OPTIONS = [
    "useCORSRouteToGetCookie",
    "url",
    "multiplex",
    "transports",
    "query",
    "path",
    "headers",
    "initialConnectionHeaders",
    "reconnection",
    "reconnectionAttempts",
    "reconnectionDelay",
    "reconnectionDelayMax",
    "rejectUnauthorized",
    "randomizationFactor",
    "timeout"
  ];

  /**
   * Constant containing the names of properties on `io.sails` which
   * may be configured using HTML attributes on the script tag which
   * loaded this file.
   *
   * @type {Array}
   *
   * (this is unused if loading from node.js)
   */
  var CONFIGURABLE_VIA_HTML_ATTR = [
    "autoConnect",
    "reconnection",
    "environment",
    "headers",
    "url",
    "transports",
    "path"
  ];

  /**
   * Constant containing the names of querystring
   * parameters sent when connecting any SailsSocket.
   *
   * @type {Dictionary}
   */
  var CONNECTION_METADATA_PARAMS = {
    version: "__sails_io_sdk_version",
    platform: "__sails_io_sdk_platform",
    language: "__sails_io_sdk_language"
  };

  /**
   * Constant containing metadata about the platform, language, and
   * current version of this SDK.
   *
   * @type {Dictionary}
   */
  var SDK_INFO = {
    version: "1.2.1", // <-- pulled automatically from package.json, do not change!
    language: "javascript",
    platform: (function() {
      if ( true && typeof module.exports !== "undefined") {
        return "node";
      } else {
        return "browser";
      }
    })()
  };

  // Build `versionString` (a querystring snippet) by
  // combining SDK_INFO and CONNECTION_METADATA_PARAMS.
  SDK_INFO.versionString =
    CONNECTION_METADATA_PARAMS.version +
    "=" +
    SDK_INFO.version +
    "&" +
    CONNECTION_METADATA_PARAMS.platform +
    "=" +
    SDK_INFO.platform +
    "&" +
    CONNECTION_METADATA_PARAMS.language +
    "=" +
    SDK_INFO.language;

  //   █████╗ ██████╗ ███████╗ ██████╗ ██████╗ ██████╗     ██╗  ██╗████████╗███╗   ███╗██╗
  //  ██╔══██╗██╔══██╗██╔════╝██╔═══██╗██╔══██╗██╔══██╗    ██║  ██║╚══██╔══╝████╗ ████║██║
  //  ███████║██████╔╝███████╗██║   ██║██████╔╝██████╔╝    ███████║   ██║   ██╔████╔██║██║
  //  ██╔══██║██╔══██╗╚════██║██║   ██║██╔══██╗██╔══██╗    ██╔══██║   ██║   ██║╚██╔╝██║██║
  //  ██║  ██║██████╔╝███████║╚██████╔╝██║  ██║██████╔╝    ██║  ██║   ██║   ██║ ╚═╝ ██║███████╗
  //  ╚═╝  ╚═╝╚═════╝ ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝     ╚═╝  ╚═╝   ╚═╝   ╚═╝     ╚═╝╚══════╝
  //
  //   █████╗ ████████╗████████╗██████╗ ██╗██████╗ ██╗   ██╗████████╗███████╗███████╗
  //  ██╔══██╗╚══██╔══╝╚══██╔══╝██╔══██╗██║██╔══██╗██║   ██║╚══██╔══╝██╔════╝██╔════╝
  //  ███████║   ██║      ██║   ██████╔╝██║██████╔╝██║   ██║   ██║   █████╗  ███████╗
  //  ██╔══██║   ██║      ██║   ██╔══██╗██║██╔══██╗██║   ██║   ██║   ██╔══╝  ╚════██║
  //  ██║  ██║   ██║      ██║   ██║  ██║██║██████╔╝╚██████╔╝   ██║   ███████╗███████║
  //  ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚══════╝
  //
  //  ███████╗██████╗  ██████╗ ███╗   ███╗      ██╗███████╗ ██████╗██████╗ ██╗██████╗ ████████╗██╗
  //  ██╔════╝██╔══██╗██╔═══██╗████╗ ████║     ██╔╝██╔════╝██╔════╝██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗
  //  █████╗  ██████╔╝██║   ██║██╔████╔██║    ██╔╝ ███████╗██║     ██████╔╝██║██████╔╝   ██║    ╚██╗
  //  ██╔══╝  ██╔══██╗██║   ██║██║╚██╔╝██║    ╚██╗ ╚════██║██║     ██╔══██╗██║██╔═══╝    ██║    ██╔╝
  //  ██║     ██║  ██║╚██████╔╝██║ ╚═╝ ██║     ╚██╗███████║╚██████╗██║  ██║██║██║        ██║   ██╔╝
  //  ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝      ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝╚═╝        ╚═╝   ╚═╝
  //
  //
  // If available, grab the DOM element for the script tag which imported this file.
  // (skip this if this SDK is being used outside of the DOM, i.e. in a Node process)
  //
  // This is used below to parse client-side sails.io.js configuration encoded as
  // HTML attributes, as well as grabbing hold of the URL from whence the SDK was fetched.
  var thisScriptTag = (function() {
    if (
      typeof window !== "object" ||
      typeof window.document !== "object" ||
      typeof window.document.getElementsByTagName !== "function"
    ) {
      return null;
    }

    // Return the URL of the last script loaded (i.e. this one)
    // (this must run before nextTick; see http://stackoverflow.com/a/2976714/486547)
    var allScriptsCurrentlyInDOM = window.document.getElementsByTagName(
      "script"
    );
    return allScriptsCurrentlyInDOM[allScriptsCurrentlyInDOM.length - 1];
  })();

  // Variables to contain src URL and other script tag config (for use below).
  var urlThisScriptWasFetchedFrom = "";
  var scriptTagConfig = {};

  if (thisScriptTag) {
    // Save the URL that this script was fetched from.
    urlThisScriptWasFetchedFrom = thisScriptTag.src;

    // Now parse the most common client-side configuration settings
    // from the script tag where they may be encoded as HTML attributes.
    //
    // Any configuration which may be provided as an HTML attribute may
    // also be provided prefixed with `data-`.  This is for folks who
    // need to support browsers that have issues with nonstandard
    // HTML attributes (or if the idea of using nonstandard HTML attributes
    // just creeps you out)
    //
    // If a `data-` prefixed attr is provided, it takes precedence.
    // (this is so that if you are already using one of these HTML
    //  attrs for some reason, you can keep it as-is and override
    //  it using `data-`. If you are using the `data-` prefixed version
    //  for some other purpose... well, in that case you'll just have to
    //  configure programmatically using `io.sails` instead.)
    CONFIGURABLE_VIA_HTML_ATTR.forEach(function(configKey) {
      scriptTagConfig[configKey] = (function() {
        // Support 'data-' prefixed or normal attributes.
        // (prefixed versions take precedence if provided)
        var htmlAttrVal = thisScriptTag.getAttribute("data-" + configKey);
        if (!htmlAttrVal) {
          htmlAttrVal = thisScriptTag.getAttribute(configKey);
        }

        // The HTML attribute value should always be a string or `null`.
        // We'll try to parse it as JSON and use that, but worst case fall back
        // to the default situation of it being a string.
        if (typeof htmlAttrVal === "string") {
          try {
            return JSON.parse(htmlAttrVal);
          } catch (e) {
            return htmlAttrVal;
          }
        }
        // If `null` was returned from getAttribute(), it means that the HTML attribute
        // was not specified, so we treat it as undefined (which will cause the property
        // to be removed below)
        else if (htmlAttrVal === null) {
          return undefined;
        }
        // Any other contingency shouldn't be possible:
        // - if no quotes are used in the HTML attribute, it still comes in as a string.
        // - if no RHS is provided for the attribute, it still comes in as "" (empty string)
        // (but we still handle this with an explicit error just in case--for debugging and support purposes)
        else
          throw new Error(
            "sails.io.js :: Unexpected/invalid script tag configuration for `" +
              configKey +
              "`: `" +
              htmlAttrVal +
              "` (a `" +
              typeof htmlAttrVal +
              "`). Should be a string."
          );
      })();

      if (scriptTagConfig[configKey] === undefined) {
        delete scriptTagConfig[configKey];
      }
    });

    // Now that they've been parsed, do an extremely lean version of
    // logical type validation/coercion of provided values.
    //////////////////////////////////////////////////////////////////

    // `autoConnect`
    if (typeof scriptTagConfig.autoConnect !== "undefined") {
      if (scriptTagConfig.autoConnect === "") {
        // Special case for empty string.  It means `true` (see above).
        scriptTagConfig.autoConnect = true;
      } else if (typeof scriptTagConfig.autoConnect !== "boolean") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `autoConnect` provided in script tag: `" +
            scriptTagConfig.autoConnect +
            "` (a `" +
            typeof scriptTagConfig.autoConnect +
            "`). Should be a boolean."
        );
      }
    }

    // `environment`
    if (typeof scriptTagConfig.environment !== "undefined") {
      if (typeof scriptTagConfig.environment !== "string") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `environment` provided in script tag: `" +
            scriptTagConfig.environment +
            "` (a `" +
            typeof scriptTagConfig.environment +
            "`). Should be a string."
        );
      }
    }

    // `headers`
    if (typeof scriptTagConfig.headers !== "undefined") {
      if (
        typeof scriptTagConfig.headers !== "object" ||
        Array.isArray(scriptTagConfig.headers)
      ) {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `headers` provided in script tag: `" +
            scriptTagConfig.headers +
            "` (a `" +
            typeof scriptTagConfig.headers +
            '`). Should be a JSON-compatible dictionary (i.e. `{}`).  Don\'t forget those double quotes (""), even on key names!  Use single quotes (\'\') to wrap the HTML attribute value; e.g. `headers=\'{"X-Auth": "foo"}\'`'
        );
      }
    }

    // `url`
    if (typeof scriptTagConfig.url !== "undefined") {
      if (typeof scriptTagConfig.url !== "string") {
        throw new Error(
          "sails.io.js :: Unexpected/invalid configuration for `url` provided in script tag: `" +
            scriptTagConfig.url +
            "` (a `" +
            typeof scriptTagConfig.url +
            "`). Should be a string."
        );
      }
    }

    // OTHER `io.sails` options are NOT CURRENTLY SUPPORTED VIA HTML ATTRIBUTES.
  }

  // Grab a reference to the global socket.io client (if one is available).
  // This is used via closure below to determine which `io` to use when the
  // socket.io client instance (`io`) is augmented to become the Sails client
  // SDK instance (still `io`).
  var _existingGlobalSocketIO = typeof io !== "undefined" ? io : undefined;

  //////////////////////////////////////////////////////////////
  /////
  ///// NOW FOR BUNCHES OF:
  /////  - PRIVATE FUNCTION DEFINITIONS
  /////  - CONSTRUCTORS
  /////  - AND METHODS
  /////
  //////////////////////////////////////////////////////////////
  //

  //  ███████╗ █████╗ ██╗██╗     ███████╗      ██╗ ██████╗        ██████╗██╗     ██╗███████╗███╗   ██╗████████╗
  //  ██╔════╝██╔══██╗██║██║     ██╔════╝      ██║██╔═══██╗      ██╔════╝██║     ██║██╔════╝████╗  ██║╚══██╔══╝
  //  ███████╗███████║██║██║     ███████╗█████╗██║██║   ██║█████╗██║     ██║     ██║█████╗  ██╔██╗ ██║   ██║
  //  ╚════██║██╔══██║██║██║     ╚════██║╚════╝██║██║   ██║╚════╝██║     ██║     ██║██╔══╝  ██║╚██╗██║   ██║
  //  ███████║██║  ██║██║███████╗███████║      ██║╚██████╔╝      ╚██████╗███████╗██║███████╗██║ ╚████║   ██║
  //  ╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚══════╝      ╚═╝ ╚═════╝        ╚═════╝╚══════╝╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝
  //

  /**
   * SailsIOClient()
   *
   * Augment the provided Socket.io client object (`io`) with methods for
   * talking and listening to one or more Sails backend(s).  If no `io` was
   * provided (i.e. in a browser setting), then attempt to use the global.
   *
   * This absorbs implicit `io.sails` configuration, sets a timer for
   * automatically connecting a socket (if `io.sails.autoConnect` is enabled)
   * and returns the augmented `io`.
   *
   * Note:
   * The automatically-connected socket is exposed as `io.socket`.  If this
   * socket attempts to bind event listeners or send requests before it is
   * connected, it will be queued up and replayed when the connection is
   * successfully opened.
   *
   * @param {SocketIO} io
   * @returns {SailsIOClient} [also called `io`]
   */

  function SailsIOClient(_providedSocketIO) {
    // First, determine which `io` we're augmenting.
    //
    // Prefer the passed-in `io` instance, but fall back to the
    // global one if we've got it.
    var io;
    if (_providedSocketIO) {
      io = _providedSocketIO;
    } else {
      io = _existingGlobalSocketIO;
    }
    // (note that for readability, we deliberately do not short circuit or use the tertiary operator above)

    // If a socket.io client (`io`) is not available, none of this will work.
    if (!io) {
      // If node:
      if (SDK_INFO.platform === "node") {
        throw new Error(
          "No socket.io client available.  When requiring `sails.io.js` from Node.js, a socket.io client (`io`) must be passed in; e.g.:\n```\nvar io = require('sails.io.js')( require('socket.io-client') )\n```\n(see https://github.com/balderdashy/sails.io.js/tree/master/test for more examples)"
        );
      }
      // Otherwise, this is a web browser:
      else {
        throw new Error(
          "The Sails socket SDK depends on the socket.io client, but the socket.io global (`io`) was not available when `sails.io.js` loaded.  Normally, the socket.io client code is bundled with sails.io.js, so something is a little off.  Please check to be sure this version of `sails.io.js` has the minified Socket.io client at the top of the file."
        );
      }
    }

    // If the chosen socket.io client (`io`) has ALREADY BEEN AUGMENTED by this SDK,
    // (i.e. if it already has a `.sails` property) then throw an error.
    if (io.sails) {
      // If node:
      if (SDK_INFO.platform === "node") {
        throw new Error(
          "The provided socket.io client (`io`) has already been augmented into a Sails socket SDK instance (it has `io.sails`)."
        );
      }
      // Otherwise, this is a web browser:
      else {
        throw new Error(
          "The socket.io client (`io`) has already been augmented into a Sails socket SDK instance.  Usually, this means you are bringing `sails.io.js` onto the page more than once."
        );
      }
    }

    /**
     * A little logger for this library to use internally.
     * Basically just a wrapper around `console.log` with
     * support for feature-detection.
     *
     * @api private
     * @factory
     */
    function LoggerFactory(options) {
      options = options || {
        prefix: true
      };

      // If `console.log` is not accessible, `log` is a noop.
      if (
        typeof console !== "object" ||
        typeof console.log !== "function" ||
        typeof console.log.bind !== "function"
      ) {
        return function noop() {};
      }

      return function log() {
        var args = Array.prototype.slice.call(arguments);

        // All logs are disabled when `io.sails.environment = 'production'`.
        if (io.sails.environment === "production") return;

        // Add prefix to log messages (unless disabled)
        var PREFIX = "";
        if (options.prefix) {
          args.unshift(PREFIX);
        }

        // Call wrapped logger
        console.log.bind(console).apply(this, args);
      };
    } //</LoggerFactory>

    // Create a private logger instance
    var consolog = LoggerFactory();
    consolog.noPrefix = LoggerFactory({
      prefix: false
    });

    /**
     * What is the `requestQueue`?
     *
     * The request queue is used to simplify app-level connection logic--
     * i.e. so you don't have to wait for the socket to be connected
     * to start trying to  synchronize data.
     *
     * @api private
     * @param  {SailsSocket}  socket
     */

    function runRequestQueue(socket) {
      var queue = socket.requestQueue;

      if (!queue) return;
      for (var i in queue) {
        // Double-check that `queue[i]` will not
        // inadvertently discover extra properties attached to the Object
        // and/or Array prototype by other libraries/frameworks/tools.
        // (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)
        var isSafeToDereference = {}.hasOwnProperty.call(queue, i);
        if (isSafeToDereference) {
          // Get the arguments that were originally made to the "request" method
          var requestArgs = queue[i];
          // Call the request method again in the context of the socket, with the original args
          socket.request.apply(socket, requestArgs);
        }
      }

      // Now empty the queue to remove it as a source of additional complexity.
      socket.requestQueue = null;
    }

    /**
     * Send a JSONP request.
     *
     * @param  {Object}   opts [optional]
     * @param  {Function} cb
     * @return {XMLHttpRequest}
     */

    function jsonp(opts, cb) {
      opts = opts || {};

      if (typeof window === "undefined") {
        // FUTURE: refactor node usage to live in here
        return cb();
      }

      var scriptEl = document.createElement("script");
      window._sailsIoJSConnect = function(response) {
        // In rare circumstances our script may have been vaporised.
        // Remove it, but only if it still exists
        // https://github.com/balderdashy/sails.io.js/issues/92
        if (scriptEl && scriptEl.parentNode) {
          scriptEl.parentNode.removeChild(scriptEl);
        }

        cb(response);
      };
      scriptEl.src = opts.url;
      document.getElementsByTagName("head")[0].appendChild(scriptEl);
    }

    //       ██╗███████╗ ██████╗ ███╗   ██╗      ██╗    ██╗███████╗██████╗ ███████╗ ██████╗  ██████╗██╗  ██╗███████╗████████╗
    //       ██║██╔════╝██╔═══██╗████╗  ██║      ██║    ██║██╔════╝██╔══██╗██╔════╝██╔═══██╗██╔════╝██║ ██╔╝██╔════╝╚══██╔══╝
    //       ██║███████╗██║   ██║██╔██╗ ██║█████╗██║ █╗ ██║█████╗  ██████╔╝███████╗██║   ██║██║     █████╔╝ █████╗     ██║
    //  ██   ██║╚════██║██║   ██║██║╚██╗██║╚════╝██║███╗██║██╔══╝  ██╔══██╗╚════██║██║   ██║██║     ██╔═██╗ ██╔══╝     ██║
    //  ╚█████╔╝███████║╚██████╔╝██║ ╚████║      ╚███╔███╔╝███████╗██████╔╝███████║╚██████╔╝╚██████╗██║  ██╗███████╗   ██║
    //   ╚════╝ ╚══════╝ ╚═════╝ ╚═╝  ╚═══╝       ╚══╝╚══╝ ╚══════╝╚═════╝ ╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝
    //
    //  ██████╗ ███████╗███████╗██████╗  ██████╗ ███╗   ██╗███████╗███████╗     ██╗     ██╗██╗    ██╗██████╗ ██╗
    //  ██╔══██╗██╔════╝██╔════╝██╔══██╗██╔═══██╗████╗  ██║██╔════╝██╔════╝    ██╔╝     ██║██║    ██║██╔══██╗╚██╗
    //  ██████╔╝█████╗  ███████╗██████╔╝██║   ██║██╔██╗ ██║███████╗█████╗      ██║      ██║██║ █╗ ██║██████╔╝ ██║
    //  ██╔══██╗██╔══╝  ╚════██║██╔═══╝ ██║   ██║██║╚██╗██║╚════██║██╔══╝      ██║ ██   ██║██║███╗██║██╔══██╗ ██║
    //  ██║  ██║███████╗███████║██║     ╚██████╔╝██║ ╚████║███████║███████╗    ╚██╗╚█████╔╝╚███╔███╔╝██║  ██║██╔╝
    //  ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝      ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚══════╝     ╚═╝ ╚════╝  ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝
    //

    /**
     * The JWR (JSON WebSocket Response) received from a Sails server.
     *
     * @api public
     * @param  {Object}  responseCtx
     *         => :body
     *         => :statusCode
     *         => :headers
     *
     * @constructor
     */

    function JWR(responseCtx) {
      this.body = responseCtx.body;
      this.headers = responseCtx.headers || {};
      this.statusCode =
        typeof responseCtx.statusCode === "undefined"
          ? 200
          : responseCtx.statusCode;
      // FUTURE: Replace this typeof short-circuit with an assertion (statusCode should always be set)

      if (this.statusCode < 200 || this.statusCode >= 400) {
        // Determine the appropriate error message.
        var msg;
        if (this.statusCode === 0) {
          msg = "The socket request failed.";
        } else {
          msg = "Server responded with a " + this.statusCode + " status code";
          msg += ":\n```\n" + JSON.stringify(this.body, null, 2) + "\n```";
          // (^^Note that we should always be able to rely on socket.io to give us
          // non-circular data here, so we don't have to worry about wrapping the
          // above in a try...catch)
        }

        // Now build and attach Error instance.
        this.error = new Error(msg);
      }
    }
    JWR.prototype.toString = function() {
      return (
        "[ResponseFromSails]" +
        "  -- " +
        "Status: " +
        this.statusCode +
        "  -- " +
        "Headers: " +
        this.headers +
        "  -- " +
        "Body: " +
        this.body
      );
    };
    JWR.prototype.toPOJO = function() {
      return {
        body: this.body,
        headers: this.headers,
        statusCode: this.statusCode
      };
    };
    JWR.prototype.pipe = function() {
      // FUTURE: look at substack's stuff
      return new Error("Client-side streaming support not implemented yet.");
    };

    //          ███████╗███╗   ███╗██╗████████╗███████╗██████╗  ██████╗ ███╗   ███╗ ██╗██╗
    //          ██╔════╝████╗ ████║██║╚══██╔══╝██╔════╝██╔══██╗██╔═══██╗████╗ ████║██╔╝╚██╗
    //          █████╗  ██╔████╔██║██║   ██║   █████╗  ██████╔╝██║   ██║██╔████╔██║██║  ██║
    //          ██╔══╝  ██║╚██╔╝██║██║   ██║   ██╔══╝  ██╔══██╗██║   ██║██║╚██╔╝██║██║  ██║
    //  ███████╗███████╗██║ ╚═╝ ██║██║   ██║   ██║     ██║  ██║╚██████╔╝██║ ╚═╝ ██║╚██╗██╔╝
    //  ╚══════╝╚══════╝╚═╝     ╚═╝╚═╝   ╚═╝   ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝ ╚═╝╚═╝
    //

    /**
     * @api private
     * @param  {SailsSocket} socket  [description]
     * @param  {Object} requestCtx [description]
     */

    function _emitFrom(socket, requestCtx) {
      if (!socket._raw) {
        throw new Error(
          "Failed to emit from socket- raw SIO socket is missing."
        );
      }

      // Since callback is embedded in requestCtx,
      // retrieve it and delete the key before continuing.
      var cb = requestCtx.cb;
      delete requestCtx.cb;

      // Name of the appropriate socket.io listener on the server
      // ( === the request method or "verb", e.g. 'get', 'post', 'put', etc. )
      var sailsEndpoint = requestCtx.method;

      socket._raw.emit(sailsEndpoint, requestCtx, function serverResponded(
        responseCtx
      ) {
        // Send back (emulatedHTTPBody, jsonWebSocketResponse)
        if (cb && !requestCtx.calledCb) {
          cb(responseCtx.body, new JWR(responseCtx));
          // Set flag indicating that callback was called, to avoid duplicate calls.
          requestCtx.calledCb = true;
          // Remove the callback from the list.
          socket._responseCbs.splice(socket._responseCbs.indexOf(cb), 1);
          // Remove the context from the list.
          socket._requestCtxs.splice(
            socket._requestCtxs.indexOf(requestCtx),
            1
          );
        }
      });
    }

    //  ███████╗ █████╗ ██╗██╗     ███████╗███████╗ ██████╗  ██████╗██╗  ██╗███████╗████████╗
    //  ██╔════╝██╔══██╗██║██║     ██╔════╝██╔════╝██╔═══██╗██╔════╝██║ ██╔╝██╔════╝╚══██╔══╝
    //  ███████╗███████║██║██║     ███████╗███████╗██║   ██║██║     █████╔╝ █████╗     ██║
    //  ╚════██║██╔══██║██║██║     ╚════██║╚════██║██║   ██║██║     ██╔═██╗ ██╔══╝     ██║
    //  ███████║██║  ██║██║███████╗███████║███████║╚██████╔╝╚██████╗██║  ██╗███████╗   ██║
    //  ╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚══════╝╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝
    //

    /**
     * SailsSocket
     *
     * A wrapper for an underlying Socket instance that communicates directly
     * to the Socket.io server running inside of Sails.
     *
     * If no `socket` option is provied, SailsSocket will function as a mock. It will queue socket
     * requests and event handler bindings, replaying them when the raw underlying socket actually
     * connects. This is handy when we don't necessarily have the valid configuration to know
     * WHICH SERVER to talk to yet, etc.  It is also used by `io.socket` for your convenience.
     *
     * @constructor
     * @api private
     *
     * ----------------------------------------------------------------------
     * Note: This constructor should not be used directly. To obtain a `SailsSocket`
     * instance of your very own, run:
     * ```
     * var mySocket = io.sails.connect();
     * ```
     * ----------------------------------------------------------------------
     */
    function SailsSocket(opts) {
      var self = this;
      opts = opts || {};

      // Initialize private properties
      self._isConnecting = false;
      self._mightBeAboutToAutoConnect = false;

      // Set up connection options so that they can only be changed when socket is disconnected.
      var _opts = {};
      SOCKET_OPTIONS.forEach(function(option) {
        // Okay to change global headers while socket is connected
        if (option == "headers") {
          return;
        }
        Object.defineProperty(self, option, {
          get: function() {
            if (option == "url") {
              return (
                _opts[option] || (self._raw && self._raw.io && self._raw.io.uri)
              );
            }
            return _opts[option];
          },
          set: function(value) {
            // Don't allow value to be changed while socket is connected
            if (
              self.isConnected() &&
              io.sails.strict !== false &&
              value != _opts[option]
            ) {
              throw new Error(
                "Cannot change value of `" +
                  option +
                  "` while socket is connected."
              );
            }
            // If socket is attempting to reconnect, stop it.
            if (
              self._raw &&
              self._raw.io &&
              self._raw.io.reconnecting &&
              !self._raw.io.skipReconnect
            ) {
              self._raw.io.skipReconnect = true;
              consolog(
                "Stopping reconnect; use .reconnect() to connect socket after changing options."
              );
            }
            _opts[option] = value;
          }
        });
      });

      // Absorb opts into SailsSocket instance
      // See http://sailsjs.com/documentation/reference/web-sockets/socket-client/sails-socket/properties
      // for description of options
      SOCKET_OPTIONS.forEach(function(option) {
        self[option] = opts[option];
      });

      // Set up "eventQueue" to hold event handlers which have not been set on the actual raw socket yet.
      self.eventQueue = {};

      // Listen for special `parseError` event sent from sockets hook on the backend
      // if an error occurs but a valid callback was not received from the client
      // (i.e. so the server had no other way to send back the error information)
      self.on("sails:parseError", function(err) {
        consolog(
          "Sails encountered an error parsing a socket message sent from this client, and did not have access to a callback function to respond with."
        );
        consolog("Error details:", err);
      });

      // FUTURE:
      // Listen for a special private message on any connected that allows the server
      // to set the environment (giving us 100% certainty that we guessed right)
      // However, note that the `console.log`s called before and after connection
      // are still forced to rely on our existing heuristics (to disable, tack #production
      // onto the URL used to fetch this file.)
    } //</SailsSocket>

    /**
     * `SailsSocket.prototype._connect()`
     *
     * Begin connecting this socket to the server.
     *
     * @api private
     */
    SailsSocket.prototype._connect = function() {
      var self = this;

      self._isConnecting = true;

      // Apply `io.sails` config as defaults
      // (now that at least one tick has elapsed)
      // See http://sailsjs.com/documentation/reference/web-sockets/socket-client/sails-socket/properties
      // for description of options and default values
      SOCKET_OPTIONS.forEach(function(option) {
        if ("undefined" == typeof self[option]) {
          self[option] = io.sails[option];
        }
      });

      // Headers that will be sent with the initial request to /socket.io (Node.js only)
      self.extraHeaders = self.initialConnectionHeaders || {};

      // For browser usage (currently works with "polling" transport only)
      self.transportOptions = self.transportOptions || {};
      self.transports.forEach(function(transport) {
        self.transportOptions[transport] =
          self.transportOptions[transport] || {};
        self.transportOptions[transport].extraHeaders =
          self.initialConnectionHeaders || {};
      });

      // Log a warning if non-Node.js platform attempts to use `initialConnectionHeaders` for anything other than `polling`.
      if (
        (self.initialConnectionHeaders &&
          SDK_INFO.platform !== "node" &&
          self.transports.indexOf("polling") === -1) ||
        self.transports.length > 1
      ) {
        if (typeof console === "object" && typeof console.warn === "function") {
          console.warn(
            "When running in browser, `initialConnectionHeaders` option is only available for the `polling` transport."
          );
        }
      }

      // Ensure URL has no trailing slash
      self.url = self.url ? self.url.replace(/(\/)$/, "") : undefined;

      // Mix the current SDK version into the query string in
      // the connection request to the server:
      if (typeof self.query === "string") {
        // (If provided as a string, trim leading question mark,
        // just in case one was provided.)
        self.query = self.query.replace(/^\?/, "");
        self.query += "&" + SDK_INFO.versionString;
      } else if (self.query && typeof self.query === "object") {
        throw new Error(
          "`query` setting does not currently support configuration as a dictionary (`{}`).  Instead, it must be specified as a string like `foo=89&bar=hi`"
        );
      } else if (!self.query) {
        self.query = SDK_INFO.versionString;
      } else {
        throw new Error(
          "Unexpected data type provided for `query` setting: " + self.query
        );
      }

      // Determine whether this is a cross-origin socket by examining the
      // hostname and port on the `window.location` object.  If it's cross-origin,
      // we'll attempt to get a cookie for the domain so that a Sails session can
      // be established.
      var isXOrigin = (function() {
        // If `window` doesn't exist (i.e. being used from Node.js), then
        // we won't bother attempting to get a cookie.  If you're using sockets
        // from Node.js and find you need to share a session between multiple
        // socket connections, you'll need to make an HTTP request to the /__getcookie
        // endpoint of the Sails server (or any endpoint that returns a set-cookie header)
        // and then use the cookie value in the `initialConnectionHeaders` option to
        // io.sails.connect()
        if (
          typeof window === "undefined" ||
          typeof window.location === "undefined"
        ) {
          return false;
        }

        // If `self.url` (aka "target") is falsy, then we don't need to worry about it.
        if (typeof self.url !== "string") {
          return false;
        }

        // Get information about the "target" (`self.url`)
        var targetProtocol = (function() {
          try {
            targetProtocol = self.url.match(/^([a-z]+:\/\/)/i)[1].toLowerCase();
          } catch (e) {}
          targetProtocol = targetProtocol || "http://";
          return targetProtocol;
        })();
        var isTargetSSL = !!self.url.match("^https");
        var targetPort = (function() {
          try {
            return self.url.match(/^[a-z]+:\/\/[^:]*:([0-9]*)/i)[1];
          } catch (e) {}
          return isTargetSSL ? "443" : "80";
        })();
        var targetAfterProtocol = self.url.replace(/^([a-z]+:\/\/)/i, "");

        // If target protocol is different than the actual protocol,
        // then we'll consider this cross-origin.
        if (
          targetProtocol.replace(/[:\/]/g, "") !==
          window.location.protocol.replace(/[:\/]/g, "")
        ) {
          return true;
        }

        // If target hostname is different than actual hostname, we'll consider this cross-origin.
        var hasSameHostname =
          targetAfterProtocol.search(window.location.hostname) === 0;
        if (!hasSameHostname) {
          return true;
        }

        // If no actual port is explicitly set on the `window.location` object,
        // we'll assume either 80 or 443.
        var isLocationSSL = window.location.protocol.match(/https/i);
        var locationPort =
          window.location.port + "" || (isLocationSSL ? "443" : "80");

        // Finally, if ports don't match, we'll consider this cross-origin.
        if (targetPort !== locationPort) {
          return true;
        }

        // Otherwise, it's the same origin.
        return false;
      })();

      // Prepare to start connecting the socket
      (function selfInvoking(cb) {
        // If this is an attempt at a cross-origin or cross-port
        // socket connection via a browswe, send a JSONP request
        // first to ensure that a valid cookie is available.
        // This can be disabled by setting `io.sails.useCORSRouteToGetCookie`
        // to false.
        //
        // Otherwise, skip the stuff below.
        //
        if (!(self.useCORSRouteToGetCookie && isXOrigin)) {
          return cb();
        }

        // Figure out the x-origin CORS route
        // (Sails provides a default)
        var xOriginCookieURL = self.url;
        if (typeof self.useCORSRouteToGetCookie === "string") {
          xOriginCookieURL += self.useCORSRouteToGetCookie;
        } else {
          xOriginCookieURL += "/__getcookie";
        }

        // Make the AJAX request (CORS)
        jsonp(
          {
            url: xOriginCookieURL,
            method: "GET"
          },
          cb
        );
      })(function goAheadAndActuallyConnect() {
        // Now that we're ready to connect, create a raw underlying Socket
        // using Socket.io and save it as `_raw` (this will start it connecting)
        self._raw = io(self.url, self);

        // If the low-level transport throws an error _while connecting_, then set the _isConnecting flag
        // to false (since we're no longer connecting with any chance of success anyway).
        // Also, in this case (and in dev mode only) log a helpful message.
        self._raw.io.engine.transport.on("error", function(err) {
          if (!self._isConnecting) {
            return;
          }

          self._isConnecting = false;

          // Track this timestamp for use in reconnection messages
          // (only relevant if reconnection is enabled.)
          self.connectionErrorTimestamp = new Date().getTime();

          // Development-only message:
          consolog("====================================");
          consolog("The socket was unable to connect.");
          consolog("The server may be offline, or the");
          consolog("socket may have failed authorization");
          consolog("based on its origin or other factors.");
          consolog("You may want to check the values of");
          consolog("`sails.config.sockets.onlyAllowOrigins`");
          consolog("or (more rarely) `sails.config.sockets.beforeConnect`");
          consolog("in your app.");
          consolog("More info: https://sailsjs.com/config/sockets");
          consolog("For help: https://sailsjs.com/support");
          consolog("");
          consolog("Technical details:");
          consolog(err);
          consolog("====================================");
        });

        // Replay event bindings from the eager socket
        self.replay();

        /**
         * 'connect' event is triggered when the socket establishes a connection
         *  successfully.
         */
        self.on("connect", function socketConnected() {
          self._isConnecting = false;
          consolog.noPrefix(
            "\n" +
              "\n" +
              // '    |>    ' + '\n' +
              // '  \\___/  '+️
              // '\n'+
              "  |>    Now connected to " +
              (self.url ? self.url : "Sails") +
              "." +
              "\n" +
              "\\___/   For help, see: http://bit.ly/2q0QDpf" +
              "\n" +
              "        (using sails.io.js " +
              io.sails.sdk.platform +
              " SDK @v" +
              io.sails.sdk.version +
              ")" +
              "\n" +
              "         Connected at: " +
              new Date() +
              "\n" +
              "\n" +
              "\n" +
              // '\n'+
              ""
            // ' ⚓︎ (development mode)'
            // 'e.g. to send a GET request to Sails via WebSockets, run:'+ '\n' +
            // '`io.socket.get("/foo", function serverRespondedWith (body, jwr) { console.log(body); })`'+ '\n' +
          );
        });

        self.on("disconnect", function() {
          // Get a timestamp of when the disconnect was detected.
          self.connectionLostTimestamp = new Date().getTime();

          // Get a shallow clone of the internal array of response callbacks, in case any of the callbacks mutate it.
          var responseCbs = [].concat(self._responseCbs || []);
          // Wipe the internal array of response callbacks before executing them, in case a callback happens to add
          // a new request to the queue.
          self._responseCbs = [];

          // Do the same for the internal request context list.
          var requestCtxs = [].concat(self._requestCtxs || []);
          self._requestCtxs = [];

          // Loop through the callbacks for all in-progress requests, and call them each with an error indicating the disconnect.
          if (responseCbs.length) {
            responseCbs.forEach(function(responseCb) {
              responseCb(
                new Error(
                  "The socket disconnected before the request completed."
                ),
                {
                  body: null,
                  statusCode: 0,
                  headers: {}
                }
              );
            });
          }

          // If there is a list of request contexts, indicate that their callbacks have been
          // called and then wipe the list.  This prevents errors in the edge case of a response
          // somehow coming back after the socket reconnects.
          if (requestCtxs.length) {
            requestCtxs.forEach(function(requestCtx) {
              requestCtx.calledCb = true;
            });
          }

          consolog("====================================");
          consolog("Socket was disconnected from Sails.");
          consolog(
            "Usually, this is due to one of the following reasons:" +
              "\n" +
              " -> the server " +
              (self.url ? self.url + " " : "") +
              "was taken down" +
              "\n" +
              " -> your browser lost internet connectivity"
          );
          consolog("====================================");
        });

        self.on("reconnecting", function(numAttempts) {
          consolog(
            "\n" +
              "        Socket is trying to reconnect to " +
              (self.url ? self.url : "Sails") +
              "...\n" +
              "_-|>_-  (attempt #" +
              numAttempts +
              ")" +
              "\n" +
              "\n"
          );
        });

        self.on("reconnect", function(transport, numAttempts) {
          if (!self._isConnecting) {
            self.on("connect", runRequestQueue.bind(self, self));
          }

          var msSinceLastOffline;
          var numSecsOffline;
          if (self.connectionLostTimestamp) {
            msSinceLastOffline =
              new Date().getTime() - self.connectionLostTimestamp;
            numSecsOffline = msSinceLastOffline / 1000;
          } else if (self.connectionErrorTimestamp) {
            msSinceLastOffline =
              new Date().getTime() - self.connectionErrorTimestamp;
            numSecsOffline = msSinceLastOffline / 1000;
          } else {
            msSinceLastOffline = "???";
            numSecsOffline = "???";
          }

          consolog(
            "\n" +
              "  |>    Socket reconnected successfully after" +
              "\n" +
              "\\___/   being offline at least " +
              numSecsOffline +
              " seconds." +
              "\n" +
              "\n"
          );
        });

        // 'error' event is triggered if connection can not be established.
        // (usually because of a failed authorization, which is in turn
        // usually due to a missing or invalid cookie)
        self.on("error", function failedToConnect(err) {
          self._isConnecting = false;
          ////////////////////////////////////////////////////////////////////////////////////
          // Note:
          // In the future, we could provide a separate event for when a socket cannot connect
          // due to a failed `beforeConnect` (aka "authorization" if you're old school).
          // this could probably be implemented by emitting a special event from the server.
          ////////////////////////////////////////////////////////////////////////////////////

          consolog(
            "Failed to connect socket (possibly due to failed `beforeConnect` on server)",
            "Error:",
            err
          );
        });
      });
    };

    /**
     * Reconnect the underlying socket.
     *
     * @api public
     */
    SailsSocket.prototype.reconnect = function() {
      if (this._isConnecting) {
        throw new Error("Cannot connect- socket is already connecting");
      }
      if (this.isConnected()) {
        throw new Error("Cannot connect- socket is already connected");
      }
      return this._connect();
    };

    /**
     * Disconnect the underlying socket.
     *
     * @api public
     */
    SailsSocket.prototype.disconnect = function() {
      this._isConnecting = false;
      if (!this.isConnected()) {
        throw new Error("Cannot disconnect- socket is already disconnected");
      }
      return this._raw.disconnect();
    };

    /**
     * isConnected
     *
     * @return {Boolean} whether the socket is connected and able to
     *                   communicate w/ the server.
     */

    SailsSocket.prototype.isConnected = function() {
      if (!this._raw) {
        return false;
      }

      return !!this._raw.connected;
    };

    /**
     * isConnecting
     *
     * @return {Boolean} whether the socket is in the process of connecting
     *                   to the server.
     */

    SailsSocket.prototype.isConnecting = function() {
      return this._isConnecting;
    };

    /**
     * isConnecting
     *
     * @return {Boolean} flag that is `true` after a SailsSocket instance is
     *                   initialized but before one tick of the event loop
     *                   has passed (so that it hasn't attempted to connect
     *                   yet, if autoConnect ends up being configured `true`)
     */
    SailsSocket.prototype.mightBeAboutToAutoConnect = function() {
      return this._mightBeAboutToAutoConnect;
    };

    /**
     * [replay description]
     * @return {[type]} [description]
     */
    SailsSocket.prototype.replay = function() {
      var self = this;

      // Pass events and a reference to the request queue
      // off to the self._raw for consumption
      for (var evName in self.eventQueue) {
        for (var i in self.eventQueue[evName]) {
          self._raw.on(evName, self.eventQueue[evName][i]);
        }
      }

      // Bind a one-time function to run the request queue
      // when the self._raw connects.
      if (!self.isConnected()) {
        self._raw.once("connect", runRequestQueue.bind(self, self));
      }
      // Or run it immediately if self._raw is already connected
      else {
        runRequestQueue(self);
      }

      return self;
    };

    /**
     * Chainable method to bind an event to the socket.
     *
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.on = function(evName, fn) {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.on(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (!this.eventQueue[evName]) {
        this.eventQueue[evName] = [fn];
      } else {
        this.eventQueue[evName].push(fn);
      }

      return this;
    };

    /**
     * Chainable method to unbind an event from the socket.
     *
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.off = function(evName, fn) {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.off(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (this.eventQueue[evName] && this.eventQueue[evName].indexOf(fn) > -1) {
        this.eventQueue[evName].splice(this.eventQueue[evName].indexOf(fn), 1);
      }

      return this;
    };

    /**
     * Chainable method to unbind all events from the socket.
     *
     * @return {SailsSocket}
     */
    SailsSocket.prototype.removeAllListeners = function() {
      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.removeAllListeners();
        return this;
      }

      // Otherwise queue the event binding.
      this.eventQueue = {};

      return this;
    };

    /**
     * Simulate a GET request to sails
     * e.g.
     *    `socket.get('/user/3', Stats.populate)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.get = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "get",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a POST request to sails
     * e.g.
     *    `socket.post('/event', newMeeting, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.post = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "post",
          data: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a PUT request to sails
     * e.g.
     *    `socket.post('/event/3', changedFields, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.put = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "put",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a PATCH request to sails
     * e.g.
     *    `socket.patch('/event/3', changedFields, $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.patch = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "patch",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate a DELETE request to sails
     * e.g.
     *    `socket.delete('/event', $spinner.hide)`
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} data   ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype["delete"] = function(url, data, cb) {
      // `data` is optional
      if (typeof data === "function") {
        cb = data;
        data = {};
      }

      return this.request(
        {
          method: "delete",
          params: data,
          url: url
        },
        cb
      );
    };

    /**
     * Simulate an HTTP request to sails
     * e.g.
     * ```
     * socket.request({
     *   url:'/user',
     *   params: {},
     *   method: 'POST',
     *   headers: {}
     * }, function (responseBody, JWR) {
     *   // ...
     * });
     * ```
     *
     * @api public
     * @option {String} url    ::    destination URL
     * @option {Object} params ::    parameters to send with the request [optional]
     * @option {Object} headers::    headers to send with the request [optional]
     * @option {Function} cb   ::    callback function to call when finished [optional]
     * @option {String} method ::    HTTP request method [optional]
     */

    SailsSocket.prototype.request = function(options, cb) {
      var usage =
        "Usage:\n" +
        "socket.request( options, [fnToCallWhenComplete] )\n\n" +
        'options.url :: e.g. "/foo/bar"' +
        "\n" +
        'options.method :: e.g. "get", "post", "put", or "delete", etc.' +
        "\n" +
        'options.params :: e.g. { emailAddress: "mike@example.com" }' +
        "\n" +
        'options.headers :: e.g. { "x-my-custom-header": "some string" }';
      // Old usage:
      // var usage = 'Usage:\n socket.'+(options.method||'request')+'('+
      //   ' destinationURL, [dataToSend], [fnToCallWhenComplete] )';

      // Validate options and callback
      if (typeof cb !== "undefined" && typeof cb !== "function") {
        throw new Error("Invalid callback function!\n" + usage);
      }
      if (typeof options !== "object" || typeof options.url !== "string") {
        throw new Error("Invalid or missing URL!\n" + usage);
      }
      if (options.method && typeof options.method !== "string") {
        throw new Error(
          'Invalid `method` provided (should be a string like "post" or "put")\n' +
            usage
        );
      }
      if (options.headers && typeof options.headers !== "object") {
        throw new Error(
          "Invalid `headers` provided (should be a dictionary with string values)\n" +
            usage
        );
      }
      if (options.params && typeof options.params !== "object") {
        throw new Error(
          "Invalid `params` provided (should be a dictionary with JSON-serializable values)\n" +
            usage
        );
      }
      if (options.data && typeof options.data !== "object") {
        throw new Error(
          "Invalid `data` provided (should be a dictionary with JSON-serializable values)\n" +
            usage
        );
      }

      // Accept either `params` or `data` for backwards compatibility (but not both!)
      if (options.data && options.params) {
        throw new Error(
          "Cannot specify both `params` and `data`!  They are aliases of each other.\n" +
            usage
        );
      } else if (options.data) {
        options.params = options.data;
        delete options.data;
      }

      // If this socket is not connected yet, queue up this request
      // instead of sending it.
      // (so it can be replayed when the socket comes online.)
      if (!this.isConnected()) {
        // If no queue array exists for this socket yet, create it.
        this.requestQueue = this.requestQueue || [];
        this.requestQueue.push([options, cb]);
        return;
      }

      // Otherwise, our socket is connected, so continue prepping
      // the request.

      // Default headers to an empty object
      options.headers = options.headers || {};

      // Build a simulated request object
      // (and sanitize/marshal options along the way)
      var requestCtx = {
        method: (options.method || "get").toLowerCase(),

        headers: options.headers,

        data: options.params || options.data || {},

        // Remove trailing slashes and spaces to make packets smaller.
        url: options.url.replace(/^(.+)\/*\s*$/, "$1"),

        cb: cb
      };

      // Get a reference to the callback list, or create a new one.
      this._responseCbs = this._responseCbs || [];

      // Get a reference to the request context list, or create a new one.
      this._requestCtxs = this._requestCtxs || [];

      // Add this callback to the list.  If the socket disconnects, we'll call
      // each cb in the list with an error and reset the list.  Otherwise the
      // cb will be removed from the list when the server responds.
      // Also add the request context to the list.  It will be removed once
      // the response comes back, or if the socket disconnects.
      if (cb) {
        this._responseCbs.push(cb);
        this._requestCtxs.push(requestCtx);
      }

      // Merge global headers in, if there are any.
      if (this.headers && "object" === typeof this.headers) {
        for (var header in this.headers) {
          if (!options.headers.hasOwnProperty(header)) {
            options.headers[header] = this.headers[header];
          }
        }
      }

      // Send the request.
      _emitFrom(this, requestCtx);
    };

    /**
     * Socket.prototype._request
     *
     * Simulate HTTP over Socket.io.
     *
     * @api private
     * @param  {[type]}   options [description]
     * @param  {Function} cb      [description]
     */
    SailsSocket.prototype._request = function(options, cb) {
      throw new Error(
        "`_request()` was a private API deprecated as of v0.11 of the sails.io.js client. Use `.request()` instead."
      );
    };

    //  ██╗ ██████╗    ███████╗ █████╗ ██╗██╗     ███████╗
    //  ██║██╔═══██╗   ██╔════╝██╔══██╗██║██║     ██╔════╝
    //  ██║██║   ██║   ███████╗███████║██║██║     ███████╗
    //  ██║██║   ██║   ╚════██║██╔══██║██║██║     ╚════██║
    //  ██║╚██████╔╝██╗███████║██║  ██║██║███████╗███████║
    //  ╚═╝ ╚═════╝ ╚═╝╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚══════╝
    //
    // Set an `io.sails` object that may be used for configuration before the
    // first socket connects (i.e. to allow auto-connect behavior to be
    // prevented by setting `io.sails.autoConnect` in an inline script
    // directly after the script tag which loaded this file).

    //  ┌─┐┌─┐┌┬┐  ┬ ┬┌─┐  ╔╦╗╔═╗╔═╗╔═╗╦ ╦╦ ╔╦╗╔═╗  ┌─┐┌─┐┬─┐  ┬┌─┐ ┌─┐┌─┐┬┬  ┌─┐
    //  └─┐├┤  │   │ │├─┘   ║║║╣ ╠╣ ╠═╣║ ║║  ║ ╚═╗  ├┤ │ │├┬┘  ││ │ └─┐├─┤││  └─┐
    //  └─┘└─┘ ┴   └─┘┴    ═╩╝╚═╝╚  ╩ ╩╚═╝╩═╝╩ ╚═╝  └  └─┘┴└─  ┴└─┘o└─┘┴ ┴┴┴─┘└─┘
    io.sails = {
      // Whether to automatically connect a socket and save it as `io.socket`.
      autoConnect: true,

      // Whether to automatically try to reconnect after connection is lost
      reconnection: false,

      // The route (path) to hit to get a x-origin (CORS) cookie
      // (or true to use the default: '/__getcookie')
      useCORSRouteToGetCookie: true,

      // The environment we're running in.
      // (logs are not displayed when this is set to 'production')
      //
      // Defaults to "development" unless this script was fetched from a URL
      // that ends in `*.min.js` or '#production', or if the conventional
      // `SAILS_LOCALS` global is set with an `_environment` of "production"
      // or "staging".  (This setting may also be manually overridden.)
      environment:
        urlThisScriptWasFetchedFrom.match(/(\#production|\.min\.js)/g) ||
        (typeof window === "object" &&
          window &&
          typeof window.SAILS_LOCALS === "object" &&
          window.SAILS_LOCALS &&
          (window.SAILS_LOCALS._environment === "staging" ||
            window.SAILS_LOCALS._environment === "production"))
          ? "production"
          : "development",

      // The version of this sails.io.js client SDK
      sdk: SDK_INFO,

      // Transports to use when communicating with the server, in the order they will be tried
      transports: ["websocket"]
    };

    //  ┌─┐─┐ ┬┌┬┐┌─┐┌┐┌┌┬┐  ┬┌─┐ ┌─┐┌─┐┬┬  ┌─┐  ┌┬┐┌─┐┌─┐┌─┐┬ ┬┬ ┌┬┐┌─┐
    //  ├┤ ┌┴┬┘ │ ├┤ │││ ││  ││ │ └─┐├─┤││  └─┐   ││├┤ ├┤ ├─┤│ ││  │ └─┐
    //  └─┘┴ └─ ┴ └─┘┘└┘─┴┘  ┴└─┘o└─┘┴ ┴┴┴─┘└─┘  ─┴┘└─┘└  ┴ ┴└─┘┴─┘┴ └─┘
    //  ┬ ┬┬┌┬┐┬ ┬  ┌┬┐┬ ┬┌─┐  ╦ ╦╔╦╗╔╦╗╦    ╔═╗╔╦╗╔╦╗╦═╗╦╔╗ ╦ ╦╔╦╗╔═╗╔═╗
    //  ││││ │ ├─┤   │ ├─┤├┤   ╠═╣ ║ ║║║║    ╠═╣ ║  ║ ╠╦╝║╠╩╗║ ║ ║ ║╣ ╚═╗
    //  └┴┘┴ ┴ ┴ ┴   ┴ ┴ ┴└─┘  ╩ ╩ ╩ ╩ ╩╩═╝  ╩ ╩ ╩  ╩ ╩╚═╩╚═╝╚═╝ ╩ ╚═╝╚═╝
    //  ┌─┐┬─┐┌─┐┌┬┐  ┌┬┐┬ ┬┌─┐  ┌─┐┌─┐┬─┐┬┌─┐┌┬┐  ┌┬┐┌─┐┌─┐
    //  ├┤ ├┬┘│ ││││   │ ├─┤├┤   └─┐│  ├┬┘│├─┘ │    │ ├─┤│ ┬
    //  └  ┴└─└─┘┴ ┴   ┴ ┴ ┴└─┘  └─┘└─┘┴└─┴┴   ┴    ┴ ┴ ┴└─┘
    //
    // Now fold in config provided as HTML attributes on the script tag:
    // (note that if `io.sails.*` is changed after this script, those changes
    //  will still take precedence)
    CONFIGURABLE_VIA_HTML_ATTR.forEach(function(configKey) {
      if (typeof scriptTagConfig[configKey] !== "undefined") {
        io.sails[configKey] = scriptTagConfig[configKey];
      }
    });
    //////////////////////////////////////////////////////////////////////////////
    // Note that the new HTML attribute configuration style may eventually
    // completely replace the original approach of setting `io.sails` properties,
    // since the new strategy is easier to reason about.  Also, it would allow us
    // to remove the timeout below someday.
    //////////////////////////////////////////////////////////////////////////////

    //  ┬┌─┐ ┌─┐┌─┐┬┬  ┌─┐ ╔═╗╔═╗╔╗╔╔╗╔╔═╗╔═╗╔╦╗  /  \
    //  ││ │ └─┐├─┤││  └─┐ ║  ║ ║║║║║║║║╣ ║   ║  /   /
    //  ┴└─┘o└─┘┴ ┴┴┴─┘└─┘o╚═╝╚═╝╝╚╝╝╚╝╚═╝╚═╝ ╩  \  /

    /**
     * Add `io.sails.connect` function as a wrapper for the built-in `io()` aka `io.connect()`
     * method, returning a SailsSocket. This special function respects the configured io.sails
     * connection URL, as well as sending other identifying information (most importantly, the
     * current version of this SDK).
     *
     * @param  {String} url  [optional]
     * @param  {Object} opts [optional]
     * @return {Socket}
     */
    io.sails.connect = function(url, opts) {
      // Make URL optional
      if ("object" === typeof url) {
        opts = url;
        url = null;
      }

      // Default opts to empty object
      opts = opts || {};

      // If explicit connection url is specified, save it to options
      opts.url = url || opts.url || undefined;

      // Instantiate and return a new SailsSocket- and try to connect immediately.
      var socket = new SailsSocket(opts);
      socket._connect();
      return socket;
    };

    //  ██╗ ██████╗    ███████╗ ██████╗  ██████╗██╗  ██╗███████╗████████╗
    //  ██║██╔═══██╗   ██╔════╝██╔═══██╗██╔════╝██║ ██╔╝██╔════╝╚══██╔══╝
    //  ██║██║   ██║   ███████╗██║   ██║██║     █████╔╝ █████╗     ██║
    //  ██║██║   ██║   ╚════██║██║   ██║██║     ██╔═██╗ ██╔══╝     ██║
    //  ██║╚██████╔╝██╗███████║╚██████╔╝╚██████╗██║  ██╗███████╗   ██║
    //  ╚═╝ ╚═════╝ ╚═╝╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝   ╚═╝
    //
    // io.socket
    //
    // The eager instance of Socket which will automatically try to connect
    // using the host that this js file was served from.
    //
    // This can be disabled or configured by setting properties on `io.sails.*` within the
    // first cycle of the event loop.
    //

    // Build `io.socket` so it exists
    // (note that this DOES NOT start the connection process)
    io.socket = new SailsSocket();
    //
    // This socket is not connected yet, and has not even _started_ connecting.
    //
    // But in the mean time, this eager socket will be queue events bound by the user
    // before the first cycle of the event loop (using `.on()`), which will later
    // be rebound on the raw underlying socket.

    //  ┌─┐┌─┐┌┬┐  ┌─┐┬ ┬┌┬┐┌─┐   ┌─┐┌─┐┌┐┌┌┐┌┌─┐┌─┐┌┬┐  ┌┬┐┬┌┬┐┌─┐┬─┐
    //  └─┐├┤  │   ├─┤│ │ │ │ │───│  │ │││││││├┤ │   │    │ ││││├┤ ├┬┘
    //  └─┘└─┘ ┴   ┴ ┴└─┘ ┴ └─┘   └─┘└─┘┘└┘┘└┘└─┘└─┘ ┴    ┴ ┴┴ ┴└─┘┴└─
    // If configured to do so, start auto-connecting after the first cycle of the event loop
    // has completed (to allow time for this behavior to be configured/disabled
    // by specifying properties on `io.sails`)

    // Indicate that the autoConnect timer has started.
    io.socket._mightBeAboutToAutoConnect = true;

    setTimeout(function() {
      // Indicate that the autoConect timer fired.
      io.socket._mightBeAboutToAutoConnect = false;

      // If autoConnect is disabled, delete the eager socket (io.socket) and bail out.
      if (io.sails.autoConnect === false || io.sails.autoconnect === false) {
        delete io.socket;
        return;
      }

      // consolog('Eagerly auto-connecting socket to Sails... (requests will be queued in the mean-time)');
      io.socket._connect();
    }, 0); // </setTimeout>

    // Return the `io` object.
    return io;
  } //</SailsIOClient>

  //
  /////////////////////////////////////////////////////////////////////////////////
  ///// </bunches of private function definitions, constructors, and methods>
  /////////////////////////////////////////////////////////////////////////////////

  //  ███████╗██╗  ██╗██████╗  ██████╗ ███████╗███████╗    ███████╗██████╗ ██╗  ██╗
  //  ██╔════╝╚██╗██╔╝██╔══██╗██╔═══██╗██╔════╝██╔════╝    ██╔════╝██╔══██╗██║ ██╔╝
  //  █████╗   ╚███╔╝ ██████╔╝██║   ██║███████╗█████╗      ███████╗██║  ██║█████╔╝
  //  ██╔══╝   ██╔██╗ ██╔═══╝ ██║   ██║╚════██║██╔══╝      ╚════██║██║  ██║██╔═██╗
  //  ███████╗██╔╝ ██╗██║     ╚██████╔╝███████║███████╗    ███████║██████╔╝██║  ██╗
  //  ╚══════╝╚═╝  ╚═╝╚═╝      ╚═════╝ ╚══════╝╚══════╝    ╚══════╝╚═════╝ ╚═╝  ╚═╝
  //

  // Add CommonJS support to allow this client SDK to be used from Node.js.
  if (SDK_INFO.platform === "node") {
    module.exports = SailsIOClient;
  }
  // Add AMD support, registering this client SDK as an anonymous module.
  else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return SailsIOClient;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/* eslint-enable */


/***/ }),

/***/ 40659:
/*!*************************!*\
  !*** ./src/js/store.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var framework7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framework7 */ 31223);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((AB) => {
   const allDCs = AB.datacollections();

   const configStore = {
      state: {
         // "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322": [],
         // "19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5": [],
         user: { username: "" },
         version: "",
      },
      getters: {
         // "0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"({ state }) {
         //    return state["0e9f5f6f-cd0b-4b93-b0c8-d51bd9852322"];
         // },
         // "19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5"({ state }) {
         //    return state["19e566e3-a6b0-4ed5-83ea-a42b1ddbf5c5"];
         // },
         user({ state }) {
            return state["user"];
         },
         version({ state }) {
            return state.version;
         },
      },
      actions: {
         getAppBuilderData({ state }, id) {
            let DC = AB.datacollectionByID(id);
            DC.setState(state);
            DC.loadData();
         },
         setUser({ state }, user) {
            state["user"] = user;
         },
         updateRecord({ state }, props) {
            let records = [...state[props.dcID].records];
            let foundIndex = records.findIndex((x) => x.uuid == props.recordID);
            let recordToUpdate = records[foundIndex];

            for (var propt in props.record) {
               if (Object.prototype.hasOwnProperty.call(recordToUpdate, propt))
                  recordToUpdate[propt] = props.record[propt];
            }
            state[props.dcID] = {
               loading: false,
               hasMore: records.length >= 60 ? false : true,
               records: records,
            };
         },
         getVersion({ state }) {
            state.version = app.f7.params.version;
         },
      },
   };

   allDCs.forEach((DC) => {
      configStore.state[DC.id] = [];
      configStore.getters[DC.id] = function ({ state }) {
         return state[DC.id];
      };
   });

   const store = (0,framework7__WEBPACK_IMPORTED_MODULE_0__["default"])(configStore);

   return store;
});


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["vendors"], () => (__webpack_exec__(62107)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=mobile_app.ab30a4eeb768c07e0aff.js.map