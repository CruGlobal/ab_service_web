(self["webpackChunkab_platform_web"] = self["webpackChunkab_platform_web"] || []).push([["AB"],{

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 94506,
	"./af.js": 94506,
	"./ar": 59687,
	"./ar-dz": 62887,
	"./ar-dz.js": 62887,
	"./ar-kw": 66307,
	"./ar-kw.js": 66307,
	"./ar-ly": 51664,
	"./ar-ly.js": 51664,
	"./ar-ma": 89926,
	"./ar-ma.js": 89926,
	"./ar-ps": 68634,
	"./ar-ps.js": 68634,
	"./ar-sa": 85207,
	"./ar-sa.js": 85207,
	"./ar-tn": 52912,
	"./ar-tn.js": 52912,
	"./ar.js": 59687,
	"./az": 5011,
	"./az.js": 5011,
	"./be": 25997,
	"./be.js": 25997,
	"./bg": 4427,
	"./bg.js": 4427,
	"./bm": 85385,
	"./bm.js": 85385,
	"./bn": 67703,
	"./bn-bd": 57002,
	"./bn-bd.js": 57002,
	"./bn.js": 67703,
	"./bo": 39841,
	"./bo.js": 39841,
	"./br": 45642,
	"./br.js": 45642,
	"./bs": 69038,
	"./bs.js": 69038,
	"./ca": 53512,
	"./ca.js": 53512,
	"./cs": 39497,
	"./cs.js": 39497,
	"./cv": 6479,
	"./cv.js": 6479,
	"./cy": 89318,
	"./cy.js": 89318,
	"./da": 97229,
	"./da.js": 97229,
	"./de": 63460,
	"./de-at": 51044,
	"./de-at.js": 51044,
	"./de-ch": 26445,
	"./de-ch.js": 26445,
	"./de.js": 63460,
	"./dv": 32096,
	"./dv.js": 32096,
	"./el": 16048,
	"./el.js": 16048,
	"./en-au": 74301,
	"./en-au.js": 74301,
	"./en-ca": 66855,
	"./en-ca.js": 66855,
	"./en-gb": 761,
	"./en-gb.js": 761,
	"./en-ie": 46127,
	"./en-ie.js": 46127,
	"./en-il": 49157,
	"./en-il.js": 49157,
	"./en-in": 37199,
	"./en-in.js": 37199,
	"./en-nz": 31511,
	"./en-nz.js": 31511,
	"./en-sg": 47309,
	"./en-sg.js": 47309,
	"./eo": 92160,
	"./eo.js": 92160,
	"./es": 68582,
	"./es-do": 71885,
	"./es-do.js": 71885,
	"./es-mx": 68131,
	"./es-mx.js": 68131,
	"./es-us": 16962,
	"./es-us.js": 16962,
	"./es.js": 68582,
	"./et": 98890,
	"./et.js": 98890,
	"./eu": 37704,
	"./eu.js": 37704,
	"./fa": 22562,
	"./fa.js": 22562,
	"./fi": 70877,
	"./fi.js": 70877,
	"./fil": 34246,
	"./fil.js": 34246,
	"./fo": 78341,
	"./fo.js": 78341,
	"./fr": 19867,
	"./fr-ca": 82347,
	"./fr-ca.js": 82347,
	"./fr-ch": 17683,
	"./fr-ch.js": 17683,
	"./fr.js": 19867,
	"./fy": 21982,
	"./fy.js": 21982,
	"./ga": 13905,
	"./ga.js": 13905,
	"./gd": 13443,
	"./gd.js": 13443,
	"./gl": 66905,
	"./gl.js": 66905,
	"./gom-deva": 91324,
	"./gom-deva.js": 91324,
	"./gom-latn": 41890,
	"./gom-latn.js": 41890,
	"./gu": 37134,
	"./gu.js": 37134,
	"./he": 96835,
	"./he.js": 96835,
	"./hi": 81394,
	"./hi.js": 81394,
	"./hr": 13564,
	"./hr.js": 13564,
	"./hu": 46269,
	"./hu.js": 46269,
	"./hy-am": 57269,
	"./hy-am.js": 57269,
	"./id": 44254,
	"./id.js": 44254,
	"./is": 8699,
	"./is.js": 8699,
	"./it": 28301,
	"./it-ch": 92887,
	"./it-ch.js": 92887,
	"./it.js": 28301,
	"./ja": 64642,
	"./ja.js": 64642,
	"./jv": 62168,
	"./jv.js": 62168,
	"./ka": 94501,
	"./ka.js": 94501,
	"./kk": 49537,
	"./kk.js": 49537,
	"./km": 45808,
	"./km.js": 45808,
	"./kn": 34881,
	"./kn.js": 34881,
	"./ko": 62951,
	"./ko.js": 62951,
	"./ku": 92452,
	"./ku-kmr": 36063,
	"./ku-kmr.js": 36063,
	"./ku.js": 92452,
	"./ky": 1853,
	"./ky.js": 1853,
	"./lb": 77639,
	"./lb.js": 77639,
	"./lo": 34502,
	"./lo.js": 34502,
	"./lt": 60874,
	"./lt.js": 60874,
	"./lv": 18237,
	"./lv.js": 18237,
	"./me": 87878,
	"./me.js": 87878,
	"./mi": 64234,
	"./mi.js": 64234,
	"./mk": 17535,
	"./mk.js": 17535,
	"./ml": 43896,
	"./ml.js": 43896,
	"./mn": 63046,
	"./mn.js": 63046,
	"./mr": 80927,
	"./mr.js": 80927,
	"./ms": 37224,
	"./ms-my": 66332,
	"./ms-my.js": 66332,
	"./ms.js": 37224,
	"./mt": 24866,
	"./mt.js": 24866,
	"./my": 24206,
	"./my.js": 24206,
	"./nb": 66723,
	"./nb.js": 66723,
	"./ne": 45097,
	"./ne.js": 45097,
	"./nl": 37529,
	"./nl-be": 1355,
	"./nl-be.js": 1355,
	"./nl.js": 37529,
	"./nn": 30296,
	"./nn.js": 30296,
	"./oc-lnc": 4802,
	"./oc-lnc.js": 4802,
	"./pa-in": 77057,
	"./pa-in.js": 77057,
	"./pl": 69850,
	"./pl.js": 69850,
	"./pt": 15552,
	"./pt-br": 83726,
	"./pt-br.js": 83726,
	"./pt.js": 15552,
	"./ro": 1717,
	"./ro.js": 1717,
	"./ru": 79117,
	"./ru.js": 79117,
	"./sd": 61742,
	"./sd.js": 61742,
	"./se": 92049,
	"./se.js": 92049,
	"./si": 83329,
	"./si.js": 83329,
	"./sk": 27619,
	"./sk.js": 27619,
	"./sl": 76707,
	"./sl.js": 76707,
	"./sq": 84281,
	"./sq.js": 84281,
	"./sr": 60436,
	"./sr-cyrl": 13408,
	"./sr-cyrl.js": 13408,
	"./sr.js": 60436,
	"./ss": 27500,
	"./ss.js": 27500,
	"./sv": 6950,
	"./sv.js": 6950,
	"./sw": 54222,
	"./sw.js": 54222,
	"./ta": 73746,
	"./ta.js": 73746,
	"./te": 1130,
	"./te.js": 1130,
	"./tet": 34740,
	"./tet.js": 34740,
	"./tg": 13378,
	"./tg.js": 13378,
	"./th": 20628,
	"./th.js": 20628,
	"./tk": 92622,
	"./tk.js": 92622,
	"./tl-ph": 30100,
	"./tl-ph.js": 30100,
	"./tlh": 22871,
	"./tlh.js": 22871,
	"./tr": 33600,
	"./tr.js": 33600,
	"./tzl": 18985,
	"./tzl.js": 18985,
	"./tzm": 3627,
	"./tzm-latn": 51145,
	"./tzm-latn.js": 51145,
	"./tzm.js": 3627,
	"./ug-cn": 4790,
	"./ug-cn.js": 4790,
	"./uk": 97712,
	"./uk.js": 97712,
	"./ur": 99529,
	"./ur.js": 99529,
	"./uz": 99141,
	"./uz-latn": 61737,
	"./uz-latn.js": 61737,
	"./uz.js": 99141,
	"./vi": 98205,
	"./vi.js": 98205,
	"./x-pseudo": 20697,
	"./x-pseudo.js": 20697,
	"./yo": 37826,
	"./yo.js": 37826,
	"./zh-cn": 83994,
	"./zh-cn.js": 83994,
	"./zh-hk": 36892,
	"./zh-hk.js": 36892,
	"./zh-mo": 43884,
	"./zh-mo.js": 43884,
	"./zh-tw": 85136,
	"./zh-tw.js": 85136
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 28434:
/*!*********************************!*\
  !*** ./AppBuilder/ABFactory.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/ABFactoryCore */ 78332);
/* harmony import */ var _core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ 53059);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ 36105);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! nanoid */ 31222);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! uuid */ 98170);
/* harmony import */ var _utils_performance__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/performance */ 18320);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./platform/FilterComplex */ 67483);
/* harmony import */ var _platform_FilterComplex__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_platform_FilterComplex__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _platform_views_ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./platform/views/ABViewGridPopupSortFields */ 83595);
/* harmony import */ var _config_Config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/Config.js */ 97146);
/* harmony import */ var _resources_Account_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../resources/Account.js */ 7018);
/* harmony import */ var _ui_ClassUI_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ui/ClassUI.js */ 32019);
/* harmony import */ var _factory_utils_Dialog_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_factory_utils/Dialog.js */ 64978);
/* harmony import */ var _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../resources/Multilingual.js */ 19962);
/* harmony import */ var _resources_Network_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../resources/Network.js */ 44730);
/* harmony import */ var _resources_Storage_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../resources/Storage.js */ 38609);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/ABViewManagerCore */ 60979);
/* harmony import */ var _core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../resources/Tenant.js */ 95324);
/* harmony import */ var _uiSettings_config_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./uiSettings/config.js */ 96253);










//
// Our Common Resources
//

// Config : responsible for all the configuration/settings of our instance.


// Account : manages the current Logged in User and Account information.




// Dialog : common UI dialogs.


// Multilingual: our interface Labels and language options


// Network: our interface for communicating to our server


// Storage: manages our interface for local storage




// Tenant: manages the Tenant information of the current instance


// UISettings: detailed settings for our common UI elements

class ABValidator {
   constructor(AB) {
      this.AB = AB;
      this.errors = [];
   }

   addError(name, message) {
      this.errors.push({ name: name, message: message });
   }

   pass() {
      return this.errors.length == 0;
   }

   fail() {
      return this.errors.length > 0;
   }

   toValidationObject() {
      var obj = {
         error: "E_VALIDATION",
         invalidAttributes: {},
      };

      var attr = obj.invalidAttributes;

      this.errors.forEach((e) => {
         attr[e.name] = attr[e.name] || [];
         attr[e.name].push(e);
      });

      return obj;
   }

   updateForm(form) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isFormValidationError(vObj, form);
   }

   updateGrid(rowID, grid) {
      var vObj = this.toValidationObject();
      this.AB.Validation.isGridValidationError(vObj, rowID, grid);
   }
}

//
// AppBuilder Objects
//

class ABFactory extends (_core_ABFactoryCore__WEBPACK_IMPORTED_MODULE_2___default()) {
   constructor(definitions) {
      super(definitions);

      // Common Reference to Configuration Values
      this.Config = _config_Config_js__WEBPACK_IMPORTED_MODULE_3__["default"];

      //
      // Resources
      //
      this.Account = _resources_Account_js__WEBPACK_IMPORTED_MODULE_4__["default"];
      this.Dialog = _factory_utils_Dialog_js__WEBPACK_IMPORTED_MODULE_5__["default"];
      this.Multilingual = _resources_Multilingual_js__WEBPACK_IMPORTED_MODULE_6__["default"];
      this.Network = _resources_Network_js__WEBPACK_IMPORTED_MODULE_7__["default"];
      this.Storage = _resources_Storage_js__WEBPACK_IMPORTED_MODULE_8__["default"];
      this.Tenant = _resources_Tenant_js__WEBPACK_IMPORTED_MODULE_9__["default"];
      this.Webix = webix;

      // Plugin Classes
      this.ClassUI = _ui_ClassUI_js__WEBPACK_IMPORTED_MODULE_10__["default"];

      // additional Class definitions
      this.Class.FilterComplex = (_platform_FilterComplex__WEBPACK_IMPORTED_MODULE_11___default());
      this.Class.ABViewManager = (_core_ABViewManagerCore__WEBPACK_IMPORTED_MODULE_12___default());
      this.Class.SortPopup = _platform_views_ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_13__["default"];

      // Temp placeholders until Resources are implemented:
      this.Analytics = {
         log: () => {},
         logError: () => {},
      };
      this.Lock = class Lock {
         constructor() {}

         acquire() {
            return Promise.resolve();
         }
         release() {
            return Promise.resolve();
         }
      };

      this.UISettings = _uiSettings_config_js__WEBPACK_IMPORTED_MODULE_14__["default"];

      this.Validation = {
         validator: () => {
            return new ABValidator(this);
         },

         errorSailsCleanup: function (error) {
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               // dig down to sails provided error object:
               if (
                  error.error &&
                  error.error == "E_UNKNOWN" &&
                  error.raw &&
                  error.raw.length > 0
               ) {
                  error = error.raw[0];
               }

               // drill down to the embedded .err object if it exists
               if (error.err) {
                  error = error.err;
               }

               // if this is from our server response:
               if (
                  error.data &&
                  error.data.error &&
                  error.data.error == "E_VALIDATION"
               ) {
                  error = error.data;
               }
            }

            return error;
         },

         /**
          * @function AB.Validation.isFormValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of the form elements.
          *
          * @codestart
          * var form = $$('formID');
          * var values = form.getValues();
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Form.isFormValidationError(err, form)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {obj} error
          *        the error response object
          * @param {obj} form
          *        the webix form instance (or reference)
          * @return {bool}
          *         true if error was about a form element.
          *         false otherwise.
          */
         isFormValidationError: function (error, form) {
            var hasFocused = false;
            // {bool} have we set focus to form component?

            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasForm = false;
                     for (var attr in attrs) {
                        // if this is a field in the form:
                        if (form.elements[attr]) {
                           var errors = attrs[attr];
                           var msg = [];
                           errors.forEach(function (err) {
                              msg.push(err.message);
                           });

                           // set the invalid error message
                           form.markInvalid(attr, msg.join(", "));

                           // set focus to the 1st form element we mark:
                           if (!hasFocused) {
                              form.elements[attr].focus();
                              hasFocused = true;
                           }

                           wasForm = true;
                        }
                     }

                     if (wasForm) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our form with an error
            // this was not a validation error so return false
            return false;
         },

         /**
          * @method AB.Validation.isGridValidationError
          *
          * scans the given error to see if it is a sails' response about an invalid
          * value from one of our grid columns.
          *
          * @codestart
          * var grid = $$('myGrid');
          * model.attr(values);
          * model.save()
          * .fail(function(err){
          *     if (!OP.Validation.isGridValidationError(err, editor, grid)) {
          *         OP.error.log('Error saving current model ()', {error:err, values:values});
          *     }
          * })
          * .then(function(newData){
          *
          * });
          * @codeend
          *
          * @param {Error} error
          *        the error response object
          * @param {integer} row
          *        the row id of the Grid to update.
          * @param {webix.datatable} Grid
          *        the webix grid instance (or reference)
          * @return {bool}
          *         true if error was about a grid column.
          *         false otherwise.
          */
         isGridValidationError: function (error, row, Grid) {
            // if we have an error object:
            if (error) {
               //// if the error obj is provided by Sails response,
               //// do some clean up on the error object:

               error = this.errorSailsCleanup(error);

               //// Now process the error object
               ////
               if (
                  (error.error && error.error == "E_VALIDATION") ||
                  (error.code && error.code == "E_VALIDATION")
               ) {
                  var attrs = error.invalidAttributes;
                  if (attrs) {
                     var wasGrid = false;
                     for (var attr in attrs) {
                        Grid.addCellCss(row, attr, "webix_invalid");
                        Grid.addCellCss(row, attr, "webix_invalid_cell");

                        var msg = [];
                        attrs[attr].forEach((e) => {
                           msg.push(e.message);
                        });

                        webix.alert({
                           text: attr + ": " + msg.join(", "),
                        });

                        wasGrid = true;
                     }

                     Grid.refresh(row);
                     Grid.clearSelection();

                     if (wasGrid) {
                        return true;
                     }
                  }
               }
            }

            // if we missed updating our Grid with an error
            // this was not a validation error so return false
            return false;
         },
      };

      // TODO: make sure "error" s are handled and sent to logs
      // this.on("error", ()=>{ Analytics.error })

      this.Definitions = {};
      // {obj} the provided interface for working with the ABDefinition table.
      // NOTE: on the web client, we simply perform web API calls to perform
      // the actions.  These are defined below.

      this.on("error", (err) => {
         // this simply prevents thrown errors if there are no listeners.
         console.error(err);
      });

      this._plugins = [];
      // {array} of loaded Plugin.applications.

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our definitionsXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this.Network.on("definition.create", (context, err, fullDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // this.error(err);
            pending?.reject(err);
            return;
         }

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: fullDef.id,
            data: fullDef,
         };
         this.emit("ab.abdefinition.create", pkt);

         let newDef = this.definitionNew(fullDef);
         pending?.resolve(newDef);
      });

      this.Network.on("definition.update", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            if (err.toString().indexOf("Not Found") > -1) {
               return this.definitionCreate(context.values)
                  .then(pending?.resolve)
                  .catch(pending?.reject);
            }
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         this._definitions[context.id] = serverDef;

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: serverDef.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.update", pkt);

         pending?.resolve(serverDef);
      });

      this.Network.on("definition.delete", (context, err, serverDef) => {
         var pending = this._pendingNetworkRequests[context.uuid];
         if (err) {
            // log the error
            // this.error(err);
            pending?.reject(err);
            return;
         }

         delete this._definitions[context.id];

         // for immediate feedback to our UI:
         // simulate the RT update from our sockets:
         var pkt = {
            id: context.id,
            data: serverDef,
         };
         this.emit("ab.abdefinition.delete", pkt);

         pending?.resolve();
      });

      //
      // Rules
      //
      const platformRules = {
         /**
          * @method toDate
          *
          * @param {string} dateText
          * @param {Object} options - {
          *                               format: "string",
          *                               ignoreTime: boolean
          *                            }
          * @return {Date}
          */
         toDate: (dateText = "", options = {}) => {
            if (!dateText) return;

            if (options.ignoreTime) dateText = dateText.replace(/T.*/, "");

            let result = options.format
               ? moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText, options.format)
               : moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText);

            let supportFormats = [
               "YYYY-MM-DD",
               "YYYY/MM/DD",
               "DD/MM/YYYY",
               "MM/DD/YYYY",
               "DD-MM-YYYY",
               "MM-DD-YYYY",
            ];

            supportFormats.forEach((format) => {
               if (!result || !result.isValid())
                  result = moment__WEBPACK_IMPORTED_MODULE_1___default()(dateText, format);
            });

            return new Date(result);
         },

         /**
          * @method toDateFormat
          *
          * @param {Date} date
          * @param {Object} options - {
          *           format: "string",
          *           localeCode: "string"
          *         }
          *
          * @return {string}
          */
         toDateFormat: (date, options) => {
            if (!date) return "";

            let momentObj = moment__WEBPACK_IMPORTED_MODULE_1___default()(date);

            if (options.localeCode) momentObj.locale(options.localeCode);

            return momentObj.format(options.format);
         },

         /**
          * @method subtractDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         subtractDate: (date, number, unit) => {
            return moment__WEBPACK_IMPORTED_MODULE_1___default()(date).subtract(number, unit).toDate();
         },

         /**
          * @method addDate
          *
          * @param {Date} date
          * @param {number} number
          * @param {string} unit
          *
          * @return {Date}
          */
         addDate: (date, number, unit) => {
            return moment__WEBPACK_IMPORTED_MODULE_1___default()(date).add(number, unit).toDate();
         },
      };
      (Object.keys(platformRules) || []).forEach((k) => {
         this.rules[k] = platformRules[k];
      });
   }

   /**
    * init()
    * prepare the ABFactory for operation. This includes parsing the
    * definitions into useable objects, preparing the System Resources, etc.
    * @return {Promise}
    */
   async init() {
      //
      // Prepare our Resources First
      //
      var allInits = [];

      allInits.push(this.Account.init(this));
      allInits.push(this.Multilingual.init(this));
      allInits.push(this.Network.init(this));
      allInits.push(this.Tenant.init(this));

      await Promise.all(allInits);
      await this.Storage.init(this);
      var data = await this.Storage.get("local_settings");
      this._localSettings = data || {};

      //
      // Real Time Update Handlers
      //

      // new ABDefinition created:
      this.on("ab.abdefinition.create", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition

         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("created", pkt.id, pkt.data);
      });

      // ABDefinition updated:
      this.on("ab.abdefinition.update", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         this._definitions[pkt.id] = pkt.data;
         this.definitionSync("updated", pkt.id, pkt.data);
      });

      // ABDefinition delete:
      this.on("ab.abdefinition.delete", (pkt) => {
         // pkt.id : definition.id
         // pkt.data : definition
         if (typeof pkt.data.json == "string") {
            try {
               pkt.data.json = JSON.parse(pkt.data.json);
            } catch (e) {
               console.log(e);
            }
         }
         delete this._definitions[pkt.id];
         this.definitionSync("destroyed", pkt.id, pkt.data);
      });

      return super.init();

      // return Promise.all(allInits)
      //    .then(() => {
      //       // some Resources depend on the above to be .init() before they can
      //       // .init() themselves.
      //       return this.Storage.init(this).then(() => {
      //          return this.Storage.get("local_settings").then((data) => {
      //             this._localSettings = data || {};
      //          });
      //       });
      //    })
      //    .then(() => {
      //       //
      //       // RealTime Updates of our ABDefinitions
      //       //

      //       // new ABDefinition created:
      //       this.on("ab.abdefinition.create", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition

      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("created", pkt.id, pkt.data);
      //       });

      //       // ABDefinition updated:
      //       this.on("ab.abdefinition.update", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          this._definitions[pkt.id] = pkt.data;
      //          this.definitionSync("updated", pkt.id, pkt.data);
      //       });

      //       // ABDefinition delete:
      //       this.on("ab.abdefinition.delete", (pkt) => {
      //          // pkt.id : definition.id
      //          // pkt.data : definition
      //          if (typeof pkt.data.json == "string") {
      //             try {
      //                pkt.data.json = JSON.parse(pkt.data.json);
      //             } catch (e) {
      //                console.log(e);
      //             }
      //          }
      //          delete this._definitions[pkt.id];
      //          this.definitionSync("destroyed", pkt.id, pkt.data);
      //       });

      //       return super.init();
      //    });
   }

   /**
    * definiitonCreate(def)
    * create a new ABDefinition
    * @param {obj} def
    *        the value hash of the new definition entry
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionCreate(def) {
      // we will set our uuid
      if (typeof def.id == "undefined") {
         def.id = this.uuid();
         def.json.id = def.id;
      }

      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.create",
            context: {
               uuid,
            },
         };
         this.Network.post(
            {
               url: `/definition/create`,
               data: def,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to CREATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to CREATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionCreate()",
               message,
               def,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionDestroy(id)
    * delete an ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @return {Promise}
    */
   async definitionDestroy(id) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.delete",
            context: {
               id,
               uuid,
            },
         };
         this.Network.delete(
            {
               url: `/definition/${id}`,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to DESTROY definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to DELETE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionDestroy()",
               message,
               id,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionUpdate(id, def)
    * update an existing ABDefinition
    * @param {string} id
    *        the uuid of the ABDefinition to update.
    * @param {obj} values
    *        the value hash of the new definition values
    * @return {Promise}
    *        resolved with a new {ABDefinition} for the entry.
    */
   async definitionUpdate(id, values) {
      return new Promise((resolve, reject) => {
         var uuid = this.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "definition.update",
            context: {
               id,
               uuid,
               values,
            },
         };
         this.Network.put(
            {
               url: `/definition/${id}`,
               data: values,
            },
            jobResponse
         ).catch((err) => {
            var message = "Error attempting to UPDATE definitions";
            if (err.code == "E_NOPERM") {
               message = "User Doesn't have permission to UPDATE definitions";
            }
            this.notify.developer(err, {
               context: "ABFactory.definitionUpdate()",
               message,
            });

            // NOTE: when using jobResponse type calls, expect that
            // handler to be handling the errors.
            // don't keep propagating them here.
         });
      });
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   // definitionsParse(defs = []) {
   //    if (!Array.isArray(defs)) {
   //       defs = [defs];
   //    }

   //    // store/replace the incoming definitions
   //    // 1st: insert ALL our definitions internally
   //    defs.forEach((d) => {
   //       this._definitions[d.id] = d;
   //    });
   //    // 2nd: Now we can then go through and signal the "updates"
   //    // and the related objects can find their dependent definitions.
   //    defs.forEach((d) => {
   //       this.definitionSync("updated", d.id, d);
   //    });

   //    return Promise.resolve();
   // }

   /**
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain which group of people we are sending a notification to.
    * @param {Error} error An error object generated at the point of issue.
    * @param {json} info Additional related information concerning the issue.
    */
   notify(domain, error, info) {
      _utils_performance__WEBPACK_IMPORTED_MODULE_15__["default"].notify(domain, error, info);
   }

   plugins() {
      return this._plugins;
   }
   pluginLoad(p) {
      this._plugins.push(p);
   }

   //
   // Utilities
   //
   alert(options) {
      this.Webix.alert(options);
   }

   cloneDeep(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(value);
   }

   error(message, ...rest) {
      var emitData = {
         message: `ABFactory[${this.Tenant.id()}]:${message.toString()}`,
      };

      console.error(emitData.message);
      if (message instanceof Error) {
         emitData.error = message;
         // this dumps the error.stack
         console.error(message);
      }

      if (rest.length > 0) {
         rest.forEach((r) => {
            if (r instanceof Error) {
               emitData.error = r;
               // this dumps the error.stack
               console.error(r);
            }

            if (typeof r == "object") {
               for (var k in r) {
                  emitData[k] = r[k];
                  console.error(k, r[k]);
               }
            }
         });
      }
      this.emit("error", emitData);
   }

   jobID() {
      return (0,nanoid__WEBPACK_IMPORTED_MODULE_16__.nanoid)();
   }

   Label() {
      return (...params) => {
         return this.Multilingual.label(...params);
      };
   }

   localSettings(key, value) {
      if (typeof value == "undefined") {
         // this is a getter:
         return this._localSettings[key];
      } else {
         // setting a value:
         this._localSettings[key] = value;
         return this.Storage.set(`local_settings`, this._localSettings);
      }
   }

   log(message, ...rest) {
      console.log(message);
      rest.forEach((r) => {
         console.log(r);
      });
   }

   isNil(value) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().isNil(value);
   }

   /**
    * @method rules.isUUID
    * evaluate a given value to see if it matches the format of a uuid
    * @param {string} key
    * @return {boolean}
    */
   isUUID(key) {
      var checker = RegExp(
         "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
         "i"
      );
      return checker.test(key);
   }

   merge(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().merge(...params);
   }

   orderBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().orderBy(...params);
   }

   uniq(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().uniq(...params);
   }

   kebabCase(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().kebabCase(...params);
   }

   sumBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().sumBy(...params);
   }

   meanBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().meanBy(...params);
   }

   maxBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().maxBy(...params);
   }

   minBy(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().minBy(...params);
   }

   uuid() {
      return (0,uuid__WEBPACK_IMPORTED_MODULE_17__["default"])();
   }

   warn(message, ...rest) {
      console.warn(message);
      rest.forEach((r) => {
         console.warn(r);
      });
   }

   isString(...params) {
      return lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ABFactory);


/***/ }),

/***/ 64978:
/*!*********************************************!*\
  !*** ./AppBuilder/_factory_utils/Dialog.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
// Dialog
// A common set of UI dialogs to show the User.
//
// NOTE: IN TRANSITION: this is our previous method of handling
// dialogs.  In future, refactor to use webix directly in code.
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Instance properties

   // Alert
   // A dialogue that popup with a message, and requires an [ok] button press
   Alert: function (opts) {
      webix.alert({
         title:
            opts.title ||
            AB.Multilingual.label("opp.dialog.alert.title", "*Alert"),
         text:
            opts.text ||
            opts.message ||
            AB.Multilingual.label(
               "opp.dialog.alert.text",
               "*Something is wrong."
            ),
         ok: opts.ok || AB.Multilingual.label("opp.dialog.alert.ok", "*OK"),
      });
   },

   // Confirm
   // A [Yes] [No] dialogue that pops up with a message
   Confirm: function (opts) {
      var title =
         opts.title ||
         AB.Multilingual.label("opp.dialog.confirm.confirmTitle", "* Confirm");
      var message =
         opts.text ||
         opts.message ||
         AB.Multilingual.label(
            "opp.dialog.confirm.confirmMsg",
            "* Are you sure you want to do this?"
         );

      var labelYes =
         opts.labelYes ||
         opts.ok ||
         AB.Multilingual.label("opp.common.yes", "* yes");
      var labelNo =
         opts.labelNo ||
         opts.cancel ||
         AB.Multilingual.label("opp.common.no", "* no");

      // var fnYes = opts.fnYes || function () { };
      // var fnNo = opts.fnNo || function () { };

      webix.confirm({
         title: title,
         text: message,

         ok: labelYes,
         cancel: labelNo,

         callback: function (result) {
            if (result) {
               if (opts.fnYes) opts.fnYes();
            } else {
               if (opts.fnNo) opts.fnNo();
            }

            if (opts.callback) opts.callback(result);
         },
      });

      // bootbox.dialog({
      //     title: title,
      //     message: message,
      //     buttons: {
      //         yes: {
      //             label: labelYes,
      //             className: 'btn-primary',
      //             callback: fnYes
      //         },
      //         no: {
      //             label: labelNo,
      //             className: 'btn-default',
      //             callback: fnNo
      //         }
      //     }
      // });
   },

   // ConfirmDelete
   // A Confirm dialogue geared towards deleting items.
   // [delete] [cancel]
   ConfirmDelete: function (opts) {
      this.Confirm({
         title:
            opts.title ||
            AB.Multilingual.label(
               "opp.dialog.confirm.deleteTitle",
               "* Confirm Delete"
            ),
         ok: opts.ok || AB.Multilingual.label("opp.common.delete", "* Delete"),
         cancel:
            opts.cancel ||
            AB.Multilingual.label("opp.common.cancel", "* Cancel"),
         text:
            opts.text ||
            opts.message ||
            AB.Multilingual.label(
               "opp.dialog.confirm.deleteMsg",
               "* Are you sure you want to delete this?",
               ["this"]
            ),
         callback: function (result) {
            if (result) {
               if (opts.fnYes) opts.fnYes();
            } else {
               if (opts.fnNo) opts.fnNo();
            }

            if (opts.callback) opts.callback(result);
         },
      });
   },

   // Message
   // A simple message displayed to the user.  Can time out
   Message: function (opts) {
      var message = opts.text || opts.message;
      var timeout = opts.timeout || 2000;

      webix.message({
         text: message,
         expire: timeout,
      });
   },
});


/***/ }),

/***/ 45434:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABApplicationCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABApplicationCore
 *
 * This is the core ABApplication class that manages the common operations
 * of an ABApplication across platforms.
 *
 * It's primary responsibility is to decode a given set of attributes into
 * a working instance of an ABApplication that can return instances of
 * it's defined sub objects.
 *
 * Platform Specific versions of those objects should be defined in a peer
 * directory named platform. These versions of the objects should override
 * these Core objects with platform specific methods of operation (like
 * .save()).
 *
 * Initially your target application should load your platform/ABApplication.js
 * file, which will include this file and sub class it.
 *
 * However, this file will include the remaining files from your platform/*
 * versions.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
const ABViewManager = __webpack_require__(/*! ../platform/ABViewManager */ 96649);
var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);

function toBool(val) {
   if (typeof val == "undefined") {
      return false;
   }

   if (val === "" || val === "false" || val === "0") {
      return false;
   }

   if (val === "true" || val === "1") {
      return true;
   }

   return val;
}

module.exports = class ABApplicationCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label", "description"], AB);

      // attributes should be in format:
      // {
      //    id:##,
      //    json:{},
      //    name:"XYZ"
      // }
      attributes.json = attributes.json || {};

      // ABApplication Attributes
      this.id = attributes.id;
      // {string} uuid

      this.type = attributes.type || "application";
      // {string} .type
      // the ABDefinition.type of this object.

      this.appType = attributes.appType || "web";
      // {string} .appType
      // the kind of Application this is. ["web", "mobile"]

      this.json = attributes.json;
      if (typeof this.json == "string") this.json = JSON.parse(this.json);
      // {obj} .json
      // the full settings of this ABApplication

      this.json["versionData"] = attributes.json?.versionData || {
         versionNumber: "1.0.0",
         changeLog: {
            "1.0.0": {
               author: "N/A",
               version: "1.0.0",
               keepVersion: 0,
               commitMessage: "Initial Version",
               timestamp: new Date().toISOString(),
            },
         },
      };

      if (typeof this.json.versionData == "string")
         this.json.versionData = JSON.parse(this.json.versionData);
      // {obj} .json
      // the full version log data of this ABApplication

      this.name = attributes.name || this.json.name || "";
      // {string} .name
      // the hard coded name of this ABDefinition Object, not to be confused
      // with the .label.  The .name is created at design time and is a text
      // reference for this object.

      this.icon = attributes.icon || "fa-rocket";
      // {string} .icon
      // this is a reference to a font awesome icon including the `fa-`
      // example `fa-child` should be stored for the `child` icon to be used
      // if user wants to get creative they can add more to this field following
      // these examples https://fontawesome.com/v4/examples/

      this.isSystemObject = toBool(attributes.isSystemObject);
      // {bool} .isSystemObject
      // is this one of the integrated System Objects used by our framework?
      // Some ABApplications and ABObjects are central to the running of the
      // AppBuilder site.  They are marked with .isSystemObject = true;  It
      // requires the role "System Designer" in order to edit/modify them.

      this.roleAccess = attributes.roleAccess || [];
      if (!Array.isArray(this.roleAccess)) {
         this.roleAccess = [this.roleAccess];
      }
      this.roleAccess = this.roleAccess.filter((r) => r);
      // {array}
      // the {ABSiteRole.id}s of the roles allowed to work with this
      // ABApplication. (see .isAccessManaged for more info)

      this.isAccessManaged = JSON.parse(attributes.isAccessManaged || false);
      // {bool} .isAccessManaged
      // does this Application imploy the more sophisticated  Access
      // permissions, or the simpler Role access permissions.
      // {true} : allows an administrator to set which role can View|Edit|Delete
      //          elements of an application.
      // {false}: indicates users having one of the .roleAccess values can have
      //          full access to this application

      this.accessManagers = attributes.accessManagers;
      if (typeof this.accessManagers == "string")
         this.accessManagers = JSON.parse(this.accessManagers);
      // {??} .accessManagers
      // if .isAccessManaged == true, then .accessManagers contain the definitions
      // of the detailed access permissions.

      this.isTranslationManaged = JSON.parse(
         attributes.isTranslationManaged || false
      );
      this.translationManagers = attributes.translationManagers;
      if (typeof this.translationManagers == "string")
         this.translationManagers = JSON.parse(this.translationManagers);

      this.isTutorialManaged = JSON.parse(
         attributes.isTutorialManaged || false
      );
      this.tutorialManagers = attributes.tutorialManagers;
      if (typeof this.tutorialManagers == "string")
         this.tutorialManagers = JSON.parse(this.tutorialManagers);

      this.hintIDs = attributes.json.hintIDs || [];
      // {array} .hintIDs
      // All the {ABHint.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABHint}s are included or excluded from
      // this app.

      this.objectIDs = attributes.json.objectIDs || [];
      // {array} .objectIDs
      // All the {ABObject.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObject}s are included or excluded from this app.

      this.queryIDs = attributes.json.queryIDs || [];
      // {array} .queryIDs
      // All the {ABObjectQuery.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABObjectQueries}s are included or excluded from
      // this app.

      this.datacollectionIDs = attributes.json.datacollectionIDs || [];
      // {array} .datacollectionIDs
      // All the {ABDataCollection.id} values that have been pulled into this
      // ABApplication for use in it's design environment.  This is how we
      // determine which {ABDataCollection}s are included or excluded from
      // this app.

      // import all our {ABViewPage}s
      let newPages = [];
      (attributes.json.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            newPages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.id}] is referenceing an unknown Page[${id}]`,
               {
                  appID: this.id,
                  pageID: id,
               }
            );
            // console.error(
            //    `App[${this.id}] is referenceing an unknown Page[${id}]`
            // );
         }
      });
      this._pages = newPages;
      // {array} ._pages
      // an array of all the {ABViewPages} this ABApplication offers as
      // interfaces for working with our Data.
      // ABViewPages operate within the confines of an ABApplication so
      // they are created/stored/accessed from within an ABApplication

      (attributes.json.processIDs || []).forEach((pID) => {
         var p = this.AB.processByID(pID);
         if (!p) {
            this.emit(
               "warning",
               `Application is referencing an unknown process.`,
               { appID: this.id, processID: pID }
            );
         }
      });

      this.processIDs = attributes.json.processIDs || [];
      // {array} .processIDs
      // an array of all the {ABProcess.id}s referenced by this Application.

      // Object List Settings
      attributes.json.objectListSettings =
         attributes.json.objectListSettings || {};
      this.objectListSettings = this.objectListSettings || {};
      this.objectListSettings.isOpen = JSON.parse(
         attributes.json.objectListSettings.isOpen || false
      );
      this.objectListSettings.searchText =
         attributes.json.objectListSettings.searchText || "";
      this.objectListSettings.sortDirection =
         attributes.json.objectListSettings.sortDirection || "asc";
      this.objectListSettings.isGroup = JSON.parse(
         attributes.json.objectListSettings.isGroup || false
      );

      // let the MLClass now process the translations:
      // transition issues:
      attributes.translations =
         attributes.translations || attributes.json.translations;

      super.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return ABViewManager;
   }

   /// ABApplication data methods
   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABApplication is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      // if we are on the basic Role assignments:
      if (!this.isAccessManaged) {
         (roles || []).forEach((r) => {
            if (this.roleAccess.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
         return foundRole;
      }

      // isAccessManaged has been set, so 2 kinds of ppl can
      // see this App
      // 1) an AccessManager
      if (parseInt(this.accessManagers.useRole)) {
         (roles || []).forEach((r) => {
            if (this.accessManagers.role.indexOf(r.uuid || r) > -1) {
               foundRole = true;
            }
         });
      }

      // stop here if found.
      if (foundRole) return foundRole;

      // 2) someone who has a role that can see one of it's pages.
      // scan each Page of this Application
      (this.pages() || []).forEach((p) => {
         // check to see if that page.isAccessibleForRoles()
         if (p.isAccessibleForRoles(roles)) {
            foundRole = true;
         }
      });
      return foundRole;
   }

   get isWebApp() {
      return this.appType == "web";
   }

   get isMobile() {
      return this.appType == "mobile";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      let versionData = this.json.versionData;

      this.json = super.toObj();

      this.json.name = this.name;

      this.json.versionData = versionData;

      this.json.objectIDs = this.objectIDs;

      this.json.objectListSettings = this.objectListSettings;

      this.json.hintIDs = this.hintIDs;

      this.json.queryIDs = this.queryIDs;

      this.json.datacollectionIDs = this.datacollectionIDs;

      this.json.pageIDs = (this._pages || []).map((p) => p.id);

      this.json.processIDs = this.processIDs || [];

      // // for each MobileApp: compile to json
      // var currApps = [];
      // this._mobileApps.forEach((app) => {
      //    currApps.push(app.toObj())
      // })
      // this.json.mobileApps = currApps;

      return {
         id: this.id,
         type: this.type || "application",
         appType: this.appType || "web",
         name: this.name,
         icon: this.icon,
         isSystemObject: this.isSystemObject,
         json: this.json,
         roleAccess: this.roleAccess,
         translations: this.json.translations,
         isAccessManaged: this.isAccessManaged,
         isTranslationManaged: this.isTranslationManaged,
         isTutorialManaged: this.isTutorialManaged,
         accessManagers: this.accessManagers,
         translationManagers: this.translationManagers,
         tutorialManagers: this.tutorialManagers,
      };
   }

   ///
   /// Mobile Apps
   ///

   ///
   /// Datacollections
   ///

   // datacollectionNew(values) {
   //    return new ABDataCollectionCore(values, this);
   // }

   datacollectionsExcluded(filter = () => true) {
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   datacollectionsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.datacollections((o) => {
         return this.datacollectionIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Objects
   ///

   objectsExcluded(filter = () => true) {
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) == -1;
      }).filter(filter);
   }

   objectsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.objects((o) => {
         return this.objectIDs.indexOf(o.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Hints
   ///

   hintsExcluded(filter = () => true) {
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) == -1;
      }).filter(filter);
   }

   hintsIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.hints((h) => {
         return this.hintIDs.indexOf(h.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   /**
    * @method connectedObjects()
    *
    * return an array of all the connected ABObjects for a given ABObject.
    *
    * @param {string} id
    *        an ID of an ABObject
    * @return {array}   array of options for webix select
    *         [ {id, value}, ... ]
    */
   connectedObjects(id) {
      console.error(
         "ABApplicationCore.connectedObjects(): who is calling this?"
      );

      if (id == "") return [];

      // Determine the object from the ID
      var myObj = this.AB.objectByID(id);

      // Get all the connected Fields for that object
      var connectedFields = myObj.connectFields();
      // Store the related fields associatively inside their related Objects ID
      var connectedObj = {};
      connectedFields.forEach((f) => {
         connectedObj[f.settings.linkObject] = this.AB.objectByID(
            f.settings.linkObject
         );
      });
      // Look up the objects by their ID and push them in an options array
      var linkedObjects = [];
      Object.keys(connectedObj).forEach(function (key /*, index */) {
         linkedObjects.push({
            id: this[key].id,
            value: this[key].label,
         });
      }, connectedObj /* = this. inside fn */);

      return linkedObjects;
   }

   /**
    * @method connectedFields()
    * return an array of all the connected ABFields for a given ABObject
    * @param {string} currObjID
    *        an ID of the current ABObject
    * @param {string} linkedObjectID
    *        an ID of the linked ABObject
    * @return {array}
    *        array of options for webix select
    */
   connectedFields(currObjID, linkedObjectID) {
      console.error("!!! Who is calling this?");

      // Determine the object from the currObjID
      var myObj = this.AB.objectByID(currObjID);

      // Get all the connected Fields for our object that match the linkedObjectID
      var connectedFields = myObj.connectFields(
         (f) => f.settings.linkObject == linkedObjectID
      );
      // Build an arry of options for the webix select
      var linkedFields = [];
      connectedFields.forEach((f) => {
         linkedFields.push({ id: f.columnName, value: f.label });
      });

      return linkedFields;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    * return an array of all the ABViewPages for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABViewPages that this fn
    *        returns true for.
    * @param {boolean} deep
    *        flag to search in sub pages
    * @return {array}
    *        array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      if (!this._pages || this._pages.length < 1) return result;

      // find into sub-pages recursively
      if (filter && deep) {
         // function searchDeep(curr) {
         //    let resultsCurr = curr._pages.filter(filter);

         //    for (let p of curr._pages) {
         //       let resultsP = searchDeep(p);
         //       if (resultsP.length) {
         //          resultsCurr = resultsCurr.concat(resultsP);
         //       }
         //    }
         //    // if we get here, end
         //    return resultsCurr;
         // }

         // result = searchDeep(this);
         result = this._searchDeep(this, "_pages", filter);
      }
      // find root pages
      else {
         result = (this._pages || []).filter(filter);
      }

      return result;
   }

   /**
    * @method _searchDeep()
    * search each node of a tree and return all matches that pass the provided
    * filter.
    * @param {AB*} curr
    *        An object that contains a tree structure.
    * @param {string} key
    *        The curr[key] reference of the array of items to search
    * @param {function} filter
    *        The curr[key].filter(filter) that returns true/false if a node is
    *        to be included in the result.
    * @return {array}
    */
   _searchDeep(curr, key, filter) {
      let items = curr[key] ?? [];
      let resultsCurr = items.filter?.(filter) ?? [];

      for (let p of items) {
         let resultsP = this._searchDeep(p, key, filter);
         if (resultsP.length) {
            resultsCurr = resultsCurr.concat(resultsP);
         }
      }

      return resultsCurr;
   }

   ///
   /// Processes
   ///

   /**
    * @method processes()
    * return an array of all the ABProcesses for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABProcesses that
    *        this fn returns true for.
    * @return {array}
    *        array of ABProcesses
    */
   processes(filter = () => true) {
      return this.AB.processes((p) => {
         return this.processIDs.indexOf(p.id) > -1;
      }).filter(filter);
   }

   hasProcess(process) {
      if (process && process.id) {
         return this.processIDs.indexOf(process.id) > -1;
      } else {
         return false;
      }
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    * return an array of all the Views for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of Views that this fn
    *        returns true for.
    * @return {array}
    *        array of Views
    */
   views(filter) {
      var result = [];
      var views = [];
      var pages = [];

      if (
         (!this._pages || this._pages.length < 1) &&
         (!this._views || this._views.length < 1)
      )
         return result;

      function lookDeep(view) {
         if (view._pages && view._pages.length) {
            view._pages.forEach((p) => {
               // check the page views recusively
               var pageViews = p.views(filter, true);
               // if there was a match store it
               if (pageViews && pageViews.length > 0) {
                  result = pageViews;
               }
               // if no match move on to the subpages
               if (result.length < 1) {
                  // loop through each subpage recursively
                  var subPages = p.pages(filter, true);
                  // if there was a match store it
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
                  if (result.length < 1) {
                     lookDeep(p);
                  }
               }
            });
         }
      }

      // look at views recursively
      if (filter) {
         // look at views recursively (views can have subviews and so on)
         if (this._views) {
            views = this._views.filter(filter);

            if (views.length < 1) {
               this._views.forEach((v) => {
                  var subViews = v.views(filter, true);
                  if (subViews && subViews.length > 0) {
                     views = subViews;
                  }
               });
            }
         }

         // if no views of the root page match now look at the sub pages and their views
         if (views.length) {
            result = views;
         } else {
            // check the first level subpages
            result = this._pages.filter(filter);

            // if no match check each pages views and subpages
            if (result.length < 1) {
               // looping through pages
               lookDeep(this);
            }
         }
      }
      // find all views
      else {
         // recusively gather all views on this view
         if (this._views) {
            views = this._views;
            if (views.length) {
               views.forEach((v) => {
                  var subViews = v.views(() => true, true);
                  if (subViews && subViews.length) {
                     views = views.concat(subViews);
                  }
               });
            }
         }

         // recursively gather all pages and their views
         if (this._pages) {
            pages = this._pages;
            if (pages.length) {
               pages.forEach((p) => {
                  // grab all views on this page
                  var pageViews = p.views(() => true, true);
                  if (pageViews && pageViews.length) {
                     views = views.concat(pageViews);
                  }
                  // grab all subpages on this page
                  var subPages = p.pages(() => true, true);
                  if (subPages && subPages.length) {
                     pages = pages.concat(subPages);
                     subPages.forEach((sub) => {
                        var subViews = sub.views(() => true, true);
                        if (subViews && subViews.length) {
                           views = views.concat(subViews);
                        }
                     });
                  }
               });
            }
         }

         result = result.concat(pages, views);
      }

      return result;
   }

   /**
    * @method viewAll()
    * return a list of all the {ABViewxxx} classes available.
    * @return {array} of ABView objects
    */
   viewAll(fn = () => true) {
      return this.ViewManager.allViews(fn);
   }

   ///
   /// Queries
   ///

   /**
    * queriesExcluded()
    * return a list of ABObjectQuery(s) that are not included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @return {array}
    */
   queriesExcluded(filter = () => true) {
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) == -1;
      }).filter(filter);
   }

   /**
    * queriesIncluded()
    * return a list of ABObjectQuery(s) that are included in this
    * ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which queries to return.
    * @param {fn} [sort] function to sort by, default is .label
    * @return {array}
    */
   queriesIncluded(filter = () => true, sort) {
      // by default sort by label
      const sortFn = sort ?? ((a, b) => a.label.localeCompare(b.label));
      return this.AB.queries((q) => {
         return this.queryIDs.indexOf(q.id) > -1;
      })
         .filter(filter)
         .sort(sortFn);
   }

   ///
   /// Roles
   ///

   /**
    * @method roles()
    * return an array of all the ABRole for this ABApplication.
    * @param {fn} filter
    *        a filter fn to further reduce which roles to return.
    * @return {array}   array of ABRole
    */
   // roles(filter = () => true) {
   //    return (this.role || []).filter(filter);
   // }

   /**
    * @method urlResolve()
    * given an object pointer, return the specific object referenced.
    * pointer must start with a '#', use '/' as delimiters, and either
    * reference an object's .id, or an object's .property.
    * for example:
    * #/_objects   : resolves to the array of ._objects pointed to by this
    *               application.
    * #/_objects/[object.id] : reolved to a specific object
    * #/_objects/[object.id]/_fields/[field.id] : resolves to a specific data field
    *               refereced by object.id.
    *
    * @param {string} pointer : the string url referencing the object you want
    *                       to retrieve.
    * @return {obj}
    */
   urlResolve(pointer) {
      var parts = pointer.split("/");

      var parseStep = (obj, steps) => {
         // we're done.  obj is what we are looking for:
         if (steps.length == 0) {
            return obj;
         }

         // pull the next step key:
         var key = steps.shift();

         // special case, "#" makes sure we are talking about the
         // Application object
         if (key == "#") {
            return parseStep(this, steps);
         }

         // if obj is an [], then key should be an .id reference to
         // lookup:
         if (Array.isArray(obj)) {
            obj = obj.filter(function (o) {
               return o.id == key;
            })[0];
            return parseStep(obj, steps);
         }

         // otherwise obj should be an {} and key a property:
         if (obj && obj[key]) {
            return parseStep(obj[key], steps);
         }

         if (key == "_objects") {
            console.error(new Error("REFACTOR: old objectBy url reference:"));

            // This can be gotten from our AB
            var id = steps.shift();
            return parseStep(this.AB.objectByID(id), steps);
         }

         // if we got here, there is an error!
         // console.error('!!! failed to lookup url:'+pointer);
         console.error("!!! failed to lookup url:" + pointer);
         return null;
      };

      return parseStep(this, parts);
   }

   /**
    * @method urlPointer()
    * return the url pointer for this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      // NOTE: if we need to expand this to search across
      // applications, then add in this application.id here:
      if (acrossApp) return "#/" + this.id + "/";
      else return "#/";
   }

   /**
    * @method urlObject()
    * return the url pointer for objects in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlObject(acrossApp) {
      return this.urlPointer(acrossApp) + "_objects/";
   }

   /**
    * @method urlView()
    * return the url pointer for pages in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPage(acrossApp) {
      return this.urlPointer(acrossApp) + "_pages/";
   }

   /**
    * @method urlQuery()
    * return the url pointer for queries in this application.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlQuery(acrossApp) {
      return this.urlPointer(acrossApp) + "_queries/";
   }

   /**
    * @method version()
    * return the current version of this Application.
    * Version information is in format "{Major}.{Minor}.{patch}"
    * @return {string}
    */
   get version() {
      return this.json?.versionData?.versionNumber ?? "0.0.0";
   }

   ///
   ///   Object List Settings
   ///
   get objectlistIsOpen() {
      return this.objectListSettings.isOpen;
   }

   set objectlistIsOpen(isOpen) {
      this.objectListSettings.isOpen = isOpen;
   }

   get objectlistSearchText() {
      return this.objectListSettings.searchText;
   }

   set objectlistSearchText(searchText) {
      this.objectListSettings.searchText = searchText;
   }

   get objectlistSortDirection() {
      return this.objectListSettings.sortDirection;
   }

   set objectlistSortDirection(sortDirection) {
      this.objectListSettings.sortDirection = sortDirection;
   }

   get objectlistIsGroup() {
      return this.objectListSettings.isGroup;
   }

   set objectlistIsGroup(isGroup) {
      this.objectListSettings.isGroup = isGroup;
   }

   ///
   /// Instance generators
   ///

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABApplication.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      // values.key = ABViewPageCore.common().key;
      values.key = "page";

      return this.ViewManager.newView(values, this, null);
   }

   /**
    * @method pageByID()
    * return pages from the given {id}
    * @param {string} id
    *        the uuid of the page to return.
    * @param {bool} deep
    *        should this search deep (through all our children's children)
    * @return {ABViewPage}
    */
   pageByID(id, deep = true) {
      return this.pages((f) => f.id == id, deep)[0];
   }

   /**
    * @method viewNew()
    *
    * return an instance of a new (unsaved) ABView.
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.ViewManager.newView(values, application, parent);
   }

   ///
   /// Utilities
   ///

   cloneDeep(/* object */) {
      var errorDepreciated = new Error(
         "ABApplicationCore.cloneDeep(): Depreciated!  Use AB.cloneDeep() instead."
      );
      throw errorDepreciated;

      // return JSON.parse(JSON.stringify(object));
   }
};


/***/ }),

/***/ 50085:
/*!****************************************************!*\
  !*** ./AppBuilder/core/ABApplicationMobileCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABApplicationMobileCore
 *
 * This is the core ABApplicationMobile class that manages the common operations
 * of a Mobile PWA ABApplication.
 */

// webpack can handle 'require()' statements, but node can't handle import
// so let's use require():
const ABViewManagerMobile = __webpack_require__(/*! ../platform/ABViewManagerMobile */ 69155);
var ABApplication = __webpack_require__(/*! ../platform/ABApplication */ 95995);

module.exports = class ABApplicationMobileCore extends ABApplication {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.appType = "mobile"; // Just making sure.
      this.networkType = attributes.networkType;

      this.pageDefault = attributes.pageDefault;
      // {uuid}
      // the {ABMobilePage}.uuid of the page that is our default Page.
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   get ViewManager() {
      return ABViewManagerMobile;
   }

   pageNew(def) {
      console.error("TODO: pageNew for ApplicationMobile");
      return null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var json = super.toObj();
      json.appType = "mobile";
      json.networkType = this.networkType;

      json.pageDefault = this.pageDefault;

      return json;
   }
};


/***/ }),

/***/ 5179:
/*!*************************************************!*\
  !*** ./AppBuilder/core/ABDataCollectionCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABDataCollection
 * Defines a set of data that other parts of the Application can work with.
 * it can point to either an ABObject, or ABObjectQuery, and can have an
 * filter, and sorts defined.
 *
 *
 *
 */
// const ABEmitter = require("../platform/ABEmitter");
const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);

// const ABObject = require("../platform/ABObject");
// const ABObjectQuery = require("../platform/ABObjectQuery");
// const RowFilter = require("../platform/RowFilter");

var DefaultValues = {
   id: "uuid",
   label: "", // label
   object: {}, // json of ABObject
   query: {}, // json of ABObjectQuery
   settings: {
      datasourceID: "", // id of ABObject or ABObjectQuery
      linkDatacollectionID: "", // id of ABDatacollection
      linkFieldID: "", // id of ABField
      followDatacollectionID: "", // id of ABDatacollection
      objectWorkspace: {
         filterConditions: {
            // array of filters to apply to the data table
            glue: "and",
            rules: [],
         },
         sortFields: [], // array of columns with their sort configurations
      },
      loadAll: false,
      // preventPopulate: false, depreciating in favour of populate
      populate: true, // true/false or array of columns to populate.
      isQuery: false, // if true it is a query, otherwise it is a object.

      fixSelect: "", // _CurrentUser, _FirstRecord, _FirstRecordDefault or row id

      syncType: 1, // 1 (Server), 2 (Client)
   },
};

const QueuedOperations = [];
// {array} of operations that we want to perform but allow some space
// between operations.
var _queueTimer = null;

function runQueue() {
   // if (!_queueTimer) {
   //    _queueTimer = setInterval(() => {
   //       runQueue();
   //    }, 20);
   // }
   if (QueuedOperations.length == 0) {
      // stop
      // clearInterval(_queueTimer);
      _queueTimer = null;
      return;
   }
   var op = QueuedOperations.shift();
   op.fn();
   _queueTimer = setTimeout(runQueue, op.timeout);
}
function queueOperation(fn, timeout = 20) {
   QueuedOperations.push({ fn, timeout });
   if (!_queueTimer) {
      runQueue();
   }
}

module.exports = class ABDataCollectionCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      attributes = attributes || {};

      // this.application = application;

      this.fromValues(attributes);

      this.__dataCollection = this._dataCollectionNew([]);
      // {DataCollection}
      // This is a working instance of a DataCollection, not an {ABDatacCollection}
      // On web/mobile this is a webix component.  So keep the creation as part of
      // the platform/ABDataCollection implementation.

      // Set filter value
      this.refreshFilterConditions();

      this.__bindComponentIds = [];
      this.__flexComponentIds = [];

      // refresh a data collection
      // this.init();

      // mark data status does not be initialized
      this._dataStatus = this.dataStatusFlag.notInitial;

      this.__filterCond = null;
      // {QueryCondition}
      // A passed in Query Condition for filtering our DataCollection.
      // This value is ANDed with our normal filter conditions.
   }

   /**
    * contextKey()
    *
    * return a unique key that represents data from/for this type of object.
    *
    * used when creating Network jobs and needing to be notified when a job
    * is complete.  We send a contextKey() to the Network job and then listen
    * for it to know when it is complete.
    * @return {string}
    */
   static contextKey() {
      return "datacollection";
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id;
      // {string} .id
      // the uuid of this ABDataCollection Definition.

      this.name = values.name || null;
      // {string} .name
      // the unchanging name of this ABDataCollection

      this.type = values.type || "datacollection";
      // {string} .type
      // the type of ABDefinition this is.

      values.settings = values.settings || {};
      this.settings = this.settings || {};
      // {obj} .settings
      // the specific operation values for this ABDataCollection

      this.settings.linkDatacollectionID =
         values.settings.linkDatacollectionID ||
         DefaultValues.settings.linkDatacollectionID;
      // {string} .settings.linkDatacollectionID
      // the uuid of another ABDataCollection that provides the link/trigger
      // for filtering the values of this ABDataCollection.

      this.settings.linkFieldID =
         values.settings.linkFieldID || DefaultValues.settings.linkFieldID;
      // {string} .settings.linkFieldID
      // this.fieldLink is intended to be the way to connect to the column in
      // the datacollectionLink that we are following.  However this field
      // is the field in this.datasource that connects to the field in
      // datacollectionLink that has the value we are linked to.
      // So, If this DC(ObjB), and our datacollectionLink (ObjA)
      // then this.fieldLink = ObjB->FieldB
      // To find the corresponding field in ObjA, we do:
      // this.fieldLink.fieldLink  (ObjA->FieldA)

      this.settings.followDatacollectionID =
         values.settings.followDatacollectionID ||
         DefaultValues.settings.followDatacollectionID;
      // {string} .settings.followDatacollectionID
      // the uuid of another ABDataCollection that provides the follow cursor data collection

      this.settings.objectWorkspace = values.settings.objectWorkspace || {
         filterConditions:
            DefaultValues.settings.objectWorkspace.filterConditions,
         sortFields: DefaultValues.settings.objectWorkspace.sortFields,
      };
      // {obj} .settings.objectWorkspace
      // the default settings for what is shown in the AppBuilder's
      // DataCollection workspace

      this.settings.fixSelect = values.settings.fixSelect;

      // Convert to boolean
      this.settings.loadAll = JSON.parse(
         values.settings.loadAll || DefaultValues.settings.loadAll
      );
      // {bool} .settings.loadAll
      // do we load all the data at one time? false == load by pages.

      this.settings.isQuery = JSON.parse(
         values.settings.isQuery || DefaultValues.settings.isQuery
      );
      // {bool} .settings.isQuery
      // is the data source for this ABDataCollection based upon an
      // ABObjectQuery?

      this.settings.populate = (() => {
         // First check .populate
         if (values.settings.populate != undefined) {
            return values.settings.populate;
            // Then check legacy .preventPopulate
         } else if (
            values.settings.preventPopulate == true ||
            values.settings.preventPopulate == "1"
         ) {
            return false;
         } else return DefaultValues.settings.populate;
      })();
      // {bool | array} populate
      // Control whcih related connections to populate. Default, true, populates
      // all connections. False loads no connnections. Also accepts an array of
      // column names to load specefic connections.

      // Convert to number
      this.settings.syncType = parseInt(
         values.settings.syncType || DefaultValues.settings.syncType
      );
      // {int} .settings.syncType
      // how is the data between this ABDataCollection and it's
      // .datasource synced?

      this.__datasource = null;
      // {obj} .__datasource
      // the reference to the ABObject/ABObjectQuery that this ABDataCollection
      // is based off of.

      this.settings.datasourceID =
         values.settings.datasourceID || DefaultValues.settings.datasourceID;
      // {string} .settings.datasourceID
      // the uuid of the .__datasource object to use

      // now lookup and reference the proper datasource
      if (this.settings.datasourceID) {
         // check for an ABObject
         var obj = this.AB.objectByID(this.settings.datasourceID);
         if (!obj) {
            // this must be an ABObjectQuery then ...
            obj = this.AB.queryByID(this.settings.datasourceID);
         }

         if (obj) {
            this.__datasource = obj;
            this.settings.isQuery = obj.type === "query";
            if (this.settings.isQuery) {
               if (this.__datasource.isGroup) {
                  if (!this.__treeCollection)
                     this.__treeCollection = this._treeCollectionNew();
                  // {TreeCollection}
                  // This is a webix TreeCollection (or similar)
                  // keep it's implementation as part of the platform

                  this.__isGroup = true;
               }
            }
         } else {
            console.error(
               `ABDataCollection[${this.name}][${this.id}] unable to find datasource [${this.settings.datasourceID}]`
            );
         }
      }

      // // Populate data source: ABObject or ABObjectQuery
      // if (values.query && values.query[0]) {
      //    this.__datasource = new ABObjectQuery(
      //       values.query[0],
      //       this.application
      //    );
      //    this.settings.isQuery = true;

      //    if (this.__datasource.isGroup) {
      //       if (!this.__treeCollection)
      //          this.__treeCollection = this._treeCollectionNew();

      //       this.__isGroup = true;
      //    }
      // } else if (values.object && values.object[0]) {
      //    this.__datasource = new ABObject(values.object[0], this.application);
      //    this.settings.isQuery = false;
      // }

      // let the MLClass now process the translations:
      super.fromValues(values);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj(); // untranslate the object

      return {
         id: this.id,
         name: this.name || this.label,
         type: this.type || "datacollection",
         settings: this.AB.cloneDeep(this.settings || {}),
         translations: obj.translations,
      };
   }

   /**
    * @method save()
    *
    * persist this instance of ABDatacollection with it's parent
    *
    *
    * @return {Promise}
    *      .resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      return this;
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABDatacollection
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      var removeFromApplications = () => {
         return new Promise((next, err) => {
            // this.AB.applications().then((apps) => {

            const apps = this.AB.applications();
            // NOTE: apps is a webix datacollection

            var allRemoves = [];

            var appsWithObject = apps.filter((a) => {
               return a.datacollectionsIncluded((o) => o.id == this.id);
            });
            appsWithObject.forEach((app) => {
               allRemoves.push(app.datacollectionRemove(this));
            });

            return Promise.all(allRemoves).then(next).catch(err);
            // });
         });
      };

      return Promise.resolve()
         .then(() => {
            return removeFromApplications();
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @property $dc
    * return the underlying webix datacollection
    * @return {webix.datacollection}
    */
   get $dc() {
      return this.__dataCollection;
   }

   /**
    * @property datasource
    * return a object of this component.
    *
    * @return {ABObject|ABObjectQuery}
    */
   get datasource() {
      if (!this.__datasource) {
         if (this.id && this.name) {
            // occassionally we have blank DCs (without .id or .name)
            // and I don't want to see errors for those
            var err = new Error(
               `DataCollection[${this.name}][${this.id}] missing reference datasource`
            );
            this.AB.notify("builder", err, { datacollection: this.toObj() });
         }
         return null;
      }
      var obj = this.AB.objectByID(this.__datasource.id);
      if (!obj) {
         obj = this.AB.queryByID(this.__datasource.id);
      }
      return obj;
   }

   /**
    * @property datasource
    * set a object to data collection
    *
    * @param {ABObject|ABObjectQuery} object
    */
   set datasource(object) {
      this.__datasource = object;

      this.refreshFilterConditions();
   }

   /**
    * @property sourceType
    * return type of source.
    *
    * @return {string} - 'object' or 'query'
    */
   get sourceType() {
      return this.settings.isQuery ? "query" : "object";
   }

   /**
    * @method datacollectionLink
    * return a ABDatacollection that link of this.
    *
    * @return {ABDatacollection}
    */
   get datacollectionLink() {
      if (!this.AB) return null;

      return this.AB.datacollectionByID(this.settings.linkDatacollectionID);
   }

   /**
    * @property fieldLink
    * return a ABFieldConnect field that link of this.
    *
    * @return {ABFieldConnect}
    */
   get fieldLink() {
      let object = this.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.linkFieldID);
   }

   /**
    * @property model
    * return a source model
    *
    * @return ABModel
    */
   get model() {
      let object = this.datasource; // already notified

      return object ? object.model() : null;
   }

   get dataStatusFlag() {
      return {
         notInitial: 0,
         initializing: 1,
         initialized: 2,
      };
   }

   get dataStatus() {
      return this._dataStatus;
   }

   ///
   /// Cursor
   ///

   setCursor(itemId) {
      // If the static cursor is set, then this DC could not set cursor to other rows
      if (
         this.settings.fixSelect &&
         (this.settings.fixSelect != "_FirstRecordDefault" ||
            this.settings.fixSelect == itemId)
      )
         return;

      if (this.__treeCollection) {
         // set cursor of tree collection
         this.setCursorTree(itemId);

         // pull current row id
         let currTreeId = this.__treeCollection.getCursor();
         if (currTreeId) {
            let currTreeItem = this.__treeCollection.getItem(currTreeId);
            if (currTreeItem) itemId = currTreeItem._itemId;
         }
      }

      let dc = this.__dataCollection;
      if (dc) {
         // Store the old cursor id
         this.__previousCursorId = dc.getCursor();

         // clear cursor
         if (itemId == null) {
            dc.setCursor(null);
         }
         // If set rowId equal current cursor, it will not trigger .onAfterCursorChange event
         else if (dc.getCursor() == itemId) {
            this.emit("changeCursor", this.getCursor());
         }
         // set new cursor
         else if (dc.exists(itemId)) {
            dc.setCursor(itemId);
         }
      }
   }

   /**
    *
    * @param {string|number} itemId - Id of item or Id of row data
    */
   setCursorTree(itemId) {
      let tc = this.__treeCollection;
      if (tc && tc.getCursor() != itemId) {
         // If it is id of tree collection, then find row id of data
         let treeCursor = tc.find({ id: itemId }, true);
         if (treeCursor) {
            tc.setCursor(itemId);
         }
         // If it is not id of tree collection, then find/set root of data
         else {
            let treeItem = tc.find({ _itemId: itemId, $parent: 0 }, true);
            if (treeItem) tc.setCursor(treeItem.id);
            else tc.setCursor(null);
         }
      }
   }

   getCursor(treeCursor = false) {
      // Cursor of tree collection
      if (treeCursor && this.__treeCollection) {
         let currId = this.__treeCollection.getCursor();
         if (currId) {
            let currItem = this.__treeCollection.getItem(currId);

            // filter current id for serialize
            this.__treeCollection.filter(
               (item) => item._itemId == currItem._itemId
            );

            // pull item with child items
            let currItemAndChilds =
               this.__treeCollection.serialize()[0] || null;

            // refresh filter
            this.refreshLinkCursor();

            return currItemAndChilds;
         }
      }

      let dc = this.__dataCollection;
      if (dc == null) return null;

      let currId = dc.getCursor();
      let currItem = dc.getItem(currId);

      return currItem;
   }

   getFirstRecord() {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getFirstId();
      var currItem = dc.getItem(currId);

      return currItem;
   }

   getNextRecord(record) {
      var dc = this.__dataCollection;
      if (dc == null) return null;

      var currId = dc.getNextId(record.id);
      var currItem = dc.getItem(currId);

      return currItem;
   }

   /**
    * @method refreshLinkCursor
    *    If the data collection is bound to another and it is the child connection
    *    it finds it's parents current set cursor and then filters its data
    *    based off of the cursor.
    *
    *    In cases where a DC has set .loadAll, our job is to filter existing data
    *    that is already loaded in the internal __dataCollection.
    *
    *    Otherwise this is not the place to trigger a data refresh.  We depend
    *    on other mechanisms (.reloadData(), datacollection .select()) to trigger
    *    an update.
    */
   refreshLinkCursor(force = false) {
      // our filter conditions need to know there was an updated cursor.
      // some of our filters are based upon our linked data.
      this.refreshFilterConditions();

      // NOTE: If DC does not set load all data, then it does not need to filter by the parent DC.
      // because it fetch data when the cursor of the parent DC changes.
      if (!this.settings.loadAll && !force) return;

      // do not set the filter unless this dc is initialized "dataStatusFlag==2"
      // if (this.dataStatus != this.dataStatusFlag.initialized) return;

      // filter the data in the data collection
      // using its parents current cursor because all the data in this child
      // data collection has been loaded and the frontend can decide what is
      // seen or not seen
      let linkCursor;
      let dvLink = this.datacollectionLink;
      if (dvLink) {
         linkCursor = dvLink.getCursor();
      }

      let filterData = (rowData) => {
         // This row is not loaded yet. It will be loaded when scrolling.
         if (rowData == null) return true;

         // if link dc cursor is null:
         // ... if there's no parent show all data
         // ... if we have a parent hide all data - address cases where user see
         //     unexpected data (ns_app#318) - should this be a DC setting?
         if (!linkCursor) return dvLink ? false : true;
         else return this.isParentFilterValid(rowData);
      };

      if (this.__dataCollection) this.__dataCollection.filter(filterData);
      if (this.__treeCollection) this.__treeCollection.filter(filterData);
   }

   setStaticCursor() {
      if (this.settings.fixSelect) {
         // set cursor to the current user
         if (this.settings.fixSelect == "_CurrentUser") {
            var username = this.currentUserUsername();
            var userFields = this.datasource.fields((f) => f.key == "user");

            // find a row that contains the current user
            var row = this.__dataCollection.find((r) => {
               var found = false;

               userFields.forEach((f) => {
                  if (found || r[f.columnName] == null) return;

                  if (r[f.columnName].filter) {
                     // Array - isMultiple
                     found =
                        r[f.columnName].filter((data) => data.id == username)
                           .length > 0;
                  } else if (r[f.columnName] == username) {
                     found = true;
                  }
               });

               return found;
            }, true);

            // set a first row of current user to cursor
            if (row) {
               this.__dataCollection.setCursor(row.id);

               this.setCursorTree(row.id);
            }
         } else if (
            this.settings.fixSelect == "_FirstRecord" ||
            this.settings.fixSelect == "_FirstRecordDefault"
         ) {
            // // find a row that contains the current user
            // var row = this.__dataCollection.find((r) => {

            //  var found = false;
            //  if (!found) {
            //    found = true;
            //    return true; // just give us the first record
            //  }

            // }, true);

            // // set a first row of current user to cursor
            // if (row)
            //  this.__dataCollection.setCursor(row.id);

            let currRowId = this.__dataCollection.getCursor();
            if (
               !currRowId ||
               (currRowId && !this.__dataCollection.exists(currRowId))
            ) {
               // If current cursor is filtered by parent DC, then select new cursor

               // set a first row to cursor
               let rowId = this.__dataCollection.getFirstId();
               // if (rowId) {
               this.__dataCollection.setCursor(rowId || null);

               if (this.__dataCollection.data.count() == 0) {
                  this.emit("collectionEmpty", {});
               }

               this.setCursorTree(rowId);
               // }
            }
         } else {
            this.__dataCollection.setCursor(this.settings.fixSelect);

            this.setCursorTree(this.settings.fixSelect);
         }
      }

      // Set the cursor to the first row
      if (this.isCursorFollow) {
         const rowId = this.__dataCollection.getFirstId();
         this.setCursor(rowId || null);
         this.setCursorTree(rowId || null);

         // If no data but the parent DC set cursor, then this should be reload data.
         const dcFollow = this.datacollectionFollow;
         if (!rowId && dcFollow?.getCursor()) {
            this.loadData();
         }
      }
   }

   ///
   /// Data
   ///

   /**
    * @method filterCondition()
    * Provide a temporary filter condition to modify the data we are returning.
    * Used by User search criterias.
    * @param {json} cond
    *        A valid QueryCondition to filter the response.
    */
   filterCondition(cond = null) {
      this.__filterCond = cond;
   }

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      this.initialized = true;

      if (!this.__dataCollection.___AD.onAfterCursorChange) {
         this.__dataCollection.___AD.onAfterCursorChange =
            this.__dataCollection.attachEvent("onAfterCursorChange", () => {
               // debugger;
               var currData = this.getCursor();

               this.emit("changeCursor", currData);
            });
      }

      // relate data functions
      let isRelated = (relateData, rowId, PK = "id") => {
         if (Array.isArray(relateData)) {
            return relateData.filter((v) => (v[PK] || v) == rowId).length > 0;
         } else {
            return relateData && (relateData[PK] || relateData) == rowId;
         }
      };

      // events
      this.on("ab.datacollection.create", (data) => {
         // If this DC is following cursor for other DC, then it should not add the new item to their list.
         if (this.isCursorFollow) return;

         let obj = this.datasource;
         if (!obj) return;

         if (!data || !data.data) return;

         let needAdd = false;
         let updatedVals = [];

         Promise.resolve()
            .then(() => {
               return new Promise((next, bad) => {
                  // Query
                  if (obj instanceof this.AB.Class.ABObjectQuery) {
                     let objList =
                        obj.objects((o) => o.id == data.objectId) || [];

                     needAdd = objList.length > 0;

                     if (!needAdd) return next();

                     let where = {
                        glue: "or",
                        rules: [],
                     };

                     objList.forEach((o) => {
                        let newDataId = data.data[`${o.PK()}`];
                        if (!newDataId) return;

                        where.rules.push({
                           key: `${o.alias || obj.objectAlias(o.id)}.${o.PK()}`,
                           rule: "equals",
                           value: newDataId,
                        });
                     });

                     obj.model()
                        .findAll({
                           where: where,
                        })
                        .then((newQueryData) => {
                           updatedVals = newQueryData.data || [];
                           updatedVals.forEach((v) => {
                              delete v.id;
                           });

                           next();
                        })
                        .catch(bad);
                  }
                  // Object
                  else {
                     needAdd = obj.id == data.objectId;
                     updatedVals = [data.data];
                     next();
                  }
               });
            })
            .then(() => {
               if (needAdd) {
                  // normalize data before add to data collection
                  // var model = obj.model();

                  // UPDATE: this should already have happened in NetworkRestSocket
                  // when the initial data is received.
                  //model.normalizeData(updatedVals);

                  (updatedVals || []).forEach((updatedV) => {
                     // filter condition before add
                     if (!this.isValidData(updatedV)) return;

                     // filter the cursor of parent DC
                     const dcLink = this.datacollectionLink;
                     if (dcLink && !this.isParentFilterValid(updatedV)) return;

                     // check to see if item already exisits in data collection
                     // and check to see that we are not loading the data serverside from cursor
                     if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        !this.__reloadWheres
                     ) {
                        this.__dataCollection.add(updatedV, 0);
                        this.emit("create", updatedV);
                        // this.__dataCollection.setCursor(rowData.id);
                     } else if (
                        !this.__dataCollection.exists(
                           updatedV[`${obj.PK()}`]
                        ) &&
                        this.__reloadWheres
                     ) {
                        // debugger;
                        if (this.isParentFilterValid(updatedV)) {
                           // we track bound components and flexlayout components
                           var attachedComponents =
                              this.__bindComponentIds.concat(
                                 this.__flexComponentIds
                              );
                           attachedComponents.forEach((bcids) => {
                              // if the reload button already exisits move on
                              if ($$(bcids + "_reloadView")) {
                                 return false;
                              }

                              // find the position of the data view
                              var pos = 0;
                              var parent = $$(bcids).getParentView();
                              if ($$(bcids).getParentView().index) {
                                 pos = $$(bcids)
                                    .getParentView()
                                    .index($$(bcids));
                              } else if (
                                 $$(bcids).getParentView().getParentView().index
                              ) {
                                 // this is a data view and it is inside a
                                 // scroll view that is inside an accodion
                                 // so we need to go deeper to add the button
                                 parent = $$(bcids)
                                    .getParentView()
                                    .getParentView();
                                 pos = $$(bcids)
                                    .getParentView()
                                    .getParentView()
                                    .index($$(bcids).getParentView());
                              }

                              // store the datacollection so we can pass it to the button later
                              var DC = this;
                              // add a button that reloads the view when clicked
                              if (parent.addView) {
                                 var L = this.AB.Label();
                                 parent.addView(
                                    {
                                       id: bcids + "_reloadView",
                                       view: "button",
                                       value: L(
                                          "New data available. Click to reload."
                                       ),
                                       css: "webix_primary webix_warn",
                                       click: function (id, event) {
                                          DC.reloadData();
                                          $$(id).getParentView().removeView(id);
                                       },
                                    },
                                    pos
                                 );
                              }
                           });
                           // this.emit("create", updatedV);
                        }
                     }
                  });

                  if (
                     this.__treeCollection // && this.__treeCollection.exists(updatedVals.id)
                  ) {
                     this.parseTreeCollection({
                        data: updatedVals,
                     });
                  }
               }

               // ABObject only
               if (!(obj instanceof this.AB.Class.ABObjectQuery)) {
                  // if it is a linked object
                  let connectedFields = this.datasource.connectFields(
                     (f) =>
                        f.datasourceLink && f.datasourceLink.id == data.objectId
                  );

                  // It should always be only one item for ABObject
                  updatedVals = updatedVals[0];

                  // update relation data
                  if (
                     updatedVals &&
                     connectedFields &&
                     connectedFields.length > 0
                  ) {
                     // various PK name
                     let PK = connectedFields[0].object.PK();
                     if (!updatedVals.id && PK != "id")
                        updatedVals.id = updatedVals[PK];

                     this.__dataCollection.find({}).forEach((d) => {
                        let updateItemData = {};

                        connectedFields.forEach((f) => {
                           var updateRelateVal = {};
                           if (f && f.fieldLink) {
                              updateRelateVal =
                                 updatedVals[f.fieldLink.relationName()] || {};
                           }

                           let rowRelateVal = d[f.relationName()] || {};

                           let valIsRelated = isRelated(
                              updateRelateVal,
                              d.id,
                              PK
                           );

                           // Relate data
                           if (
                              Array.isArray(rowRelateVal) &&
                              rowRelateVal.filter(
                                 (v) =>
                                    v == updatedVals.id ||
                                    v.id == updatedVals.id ||
                                    v[PK] == updatedVals.id
                              ).length < 1 &&
                              valIsRelated
                           ) {
                              rowRelateVal.push(updatedVals);

                              updateItemData[f.relationName()] = rowRelateVal;
                              updateItemData[f.columnName] = updateItemData[
                                 f.relationName()
                              ].map((v) => v.id || v[PK] || v);
                           } else if (
                              !Array.isArray(rowRelateVal) &&
                              (rowRelateVal != updatedVals.id ||
                                 rowRelateVal.id != updatedVals.id ||
                                 rowRelateVal[PK] != updatedVals.id) &&
                              valIsRelated
                           ) {
                              updateItemData[f.relationName()] = updatedVals;
                              updateItemData[f.columnName] =
                                 updatedVals.id || updatedVals;
                           }
                        });

                        // If this item needs to update
                        if (Object.keys(updateItemData).length > 0) {
                           // normalize data before add to data collection
                           var model = obj.model();

                           // UPDATE: this should already have happened in NetworkRestSocket
                           // when the initial data is received.
                           // model.normalizeData(updateItemData);

                           this.__dataCollection.updateItem(
                              d.id,
                              updateItemData
                           );

                           if (this.__treeCollection)
                              this.__treeCollection.updateItem(
                                 d.id,
                                 updateItemData
                              );

                           this.emit(
                              "update",
                              this.__dataCollection.getItem(d.id)
                           );
                        }
                     });
                  }
               }

               this.updateRelationalDataFromLinkDC(data.objectId, data.data);
               // filter link data collection's cursor
               this.refreshLinkCursor();
               this.setStaticCursor();
            });
      });

      this.on("ab.datacollection.update", (data) => {
         // {json} data
         // incoming socket payload:
         // data.objectId {string} uuid of the ABObject's row that was updated
         // data.data {json} the new updated value of that row entry.

         let obj = this.datasource;
         if (!obj) return;

         // updated values
         let values = data.data;
         if (!values) return;

         // #Johnny: removing this check.  A DC that is following another cursor
         // still has a value that might need updating.
         // DC who is following cursor should update only current cursor.
         // if (
         //    this.isCursorFollow &&
         //    this.getCursor()?.id != (values[obj.PK()] ?? values.id)
         // ) {
         //    return;
         // }

         let needUpdate = false;
         let isExists = false;
         let updatedIds = [];
         // {array}
         // an array of the row indexs in our DataCollection that have values
         // that need to be updated.

         let updatedTreeIds = [];
         let updatedVals = {};

         //
         // Case 1: This DC contains the value that was updated
         // In this case, we want to replace our current entry with
         // the new one passed in.
         // EX: This is a DC of Users, and the incoming Entry is a User
         // that we are already displaying.
         //

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needUpdate = objList.length > 0;
            if (needUpdate) {
               (objList || []).forEach((o) => {
                  updatedIds = updatedIds.concat(
                     this.__dataCollection
                        .find((item) => {
                           return (
                              item[
                                 `${this.datasource.objectAlias(
                                    o.id
                                 )}.${o.PK()}`
                              ] == (values[o.PK()] || values.id)
                           );
                        })
                        .map((o) => o.id) || []
                  );

                  // grouped queries
                  if (this.__treeCollection) {
                     updatedTreeIds = updatedTreeIds.concat(
                        this.__treeCollection
                           .find((item) => {
                              return (
                                 item[
                                    `${this.datasource.objectAlias(
                                       o.id
                                    )}.${o.PK()}`
                                 ] == (values[o.PK()] || values.id)
                              );
                           })
                           .map((o) => o.id) || []
                     );
                  }
               });

               isExists = updatedIds.length > 0;

               updatedVals = this._queryUpdateData(objList, values);
            }
         }
         // Object
         else {
            needUpdate = obj.id == data.objectId;
            if (needUpdate) {
               // various PK name
               if (!values.id && obj.PK() != "id") values.id = values[obj.PK()];

               updatedIds.push(values.id);

               isExists = this.__dataCollection.exists(values.id);
               updatedVals = values;
            }
         }

         // if it is the source object
         if (needUpdate) {
            if (isExists) {
               if (this.isValidData(updatedVals)) {
                  // only spread around cloned copies because some objects (I'm
                  // looking at you ABFieldUser) will modify some data for local
                  // usage.
                  updatedVals = this.AB.cloneDeep(updatedVals);
                  if (this.__dataCollection) {
                     updatedIds = this.AB.uniq(updatedIds);
                     updatedIds.forEach((itemId) => {
                        this.__dataCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  if (this.__treeCollection) {
                     // update data in tree
                     updatedTreeIds = this.AB.uniq(updatedTreeIds);
                     updatedTreeIds.forEach((itemId) => {
                        this.__treeCollection.updateItem(itemId, updatedVals);
                     });
                  }

                  this.emit("update", updatedVals);

                  // If the update item is current cursor, then should tell components to update.
                  let currData = this.getCursor();
                  if (currData?.id == updatedVals.id) {
                     this.emit("cursorStale", currData);
                  }
               } else {
                  // Johnny: Here we are simply removing the DataCollection Entries that are
                  // no longer valid.
                  // Just cycle through the collected updatedIds and remove them.
                  let currData = this.getCursor();
                  updatedIds.forEach((id) => {
                     // If the item is current cursor, then the current cursor should be cleared.

                     if (currData?.id == id) this.emit("cursorStale", null);

                     this.__dataCollection.remove(id);

                     // TODO: update tree list
                     // if (this.__treeCollection) {
                     //  this.__treeCollection.remove(id);
                     // }

                     this.emit("delete", id);
                  });
               }
            }
            // filter before add new record
            else if (this.isValidData(updatedVals)) {
               // this means the updated record was not loaded yet so we are adding it to the top of the grid
               // the placement will probably change on the next load of the data
               this.__dataCollection.add(updatedVals, 0);

               if (this.__treeCollection)
                  this.parseTreeCollection({
                     data: [updatedVals],
                  });

               this.emit("create", updatedVals);
            }
         }

         //
         // Case 2: This DC has entries that CONNECT to the updated value.
         // We need to make sure our connections, properly reflect the
         // current state of the incoming data.
         //
         // EG: This DC is a list of Roles that connect to User, and an updated
         // User is passed in.

         let currCursor = this.getCursor();
         let updateCursor = null;

         // if it is a linked object
         // look for connected fields that link to the incoming objectId
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields?.length > 0
         ) {
            // various PK name
            // webix datacollections require an .id value, so make sure
            // this incoming value has an .id set
            let PK = obj.PK();
            if (!values.id && PK != "id") values.id = values[PK];

            if (this.__dataCollection.count() > 0) {
               this.__dataCollection.find({}).forEach((d) => {
                  let updateItemData = {
                     id: d.id,
                  };

                  connectedFields.forEach((f) => {
                     if (!f) return;

                     let updateRelateVal = {};
                     let rowRelateVal = d[f.relationName()] || {};

                     if (f.fieldLink)
                        updateRelateVal =
                           values[f.fieldLink.relationName()] || {};

                     // check to see if we are supposed to be related to this
                     let valIsRelated = isRelated(updateRelateVal, d.id, PK);

                     // If NO, then make sure we Unrelate data
                     // if this is an array -> filter out the entry
                     if (
                        Array.isArray(rowRelateVal) &&
                        rowRelateVal.filter(
                           (v) =>
                              v == values.id ||
                              v.id == values.id ||
                              v[PK] == values.id
                        ).length > 0 &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = rowRelateVal.filter(
                           // NOTE: Special case: the incoming value.id will be .uuid
                           // however in case of User Fields, v.id == username and not .uuid
                           // so we put our default check to be v[PK] here to play nice
                           (v) => (v[PK] || v.id || v) != values.id
                        );
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map((v) => v.id || v[PK] || v);
                     } else if (
                        // this is not an array so set link to null
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal == values.id ||
                           rowRelateVal.id == values.id ||
                           rowRelateVal[PK] == values.id) &&
                        !valIsRelated
                     ) {
                        updateItemData[f.relationName()] = null;
                        updateItemData[f.columnName] = null;
                     }

                     // However, if we are supposed to be related => make sure we are
                     // If this is an array, then add to list
                     // AND YES: make sure it is cloned
                     if (valIsRelated) {
                        values = this.AB.cloneDeep(values);
                     }
                     if (Array.isArray(rowRelateVal) && valIsRelated) {
                        // update relate data
                        if (
                           rowRelateVal.filter(
                              (v) =>
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                           ).length > 0
                        ) {
                           // just update the one entry in my array with the new
                           // value
                           rowRelateVal.forEach((v, index) => {
                              if (
                                 v == values.id ||
                                 v.id == values.id ||
                                 v[PK] == values.id
                              )
                                 rowRelateVal[index] = values;
                           });
                        }
                        // add new relate
                        else {
                           rowRelateVal.push(values);
                        }

                        updateItemData[f.relationName()] = rowRelateVal;
                        updateItemData[f.columnName] = updateItemData[
                           f.relationName()
                        ].map(
                           (v) => f.getRelationValue(v) /*v.id || v[PK] || v*/
                        );
                     } else if (
                        !Array.isArray(rowRelateVal) &&
                        (rowRelateVal != values.id ||
                           rowRelateVal.id != values.id ||
                           rowRelateVal[PK] != values.id) &&
                        valIsRelated
                     ) {
                        updateItemData[f.relationName()] = values;
                        // make ConnectedField use .getRelationValue() here!
                        updateItemData[f.columnName] =
                           f.getRelationValue(values);
                     }
                  });

                  // If this item needs to update
                  // meaning there is > 1 key in the object (we always have .id)
                  if (Object.keys(updateItemData).length > 1) {
                     // normalize data before add to data collection
                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.

                     // NOTE: We could not normalize relational data because they are not full data
                     // Merge update data to exists data instead

                     if (this.__treeCollection?.exists(d.id)) {
                        const treeItem = Object.assign(
                           this.__treeCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__treeCollection.updateItem(d.id, treeItem);
                     }

                     if (this.__dataCollection?.exists(d.id)) {
                        const dcItem = Object.assign(
                           this.__dataCollection.getItem(d.id),
                           updateItemData
                        );
                        this.__dataCollection.updateItem(d.id, dcItem);
                        this.emit(
                           "update",
                           this.__dataCollection.getItem(d.id)
                        );
                        if (currCursor?.id == dcItem.id) {
                           updateCursor = dcItem;
                        }
                     }
                  }
               });
            }
         }

         //
         // Case 3: Our DC is linked to a DC that was effected by this update.
         //
         // We will approach it from another direction, if the current DC made
         // an update to it's current Cursor, then we will emit a "cursorStale"
         // event, so our linked DCs will update themselves with the new value:
         if (updateCursor) {
            this.emit("cursorStale", null);
         }
         // this.updateRelationalDataFromLinkDC(data.objectId, values);
         this.refreshLinkCursor();

         this.setStaticCursor();
      });

      // We are subscribing to notifications from the server that an item may be stale and needs updating
      // We will improve this later and verify that it needs updating before attempting the update on the client side
      this.on("ab.datacollection.stale", (data) => {
         // debugger;
         // if we don't have a datasource or model, there is nothing we can do here:
         // Verify the datasource has the object we are listening for if not just stop here
         if (
            !this.datasource ||
            !this.model ||
            this.datasource.id != data.objectId
         ) {
            return;
         }

         // updated values
         var values = data.data;

         if (!values) return;

         // use the Object's defined Primary Key:
         var PK = this.model.object.PK();
         if (!values[PK]) {
            PK = "id";
         }

         // DC who is following cursor should update only current cursor.
         if (
            this.isCursorFollow &&
            this.getCursor()?.[PK] != (values[PK] ?? values.id)
         ) {
            return;
         }

         if (values) {
            if (this.__dataCollection.exists(values[PK])) {
               var cond = { where: {} };
               cond.where[PK] = values[PK];
               // this data collection has the record so we need to query the server to find out what it's latest data is so we can update all instances
               this.model.staleRefresh(cond).then((res) => {
                  // check to make sure there is data to work with
                  if (Array.isArray(res.data) && res.data.length) {
                     // debugger;
                     let obj = this.datasource;
                     if (!obj) return;
                     // normalize data before add to data collection

                     // UPDATE: this should already have happened in NetworkRestSocket
                     // when the initial data is received.
                     //var model = obj.model();
                     // model.normalizeData(res.data[0]);

                     // tell the webix data collection to update using their API with the row id (values.id) and content (res.data[0])
                     if (this.__dataCollection.exists(values[PK])) {
                        this.__dataCollection.updateItem(
                           values[PK],
                           res.data[0]
                        );
                     }

                     // If the update item is current cursor, then should tell components to update.
                     var currData = this.getCursor();
                     if (currData?.[PK] == values[PK]) {
                        this.emit("cursorStale", currData);
                     }
                  } else {
                     // If there is no data in the object then it was deleted...lets clean things up
                     // If the deleted item is current cursor, then the current cursor should be cleared.
                     var currId = this.getCursor();
                     if (currId == values[PK]) this.emit("cursorStale", null);

                     this.__dataCollection.remove(values[PK]);
                     this.emit("delete", values[PK]);
                  }
               });
            }
         }

         // filter link data collection's cursor
         this.refreshLinkCursor();
         this.setStaticCursor();
      });

      this.on("ab.datacollection.delete", (data) => {
         // debugger;
         let obj = this.datasource;
         if (!obj) return;

         let deleteId = data.data;
         let needDelete = false;
         let deletedIds = [];
         let deletedTreeIds = [];

         // Query
         if (obj instanceof this.AB.Class.ABObjectQuery) {
            let objList = obj.objects((o) => o.id == data.objectId) || [];
            needDelete = objList.length > 0;
            if (needDelete) {
               (objList || []).forEach((o) => {
                  deletedIds =
                     this.__dataCollection
                        .find((item) => {
                           return item[`${o.alias}.${o.PK()}`] == deleteId;
                        })
                        .map((o) => o.id) || [];

                  // grouped queries
                  if (this.__treeCollection) {
                     deletedTreeIds =
                        this.__treeCollection
                           .find((item) => {
                              return item[`${o.alias}.${o.PK()}`] == deleteId;
                           })
                           .map((o) => o.id) || [];
                  }
               });
            }
         }
         // Object
         else {
            needDelete = obj.id == data.objectId;
            if (needDelete) {
               deletedIds.push(deleteId);
            }
         }

         // if it is the source object
         if (needDelete) {
            // If the deleted item is current cursor, then the current cursor should be cleared.
            var currData = this.getCursor();

            deletedIds.forEach((delId) => {
               if (currData?.[obj.PK()] == delId)
                  this.emit("cursorStale", null);

               if (this.__dataCollection.exists(delId))
                  this.__dataCollection.remove(delId);
            });

            if (this.__treeCollection) {
               deletedTreeIds.forEach((delId) => {
                  if (this.__treeCollection.exists(delId))
                     this.__treeCollection.remove(delId);
               });
            }

            if (deletedIds[0]) this.emit("delete", deletedIds[0]);
         }

         // if it is a linked object
         let connectedFields = obj.connectFields(
            (f) => f.datasourceLink && f.datasourceLink.id == data.objectId
         );

         // update relation data
         if (
            obj instanceof this.AB.Class.ABObject &&
            connectedFields &&
            connectedFields.length > 0
         ) {
            // various PK name
            let PK = connectedFields[0].object.PK();

            this.__dataCollection.find({}).forEach((d) => {
               let updateRelateVals = {};

               connectedFields.forEach((f) => {
                  let relateVal = d[f.relationName()];
                  if (relateVal == null) return;

                  if (
                     Array.isArray(relateVal)
                     // JOHNNY: for speed improvements, don't make this check:
                     // just do it and that will reduce 1x through the array.
                     // &&
                     // relateVal.filter(
                     //    (v) =>
                     //       v == deleteId ||
                     //       v.id == deleteId ||
                     //       v[PK] == deleteId
                     // ).length > 0
                  ) {
                     updateRelateVals[f.relationName()] = relateVal.filter(
                        (v) => (v.id || v[PK] || v) != deleteId
                     );
                     updateRelateVals[f.columnName] = updateRelateVals[
                        f.relationName()
                     ].map((v) => v.id || v[PK] || v);
                  } else if (
                     relateVal == deleteId ||
                     relateVal.id == deleteId ||
                     relateVal[PK] == deleteId
                  ) {
                     updateRelateVals[f.relationName()] = null;
                     updateRelateVals[f.columnName] = null;
                  }
               });

               // If this item needs to update
               if (Object.keys(updateRelateVals).length > 0) {
                  // normalize data before add to data collection

                  // var model = obj.model();
                  // model.normalizeData(updateRelateVals);

                  this.__dataCollection.updateItem(d.id, updateRelateVals);

                  if (this.__treeCollection)
                     this.__treeCollection.updateItem(d.id, updateRelateVals);

                  this.emit("update", this.__dataCollection.getItem(d.id));
               }
            });
         }
      });

      // add listeners when cursor of link data collection is changed
      const linkDC = this.datacollectionLink;
      // if (linkDC && this.settings.loadAll) {
      if (linkDC) {
         this.eventAdd({
            emitter: linkDC,
            eventName: "changeCursor",
            listener: (currentCursor) => {
               // NOTE: we can clear data here to update UI display, then data will be fetched when webix.dataFeed event
               if (
                  !this.settings?.loadAll &&
                  currentCursor?.id != linkDC.previousCursorId
               )
                  this.clearAll();

               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });

         this.eventAdd({
            emitter: linkDC,
            eventName: "cursorStale",
            listener: (currentCursor) => {
               // cursorStale : the current cursor hasn't CHANGED, but the data
               // of that value has changed.
               // This is triggered by one of our socket updates that detects
               // changes to the cursor data.

               // if don't have .loadAll set,  we'll need to update our data:
               if (!this.settings?.loadAll) {
                  // What I do here depends on what my linked DC has set for
                  // it's .loadConnections (shouldPopulate) value
                  let dvLink = this.datacollectionLink;
                  let isMyDataThere = dvLink.shouldPopulate;
                  if (Array.isArray(isMyDataThere)) {
                     // if this was an array: it should be an array of columnNames
                     // of the dvLink that are being populated.

                     // the column I'm interested in:
                     let colName = this.fieldLink.fieldLink.columnName;

                     // is it there?
                     isMyDataThere = isMyDataThere.indexOf(colName) > -1;
                  }
                  if (!isMyDataThere) {
                     // If it didn't populate it's data, then I can't be
                     // efficient about how to update my data.
                     // we'll just have to reload:

                     // find out how many entries we have already loaded and try to
                     // load at least that many again.:
                     let count = 20;
                     if (this.__dataCollection.count() > count)
                        count = this.__dataCollection.count();
                     if (this.__treeCollection?.count() > count)
                        count = this.__treeCollection.count();

                     let currCursor = this.__dataCollection.getCursor();
                     this.clearAll();
                     this.reloadData(0, count).then(() => {
                        this.__dataCollection.setCursor(currCursor);
                        this.emit("cursorSelect", currCursor);
                     });
                  } else {
                     // if the linked DC does have my data populated:

                     // the values I currently contain can fall into 1 of 3 categories:
                     // 1) A value I currently have that I need to Keep
                     // 2) A value I currently have that I need to remove
                     // 3) A value I don't have, but need to Add

                     // the current value of the cursor should have the ID references
                     // to what SHOULD be in my display

                     // get the current cursor of our linked DC
                     let linkCursor;

                     if (dvLink) {
                        linkCursor = dvLink.getCursor();
                     }
                     if (!linkCursor) {
                        // if linkCursor is no longer set, then we should clear()
                        this.clearAll();
                        return;
                     }

                     let PK = this.datasource.PK();

                     // lets start by assuming all the current values in cursor are #3
                     // -> all the values into valuesToAdd:

                     let colName = this.fieldLink.fieldLink.relationName();
                     let valuesToAdd = {};
                     let valuesIn = linkCursor[colName] || [];
                     if (!Array.isArray(valuesIn)) valuesIn = [valuesIn];
                     valuesIn = valuesIn.filter((v) => v);
                     valuesIn.forEach((v) => {
                        valuesToAdd[v[PK]] = v;
                     });

                     let valuesToRemove = [];
                     // step through all the values I currently have
                     let currValues = this.__dataCollection.find(() => true);
                     currValues.forEach((value) => {
                        // if value is in valuesToAdd
                        if (valuesToAdd[value[PK]]) {
                           // we already have it so turns out we don't need to add
                           // it after all
                           delete valuesToAdd[value[PK]];
                        } else {
                           // the current state of the Link Cursor value doesn't have
                           // this value, so we need to remove it:
                           valuesToRemove.push(value[PK]);
                        }
                     });

                     // now remove the items we don't want:
                     this.__dataCollection.remove(valuesToRemove);

                     // then we have to ask for the values we need to add:
                     valuesToAdd = Object.keys(valuesToAdd); // convert to []
                     if (valuesToAdd.length > 0) {
                        let cond = { where: {} };
                        cond.where[PK] = valuesToAdd;
                        // NOTE: we are using the abbreviated condition syntax here.

                        // NOTE: staleRefresh() has some buffering capabilities
                        // that combine multiple calls into 1 more efficient call:
                        this.model.staleRefresh(cond).then((res) => {
                           // check to make sure there is data to work with
                           if (Array.isArray(res.data) && res.data.length) {
                              res.data.forEach((d) => {
                                 this.__dataCollection.add(d);
                              });
                           }
                        });
                     }
                  }

                  return;
               }

               // Otherwise, we need to refilter our data:
               this.refreshLinkCursor();
               this.setStaticCursor();
            },
         });
      }

      // add listeners when cursor of the followed data collection is changed
      const followDC = this.datacollectionFollow;
      if (followDC) {
         this.eventAdd({
            emitter: followDC,
            eventName: "changeCursor",
            listener: () => {
               const followCursor = followDC.getCursor();
               const currentCursor = this.getCursor();

               // If the cursor is not the new, then it should not reload.
               if (
                  followCursor?.[followDC.datasource.PK()] ==
                  currentCursor?.[this.datasource.PK()]
               )
                  return;

               this.clearAll();
               this.loadData();
            },
         });

         this.eventAdd({
            emitter: followDC,
            eventName: "cursorStale",
            listener: () => {
               // cursorStale : the current cursor hasn't CHANGED, but the data
               // of that value has changed.
               // This is triggered by one of our socket updates that detects
               // changes to the cursor data.

               this.clearAll();
               this.loadData();
            },
         });
      }
   }

   /*
    * waitForDataCollectionToInitialize()
    * there are certain situations where this datacollection shouldn't
    * load until another one has loaded.  In those cases, the fn()
    * will wait for the required datacollection to emit "initializedData"
    * before continuing on.
    * @param {ABViewDataCollection} DC
    *      the DC this datacollection depends on.
    * @returns {Promise}
    */
   async waitForDataCollectionToInitialize(DC, msg) {
      DC.init();

      return new Promise((resolve, reject) => {
         /* eslint-disable no-fallthrough */
         switch (DC.dataStatus) {
            // if that DC hasn't started initializing yet, start it!
            case DC.dataStatusFlag.notInitial:
               DC.loadData().catch(reject);
            // no break;

            // once in the process of initializing

            case DC.dataStatusFlag.initializing:
               /* eslint-enable no-fallthrough*/
               // listen for "initializedData" event from the DC
               // then we can continue.
               this.eventRemove("initializedData");
               this.eventAdd({
                  emitter: DC,
                  eventName: "initializedData",
                  listener: () => {
                     // go next
                     resolve();
                  },
               });
               break;

            // if it is already initialized, we can continue:
            case DC.dataStatusFlag.initialized:
               resolve();
               break;

            // just in case, if the status is not known, just continue
            default:
               resolve();
               break;
         }
         /* eslint-enable no-fallthrough */
      });
   }

   // /**
   //  * @method whereCleanUp()
   //  * Parse through the current where condition and remove any null or
   //  * empty logical blocks.
   //  * @param {obj} curr
   //  *        1) The current where condition in ABQuery Format:
   //  *        {
   //  *           glue: [AND, OR],
   //  *           rules: [ {rule} ]
   //  *        }
   //  *        or 2) The current {rule} to validate
   //  *        {
   //  *          key:{string},
   //  *          rule:{string},
   //  *          vlaue:{mixed}
   //  *        }
   //  * @return {ABQuery.where} / { Rule }
   //  */
   // whereCleanUp(curr) {
   //    if (curr) {
   //       if (curr.glue && curr.rules) {
   //          // this is a logical Block (AND, OR)
   //          // we need to filter the children
   //          let newValue = { glue: curr.glue, rules: [] };
   //          curr.rules.forEach((r) => {
   //             let cleanRule = this.whereCleanUp(r);
   //             // don't add values that didn't pass
   //             if (cleanRule) {
   //                newValue.rules.push(cleanRule);
   //             }
   //          });

   //          // if we have a non empty block, then return it:
   //          if (newValue.rules.length > 0) {
   //             return newValue;
   //          }

   //          // this isn't really a valid conditional, so null
   //          return null;
   //       }

   //       // This is a specific rule, that isn't null so:
   //       return curr;
   //    }
   //    return null;
   // }

   async loadData(start, limit) {
      // mark data status is initializing
      if (this._dataStatus == this.dataStatusFlag.notInitial) {
         this._dataStatus = this.dataStatusFlag.initializing;
         this.emit("initializingData", {});
      }

      var obj = this.datasource;
      if (obj == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      var model = obj.model();
      if (model == null) {
         this._dataStatus = this.dataStatusFlag.initialized;
         return Promise.resolve([]);
      }

      // pull the defined sort values
      var sorts = this.settings.objectWorkspace.sortFields || [];

      // pull filter conditions
      let wheres = this.AB.cloneDeep(
         this.settings.objectWorkspace.filterConditions ?? {}
      );
      // if we pass new wheres with a reload use them instead
      if (this.__reloadWheres) {
         wheres = this.__reloadWheres;
      }
      wheres.glue = wheres.glue || "and";
      wheres.rules = wheres.rules || [];

      const __additionalWheres = {
         glue: "and",
         rules: [],
      };

      // add the filterCond if there are rules to add
      if (this.__filterCond?.rules?.length > 0) {
         __additionalWheres.rules.push(this.__filterCond);
      }

      // Filter by a selected cursor of a link DC
      let linkRule = this.ruleLinkedData();
      if (!this.settings.loadAll && linkRule) {
         __additionalWheres.rules.push(linkRule);
      }
      // pull data rows following the follow data collection
      else if (this.datacollectionFollow) {
         const followCursor = this.datacollectionFollow.getCursor();
         // store the PK as a variable
         let PK = this.datasource.PK();
         // if the datacollection we are following is a query
         // add "BASE_OBJECT." to the PK so we can select the
         // right value to report the cursor change to
         if (this.datacollectionFollow.settings.isQuery) {
            PK = "BASE_OBJECT." + PK;
         }
         if (followCursor) {
            start = 0;
            limit = null;
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: followCursor[PK],
                  },
               ],
            };
         }
         // Set no return rows
         else {
            wheres = {
               glue: "and",
               rules: [
                  {
                     key: this.datasource.PK(),
                     rule: "equals",
                     value: "NO RESULT ROW",
                  },
               ],
            };
         }
      }

      // Combine setting & program filters
      if (__additionalWheres.rules.length) {
         if (wheres.rules.length) {
            __additionalWheres.rules.unshift(wheres);
         }
         wheres = __additionalWheres;
      }

      // remove any null in the .rules
      // if (wheres?.rules?.filter) wheres.rules = wheres.rules.filter((r) => r);
      wheres = obj.whereCleanUp(wheres);

      // set query condition
      var cond = {
         where: wheres || {},
         // limit: limit || 20,
         skip: start || 0,
         sort: sorts,
         populate: this.shouldPopulate,
      };

      //// NOTE: we no longer set a default limit on loadData() but
      //// require the platform.loadData() to pass in a default limit.
      if (limit != null) {
         cond.limit = limit;
      }

      // if settings specify loadAll, then remove the limit
      if (this.settings.loadAll && !this.isCursorFollow) {
         delete cond.limit;
      }

      //
      // Step 1: make sure any DataCollections we are linked to are
      // initialized first.  Then proceed with our initialization.
      //
      const parentDc = this.datacollectionLink ?? this.datacollectionFollow;
      // If we are linked to another datacollection then wait for it
      if (parentDc) {
         await this.waitForDataCollectionToInitialize(parentDc);
      }

      //
      // Step 2: if we have any filter rules that depend on other DataCollections,
      // then wait for them to be initialized first.
      // eg: "(not_)in_data_collection" rule filters
      if (wheres?.rules?.length) {
         const dcFilters = [];

         wheres.rules.forEach((rule) => {
            // if this collection is filtered by data collections we need to load them in case we need to validate from them later
            if (
               rule.rule == "in_data_collection" ||
               rule.rule == "not_in_data_collection"
            ) {
               const dv = this.AB.datacollectionByID(rule.value);
               if (dv) {
                  dcFilters.push(this.waitForDataCollectionToInitialize(dv));
               }
            }
         });

         await Promise.all(dcFilters);
      }

      //
      // Step 3: pull data to data collection
      // we will keep track of the resolve, reject for this
      // operation.
      // the actual resolve() should happen in the
      // .processIncomingData() after the  data is processed.
      return new Promise((resolve, reject) => {
         this._pendingLoadDataResolve = {
            resolve: resolve,
            reject: reject,
         };

         this.platformFind(model, cond).catch((err) => {
            reject(err);
         });
      });
   }

   platformFind(model, cond) {
      //// Core Migration Note:
      //// the ABViewDataCollectionCore now manages data in a different way:
      //// local data  vs  Remote Data
      //// this will need to be updated to reflect that management:
      //// (and also explains why we refactored things into .processIncomingData())
      return model.findAll(cond).then((data) => {
         return this.processIncomingData(data);
      });
   }

   /**
    * @method shouldPopulate()
    * Return our populate status. We now want to query this info outside this
    * object.
    * @return {bool|Array}
    *         true/false,  or an array of columnNames that are being populated.
    */
   get shouldPopulate() {
      return (
         this.settings.populate ??
         (this.settings.preventPopulate ? false : true)
      );
   }

   /**
    * @method queuedParse()
    * This is an attempt at loading very large datasets into a Webix DC without locking up
    * the display.
    * @param {array} data
    *        The data to load into the __dataCollection
    * @param {callback} cb
    *        A callback to call when the data has been fully loaded.
    */
   async queuedParse(incomingData, cb) {
      const data = incomingData?.data || incomingData;
      if (!data?.length) {
         cb?.();
         return Promise.resolve();
      }

      const total_count = incomingData.total_count;

      let nextData;
      if (data.length > 250) {
         let pos = this.__dataCollection.count();
         let remain = data.splice(250);
         nextData = {
            data: remain,
            pos: pos + data.length,
            total_count,
         };
      }

      const parsedData = {
         data,
         pos: incomingData.pos,
         total_count,
      };
      this.__dataCollection.parse(parsedData);

      return new Promise((resolve) => {
         setTimeout(async () => {
            await this.queuedParse(nextData);
            cb?.();
            resolve();
         }, 15);
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      return Promise.resolve().then(() => {
         // store total count
         this.__totalCount = data.total_count;

         // Need to .parse at the first time
         if (!this.__dataCollection.find({}).length) {
            this.__dataCollection.clearAll();
            // this.__dataCollection.parse(data);
         }

         if (this.__throttleIncoming) clearTimeout(this.__throttleIncoming);
         this.__throttleIncoming = setTimeout(async () => {
            // using queuedParse() to responsively handle large datasets.
            await this.queuedParse(data);

            // In order to get the total_count updated I had to use .load()
            this.__dataCollection.load(async () => {
               setTimeout(() => {
                  this.refreshLinkCursor();
               }, 250);

               return {
                  // NOTE: return a empty array to prevent render items in DataTable twice. (Items are rendered in .queuedParse function)
                  data: [],
                  pos: data.pos,
                  total_count: data.total_count,
               };
            });

            // this does nothing???
            this.parseTreeCollection(data);

            // if we are linked, then refresh our cursor
            var linkDv = this.datacollectionLink;
            if (linkDv) {
               // filter data by match link data collection
               this.refreshLinkCursor();
               this.setStaticCursor();
            } else {
               // set static cursor
               this.setStaticCursor();
            }

            // now we close out our .loadData() promise.resolve() :
            if (this._pendingLoadDataResolve) {
               this._pendingLoadDataResolve.resolve();

               // after we call .resolve() stop tracking this:
               this._pendingLoadDataResolve = null;
            }

            // If dc set load all, then it will not trigger .loadData in dc at
            // .onAfterLoad event
            if (this.settings.loadAll) {
               this.emit("loadData", {});
            }

            // mark initialized data
            if (this._dataStatus != this.dataStatusFlag.initialized) {
               this._dataStatus = this.dataStatusFlag.initialized;
               this.emit("initializedData", {});
            }
         }, 100);
      });
   }

   /**
    * @method reloadData()
    * Trigger the DataCollection to reload its data from the server.
    * @param {int} start
    *        Start position of where we want the data to load.
    * @param {int} limit
    *        How many entries to load at a time.
    * @return {Promise}
    */
   reloadData(start, limit) {
      // var waitForDataCollectionToInitialize = (DC) => {
      //    return new Promise((resolve, reject) => {
      //       switch (DC.dataStatus) {
      //          // if that DC hasn't started initializing yet, start it!
      //          case DC.dataStatusFlag.notInitial:
      //             DC.loadData().catch(reject);
      //          // no break;

      //          // once in the process of initializing
      //          /* eslint-disable no-fallthrough*/
      //          case DC.dataStatusFlag.initializing:
      //             /* eslint-enable no-fallthrough*/
      //             // listen for "initializedData" event from the DC
      //             // then we can continue.
      //             this.eventAdd({
      //                emitter: DC,
      //                eventName: "initializedData",
      //                listener: () => {
      //                   // go next
      //                   resolve();
      //                },
      //             });
      //             break;

      //          // if it is already initialized, we can continue:
      //          case DC.dataStatusFlag.initialized:
      //             resolve();
      //             break;

      //          // just in case, if the status is not known, just continue
      //          default:
      //             resolve();
      //             break;
      //       }
      //    });
      // };

      return Promise.resolve().then(() => {
         // check if we are currently waiting for more data requests on this datacollection before continuing
         if (this.reloadTimer) {
            // if we are already waiting delete the current timer
            clearTimeout(this.reloadTimer);
            delete this.reloadTimer;
         }

         // return a promise
         if (!this.reloadPromise) {
            this.reloadPromise = new Promise((resolve, reject) => {
               this.reloadPromise__resolve = resolve;
               this.reloadPromise__reject = reject;
            });
         }

         // then create a new timeout to delete current timeout, clear data
         // and load new
         this.reloadTimer = setTimeout(() => {
            // clear the data from the dataCollection,
            this.clearAll();
            // then loads new data from the server
            return this.loadData(start, limit)
               .then(() => {
                  if (this.reloadPromise) {
                     this.reloadPromise__resolve();
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }

                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               })
               .catch((err) => {
                  if (this.reloadPromise) {
                     this.reloadPromise__reject(err);
                     delete this.reloadPromise;
                     delete this.reloadPromise__resolve;
                     delete this.reloadPromise__reject;
                  }
                  // delete the current setTimeout
                  clearTimeout(this.reloadTimer);
                  delete this.reloadTimer;
               });
         }, 50);
         // setting to 50ms because right now we do not see many
         // concurrent calls,  we need to increase this if we begin to

         return this.reloadPromise;
      });
   }

   /**
    * reloadWheres()
    * stores the child data collections filters for subsequent loads.
    * It is called from bindParentDc() when child data collections that are not
    * marked to load all data are initializing. To do this we use webix
    * server side binding by setting the param of "dataFeed".
    * @param {obj} wheres  the new filters for the data collection
    *        This is a combination of any exisiting filters the data collection
    *        alreay had as well as the filter for the current cursor set by the
    *        master data collection. We store this in __reloadWheres for when
    *        the data needs to be updated.
    *        The format of the wheres is our Query Builder Format
    *        ex: {
    *              "glue": "and",
    *              "rules": [{
    *                "key": "33ba8957-6b9c-4ddb-9533-c46b13878ae1",
    *                "rule": "contains",
    *                "value": "1594176994894"
    *              }]
    *            }
    */
   reloadWheres(wheres) {
      this.__reloadWheres = wheres;
   }

   getData(filter) {
      var dc = this.__dataCollection;
      if (dc) {
         return dc.find((row) => {
            let isValid = true;

            // data collection filter
            // isValid = this.isValidData(row);

            // NOTE: data are filtered from the server side (webix.dataFeed)
            // parent dc filter
            let linkDv = this.datacollectionLink;
            if (linkDv && this.settings.loadAll && isValid) {
               isValid = this.isParentFilterValid(row);
            }

            // addition filter
            if (isValid && filter) {
               isValid = filter(row);
            }

            return isValid;
         });
      } else {
         return [];
      }
   }

   isParentFilterValid(rowData) {
      // data is empty
      if (rowData == null) return false;

      var linkDv = this.datacollectionLink;
      if (linkDv == null) return true;

      const linkObj = linkDv.datasource;
      if (linkObj == null) return true;

      var fieldLink = this.fieldLink;
      if (fieldLink == null) return true;

      // if the parent's cursor is not set we have not filted this collection
      // yet so the data that comes back should be valid
      var linkCursor = linkDv.getCursor();
      if (linkCursor == null) {
         return true;
      }

      var linkVal = rowData[fieldLink.relationName()];
      if (linkVal == null) {
         // try to get relation value(id) again
         if (rowData[fieldLink.columnName]) {
            linkVal = rowData[fieldLink.columnName];
         } else {
            return false;
         }
      }

      let PK = fieldLink.object.PK();

      // array - 1:M , M:N
      if (linkVal.filter) {
         return (
            linkVal.filter(
               (val) =>
                  (val[PK] || val.id || val) ==
                  (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
            ).length > 0
         );
      } else {
         return (
            (linkVal[PK] || linkVal.id || linkVal) ==
            (linkCursor[linkObj.PK()] || linkCursor.id || linkCursor)
         );
      }
   }

   clearAll() {
      if (this.__dataCollection) this.__dataCollection.clearAll();

      if (this.__treeCollection) this.__treeCollection.clearAll();

      this._dataStatus = this.dataStatusFlag.notInitial;
   }

   get totalCount() {
      return this.__totalCount || 0;
   }

   ///
   /// Components
   ///

   /**
    * @method bind
    * @param {Object} component - a webix element instance
    */
   bind(/* component */) {
      console.error("Platform.ABDataCollection.bind() Not implemented");
   }

   unbind(/* component */) {
      console.error("Platform.ABDataCollection.unbind() Not implemented");
   }

   removeComponent(comId) {
      // get index
      let index = this.__bindComponentIds.indexOf(comId);

      // delete
      this.__bindComponentIds.splice(index, 1);
   }

   /**
    * @method ruleLinkedData()
    * return a QueryFilter rule that also checks that incoming data is linked
    * to our .datacollectionLink (if it exists).
    * @return {obj} {QueryFilterRule}
    */
   ruleLinkedData() {
      let rule = null;
      const dataCollectionLink = this.datacollectionLink;
      const fieldLink = this.fieldLink;
      if (dataCollectionLink && fieldLink) {
         const linkCursorId = dataCollectionLink?.getCursor()?.id;
         if (linkCursorId) {
            rule = {
               alias: fieldLink.alias, // ABObjectQuery
               key: fieldLink.id,
               rule: fieldLink.alias ? "contains" : "equals", // NOTE: If object is query, then use "contains" because ABOBjectQuery return JSON
               value: fieldLink.getRelationValue(
                  dataCollectionLink.__dataCollection.getItem(linkCursorId)
               ),
            };
         }
      }
      return rule;
   }

   /**
    * @method refreshFilterConditions()
    * This is called in two primary cases:
    *    - on initialization of a DC to setup our filters.
    *    - in the operation of the ABDesigner when using a DC to display data
    *      in the Work_object_grid and the datacollection_work(?)
    * In the case of the ABDesigner, new temporary where conditions are provided
    * from the possible filters we can set, and those need to effect the data
    * we display.
    * @param {ABRowFilter.where} wheres
    *        The filter condition from the ABRowFilter values we are storing.
    */
   refreshFilterConditions(wheres = null) {
      // There are 3 Filters that help us know if our data is Valid:
      // 1) A filter for any ABObjectQuery we are managing.
      // 2) A filter for our own filter condition
      // 3) A filter that represents what our scopes allows

      // Set filter of ABObject
      if (this.__filterDatasource == null)
         this.__filterDatasource = this.AB.filterComplexNew(
            `${this.id}_filterDatasource`
         );

      if (this.datasource) {
         // this.__filterDatasource.applicationLoad(this.datasource.application);
         this.__filterDatasource.fieldsLoad(this.datasource.fields());

         let filterConditions;

         // Query
         if (this.datasource instanceof this.AB.Class.ABObjectQuery) {
            filterConditions = this.datasource.where;
         }
         // Apr 29, 2021 Removed this because we do not want Object filters to
         // effect validation of DataCollections
         // Object

         // else if (this.datasource instanceof ABObject) {
         //    let currentView = this.datasource.currentView();
         //    if (currentView && currentView.filterConditions)
         //       filterConditions = currentView.filterConditions;
         // }

         if (filterConditions)
            this.__filterDatasource.setValue(filterConditions);
         else this.__filterDatasource.setValue({});
      } else {
         this.__filterDatasource.fieldsLoad([]);
         this.__filterDatasource.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of data view
      // Apr 29, 2021 Added this code back to validate with DataCollection Filters
      if (this.__filterDatacollection == null)
         this.__filterDatacollection = this.AB.filterComplexNew(
            `${this.id}_filterDatacollection`
         );

      // this.__filterDatacollection.applicationLoad(
      //    this.datasource ? this.datasource.application : null
      // );
      this.__filterDatacollection.fieldsLoad(
         this.datasource ? this.datasource.fields() : []
      );

      // if we pass in wheres, then Save that value to our internal .filterConditions
      if (wheres) this.settings.objectWorkspace.filterConditions = wheres;

      let filter = this.AB.cloneDeep(
         this.settings.objectWorkspace?.filterConditions ?? {
            glue: "and",
            rules: [],
         }
      );
      // sanity checks:
      // I've learned not to trust: this.settings.objectWorkspace
      filter.glue = filter.glue || "and";
      filter.rules = filter.rules || [];

      // if there is a linkRule, add it to filter
      let linkRule = this.ruleLinkedData(); // returns a rule if we are linked
      if (linkRule) {
         // NOTE: linkRule was originally designed to produce a rule for the
         // loadData() routine.  In SQL, our linkRule might have an "equals"
         // rule, to match.  But in this context if our linktype is "many"
         // we need to change the rule to "contains":
         if (this.fieldLink?.linkType() == "many") {
            linkRule.rule = "contains";
         }

         // if linkRule not already IN filter:
         let isAlreadyThere = false;
         let keys = Object.keys(linkRule);
         (filter.rules || []).forEach((r) => {
            if (isAlreadyThere) return;
            let allMatch = true;
            keys.forEach((k) => {
               if (r[k] != linkRule[k]) {
                  allMatch = false;
               }
            });
            isAlreadyThere = allMatch;
         });
         if (!isAlreadyThere) {
            // link Rule needs to be ANDed to our current Rules:
            if (filter.glue == "and") {
               filter.rules.push(linkRule);
            } else {
               filter = { glue: "and", rules: [filter, linkRule] };
            }
         }
      }

      if ((filter.rules || []).length > 0 && !this.isCursorFollow) {
         this.__filterDatacollection.setValue(filter);
      } else {
         this.__filterDatacollection.setValue(
            DefaultValues.settings.objectWorkspace.filterConditions
         );
      }

      // Set filter of user's scope
      if (this.__filterScope == null)
         this.__filterScope = this.AB.filterComplexNew(
            `${this.id}_filterScope`
         );

      if (this.datasource) {
         let scopeList = (this.userScopes || []).filter(
            (s) =>
               !s.allowAll &&
               (s.objectIds || []).indexOf(this.datasource.id) > -1
         );
         if (scopeList && scopeList.length > 0) {
            // this.__filterScope.applicationLoad(this.datasource.application);
            this.__filterScope.fieldsLoad(this.datasource.fields() || []);

            // concat all rules of scopes
            let scopeRules = [];
            scopeList
               .filter(
                  (s) => s.filter && s.filter.rules && s.filter.rules.length
               )
               .forEach((s) => {
                  let sRules = (s.filter.rules || []).filter(
                     (r) =>
                        this.datasource.fields((f) => f.id == r.key).length > 0
                  );

                  scopeRules = scopeRules.concat(sRules);
               });

            let scopeWhere = {
               glue: "or",
               rules: scopeRules,
            };
            this.__filterScope.setValue(scopeWhere);
         }
      }
   }

   get isGroup() {
      return this.__isGroup || false;
   }

   ///
   /// Sync type
   ///

   get syncTypeFlag() {
      return {
         server: 1,
         client: 2,
      };
   }

   get syncType() {
      return this.settings.syncType || DefaultValues.syncType;
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(/*data*/) {
      var error = new Error(
         "the platform.ABDataCollection._dataCollectionNew() is expected to return a proper DataCollection!"
      );
      console.error(error);
      return null;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      console.error(
         "the platform.ABDataCollection._treeCollectionNew() is expected to return a proper TreeCollection!"
      );
      return null;
   }

   parseTreeCollection(data = {}) {
      // TODO all this does is log "is missing?"
      if (data === {}) {
         console.log(
            "Platform.ABDataCollection.parseTreeCollection() missing!"
         );
      }
   }
   // parseTreeCollection(data = {}) {

   //  if (!(this.__datasource instanceof ABObjectQuery) ||
   //    !this.__datasource.isGroup ||
   //    !this.__treeCollection)
   //    return;

   //  let addRowToTree = (join = {}, parentAlias = null) => {

   //    let alias = join.alias;

   //    (data.data || []).forEach(row => {

   //      let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
   //      if (!dataId) return;

   //      // find parent nodes
   //      let parentItemIds = [];
   //      let parentId = row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
   //      if (parentId) {
   //        parentItemIds = this.__treeCollection
   //          .find(item => item._alias == parentAlias && item._dataId == parentId)
   //          .map(item => item.id);
   //      }

   //      // check exists
   //      let exists = this.__treeCollection.find(item => {
   //        return item._alias == alias &&
   //          item._dataId == dataId &&
   //          (parentItemIds.length == 0 || parentItemIds.indexOf(item.$parent) > -1);
   //      }, true);
   //      if (exists) return;

   //      let treeNode = {};
   //      treeNode._alias = alias;
   //      treeNode._dataId = dataId;
   //      treeNode._itemId = row.id; // Keep row id for set cursor to data collection

   //      Object.keys(row).forEach(propName => {

   //        // Pull value from alias
   //        if (propName.indexOf(`${alias}.`) == 0) {
   //          treeNode[propName] = row[propName];
   //        }

   //      });

   //      if (row.translations)
   //        treeNode.translations = row.translations;

   //      // child nodes
   //      if (parentItemIds.length > 0)
   //        parentItemIds.forEach(parentItemId => {
   //          this.__treeCollection.add(treeNode, null, parentItemId);
   //        });
   //      // root node
   //      else
   //        this.__treeCollection.add(treeNode, null);

   //    });

   //    // Sub-joins
   //    (join.links || []).forEach(link => {
   //      addRowToTree(link, alias);
   //    });

   //  };

   //  // Show loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.showProgress)
   //      boundComp.showProgress({ type: "icon" });

   //  });

   //  addRowToTree(this.__datasource.joins());

   //  // Hide loading cursor
   //  (this.__bindComponentIds || []).forEach(comId => {

   //    let boundComp = $$(comId);
   //    if (boundComp &&
   //      boundComp.hideProgress)
   //      boundComp.hideProgress();

   //  })
   // }

   /**
    * @method _queryUpdateData
    *
    * @param {Array} objList - List of ABObject
    * @param {Object} values
    */
   _queryUpdateData(objList, values) {
      let updatedVals = {};

      // Add alias to properties of update data
      Object.keys(values).forEach((key) => {
         objList.forEach((oItem) => {
            let alias = this.datasource.objectAlias(oItem.id);

            updatedVals[`${alias}.${key}`] = values[key];

            // Add alias to properties of .translations
            if (
               key == "translations" &&
               values["translations"] &&
               values["translations"].length
            ) {
               updatedVals.translations = [];

               values["translations"].forEach((tran) => {
                  let updatedTran = {};

                  Object.keys(tran).forEach((tranKey) => {
                     if (tranKey == "language_code")
                        updatedTran["language_code"] = tran["language_code"];
                     else updatedTran[`${alias}.${tranKey}`] = tran[tranKey];
                  });

                  updatedVals.translations.push(updatedTran);
               });
            }
         });
      });

      return updatedVals;
   }

   isValidData(rowData) {
      let result = true;

      // NOTE: should we use filter of the current view of object to filter
      //        if yes, update .wheres condition in .loadData too
      if (this.__filterDatasource)
         result = result && this.__filterDatasource.isValid(rowData);

      if (this.__filterDatacollection)
         result = result && this.__filterDatacollection.isValid(rowData);

      if (result && this.__filterScope)
         result = result && this.__filterScope.isValid(rowData);

      return result;
   }

   updateRelationalDataFromLinkDC(objectId, rowData) {
      const dcLink = this.datacollectionLink;
      const cursorLink = dcLink?.getCursor();

      // Add the new data that just relate to the Link DC
      if (
         dcLink?.datasource.id == objectId &&
         cursorLink &&
         cursorLink.id == rowData?.id
      ) {
         const obj = this.datasource;
         const linkedField = this.fieldLink;
         let relatedData = rowData[linkedField.fieldLink.relationName()];
         if (relatedData && !Array.isArray(relatedData))
            relatedData = [relatedData];

         (relatedData ?? []).forEach((item) => {
            if (item == null) return;

            if (!this.__dataCollection.exists(item[obj.PK()])) {
               // QUESTION: Should we .find to get fully info here ?
               const newItem = this.AB.cloneDeep(item);
               newItem[linkedField.relationName()] = [rowData];
               this.__dataCollection.add(newItem);
            }
         });

         // trigger to components to know there are updated data.
         this.emit("warnRefresh");
      }
   }

   // Clone

   clone(settings) {
      settings = settings || this.toObj();
      var clonedDatacollection = new this.constructor(settings, this.AB);
      clonedDatacollection.__datasource = this.__datasource;
      clonedDatacollection._dataStatus = this._dataStatus;

      // clonedDatacollection.__dataCollection = this.__dataCollection.copy();
      clonedDatacollection.__filterDatacollection.setValue(
         settings.settings.objectWorkspace.filterConditions
      );

      var parseMe = () => {
         if (clonedDatacollection.__dataCollection) {
            clonedDatacollection.__dataCollection.parse(
               this.__dataCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
         if (clonedDatacollection.__treeCollection) {
            clonedDatacollection.__treeCollection.parse(
               this.__treeCollection
                  .find({})
                  .filter((row) =>
                     clonedDatacollection.__filterDatacollection.isValid(row)
                  )
            );
         }
      };

      parseMe();

      // return new Promise((resolve, reject) => {
      //    // load the data
      //    clonedDatacollection
      //       .loadData()
      //       .then(() => {

      // set the cursor
      clonedDatacollection.setStaticCursor();

      var cursorID = this.getCursor();
      if (cursorID) {
         // NOTE: webix documentation issue: .getCursor() is supposed to return
         // the .id of the item.  However it seems to be returning the {obj}
         if (cursorID.id) cursorID = cursorID.id;

         clonedDatacollection.setCursor(cursorID);
      }

      return clonedDatacollection;

      // resolve(clonedDatacollection);
      //       })
      //       .catch(reject);
      // });
   }

   filteredClone(filters) {
      var obj = this.toObj();

      // check to see that filters are set (this is sometimes helpful to select the first record without doing so at the data collection level)
      if (filters?.rules?.length) {
         if (obj.settings.objectWorkspace.filterConditions?.rules?.length) {
            obj.settings.objectWorkspace.filterConditions.rules =
               obj.settings.objectWorkspace.filterConditions.rules.concat(
                  filters.rules
               );
         } else {
            obj.settings.objectWorkspace.filterConditions = filters;
         }
      }
      let clonedDC = this.clone(obj);
      return clonedDC; // new ABViewDataCollection(settings, this.application, this.parent);
   }

   //
   // Event handles
   //

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    *              emitter: object,
    *              eventName: string,
    *              listener: function
    *            }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      this.__events = this.__events || [];

      let exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    */
   eventClear() {
      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method eventRemove()
    * unsubscribe a event.
    *
    */
   eventRemove(eventName) {
      if (this.__events?.length > 0 && eventName) {
         this.__events.forEach((e) => {
            if (eventName == e.eventName)
               e.emitter.removeListener(e.eventName, e.listener);
         });

         this.__events = this.__events.filter((e) => e.eventName != eventName);
      }
   }

   get userScopes() {
      return [];
   }

   get isCursorFollow() {
      return (
         this.settings.followDatacollectionID &&
         (!this.settings.linkDatacollectionID || !this.settings.linkFieldID)
      );
   }

   get datacollectionFollow() {
      if (!this.isCursorFollow) return null;

      return (this.AB ?? AB).datacollectionByID(
         this.settings.followDatacollectionID
      );
   }

   get previousCursorId() {
      return this.__previousCursorId;
   }

   waitReady() {
      // if (this.dataStatus == this.dataStatusFlag.initialized) {
      //    return Promise.resolve();
      // }
      // console.log(`DC[${this.label}] waiting for initializedData.`);
      // return new Promise((resolve /*, reject */) => {
      //    this.once("initializedData", ()=>{
      //       resolve();
      //    })

      // })

      return this.waitForDataCollectionToInitialize(this);
   }
};


/***/ }),

/***/ 32877:
/*!*********************************************!*\
  !*** ./AppBuilder/core/ABDefinitionCore.js ***!
  \*********************************************/
/***/ ((module) => {

// import ABApplication from "./ABApplication"

module.exports = class ABDefinitionCore {
   constructor(attributes, AB) {
      this.AB = AB;
      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			type: 'xxxxx',
			json: "{json}"
		}
		*/
      if (attributes.id) {
         this.id = attributes.id;
      }
      this.name =
         attributes?.name ||
         attributes?.json?.name ||
         attributes?.json?.label ||
         attributes?.json?.translations?.[0]?.label ||
         "";
      if (!this.name) {
         this.AB.notify.builder(
            new Error("Attributes for definition had no 'name'"),
            {
               context: "ABDefinitionCore.fromValues()",
               attributes,
            }
         );
      }
      this.type = attributes.type || attributes?.json?.type || "";
      this.json = attributes.json || null;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      return {
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.json,
      };
   }

   /**
    * @method destroy()
    * destroy the current instance of ABDefinition
    * Also remove it from our parent application
    * @return {Promise}
    */
   destroy() {
      return this.AB.definitionDestroy(this.id);
   }

   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    *         .resolve( {this} )
    */
   async save() {
      if (this.id) {
         return this.AB.definitionUpdate(this.id, this.toObj());
      } else {
         return this.AB.definitionCreate(this.toObj());
      }
   }
};


/***/ }),

/***/ 78332:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABFactoryCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFactoryCore
 * an object that contains the definitions and references for a single tenant.
 * It is expected that an instance of this should be returned from an
 * ABBootstrap.init(req).then((AB)=>{}) call.
 */

// const _ = require("lodash");
// const uuidv4 = require("uuid");

const ABApplication = __webpack_require__(/*! ../platform/ABApplication */ 95995);
const ABApplicationMobile = __webpack_require__(/*! ../platform/ABApplicationMobile */ 90804);
const ABDefinition = __webpack_require__(/*! ../platform/ABDefinition */ 84650);

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 52174);

const ABFieldManager = __webpack_require__(/*! ./ABFieldManager */ 67431);

const ABIndex = __webpack_require__(/*! ../platform/ABIndex */ 97938);
const ABObject = __webpack_require__(/*! ../platform/ABObject */ 24869);
const ABObjectExternal = __webpack_require__(/*! ../platform/ABObjectExternal */ 2550);
const ABObjectImport = __webpack_require__(/*! ../platform/ABObjectImport */ 38968);
const ABObjectApi = __webpack_require__(/*! ../platform/ABObjectApi */ 34532);
const ABDataCollection = __webpack_require__(/*! ../platform/ABDataCollection */ 35122);
const ABObjectQuery = __webpack_require__(/*! ../platform/ABObjectQuery */ 76500);

const ABHint = __webpack_require__(/*! ../platform/ABHint */ 17063);
const ABProcess = __webpack_require__(/*! ../platform/ABProcess */ 63509);

const ABProcessParticipant = __webpack_require__(/*! ../platform/process/ABProcessParticipant */ 98618);
const ABProcessLane = __webpack_require__(/*! ../platform/process/ABProcessLane */ 94410);
const ABProcessTaskManager = __webpack_require__(/*! ./process/ABProcessTaskManager */ 78949);

const ABStep = __webpack_require__(/*! ../platform/ABStep */ 21002);

const ABViewDetailItem = __webpack_require__(/*! ../platform/views/ABViewDetailItem */ 54325);
const ABViewFormItem = __webpack_require__(/*! ../platform/views/ABViewFormItem */ 48933);
const ABMobileViewFormItem = __webpack_require__(/*! ../platform/mobile/ABMobileViewFormItem */ 21579);

// const ABObjectWorkspaceViewGrid = require("../platform/workspaceViews/ABObjectWorkspaceViewGrid");
// const ABObjectWorkspaceViewKanban = require("../platform/workspaceViews/ABObjectWorkspaceViewKanban");
// const ABObjectWorkspaceViewGantt = require("../platform/workspaceViews/ABObjectWorkspaceViewGantt");

const RowFilter = __webpack_require__(/*! ../platform/RowFilter */ 12416);
const FilterComplex = __webpack_require__(/*! ../platform/FilterComplex */ 67483);

const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);

const EventEmitter = __webpack_require__(/*! ../platform/ABEmitter */ 26263);

class ABFactory extends EventEmitter {
   constructor(definitions) {
      /**
       * @param {hash} definitions
       *        { ABDefinition.id : {ABDefinition} }
       *        of all the definitions defined for the current Tenant
       */

      super();
      this.setMaxListeners(0);

      this._definitions = definitions || {};
      // {hash}  { ABDefinition.id : {ABDefinition} }
      // ensure ._definitions is a HASH{ ID : {ABDefinition}}
      if (Array.isArray(definitions)) {
         var hash = {};
         definitions.forEach((d) => {
            hash[d.id] = d;
         });
         this._definitions = hash;
      }

      //
      //
      // Manage our working objects
      //

      this._allApplications = [];
      // {array} of all the ABApplication(s) in our site.

      this._allObjects = [];
      // {array} of all the ABObject(s) in our site.

      this._allHints = [];
      // {array} of all the ABHint(s) in our site.

      this._allProcesses = [];
      // {array} of all the ABProcess(s) in our site.

      this._allQueries = [];
      // {array} of all the ABObjectQuery(s) in our site.

      this._allSteps = [];
      // {array} of all the ABStep(s) in our site.

      this._allDatacollections = [];
      // {array} of all the ABDataCollection(s) in our site.

      //
      // Class References
      //
      this.Class = {
         ABApplication,
         ABComponent,
         ABDefinition,
         ABFieldManager,
         ABIndex,
         ABMLClass,
         ABObject,
         ABObjectExternal,
         ABObjectImport,
         ABObjectApi,
         ABObjectQuery,
         ABProcessParticipant,
         // ABRole      // Do we need this anymore?

         // ABObjectWorkspaceViewGrid,
         // ABObjectWorkspaceViewKanban,
         // ABObjectWorkspaceViewGantt,

         ABProcessTaskManager,

         ABViewDetailItem,
         ABViewFormItem,
         ABMobileViewFormItem,
      };

      //
      // Rules
      // These are a common set of "rules" for all platforms.
      //
      this.rules = {
         /**
          * @method AB.rules.isUUID
          * evaluate a given value to see if it matches the format of a uuid
          * @param {string} key
          * @return {boolean}
          */
         isUUID: function (key) {
            var checker = RegExp(
               "^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$",
               "i"
            );
            return checker.test(key);
         },

         /**
          * @method AB.rules.nameFilter()
          * return a properly formatted name for an AppBuilder object.
          * @param {string} name
          *        The name of the object we are conditioning.
          * @return {string}
          */
         nameFilter: function (name) {
            return String(name).replace(/[^a-z0-9_.]/gi, "");
         },

         /**
          * @method AB.rules.toApplicationNameFormat()
          * return a properly formatted Application Name
          * @param {string} name
          *        The name of the Application we are conditioning.
          * @return {string}
          */
         toApplicationNameFormat: function (name) {
            return "AB_" + this.nameFilter(name);
         },

         /**
          * @method AB.rules.toFieldRelationFormat()
          * This function uses for define relation name of Knex Objection
          * return a relation name of column
          * @param {string} colName
          *        The name of the Column
          * @return {string}
          */
         toFieldRelationFormat: function (colName) {
            return this.nameFilter(colName) + "__relation";
         },

         /**
          * @method AB.rules.toJunctionTableFK()
          * return foriegnkey (FK) column name for a junction table name
          * @param {string} objectName
          *        The name of the Object with a connection
          * @param {string} columnName
          *        The name of the connection columnName.
          * @return {string}
          */
         toJunctionTableFK: function (objectName, columnName) {
            var fkName = objectName + "_" + columnName;

            if (fkName.length > 64) fkName = fkName.substring(0, 64);

            return fkName;
         },

         /**
          * @method AB.rules.toJunctionTableNameFormat()
          * return many-to-many junction table name
          * @param {string} appName
          *        The name of the Application for this object
          * @param {string} sourceTableName
          *        The name of the source object we are conditioning.
          * @param {string} targetTableName
          *        The name of the target object we are conditioning.
          * @param {string} colName
          * @return {string}
          */
         toJunctionTableNameFormat: function (
            appName,
            sourceTableName,
            targetTableName,
            colName
         ) {
            // The maximum length of a table name in MySql is 64 characters
            appName = this.toApplicationNameFormat(appName);
            if (appName.length > 17) appName = appName.substring(0, 17);

            if (sourceTableName.length > 15)
               sourceTableName = sourceTableName.substring(0, 15);

            if (targetTableName.length > 15)
               targetTableName = targetTableName.substring(0, 15);

            colName = this.nameFilter(colName);
            if (colName.length > 14) colName = colName.substring(0, 14);

            return "{appName}_{sourceName}_{targetName}_{colName}"
               .replace("{appName}", appName)
               .replace("{sourceName}", sourceTableName)
               .replace("{targetName}", targetTableName)
               .replace("{colName}", colName);
         },

         /**
          * @method AB.rules.toObjectNameFormat
          * return a properly formatted Object/Table Name
          * @param {string} objectName
          *        The {ABObject}.name of the Object we are conditioning.
          * @return {string}
          */
         toObjectNameFormat: function (objectName) {
            return `AB_${this.nameFilter(objectName)}`;
         },
      };

      // Notify Helpers
      this.notify.builder = (...params) => {
         this.notify("builder", ...params);
      };

      this.notify.developer = (...params) => {
         this.notify("developer", ...params);
      };
   }

   /**
    * @method definitionClean()
    * make sure the provided ABDefinition values are properly formatted
    * @param {ABDefinition} d
    *        The json settings of an ABDefinition object.
    */
   definitionClean(d) {
      if (typeof d.json == "string") {
         try {
            d.json = JSON.parse(d.json);
         } catch (e) {
            console.log(e);
            console.error(` Error on definition id[${d.id}]`);
         }
      }
   }

   init() {
      let allDefinitions = Object.keys(this._definitions).map(
         (k) => this._definitions[k]
      );
      // {array} all our definitions in an Array format.

      // make sure our definitions.json field is an {} and not string
      allDefinitions.forEach((d) => {
         this.definitionClean(d);
      });

      // perform these in order:
      [
         "object",
         "query",
         "datacollection",
         "process",
         "hint",
         "step",
         "application",
      ].forEach((type) => {
         var objTypes = allDefinitions.filter((d) => d.type == type);
         objTypes.forEach((def) => {
            let { keyList, keyFn } = this.objectKeysByDef(def);
            if (keyList) {
               this[keyList].push(this[keyFn](def.json));
            }
         });
      });

      this.emit("init.objects_ready");
      return Promise.resolve();
   }

   /**
    * @method objectKeysByDef()
    * Analyze the provided ABDefinition json and return which set of list and
    * functions are used to create a new instance of this definition.
    * @param {json} def
    *        the ABDefinition json of the definition we are evaluating
    * @return { keyList, keyFn }
    *        keyList: {string}  which of our internal lists to store this new
    *                 object.
    *        keyFn: {string} which of our methods to call with the def.json
    *               as the param that will create the new object.
    *
    *        ex:  this[keyList].push( this[keyFn](def.json));
    *
    *        if this def is not one of the types we track,
    *        keyList = keyFn = null;
    */
   objectKeysByDef(def) {
      switch (def.type) {
         case "application":
            return { keyList: "_allApplications", keyFn: "applicationNew" };

         case "datacollection":
            return {
               keyList: "_allDatacollections",
               keyFn: "datacollectionNew",
            };

         case "hint":
            return { keyList: "_allHints", keyFn: "hintNew" };

         case "steps":
            return { keyList: "_allSteps", keyFn: "stepNew" };

         case "object":
            return { keyList: "_allObjects", keyFn: "objectNew" };

         case "process":
            return { keyList: "_allProcesses", keyFn: "processNew" };

         case "query":
            return { keyList: "_allQueries", keyFn: "queryNew" };

         default:
            // we don't manage any other
            return { keyList: null, keyFn: null };
      }
   }

   //
   // Definitions
   //

   /**
    * definitionByID(id)
    * return an ABDefinition.json value ready for our objects to use.
    * @param {string} id
    *        the uuid of the ABDefinition to delete
    * @param {bool} isRaw
    *        indicates if we want the full ABDefinition, or the .json param
    *        true : returns full ABDefinition value.
    *        false: returns the .json parameter used by most ABObjects.
    * @return {Promise}
    */
   definitionByID(id, isRaw = false) {
      if (this._definitions[id]) {
         if (isRaw) {
            return this._definitions[id];
         } else {
            return this._definitions[id].json;
         }
      }
      return null;
   }

   /**
    * definitionNew(values)
    * return an ABDefinition object tied to this Tenant.
    * @param {obj} values
    *        The value hash of the ABDefinition object to create.
    * @return {ABDefinition}
    */
   definitionNew(values) {
      return new ABDefinition(values, this);
   }

   /**
    * definitionsParse()
    * include the incoming definitions into our ABFactory. These new
    * definitions will replace any existing ones with the same .id.
    * @param {array[ABDefinitioin]} defs
    *     the incoming array of ABDefinitions to parse.
    * @return {Promise}
    */
   definitionsParse(defs = []) {
      if (!Array.isArray(defs)) {
         defs = [defs];
      }

      // store/replace the incoming definitions
      // 1st: insert ALL our definitions internally
      defs.forEach((d) => {
         this.definitionClean(d);
         this._definitions[d.id] = d;
      });
      // 2nd: Now we can then go through and signal the "updates"
      // and the related objects can find their dependent definitions.
      defs.forEach((d) => {
         this.definitionSync("updated", d.id, d);
      });

      return Promise.resolve();
   }

   /**
    * definitionSync()
    * Synchronize an individual definition into our repository of definitions.
    * @param {string} op
    *        the type of synchronization this is
    *        [ "created", "updated", "destroyed"]
    * @param {uuid} id
    *        the definition.id of the definition we are synchronizing
    * @param {json} def
    *        the ABDefinition attributes we are storing.
    */
   definitionSync(op, id, def) {
      var { keyList, keyFn } = this.objectKeysByDef(def);
      if (keyList) {
         var curr;
         switch (op) {
            case "created":
               this[keyList].push(this[keyFn](def.json));
               this.emit("definition.created", def.json);
               break;

            case "updated":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);

               // remove from list
               this[keyList] = this[keyList].filter((d) => d.id != id);
               // add new one:
               this[keyList].push(this[keyFn](def.json));

               // signal this object needs to be updated:
               // NOTE: if this is one of the objects we are tracking,
               // we don't need to this.emit() the message.
               if (curr) {
                  curr.emit("definition.updated", def.json);
               } else {
                  this.emit("definition.updated", def.json);
               }
               break;

            case "destroyed":
               // get the current object
               curr = this[keyList].find((d) => d.id == id);
               if (curr) {
                  // remove from list
                  this[keyList] = this[keyList].filter((d) => d.id != id);

                  // signal this object needs to be updated:
                  curr.emit("definition.deleted", def.json);

                  this.emit("definition.deleted", def.json);
               }
               break;
         }
      }
   }

   //
   // ABObjects
   //
   /**
    * @method applications()
    * return all the ABApplications that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABApplications.
    *        Must return true to include the entry.
    * @return {array}
    */
   applications(fn = () => true) {
      return (this._allApplications || []).filter(fn);
   }

   /**
    * @method applicationByID()
    * returns a single ABApplication that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABApplication we are searching
    *        for.
    * @return {ABApplication}
    *        the matching ABApplication object if found
    *        {null} if not found.
    */
   applicationByID(ID) {
      return this.applications((a) => a.id == ID)[0];
   }

   /**
    * @method applicationNew()
    * Return a new instance of an ABApplication object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplication object we are
    *        creating.
    * @return {ABApplication}
    */
   applicationNew(values) {
      // just in case we got here by mistake:
      if (values.appType == "mobile") {
         return this.applicationMobileNew(values);
      }

      return new ABApplication(values, this);
   }

   /**
    * @method applicationMobileNew()
    * Return a new instance of an ABApplicationMobile object.
    * @param {json} values
    *        the ABDefinition.json of the ABApplicationMobile object we are
    *        creating.
    * @return {ABApplicationMobile}
    */
   applicationMobileNew(values) {
      return new ABApplicationMobile(values, this);
   }

   /**
    * @method datacollections()
    * return an array of all the ABDataCollection for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABDataCollection that
    *        this fn returns true for.
    * @return {array}
    *        array of ABDataCollection
    */
   datacollections(filter = () => true) {
      return (this._allDatacollections || []).filter(filter);
   }

   /**
    * @method datacollectionByID()
    * returns a single ABDatacollection that matches the given ID.
    * @param {string} ID
    *        the .id/.name/.label of the ABDatacollection we are searching
    *        for.
    * @return {ABDatacollection}
    *        the matching ABDatacollection object if found
    *        {null} if not found.
    */
   datacollectionByID(ID) {
      // an undefined or null ID should not match any DC.
      if (!ID) return null;

      return this.datacollections((dc) => {
         return dc.id == ID || dc.name == ID || dc.label == ID;
      })[0];
   }

   /**
    * @method datacollectionNew()
    * create a new instance of ABDataCollection
    * @param {obj} values
    *        the initial values for the DC
    * @return {ABDatacollection}
    */
   datacollectionNew(values) {
      var dc = new ABDataCollection(values, this);
      dc.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allDatacollections = this._allDatacollections.filter(
            (d) => d.id != dc.id
         );
      });
      return dc;
   }

   /**
    * @method fieldNew()
    * return an instance of a new (unsaved) ABField that is tied to a given
    * ABObject.
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    * @param {obj} values  the initial values for this field.
    *                - { key:'{string}'} is required
    * @param {ABObject} object  the parent object this field belongs to.
    * @return {ABField}
    */
   fieldNew(values, object) {
      // NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
      return ABFieldManager.newField(values, object);
   }

   /**
    * @method indexNew()
    * return an instance of a new (unsaved) ABIndex.
    * @return {ABIndex}
    */
   indexNew(values, object) {
      return new ABIndex(values, object);
   }

   /**
    * @method Label()
    * a simple label factory.
    * It is expected to be called like this:
    * @codestart
    *    var L = AB.Label();
    *    var outputText = L("Hello World");
    *    var o2 = L("I'm {0} years old", [5]);
    * @codeend
    * @return {fn}
    */
   Label() {
      return (key, altText, values = []) => {
         var label = key;
         if (altText) {
            if (Array.isArray(altText)) {
               values = altText;
            } else {
               label = altText;
            }
         }

         values.forEach((v, i) => {
            var sub = `{${i}}`;
            label = label.replaceAll(sub, v);
         });

         return label;
      };
   }

   /**
    * @method objects()
    * return an array of all the ABObjects for this ABApplication.
    * @param {fn} filter
    *        a filter fn to return a set of ABObjects that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObject
    */
   objects(filter = () => true) {
      return (this._allObjects || []).filter(filter);
   }

   /**
    * @method objectByID()
    * return the specific object requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   objectByID(ID) {
      return this.objects((o) => {
         return o.id == ID || o.name == ID || o.label == ID;
      })[0];
   }

   /**
    * @method objectNew()
    * return an instance of a new (unsaved) ABObject that is tied to this
    * ABApplication.
    * NOTE: this new object is not included in our this.objects until a .save()
    * is performed on the object.
    * @return {ABObject}
    */
   objectNew(values) {
      var newObj = null;

      if (values.isExternal == true)
         newObj = new ABObjectExternal(values, this);
      else if (values.isImported == true)
         newObj = new ABObjectImport(values, this);
      else if (values.isAPI == true) newObj = new ABObjectApi(values, this);
      else newObj = new ABObject(values, this);

      /*
      // IS THIS CORRECT?
      newObj.on("destroyed", () => {
         // make sure it is no longer in our internal list
         this._allObjects = this._allObjects.filter((o) => o.id != newObj.id);
      });
      */

      return newObj;
   }

   objectFile() {
      return this.objectByID("4a9d89c9-f4eb-41af-91e4-909eff389f3e");
   }

   objectLanguage() {
      return this.objectByID("d84cd351-d96c-490f-9afb-2a0b880ca0ec");
   }

   objectProcessForm() {
      return this.objectByID("d36ae4c8-edef-48d8-bd9c-79a0edcaa067");
   }

   objectProcessInstance() {
      return this.objectByID("2ba85be0-78db-4eda-ba43-c2c4e3831849");
   }

   objectRole() {
      return this.objectByID("c33692f3-26b7-4af3-a02e-139fb519296d");
   }

   objectScope() {
      return this.objectByID("af10e37c-9b3a-4dc6-a52a-85d52320b659");
   }

   objectToken() {
      return this.objectByID("08826ac7-4b33-4745-a3d7-f7831ca4ff59");
   }

   objectUser() {
      return this.objectByID("228e3d91-5e42-49ec-b37c-59323ae433a1");
   }

   objectKey() {
      return this.objectByID("d734fe8c-b615-446c-8a5f-793ddece19f9");
   }

   objectSecret() {
      return this.objectByID("db5b3b26-5300-4c92-bc73-8ce4f4696992");
   }

   //
   // Hints
   //
   /**
    * @method hints()
    * return all the ABHints that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABHints.
    *        Must return true to include the entry.
    * @return {array}
    */
   hints(filter = () => true) {
      return (this._allHints || []).filter(filter);
   }

   /**
    * @method hintByID()
    * return the specific hint requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   hintID(ID) {
      return this.hints((h) => {
         return h.id == ID || h.name == ID || h.label == ID;
      })[0];
   }

   /**
    * @method hintNew()
    * return an instance of a new (unsaved) ABHint that is tied to this
    * ABApplication.
    * NOTE: this new hint is not included in our this.hints until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   hintNew(values) {
      var newHint = new ABHint(values, this);

      return newHint;
   }

   //
   // Steps
   //
   /**
    * @method steps()
    * return all the ABSteps that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABSteps.
    *        Must return true to include the entry.
    * @return {array}
    */
   steps(filter = () => true) {
      return (this._allSteps || []).filter(filter);
   }

   /**
    * @method stepByID()
    * return the specific step requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   stepID(ID) {
      return this.steps((s) => {
         return s.id == ID || s.name == ID || s.label == ID;
      })[0];
   }

   /**
    * @method stepNew()
    * return an instance of a new (unsaved) ABStep that is tied to this
    * ABApplication.
    * NOTE: this new step is not included in our this.steps until a .save()
    * is performed on the object.
    * @return {ABHint}
    */
   stepNew(id, hintID) {
      var stepDef = this.definitionByID(id);
      if (stepDef) {
         var getStep = new ABStep(stepDef, this);
         return getStep;
      } else {
         var params = {
            settings: {
               hint: hintID,
            },
         };
         var newStep = new ABStep(params, this);
         return newStep;
      }
      // return null;
   }

   //
   // Processes
   //
   /**
    * @method processes()
    * return all the ABProcess that match the provided filter.
    * @param {fn} fn
    *        A filter function to select specific ABProcess.
    *        Must return true to include the entry.
    * @return {array}
    */
   processes(filter = () => true) {
      return (this._allProcesses || []).filter(filter);
   }

   /**
    * @method processByID()
    * return the specific process requested by the provided id.
    * @param {string} ID
    * @return {obj}
    */
   processByID(ID) {
      return this.processes((p) => {
         return p.id == ID || p.name == ID || p.label == ID;
      })[0];
   }

   /**
    * @method processNew()
    * Return a new instance of an ABProcess object.
    * @param {json} values
    *        the ABDefinition.json of the ABProcess object we are
    *        creating.
    * @return {ABProcess}
    */
   processNew(values) {
      return new ABProcess(values, this);
   }

   /**
    * @method processElementNew(id)
    * return an instance of a new ABProcessOBJ that is tied to a given
    * ABProcess.
    * @param {string} id
    *        the ABDefinition.id of the element we are creating
    * @param {ABProcess} process
    *        the process this task is a part of.
    * @return {ABProcessTask}
    */
   processElementNew(id, process) {
      var taskDef = this.definitionByID(id);
      if (taskDef) {
         switch (taskDef.type) {
            case ABProcessParticipant.defaults().type:
               return new ABProcessParticipant(taskDef, process, this);
            // break;

            case ABProcessLane.defaults().type:
               return new ABProcessLane(taskDef, process, this);
            // break;

            default:
               // default to a Task
               return ABProcessTaskManager.newTask(taskDef, process, this);
            // break;
         }
      }
      return null;
   }

   /**
    * @method processElementNewForModelDefinition(def)
    *
    * return an instance of a new ABProcess[OBJ] that is tied to the given
    * BPMI:Element definition.
    *
    * @param {BPMI:Element} element the element definition from our BPMI
    *              modler.
    * @return {ABProcess[OBJ]}
    */
   processElementNewForModelDefinition(element, process) {
      var newElement = null;

      switch (element.type) {
         case "bpmn:Participant":
            newElement = new ABProcessParticipant({}, process, this);
            break;

         case "bpmn:Lane":
            newElement = new ABProcessLane({}, process, this);
            break;

         default:
            var defaultDef = ABProcessTaskManager.definitionForElement(element);
            if (defaultDef) {
               newElement = ABProcessTaskManager.newTask(
                  defaultDef,
                  process,
                  this
               );
            }
            break;
      }

      // now make sure this new Obj pulls any relevant info from the
      // diagram element
      if (newElement) {
         newElement.fromElement(element);
      }
      return newElement;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery(s).
    * @param {fn} filter
    *        a filter fn to return a set of ABObjectQuery(s) that this fn
    *        returns true for.
    * @return {array}
    *        array of ABObjectQuery
    */
   queries(filter = () => true) {
      return (this._allQueries || []).filter(filter);
   }
   // queriesAll() {
   //    console.error(
   //       "ABFactory.queriesAll() Depreciated! Use .queries() instead. "
   //    );
   //    return this.queries();
   // }

   /**
    * @method queryByID()
    * return the specific query requested by the provided id.
    * NOTE: this method has been extended to allow .name and .label
    * as possible lookup values.
    * @param {string} ID
    * @return {ABObjectQuery}
    */
   queryByID(ID) {
      return this.queries((q) => {
         return q.id == ID || q.name == ID || q.label == ID;
      })[0];
   }

   /**
    * @method queryNew()
    * return an instance of a new (unsaved) ABObjectQuery that is tied to this
    * ABFactory.
    * @return {ABObjectQuery}
    */
   queryNew(values) {
      return new ABObjectQuery(values, this);
   }

   /**
    * @method rowfilterNew()
    * return an instance of a new RowFilter that is tied to this
    * ABFactory.
    * @return {RowFilter}
    */
   rowfilterNew(App, idBase) {
      if (App) {
         console.error("!! Who is calling this with an App?");
      }
      return new RowFilter(App || this._App, idBase, this);
   }

   /**
    * @method filterComplexNew()
    * return an instance of a new FilterComplex that is tied to this
    * ABFactory.
    * @return {FilterComplex}
    */
   filterComplexNew(idBase, options = {}) {
      return new FilterComplex(idBase, this, options);
   }

   /**
    * @method viewNewDetatched()
    * Return an instance of a View that is NOT attached to an ABApplication.
    * @return {ABViewXXX}
    */
   viewNewDetatched(values) {
      if (!this._mockApp) {
         this._mockApp = this.applicationNew({});
      }
      return this._mockApp.viewNew(values, this._mockApp);
   }

   //
   // Utilities
   //

   /**
    * notify()
    * will send alerts to a group of people. These alerts are usually about
    * configuration errors, or software problems.
    * @param {string} domain
    *     which group of people we are sending a notification to.
    * @param {Error} error
    *     An error object generated at the point of issue.
    * @param {json} info
    *     Additional related information concerning the issue.
    */
   notify(/* ...params */) {
      console.error(
         "ABFactory.notify() is expected to be overwritten by the platform!"
      );
   }

   /**
    * notifyInfo()
    * a common routine to parse the info parameter provided to .notify() into
    * a more detailed set of data.
    * @param {json} info
    * @return {json}
    */
   _notifyInfo(info) {
      var moreInfo = {};

      if (info) {
         Object.keys(info).forEach((k) => {
            switch (k) {
               case "field":
                  moreInfo.objectID = info[k].object?.id;
                  moreInfo.objectName = info[k].object?.name;
                  moreInfo.fieldID = info[k].id;
                  moreInfo.fieldName = info[k].label || info[k].name;
                  break;

               case "object":
                  moreInfo.objectID = info[k].id;
                  moreInfo.objectName = info[k].name;
                  break;

               case "datacollection":
                  moreInfo.datacollectionID = info[k].id;
                  moreInfo.datacollectionName = info[k].label || info[k].name;
                  var ds = info[k].datasource;
                  if (ds) {
                     moreInfo.datacollectionDSID = ds.id;
                     moreInfo.datacollectionDSName = ds.name;
                  }
                  break;

               case "process":
                  moreInfo.processID = info[k].id;
                  moreInfo.processName = info[k].label || info[k].name;
                  break;

               case "req":
                  moreInfo.req = {
                     jobID: info[k].jobID,
                     tenantID: info[k]._tenantID,
                     user: info[k]._user,
                  };
                  break;

               case "task":
                  if (info[k].process) {
                     moreInfo.processID = info[k].process.id;
                     moreInfo.processName =
                        info[k].process.label || info[k].process.name;
                  }
                  moreInfo.taskID = info[k].id;
                  moreInfo.taskName = info[k].label || info[k].name;
                  break;

               case "view":
                  if (info[k].application) {
                     moreInfo.applicationID = info[k].application.id;
                     moreInfo.applicationName =
                        info[k].application.label || info[k].application.name;
                  }
                  moreInfo.viewID = info[k].id;
                  moreInfo.viewName = info[k].label || info[k].name;
                  moreInfo.viewKey = info[k].key;
                  break;
               default:
                  moreInfo[k] = info[k];
                  break;
            }
         });
      }

      return moreInfo;
   }
}

module.exports = ABFactory;


/***/ }),

/***/ 67431:
/*!*******************************************!*\
  !*** ./AppBuilder/core/ABFieldManager.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldManager
 *
 * An interface for managing the different ABFields available in our AppBuilder.
 *
 */

/*
 * Fields
 * A name => ABField  hash of the different ABFields available.
 */
var Fields = {};

var AllFieldClasses = [
   __webpack_require__(/*! ../platform/dataFields/ABFieldString */ 2163),
   __webpack_require__(/*! ../platform/dataFields/ABFieldLongText */ 26331),
   __webpack_require__(/*! ../platform/dataFields/ABFieldNumber */ 18799),
   __webpack_require__(/*! ../platform/dataFields/ABFieldDate */ 4637),
   __webpack_require__(/*! ../platform/dataFields/ABFieldDateTime */ 85690),
   __webpack_require__(/*! ../platform/dataFields/ABFieldBoolean */ 9740),
   __webpack_require__(/*! ../platform/dataFields/ABFieldList */ 34963),
   __webpack_require__(/*! ../platform/dataFields/ABFieldTree */ 10567),
   __webpack_require__(/*! ../platform/dataFields/ABFieldEmail */ 75922),
   __webpack_require__(/*! ../platform/dataFields/ABFieldFile */ 72408),
   __webpack_require__(/*! ../platform/dataFields/ABFieldImage */ 15884),
   __webpack_require__(/*! ../platform/dataFields/ABFieldUser */ 78025),
   __webpack_require__(/*! ../platform/dataFields/ABFieldConnect */ 89981),
   __webpack_require__(/*! ../platform/dataFields/ABFieldCalculate */ 59675),
   __webpack_require__(/*! ../platform/dataFields/ABFieldTextFormula */ 81961),
   __webpack_require__(/*! ../platform/dataFields/ABFieldFormula */ 37900),
   __webpack_require__(/*! ../platform/dataFields/ABFieldAutoIndex */ 44322),
   __webpack_require__(/*! ../platform/dataFields/ABFieldJson */ 4213),
   __webpack_require__(/*! ../platform/dataFields/ABFieldCombine */ 63048),
   __webpack_require__(/*! ../platform/dataFields/ABFieldSelectivity */ 53317),
];

AllFieldClasses.forEach((FIELD) => {
   Fields[FIELD.defaults().key] = FIELD;
});

module.exports = class ABFieldManager {
   /*
    * @function allFields
    * return all the currently defined ABFields in an array.
    * @return [{ABField},...]
    */
   static allFields() {
      var fields = [];
      for (var f in Fields) {
         fields.push(Fields[f]);
      }
      return fields;
   }

   /**
    * @function fieldByKey()
    * Return a specific ABField that matches the given key
    * @param {string} key
    *        The ABField.key value we are looking for.
    * @return {ABFieldXXX || undefined}
    */
   static fieldByKey(key) {
      return Fields[key];
   }

   /*
    * @function newField
    * return an instance of an ABField based upon the values.key value.
    * @return {ABField}
    */
   static newField(values, object) {
      if (values.key) {
         try {
            return new Fields[values.key](values, object);
         } catch (err) {
            console.log("Error", err);
            console.log("Available fields", Fields);
            console.log("Requested field", values.key);
         }
      } else {
         console.log("-------");
         console.log("values:");
         console.error(values);
         console.log();
         console.error("object:");
         console.error(object);
         console.log("-------");
         throw new Error(
            `ABFieldManager.newField(): Unknown Field Key [${values.name}][${values.key}] for object[${object.name}]`
         );
         //// TODO: what to do here?
      }
   }
};


/***/ }),

/***/ 43472:
/*!***************************************!*\
  !*** ./AppBuilder/core/ABHintCore.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"

var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);
const _concat = __webpack_require__(/*! lodash/concat */ 60659);

module.exports = class ABHintCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["name", "description"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      description: 'description',
      type: 'hint',
      settings: {
         active: {boolean},
         view: uuid
      }
    }
    */

      let active = attributes?.settings?.active ?? "1";

      this.id = attributes?.id || "";
      this.name = attributes?.name || "New Tutorial";
      this.description = attributes?.description || "";
      this.type = attributes?.type || "hint";
      this.settings = {};
      this.settings.active = active;
      this.settings.transition = attributes?.settings?.transition;
      this.settings.showIntroStep = attributes?.settings?.showIntroStep;
      this.settings.view = attributes?.settings?.view || "";
      this.stepIDs = attributes?.stepIDs || [];

      let currSteps = this?._steps || {};
      this._steps = {};
      (attributes?.stepIDs || []).forEach((sID) => {
         if (!sID) return;
         var ele = this.AB.stepNew(sID, this.id);
         if (ele) {
            this._steps[sID] = ele;
         }
      });
      if (attributes) super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["type", "settings", "stepIDs", "id", "name"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * steps()
    * return an array of steps that match the given filter (or all steps
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABStep]}
    */
   steps(fn = () => true) {
      var allSteps = Object.keys(this._steps).map((e) => {
         return this._steps[e];
      });
      return allSteps.filter(fn);
   }

   /**
    * stepAdd()
    * insert a step to be added to this hint.
    * @param {ABStep} element
    *        the full instance of an ABStep to track.
    */
   stepAdd(step) {
      this._steps[step.id] = step;
   }

   /**
    * stepByID()
    * return the {ABStep} that has the given .id
    * @param {string} id
    * @return {ABStep[OBJ]}
    */
   stepByID(id) {
      return this._steps[id] ?? null;
   }

   /**
    * stepRemove()
    * remove a step from being displayed by this hint.
    * @param {id} ABStep ID
    *        an ID of a step
    *        to remove.
    */
   stepRemove(id) {
      // remove from stepIDs array
      let stepIndex = this.stepIDs.indexOf(id);
      if (stepIndex > -1) {
         this.stepIDs.splice(stepIndex, 1);
      }
      // remove from _steps definitions
      delete this._steps[id];
   }
};


/***/ }),

/***/ 12796:
/*!****************************************!*\
  !*** ./AppBuilder/core/ABIndexCore.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);

module.exports = class ABIndexCore extends ABMLClass {
   constructor(attributes, object) {
      super(["label"], object.AB);
      this.object = object;

      this.fromValues(attributes);
   }

   fromValues(attributes) {
      /*
      {
        id: uuid(),
        name: 'name',
        fields:[
            {ABDataField.id}
        ],
        unique: {boolean}
      }
      */
      this.id = attributes.id;
      this.type = "index";
      this.name = attributes.name;
      this.unique = JSON.parse(attributes.unique || false);

      // Convert to an array
      if (attributes.fieldIDs && !Array.isArray(attributes.fieldIDs)) {
         attributes.fieldIDs = [attributes.fieldIDs];
      }

      this._unknownFieldIDs = [];
      this.fields = (attributes.fieldIDs || [])
         .map((f) => {
            let field = this.object.fieldByID(f);
            if (!field) {
               this._unknownFieldIDs.push(f);
               let err = new Error(
                  `Index[${this.name}][${this.id}] is referencing an unknown field[${f}]`
               );
               this.AB.notify.developer(err, {
                  index: this.id,
                  field: f,
               });
            }
            return field;
         })
         .filter((fId) => fId);

      if (this.fields.length == 0) {
         let err = new Error(
            `Index[${this.name}][${this.id}] is not referencing any fields`
         );
         this.AB.notify.developer(err, {
            index: this.id,
            attributeFieldIDs: attributes.fieldIDs || [],
         });
      }

      // let the MLClass process the Translations
      super.fromValues(attributes);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let result = super.toObj();

      result.id = this.id;
      result.type = "index";
      result.name = this.name;
      result.unique = this.unique;

      // Convert to an array
      if (this.fields && !Array.isArray(this.fields)) {
         this.fields = [this.fields];
      }

      result.fieldIDs = (this.fields || [])
         .map((f) => {
            // Convert to the id of field
            return f.id || f;
         })
         .filter((fId) => fId);

      // carry along the unknown Field IDs so a
      // developer/builder can come along and trace
      // what happened.
      this._unknownFieldIDs.forEach((f) => {
         result.fieldIDs.push(f);
      });

      return result;
   }

   get indexName() {
      let tableName = this.object.dbTableName();

      // Maximum 64 characters long
      return `${tableName}_${this.name}`.replace(/ /g, "").substring(0, 64);
   }

   get uniqueName() {
      let indexName = this.indexName.substring(0, 57);

      return `${indexName}_unique`;
   }
};


/***/ }),

/***/ 21177:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABMLClassCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABMLClassCore
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This core ABMLClass will internally track the multilingual fields
 * (this.mlFields) and auto
 */
var ABEmitter = __webpack_require__(/*! ../platform/ABEmitter */ 26263);
module.exports = class ABMLClassCore extends ABEmitter {
   constructor(fieldList, AB) {
      super();
      this.mlFields = fieldList || ["label"];
      // {array}
      // field names of values that are multilingual

      this.AB = AB;
      // {ABFactory}
      // our common source of references for other AB objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * @method fromValues
    * called during the .fromValues() work chain.  Should be called
    * AFTER all the current data is already populated.
    */
   fromValues(attributes) {
      this.translations = attributes.translations;

      // if translations were provided
      if (this.translations) {
         // multilingual fields: label, description
         this.translate();
      } else {
         // maybe this came from a form that has ML values in the attributes, but
         // no .translations[] yet:
         // check for mlFields in attributes and record them here:
         (this.mlFields || []).forEach((field) => {
            if (attributes[field]) {
               this[field] = attributes[field];
            }
         });
      }
   }

   /**
    * @function defaultTranslations()
    * return an initial .translations entry to initialize the
    * translations values of a given translateable object.
    * @param {array} fields  the multilingual fields this obj manages.
    * @param {json}  values  a default set of values for this object.
    * @return {array}  of translation entries.
    */
   defaultTranslations(fields, values) {
      values = values || {};

      var entry = {
         // Question: should this be this.AB.Multilingual.currentLanguage() || "en"
         // currently since the defaults are sent in programattically, we are
         // expecting the labels to be in "en"
         language_code: "en",
      };

      fields.forEach((f) => {
         entry[f] = values[f] || f;
      });

      return [entry];
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return "en";
   }

   /**
    * @method toObj()
    * called during the .toObj() work chain.  Should be called
    * BEFORE the current data is populated.
    */
   toObj() {
      this.unTranslate();

      return {
         translations: this.translations,
      };
   }

   /**
    * @method toDefinition()
    * convert this instance into an ABDefinition object.
    * @return {ABDefinition}
    */
   toDefinition() {
      return this.AB.definitionNew({
         id: this.id,
         name: this.name,
         type: this.type,
         json: this.toObj(),
      });
   }

   /**
    * @method translate
    * Given a set of json data, pull out any multilingual translations
    * and flatten those values to the base object.
    * @param {obj} obj  The instance of the object being translated
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull to
    *                       the obj[field] value.
    */
   translate(obj, json, fields, languageCode = null) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      if (typeof json.translations == "string") {
         json.translations = JSON.parse(json.translations);
      }

      var currLanguage = languageCode || this.languageDefault();

      if (fields && fields.length > 0) {
         // [fix] if no matching translation is in our json.translations
         //       object, then just use the 1st one.
         var first = null; // the first translation entry encountered
         var found = false; // did we find a matching translation?

         json.translations.forEach(function (t) {
            if (!first) first = t;

            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               found = true;

               // copy each field to the root object
               fields.forEach(function (f) {
                  if (t[f] != null) obj[f] = t[f];

                  obj[f] = t[f] || ""; // default to '' if not found.
               });
            }
         });

         // if !found, then use the 1st entry we did find.  prepend desired
         // [language_code] to each of the fields.
         if (!found && first) {
            // copy each field to the root object
            fields.forEach(function (f) {
               if (first[f] != null && first[f] != "")
                  obj[f] = `[${currLanguage}]${first[f]}`;
               else obj[f] = ""; // default to '' if not found.
            });
         }
      }
   }

   /**
    * @method unTranslate
    * Take the multilingual information in the base obj, and push that
    * down into the json.translations data.
    * @param {obj} obj  The instance of the object with the translation
    * @param {json} json The json data being used for translation.
    *                      There should be json.translations = [ {transEntry}, ...]
    *                      where transEntry = {
    *                          language_code:'en',
    *                          field1:'value',
    *                          ...
    *                      }
    * @param {array} fields an Array of multilingual fields to pull from
    *                       the obj[field] value.
    */
   unTranslate(obj, json, fields) {
      if (!obj) obj = this;
      if (!json) json = this;
      if (!fields) fields = this.mlFields || [];

      if (!json.translations) {
         json.translations = [];
      }

      var currLanguage = this.languageDefault();

      if (fields && fields.length > 0) {
         var foundOne = false;

         json.translations.forEach(function (t) {
            // find the translation for the current language code
            if (t.language_code == currLanguage) {
               // copy each field to the root object
               fields.forEach(function (f) {
                  // verify obj[f] is defined
                  // --> DONT erase the existing translation
                  if (obj[f] != null) {
                     t[f] = obj[f];
                  }
               });

               foundOne = true;
            }
         });

         // if we didn't update an existing translation
         if (!foundOne) {
            // create a translation entry:
            var trans = {};

            // assume current languageCode:
            trans.language_code = currLanguage;

            fields.forEach(function (field) {
               if (obj[field] != null) {
                  trans[field] = obj[field];
               }
            });

            json.translations.push(trans);
         }
      }
   }
};


/***/ }),

/***/ 69410:
/*!****************************************!*\
  !*** ./AppBuilder/core/ABModelCore.js ***!
  \****************************************/
/***/ ((module) => {

//
// ABModelCore
//
// Represents the Data interface for an ABObject data.
//
// to use an ABModel to load a DataTable:
// Method 1:
//  gather all the data externally and send to the DataTable
//    Model.findAll()
//    .then((data)=>{
//      DataTable.parse(data);
//    })
//

module.exports = class ABModelCore {
   constructor(object) {
      // link me to my ABObject
      this.object = object;
      this.AB = object.AB;

      this._where = null;
      this._sort = null;
      this._skip = null;
      this._limit = null;

      this.staleRefreshInProcess = false;
      this.staleRefreshMap = {
         /* id : Promise */
      };
      this.staleRefreshPending = [];
      this.staleRefreshTimerID = null;

      // include this
      this.responseContext = { key: "--", context: {} };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   contextKey(key) {
      this.responseContext.key = key || "--";
   }

   contextValues(values) {
      this.responseContext.context = values || {};
   }

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      console.error(
         "!!! ABModelCore.request() should be overridden by platform."
      );
      return Promise.resolve();
   }

   // /**
   //  * @method create
   //  * update model values on the server.
   //  */
   // create(values) {

   //   this.prepareMultilingualData(values);

   //   var params = {
   //     url: this.object.urlRest(),
   //     params: values
   //   }
   //   return this.request('post', params)
   //     .then((data) => {

   //       this.normalizeData(data);

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a create event
   //       // triggerEvent('create', this.object, data);

   //     })
   //     .catch(reject);

   // }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer} id  the .id of the instance to remove.
    * @return {Promise}
    */
   // delete(id) {

   //   var params = {
   //     url: this.object.urlRestItem(id)
   //   }
   //   return this.request('delete', params)
   //     .then((data) => {

   //       return data;

   //       // FIX: now with sockets, the triggers are fired from socket updates.
   //       // trigger a delete event
   //       // triggerEvent('delete', this.object, id);

   //     })
   // }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   //   findAll(cond) {

   //     cond = cond || {};

   //     var params = {
   //       url: this.object.urlRest(),
   //       params: cond
   //     }
   //     return this.request('get', params)
   //       .then((data) => {

   //         this.normalizeData(data.data);

   //         resolve(data);
   //       })
   //       .catch((err) => {
   // /// TODO: this should be done in platform/ABModel:
   //         // if (err && err.code) {
   //         //  switch(err.code) {
   //         //    case "ER_PARSE_ERROR":
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Parse Error with provided condition', { error: err, condition:cond })
   //         //      break;

   //         //    default:
   //         //      OP.Error.log('AppBuilder:ABModel:findAll(): Unknown Error with provided condition', { error: err, condition:cond })
   //         //      break;
   //         //  }

   //         // }
   // console.error(err);
   //       })

   //   }

   urlParamsCreate(values) {
      return {
         url: this.object.urlRest(),
         params: values,
      };
   }

   urlParamsDelete(id) {
      return {
         url: this.object.urlRestItem(id),
      };
   }

   urlParamsFind(cond) {
      return {
         url: this.object.urlRest(),
         params: cond || {},
      };
   }

   urlParamsUpdate(id, values) {
      return {
         url: this.object.urlRestItem(id),
         params: values,
      };
   }

   /**
    * @method count
    * count a data find with the provided condition.
    */
   count(cond) {
      cond = cond || {};

      var params = {
         url: this.object.urlRestCount(),
         params: cond,
      };
      return this.request("get", params)
         .then((numberOfRows) => {
            // resolve(numberOfRows);
            return numberOfRows;
         })
         .catch((err) => {
            // TODO: this should be done in platform/ABModel

            // OP.Error.log('AppBuilder:ABModel:count(): Parse Error with provided condition', { error: err, condition:cond })

            // reject(err);
            console.error(err);
         });
   }

   /**
    * @method staleRefresh
    * Process a request to refresh the data for a given entry.
    * This method is called from a ABDataview when it receives
    * a 'ab.datacollection.stale' message.
    * This method will try to queue similar reqeusts and then issue 1 large
    * request, rather than numerous individual ones.
    * @param {obj} cond  the condition of the entry we are requesting.
    * @return {Promise}
    */
   staleRefresh(cond) {
      // cond should be { where:{ id: X } } format.
      var PK = this.object.PK();

      var currID = cond[PK]; // just in case we get a { id: X }
      if (cond.where) {
         currID = cond.where[PK];
      }

      return new Promise((resolve, reject) => {
         if (!currID) {
            var Err = new Error(
               "Model.staleRefresh(): could not resolve ." + PK
            );
            Err.cond = cond;
            reject(Err);
            return;
         }

         // convert to PK : Promise object:
         var entry = {
            resolve: resolve,
            reject: reject,
         };
         entry[PK] = currID;

         // queue up refresh condition
         this.staleRefreshPending.push(entry);

         // if ! staleRefreshInProcess
         if (!this.staleRefreshInProcess) {
            // set timeout to another 200ms wait after LAST staleRefresh()
            if (this.staleRefreshTimerID) {
               clearTimeout(this.staleRefreshTimerID);
            }
            this.staleRefreshTimerID = setTimeout(() => {
               this.staleRefreshProcess();
            }, 200);
         }
      });
   }

   /**
    * @method staleRefreshProcess
    * Actually process the current pending requests.
    */
   staleRefreshProcess() {
      this.staleRefreshInProcess = true;
      var currentEntries = this.staleRefreshPending;
      this.staleRefreshPending = [];
      var PK = this.object.PK();

      var responseHash = {
         /* id : [{entry}] */
      };
      var cond = { where: {} };
      cond.where[PK] = [];

      console.log(
         "Model.staleRefreshProcess(): buffered " +
            currentEntries.length +
            " requests"
      );
      currentEntries.forEach((e) => {
         responseHash[e[PK]] = responseHash[e[PK]] || [];
         responseHash[e[PK]].push(e);
      });

      cond.where[PK] = Object.keys(responseHash);

      this.findAll(cond).then((res) => {
         // for each entry we got back
         if (Array.isArray(res.data) && res.data.length) {
            res.data.forEach((data) => {
               // find it's matching request:
               if (responseHash[data[PK]]) {
                  // respond to the pending promise
                  // and remove these entries from responseHash
                  var entries = responseHash[data[PK]];
                  entries.forEach((entry) => {
                     var resolve = entry.resolve;
                     resolve({ data: [data] });
                  });

                  delete responseHash[data[PK]];
               } else {
                  console.error(
                     "Model.staleRefreshProcess(): returned entry was not in our responseHash:",
                     data,
                     responseHash
                  );
               }
            });
         }

         // now if there are any entries left in responseHash,
         // respond with an empty entry:
         var allKeys = Object.keys(responseHash);
         if (allKeys.length > 0) {
            console.warn(
               "Model.staleRefreshProcess(): " +
                  allKeys.length +
                  " entries with no responses. "
            );
         }
         allKeys.forEach((key) => {
            let entry = responseHash[key];
            let resolve;
            if (Array.isArray(entry)) {
               resolve = entry[0].resolve;
            } else {
               resolve = entry.resolve;
            }
            resolve({ data: [] });
            delete responseHash[key];
         });

         // now check to see if there are any more pending requests:
         if (this.staleRefreshPending.length > 0) {
            // process them:
            this.staleRefreshProcess();
         } else {
            // mark we are no longer processing stale requests.
            this.staleRefreshInProcess = false;
         }
      });
   }

   /**
     * @method findConnected
     * return the connected data associated with an instance of this model.
     *
     * to limit the result to only a single connected column:
     *    model.findConnected( 'col1', {data})
     *    then ((data) => {
     *      // data = [{obj1}, {obj2}, ... {objN}]
     *    })
     *
     * To find >1 connected field data:
     *    model.findConnected( ['col1', 'col2'], {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     col1 : [{obj1}, {obj2}, ... {objN}],
     *      //     col2 : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })
     *
     * To find all connected field data:
     *    model.findConnected( {data} )
     *    .then((data) =>{
     *    
     *      // data = {
     *      //     connectedColName1 : [{obj1}, {obj2}, ... {objN}],
     *      //     connectedColName2 : [{obj1}, {obj2}, ... {objN}],
     *      //    ...
     *      //     connectedColNameN : [{obj1}, {obj2}, ... {objN}]
     *      // }
     *    })

     * @param {string/array} fields  [optional] an array of connected fields you want to return.
     * @param {obj} data  the current object instance (data) to lookup
     * @return {Promise}
     */
   findConnected(fields, data) {
      if (typeof data == "undefined") {
         if (!Array.isArray(fields) && typeof fields == "object") {
            data = fields;
            fields = []; // return all fields
         }
      }

      if (typeof fields == "string") {
         fields = [fields]; // convert to an array of values
      }

      return new Promise((resolve, reject) => {
         // sanity checking:
         if (!data.id) {
            // I can't find any connected items, if I can't find this one:
            resolve(null);
            return;
         }

         let cond = {};
         cond[this.object.PK()] = data.id;
         this.findAll({ where: cond, populate: true })
            .then((results) => {
               if (
                  !results.data ||
                  !Array.isArray(results.data) ||
                  results.data.length == 0
               ) {
                  resolve([]); // no data to return.
                  return;
               }

               // work with the first object.
               var myObj = results.data[0];

               // if only 1 field requested, then return that
               if (fields.length == 1) {
                  let data =
                     myObj[
                        fields[0].replace(/[^a-z0-9.]/gi, "") + "__relation"
                     ];
                  if (!data) return resolve([]);

                  if (!Array.isArray(data)) data = [data];

                  resolve(data);
                  return;
               }

               // if no fields requested, return them all:
               if (fields.length == 0) {
                  var allFields = this.object.fields((f) => {
                     return f.settings.linkType;
                  });
                  allFields.forEach((f) => {
                     fields.push(f.columnName);
                  });
               }

               var returnData = {};
               fields.forEach((colName) => {
                  returnData[colName] =
                     myObj[colName.replace(/[^a-z0-9.]/gi, "") + "__relation"];
               });

               resolve(returnData);
            })
            .catch((err) => {
               console.error("!!! error with findConnected() attempt:", err);
               reject(err);
            });
      });
   }

   // /**
   //  * @method loadInto
   //  * loads the current values into the provided Webix DataTable
   //  * @param {DataTable} DT  A Webix component that can dynamically load data.
   //  */
   // loadInto(DT) {

   //   // if a limit was applied, then this component should be loading dynamically
   //   if (this._limit) {

   //     DT.define('datafetch', this._limit);
   //     DT.define('datathrottle', 250);  // 250ms???

   //     // catch the event where data is requested:
   //     // here we will do our own findAll() so we can persist
   //     // the provided .where condition.

   //     // oh yeah, and make sure to remove any existing event handler when we
   //     // perform a new .loadInto()
   //     DT.___AD = DT.___AD || {};
   //     if (DT.___AD.onDataRequestEvent) {
   //       DT.detachEvent(DT.___AD.onDataRequestEvent);
   //     }
   //     DT.___AD.onDataRequestEvent = DT.attachEvent("onDataRequest", (start, count) => {

   //       var cond = {
   //         where: this._where,
   //         sort: this._sort,
   //         limit: count,
   //         skip: start
   //       }

   //       if (DT.showProgress)
   //         DT.showProgress({ type: "icon" });

   //       this.findAll(cond)
   //         .then((data) => {
   //           data.data.forEach((item) => {
   //             if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //               item.$height = parseInt(item.properties.height);
   //             } else if (parseInt(this._where.height) > 0) {
   //               item.$height = parseInt(this._where.height)
   //             }
   //           });
   //           DT.parse(data);

   //           if (DT.hideProgress)
   //             DT.hideProgress();

   //         })

   //       return false; // <-- prevent the default "onDataRequest"
   //     });

   //     DT.refresh();
   //   }

   //   // else just load it all at once:
   //   var cond = {};
   //   if (this._where) cond.where = this._where;
   //   if (this._sort) cond.sort = this._sort;
   //   if (this._limit != null) cond.limit = this._limit;
   //   if (this._skip != null) cond.skip = this._skip;

   //   if (DT.showProgress)
   //     DT.showProgress({ type: "icon" });

   //   this.findAll(cond)
   //     .then((data) => {
   //       data.data.forEach((item) => {
   //         if (item.properties != null && item.properties.height != "undefined" && parseInt(item.properties.height) > 0) {
   //           item.$height = parseInt(item.properties.height);
   //         } else if (parseInt(this._where.height) > 0) {
   //           item.$height = parseInt(this._where.height)
   //         }
   //       });
   //       DT.parse(data);

   //       if (DT.hideProgress)
   //         DT.hideProgress();

   //     })
   //     .catch((err) => {
   //       console.error('!!!!!', err);
   //     })

   // }

   // /**
   //  * @method limit
   //  * set the limit value for this set of data
   //  * @param {integer} limit  the number or elements to return in this call
   //  * @return {ABModel} this object that is chainable.
   //  */
   // limit(limit) {
   //   this._limit = limit;
   //   return this;
   // }

   // /**
   //  * @method skip
   //  * set the skip value for this set of data
   //  * @param {integer} skip  the number or elements to skip
   //  * @return {ABModel} this object that is chainable.
   //  */
   // skip(skip) {
   //   this._skip = skip;
   //   return this;
   // }

   //   /**
   //    * @method update
   //    * update model values on the server.
   //    */
   //   update(id, values) {

   //     this.prepareMultilingualData(values);

   //     // remove empty properties
   //     for (var key in values) {
   //       if (values[key] == null)
   //         delete values[key];
   //     }

   //     var params = {
   //       url: this.object.urlRestItem(id),
   //       params: values
   //     }
   //     return this.request('put', params)
   //       .then((data) => {

   //         // .data is an empty object ??

   //         this.normalizeData(data);

   //         return data;

   //         // FIX: now with sockets, the triggers are fired from socket updates.
   //         // trigger a update event
   //         // triggerEvent('update', this.object, data);

   //       })
   //       .catch((err)=>{
   // console.error(err);
   //       });

   //   }

   /**
    * @method upsert
    * upsert model values on the server.
    */
   upsert(values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      var params = {
         url: this.object.urlRest(),
         params: values,
      };
      return this.request("put", params)
         .then((data) => {
            // .data is an empty object ??

            this.normalizeData(data);

            return data;

            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a update event
            // triggerEvent('update', this.object, data);
         })
         .catch((err) => {
            console.error(err);
         });
   }

   /**
    * @method where
    * set the where condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   where(cond) {
      this._where = cond;
      return this;
   }

   /**
    * @method where
    * set the sort condition for the data being loaded.
    * @param {json} cond  the json condition statement.
    * @return {ABModel} this object that is chainable.
    */
   sort(cond) {
      this._sort = cond;
      return this;
   }

   /**
    * @method refresh
    * refresh model definition on the server.
    */
   refresh() {
      console.error("!!! Depreciated: where is this being called from?");
      return Promise.resolve();

      // var params = {
      //    url: this.object.urlRestRefresh(),
      // };
      // return this.request("put", params);
   }

   normalizeData(data) {
      // convert to array
      if (!(data instanceof Array)) data = [data];

      // find all connected fields
      var connectedFields = this.object.connectFields();

      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();

      // if this object has some date fields, convert the data to date object:
      var dateFields =
         this.object.fields(function (f) {
            return f.key == "date" || f.key == "datetime";
         }) || [];

      // calculate fields
      var calculatedFields = this.object.fields((f) => f.key == "calculate");

      data.forEach((d) => {
         if (d == null) return;

         // various PK name
         if (!d.id && this.object.PK() != "id") d.id = d[this.object.PK()];

         // loop through data's connected fields
         connectedFields.forEach((c) => {
            // get the relation name so we can change the original object
            var relationName = c.relationName();

            // if (d[c.columnName] == null)
            //  d[c.columnName] = '';

            // if there is no data we can exit now
            if (d[relationName] == null) return;

            // if relation data is still a string and isn't empty
            if (
               typeof d[relationName] == "string" &&
               d[relationName].length > 0
            ) {
               // parse the string into an object
               d[relationName] = JSON.parse(d[relationName]);
            }

            // if the data is an array we need to loop through it
            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((r) => {
                  // if translations are present and they are still a string
                  if (r.translations && typeof r.translations == "string") {
                     // parse the string into an object
                     r.translations = JSON.parse(r.translations);
                  }
               });
               // if the data is not an array it is a single item...check that has translations and it is a string
            } else if (
               d[relationName].translations &&
               typeof d[relationName].translations == "string"
            ) {
               // if so parse the string into an object
               d[relationName].translations = JSON.parse(
                  d[relationName].translations
               );
            }

            // set .id to relation columns
            let objectLink = c.datasourceLink;

            // if we didn't get the linked object, just return.
            if (!objectLink) return;

            let olPK = objectLink.PK();
            var relatedMlFields = objectLink.multilingualFields();

            if (Array.isArray(d[relationName])) {
               d[relationName].forEach((subData) => {
                  // update .id values
                  // if (olPK != "id" && subData[olPK]) subData.id = subData[olPK];
                  const relationValue = c.getRelationValue(subData);
                  if (olPK != "id") subData.id = relationValue;

                  // perform Translation
                  if (relatedMlFields.length) {
                     objectLink.translate(subData, subData, relatedMlFields);
                  }
               });
            } else {
               // update .id value
               // if (d[relationName][olPK]) {
               //    d[relationName].id = d[relationName][olPK];
               // }
               const relationValue = c.getRelationValue(d[relationName]);
               if (relationValue) {
                  d[relationName].id = relationValue;
               }

               // perform Translation
               if (relatedMlFields.length) {
                  objectLink.translate(
                     d[relationName],
                     d[relationName],
                     relatedMlFields
                  );
               }
            }

            // if (
            //    objectLink &&
            //    olPK != "id" &&
            //    d[relationName] &&
            //    !d[relationName].id
            // ) {
            //    // is array
            //    if (d[relationName].forEach) {
            //       d[relationName].forEach((subData) => {
            //          if (subData[olPK]) subData.id = subData[olPK];
            //       });
            //    } else if (d[relationName][olPK]) {
            //       d[relationName].id = d[relationName][olPK];
            //    }
            // }

            // if (relatedMlFields.length) {
            //    d[relationName];
            //    objectLink.translate(
            //       d[relationName],
            //       d[relationName],
            //       relatedMlFields
            //    );
            // }

            // Change property name of connected field
            if (!d[c.columnName]) {
               if (c.linkType() == "one") {
                  if (d[relationName]) {
                     // d[c.columnName] = d[relationName][olPK];
                     d[c.columnName] = c.getRelationValue(d[relationName]);
                  } else {
                     d[c.columnName] = null;
                  }
               } else {
                  if (d[relationName]) {
                     if (Array.isArray(d[relationName])) {
                        try {
                           d[c.columnName] = (d[relationName] || []).map(
                              // (i) => i[olPK]
                              (i) => c.getRelationValue(i)
                           );
                        } catch (e) {
                           console.log("+++++++++++++++");
                           console.log(`ID:[${c.id}]`);
                           console.log(`ColumnName:[${c.label}]`);
                           console.log(`relationName:[${relationName}]`);
                           console.log(`linkType:[${c.linkType()}]`);
                           console.log("data:");
                           console.log(JSON.stringify(d[relationName]));
                           console.log("+++++++++++++++");
                        }
                     } else {
                        // this is strange: supposed to be "many" but coming in
                        // as "one"
                        console.log("+++++++++++++++");
                        console.log(`ID:[${c.id}]`);
                        console.log(`ColumnName:[${c.label}]`);
                        console.log(`relationName:[${relationName}]`);
                        console.log(`linkType:[${c.linkType()}]`);
                        console.log("data:");
                        console.log(JSON.stringify(d[relationName]));
                        console.log("+++++++++++++++");
                        // d[c.columnName] = [d[relationName][olPK]];
                        d[c.columnName] = [c.getRelationValue(d[relationName])];
                     }
                  } else {
                     d[c.columnName] = [];
                  }
               }
            }
         });

         if (mlFields.length) {
            this.object.translate(d, d, mlFields);
         }

         // convert the data to date object
         dateFields.forEach((date) => {
            if (d && d[date.columnName] != null) {
               // check to see if data has already been converted to a date object
               if (typeof d[date.columnName] == "string") {
                  if (date.key == "date") {
                     // if we are ignoring the time it means we ignore timezone as well
                     // so lets trim that off when creating the date so it can be a simple date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName],
                        {
                           format: "MM/DD/YYYY",
                           ignoreTime: true,
                        }
                     );
                  } else {
                     // Convert UTC to Date
                     d[date.columnName] = this.AB.rules.toDate(
                        d[date.columnName]
                     );
                     // d[date.columnName] = new Date(moment(d[date.columnName]));
                  }
               }
            }
         });

         calculatedFields.forEach((calField) => {
            d[calField.columnName] = calField.format(d);
         });
      });
   }
};


/***/ }),

/***/ 84227:
/*!********************************************!*\
  !*** ./AppBuilder/core/ABObjectApiCore.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObject = __webpack_require__(/*! ../platform/ABObject */ 24869);
const ABModelApi = __webpack_require__(/*! ../platform/ABModelApi */ 34697);

module.exports = class ABObjectApiCore extends ABObject {
   constructor(attributes, AB) {
      super(attributes, AB);

      this.isAPI = true;

      this.fromValues(attributes);
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.readonly = parseInt(attributes.readonly) || 0;
      this.apiType = attributes.apiType || "Read";
      this.request = attributes.request ?? {};
      this.request.headers = attributes.request?.headers ?? [];
      this.response = attributes.response ?? {};
      this.response.fields = attributes.response?.fields ?? [];
      this.isFetched = attributes.isFetched ?? false;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const result = super.toObj();

      result.isAPI = this.isAPI;
      result.readonly = this.readonly;
      result.apiType = this.apiType;
      result.request = this.request ?? {};
      result.request.headers = this.request?.headers ?? [];
      result.response = this.response ?? {};
      result.response.fields = this.response?.fields ?? [];
      result.isFetched = this.isFetched;

      return result;
   }

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new ABModelApi(this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @function getPagingValues()
    *
    * @return {Object} - {
    *                       start: "Property name of the API for start index",
    *                       limit: "Property name of the API for limit return the item number"
    *                     }
    */
   getPagingValues({ skip, limit }) {
      const result = {};
      const pagingSettings = this.request?.paging ?? {};

      if (pagingSettings.start && skip != null) {
         result[pagingSettings.start] = skip;
      }
      if (pagingSettings.limit && limit != null) {
         result[pagingSettings.limit] = limit;
      }

      return result;
   }

   dataFromKey(data) {
      let result = [];

      if (!Array.isArray(data)) data = [data];

      data.forEach((item) => {
         // Clone item
         let itemResult = { ...item };

         // Pull data from `Data key` of the API object
         // FORMAT: "Property.Name.Value"
         (this.response.dataKey ?? "").split(".").forEach((key) => {
            if (key == "" || key == null) return;
            itemResult = itemResult?.[key];
         });

         if (Array.isArray(itemResult)) {
            result = result.concat(itemResult);
         } else if (itemResult) {
            result.push(itemResult);
         }
      });

      return result;
   }

   get headers() {
      const headers = {};

      (this.request.headers ?? []).forEach((header) => {
         if (header?.value == null) return;

         headers[header.key] = header.value;
      });

      return headers;
   }
};


/***/ }),

/***/ 83899:
/*!*****************************************!*\
  !*** ./AppBuilder/core/ABObjectCore.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABObjectCore
 *
 * Manage the loading of specific ABObject data into useable objects
 * that can instantiate themselves and provide field and model resources.
 */

var ABModel = __webpack_require__(/*! ../platform/ABModel */ 58174);
var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABObjectCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      /*
{
	id: uuid(),
	connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
	name: 'name',
	labelFormat: 'xxxxx',
	labelSettings: Object,
	isImported: 1/0,
	isExternal: 1/0,
	tableName:'string',  // NOTE: store table name of import object to ignore async
	primaryColumnName: 'string', // NOTE: store column name of PK
	transColumnName: 'string', // NOTE: store column name of translations table
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:	 ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],
	fields:[
		{ABDataField}
   ],
   indexes: [
      {ABIndex}
   ]
}
*/

      this.fromValues(attributes);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object. These methods are not dependent
   /// on the instance values of the Application.
   ///

   static contextKey() {
      return "object";
   }

   ///
   /// Instance Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            connName: 'string', // Sails DB connection name: 'appdev_default', 'legacy_hris', etc. Default is 'appBuilder'.
            name: 'name',
            labelFormat: 'xxxxx',
            labelSettings: Object,
            isImported: 1/0,
            isExternal: 1/0,
            tableName:'string',  // NOTE: store table name of import object to ignore async
            primaryColumnName: 'string', // NOTE: store column name of PK
            transColumnName: 'string', // NOTE: store column name of translations table
            urlPath:'string',
            importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
                                        // to get other object:  ABApplication.objectFromRef(obj.importFromObject);
            translations:[
                {}
            ],
            fields:[
                {ABDataField}
            ],
            indexes: [
               {ABIndex}
            ]
        }
        */

      this.id = attributes.id;
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = attributes.type || "object";
      // {string} .type
      // the type of ABDefinition this is.

      this.connName = attributes.connName || undefined; // undefined == 'appBuilder'
      // {string} .connName
      // the sails.config.connections[connName] configuration reference.
      // if not set ({undefined}), then our default "appBuilder" config is used

      this.name = attributes.name || "";
      // {string} .name
      // A name reference for this ABObject. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      this.labelFormat = attributes.labelFormat || "";
      // {string} .labelFormat
      // A string template for how to display an entry for this ABObject in
      // common UI elements like grids, lists, etc...

      this.labelSettings = attributes.labelSettings || {};
      // {Object} .labelSettings

      this.labelSettings.isNoLabelDisplay = parseInt(
         this.labelSettings.isNoLabelDisplay || 0
      );
      // {bool} .isNoLabelDisplay

      this.isImported = parseInt(attributes.isImported || 0);
      // {depreciated}
      // {bool} .isImported
      // previously used to mark ABObjects that were created in other
      // ABApplicaitons.  No longer relevant with Global ABObjects

      this.isExternal = parseInt(attributes.isExternal || 0);
      // {bool} .isExternal
      // Marks this ABObject as referencing a pre-existing table in the DB that
      // we are treating as an ABObject.
      // These objects are not allowed to create/update/destroy the db table
      // nor can we add/remove fields.
      // However we are able to customize the Field definitions to change the
      // column names, hidden attributes, Object label, etc...
      // We can update our Defintion attributes, but not any actual DB changes.

      this.tableName = attributes.tableName || ""; // NOTE: store table name of import object to ignore async
      // {string} .tableName
      // the `{database}.{tableName}` of the db table that this ABObject's data
      // is stored in.
      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.tableName = this.tableName.replace(/[^a-zA-Z0-9_ ]/gi, "");

      this.primaryColumnName = attributes.primaryColumnName || ""; // NOTE: store column name of PK
      // {string} .primaryColumnName
      // is the col_name of which key is the primary key.  By default it is
      // "uuid", but in some external objects this might be something else
      // ("id", "ren_id", etc...).

      this.transColumnName = attributes.transColumnName || ""; // NOTE: store column name of translations table
      // {string} .transColumnName
      // this is a workaround to include hris_ren_data and hris_ren_trans data

      this.urlPath = attributes.urlPath || "";

      // this.importFromObject = attributes.importFromObject || "";

      this.isSystemObject = attributes.isSystemObject;
      // {bool} .isSystemObject
      // We are now storing some of our System Required Data as ABObjects as well.
      // These Objects should not be allowed to be modified by typical AppBuilder
      // designer.  However we can enable a mode for AB Designer to then expand these
      // ABObjects, and eventually we can use the AppBuilder to Create the AppBuilder.
      if (
         typeof this.isSystemObject == "undefined" ||
         this.isSystemObject == "false"
      ) {
         this.isSystemObject = false;
      }

      this.createdInAppID = attributes.createdInAppID;
      // {string} .createdInAppID
      // the .id of the ABApplication that originally created this ABObject.

      // if attributes.objectWorkspace DOES exist, make sure it is fully
      // populated.
      if (typeof attributes.objectWorkspace != "undefined") {
         if (typeof attributes.objectWorkspace.sortFields == "undefined")
            attributes.objectWorkspace.sortFields = [];
         if (typeof attributes.objectWorkspace.filterConditions == "undefined")
            attributes.objectWorkspace.filterConditions = [];
         if (typeof attributes.objectWorkspace.frozenColumnID == "undefined")
            attributes.objectWorkspace.frozenColumnID = "";
         if (typeof attributes.objectWorkspace.hiddenFields == "undefined")
            attributes.objectWorkspace.hiddenFields = [];
      }
      this.objectWorkspace = attributes.objectWorkspace || {
         sortFields: [], // array of columns with their sort configurations
         filterConditions: [], // array of filters to apply to the data table
         frozenColumnID: "", // id of column you want to stop freezing
         hiddenFields: [], // array of [ids] to add hidden:true to
      };
      // {obj} .objectWorkspace
      // When in the ABObject editor in the AppBuilder Designer, different
      // views of the information can be created.  These views are stored here
      // and are avaiable to other users in the Designer.

      // pull in field definitions:
      var fields = [];
      this.fieldIDs = attributes.fieldIDs || [];
      // {array}  [ ABField.id, ... ]
      // this is a collection of ALL the ABFields this object references.
      // This will include ABFields that were directly created for this object
      // and will include ABFields that were imported.

      this.importedFieldIDs = attributes.importedFieldIDs || [];
      // {array} [ ABField.id, ... ]
      // this is a collection of the ABFields in our .fieldIDs that were
      // IMPORTED.

      this._unknownFieldIDs = [];
      this.fieldIDs.forEach((id) => {
         if (!id) return;

         var def = this.AB.definitionByID(id);
         if (def) {
            fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._fields = fields;

      // pull in index definitions:
      this.importIndexes(attributes.indexIDs);

      // let the MLClass now process the translations:
      super.fromValues(attributes);
   }

   /**
    * @method importIndexes
    * instantiate a set of indexes from the given ids.
    * @param {array} indexIDs The different ABDefinition IDs for each index
    *        [ "uuid11", "uuid2", ... "uuidN" ]
    */
   importIndexes(indexIDs) {
      this._unknownIndex = [];
      var indexes = [];
      (indexIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            indexes.push(this.AB.indexNew(def, this));
         } else {
            this._unknownIndex.push(id);
            let err = new Error(
               `O[${this.name}] is referenceing an unknown index id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      });
      this._indexes = indexes;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   // exportFields() {
   //     var currFields = [];
   //     this._fields.forEach((obj) => {
   //         currFields.push(obj.toObj());
   //     });
   //     return currFields;
   // }

   // /**
   //  * @method exportFields
   //  * convert our array of fields into a settings object for saving to disk.
   //  * @return {array}
   //  */
   // exportIndexes() {
   //    var currIndexes = [];
   //    this._indexes.forEach((idx) => {
   //       currIndexes.push(idx.toObj());
   //    });
   //    return currIndexes;
   // }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      // track the field .ids of our fields
      var fieldIDs = this.fields().map((f) => f.id);
      (this._unknownFieldIDs || []).forEach((id) => {
         fieldIDs.push(id);
      });
      // NOTE: we keep the ._unknownFieldIDs so a developer/builder
      // can come back and track down what happened to the missing
      // ids.

      // track the index .ids of our indexes
      var indexIDs = this.indexes().map((f) => f.id);
      (this._unknownIndex || []).forEach((id) => {
         indexIDs.push(id);
      });

      return {
         id: this.id,
         type: this.type || "object",
         connName: this.connName,
         name: this.name,
         labelFormat: this.labelFormat,
         labelSettings: this.labelSettings || {},
         isImported: this.isImported,
         isExternal: this.isExternal,
         tableName: this.tableName,
         // NOTE: store table name of import object to ignore async
         primaryColumnName: this.primaryColumnName,
         // NOTE: store column name of PK
         transColumnName: this.transColumnName,
         // NOTE: store column name of translations table
         urlPath: this.urlPath,
         // importFromObject: this.importFromObject,
         objectWorkspace: this.objectWorkspace,
         isSystemObject: this.isSystemObject,

         translations: obj.translations,
         fieldIDs: fieldIDs,
         importedFieldIDs: this.importedFieldIDs,
         indexIDs: indexIDs,
         createdInAppID: this.createdInAppID,
      };
   }

   ///
   /// Objects
   ///

   /**
    * @method objectLinks()
    *
    *  return an array of ABObject that's connected.
    *
    * @param {object} filter
    * @return {array} - An array of ABObject
    */
   objectLinks(/* filter */) {
      var connectFields = this.connectFields();

      return connectFields.map((f) => f.datasourceLink);
   }

   ///
   /// Fields
   ///

   /**
    * @method fields()
    * return an array of all the ABFields for this ABObject.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array[ABFieldxxx]}
    */
   fields(fn = () => true) {
      return this._fields.filter(fn);
   }

   /**
    * @method fieldByID()
    * return the object's field from the given {ABField.id}
    * @param {string} id
    *        the uuid of the field to return.
    * @return {ABFieldxxx}
    */
   fieldByID(id) {
      return this.fields((f) => f?.id == id)[0];
   }

   /**
    * @method connectFields()
    *
    * return an array of the ABFieldConnect that is connect object fields.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   connectFields(fn = () => true) {
      return this.fields((f) => f && f.isConnection).filter(fn);
   }

   /**
    * @method fieldImport
    * register the given ABField.id as an imported field for this ABObject.
    * The ABField definition should be available before making this call.
    * After this call, the ABField is included in the ABObject, but the ABObject
    * has NOT been saved.
    * @param {ABField} fieldID The ABDefinition.id for a field that is imported
    *        into this object.
    */
   fieldImport(id) {
      if (!id) return;

      if (this.importedFieldIDs.indexOf(id) == -1) {
         this.importedFieldIDs.push(id);
      }

      // just to be safe:
      var isThere = this._fields.find((f) => f.id == id);
      if (!isThere) {
         var def = this.AB.definitionByID(id);
         if (def) {
            this._fields.push(this.AB.fieldNew(def, this));
         } else {
            this._unknownFieldIDs = this._unknownFieldIDs || [];
            this._unknownFieldIDs.push(id);
            let err = new Error(
               `O[${this.name}] is importing an unknown field id[${id}]`
            );
            this.AB.notify.builder(err, {
               field: { id, object: { id: this.id, name: this.name } },
            });
         }
      }
   }

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @return {ABField}
    */
   fieldNew(values) {
      return this.AB.fieldNew(values, this);
   }

   /**
    * @method fieldRemove()
    *
    * remove the given ABField from our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldRemove(field) {
      var origLen = this._fields.length;
      this._fields = this.fields(function (o) {
         return o.id != field.id;
      });

      // be sure to remove this from our imported ids if it was
      // listed there.
      this.importedFieldIDs = this.importedFieldIDs.filter(
         (fid) => fid != field.id
      );

      if (this._fields.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method fieldReorder()
    *
    * reorder the fields in our object
    *
    * @param {ABField} field The instance of the field to remove.
    * @return {Promise}
    */
   fieldReorder(sourceId, targetId) {
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == sourceId) {
            itemMoved = this._fields[i];
            this._fields.splice(i, 1);
            oPos = i;
            break;
         }
      }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (var j = 0; j < this._fields.length; j++) {
         if (this._fields[j].columnName == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) {
               j++;
            }
            this._fields.splice(j, 0, itemMoved);
            break;
         }
      }

      return this.save();
   }

   /**
    * @method fieldSave()
    *
    * save the given ABField in our ._fields array and persist the current
    * values.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldSave(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         this._fields.push(field);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method fieldAdd()
    *
    * save the given ABField in our ._fields array and persist the current
    * values if they changed.
    *
    * @param {ABField} field The instance of the field to save.
    * @return {Promise}
    */
   fieldAdd(field) {
      var isIncluded = this.fieldByID(field.id);
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._fields.push(field);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method imageFields()
    *
    * return an array of the ABFieldImage fields this object has.
    * @param {fn} fn
    *        a filter function that returns {true} if a value should
    *        be included, or {false} otherwise.
    * @return {array}
    */
   imageFields(fn = () => true) {
      return this.fields((f) => f && f.key == "image").filter(fn);
   }

   /**
    * @method multilingualFields()
    *
    * return an array of columnnames that are multilingual.
    *
    * @return {array}
    */
   multilingualFields() {
      return this.fields((f) => f && f.isMultilingual).map((f) => f.columnName);
   }

   /**
    * @method indexes()
    *
    * return an array of all the ABIndex for this ABObject.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   indexes(filter = () => true) {
      return this._indexes.filter(filter);
   }

   /**
    * @method indexByID()
    * return the object's index from the given {ABIndex.id}
    * @param {string} id
    *        the id of the ABIndex to return.
    * @return {ABIndex}
    */
   indexByID(id) {
      return this.indexes((f) => f.id == id)[0];
   }

   /**
    * @method indexRemove()
    * remove the given ABIndex from our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexRemove(index) {
      var origLen = this._indexes.length;
      this._indexes = this.indexes(function (idx) {
         return idx.id != index.id;
      });

      // persist our changes if something changed.
      if (origLen != this._indexes.length) {
         return this.save();
      }

      // nothing was removed, so continue on.
      return Promise.resolve();
   }

   /**
    * @method indexSave()
    * save the given ABIndex in our ._indexes array and persist the current
    * values.
    * @param {ABIndex} index
    * @return {Promise}
    */
   indexSave(index) {
      var isIncluded = this.indexByID(index.id);
      if (!isIncluded) {
         this._indexes.push(index);
         return this.save();
      }

      return Promise.resolve();
   }

   ///
   /// Working with data from server
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObject.
    */
   model() {
      var model = new ABModel(this);

      // default the context of this model's operations to this object
      model.contextKey(ABObjectCore.contextKey());
      model.contextValues({ id: this.id });

      return model;
   }

   ///
   /// URL
   ///

   /**
    * @method urlRest
    * return the url to access the data for this object.
    * @return {string}
    */
   urlRest() {
      return `/app_builder/model/${this.id}`;
   }

   /**
    * @method urlRestBatch
    * return the url to use for batch creates for this object
    * @return {string}
    */
   urlRestBatch() {
      return `/app_builder/batch/model/${this.id}`;
   }

   /**
    * @method urlRestItem
    * return the url to access the data for an instance of this object.
    * @return {string}
    */
   urlRestItem(id) {
      return `/app_builder/model/${this.id}/${id}`;
   }

   /**
    * @method urlRestLog
    * return the url to access the logs for this ABObject.
    * @return {string}
    */
   urlRestLog() {
      return `/app_builder/object/${this.id}/track`;
   }

   /**
    * @method urlRestRefresh
    * return the url to signal a refresh for this object.
    * @return {string}
    */
   urlRestRefresh() {
      return `/app_builder/model/refreshobject/${this.id}`;
   }

   /**
    * @method urlCount
    * return the url to count of data for this object.
    * @return {string}
    */
   urlRestCount() {
      return `/app_builder/model/${this.id}/count`;
   }

   ///
   ///	Object Workspace Settings
   ///
   get workspaceSortFields() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.sortFields;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.sortFields;
      }
   }

   set workspaceSortFields(fields) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.sortFields = fields;
      }
      // old version
      else {
         this.objectWorkspace.sortFields = fields;
      }
   }

   get workspaceFilterConditions() {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) return currView.filterConditions;
         else return null;
      }
      // old version
      else {
         return this.objectWorkspace.filterConditions;
      }
   }

   set workspaceFilterConditions(filterConditions) {
      // new version
      if (this.workspaceViews) {
         let currView = this.workspaceViews.getCurrentView();
         if (currView) currView.filterConditions = filterConditions;
      }
      // old version
      else {
         this.objectWorkspace.filterConditions = filterConditions;
      }
   }

   get workspaceFrozenColumnID() {
      return this.objectWorkspace.frozenColumnID;
   }

   set workspaceFrozenColumnID(id) {
      this.objectWorkspace.frozenColumnID = id;
   }

   get workspaceHiddenFields() {
      return this.objectWorkspace.hiddenFields || [];
   }

   set workspaceHiddenFields(fields) {
      this.objectWorkspace.hiddenFields = fields;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return this.isImported || this.isExternal || this.readonly;
   }

   /**
    * @method defaultValues
    * Collect a hash of key=>value pairs that represent the default values
    * from each of our fields.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   defaultValues() {
      var values = {};
      this.fields().forEach((f) => {
         f.defaultValue(values);
      });

      return values;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(/* data */) {
      // NOTE: the platform needs to define a way to verify the data
      console.warn("Platform.ABObject.isValidData() missing");
      return true;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error("Who is calling this?");

      if (this.application == null) return null;

      return this.application.urlObject(acrossApp) + this.id;
   }

   /**
    * @method urlField
    * return a string pointer to this object's fields
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlField(acrossApp) {
      console.error("Who is calling this?");

      return this.urlPointer(acrossApp) + "/_fields/";
   }

   /**
    * @method PK
    * return a string of the primary column name
    *
    * @return {string}
    */
   PK() {
      return this.primaryColumnName || "uuid";
   }

   remoteCreate(data) {
      console.log(
         "object[" + this.name + "] received a remoteCreate() with data:",
         data
      );
   }

   /**
    * @method clone
    * return a clone of ABObject
    *
    * @return {ABObjectBase}
    */
   clone() {
      // ignore properties who're spend much performance
      // NOTE: do not clone them. Just copy reference
      let ignoreProps = ["application", "_fields"];

      let cloneOne = JSON.parse(JSON.stringify(this));

      ignoreProps.forEach((prop) => {
         cloneOne[prop] = this[prop];
      });

      return cloneOne;
   }

   /**
    * @method minRelationData()
    * return an array of ABField.columnNames that make up
    * the minimum fields required to display this objects __RELATION
    * data in our UI widgets.
    */
   minRelationData() {
      var fields = [this.PK()];

      if (this.multilingualFields().length > 0) {
         fields.push("translations");
      }

      var labelData = this.labelFormat || "";

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            fields.push(field.columnName);
         });
      }

      // System requires to include number field values
      // because they are used on Formula/Calculate fields on client side
      fields = fields.concat(
         this.fields((f) => f.key == "number").map((f) => f.columnName)
      );

      return fields;
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = "{" + defaultField.id + "}";
         else {
            // if label is empty, then show .id
            if (!labelData.trim()) {
               let labelSettings = this.labelSettings || {};
               if (labelSettings && labelSettings.isNoLabelDisplay) {
                  labelData = L(labelSettings.noLabelText || "[No Label]");
               } else {
                  // show id of row
                  labelData = `${
                     this.AB.rules.isUUID(rowData.id) ? "ID: " : ""
                  }${rowData.id}`;
               }
            }
         }
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.rules.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   /**
    * @method whereCleanUp()
    * Parse through the current where condition and remove any null or
    * empty logical blocks.
    * @param {obj} curr
    *        1) The current where condition in ABQuery Format:
    *        {
    *           glue: [AND, OR],
    *           rules: [ {rule} ]
    *        }
    *        or 2) The current {rule} to validate
    *        {
    *          key:{string},
    *          rule:{string},
    *          vlaue:{mixed}
    *        }
    * @return {ABQuery.where} / { Rule }
    */
   whereCleanUp(curr) {
      if (curr) {
         if (curr.glue && curr.rules) {
            // this is a logical Block (AND, OR)
            // we need to filter the children
            let newValue = { glue: curr.glue, rules: [] };
            curr.rules.forEach((r) => {
               let cleanRule = this.whereCleanUp(r);
               // don't add values that didn't pass
               if (cleanRule) {
                  newValue.rules.push(cleanRule);
               }
            });

            // if we have a non empty block, then return it:
            if (newValue.rules.length > 0) {
               return newValue;
            }

            // this isn't really a valid conditional, so null
            return null;
         }

         // This is a specific rule, that isn't null so:
         // if it isn't {}, then return it
         if (Object.keys(curr).length > 0) return curr;

         // otherwise we skip this as well
         return null;
      }
      return null;
   }
};


/***/ }),

/***/ 2732:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABObjectQueryCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//

var ABObject = __webpack_require__(/*! ../platform/ABObject */ 24869);
var ABModelQuery = __webpack_require__(/*! ../platform/ABModelQuery */ 63549);

module.exports = class ABObjectQueryCore extends ABObject {
   constructor(attributes, AB) {
      super(attributes, AB);
      /*
{
	id: uuid(),
	name: 'name',
	labelFormat: 'xxxxx',
	isImported: 1/0,
	urlPath:'string',
	importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
								// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
	translations:[
		{}
	],



	// ABOBjectQuery Specific Changes
	// we store a list of fields by their urls:
	fields:[
		{
			alias: "",
			fieldURL:'#/url/to/field',
		}
	],


	// we store a list of joins:
	joins:{
		alias: "",							// the alias name of table - use in SQL command
		objectURL:"#/...",					// the base object of the join
		links: [
			{
				alias: "",							// the alias name of table - use in SQL command
				fieldID: "uuid",					// the connection field of the object we are joining with.
				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
				links: [
					...
				]
			}
		]

	},


	where: { QBWhere }
}
*/
      this.isQuery = true;
      // {bool}
      // a property to mark the difference between an ABObject and ABObjectQuery.

      this.__missingObject = this.__missingObject ?? [];
      // {array} fieldInfo
      // the field info that defined an object we can't find.

      this.__missingFields = this.__missingFields ?? [];
      // {array} [ { objID, fieldID }, ... ]
      // a list of field definitions that we are unable to resolve.

      this.__cantFilter = [];
      // {array} [ {field, fieldInfo}, ... ]
      // a list of field that were assigned but can't be used for filtering.

      this.__duplicateFields = [];
      // {array} [ {fieldInfo}, ... ]
      // a list of duplicate field definitions.

      this.__linkProblems = [];
      // {array} [ { message, data }, ...]
      // a list of warning messages related to link objects
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   /**
    * contextKey()
    * returns a unique key that represents a query in
    * our networking job resolutions.
    * @return {string}
    */
   static contextKey() {
      return "query";
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   fromValues(attributes) {
      super.fromValues(attributes);

      this.type = "query";

      // populate connection objects
      // this._objects = {};
      // this.obj2Alias = attributes.obj2Alias || {};

      this.alias2Obj = {}; // this gets built in the .importJoins()
      // { "alias" : object.id }
      // this is a lookup hash of a referenced alias to the Object it
      // references.

      this.objectIDs = [];
      // {array}  of ABObject.id s that are referenced by this query.
      // this is how we limit our searches on objects.
      // this gets built in the .importJoins();

      this.viewName = attributes.viewName || "";
      // {string}
      // this is the SQL tablename of where our Query will store it's
      // view data.

      // import all our ABObjects
      this.importJoins(attributes.joins || {});

      // import fields after joins are imported
      this._fields = null;
      this.importFields(attributes.fields || []);
      // {array} [ { alias, field}, {},... ]
      // an array of field definition structures that mark what fields this
      // query is interested in pulling data from.
      //    .alias : {string} matches the alias of the ABObject that the field
      //             is from
      //    .field : {ABFieldXXX} the link to the actual ABField instance

      // Import our Where condition
      this.where = attributes.where || {}; // .workspaceFilterConditions
      // Fix default where.glue value
      if (
         this.where &&
         !this.where.glue &&
         this.where.rules &&
         this.where.rules.length > 0
      )
         this.where.glue = "and";

      this._objectWorkspaceViews = attributes.objectWorkspaceViews || {};

      this.settings = this.settings || {};

      if (attributes && attributes.settings) {
         // convert from "0" => true/false
         this.settings.grouping = JSON.parse(
            attributes.settings.grouping || false
         );
         this.settings.hidePrefix = JSON.parse(
            attributes.settings.hidePrefix || false
         );
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABObjectQuery instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.viewName = this.viewName;

      result.joins = this.exportJoins();
      result.fields = this.exportFields();
      result.where = this.where; // .workspaceFilterConditions

      result.settings = this.settings;

      return result;
   }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    */
   importFields(fieldSettings) {
      var newFields = [];
      (fieldSettings || []).forEach((fieldInfo) => {
         if (fieldInfo == null) return;

         // pull object by alias name
         let object = this.objectByAlias(fieldInfo.alias);

         // Pull object from .AB
         if (!object && this.AB) {
            object = this.AB.objectByID(fieldInfo.objectID);

            // keep
            if (object) {
               this._objects = this._objects || {};
               this._objects[fieldInfo.alias] = object;
            }
         }

         if (!object) {
            this.__missingObject = this.__missingObject ?? [];
            this.__missingObject.push(fieldInfo);
            return;
         }

         let field = object.fieldByID(fieldInfo.fieldID);
         if (!field) {
            this.__missingFields = this.__missingFields ?? [];
            this.__missingFields.push({
               objID: object.id,
               fieldID: fieldInfo.fieldID,
               fieldInfo,
            });
            return;
         }

         if (!this.canFilterField(field)) {
            this.__cantFilter = this.__cantFilter ?? [];
            this.__cantFilter.push({ field, fieldInfo });
         }

         // check duplicate
         let isNew =
            newFields.filter(
               (f) =>
                  f.alias == fieldInfo.alias && f.field.id == fieldInfo.fieldID
            ).length < 1;

         if (!isNew) {
            this.__duplicateFields = this.__duplicateFields ?? [];
            this.__duplicateFields.push({ fieldInfo });
         }

         // should be a field of base/join objects
         if (field && this.canFilterField(field) && isNew) {
            // add alias to field
            // create new instance of this field:
            var def = field.toObj();
            let clonedField = new field.constructor(def, field.object);

            clonedField.alias = fieldInfo.alias;

            let alias = fieldInfo.alias;
            if (Array.isArray(this.joins())) {
               // NOTE: query v1
               alias = field.object.name;
            }

            newFields.push({
               alias: alias,
               field: clonedField,
            });
         }
      });
      this._fields = newFields;
   }

   /**
    * @method exportFields
    * convert our array of fields into a settings object for saving to disk.
    * @return {array}
    */
   exportFields() {
      var currFields = [];
      this._fields.forEach((fieldInfo) => {
         currFields.push({
            alias: fieldInfo.alias,
            objectID: fieldInfo.field.object.id,
            fieldID: fieldInfo.field.id,
         });
      });

      // let's persist the faulty settings so a developer or builder can
      // review and fix it by hand.
      (this.__missingObject || []).forEach((f) => {
         currFields.push(f);
      });

      (this.__cantFilter || []).forEach((f) => {
         currFields.push(f.fieldInfo);
      });

      return currFields;
   }

   /**
    * @method fields()
    *
    * Support the ABObject api by returning a list of fields relevant
    * to this ABObjectQuery.
    *
    * @return {array}
    */
   fields(fn = () => true) {
      if (!fn) fn = () => true;
      return this._fields.map((f) => f.field).filter(fn);
   }

   ///
   /// Joins & Objects
   ///

   /**
    * @method joins()
    *
    * return an object of joins for this Query.
    *
    * @return {Object}
    */
   joins() {
      return this._joins || {};
   }

   /**
    * @method objects()
    *
    * return an array of all the relevant ABObjects for this Query.
    *
    * @return {array}
    */
   objects(fn = () => true) {
      // FOR proper expected operation, this fn must only return object
      // matches for which this ABQuery is managing objects:

      return this.AB.objects((o) => this.objectIDs.indexOf(o.id) > -1).filter(
         fn
      );
   }

   /**
    * @method objectAlias()
    *
    * return alias of of ABObjects.
    *
    * @return {string}
    */
   objectAlias(objectId) {
      let result = null;

      Object.keys(this.alias2Obj || {}).forEach((alias) => {
         if (!result && this.alias2Obj[alias] == objectId) {
            result = alias;
         }
      });

      return result;
   }

   /**
    * @method objectBase
    * return the origin object
    *
    * @return {ABObject}
    */
   objectBase() {
      if (!this._joins.objectID) return null;

      return this.AB.objectByID(this._joins.objectID) || null;
   }

   /**
    * @method objectByAlias()
    * return ABObject search by alias name
    *
    * @param {string} - alias name
    * @return {ABClassObject}
    */
   objectByAlias(alias) {
      var objID = this.alias2Obj[alias];
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method objectByID()
    * return ABObject search by ID
    * @param {string} objID
    *        The requested {ABObject}.id of the object to return.
    * @return {ABObject} | null
    */
   objectByID(objID) {
      if (objID) {
         return this.objects((o) => o.id == objID)[0];
      }
      return null;
   }

   /**
    * @method links()
    *
    * return an array of links for this Query.
    *
    * @return {array}
    */
   links(filter = () => true) {
      return (this._links || []).filter(filter);
   }

   /**
    * @method importJoins
    * instantiate a set of joins from the given attributes.
    * Our joins contain a set of ABObject URLs that should already be created in our Application.
    * @param {Object} settings The different field urls for each field
    *					{ }
    */
   importJoins(settings) {
      // copy join settings
      this._joins = this.AB.cloneDeep(settings);

      var uniqueObjectIDs = {};
      // { obj.id : obj.id }
      // a hash of object.ids for all the relevant ABObjects necessary for this
      // ABObjectQuery

      var newLinks = [];
      // {array} of link definitions
      // build the operating values for this._links

      let storeObject = (object, alias) => {
         if (!object) return;

         // var inThere = newObjects.filter(obj => obj.id == object.id && obj.alias == alias ).length > 0;
         // if (!inThere) {
         // newObjects[alias] = object;
         // this.obj2Alias[object.id] = alias;
         this.alias2Obj[alias] = object.id;
         uniqueObjectIDs[object.id] = object.id;
         // newObjects.push({
         // 	alias: alias,
         // 	object: object
         // });
         // }
      };

      let storeLinks = (links) => {
         (links || []).forEach((link) => {
            // var inThere = newLinks.filter(l => l.fieldID == link.fieldID).length > 0;
            // if (!inThere) {
            newLinks.push(link);
            // }
         });
      };

      this.__linkProblems = this.__linkProblems ?? [];

      let processJoin = (baseObject, joins) => {
         if (!baseObject) return;

         (joins || []).forEach((link) => {
            // Convert our saved settings:
            //	{
            //		alias: "",							// the alias name of table - use in SQL command
            //		objectID: "uuid",					// id of the connection object
            //		links: [
            //			{
            //				alias: "",							// the alias name of table - use in SQL command
            //				fieldID: "uuid",					// uhe connection field of the object we are joining with.
            //				type:[left, right, inner, outer]	// join type: these should match the names of the knex methods
            //						=> innerJoin, leftJoin, leftOuterJoin, rightJoin, rightOuterJoin, fullOuterJoin
            //				links: [
            //					...
            //				]
            //			}
            //		]
            //	},

            var linkField = baseObject.fieldByID(link.fieldID);
            if (!linkField) {
               this.__linkProblems.push({
                  message: `could not resolve our linkField[${link.fieldID}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            // track our linked object
            var linkObject = this.AB.objectByID(linkField.settings.linkObject);
            if (!linkObject) {
               this.__linkProblems.push({
                  message: `could not resolve our linked field -> linkObject[${linkField.settings.linkObject}]`,
                  data: {
                     link,
                  },
               });
               return;
            }

            storeObject(linkObject, link.alias);

            storeLinks(link.links);

            processJoin(linkObject, link.links);
         });
      };

      // if (!this._joins.objectURL)
      // 	// TODO: this is old query version
      // 	return;

      // store the root object
      var rootObject = this.objectBase();
      if (!rootObject) {
         // this._objects = newObjects;
         this.__linkProblems.push({
            message: "could not resolve our base object",
            data: {
               objectID: this._joins?.objectID,
            },
         });
         return;
      }

      storeObject(rootObject, "BASE_OBJECT");

      storeLinks(settings.links);

      processJoin(rootObject, settings.links);

      // this._objects = newObjects;
      this._links = newLinks;
      this.objectIDs = Object.keys(uniqueObjectIDs);
   }

   /**
    * @method exportJoins
    * save our list of objects into our format for persisting on the server
    * @param {array} settings
    */
   exportJoins() {
      return this.AB.cloneDeep(this._joins || {});
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method model
    * return a Model object that will allow you to interact with the data for
    * this ABObjectQuery.
    */
   model() {
      var model = new ABModelQuery(this);

      // default the context of this model's operations to this object
      model.contextKey(this.constructor.contextKey());
      model.contextValues({ id: this.id }); // the datacollection.id

      return model;
   }

   /**
    * @method canFilterObject
    * evaluate the provided object to see if it can directly be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterObject(object) {
      if (!object) return false;

      // I can filter this object if it is one of the objects in my joins
      return (
         this.objects((obj) => {
            return obj.id == object.id;
         }).length > 0
      );
   }

   /**
    * @method canFilterField
    * evaluate the provided field to see if it can be filtered by this
    * query.
    * @param {ABObject} object
    * @return {bool}
    */
   canFilterField(field) {
      if (!field) return false;

      // I can filter a field if it's object OR the object it links to can be filtered:
      let object = field.object;
      // Transition:
      // let linkedObject = this.objects(
      //    (obj) => obj.id == field.settings.linkObject
      // )[0];
      var linkedObject = field.datasourceLink;

      return this.canFilterObject(object) || this.canFilterObject(linkedObject);
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this object. This url pointer
    * should be able to be used by this.AB.urlResolve() to return
    * this object.
    *
    * @param {boolean} acrossApp - flag to include application id to url
    *
    * @return {string}
    */
   urlPointer(acrossApp) {
      console.error(
         "ABQueryCore.urlPointer(): Depreciated: Where is this being called?"
      );
      return this.application.urlQuery(acrossApp) + this.id;
   }

   /**
    * @method isGroup
    *
    * @return {boolean}
    */
   get isGroup() {
      return this.settings.grouping || false;
   }

   /**
    * @method isReadOnly
    *
    * @return {boolean}
    */
   get isReadOnly() {
      return true;
   }

   /**
    * @method isDisabled()
    * check this contains removed objects or fields
    *
    * @return {boolean}
    */
   isDisabled() {
      return this.disabled || false;
   }

   get workspaceFilterConditions() {
      let filterConditions = super.workspaceFilterConditions;
      if (
         filterConditions == null ||
         filterConditions.rules == null ||
         !filterConditions.rules.length
      ) {
         filterConditions = this.where;
      }

      return filterConditions;
   }
};


/***/ }),

/***/ 42260:
/*!******************************************!*\
  !*** ./AppBuilder/core/ABProcessCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"

var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);
const _concat = __webpack_require__(/*! lodash/concat */ 60659);

const ABProcessTaskSubProcess = __webpack_require__(/*! ../platform/process/tasks/ABProcessTaskSubProcess */ 39966);

module.exports = class ABProcessCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["label"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      this.elements().forEach((e) => {
         e.onProcessReady();
      });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process";
      this.xmlDefinition = attributes.xmlDefinition || null;

      // this.json = attributes.json || null;
      let currElements = this._elements || {};
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         var ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this.emit(
                  "warning",
                  `P[${this.name}] is referencing an unknown process element id[${eID}]`,
                  { process: this.id, eID }
               );
            }
         }
      });

      this._connections = attributes.connections || {};

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "xmlDefinition"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      data.elementIDs = [];
      for (var e in this._elements) {
         // NOTE: when a task is initially created, it doesn't have an .id
         // so we need to reference it by it's .diagramID
         data.elementIDs.push(
            this._elements[e].id ?? this._elements[e].diagramID
         );
      }

      data.connections = this._connections;

      // data.participantIDs = [];
      // for (var p in this._participants) {
      //     data.participantIDs.push(this._participants[p].id);
      // }

      return data;
   }

   //
   // XML Model
   //

   /**
    * modelDefinition()
    * return the current xml definition for this process
    * @return {string}
    */
   modelDefinition() {
      return this.xmlDefinition;
   }

   /**
    * modelNew()
    * initialze our xml definition to a new state.
    * @return {string}
    */
   modelNew() {
      this.xmlDefinition = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="process-def-${this.id}" targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn2:process id="Process_1" isExecutable="true">
    <bpmn2:startEvent id="StartEvent_1"/>
  </bpmn2:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn2:definitions>`;

      //// TODO: create a default Start Task here??
   }

   /**
    * modelUpdate()
    * update our xml definition from the provided description.
    * @param {string} xml  bpmn2 xml definition from our modeler.
    * @return {string}
    */
   modelUpdate(xml) {
      this.xmlDefinition = xml;
   }

   //
   // Diagram Elements
   //

   /**
    * connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn = () => true) {
      var allConnections = Object.keys(this._connections).map((e) => {
         return this._connections[e];
      });

      // If parent, merge connections
      if (this.process && this.key === "SubProcess") {
         allConnections = allConnections.concat(this.process.connections());
      }

      return allConnections.filter(fn);
   }

   /**
    * connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      return this.connections((t) => {
         return t.id == dID;
      })[0];
   }

   /**
    * connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      return this.connections((c) => {
         return c.to == dID;
      });
   }

   /**
    * connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      return this.connections((c) => {
         return c.from == dID;
      });
   }

   /**
    * connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      delete this._connections[element.id];
   }

   /**
    * connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      var bo = element.businessObject;
      var from = null;
      if (bo.sourceRef) {
         from = bo.sourceRef.id;
      }

      var to = null;
      if (bo.targetRef) {
         to = bo.targetRef.id;
      }

      var connection = {
         id: element.id,
         type: element.type,
         from: from,
         to: to,
      };
      return connection;
   }

   /**
    * connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      var simpleConn = this.connectionSimplyElement(element);
      if (simpleConn.from && simpleConn.to && element.parent) {
         this._connections[simpleConn.id] = simpleConn;
      } else {
         // this connection is no longer connecting anything thing.
         // it is being removed.
         this.connectionRemove(element);
      }
   }

   /**
    * elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      var allElements = Object.keys(this._elements).map((e) => {
         return this._elements[e];
      });
      return allElements.filter(fn);
   }

   /**
    * elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      this._elements[element.id || element.diagramID] = element;
   }

   /**
    * elementByID()
    * return the {ABProcessElement} that has the given .id
    * @param {string} id
    * @return {ABProcess[OBJ]}
    */
   elementByID(id) {
      return this._elements[id] ?? null;
   }

   /**
    * elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      return this.elements((t) => {
         return t.diagramID == dID;
      })[0];
   }

   /**
    * elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      delete this._elements[def.id || def.diagramID];
   }

   /**
    * isTriggeredBy()
    * scan our tasks and see if we have a "trigger" task that responds to
    * the provided key.
    * @param {string} key the trigger key
    * @return {bool}
    */
   isTriggeredBy(key) {
      return this.taskForTriggerKey(key) != null;
   }

   /**
    * connectionNextTask()
    * return the ABProcessElement(s) that are after the given Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionNextTask(currElement) {
      var elements = [];
      var nextConnections = this.connections((c) => {
         return c.from == currElement.diagramID;
      });
      nextConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.to;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      var elements = [];
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      prevConnections.forEach((c) => {
         var element = this.elements((e) => {
            return e.diagramID == c.from;
         })[0];
         if (element) {
            elements.push(element);
         }
      });
      return elements;
   }

   /**
    * processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      // var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      // return values.length > 0
      //    ? values.length > 1
      //       ? values
      //       : values[0]
      //    : null;

      var tasksToAsk = this.allPreviousTasks(currElement);
      var values = queryPreviousTasks(tasksToAsk, "processData", params, this);
      return values.length > 0
         ? values.length > 1
            ? values
            : values[0]
         : null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      var tasksToAsk = this.allPreviousTasks(currElement);
      // var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataFields",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * allPreviousConnections()
    * walk through the current graph and return all the previous connections
    * leading up to the given {ProcessElement}
    * @param {Connection} conn
    * @param {hash} hashConn
    *        { connection.id : connection }
    * @return {array}
    */
   allPreviousConnectionsForConnection(conn, hashConn) {
      var prevConnections = this.connections((c) => {
         return c.to == conn.from;
      });

      prevConnections.forEach((c) => {
         if (!hashConn[c.id]) {
            hashConn[c.id] = c;
            this.allPreviousConnectionsForConnection(c, hashConn);
         }
      });
   }
   allPreviousConnectionsForElement(currElement) {
      var prevConnections = this.connections((c) => {
         return c.to == currElement.diagramID;
      });
      var hashConn = {
         /* connection.id : connection */
      };
      // hashConn will contains the final collection of connections.

      prevConnections.forEach((c) => {
         hashConn[c.id] = c;
         this.allPreviousConnectionsForConnection(c, hashConn);
      });

      // TODO: detect circle backs and remove connections that
      // resolve back to currElement

      // convert our hash into an array
      return Object.keys(hashConn).map((k) => hashConn[k]);
   }

   allPreviousTasks(currElement) {
      var prevTasks = {}; /* task.id : task */
      var allPreviousConnections =
         this.allPreviousConnectionsForElement(currElement);
      var task;
      allPreviousConnections.forEach((conn) => {
         // each conn has a .to and a .from => grab both tasks
         task = this.elementForDiagramID(conn.to);
         if (task) prevTasks[task.id] = task;

         task = this.elementForDiagramID(conn.from);
         if (task) prevTasks[task.id] = task;
      });

      var tasksToAsk = Object.keys(prevTasks)
         .map((k) => prevTasks[k])
         .filter((t) => t.id != currElement.id);

      return tasksToAsk;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataObjects(currElement) {
      var tasksToAsk = this.connectionPreviousTask(currElement);
      var fields = queryPreviousTasks(
         tasksToAsk,
         "processDataObjects",
         null,
         this
      );
      return fields.length > 0 ? fields : null;
   }

   /**
    * taskForTriggerKey()
    * return one or more tasks that respond to the given trigger key
    * @param {string} key a trigger key
    * @return {[ABProcessTask,...]}
    */
   taskForTriggerKey(key) {
      var trigger = this.elements((t) => {
         return t.triggerKey == key;
      })[0];
      if (trigger) {
         return trigger;
      } else {
         return null;
      }
   }

   //
   // Participants
   //

   // /**
   //  * participants()
   //  * return an array of participants that match the given filter (or all tasks
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided participants
   //  *                should be returned.
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participants(fn) {
   //     if (!fn)
   //         fn = () => {
   //             return true;
   //         };
   //     var all = Object.keys(this._participants).map((p) => {
   //         return this._participants[p];
   //     });
   //     return all.filter(fn);
   // }

   // /**
   //  * participantsForDiagramID()
   //  * return the participant(s) that are tied to the given xml diagram ID.
   //  * @param {string} dID the diagram ID
   //  * @return {[ABProcessParticipant,...]}
   //  */
   // participantsForDiagramID(dID) {
   //     return this.participants((p) => {
   //         return p.diagramID == dID;
   //     });
   // }
};

var queryPreviousTasks = (
   list,
   method,
   param,
   process,
   responses,
   processedIDs
) => {
   // recursive fn() to step through our graph and compile
   // results.
   if (typeof responses == "undefined") {
      responses = [];
   }
   if (typeof processedIDs == "undefined") {
      processedIDs = [];
   }
   if (list.length == 0) {
      return responses;
   } else {
      // get next task
      const task = list.shift();

      // if we haven't already done task:
      if (processedIDs.indexOf(task.diagramID) == -1) {
         // mark this task as having been processed
         processedIDs.push(task.diagramID);

         let value = null;

         // get any field's it provides
         if (!(task instanceof ABProcessTaskSubProcess))
            value = task[method].apply(task, param);

         // value = task[method].apply(task, param);

         if (value === null) value = [];
         responses = _concat(responses, value);

         // add any previous tasks to our list
         list = _concat(list, process.connectionPreviousTask(task));
      }

      // process next Task
      return queryPreviousTasks(
         list,
         method,
         param,
         process,
         responses,
         processedIDs
      );
   }
};


/***/ }),

/***/ 73323:
/*!***************************************!*\
  !*** ./AppBuilder/core/ABStepCore.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"

var ABMLClass = __webpack_require__(/*! ../platform/ABMLClass */ 70504);
const _concat = __webpack_require__(/*! lodash/concat */ 60659);

module.exports = class ABStepCore extends ABMLClass {
   constructor(attributes, AB) {
      super(["name", "text"], AB);

      this.fromValues(attributes);

      // indicate we are ready.
      // this.elements().forEach((e) => {
      //    e.onProcessReady();
      // });
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
    {
      id: uuid(),
      name: 'name',
      type: 'xxxxx',
      json: "{json}"
    }
    */
      this.id = attributes.id;
      this.name = attributes.name || "New Step";
      this.type = attributes.type || "step";
      this.text = attributes.text || "";
      this.settings = attributes.settings || {};
      this.settings.event = attributes?.settings?.event || "click";
      this.settings.el = attributes?.settings?.el || "";
      // this.xmlDefinition = attributes.xmlDefinition || null;

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this ABProcess instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      // debugger;
      // default label value
      if (!this.label) {
         this.label = this.name;
      }

      // OP.Multilingual.unTranslate(this, this, ["label"]);
      var data = super.toObj();

      var fieldsToSave = ["id", "name", "settings", "type"];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   // /**
   //  * steps()
   //  * return an array of steps that match the given filter (or all steps
   //  * if no filter is provided).
   //  * @param {fn} fn an iterator that returns true if the provided element
   //  *                should be returned.
   //  * @return {[ABStep]}
   //  */
   // steps(fn = () => true) {
   //    var allSteps = Object.keys(this._steps).map((e) => {
   //       return this._steps[e];
   //    });
   //    return allSteps.filter(fn);
   // }

   // /**
   //  * stepAdd()
   //  * insert a step to be added to this hint.
   //  * @param {ABStep} element
   //  *        the full instance of an ABStep to track.
   //  */
   // stepAdd(step) {
   //    this._steps[step.id] = step;
   // }

   // /**
   //  * stepByID()
   //  * return the {ABStep} that has the given .id
   //  * @param {string} id
   //  * @return {ABStep[OBJ]}
   //  */
   // stepByID(id) {
   //    return this._step[id] ?? null;
   // }

   // /**
   //  * stepRemove()
   //  * remove a step from being displayed by this hint.
   //  * @param {obj|ABStep} def
   //  *        a definition of, or full Object instance of the ABStep
   //  *        to remove.
   //  */
   // stepRemove(def) {
   //    delete this._steps[def.id];
   // }
};


/***/ }),

/***/ 60979:
/*!**********************************************!*\
  !*** ./AppBuilder/core/ABViewManagerCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewManager
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

var AllViews = [
   __webpack_require__(/*! ../platform/views/ABView */ 94784),
   __webpack_require__(/*! ../platform/views/ABViewCarousel */ 64422),
   __webpack_require__(/*! ../platform/views/ABViewChart */ 73936),
   __webpack_require__(/*! ../platform/views/ABViewChartArea */ 2909),
   __webpack_require__(/*! ../platform/views/ABViewChartBar */ 69623),
   __webpack_require__(/*! ../platform/views/ABViewChartLine */ 6765),
   __webpack_require__(/*! ../platform/views/ABViewChartPie */ 28280),
   __webpack_require__(/*! ../platform/views/ABViewComment */ 39058),
   __webpack_require__(/*! ../platform/views/ABViewConditionalContainer */ 45025),
   __webpack_require__(/*! ../platform/views/ABViewConnectDataFilter */ 57111),
   __webpack_require__(/*! ../platform/views/ABViewContainer */ 35798),
   __webpack_require__(/*! ../platform/views/ABViewCSVExporter */ 11200),
   __webpack_require__(/*! ../platform/views/ABViewCSVImporter */ 74841),
   __webpack_require__(/*! ../platform/views/ABViewDataFilter */ 97814),
   __webpack_require__(/*! ../platform/views/ABViewDataview */ 24216),
   __webpack_require__(/*! ../platform/views/ABViewDocxBuilder */ 84648),
   __webpack_require__(/*! ../platform/views/ABViewGrid */ 77574),
   __webpack_require__(/*! ../platform/views/ABViewImage */ 44998),
   __webpack_require__(/*! ../platform/views/ABViewLabel */ 47935),
   __webpack_require__(/*! ../platform/views/ABViewLayout */ 90427),
   __webpack_require__(/*! ../platform/views/ABViewList */ 94116),
   __webpack_require__(/*! ../platform/views/ABViewMenu */ 85342),
   __webpack_require__(/*! ../platform/views/ABViewPage */ 2983),
   __webpack_require__(/*! ../platform/views/ABViewPDFImporter */ 7617),
   __webpack_require__(/*! ../platform/views/ABViewPivot */ 40912),
   __webpack_require__(/*! ../platform/views/ABViewTab */ 69366),
   __webpack_require__(/*! ../platform/views/ABViewText */ 69330),

   //
   // Special Editors
   //
   __webpack_require__(/*! ../platform/views/ABViewGantt */ 62171),
   __webpack_require__(/*! ../platform/views/ABViewKanban */ 13665),
   __webpack_require__(/*! ../platform/views/ABViewReportsManager */ 25583),
   __webpack_require__(/*! ../platform/views/ABViewScheduler */ 68695),

   //
   // Detail Components
   //
   __webpack_require__(/*! ../platform/views/ABViewDetail */ 65862),
   __webpack_require__(/*! ../platform/views/ABViewDetailCheckbox */ 11865),
   __webpack_require__(/*! ../platform/views/ABViewDetailConnect */ 6101),
   __webpack_require__(/*! ../platform/views/ABViewDetailCustom */ 52378),
   __webpack_require__(/*! ../platform/views/ABViewDetailImage */ 71951),
   // require("../platform/views/ABViewDetailSelectivity"),
   __webpack_require__(/*! ../platform/views/ABViewDetailText */ 97654),
   __webpack_require__(/*! ../platform/views/ABViewDetailTree */ 18745),

   //
   // Form Components
   //
   __webpack_require__(/*! ../platform/views/ABViewForm */ 40194),
   __webpack_require__(/*! ../platform/views/ABViewFormButton */ 44388),
   __webpack_require__(/*! ../platform/views/ABViewFormCheckbox */ 93452),
   __webpack_require__(/*! ../platform/views/ABViewFormConnect */ 55030),
   __webpack_require__(/*! ../platform/views/ABViewFormCustom */ 36365),
   __webpack_require__(/*! ../platform/views/ABViewFormDatepicker */ 31223),
   __webpack_require__(/*! ../platform/views/ABViewFormJson */ 51533),
   __webpack_require__(/*! ../platform/views/ABViewFormNumber */ 54045),
   __webpack_require__(/*! ../platform/views/ABViewFormReadonly */ 26314),
   __webpack_require__(/*! ../platform/views/ABViewFormSelectMultiple */ 87262),
   __webpack_require__(/*! ../platform/views/ABViewFormSelectSingle */ 24215),
   __webpack_require__(/*! ../platform/views/ABViewFormTextbox */ 83743),
   __webpack_require__(/*! ../platform/views/ABViewFormTree */ 20297),
];

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
AllViews.forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

module.exports = class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            console.error(
               "!! View[" +
                  values.key +
                  "] not yet defined.  Have an ABView instead:"
            );
            return new Views["view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }
};


/***/ }),

/***/ 42428:
/*!****************************************************!*\
  !*** ./AppBuilder/core/ABViewManagerMobileCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewManagerMobile
 *
 * An interface for managing the different ABViews available in our AppBuilder.
 *
 */

/*
 * Views
 * A name => ABView  hash of the different ABViews available.
 */
var Views = {};
[
   __webpack_require__(/*! ../platform/mobile/ABMobilePage */ 18315),
   __webpack_require__(/*! ../platform/mobile/ABMobileView */ 94197),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewForm */ 55957),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormButton */ 85507),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormCheckbox */ 82097),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormConnect */ 89274),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormDate */ 32747),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormDatetime */ 24207),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormEmail */ 81854),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormFile */ 57078),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormFormula */ 11228),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormImage */ 79880),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormNumber */ 80585),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormReadonly */ 12767),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormSelectMultiple */ 32763),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormSelectSingle */ 28131),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewFormTextbox */ 78310),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewLabel */ 98534),
   __webpack_require__(/*! ../platform/mobile/ABMobileViewList */ 76944),
].forEach((v) => {
   if (v.default?.common) {
      v = v.default;
   }
   Views[v.common().key] = v;
});

module.exports = class ABViewManagerCore {
   /**
    * @function allViews
    * return all the currently defined ABViews in an array.
    * @return [{ABView},...]
    */
   static allViews(fn = () => true) {
      var views = [];
      for (var v in Views) {
         var V = Views[v];
         if (fn(V)) {
            views.push(V);
         }
      }
      return views;
   }

   /**
    * @function newView
    * return an instance of an ABView based upon the values.key value.
    * @return {ABView}
    */
   static newView(values, application, parent) {
      parent = parent || null;

      if (values.key == "detailselectivity") {
         values.key = "detailconnect";
      }

      //		if ((values.key) && (Views[values.key])) {
      if (values.key) {
         if (!Views[values.key]) {
            console.error(
               "!! View[" +
                  values.key +
                  "] not yet defined.  Have an ABView instead:"
            );
            return new Views["mobile-view"](values, application, parent);
         }

         return new Views[values.key](values, application, parent);
      } else {
         var err = new Error(`Unknown view key [${values.key}]`);
         console.error(err); // show the stack.
         console.error({
            error: err,
            values: values,
            application: application,
         });
         return null;
      }
   }

   static viewClass(key) {
      if (Views[key]) {
         return Views[key];
      }
      console.error(`Unknown View Key[${key}]`);
      return;
   }
};


/***/ }),

/***/ 78260:
/*!**********************************************!*\
  !*** ./AppBuilder/core/FilterComplexCore.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 52174);
// const ABObjectQuery = require("../platform/ABObjectQuery");

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field) {
   if (!field) return null;
   if (!field.columnName) return null;
   const columnName = field.columnName;

   let value = null;

   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName];
   } else {
      value = rowData[columnName];
   }

   // pull relation data
   if (value == null && field.relationName) {
      const relationName = field.relationName();
      const pureRelationName = relationName.split(".")[1]; // support [BASE_OBJECT.columnName] field name of ABQuery
      value = rowData[relationName] || rowData[pureRelationName];
   }

   if (value != null && !isNaN(value)) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (const k in rowData) {
      const key = k.split(".")[1];
      if (key && key == field.id) {
         value = rowData[k];
      }
   }

   if (
      (value == null || (typeof value == "number" && isNaN(value))) &&
      field.format
   )
      value = field.format(rowData);

   return value;
}

function getConnectFieldValue(rowData, field) {
   let connectedVal = "";

   if (rowData) {
      let relationName = field.relationName();
      if (rowData[relationName]) {
         connectedVal =
            (field.indexField
               ? rowData[relationName][field.indexField.columnName]
               : null) ?? // custom index
            (field.indexField2
               ? rowData[relationName][field.indexField2.columnName]
               : null) ?? // custom index 2
            rowData[relationName].id ??
            rowData[relationName];
      } else {
         let fieldVal = getFieldVal(rowData, field);
         if (fieldVal != null) {
            connectedVal = fieldVal;
         }
      }
   }
   return connectedVal;
}

module.exports = class FilterComplexCore extends ABComponent {
   constructor(idBase, AB) {
      idBase = idBase || "ab_filter_complex";

      if (typeof AB === "undefined") {
         console.error("FilterComplexCore(): being called without an AB!");
      }

      super(null, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.condition = {};
      // const batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      const _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options = {}) {
      this._settings = options;
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      // If conditions but no data return false
      if (condition?.rules?.length && rowData == null) return false;

      // If no conditions, then return true
      if (!condition?.rules?.length || rowData == null) return true;

      let result = condition.glue === "and" ? true : false;

      condition.rules.forEach((filter) => {
         // Nested filters
         if (filter?.rules?.length) {
            if (condition.glue === "or")
               result = result || this.isValid(rowData, filter);
            else result = result && this.isValid(rowData, filter);
            return;
         }
         // Skip incomplete filter condition
         else if (!filter.key || !filter.rule) return;

         const fieldInfo = (this._Fields || []).filter(
            (f) => f.id == filter.key || f.columnName == filter.key
         )[0];

         if (!fieldInfo) return;

         let condResult = null;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         let ruleFieldType = fieldInfo.key;

         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         let value = null;

         if (fieldInfo.relationName) {
            value = getConnectFieldValue(rowData, fieldInfo);
         } else {
            value = getFieldVal(rowData, fieldInfo);
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               if (value == null) value = "";

               condResult = this.textValid(value, filter.rule, filter.value);
               break;
            case "date":
            case "datetime":
               condResult = this.dateValid(value, filter.rule, filter.value);
               break;
            case "number":
            case "calculate":
            case "formula":
               condResult = this.numberValid(value, filter.rule, filter.value);
               break;
            case "list":
               condResult = this.listValid(value, filter.rule, filter.value);
               break;
            case "boolean":
               condResult = this.booleanValid(value, filter.rule, filter.value);
               break;
            case "user":
               condResult = this.userValid(value, filter.rule, filter.value);
               break;
            case "connectField":
            case "connectObject":
               condResult = this.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = this.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (condition.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   textValid(value, rule, compareValue) {
      let result = false;

      value = value.trim().toLowerCase();
      value = this._logic.removeHtmlTags(value); // remove html tags - rich text editor

      compareValue = compareValue.trim().toLowerCase().replace(/  +/g, " ");

      // support "john smith" => "john" OR/AND "smith"
      const compareArray = compareValue.split(" ");

      switch (rule) {
         case "contains":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value.indexOf(val) > -1;
            });
            break;
         case "not_contains":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value.indexOf(val) < 0;
            });
            break;
         case "equals":
            compareArray.forEach((val) => {
               if (result == false)
                  // OR
                  result = value == val;
            });
            break;
         case "not_equal":
            result = true;
            compareArray.forEach((val) => {
               if (result == true)
                  // AND
                  result = value != val;
            });
            break;
         case "is_empty":
            result = value == "" || value == null;
            break;
         case "is_not_empty":
            result = value != "" && value != null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   dateValid(value, rule, compareValue) {
      let result = false;

      if (!(value instanceof Date)) value = new Date(value);

      if (!(compareValue instanceof Date))
         compareValue = new Date(compareValue);
      switch (rule) {
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         case "is_current_date":
            result =
               value.setHours(0, 0, 0, 0) == compareValue.setHours(0, 0, 0, 0);
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }
      return result;
   }

   numberValid(value, rule, compareValue) {
      let result = false;

      value = Number(value);
      compareValue = Number(compareValue);

      switch (rule) {
         case "equal":
         case "equals":
            result = value == compareValue;
            break;
         case "not_equal":
            result = value != compareValue;
            break;
         case "less":
            result = value < compareValue;
            break;
         case "greater":
            result = value > compareValue;
            break;
         case "less_or_equal":
            result = value <= compareValue;
            break;
         case "greater_or_equal":
            result = value >= compareValue;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   listValid(value, rule, compareValue) {
      let result = false;

      // compareValue = compareValue.toLowerCase();

      if (!Array.isArray(compareValue)) compareValue = [compareValue];

      switch (rule) {
         case "equals":
            if (value) result = compareValue.indexOf(value) > -1;
            break;
         case "not_equal":
            if (value) result = compareValue.indexOf(value) < 0;
            else result = true;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   booleanValid(value, rule, compareValue) {
      let result = false;

      switch (rule) {
         case "checked":
            result = value == true || value > 0 || value == "true";
            break;
         case "unchecked":
            result =
               value == false ||
               value <= 0 ||
               value == "false" ||
               value == null;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }

      return result;
   }

   userValid(value, rule, compareValue) {
      if (!value) return false;
      let result = false;

      // if (Array.isArray(value)) value = [value];
      /* eslint-disable no-fallthrough */
      switch (rule) {
         case "is_current_user":
            result = value == this.Account.username;
            break;
         case "is_not_current_user":
            result = value != this.Account.username;
            break;
         case "contain_current_user":
            compareValue = this.Account.username;
         // break;  <-- NO BREAK HERE: fall through to "equals"

         case "equals":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == compareValue).length >
               0;
            break;
         case "not_contain_current_user":
            compareValue = this.Account.username;
         // break;  <-- NO BREAK HERE: fall through to "not_equals"

         case "not_equal":
            if (!Array.isArray(value)) value = [value];

            result =
               value.filter((v) => (v.username || v) == compareValue).length <
               1;
            break;
         default:
            result = this.queryFieldValid(value, rule, compareValue);
            break;
      }
      /* eslint-enable no-fallthrough */

      return result;
   }

   queryFieldValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      // queryId:fieldId
      const queryId = compareValue.split(":")[0],
         fieldId = compareValue.split(":")[1];

      // if no query
      const query = this.AB.queries((q) => q.id == queryId)[0];
      if (!query) return result;

      // if no field
      const field = query.fields((f) => f.id == fieldId)[0];
      if (!field) return result;

      let qIdBase = "{idBase}-query-field-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFieldFilter = new this.constructor(qIdBase, this.AB);
      inQueryFieldFilter.Account = this.Account;
      inQueryFieldFilter.fieldsLoad(query.fields());
      inQueryFieldFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query_field":
            result = inQueryFieldFilter.isValid(rowData);
            break;
         case "not_in_query_field":
            result = !inQueryFieldFilter.isValid(rowData);
            break;
      }

      return result;
   }

   inQueryValid(rowData, rule, compareValue) {
      let result = false;

      if (!compareValue || !this.AB) return result;

      // if no query
      let query = this.AB.queries((q) => q.id == compareValue)[0];
      if (!query) return result;

      let qIdBase = "{idBase}-query-{id}"
            .replace("{idBase}", this.idBase)
            .replace("{id}", query.id),
         inQueryFilter = new this.constructor(qIdBase, this.AB);
      inQueryFilter.Account = this.Account;
      inQueryFilter.fieldsLoad(query.fields());
      inQueryFilter.setValue(query.workspaceFilterConditions);

      switch (rule) {
         case "in_query":
            result = inQueryFilter.isValid(rowData);
            break;
         case "not_in_query":
            result = !inQueryFilter.isValid(rowData);
            break;
      }

      return result;
   }

   dataCollectionValid(value, rule, compareValue) {
      let result = false;

      if (!compareValue) return result;

      let dc = this.AB.datacollections((d) => d.id == compareValue)[0];

      switch (rule) {
         case "in_data_collection":
            if (!dc) return false;

            result = dc.getData((d) => d.id == value.id).length > 0;
            break;
         case "not_in_data_collection":
            if (!dc) return true;

            result = dc.getData((d) => d.id == value.id).length < 1;
            break;
      }

      return result;
   }

   connectFieldValid(rowData, field, rule, compareValue) {
      let relationName = field.relationName();

      let connectedVal = "";

      if (rowData) {
         if (rowData[relationName]) {
            connectedVal = (
               (field.indexField
                  ? rowData[relationName][field.indexField.columnName]
                  : null) ?? // custom index
               (field.indexField2
                  ? rowData[relationName][field.indexField2.columnName]
                  : null) ?? // custom index 2
               rowData[relationName].id ??
               rowData[relationName]
            )
               .toString()
               .toLowerCase();
         } else {
            let fieldVal = getFieldVal(rowData, field);
            if (fieldVal != null) {
               connectedVal = fieldVal;
            }
         }
      }

      // If value will be the connected object, then pull value (string)
      if (typeof connectedVal == "object") {
         connectedVal =
            connectedVal[field.indexField.columnName] ??
            connectedVal[field.indexField2.columnName] ??
            connectedVal[field.columnName] ??
            connectedVal;
      }

      // Compare value isn't always a string?
      // https://appdev-designs.sentry.io/issues/5056850389/
      let compareValueLowercase =
         typeof compareValue === "string"
            ? compareValue.toLowerCase?.()
            : compareValue;

      switch (rule) {
         case "contains":
            return connectedVal.toString().indexOf(compareValueLowercase) > -1;
         case "not_contains":
            return connectedVal.toString().indexOf(compareValueLowercase) == -1;
         case "equals":
            return connectedVal == compareValueLowercase;
         case "not_equal":
            return connectedVal != compareValueLowercase;
         case "in_query":
         case "not_in_query":
            return this.inQueryValid(rowData[relationName], rule, compareValue);
         case "is_current_user":
         case "is_not_current_user":
         case "contain_current_user":
         case "not_contain_current_user":
            return this.userValid(connectedVal, rule, compareValue);
         case "is_empty":
            return (
               rowData[relationName] == null ||
               rowData[relationName].length < 1 ||
               rowData[relationName] == ""
            );
         case "is_not_empty":
            return (
               rowData[relationName] != null &&
               ((Array.isArray(rowData[relationName]) &&
                  rowData[relationName].length > 0) ||
                  rowData[relationName] != "")
            );
         case "in_data_collection":
         case "not_in_data_collection":
            return this.dataCollectionValid(connectedVal, rule, compareValue);
      }
   }

   thisObjectValid(rowData, rule, compareValue) {
      let result = false;
      let query = null;
      let listThisObjects = null;
      let alias = null;
      let newRowData = null;

      switch (rule) {
         // if in_query condition
         case "in_query":
         case "not_in_query":
            if (!this._Object) return result;

            // if > 1 copy of this object in query ==> Error!
            query = this.AB.queries((q) => q.id == compareValue)[0];

            if (!query) return result;

            listThisObjects = query.objects((o) => {
               return o.id == this._Object.id;
            });

            if (listThisObjects.length > 1) {
               // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
               // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
               // this object as part of the query.

               console.error(
                  "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
               );

               return true;
            }

            // get this object's alias from the query
            alias = query.objectAlias(this._Object.id);

            // make sure all my columns in rowData are prefixed by "alias".columnName
            newRowData = {};

            Object.keys(rowData).forEach((key) => {
               newRowData[`${alias}.${key}`] = rowData[key];
            });

            // then pass this on to the _logic.queryValid();
            return this.inQueryValid(newRowData, rule, compareValue);

         // if in_datacollection condition
         case "in_data_collection":
         case "not_in_data_collection":
            // send rowData, null to datacollectionValid()
            return this.dataCollectionValid(rowData, rule, compareValue);
      }
   }

   processFieldsLoad(processFields = []) {
      if (processFields && !Array.isArray(processFields)) {
         processFields = [processFields];
      }
      this._ProcessFields = processFields;

      this.uiInit();
   }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param array {ABField}
    * @param object {ABObject} [optional]
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter(
         (f) => f && f.fieldIsFilterable && f.fieldIsFilterable()
      );
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         // insert our uuid in addition to the rest of our fields
         let thisObjOption = {
            id: "this_object",
            label: object.label,
            key: "uuid",
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         // NOTE: Could not reference ABObjectQuery because recursive looping reference
         // if (object instanceof ABObjectQuery) {
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   fieldsToQB() {
      /*
      let mapTypes = {
         LongText: "string",
         email: "string",
         datetime: "date",
         connectField: "connectObject"
      };

      const fields = this._Fields.map((f) => {
         // Label
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         // Type
         let type = f.key || f.type;
         if (mapTypes[type]) type = mapTypes[type];

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return { id: f.columnName, value: label, type: type };
      });
      return fields;
      */

      let fields = (this._Fields || []).map((f) => {
         let label = f.label;
         if (this._settings.showObjectName && f.object && f.object.label)
            label = `${f.object.label}.${f.label}`;

         let type = "text"; // "text", "number", "date"
         let conditions = [];
         let processFieldKeys = [];
         let hasQueryField = true;

         if (!this._settings.isProcessParticipant)
            switch (f.key) {
               case "boolean":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersBoolean(f)
                  );
                  processFieldKeys = ["boolean"];

                  break;

               case "connectObject":
                  conditions = this.fieldsAddFiltersConnectObject(f);

                  // Add filter options to Custom index
                  if (
                     // 1:M
                     (f.settings.linkType == "one" &&
                        f.settings.linkViaType == "many") ||
                     // 1:1 isSource = true
                     (f.settings.linkType == "one" &&
                        f.settings.linkViaType == "one" &&
                        f.settings.isSource)
                  ) {
                     const stringResults = this.fieldsAddFiltersString(
                        f
                     ).filter(
                        (opt) =>
                           f.settings.isCustomFK ||
                           // If this connect field does not use custom FK, then allow just `is empty` and `is not empty` filter options
                           opt.id == "is_empty" ||
                           opt.id == "is_not_empty"
                     );
                     conditions = stringResults.concat(conditions);
                  }

                  hasQueryField = false;
                  processFieldKeys = ["connectObject"];

                  break;

               case "date":
               case "datetime":
                  type = "date";
                  conditions = conditions.concat(this.fieldsAddFiltersDate(f));
                  processFieldKeys = ["date", "datetime"];

                  break;

               case "calculate":
               case "formula":
               case "number":
                  type = "number";
                  conditions = conditions.concat(
                     this.fieldsAddFiltersNumber(f)
                  );
                  processFieldKeys = ["calculate", "formula", "number"];

                  break;

               case "string":
               case "LongText":
               case "email":
               case "AutoIndex":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersString(f)
                  );
                  processFieldKeys = [
                     "string",
                     "LongText",
                     "email",
                     "AutoIndex",
                  ];

                  break;

               case "list":
                  conditions = conditions.concat(this.fieldsAddFiltersList(f));

                  break;

               case "user":
                  conditions = conditions.concat(this.fieldsAddFiltersUser(f));
                  processFieldKeys = ["user"];

                  break;

               case "uuid":
                  conditions = conditions.concat(
                     this.fieldsAddFiltersThisObject(f)
                  );
                  hasQueryField = false;

                  break;
               default:
                  break;
            }
         else
            switch (f.key) {
               case "connectObject":
               case "uuid":
                  hasQueryField = false;

                  break;
            }

         conditions = conditions.concat(
            this.fieldsAddFiltersQuery(f, hasQueryField)
         );

         if (this._settings.isRecordRule) {
            conditions = conditions.concat(this.fieldsAddFiltersRecordRule(f));
         }

         let isProcessField =
            (this._ProcessFields || []).filter((processField) => {
               if (!processField) return false;

               if (processField.field) {
                  return processFieldKeys.includes(processField.field.key);
               } else if (processField.key) {
                  // uuid
                  let processFieldId = processField.key.split(".").pop();
                  return processFieldId == f.id || processFieldId == f.key;
               }
            }).length > 0;

         if (isProcessField) {
            conditions = conditions.concat(this.fieldsAddFiltersContext(f));
         }

         conditions = conditions.concat(this.fieldsAddFiltersCustom(f));

         // let type = f.id; // the default unique identifier for our filter types
         // if (f.id == "this_object") {
         //    // if this happens to be our special "this_object" field, then our
         //    // type needs to be the "uuid" type in the definition:
         //    type = f.type;
         // }

         // the format for webix querybuilder:
         // { id  value:"label" type }
         //      type: {string} the type of value it is.
         //            since we want to tailor value selectors per field,
         //            we will make a unique type for each field. and then
         //            add value selectors for that specific .type
         return {
            id: f.id,
            value: label,
            type: type,
            conditions: conditions,
            // format: () => {},
         };
      });

      // !!! Process Fields of ABProcess
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L636
      // https://github.com/digi-serve/appbuilder_class_core/blob/master/FilterComplexCore.js#L564
      // (this._ProcessFields || [])
      //    // if there is no .field, it is probably an embedded special field
      //    .filter((pField) => pField.field == null)
      //    .forEach((pField) => {
      //       // like: .uuid
      //       let key = pField.key.split(".").pop();
      //       if (key == "uuid" && this._Object) {
      //          fields.unshift({
      //             id: pField.key,
      //             value: this._Object.label,
      //             type: "text",
      //             conditions: this.fieldsAddFiltersContext(),
      //          });
      //       }
      //    });

      return fields;
   }

   fieldsAddFiltersDate(field) {
      let dateConditions = {
         less: this.labels.component.beforeCondition,
         greater: this.labels.component.afterCondition,
         less_or_equal: this.labels.component.onOrBeforeCondition,
         greater_or_equal: this.labels.component.onOrAfterCondition,
         is_current_date: this.labels.component.isCurrentDateCondition,
         less_current: this.labels.component.beforeCurrentCondition,
         greater_current: this.labels.component.afterCurrentCondition,
         less_or_equal_current:
            this.labels.component.onOrBeforeCurrentCondition,
         greater_or_equal_current:
            this.labels.component.onOrAfterCurrentCondition,
         last_days: this.labels.component.onLastDaysCondition,
         next_days: this.labels.component.onNextDaysCondition,
      };

      let result = [];

      for (let condKey in dateConditions) {
         if (condKey == "is_current_date") {
            result.push({
               id: condKey,
               value: dateConditions[condKey],
               batch: "none",
               handler: (a, b) => this.dateValid(a, condKey, b),
            });
         } else {
            result.push({
               id: condKey,
               value: dateConditions[condKey],
               batch: "datepicker",
               handler: (a, b) => this.dateValid(a, condKey, b),
            });
         }
      }
      return result;
   }

   fieldsAddFiltersString(field) {
      let stringConditions = {
         contains: {
            batch: "text",
            label: this.labels.component.containsCondition,
         },
         not_contains: {
            batch: "text",
            label: this.labels.component.notContainsCondition,
         },
         equals: {
            batch: "text",
            label: this.labels.component.isCondition,
         },
         not_equal: {
            batch: "text",
            label: this.labels.component.isNotCondition,
         },
         is_empty: {
            batch: "none",
            label: this.labels.component.isEmpty,
         },
         is_not_empty: {
            batch: "none",
            label: this.labels.component.isNotEmpty,
         },
      };

      let result = [];

      for (let condKey in stringConditions) {
         result.push({
            id: condKey,
            value: stringConditions[condKey].label,
            batch: stringConditions[condKey].batch,
            handler: (a, b) => this.textValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersNumber(field) {
      let numberConditions = {
         equals: this.labels.component.equalCondition,
         not_equal: this.labels.component.notEqualCondition,
         less: this.labels.component.lessThanCondition,
         greater: this.labels.component.moreThanCondition,
         less_or_equal: this.labels.component.lessThanOrEqualCondition,
         greater_or_equal: this.labels.component.moreThanOrEqualCondition,
      };

      let result = [];

      for (let condKey in numberConditions) {
         result.push({
            id: condKey,
            value: numberConditions[condKey],
            batch: "text",
            handler: (a, b) => this.numberValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersList(field) {
      let listConditions = {
         equals: this.labels.component.equalListCondition,
         not_equal: this.labels.component.notEqualListCondition,
      };

      let result = [];

      for (let condKey in listConditions) {
         result.push({
            id: condKey,
            value: listConditions[condKey],
            batch: "list",
            handler: (a, b) => this.listValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersBoolean(field) {
      let booleanConditions = {
         checked: this.labels.component.checkedCondition,
         unchecked: this.labels.component.notCheckedCondition,
      };

      let result = [];

      for (let condKey in booleanConditions) {
         result.push({
            id: condKey,
            value: booleanConditions[condKey],
            batch: "none",
            handler: (a, b) => this.booleanValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersUser(field) {
      let userConditions = {
         is_current_user: {
            batch: "none",
            label: this.labels.component.isCurrentUserCondition,
         },
         is_not_current_user: {
            batch: "none",
            label: this.labels.component.isNotCurrentUserCondition,
         },
         contain_current_user: {
            batch: "none",
            label: this.labels.component.containsCurrentUserCondition,
         },
         not_contain_current_user: {
            batch: "none",
            label: this.labels.component.notContainsCurrentUserCondition,
         },
         equals: {
            batch: "user",
            label: this.labels.component.equalListCondition,
         },
         not_equal: {
            batch: "user",
            label: this.labels.component.notEqualListCondition,
         },
      };

      let result = [];

      for (let condKey in userConditions) {
         result.push({
            id: condKey,
            value: userConditions[condKey].label,
            batch: userConditions[condKey].batch,
            handler: (a, b) => this.userValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersConnectObject(field) {
      const connectConditions = {
         same_as_user: {
            batch: "user",
            label: this.labels.component.sameAsUser,
            handler: (a, b) => this.userValid(a, "same_as_user", b),
         },
         not_same_as_user: {
            batch: "user",
            label: this.labels.component.notSameAsUser,
            handler: (a, b) => this.userValid(a, "not_same_as_user", b),
         },
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "in_data_collection", b),
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
            handler: (a, b) =>
               this.dataCollectionValid(a, "not_in_data_collection", b),
         },
         // TODO
         // contains: this.labels.component.containsCondition,
         // not_contains: this.labels.component.notContainCondition,
         // equals: this.labels.component.isCondition,
         // not_equal: this.labels.component.isNotCondition
      };

      const result = [];

      for (let condKey in connectConditions) {
         result.push({
            id: condKey,
            value: connectConditions[condKey].label,
            batch: connectConditions[condKey].batch,
            handler: connectConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersQuery(field, hasQueryField = false) {
      const queryConditions = hasQueryField
         ? {
              in_query_field: {
                 label: this.labels.component.inQueryField,
                 batch: "queryField",
              },
              not_in_query_field: {
                 label: this.labels.component.notInQueryField,
                 batch: "queryField",
              },
           }
         : {
              in_query: {
                 label: this.labels.component.inQuery,
                 batch: "query",
              },
              not_in_query: {
                 label: this.labels.component.notInQuery,
                 batch: "query",
              },
           };

      const result = [];

      for (const condKey in queryConditions) {
         result.push({
            id: condKey,
            value: queryConditions[condKey].label,
            batch: queryConditions[condKey].batch,
            handler: (a, b) => this.queryFieldValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersThisObject(field) {
      let thisObjectConditions = {
         in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.inDataCollection,
         },
         not_in_data_collection: {
            batch: "datacollection",
            label: this.labels.component.notInDataCollection,
         },
      };

      let result = [];

      for (let condKey in thisObjectConditions) {
         result.push({
            id: condKey,
            value: thisObjectConditions[condKey].label,
            batch: thisObjectConditions[condKey].batch,
            handler: (a, b) => this.thisObjectValid(a, condKey, b),
         });
      }

      return result;
   }

   fieldsAddFiltersRecordRule(field) {
      let recordRuleConditions = {
         same_as_field: this.labels.component.sameAsField,
         not_same_as_field: this.labels.component.notSameAsField,
      };

      let result = [];

      for (let condKey in recordRuleConditions) {
         result.push({
            id: condKey,
            value: recordRuleConditions[condKey],
            batch: "recordRule",
            handler: (a, b) => true, // TODO: record rule validation
         });
      }

      return result;
   }

   fieldsAddFiltersContext(field) {
      let contextConditions = {
         context_equals: {
            batch: "context",
            label: this.labels.component.equalsProcessValue,
            handler: (a, b) => a == b,
         },
         context_not_equal: {
            batch: "context",
            label: this.labels.component.notEqualsProcessValueCondition,
            handler: (a, b) => a != b,
         },
         context_in: {
            batch: "context",
            label: this.labels.component.inProcessValueCondition,
            handler: (a, b) => a.indexOf(b) > -1,
         },
         context_not_in: {
            batch: "context",
            label: this.labels.component.notInProcessValueCondition,
            handler: (a, b) => a.indexOf(b) == -1,
         },
      };

      let result = [];

      for (let condKey in contextConditions) {
         result.push({
            id: condKey,
            value: contextConditions[condKey].label,
            batch: contextConditions[condKey].batch,
            handler: contextConditions[condKey].handler,
         });
      }

      return result;
   }

   fieldsAddFiltersCustom(field) {
      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id || field] ?? {};
      return options.conditions ?? [];
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    *
    * return an array of all the ABObjectQuery.
    *
    * @param filter {Object}
    *
    * @return {array}
    */
   queries(filter = () => true) {
      const queryList = this._Queries ?? this.AB?.queries?.() ?? [];

      return queryList.filter((q) => filter(q));
   }

   setValue(settings) {
      this.condition = settings || {};

      this.condition.rules = this.condition.rules || [];
   }

   /**
    * @method getValue
    * return the current condition of the filter.
    * @return {JSON} -
    * {
    * 	glue: '', // 'and', 'or'
    *		rules: [
    *			{
    *				key:	'uuid',
    *				rule:	'rule',
    *				value:	'value'
    *			}
    *		]
    * }
    */
   getValue() {
      // When asked for a value before a condition is set, default the
      // unset glue to "and";
      if (typeof this.condition.glue == "undefined") {
         this.condition.glue = "and";
      }
      return this.condition;
   }

   isComplete() {
      let result = true;

      const noValueRules = [
         "is_current_user",
         "is_not_current_user",
         "contain_current_user",
         "not_contain_current_user",
         "same_as_user",
         "not_same_as_user",
         "is_empty",
         "is_not_empty",
         "checked",
         "unchecked",
         "is_current_date",
      ];

      const isCompleteRules = (rules = []) => {
         if (result == false) return;

         rules.forEach((r) => {
            if (r?.rules && Array.isArray(r?.rules)) {
               isCompleteRules(r?.rules);
            } else {
               result =
                  result &&
                  r?.key != null &&
                  r?.key != "" &&
                  r?.rule != null &&
                  r?.rule != "" &&
                  ((r?.value != null && r?.value != "") ||
                     noValueRules.indexOf(r?.rule) > -1);
            }
         });
      };

      isCompleteRules(this.condition?.rules);

      return result;
   }
};


/***/ }),

/***/ 87674:
/*!******************************************!*\
  !*** ./AppBuilder/core/RowFilterCore.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABComponent = __webpack_require__(/*! ../platform/ABComponent */ 52174);

/**
 *  support get data from objects and queries
 */
function getFieldVal(rowData, field, returnSingular = true) {
   if (!field) return null;
   if (!field.columnName) return null;
   // if rowData is an array, then pull the first element to get value
   if (rowData && rowData[0]) rowData = rowData[0];

   let columnId = field.id;
   let columnName = field.columnName;

   let value = null;
   if (columnName.indexOf(".") > -1) {
      let colName = columnName.split(".")[1];
      value = rowData[columnName] || rowData[colName] || rowData[columnId];
   } else {
      value = rowData[columnName] || rowData[columnId];
   }

   if (value) {
      return value;
   }

   // otherwise, this might be a process check where the rowData keys have
   // '[diagramID].[field.id]'
   for (var k in rowData) {
      var key = k.split(".")[1];
      if (key && (key == columnId || key == columnName)) {
         value = rowData[k];
      }
   }

   // if value is an array, filter empty item
   if (value && Array.isArray(value)) {
      value = value.filter((v) => v != null);
      if (returnSingular) value = value[0];
   }

   return value;
}

module.exports = class RowFilterCore extends ABComponent {
   constructor(App, idBase, AB) {
      idBase = idBase || "ab_row_filter";

      super(App, idBase, AB);

      this.Account = { username: "??" };
      this._settings = {};
      this.config_settings = {};
      // var batchName; // we need to revert to this default when switching away from a in/by query field

      this._QueryFields = [];
      this._Fields;

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onChange: () => {},
         },

         /**
          * @method getValue
          *
          * @return {JSON} -
          * {
          * 		glue: '', // 'and', 'or'
          *		rules: [
          *			{
          *				key:	'column name',
          *				rule:	'rule',
          *				value:	'value'
          *			}
          *		]
          * }
          */
         getValue: () => {
            return this.config_settings;
         },

         removeHtmlTags: function (text) {
            let result = "";
            try {
               let div = document.createElement("div");
               div.innerHTML = text;

               result = div.textContent || div.innerText || "";
            } catch (err) {
               result = (text || "").replace(/(<([^>]+)>)/gi, "");
            }

            return result;
         },

         textValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value == null) value = "";

            value = value.toString().trim().toLowerCase();
            value = _logic.removeHtmlTags(value); // remove html tags - rich text editor

            compareValue = compareValue
               .toString()
               .trim()
               .toLowerCase()
               .replace(/  +/g, " ");

            // support "john smith" => "john" OR/AND "smith"
            var compareArray = compareValue.split(" ");

            switch (rule) {
               case "contains":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value.indexOf(val) > -1;
                  });
                  break;
               case "not_contains":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value.indexOf(val) < 0;
                  });
                  break;
               case "equals":
                  compareArray.forEach((val) => {
                     if (result == false)
                        // OR
                        result = value == val;
                  });
                  break;
               case "not_equal":
                  result = true;
                  compareArray.forEach((val) => {
                     if (result == true)
                        // AND
                        result = value != val;
                  });
                  break;
               case "is_empty":
                  result = value == null || value == "";
                  break;
               case "is_not_empty":
                  result = value != null && value != "";
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         dateValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (!(value instanceof Date)) value = new Date(value);

            if (!(compareValue instanceof Date))
               compareValue = new Date(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         numberValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            value = Number(value);
            compareValue = Number(compareValue);

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               case "less":
                  result = value < compareValue;
                  break;
               case "greater":
                  result = value > compareValue;
                  break;
               case "less_or_equal":
                  result = value <= compareValue;
                  break;
               case "greater_or_equal":
                  result = value >= compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         listValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);
            if (value && value.toLowerCase) value = value.toLowerCase();

            compareValue = compareValue.toLowerCase();

            if (!Array.isArray(compareValue)) compareValue = [compareValue];

            switch (rule) {
               case "equals":
                  if (value) result = compareValue.indexOf(value) > -1;
                  break;
               case "not_equal":
                  if (value) result = compareValue.indexOf(value) < 0;
                  else result = true;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         booleanValid: function (rowData, field, rule, compareValue) {
            var result = false;

            var value = getFieldVal(rowData, field);

            // default value should be false
            if (value == null) value = false;

            switch (rule) {
               case "equals":
                  result = value == compareValue;
                  break;
               case "not_equal":
                  result = value != compareValue;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         userValid: (rowData, field, rule, compareValue) => {
            var result = false;

            var value = getFieldVal(rowData, field);

            // if (Array.isArray(value)) value = [value];

            switch (rule) {
               case "is_current_user":
                  result = value == this.Account.username;
                  break;
               case "is_not_current_user":
                  result = value != this.Account.username;
                  break;
               case "contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length > 0;
                  break;
               case "not_contain_current_user":
                  if (!value) {
                     result = false;
                     break;
                  }
                  if (!Array.isArray(value)) value = [value];

                  result =
                     (value || []).filter((v) => {
                        if (v) {
                           return (
                              (v.username || v.id || v.text || v) ==
                              this.Account.username
                           );
                        } else {
                           return false;
                        }
                     }).length == 0;
                  break;
               case "equals":
                  result = value.indexOf(compareValue) > -1;
                  break;
               case "not_equal":
                  result = value.indexOf(compareValue) < 0;
                  break;
               default:
                  result = _logic.queryValid(rowData, rule, compareValue);
                  break;
            }

            return result;
         },

         queryValid: (rowData, rule, compareValue) => {
            var result = false;

            if (!this.AB || !compareValue) return result;

            // queryId:fieldId
            var queryId = compareValue.split(":")[0],
               fieldId = compareValue.split(":")[1];

            // if no query
            var query = this.queries((q) => q.id == queryId)[0];
            if (!query) return result;

            // if no field
            var field = query.fields((f) => f.id == fieldId)[0];
            if (!field) return result;

            let qIdBase = "{idBase}-query-field-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFieldFilter = new this.constructor(this.App, qIdBase);
            inQueryFieldFilter.Account = this.Account;
            // inQueryFieldFilter.applicationLoad(this._Application);
            inQueryFieldFilter.fieldsLoad(query.fields());
            inQueryFieldFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query_field":
                  result = inQueryFieldFilter.isValid(rowData);
                  break;
               case "not_in_query_field":
                  result = !inQueryFieldFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         inQueryValid: (rowData, columnName, rule, compareValue) => {
            let result = false;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            if (!compareValue || !this.AB) return result;

            // if no query
            let query = this.queries((q) => q.id == compareValue)[0];
            if (!query) return result;

            let qIdBase = "{idBase}-query-{id}"
                  .replace("{idBase}", idBase)
                  .replace("{id}", query.id),
               inQueryFilter = new this.constructor(this.App, qIdBase);
            inQueryFilter.Account = this.Account;
            // inQueryFilter.applicationLoad(this._Application);
            inQueryFilter.fieldsLoad(query.fields());
            inQueryFilter.setValue(query.workspaceFilterConditions);

            switch (rule) {
               case "in_query":
                  result = inQueryFilter.isValid(rowData);
                  break;
               case "not_in_query":
                  result = !inQueryFilter.isValid(rowData);
                  break;
            }

            return result;
         },

         dataCollectionValid: (rowData, columnName, rule, compareValue) => {
            var result = false;

            if (!compareValue || !this.AB) return result;

            if (columnName) {
               rowData = rowData[columnName] || {};
            }

            let dc = this.AB.datacollectionByID(compareValue);

            switch (rule) {
               case "in_data_collection":
                  if (!dc) return false;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length > 0;
                  break;
               case "not_in_data_collection":
                  if (!dc) return true;

                  result =
                     dc.getData(
                        (d) => (d.id || d.uuid) == (rowData.id || rowData.uuid)
                     ).length < 1;
                  break;
            }

            return result;
         },

         connectFieldValid: function (rowData, field, rule, compareValue) {
            let relationName = field.relationName();

            let connectedVal = "";

            if (rowData) {
               if (rowData[relationName]) {
                  connectedVal = (
                     (field.indexField
                        ? rowData[relationName][field.indexField.columnName]
                        : false) || // custom index
                     (field.indexField2
                        ? rowData[relationName][field.indexField2.columnName]
                        : false) || // custom index 2
                     rowData[relationName].id ||
                     rowData[relationName]
                  )
                     .toString()
                     .toLowerCase();
               } else {
                  let fieldVal = getFieldVal(rowData, field);
                  if (fieldVal != null) {
                     connectedVal = fieldVal;

                     // an Object to a String
                     if (typeof connectedVal == "object") {
                        connectedVal =
                           field.datasourceLink.displayData(connectedVal);
                     }
                  }
               }
            }

            let compareValueLowercase = (compareValue || "").toLowerCase();

            switch (rule) {
               case "contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) > -1
                  );
               case "not_contains":
                  return (
                     connectedVal.toString().indexOf(compareValueLowercase) ==
                     -1
                  );
               case "equals":
                  return connectedVal == compareValueLowercase;
               case "not_equal":
                  return connectedVal != compareValueLowercase;
               case "in_query":
               case "not_in_query":
                  return _logic.inQueryValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
                  return _logic.userValid(rowData, field, rule, compareValue);
               case "is_empty":
                  return (
                     rowData[relationName] == null ||
                     rowData[relationName].length < 1 ||
                     rowData[relationName] == ""
                  );
               case "is_not_empty":
                  return (
                     rowData[relationName] != null &&
                     ((Array.isArray(rowData[relationName]) &&
                        rowData[relationName].length > 0) ||
                        rowData[relationName] != "")
                  );
               case "in_data_collection":
               case "not_in_data_collection":
                  return _logic.dataCollectionValid(
                     rowData,
                     relationName,
                     rule,
                     compareValue
                  );
            }
         },

         thisObjectValid: (rowData, rule, compareValue) => {
            let result = false;

            switch (rule) {
               // if in_query condition
               case "in_query":
               case "not_in_query":
                  if (!this.AB || !this._Object) return result;

                  // if > 1 copy of this object in query ==> Error!
                  var query = this.queries((q) => q.id == compareValue)[0];
                  if (!query) return result;

                  var listThisObjects = query.objects((o) => {
                     return o.id == this._Object.id;
                  });
                  if (listThisObjects.length > 1) {
                     // Alternative: choose the 1st instance of this object in the query, and make the compare on that.
                     // Be sure to warn the developer of the limitiations of an "this_object" "in_query"  when query has > 1 copy of
                     // this object as part of the query.

                     console.error(
                        "HEY!  Can't compare this_object to a query that has > 1 copy of that object!"
                     );
                     return true;
                  }

                  // get this object's alias from the query
                  var alias = query.objectAlias(this._Object.id);

                  // make sure all my columns in rowData are prefixed by "alias".columnName
                  var newRowData = {};
                  Object.keys(rowData).forEach((key) => {
                     newRowData[`${alias}.${key}`] = rowData[key];
                  });

                  // then pass this on to the _logic.queryValid();
                  return _logic.inQueryValid(
                     newRowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */

               // if in_datacollection condition
               case "in_data_collection":
               case "not_in_data_collection":
                  // send rowData, null to datacollectionValid()
                  return _logic.dataCollectionValid(
                     rowData,
                     null,
                     rule,
                     compareValue
                  );
               // break; /* eslint no-unreachable */
            }
         },
      });

      // Interface methods for parent component:
      // this.objectLoad = _logic.objectLoad;
      // this.viewLoad = _logic.viewLoad;
      this.getValue = _logic.getValue;
      // this.setValue = _logic.setValue;
      // this.isValid = _logic.isValid;
   }

   init(options) {
      if (options.showObjectName) {
         this._settings.showObjectName = options.showObjectName;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    */
   isValid(rowData) {
      var config_settings = this.config_settings;
      var _logic = this._logic;

      // If no conditions, then return true
      if (
         config_settings == null ||
         config_settings.rules == null ||
         config_settings.rules.length == 0
      )
         return true;

      if (rowData == null) return false;

      var result = config_settings.glue === "and" ? true : false;

      config_settings.rules.forEach((filter) => {
         if (!filter?.key || !filter?.rule) return;

         var fieldInfo = this._Fields.filter((f) => f.id == filter.key)[0];
         if (!fieldInfo) return;

         var condResult;

         // Filters that have "this_object" don't have a fieldInfo.key, so in that case,
         // define a special .key == "this_object"
         var ruleFieldType = fieldInfo.key;
         if (typeof fieldInfo.key == "undefined") {
            if (fieldInfo.id != "this_object") {
               fieldInfo.key = "connectField"; // if you are looking at the parent object it won't have a key to analyze
               ruleFieldType = fieldInfo.key;
            } else ruleFieldType = "this_object";
         }

         switch (ruleFieldType) {
            case "string":
            case "LongText":
            case "email":
               condResult = _logic.textValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "date":
            case "datetime":
               condResult = _logic.dateValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "number":
            case "formula":
               condResult = _logic.numberValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "list":
               condResult = _logic.listValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "boolean":
               condResult = _logic.booleanValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "user":
               condResult = _logic.userValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "connectField":
            case "connectObject":
               condResult = _logic.connectFieldValid(
                  rowData,
                  fieldInfo,
                  filter.rule,
                  filter.value
               );
               break;
            case "this_object":
               condResult = _logic.thisObjectValid(
                  rowData,
                  filter.rule,
                  filter.value
               );
               break;
         }

         if (config_settings.glue === "and") {
            result = result && condResult;
         } else {
            result = result || condResult;
         }
      });

      return result;
   }

   /**
    * @method applicationLoad
    * set application
    *
    * @param application {ABApplication}
    */
   // applicationLoad(application) {
   //    this._Application = application;
   // }

   /**
    * @method fieldsLoad
    * set fields
    *
    * @param {array} fields
    *        an array of fields used in this Query
    * @param {ABObject} object [optional]
    *        (optional) ABObject reference if this Filter should support
    *        the "this object" conditions.
    */
   fieldsLoad(fields = [], object = null) {
      this._Fields = fields.filter((f) => f?.fieldIsFilterable?.());
      // NOTE: User fields are now Connections, but we want to treat them
      // differently.
      this._QueryFields = this._Fields
         ? this._Fields.filter((f) => f && f.isConnection && f.key != "user")
         : [];

      // insert our 'this object' entry if an Object was given.
      if (object) {
         this._Object = object;

         let thisObjOption = {
            id: "this_object",
            label: object.label,
         };

         // If object is query ,then should define default alias: "BASE_OBJECT"
         if (object.viewName) {
            thisObjOption.alias = "BASE_OBJECT";
         }

         this._Fields.unshift(thisObjOption);
      } else {
         delete this._Object;
      }
   }

   queriesLoad(queries = []) {
      this._Queries = queries;
   }

   /**
    * @method queries()
    * return an array of all the ABObjectQuery.
    * @param {fn} filter
    * @return {array}
    */
   queries(filter = () => true) {
      let result = [];

      if (this.AB) {
         result = result.concat(this.AB.queries(filter));
      }

      if (this._Queries) {
         result = result.concat(
            (this._Queries || []).filter(
               (q) => filter(q) && result.filter((r) => r.id == q.id).length < 1
            )
         );
      }

      return result;
   }

   setValue(settings) {
      this.config_settings = settings || {};
      this.config_settings.rules = this.config_settings.rules || [];
   }
};


/***/ }),

/***/ 374:
/*!************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldAutoIndexCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldAutoIndex
 *
 * An ABFieldAutoIndex defines a AutoIndex field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldAutoIndexDefaults = {
   key: "AutoIndex",
   // unique key to reference this specific DataField

   description: "Auto Increment Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Auto Index",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["tinyint", "smallint", "mediumint", "int", "integer"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   prefix: "",
   delimiter: "none",
   displayLength: 4,
   previewText: "0000",
};

module.exports = class ABFieldAutoIndexCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldAutoIndexDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldAutoIndexDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getDelimiterSign(text) {
      const delimiterItem = this.delimiterList().filter((item) => {
         return item.id == text;
      })[0];

      return delimiterItem ? delimiterItem.sign : "";
   }

   static delimiterList() {
      return [
         { id: "none", value: L("None"), sign: "" },
         { id: "comma", value: L("Comma"), sign: ", " },
         { id: "slash", value: L("Slash"), sign: "/" },
         { id: "space", value: L("Space"), sign: " " },
         { id: "dash", value: L("Dash"), sign: "-" },
         { id: "colon", value: L("Colon"), sign: ":" },
      ];
   }

   static setValueToIndex(prefix, delimiter, displayLength, displayNumber) {
      const resultIndex =
         prefix +
         this.getDelimiterSign(delimiter) +
         ("0000000000" + displayNumber).slice(-parseInt(displayLength));

      return resultIndex;
   }

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.displayLength = parseInt(this.settings.displayLength);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }

   format(rowData) {
      if (!rowData?.[this.columnName]) return "";

      try {
         const resultAutoIndex = this.constructor.setValueToIndex(
            this.settings.prefix,
            this.settings.delimiter,
            this.settings.displayLength,
            rowData[this.columnName]
         );

         return resultAutoIndex;
      } catch (err) {
         return "";
      }
   }
};


/***/ }),

/***/ 85410:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldBooleanCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldBoolean
 *
 * An ABFieldBoolean defines a boolean field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldBooleanDefaults = {
   key: "boolean",
   // unique key to reference this specific DataField

   description: "A single checkbox that can be checked or unchecked.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "check-square-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'check-square-o'  to
   // reference 'fa-check-square-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Checkbox",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["boolean"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["bool", "boolean"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: 0,
};

module.exports = class ABFieldBooleanCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldBooleanDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldBooleanDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      if (this.settings.default != null)
         this.settings.default = parseInt(this.settings.default);
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null && this.settings.default != null) {
         values[this.columnName] = this.settings.default;
      }
   }
};


/***/ }),

/***/ 88238:
/*!************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCalculateCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCalculate
 *
 * An ABFieldCalculate defines a calculate field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

/** Private methods */
function AGE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   const today = new Date();
   const oneYear = 31536000000; // (24 * 60 * 60 * 1000) * 365;
   const diffYears = (today - dataDate) / oneYear;

   if (diffYears < 1) return Math.round(diffYears * 10) / 10;
   // float 2 digits
   else return Math.floor(diffYears); // no float digit

   // const today = new Date();
   // const age = today.getFullYear() - dataDate.getFullYear();
   // if (age < 1) {
   // 	const m = today.getMonth() - dataDate.getMonth();

   // 	age = parseFloat("0." + m);

   // 	// if (m < 0 || (m === 0 && today.getDate() < dataDate.getDate())) {
   // 	// 	age--;
   // 	// }
   // }
   // return age;
}

function YEAR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getFullYear();
}

function MONTH(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // Start at 0
   return dataDate.getMonth();
}

function DAY(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   return dataDate.getDate();
}

function DATE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one day
   const oneDay = 86400000; // 1000 * 60 * 60 * 24

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneDay);
}

function HOUR(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneHour = 3600000; // 1000 * 60 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneHour);
}

function MINUTE(dateString) {
   // validate
   if (!dateString) return 0;
   const dataDate = new Date(dateString);
   if (!dataDate) return 0;

   // number of miliseconds in one hour
   const oneMinute = 60000; // 1000 * 60

   // Convert back to days and return
   return Math.round(dataDate.getTime() / oneMinute);
}

function MINUTE_TO_HOUR(mins) {
   const hours = mins / 60;
   const rhours = Math.floor(hours);
   const minutes = (hours - rhours) * 60;
   const rminutes = Math.round(minutes);

   return parseFloat(`${rhours}.${rminutes}`);
}

const ABFieldCalculateDefaults = {
   key: "calculate",
   // unique key to reference this specific DataField

   description: "Perform a calculation based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calculator",
   // font-awesome icon reference.  (without the 'fa-').  so 'calculator'  to
   // reference 'fa-calculator'

   isFilterable: (field) => {
      const unsupportedInFilter = ["MINUTE_TO_HOUR", "DATE", "HOUR", "MINUTE"];
      const unsupported = unsupportedInFilter.filter((item) =>
         field.settings.formula.includes(item)
      );
      return unsupported.length == 0;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Calculate",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   formula: "",
   decimalSign: "none", // "none", "comma", "period", "space"
   decimalPlaces: 0, // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
};

module.exports = class ABFieldCalculateCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldCalculateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCalculateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method convertToJs
    *
    * @param {ABOBject} object
    * @param {string} formula
    * @param {object} rowData
    * @param {integer} place
    * @param {string} alias [Optional]
    */
   static convertToJs(object, formula, rowData, place, alias = null) {
      if (!formula) return "";

      // replace with current date
      formula = formula.replace(/\(CURRENT\)/g, "(new Date())");

      object.fields().forEach((f) => {
         let colName = f.columnName;
         if (colName.indexOf(".") > -1)
            // QUERY: get only column name
            colName = colName.split(".")[1];

         // if template does not contain, then should skip
         if (formula.indexOf("{" + colName + "}") < 0) return;

         const data =
            rowData[`${object.alias ?? alias}.${f.columnName}`] ??
            rowData[f.columnName];

         // number fields
         if (f.key == "number") {
            const numberVal = `(${data || 0})`; // (number) - NOTE : (-5) to support negative number
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               numberVal
            );
         }
         // calculate and formula fields
         else if (f.key == "calculate" || f.key == "formula") {
            let calVal = f.format(rowData) || 0;

            // pull number only
            if (typeof calVal == "string")
               calVal = calVal.replace(/[^-0-9.]/g, "");

            calVal = `(${calVal})`;

            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               calVal
            );
         }
         // date fields
         else if (f.key == "date" || f.key == "datetime") {
            const dateVal = `"${data || ""}"`; // "date"
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               dateVal
            );
         }
         // boolean fields
         else if (f.key == "boolean") {
            const booleanVal = `(${data || 0})`; // show 1 or 0 for boolean
            formula = formula.replace(
               new RegExp("{" + colName + "}", "g"),
               booleanVal
            );
         }
      });

      // decimal places - toFixed()
      // FIX: floating number calculation
      // https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
      return eval(formula).toFixed(place || 0);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   format(rowData) {
      let place = 0;
      if (this.settings.decimalSign != "none") {
         place = this.settings.decimalPlaces;
      }

      try {
         let result = this.constructor.convertToJs(
            this.object,
            this.settings.formula,
            rowData,
            place,
            this.alias
         );

         if (typeof result == "string")
            result = result.replace(/[^-0-9.]/g, "");

         switch (this.settings.decimalSign) {
            case "comma":
               result = result.replace(".", ",");
               break;
            case "space":
               result = result.replace(".", " ");
               break;
         }

         return result;
      } catch (err) {
         return "";
      }
   }
};


/***/ }),

/***/ 72131:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCombineCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCombine
 *
 * An ABFieldCombine defines a combined field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

// function L(key, altText) {
//    // TODO:
//    return altText; // AD.lang.label.getLabel(key) || altText;
// }

const ABFieldCombinedDefaults = {
   key: "combined",
   // unique key to reference this specific DataField

   description: "Combined Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "key",
   // font-awesome icon reference.  (without the 'fa-').  so 'key'  to
   // reference 'fa-key'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Combined Field",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   combinedFields: "",
   // {string} "field's uuid1, field's uuid2, field's uuid3, ..."
   // This tells us what fields will be combined.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   delimiter: "plus", // plus, space, dash, period
};

module.exports = class ABFieldCombineCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldCombinedDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldCombinedDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   fromValues(values) {
      super.fromValues(values);

      this.settings.delimiter =
         values.settings.delimiter || defaultValues.delimiter;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Remove every values, then we will use AUTO_INCREMENT of MySQL
      delete values[this.columnName];
   }
};


/***/ }),

/***/ 63800:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldConnectCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldConnect
 *
 * An ABFieldConnect defines a connect to other object field type.
 *
 */

var ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

// function L(key, altText) {
//    // TODO:
//    return altText; // AD.lang.label.getLabel(key) || altText;
// }

const ABFieldConnectDefaults = {
   key: "connectObject",
   // unique key to reference this specific DataField

   description: "Connect two data objects together",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "external-link",
   // font-awesome icon reference.  (without the 'fa-').  so 'external-link'  to
   // reference 'fa-external-link'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      const linkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      return ["one:many", "one:one"].indexOf(linkType) > -1;
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Connect to another record",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   linkObject: "", // ABObject.id
   // the .id of the ABObject we are connected to

   linkType: "one", // [one, many]
   // 'one' : this object can have only 1 of our linkObject
   // 'many': this object can have MANY of our linkObject

   linkViaType: "many", // [one, many]
   // 'one' : the linkedObject can only have 1 of me
   // 'many' : the linkedObject can have many of me

   linkColumn: "", // ABField.id
   // the .id of the field in the linkedObject that is our
   // connected field.

   isSource: null, // bit : 1,0
   // isSource indicates that this object is the source of the connection:
   // if linkType==one, and isSource=1, then the value in this object's field
   // 		is the connected object's id
   // if linkType == one, and isSource = 0, then the linkObject has this obj.id
   //  	in it's connected field (linkColumn)

   // the next 3 Fields are concerning how we connect to other ABObjects when
   // we are NOT using the .uuid as the connecting Value. Instead, there is an
   // ABIndex setting we are connecting with.
   isCustomFK: 0,
   // {bool} truthy [0,1, etc...]
   // indicates that this connection is using 1 or more custom foreign keys
   // for the data it is storing in it's relationship.

   indexField: "", // ABField.id
   // {string} {ABField.id}
   // In a Connection defined between A --> B, this field represents the ABField
   // that is used for the data being stored.
   // In 1:1,  1:M  or M:1  relationships, .indexField always refers to the
   //       field we are pulling the Data FROM.
   // In M:N relationships:  this will refer to the A.Field.id that is a custom
   //       key (if any).

   indexField2: "", // ABField.id
   // {string}  {ABField.id}
   // In the M:N relationship: this field refers to the B.Field.id that is a
   //       custom Key for the data we are storing.
};

module.exports = class ABFieldConnectCore extends ABField {
   constructor(values, object, fieldDefaults = ABFieldConnectDefaults) {
      super(values, object, fieldDefaults);

      this.isConnection = true;
      // {bool}
      // is this an ABFieldConnect type of field.
      // this is a simplified helper to identify if an ABField is a type
      // of connect field.  Since this is the only place it is defined,
      // all other field types will be falsy

      // // text to Int:
      // this.settings.isSource = parseInt(this.settings.isSource || 0);
      // this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldConnectDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.isSource = parseInt(this.settings.isSource || 0);
      this.settings.isCustomFK = parseInt(this.settings.isCustomFK || 0);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(/* values */) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   relationName() {
      // there is object name - {objectName}.{columnName}
      if (this.columnName.indexOf(".") > -1) {
         const names = this.columnName.split(".");
         return `${names[0]}.${this.AB.rules.toFieldRelationFormat(names[1])}`;
      } else {
         return this.AB.rules.toFieldRelationFormat(this.columnName);
      }
   }

   /**
    * @method datasourceLink
    * return the ABObject that this field connection links to
    * @return {ABObject}
    */
   get datasourceLink() {
      const linkObj = this.AB.objectByID(this.settings.linkObject);
      if (!linkObj) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkObject[${this.settings.linkObject}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkObject: this.settings.linkObject,
         });
      }
      return linkObj;
   }

   /**
    * @method fieldLink
    * return the ABField that we are linked to.
    * @return {ABDataField}  or undefined if not found.
    */
   get fieldLink() {
      const objectLink = this.datasourceLink;
      if (!objectLink) return null; // note: already Notified

      const linkColumn = objectLink.fieldByID(this.settings.linkColumn);
      if (!linkColumn) {
         const configError = new Error(
            `ConnectField[${this.label}][${this.id}] unable to find linkColumn[${this.settings.linkColumn}]`
         );
         this.AB.notify.builder(configError, {
            field: this,
            linkColumn: this.settings.linkColumn,
         });
      }
      return linkColumn;
   }

   /**
    * @method pullRelationValues
    * Return the data values for this field entry in the provided data row.
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData;

      // Get linked object
      const linkedObject = this.datasourceLink;

      let data = this.dataValue(row);
      if (data && linkedObject) {
         // convert to JSON
         if (typeof data == "string") {
            try {
               data = JSON.parse(data);
            } catch (e) {
               // must be a UUID
               // so just set that to selectedData:
               selectedData = data;
            }
         }

         selectedData = data;
      }

      return selectedData;
   }

   dataValue(rowData) {
      if (rowData == null) return "";

      const propName = `${this.object.name}.${this.relationName()}`;

      return (
         rowData[this.relationName()] ||
         rowData[propName] ||
         rowData[this.columnName] ||
         ""
      );
   }

   format(rowData) {
      const val = this.pullRelationValues(rowData);
      const linkedObject = this.datasourceLink;

      // array
      if (Array.isArray(val))
         return val
            .map((v) => {
               if (v.text == null) return linkedObject.displayData(v) || "";
               else return v.text || "";
            })
            .join(", ");
      // string
      else if (val) {
         if (val.text == null) return linkedObject.displayData(rowData) || "";
         else if (val.text) return val.text || "";
      }
      // empty string
      else return "";
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkType() {
      return this.settings.linkType;
   }

   /**
    * @method linkType
    * return the type of connection we have to our connected object
    * @return {string}
    */
   linkViaType() {
      return this.settings.linkViaType;
   }

   /**
    * @method isSource
    * does this object contain the .id of the remote object (in case of linkType : one )
    * @return {bool}
    */
   isSource() {
      return this.settings.isSource;
   }

   /**
    * @property indexField
    * @return {ABField}
    */
   get indexField() {
      if (!this.settings.isCustomFK || !this.settings.indexField) {
         return null;
      }
      const linkType = `${this.settings.linkType}:${this.settings.linkViaType}`;
      // 1:M
      if (linkType === "one:many") {
         return this.datasourceLink.fieldByID(this.settings.indexField);
      }
      // 1:1
      else if (linkType === "one:one") {
         if (this.settings.isSource) {
            return this.datasourceLink.fieldByID(this.settings.indexField);
         } else {
            return this.object.fieldByID(this.settings.indexField);
         }
      }
      // M:1
      else if (linkType === "many:one") {
         return this.object.fieldByID(this.settings.indexField);
      }
      // M:N
      else if (linkType === "many:many") {
         let indexField = this.object.fieldByID(this.settings.indexField);

         if (indexField == null)
            indexField = this.datasourceLink.fieldByID(
               this.settings.indexField
            );

         return indexField;
      }

      return null;
   }

   /**
    * @property indexField2
    * @return {ABField}
    */
   get indexField2() {
      if (!this.settings.isCustomFK || !this.settings.indexField2) {
         return null;
      }

      let indexField;

      // M:N only
      if (
         this.settings.linkType == "many" &&
         this.settings.linkViaType == "many"
      ) {
         indexField = this.object.fieldByID(this.settings.indexField2);

         if (indexField == null)
            indexField = this.datasourceLink.fieldByID(
               this.settings.indexField2
            );
      }

      return indexField;
   }

   /**
    * @method getRelationValue
    * pull values for update connect data
    * @param {Object} rowData
    * @param {Object} options - {
    *                               forUpdate: boolean
    *                           }
    * @return {Object}
    */
   getRelationValue(rowData, options = {}) {
      if (rowData == null) return;
      let colName;
      const indexField = this.indexField;
      const datasourceLink = this.datasourceLink;

      const linkType = `${this.settings.linkType}:${this.settings.linkViaType}`;

      // custom index
      // M:N
      if (linkType === "many:many") {
         const indexField2 = this.indexField2;

         if (indexField && indexField.object.id == datasourceLink.id) {
            colName = indexField.columnName;
         } else if (indexField2 && indexField2.object.id == datasourceLink.id) {
            colName = indexField2.columnName;
         }
      }
      // 1:M, 1:1 isSource = true
      else if (
         indexField &&
         (linkType === "one:many" ||
            (linkType === "one:one" && this.settings.isSource))
      ) {
         colName = indexField.columnName;
      }
      // M:1
      else if (linkType === "many:one") {
         // NOTE: M:1 has special case
         // it uses different value for search and update.
         // UPDATE uses row id
         // SEARCH uses custom index value
         if (options.forUpdate) {
            colName = datasourceLink.PK();
         } else {
            colName = indexField
               ? indexField.columnName
               : this.fieldLink.columnName;
         }
      }
      // NO CUSTOM INDEX
      else if (datasourceLink) {
         colName = datasourceLink.PK();
      }

      let result =
         rowData[colName] ||
         rowData[this.object?.PK()] ||
         rowData.id ||
         rowData;

      if (colName == "id") {
         result = parseInt(result);
      }

      return result;
   }
};


/***/ }),

/***/ 34493:
/*!***************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldCore
 *
 * ABFieldBase defines the common ABField structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABObject classes.
 *
 */
// const ABEmitter = require("../../platform/ABEmitter");
const ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 70504);

module.exports = class ABFieldCore extends ABMLClass {
   constructor(values, object, fieldDefaults) {
      super(["label"], object.AB);

      // NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      this.defaults = fieldDefaults || {};

      /*
  		{
  			id:'uuid',					// uuid value for this obj
  			key:'fieldKey',				// unique key for this Field
  			icon:'font',				// fa-[icon] reference for an icon for this Field Type
  			label:'',					// pulled from translation
			columnName:'column_name',	// a valid mysql table.column name
			isImported: 1/0,			// flag to mark is import from other object
			settings: {					// unique settings for the type of field
				showIcon:true/false,	// only useful in Object Workspace DataTable
				isImported: 1/0,		// flag to mark is import from other object
				required: 1/0,			// field allows does not allow NULL or it does allow NULL
				width: {int}			// width of display column

				// specific for dataField
			},
			translations:[]
  		}
  		*/

      this.object = object;

      this.fromValues(values);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///
   static get reservedNames() {
      return [
         "id",
         "created_at",
         "updated_at",
         "properties",
         "createdAt",
         "updatedAt",
      ];
   }

   static defaultValues() {
      return {};
   }

   // unique key to reference this specific DataField
   fieldKey() {
      return this.defaults.key;
   }

   /**
    * Sails ORM data types that can be imported to this DataField
    * @return {Array}
    */
   fieldOrmTypes() {
      if (this.defaults.compatibleOrmTypes) {
         if (Array.isArray(this.defaults.compatibleOrmTypes)) {
            return this.defaults.compatibleOrmTypes;
         } else {
            return [this.defaults.compatibleOrmTypes];
         }
      } else {
         return [];
      }
   }

   /**
    * Mysql data types that can be imported to this DataField
    * @return {Array}
    */
   fieldMysqlTypes() {
      if (this.defaults.compatibleMysqlTypes) {
         if (Array.isArray(this.defaults.compatibleMysqlTypes)) {
            return this.defaults.compatibleMysqlTypes;
         } else {
            return [this.defaults.compatibleMysqlTypes];
         }
      } else {
         return [];
      }
   }

   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   fieldIcon() {
      return this.defaults.icon;
   }

   // the multilingual text for the name of this data field.
   fieldMenuName() {
      return this.defaults.menuName;
   }

   // the multilingual text for the name of this data field.
   fieldDescription() {
      return this.defaults.description;
   }

   // the flag to set when checking if field should be filterable
   fieldIsFilterable() {
      if (this.defaults.isFilterable != null) {
         if (typeof this.defaults.isFilterable === "function") {
            return this.defaults.isFilterable(this);
         } else {
            return this.defaults.isFilterable;
         }
      }

      return 1;
   }

   // the flag to set when checking if field should be sortable
   fieldIsSortable() {
      if (this.defaults.isSortable != null) {
         if (typeof this.defaults.isSortable === "function") {
            return this.defaults.isSortable(this);
         } else {
            return this.defaults.isSortable;
         }
      }

      return 1;
   }

   // the flag to set when checking if the field should be used as a label
   fieldUseAsLabel() {
      if (this.defaults.useAsLabel != null) {
         if (typeof this.defaults.useAsLabel === "function") {
            return this.defaults.useAsLabel(this);
         } else {
            return this.defaults.useAsLabel;
         }
      }

      return 1;
   }

   fieldSupportRequire() {
      if (this.defaults.supportRequire) return this.defaults.supportRequire;
      // default
      else return true;
   }

   fieldSupportQuery() {
      if (this.defaults.supportQuery != null) {
         if (typeof this.defaults.supportQuery === "function") {
            return this.defaults.supportQuery(this);
         } else {
            return this.defaults.supportQuery;
         }
      }

      return true;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABField instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      return {
         id: this.id,
         type: this.type || "field",
         key: this.key,
         icon: this.icon,
         isImported: this.isImported,
         columnName: this.columnName,
         settings: this.settings,
         translations: obj.translations,
      };
   }

   defaultCheck(val, defaultVal) {
      let returnVal = defaultVal;
      if (typeof val != "undefined") {
         returnVal = val;
      }
      return returnVal;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      if (!this.id) this.id = values.id; // NOTE: only exists after .save()
      this.type == values.type || "field";
      this.key = values.key || this.fieldKey();
      this.icon = values.icon || this.fieldIcon();

      values.settings = values.settings || {};

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      this.label = values.label || values.settings.label || "?label?";

      this.columnName = values.columnName || "";

      this.isImported = values.isImported || 0;

      this.settings = values.settings;
      this.settings.showIcon = this.defaultCheck(values.settings.showIcon, "1");
      this.settings.required = this.defaultCheck(values.settings.required, "0");
      this.settings.width = this.defaultCheck(values.settings.width, "0");

      // convert from "0" => 0
      this.isImported = parseInt(this.isImported);
      this.settings.showIcon = parseInt(this.settings.showIcon);
      this.settings.required = parseInt(this.settings.required);
      this.settings.unique = parseInt(this.settings.unique || 0);
      this.settings.width = parseInt(this.settings.width);

      // we're responsible for setting up our specific settings:
      const defaultValues = this.constructor.defaultValues() || {};
      for (const dv in defaultValues) {
         this.settings[dv] = this.defaultCheck(
            values.settings[dv],
            defaultValues[dv]
         );
      }

      // const the MLClass now process the Translations
      super.fromValues(values);

      // final validity check: columnName really should have a value:
      this.columnName = this.columnName || this.label;

      // knex does not like .(dot) in table and column names
      // https://github.com/knex/knex/issues/2762
      this.columnName = this.columnName.replace(/[^a-zA-Z0-9_ ]/gi, "");
   }

   /**
    * @method urlPointer()
    * return a string pointer to decode this object from the root application
    * object.
    * @return {string} pointer reference
    */
   urlPointer() {
      return this.object.urlField() + this.id;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "";
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    */
   isValidData(data, validator) {
      // console.error('!!! Field ['+this.fieldKey()+'] has not implemented .isValidData()!!!');
      if (
         this.settings.required &&
         (data[this.columnName] == null || data[this.columnName] == "") &&
         data[this.columnName] != 0
      ) {
         validator.addError(this.columnName, "This is a required field.");
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return false;
   }

   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = "";
      if (rowData?.[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData?.[propName] != null) {
         result = rowData[propName];
      }

      return result;
   }

   /**
    * @method format
    * return display text to detail comonent and define label of object
    *
    * @param {Object} rowData - data
    */
   format(rowData) {
      if (rowData) {
         return this.dataValue(rowData);
      } else return "";
   }

   /**
    * @method toDefinition()
    *
    * convert this instance into an ABDefinition object.
    *
    * @return {ABDefinition}
    */
   toDefinition() {
      const myDef = super.toDefinition();

      // attempt to provide a more descriptive name:
      // [obj]->[fieldName]
      if (myDef.name == "") {
         myDef.name =
            myDef.json.name || myDef.json.label || myDef.json.columnName;
      }
      if (this.object && this.object.name) {
         myDef.name = `${this.object.name}->${myDef.name}`;
      }
      return myDef;
   }
};


/***/ }),

/***/ 36009:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldDateCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldDate
 *
 * An ABFieldDate defines a date field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldDateDefaults = {
   key: "date",
   // unique key to reference this specific DataField

   description: "Pick one from a calendar.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "calendar",
   // font-awesome icon reference.  (without the 'fa-').  so 'calendar'  to
   // reference 'fa-calendar'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["date"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["date"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   dateFormat: 2, // 1 (Ignore date), 2, 3, 4, 5
   defaultDate: 1, // 1 (None), 2 (Current Date), 3 (Specific Date)
   defaultDateValue: null, // {Date}
   validateCondition: "none",
   validateRangeUnit: "days",
   validateRangeBefore: 0,
   validateRangeAfter: 0,
   validateStartDate: null,
   validateEndDate: null,
};

module.exports = class ABFieldDateCore extends ABField {
   constructor(values, object, defaultValues = ABFieldDateDefaults) {
      super(values, object, defaultValues);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.dateFormat = parseInt(this.settings.dateFormat);
      this.settings.defaultDate = parseInt(this.settings.defaultDate);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      let dateResult;

      // Set current date as default
      if (this.settings.defaultDate == 2) {
         dateResult = new Date();
      }
      // Set specific date as default
      else if (
         this.settings.defaultDate == 3 &&
         this.settings.defaultDateValue
      ) {
         dateResult = new Date(this.settings.defaultDateValue);
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null) {
         values[this.columnName] = this.AB.rules.toDateFormat(dateResult, {
            format: "YYYY-MM-DD",
         });
         // values[this.columnName] = moment(dateResult).format("YYYY-MM-DD");
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (data[this.columnName]) {
         let value = data[this.columnName];

         if (!(value instanceof Date)) {
            value = this.AB.rules.toDate(value);
            // value = new Date(this.convertToMoment(value));
         }

         // verify we didn't end up with an InValid Date result.
         if (
            Object.prototype.toString.call(value) === "[object Date]" &&
            isFinite(value)
         ) {
            let isValid = true;

            // Custom vaildate is here
            if (this.settings && this.settings.validateCondition) {
               const startDate = this.settings.validateStartDate
                     ? new Date(this.settings.validateStartDate)
                     : null,
                  endDate = this.settings.validateEndDate
                     ? new Date(this.settings.validateEndDate)
                     : null,
                  startDateDisplay = this.getDateDisplay(startDate),
                  endDateDisplay = this.getDateDisplay(endDate);
               const minDate = this.AB.rules.subtractDate(
                  new Date(),
                  this.settings.validateRangeBefore,
                  this.settings.validateRangeUnit
               );
               const maxDate = this.AB.rules.addDate(
                  new Date(),
                  this.settings.validateRangeAfter,
                  this.settings.validateRangeUnit
               );
               switch (this.settings.validateCondition) {
                  case "dateRange":
                     if (minDate < value && value < maxDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              this.getDateDisplay(minDate),
                              this.getDateDisplay(maxDate),
                           ])
                        );
                     }

                     break;
                  case "between":
                     if (startDate < value && value < endDate) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "notBetween":
                     if (value < startDate && endDate < value) isValid = true;
                     else {
                        isValid = false;
                        validator.addError(
                           this.columnName,
                           L("Should not be in between {0} and {1}", [
                              startDateDisplay,
                              endDateDisplay,
                           ])
                        );
                     }
                     break;
                  case "=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() == startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<>":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() != startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should not equal {0}", [startDateDisplay])
                        );
                     break;
                  case ">":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() > startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after {0}", [startDateDisplay])
                        );
                     break;
                  case "<":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() < startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before {0}", [startDateDisplay])
                        );
                     break;
                  case ">=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() >= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should after or equal {0}", [startDateDisplay])
                        );
                     break;
                  case "<=":
                     isValid =
                        value.getTime &&
                        startDate.getTime &&
                        value.getTime() <= startDate.getTime();
                     if (!isValid)
                        validator.addError(
                           this.columnName,
                           L("Should before or equal {0}", [startDateDisplay])
                        );
                     break;
               }
            }

            if (isValid) {
               // Reformat value to DB
               // NOTE: should we update here?
               data[this.columnName] = this.exportValue(value);
            }
         } else {
            // return a validation error
            validator.addError(this.columnName, "Should be a Date!");
         }
      }
   }

   format(rowData) {
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }

      // pull format from settings.
      const dateObj = this.AB.rules.toDate(d);
      return this.getDateDisplay(dateObj);

      // const momentObj = this.convertToMoment(d);
      // return this.getDateDisplay(new Date(momentObj));
   }

   getFormat() {
      let dateFormatString = "";

      const dateFormat =
         this.settings && this.settings.dateFormat
            ? this.settings.dateFormat
            : "";

      switch (dateFormat) {
         //Ignore Date
         case (1, 2):
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
         //mm/dd/yyyy
         case 3:
            {
               dateFormatString = "%m/%d/%Y";
            }
            break;
         //M D, yyyy
         case 4:
            {
               dateFormatString = "%M %d, %Y";
            }
            break;
         //D M, yyyy
         case 5:
            {
               dateFormatString = "%d %M, %Y";
            }
            break;
         default:
            {
               dateFormatString = "%d/%m/%Y";
            }
            break;
      }

      return dateFormatString;
   }

   getDateDisplay(dateData) {
      const dateFormat = this.getFormat();

      return this.dateToString(dateFormat, dateData);
   }

   // convertToMoment(string) {
   //    const result = moment(string);

   //    const supportFormats = [
   //       "DD/MM/YYYY",
   //       "MM/DD/YYYY",
   //       "DD-MM-YYYY",
   //       "MM-DD-YYYY"
   //    ];

   //    supportFormats.forEach((format) => {
   //       if (!result || !result.isValid()) result = moment(string, format);
   //    });

   //    return result;
   // }

   exportValue(value) {
      return value
         ? this.AB.rules.toDateFormat(value, {
              format: "YYYY-MM-DD",
           })
         : "";
      // return this.convertToMoment(value).format("YYYY-MM-DD");
   }

   dateToString(dateFormat, dateData) {
      if (dateData && dateData.toString) return dateData.toString();
      else return "";
   }
};

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
module.exports.RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2}$";


/***/ }),

/***/ 32965:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldDateTimeCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldDateTime
 *
 * An ABFieldDateTime defines a datetime field type.
 *
 */

const ABFieldDateCore = __webpack_require__(/*! ./ABFieldDateCore */ 36009);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldDateDefaults = {
   key: "datetime",
   // unique key to reference this specific DataField

   description: "Pick one from date & time.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "clock-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'clock-o'  to
   // reference 'clock-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Date & Time",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["datetime"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["datetime"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   timeFormat: 2, // 1 (Ignore time), 2, 3
   defaultTime: 1, // 1 (None), 2 (Current Time), 3 (Specific Time)
   defaultTimeValue: null, // {Date}
};

module.exports = class ABFieldDateTimeCore extends ABFieldDateCore {
   constructor(values, object) {
      super(values, object, ABFieldDateDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldDateDefaults;
   }

   static defaultValues() {
      const baseDefault = super.defaultValues();
      return Object.assign(baseDefault, defaultValues);
   }

   // TODO: current webpack install fails here without babel-loader,
   // so swtich this to old JS method of Static Values (see bottom)
   // static RegEx = "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.timeFormat = parseInt(this.settings.timeFormat);
      this.settings.defaultTime = parseInt(this.settings.defaultTime);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] != null) return;

      super.defaultValue(values);

      let dateResult;

      // From default value of ABFieldDateCore
      if (values[this.columnName]) {
         dateResult = this.AB.rules.toDate(values[this.columnName]);
         // const momentVal = this.convertToMoment(values[this.columnName]);
         // if (momentVal.isValid()) {
         //    dateResult = new Date(momentVal);
         // }
      }

      // Set current time as default
      if (this.settings.defaultTime == 2) {
         const currDate = new Date();

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(currDate.getHours());
         dateResult.setMinutes(currDate.getMinutes());
         dateResult.setSeconds(currDate.getSeconds());
         dateResult.setMilliseconds(currDate.getMilliseconds());
      }
      // Set specific time as default
      else if (
         this.settings.defaultTime == 3 &&
         this.settings.defaultTimeValue
      ) {
         const defaultTime = new Date(this.settings.defaultTimeValue);

         if (dateResult == null) dateResult = new Date();

         dateResult.setHours(defaultTime.getHours());
         dateResult.setMinutes(defaultTime.getMinutes());
         dateResult.setSeconds(defaultTime.getSeconds());
         dateResult.setMilliseconds(defaultTime.getMilliseconds());
      }

      // if no default value is set, then don't insert a value.
      if (dateResult != null)
         values[this.columnName] = dateResult.toISOString();
   }

   getFormat() {
      const timeFormat = this.getTimeFormat();

      this.settings = this.settings || {};

      if (this.settings.dateFormat == 1) {
         return timeFormat;
      }

      const dateFormat = super.getFormat();

      return `${dateFormat} ${timeFormat}`;
   }

   format(rowData) {
      const datetimeFormat = this.getFormat();
      const d = this.dataValue(rowData);
      const dateObj = this.AB.rules.toDate(d);

      if (d == "" || d == null) {
         return "";
      }

      return webix.Date.dateToStr(datetimeFormat)(dateObj);
   }

   getTimeFormat() {
      this.settings = this.settings || {};
      switch (this.settings.timeFormat) {
         case 2:
            return " %h:%i %A";
         case 3:
            return " %H:%i";
         default:
            return "";
      }
   }

   /**
    * @method exportValue
    * @param {Date} date
    * @return {string}
    */
   exportValue(date) {
      return date?.toISOString?.() ?? "";
   }
};

// Transition Code:
// revert to static RegEx once babel-loader is working locally.
module.exports.RegEx =
   "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$";


/***/ }),

/***/ 95905:
/*!********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldEmailCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldEmail
 *
 * An ABFieldEmail defines a boolean field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldEmailDefaults = {
   key: "email",
   // unique key to reference this specific DataField

   description: "Email fields are used to store email addresses.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "envelope",
   // font-awesome icon reference.  (without the 'fa-').  so 'envelope'  to
   // reference 'fa-envelope'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Email",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   default: "",
   defaultCheckbox: 0,
};

module.exports = class ABFieldEmailCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldEmailDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldEmailDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            values[this.columnName] = this.settings.default;
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      if (data[this.columnName]) {
         const Reg =
            /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

         let value = data[this.columnName];
         value = String(value).toLowerCase();
         if (!Reg.test(value)) {
            validator.addError(this.columnName, "Invalid email");
         }
      }
   }
};


/***/ }),

/***/ 34921:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldFileCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldFile
 *
 * An ABFieldFile defines a File field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldFileDefaults = {
   key: "file",
   // unique key to reference this specific DataField

   description: "Attach a File to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file",
   // font-awesome icon reference.  (without the 'fa-').  so 'file'  to
   // reference 'fa-file'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "File Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   removeExistingData: 0,
   fileSize: 0,
   fileType: "",
};

module.exports = class ABFieldFileCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldFileDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFileDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.fileSize = parseInt(this.settings.fileSize);
      this.settings.limitFileSize = parseInt(this.settings.limitFileSize);
      this.settings.limitFileType = parseInt(this.settings.limitFileType);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method dataValue
    * return the file data stored as part of this field.
    *
    * An ABFieldFile column contains a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * This will return the json object.
    * @param {obj} values a key=>value hash of the current values.
    * @return {obj} { uuid, filename }, or {} if empty.
    */
   dataValue(rowData) {
      const propName = `${this.alias || this.object.name}.${this.columnName}`;

      let result = rowData[this.columnName] || rowData[propName] || {};
      if (typeof result == "string") {
         try {
            result = JSON.parse(result);
         } catch (err) {
            // ignore error
         }
      }

      return result;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    *
    * An ABFieldFile expects a json structure that contains
    *  .uuid : {string} a file uuid reference
    *  .filename : {string} the name of the file that was uploaded.
    *
    * For a default value, we return an empty json object: "{}"
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      values[this.columnName] = "{}";
   }

   format(rowData) {
      let result = this.dataValue(rowData);
      if (result) {
         if (typeof result == "string") {
            try {
               result = JSON.parse(result);
            } catch (err) {
               // ignore error.
            }
         }

         // return file name
         return result ? result.filename || "" : "";
      } else {
         return "";
      }
   }

   /**
    * @method requestParam
    * return the entry in the given input that relates to this field.
    * @param {obj} allParameters  a key=>value hash of the inputs to parse.
    * @return {obj} or undefined
    */
   requestParam(allParameters) {
      const myParameter = super.requestParam(allParameters);

      // if we have our default empty object, then remove the entry
      // and let the DB insert a null value.
      let val = myParameter?.[this.columnName];
      if (val == "{}" || val == "") {
         delete myParameter[this.columnName];
      }
      if ("string" === typeof val) {
         try {
            myParameter[this.columnName] = JSON.parse(val);
         } catch (e) {
            /* ignore */
         }
      }

      return myParameter;
   }
};


/***/ }),

/***/ 75193:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldFormulaCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldFormula
 *
 * An ABFieldFormula are used to run calculations on connected (child) records
 * and store the total of that calculation in the parent.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const ABFieldFormulaDefaults = {
   key: "formula",
   // unique key to reference this specific DataField

   description:
      "Perform a calculation by a formula type based upon existing values",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "circle-o-notch",
   // font-awesome icon reference.  (without the 'fa-').  so 'circle-o-notch'  to
   // reference 'fa-circle-o-notch'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportQuery: (field) => {
      const fieldLink = field.fieldLink;
      if (fieldLink == null) return false;

      // Not support calculate field in query
      return fieldLink.key !== "calculate";
   },

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   field: "", // id of ABField : NOTE - store our connect field to support when there are multi - linked columns
   objectLink: "", // id of ABObject
   fieldLink: "", // id of ABField
   type: "sum", // "sum", "average", "max", "min", "count"
   where: "",
};

module.exports = class ABFieldFormulaCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldFormulaDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // this field is read only
      delete values[this.columnName];
   }

   /**
    * @method format
    * both calculate and format the data input based of user settings
    * for this field.
    * @param {obj} rowData
    *        a key=>value hash of the current values.
    * @param {boolean} reCalculate
    *        a boolean that signals if we should force recalculation of values
    */
   format(rowData, reCalculate = false, isGrouped = false) {
      const fieldLink = this.fieldLink;

      const reformat = (numData) => {
         // ABFieldCalculate does not need to .format again
         if (!fieldLink || fieldLink.key == "calculate") {
            return numData;
         } else {
            const rowDataFormat = {};
            rowDataFormat[fieldLink.columnName] = numData;
            return fieldLink.format(rowDataFormat);
         }
      };

      // if data exists, then will not calculate on client side
      // unless we pass reCalculate=true to force the recalculation
      if (rowData[this.columnName] != null && !reCalculate && !isGrouped) {
         // reformat data
         return reformat(rowData[this.columnName]);
      } else if (
         rowData[this.columnName] != null &&
         !reCalculate &&
         isGrouped
      ) {
         return rowData[this.columnName];
      }

      if (!fieldLink) return 0;

      const fieldBase = this.fieldBase();
      if (!fieldBase) return 0;

      let data =
         rowData[fieldBase.relationName()] ||
         rowData[fieldBase.columnName] ||
         [];
      if (!Array.isArray(data)) data = [data];

      // Filter
      if (
         data &&
         data.length &&
         this.settings &&
         this.settings.where &&
         this.settings.where.rules &&
         this.settings.where.rules.length
      ) {
         this.filterHelper.setValue(this.settings.where);
         data = data.filter((item) => this.filterHelper.isValid(item));
      }

      let numberList = [];

      // pull number from data
      switch (fieldLink.key) {
         case "calculate":
            data.forEach((d) => {
               numberList.push(parseFloat(fieldLink.format(d) || 0));
            });
            break;
         case "number":
            numberList = data.map((d) => d[fieldLink.columnName] || 0);
            break;
      }

      let result = 0;

      // get the decimal size of the numbers being calculated
      const decimalSize = fieldLink.getDecimalSize();

      // calculate
      switch (this.settings.type) {
         case "sum":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               result = sum / multiplier;
            }
            break;

         case "average":
            if (numberList.length > 0) {
               // get power of 10 to the number of decimal places this number
               // is formated to require
               const multiplier = Math.pow(10, decimalSize);
               // multiply values by muliplyier and add them to pervious value
               // because in javascript adding number with decimals can cause issues
               // ex: 9.11 + 222.11 = 231.22000000000003
               let sum = 0;
               numberList.forEach((val) => {
                  sum += val * multiplier || 0;
               });
               // divide result by multiplier to get actual value
               // and divide by length to get the average
               result = sum / multiplier / numberList.length;
            }
            break;

         case "max":
            result = Math.max(...numberList) || 0;
            break;
         case "min":
            result = Math.min(...numberList) || 0;
            break;
         case "count":
            result = numberList.length;
            break;
      }

      rowData[this.columnName] = result;

      // ABFieldCalculate does not need to .format again
      if (fieldLink.key == "calculate") {
         return result;
      } else {
         return reformat(result);
      }
   }

   fieldBase() {
      return this.object.fieldByID(this.settings.field);
   }

   get fieldLink() {
      const obj = this.AB.objectByID(this.settings.object);
      if (!obj) return null;

      const field = obj.fieldByID(this.settings.fieldLink);
      if (!field) return null;

      return field;
   }

   get filterHelper() {
      if (this._rowFilter == null) {
         this._rowFilter = this.AB.filterComplexNew(`${this.id}_filterComplex`);

         if (this.fieldLink && this.fieldLink.object) {
            this._rowFilter.fieldsLoad(this.fieldLink.object.fields());
            this._rowFilter.setValue(this.settings.where);
         }
      }

      return this._rowFilter;
   }
};


/***/ }),

/***/ 93355:
/*!********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldImageCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldImageCore
 *
 * An ABFieldImage defines a Image field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const ABFieldImageDefaults = {
   key: "image",
   // unique key to reference this specific DataField

   description: "Attach an image to this object.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "file-image-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'file-image-o'  to
   // reference 'fa-file-image-o'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Image Attachment",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   useWidth: 0,
   imageWidth: "",
   useHeight: 0,
   imageHeight: "",
   removeExistingData: 0,
   useDefaultImage: false,
   defaultImageUrl: "",
};

module.exports = class ABFieldImageCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldImageDefaults);

      // NOTE: our Labels are ready here:
      // if (
      //    ABFieldImageDefaults.menuName == "*Image Attachment" &&
      //    this.AB.Label
      // ) {
      //    const L = this.AB.Label();
      //    ABFieldImageDefaults.menuName = L("Image Attachment");
      //    ABFieldImageDefaults.description = L("Attach an image to this object.");
      // }

      /*
    	{
			settings: {
				'useWidth':0,
				'imageWidth':'',
				'useHeight': 0,
				'imageHeight': '',
				'removeExistingData': 0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldImageDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      this.settings.useWidth = parseInt(this.settings.useWidth);
      this.settings.useHeight = parseInt(this.settings.useHeight);
      this.settings.imageWidth = parseInt(this.settings.imageWidth);
      this.settings.imageHeight = parseInt(this.settings.imageHeight);
      this.settings.useDefaultImage = parseInt(this.settings.useDefaultImage);
      this.settings.removeExistingData = parseInt(
         this.settings.removeExistingData
      );
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
};


/***/ }),

/***/ 97972:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldJsonCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldJson
 *
 * An ABFieldJson defines a JSON field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const ABFieldJsonDefaults = {
   key: "json",
   // unique key to reference this specific DataField

   description: "JSON value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "JSON",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["json"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["json"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {};

module.exports = class ABFieldJsonCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldJsonDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldJsonDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // in the case of a JSON data type, we should NOT insert a ""
      //
      // values[this.columnName] = "";
   }
};


/***/ }),

/***/ 86430:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldListCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldListCore
 *
 * An ABFieldList defines a select list field type.
 *
 */

// const ABFieldSelectivity = require("../../platform/dataFields/ABFieldSelectivity");
const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldListDefaults = {
   key: "list",
   // unique key to reference this specific DataField

   description:
      "Select list allows you to select predefined options below from a dropdown.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "th-list",
   // font-awesome icon reference.  (without the 'fa-').  so 'th-list'  to
   // reference 'fa-th-list'

   isFilterable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Select list",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "char",
      "varchar",
      "tinytext" /* "text", "mediumtext" */,
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   hasColors: (field) => {
      if (field.settings.hasColors) {
         return true;
      } else {
         return false;
      }
   },
};

const defaultValues = {
   isMultiple: 0,
   // {bool}
   // can multiple values be selected?

   hasColors: 0,
   // {bool}
   // are we to display our values in colors?

   options: [],
   // {array}
   // The options defined for this list:
   // [ { id, text, hex, translations },...]
   //    .id {string} a unique id for this value
   //    .text {string} the displayed text of this value
   //    .hex {string} a color hex definition for this value
   //    .translations {obj} the multilingual definitions for this value.

   default: "none",
   multipleDefault: [],
};

module.exports = class ABFieldListCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldListDefaults);

      this.pendingDeletions = [];
      // {array}
      // a list of pending option deletions that need to be processed
      // when this is saved.
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldListDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }

      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.hasColors = parseInt(this.settings.hasColors);
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      obj.settings.options.forEach((opt) => {
         this.unTranslate(opt, opt, ["text"]);
      });

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // Multiple select list
      if (this.settings.isMultiple == true) {
         let defaultVals = [];
         this.settings.multipleDefault.forEach((def) => {
            this.settings.options.forEach((opt) => {
               if (opt.id == def.text) {
                  defaultVals.push(opt);
               }
            });
         });
         values[this.columnName] = defaultVals || [];
      }
      // Single select list
      else if (this.settings.default && this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }

   /**
    * @method options
    * Return an array of [{ id, text }] options defined by this field.
    * @return {array}
    */
   options() {
      return this.settings.options.map((opt) => {
         return {
            id: opt.id,
            text: opt.text,
            hex: opt.hex ? opt.hex : "",
            translations: opt.translations ? opt.translations : "",
         };
      });
   }

   format(rowData, options = {}) {
      let val = this.dataValue(rowData) || [];

      if (typeof val == "string") {
         try {
            val = JSON.parse(val);
         } catch (e) {
            // continue regardless of error
         }
      }

      // Convert to array
      if (!Array.isArray(val)) val = [val];

      const displayOpts = this.settings.options
         .filter((opt) => val.filter((v) => (v.id || v) == opt.id).length > 0)
         .map((opt) => {
            let text = opt.text;
            const languageCode = options.languageCode || "en";

            // Pull text of option with specify language code
            const optTran = (opt.translations || []).filter(
               (o) => o.language_code == languageCode
            )[0];
            if (optTran) text = optTran.text;

            return text;
         });

      return displayOpts.join(", ");
   }
};


/***/ }),

/***/ 81213:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldLongTextCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldLongText
 *
 * An ABFieldLongText defines a LongText field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const MAX_CHAR_LENGTH = 5000;

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldLongTextDefaults = {
   key: "LongText", // unique key to reference this specific DataField

   description: "Multiple lines of text",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "align-right",
   // font-awesome icon reference.  (without the 'fa-').  so 'align-right'  to
   // reference 'fa-align-right'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Long text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["longtext", "mediumtext", "text"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldLongText can be.
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

module.exports = class ABFieldLongText extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldLongTextDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
    	*/
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldLongTextDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.default = values.settings.default || "";

      // we're responsible for setting up our specific settings:
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         if (this.object)
            this.object.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual)
         if (this.object)
            this.object.unTranslate(obj.settings, obj.settings, ["default"]);
         else obj.settings.default = this.settings.default;

      return obj;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (values[this.columnName] == null) {
         if (typeof this.settings.default == "string") {
            values[this.columnName] = this.settings.default;
         } else {
            values[this.columnName] = "";
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (
         data &&
         data[this.columnName] &&
         data[this.columnName].length > MAX_CHAR_LENGTH
      ) {
         validator.addError(
            this.columnName,
            `should NOT be longer than ${MAX_CHAR_LENGTH} characters`
         );
      }
   }
};


/***/ }),

/***/ 42686:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldNumberCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldNumber
 *
 * An ABFieldNumber defines a Number field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const ABFieldNumberDefaults = {
   key: "number",
   // unique key to reference this specific DataField

   description: "A Float or Integer Value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "hashtag",
   // font-awesome icon reference.  (without the 'fa-').  so 'hashtag'  to
   // reference 'fa-hashtag'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Number",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: true,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["number"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: [
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "integer",
      "bigint",
      "decimal",
      "dec",
      "numeric",
      "fixed",
      "float",
      "real",
   ],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   // 'allowRequired': 0,
   default: "",
   typeFormat: "none",
   typeDecimals: "none",
   typeDecimalPlaces: 0,
   typeRounding: "none",
   typeThousands: "none",
   validation: 0,
   validateMinimum: "",
   validateMaximum: "",
};

let L = null; //AB.Label();

module.exports = class ABFieldNumberCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldNumberDefaults);

      /*
    	{
			settings: {
				'allowRequired':0,
				'default':null,
				'typeFormat': 'none',
				'typeDecimals': 'none',
				'typeDecimalPlaces': 'none',
				'typeRounding' : 'none',
				'typeThousands': 'none',
				'validation':0,
				'validateMinimum':null,
				'validateMaximum':null
			}
    	}
    	*/
      if (!L) {
         L = this.AB.Label();
      }
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldNumberDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static formatList(iL) {
      if (iL && !L) L = iL;
      return [
         { id: "none", value: L("None") },
         {
            id: "dollar",
            value: L("$"),
            sign: "$",
            position: "prefix",
         },
         {
            id: "yen",
            value: L("¥"),
            sign: "¥",
            position: "prefix",
         },
         {
            id: "pound",
            value: L("£"),
            sign: "£",
            position: "prefix",
         },
         {
            id: "euroBefore",
            value: L("€ (before)"),
            sign: "€",
            position: "prefix",
         },
         {
            id: "euroAfter",
            value: L("€ (after)"),
            sign: "€",
            position: "postfix",
         },
         {
            id: "percent",
            value: L("%"),
            sign: "%",
            position: "postfix",
         },
      ];
   }

   static delimiterList() {
      return [
         { id: "none", value: L("None") },
         {
            id: "comma",
            value: L("Comma"),
            sign: ",",
         },
         {
            id: "period",
            value: L("Period"),
            sign: ".",
         },
         {
            id: "space",
            value: L("Space"),
            sign: " ",
         },
      ];
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      // text to Int:
      // this.settings.allowRequired = parseInt(this.settings.allowRequired);
      this.settings.validation = parseInt(this.settings.validation);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (this.settings.default != "") {
         values[this.columnName] = this.settings.default;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      // const L = this.AB.Label();

      if (data[this.columnName] != null && data[this.columnName] != "") {
         let value = data[this.columnName];

         // if this is an integer:
         if (this.settings.typeDecimals == "none") {
            value = parseInt(value);
         } else {
            const places = parseInt(this.settings.typeDecimalPlaces) || 2;
            value = parseFloat(parseFloat(value).toFixed(places));
         }

         const isNumeric = (n) => {
            return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
         };
         if (!isNumeric(value)) {
            validator.addError(this.columnName, L("invalid number"));
         }

         // validate Minimum
         if (
            this.settings.validation == true &&
            this.settings.validateMinimum != null &&
            this.settings.validateMinimum > value
         ) {
            const errMessage = L("should be greater than {0}", [
               this.settings.validateMinimum,
            ]);

            validator.addError(this.columnName, errMessage);
         }

         // validate Maximum
         if (
            this.settings.validation == true &&
            this.settings.validateMaximum != null &&
            this.settings.validateMaximum < value
         ) {
            const errMessage = L("should be less than {0}", [
               this.settings.validateMaximum,
            ]);

            validator.addError(this.columnName, errMessage);
         }
      }
   }

   format(rowData) {
      if (
         rowData?.[this.columnName] == null ||
         (rowData[this.columnName] != 0 && rowData[this.columnName] == "")
      )
         return "";

      let data = rowData[this.columnName] || 0;

      if (typeof data == "string") {
         data = data.replace(/,/g, "");
      }

      // Validate number
      if (isNaN(parseFloat(data))) data = 0;

      const formatSign = this.constructor
         .formatList()
         .filter((item) => item.id == this.settings.typeFormat)[0];
      const decimalPlaces =
         this.settings.typeDecimalPlaces != "none"
            ? parseInt(this.settings.typeDecimalPlaces)
            : 0;

      let thousandsSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeThousands)[0];
      let decimalSign = this.constructor
         .delimiterList()
         .filter((item) => item.id == this.settings.typeDecimals)[0];
      let prefix = "";
      let postfix = "";

      if (formatSign && formatSign.sign) {
         switch (formatSign.position) {
            case "prefix":
               prefix = formatSign.sign;
               break;
            case "postfix":
               postfix = formatSign.sign;
               break;
         }
      }

      decimalSign = decimalSign.sign || "";
      thousandsSign = thousandsSign.sign || "";

      // round number
      if (this.settings.typeRounding == "roundDown") {
         const digit = Math.pow(10, decimalPlaces);
         data = Math.floor(data * digit) / digit;
      }

      const number = this.formatNumber(data, {
         groupDelimiter: thousandsSign,
         groupSize: 3,
         decimalDelimiter: decimalSign,
         decimalSize: decimalPlaces,
      });

      return `${prefix} ${number} ${postfix}`;
   }

   formatNumber(data, options = {}) {
      if (data === "" || data == null) return data;

      data = parseFloat(data);
      const negativeSign = data < 0 ? "-" : "";
      data = Math.abs(data);

      const dataStr = data.toString();
      const integerStr = dataStr.split(".")[0];
      const decimalStr = dataStr.split(".")[1];

      let integerValue = "";

      // Thousands digit sign
      if (options.groupDelimiter) {
         const step = 3;
         let i = integerStr.length;

         do {
            i -= step;
            const chunk =
               i > 0
                  ? integerStr.substr(i, step)
                  : integerStr.substr(0, step + i);
            integerValue = `${chunk}${
               integerValue ? options.groupDelimiter + integerValue : ""
            }`;
         } while (i > 0);
      } else {
         integerValue = integerStr;
      }

      // Integer
      let result = `${negativeSign}${integerValue}`;

      // Decimal
      if (decimalStr && options.decimalDelimiter && options.decimalSize) {
         const decimalVal = data.toFixed(options.decimalSize).split(".")[1];
         result += `${options.decimalDelimiter}${decimalVal}`;
      }

      return result;
   }

   getDecimalSize() {
      if (this.settings.typeDecimalPlaces != "none") {
         return parseInt(this.settings.typeDecimalPlaces);
      } else {
         return 0;
      }
   }
};


/***/ }),

/***/ 5254:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldStringCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldString
 *
 * An ABFieldString defines a string field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

const MAX_CHAR_LENGTH = 255;

const ABFieldStringDefaults = {
   key: "string",
   // unique key to reference this specific DataField

   description: "short string value",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "font",
   // font-awesome icon reference.  (without the 'fa-').  so 'font'  to
   // reference 'fa-font'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Single line text",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: true,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   MAX_CHAR_LENGTH,
   // {integer}
   // The maximum length our ABFieldString can be.
};

const defaultValues = {
   default: "",
   supportMultilingual: 0,
};

module.exports = class ABFieldStringCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldStringDefaults);

      /*
    	{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
    	}
        */
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldStringDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // we're responsible for setting up our specific settings:
      this.settings.default = values.settings.default || defaultValues.default;
      this.settings.supportMultilingual =
         values.settings.supportMultilingual + "" ||
         defaultValues.supportMultilingual;

      // text to Int:
      this.settings.supportMultilingual = parseInt(
         this.settings.supportMultilingual
      );

      if (this.settings.supportMultilingual) {
         this.translate(this.settings, this.settings, ["default"]);
      } else this.settings.default = values.settings.default || "";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      if (this.settings.supportMultilingual) {
         this.unTranslate(obj.settings, obj.settings, ["default"]);
      } else obj.settings.default = this.settings.default;

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);

      if (data?.[this.columnName]?.length > MAX_CHAR_LENGTH) {
         const L = this.AB.Label();
         validator.addError(
            this.columnName,
            L("should NOT be longer than {0} characters", [MAX_CHAR_LENGTH])
         );
      }
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      return this.settings.supportMultilingual == 1;
   }
};


/***/ }),

/***/ 35756:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldTextFormulaCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldTextFormula
 *
 * An ABFieldTextFormula defines a TextFormula field type.
 *
 */

const ABField = __webpack_require__(/*! ../../platform/dataFields/ABField */ 34117);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldTextFormulaDefaults = {
   key: "TextFormula",
   // unique key to reference this specific DataField

   description: "Text Formula",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "question",
   // font-awesome icon reference.  (without the 'fa-').  so 'question'  to
   // reference 'fa-question'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Text Formula",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

// defaultValues: the keys must match a .name of your elements to set it's default value.
const defaultValues = {
   textFormula: "",
   // {string} "some text or text with formula ..."
   // This tells us what the formula we need to do with text included text string.
   // if we don't have this, the old value which we filled out won't be cleared when we do "Add field" this type again.

   // 'imageWidth':'',
   // 'useHeight': 0,
   // 'imageHeight': ''
};

/** Private methods */

/**
 * @method setValueToFormula
 *
 * @param {ABOBject} object
 * @param {string} formulaString
 * @param {object} rowData
 */

function setValueToFormula(object, formulaString, rowData) {
   if (!formulaString) return;

   const fieldRegExp = /{[^{}]+}/gm;
   const matches_field_array = formulaString.match(fieldRegExp);
   matches_field_array.forEach((element) => {
      const columnName = element.replace(/{|}|"/g, "");
      object.fields().forEach((field) => {
         if (field.columnName == columnName) {
            if (field.key == "AutoIndex") {
               //Check AutoIndex Field
               const autoIndexVal = field.format(rowData) || 0;
               formulaString = formulaString.replace(element, autoIndexVal);
            } else if (field.key == "calculate") {
               //Calculate Field
               const calVal = `(${field.format(rowData) || 0})`;
               formulaString = formulaString.replace(element, eval(calVal));
            } else if (field.key == "date") {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName]
                     ? field.exportValue(rowData[columnName])
                     : ""
               );
            } else {
               formulaString = formulaString.replace(
                  element,
                  rowData[columnName] ? field.format(rowData) : ""
               );
            }
         }
      });
   });

   return formulaString;
}

/**
 * @method setBuildinValueToFormula
 *
 * @param {ABFactory} AB
 * @param {string} formulaString
 */

function setBuildinValueToFormula(AB, formulaString) {
   const buildInRegExp = /\w+\(.*?\)/gm;
   const matches_buildin_array = formulaString.match(buildInRegExp);
   if (matches_buildin_array) {
      const buildinList = getBuildInFunction();
      matches_buildin_array.forEach((element) => {
         const formula_array = element.split(/\(|\)/);
         const isBracketInBracket =
            formula_array.length > 2 && formula_array[2] != "";
         const functionName = formula_array[0];
         const parameters_array = formula_array[1].split(",");
         let isMatch = false;
         for (let i = 0; i < buildinList.length; i++) {
            let resultParameters = element;
            if (functionName == buildinList[i].id) {
               if (parameters_array.length == buildinList[i].parameter_size) {
                  switch (functionName) {
                     case "left":
                        resultParameters = getLeft(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "right":
                        resultParameters = getRight(
                           parameters_array[0],
                           parameters_array[1]
                        );
                        break;
                     case "mid":
                        resultParameters = getMid(
                           parameters_array[0],
                           parameters_array[1],
                           parameters_array[2]
                        );
                        break;
                     case "trim":
                        resultParameters = getTrim(parameters_array[0]);
                        break;
                     case "trimLeft":
                        resultParameters = getTrimLeft(parameters_array[0]);
                        break;
                     case "trimRight":
                        resultParameters = getTrimRight(parameters_array[0]);
                        break;
                     case "length":
                        resultParameters = getLength(parameters_array[0]);
                        break;
                     case "regexReplace":
                        resultParameters = getRegExpReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "extractRegex":
                        resultParameters = getExtractRegex(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     case "replace":
                        resultParameters = getReplace(
                           parameters_array[0],
                           parameters_array[1].trimLeft(),
                           parameters_array[2].trimLeft()
                        );
                        break;
                     case "lower":
                        resultParameters = getLower(parameters_array[0]);
                        break;
                     case "upper":
                        resultParameters = getUpper(parameters_array[0]);
                        break;
                     case "capitalize":
                        resultParameters = getCapitalize(parameters_array[0]);
                        break;
                     case "random":
                        resultParameters = getRandom(parameters_array[0]);
                        break;
                     case "numberToWords":
                        resultParameters = getNumberToWords(
                           parameters_array[0]
                        );
                        break;
                     case "getDateDayOfWeekName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateDayOfWeekName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "getDateMonthOfYearName":
                        if (isBracketInBracket) {
                           element = element + ")";
                        }
                        resultParameters = getDateMonthOfYearName(
                           AB,
                           parameters_array[0]
                        );
                        break;
                     case "formatDate":
                        resultParameters = getFormatDate(
                           parameters_array[0],
                           parameters_array[1].trimLeft()
                        );
                        break;
                     default:
                        break;
                  }
                  isMatch = true;
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
                  return;
               } else {
                  resultParameters = functionName + "(Bad Parameter)";
                  formulaString = formulaString.replace(
                     element,
                     resultParameters
                  );
               }
            }
         }
      });
   }
   return formulaString;
}

function getBuildInFunction() {
   const functionList = [
      {
         id: "left",
         value: "left({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "right",
         value: "right({COLUMN_NAME}, 1)",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "mid",
         value: "mid({COLUMN_NAME}, 1, 1)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "trim",
         value: "trim({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimLeft",
         value: "trimLeft({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "trimRight",
         value: "trimRight({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "length",
         value: "length({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "regexReplace",
         value: "regexReplace({COLUMN_NAME}, [*], REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "extractRegex",
         value: "extractRegex({COLUMN_NAME}, [*])",
         type: "build-in",
         parameter_size: 2,
      },
      {
         id: "replace",
         value: "replace({COLUMN_NAME}, SEARCH_VALUE, REPLACE_VALUE)",
         type: "build-in",
         parameter_size: 3,
      },
      {
         id: "lower",
         value: "lower({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "upper",
         value: "upper({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "capitalize",
         value: "capitalize({COLUMN_NAME})",
         type: "build-in",
         parameter_size: 1,
      },
      { id: "random", value: "random(1)", type: "build-in", parameter_size: 1 },
      {
         id: "numberToWords",
         value: "numberToWords({NUMBER_COLUMN} or 012...)",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateDayOfWeekName",
         value: "getDateDayOfWeekName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "getDateMonthOfYearName",
         value: "getDateMonthOfYearName({DATE_COLUMN})",
         type: "build-in",
         parameter_size: 1,
      },
      {
         id: "formatDate",
         value: "formatDate({DATE_COLUMN}, OUTPUT_FORMAT)",
         type: "build-in",
         parameter_size: 2,
      },
   ];
   return functionList;
}

function getLeft(string, endPosition) {
   return string.substring(0, parseInt(endPosition));
}

function getRight(string, endposition) {
   const reverseStr = reverseString(string).substring(0, parseInt(endposition));
   return reverseString(reverseStr);
}

function reverseString(string) {
   return string.split(" ").reverse().join(" ");
}

function getMid(string, startPosition, length) {
   if (string.length < startPosition) return "mid(Bad Parameter)";
   return string.substring(
      parseInt(startPosition),
      parseInt(startPosition) + parseInt(length)
   );
}

function getTrim(string) {
   return string.trim();
}

function getTrimLeft(string) {
   return string.trimLeft();
}

function getTrimRight(string) {
   return string.trimRight();
}

function getLength(string) {
   return string.length;
}

function getRegExpReplace(string, regexp, replaceString) {
   return string.replace(regexp, replaceString);
}

function getExtractRegex(string, regexp) {
   const extractResult = string.match(regexp);
   if (Array.isArray(extractResult)) {
      return extractResult[0];
   }
   return extractResult;
}

function getReplace(string, searchValue, replaceValue) {
   return string.replace(searchValue, replaceValue);
}

function getLower(string) {
   return string.toLowerCase();
}

function getUpper(string) {
   return string.toUpperCase();
}

function getCapitalize(string) {
   return string
      .toLowerCase()
      .split(" ")
      .map((s) => s.charAt(0).toUpperCase() + s.substring(1))
      .join(" ");
}

function getRandom(max) {
   return Math.floor(Math.random() * (max + 1));
}

function getNumberToWords(number) {
   const string = number.trim(",").toString();

   let units,
      tens,
      scales,
      start,
      end,
      chunks,
      chunksLen,
      chunk,
      ints,
      i,
      word,
      words;

   const and = "";

   /* Is number zero? */
   if (parseInt(string) === 0) {
      return "zero";
   }

   /* Array of units as words */
   units = [
      "",
      "one",
      "two",
      "three",
      "four",
      "five",
      "six",
      "seven",
      "eight",
      "nine",
      "ten",
      "eleven",
      "twelve",
      "thirteen",
      "fourteen",
      "fifteen",
      "sixteen",
      "seventeen",
      "eighteen",
      "nineteen",
   ];

   /* Array of tens as words */
   tens = [
      "",
      "",
      "twenty",
      "thirty",
      "forty",
      "fifty",
      "sixty",
      "seventy",
      "eighty",
      "ninety",
   ];

   /* Array of scales as words */
   scales = [
      "",
      "thousand",
      "million",
      "billion",
      "trillion",
      "quadrillion",
      "quintillion",
      "sextillion",
      "septillion",
      "octillion",
      "nonillion",
      "decillion",
      "undecillion",
      "duodecillion",
      "tredecillion",
      "quatttuor-decillion",
      "quindecillion",
      "sexdecillion",
      "septen-decillion",
      "octodecillion",
      "novemdecillion",
      "vigintillion",
      "centillion",
   ];

   /* Split user arguemnt into 3 digit chunks from right to left */
   start = string.length;
   chunks = [];
   while (start > 0) {
      end = start;
      chunks.push(string.slice((start = Math.max(0, start - 3)), end));
   }

   /* Check if function has enough scale words to be able to stringify the user argument */
   chunksLen = chunks.length;
   if (chunksLen > scales.length) {
      return "";
   }

   /* Stringify each integer in each chunk */
   words = [];
   for (i = 0; i < chunksLen; i++) {
      chunk = parseInt(chunks[i]);

      if (chunk) {
         /* Split chunk into array of individual integers */
         ints = chunks[i].split("").reverse().map(parseFloat);

         /* If tens integer is 1, i.e. 10, then add 10 to units integer */
         if (ints[1] === 1) {
            ints[0] += 10;
         }

         /* Add scale word if chunk is not zero and array item exists */
         if ((word = scales[i])) {
            words.push(word);
         }

         /* Add unit word if array item exists */
         if ((word = units[ints[0]])) {
            words.push(word);
         }

         /* Add tens word if array item exists */
         if ((word = tens[ints[1]])) {
            words.push(word);
         }

         /* Add 'and' string after units or tens integer if: */
         if (ints[0] || ints[1]) {
            /* Chunk has a hundreds integer or chunk is the first of multiple chunks */
            if (ints[2] || (!i && chunksLen)) {
               words.push(and);
            }
         }

         /* Add hundreds word if array item exists */
         if ((word = units[ints[2]])) {
            words.push(word + " hundred");
         }
      }
   }

   return words.reverse().join(" ");
}

function getDateDayOfWeekName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("dddd");

   return AB.rules.toDateFormat(date, {
      format: "dddd",
      localeCode: AB.Account.language(),
   });
}

function getDateMonthOfYearName(AB, date) {
   // const localizeDT = moment(date);
   // localizeDT.locale(AD.lang.currentLanguage);
   // return localizeDT.format("MMMM");

   return AB.rules.toDateFormat(date, {
      format: "MMMM",
      localeCode: AB.Account.language(),
   });
}

function getFormatDate(date, format) {
   const dt = new Date(date);
   return dt.toString(format);
}

module.exports = class ABFieldTextFormulaCore extends ABField {
   constructor(values, object) {
      super(values, object, ABFieldTextFormulaDefaults);

      /*
    	{
			settings: {
				textDefault: 'string',
				supportMultilingual: true/false
			}
    	}
    	*/

      // // text to Int:
      // this.settings.supportMultilingual = parseInt(this.settings.supportMultilingual);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTextFormulaDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   static getBuildInFunction() {
      return getBuildInFunction();
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default value
         // values[this.columnName] = this.settings.DEFAULT_VALUE;
      }
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      validator = super.isValid();

      // validator.addError(this.columnName, L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /*
    * @property isMultilingual
    * does this field represent multilingual data?
    * @return {bool}
    */
   get isMultilingual() {
      // return this.settings.supportMultilingual == 1;
      return false;
   }

   format(rowData) {
      try {
         if (!this.settings.textFormula) return "";

         let resultFormula = this.settings.textFormula;

         //Set Field value first
         resultFormula = setValueToFormula(this.object, resultFormula, rowData);

         //then Check Build-in Function
         resultFormula = setBuildinValueToFormula(this.AB, resultFormula);

         return resultFormula;
      } catch (err) {
         return "";
      }
   }
};

//// NOTE: if you need a unique [edit_type] by your returned config.editor above:
// webix.editors = {
//   "[edit_type]": {
//     focus: function () {...}
//     getValue: function () {...},
//     setValue: function (value) {...},
//     render: function () {...}
//   }
// };

//// NOTE: if you need a unique [sort_type] by your returned config.sort above:
// webix.DataStore.prototype.sorting.as.[sort_type] = function(a,b){
//     return a > b ? 1 : -1;
// }


/***/ }),

/***/ 8514:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldTreeCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldTreeCore
 *
 * An ABFieldTree defines a select list field type.
 *
 */

const ABFieldSelectivity = __webpack_require__(/*! ../../platform/dataFields/ABFieldSelectivity */ 53317);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldTreeDefaults = {
   key: "tree",
   // unique key to reference this specific DataField

   description:
      "Data tree allows you to build a hierarchical set of selectable data. (ex: Categories and sub-categories)",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "sitemap",
   // font-awesome icon reference.  (without the 'fa-').  so 'sitemap'  to
   // reference 'fa-sitemap'

   isFilterable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: false,
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "Data Tree",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: false,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["text", "mediumtext", "longtext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php
};

const defaultValues = {
   options: [],
};

module.exports = class ABFieldTreeCore extends ABFieldSelectivity {
   constructor(values, object) {
      super(values, object, ABFieldTreeDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldTreeDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // translate options list
      if (this.settings.options && this.settings.options.length > 0) {
         this.settings.options.forEach((opt) => {
            this.translate(opt, opt, ["text"]);
         });
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      const obj = super.toObj();

      // Un-translate options list
      if (obj.settings.options && obj.settings.options.length > 0) {
         obj.settings.options.forEach((opt) => {
            this.unTranslate(opt, opt, ["text"]);
         });
      }

      return obj;
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {}

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
   }
};


/***/ }),

/***/ 58706:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/dataFields/ABFieldUserCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldUser
 *
 * An ABFieldUser defines a user field type.
 *
 */

const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 89981);

function L(key, altText) {
   // TODO:
   return altText; // AD.lang.label.getLabel(key) || altText;
}

const ABFieldUserDefaults = {
   key: "user",
   // unique key to reference this specific DataField

   description: "Add users to a record.",
   // description: what gets displayed in the Editor description.
   // NOTE: this will be displayed using a Label: L(description)

   icon: "user-o",
   // font-awesome icon reference.  (without the 'fa-').  so 'user-o'  to
   // reference 'fa-user-o'

   isFilterable: true,
   // {bool} / {fn}
   // determines if the current ABField can be used to filter (FilterComplex
   // or Query) data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => field.setting.something == true

   isSortable: (field) => {
      if (field.settings.isMultiple) {
         return false;
      } else {
         return true;
      }
   },
   // {bool} / {fn}
   // determines if the current ABField can be used to Sort data.
   // if a {fn} is provided, it will be called with the ABField as a parameter:
   //  (field) => true/false

   menuName: "User",
   // menuName: what gets displayed in the Editor drop list
   // NOTE: this will be displayed using a Label: L(menuName)

   supportRequire: false,
   // {bool}
   // does this ABField support the Required setting?

   supportUnique: false,
   // {bool}
   // does this ABField support the Unique setting?

   useAsLabel: true,
   // {bool} / {fn}
   // determines if this ABField can be used in the display of an ABObject's
   // label.

   compatibleOrmTypes: ["string"],
   // {array}
   // what types of Sails ORM attributes can be imported into this data type?
   // http://sailsjs.org/documentation/concepts/models-and-orm/attributes#?attribute-options

   compatibleMysqlTypes: ["char", "varchar", "tinytext"],
   // {array}
   // what types of MySql column types can be imported into this data type?
   // https://www.techonthenet.com/mysql/datatypes.php

   USERNAME_FIELD_ID: "5760560b-c078-47ca-98bf-e18ac492a561",
   // {string} .uuid
   // the ABField.id of the SiteUser.username field.  This is what other
   // objects will link to in their ABFieldUser connections.
};

const defaultValues = {
   editable: 1,
   isMultiple: 0,
   isCurrentUser: 0,
   isShowProfileImage: 0,
   isShowUsername: 1,
};

module.exports = class ABFieldUserCore extends ABFieldConnect {
   constructor(values, object) {
      super(values, object, ABFieldUserDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return ABFieldUserDefaults;
   }

   static defaultValues() {
      return defaultValues;
   }

   ///
   /// Instance Methods
   ///

   fromValues(values) {
      super.fromValues(values);

      this.settings.editable = parseInt(this.settings.editable);
      this.settings.isMultiple = parseInt(this.settings.isMultiple);
      this.settings.isCurrentUser = parseInt(this.settings.isCurrentUser);
      this.settings.isShowProfileImage = parseInt(
         this.settings.isShowProfileImage
      );
      this.settings.isShowUsername = parseInt(this.settings.isShowUsername);
   }

   ///
   /// Working with Actual Object Values:
   ///

   format(rowData) {
      let val = this.dataValue(rowData) || [];

      if (val && !Array.isArray(val)) val = [val];
      if (!val) val = [];

      return val.map((v) => v.username || v).join(", ");
   }
};


/***/ }),

/***/ 73134:
/*!****************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobilePageCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABMobilePageCore
 *
 * An view that represents a "Page" on the Mobile Device.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);
// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABMobilePageDefaults = {
   key: "mobile-page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-'  )
};

const ABPropertyComponentDefaults = {
   type: "page",
   // {string}
   // What type of "Page" this is: ['page', 'popup', 'reportPage']

   defaultPage: 0,
   // {bool} 1|0
   // is this the default page for the Mobile App? If so, this is the initial
   // Page that is displayed when the App is loaded.
   // NOTE: there can be only 1 page defined in the app as .defaultPage

   hideTitle: 0,
   // {bool} 1|0
   // By default we will display this.label as our Title. Set this to 1 to not
   // show the tile on the page.

   hideTabs: 0,
   // {bool} 1|0
   // By default, pages will show any Tab options on their display.  Set this
   // to 1 to not show the tab options for this Page. (good for pages that
   // are linkedPages with forms )
};

module.exports = class ABMobilePageCore extends ABMobileView {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABMobilePageDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABMobilePage, but has
      // different implications ... so we default an ABMobilePage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABMobilePageDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABMobilePage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;
      obj.route = this.route;

      obj.myAppID = this.myAppID;

      obj.menuType = this.menuType;

      obj.defaultPage = this.defaultPage;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      const DV = ABPropertyComponentDefaults;

      this.route =
         values.route || (this.name || this.label).replaceAll(" ", "_");

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      this.menuType = values.menuType || "menu";
      // {string}  ["menu", "tab"]
      // indicates if this Page was added as a Mobile App's "menu" or "Tab"

      this.defaultPage = values.defaultPage || 0;
      // {bool}  1|0
      // indicates if this is the default page that is loaded when the mobile app
      // is started.
      // NOTE: only 1 Page in a Mobile App can have this setting = 1.

      this.settings.hideTitle = parseInt(
         values.settings.hideTitle ?? DV.hideTitle
      );
      // {bool} 1|0
      // By default an ABMobilePage will display it's this.label for a title
      // on the page.  Setting this to TRUE (1) will hide the title.

      this.settings.hideTabs = parseInt(
         values.settings.hideTabs ?? DV.hideTabs
      );
      // {bool} 1|0
      // By default, pages will show any Tab options on their display.  Set this
      // to 1 to not show the tab options for this Page. (good for pages that
      // are linkedPages with forms )

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.emit(
               "warning",
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`,
               {
                  appID: this.application.id,
                  pageID: this.id,
                  missingPageID: id,
               }
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      // this.settings.columns = this.settings.columns || 1;
      // this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABMobilePage
            // be sure to remove any of it's ABMobilePage as well
            // This cleans out any dangling ABDefinitions

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });
   }

   /**
    * @method save()
    * persist this instance of ABMobilePage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            // make sure .defaultPage is properly set
            if (this.defaultPage) {
               return this.application.setPageDefault(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method refreshInstance()
    * This returns a NEW instance of a ABMobilePage based upon the latest
    * version of it's Definition.  It also resolves any current listeners
    * this copy currently has and prepare this to discard itself.
    */
   refreshInstance() {
      console.warn(
         "This version of ABMobilePage hasn't updated it's refreshInstance()",
         this
      );
      return this;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABMobilePages for this ABMobilePage.
    *
    * @param {fn} filter		a filter fn to return a set of ABMobilePages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABMobilePages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         // if (this._pages && this._pages.length > 0) {
         //    result = this._pages.filter(filter);

         //    if (result.length < 1) {
         //       this._pages.forEach((p) => {
         //          var subPages = p.pages(filter, deep);
         //          if (subPages && subPages.length > 0) {
         //             result = subPages;
         //          }
         //       });
         //    }
         // }
         result = this.application._searchDeep(this, "_pages", filter);
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABMobilePage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABMobilePage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABMobilePage that is tied to this
    * ABMobilePage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABMobilePage}
    */
   pageNew(values) {
      // make sure this is an ABMobilePage description
      values.key = ABMobilePageDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABMobilePage from our ._pages array and persist the current
    * values.
    *
    * @param {ABMobilePage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages((p) => p.id != page.id);

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABMobilePageDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABMobilePage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABMobilePage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
};


/***/ }),

/***/ 86501:
/*!****************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */

var ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 70504);

const ABMobileViewDefaults = {
   key: "mobile-view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

module.exports = class ABMobileViewCore extends ABMLClass {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABMobileViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABMobileViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || this.viewKey(),
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         // accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || this.viewKey();
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      // this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label =
               this.parent.label +
               "." +
               (this.field?.()?.columnName ?? this.defaults.key);
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   // isAccessibleForRoles(roles) {
   //    var foundRole = false;

   //    var accessibleRoles = Object.keys(this.accessLevels) || [];
   //    (roles || []).forEach((r) => {
   //       if (accessibleRoles.indexOf(r.uuid || r) > -1) {
   //          foundRole = true;
   //       }
   //    });

   //    return foundRole;
   // }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   // getUserAccess() {
   //    // by default everyone has no access
   //    var accessLevel = 0;

   //    if (this.application.isAccessManaged) {
   //       // check to see if the current users is the access manager
   //       var isAccessManager = false;
   //       // first check if manager is defined by their role
   //       if (parseInt(this.application.accessManagers.useRole) == 1) {
   //          // if so check if any of the user's role match the managers
   //          this.AB.Account.roles().forEach((role) => {
   //             if (
   //                this.application.accessManagers.role.indexOf(
   //                   role.id || role.uuid
   //                ) > -1
   //             ) {
   //                // if so set the access level to full access
   //                isAccessManager = true;
   //                accessLevel = 2;
   //             }
   //          });
   //       }
   //       // if the user isn't already set as the manager and the manager is defined by their account
   //       if (
   //          !isAccessManager &&
   //          parseInt(this.application.accessManagers.useAccount) == 1
   //       ) {
   //          // check if the user's account matches the managers
   //          if (
   //             this.application.accessManagers.account.indexOf(
   //                this.AB.Account.uuid() + ""
   //             ) > -1
   //          ) {
   //             // if so set the access level to full access
   //             isAccessManager = true;
   //             accessLevel = 2;
   //          }
   //       }

   //       // if the user is not the manager check if the page has access levels defined for roles
   //       if (
   //          this.accessLevels &&
   //          Object.keys(this.accessLevels).length > 0 &&
   //          !isAccessManager
   //       ) {
   //          // check to see if the user's roles matches one of the roles defined
   //          this.AB.Account.roles().forEach((role) => {
   //             var currentRole = this.accessLevels[role.id || role.uuid];
   //             if (currentRole && parseInt(currentRole) > accessLevel)
   //                // if the access level is higher than a previous role set to the new level
   //                accessLevel = parseInt(currentRole);
   //          });
   //       }
   //    } else {
   //       accessLevel = 2;
   //    }

   //    return accessLevel;
   // }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "mobile-form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "mobile-form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "mobile-detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "mobile-detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "mobile-page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            [
               "mobile-form",
               "grid",
               "line",
               "area",
               "bar",
               "gantt",
               "kanban",
            ].indexOf(this.key) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "mobile-form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               [
                  "button",
                  "label",
                  "mobile-page",
                  "tab",
                  "viewcontainer",
               ].indexOf(this.key) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `MobileView[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   // updateAccessLevels(roleId, accessLevel) {
   //    if (parseInt(accessLevel) == 0) {
   //       if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
   //    } else {
   //       this.accessLevels[roleId] = accessLevel;
   //    }

   //    return this.save(false, false);
   // }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         // result = result.concat(this._views.filter(filter));

         // this._views.forEach((v) => {
         //    var subViews = v.views(filter, deep);
         //    if (subViews && subViews.length > 0) {
         //       result = result.concat(subViews);
         //    }
         // });
         result = this.application._searchDeep(this, "_views", filter);
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewByID()
    *
    * return the specific View referenced by the given ID.
    *
    * @param {uuid} ID
    *        the {ABMobileView}.id of the child view we are requesting
    *
    * @return {ABMobileView || undefined}
    */
   viewByID(ID) {
      return this.views((v) => v.id == ID, true)[0];
   }

   /**
    * @method viewNew()
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   // viewDestroy(view) {
   //    console.error("DEPRECIATED: where is this called?");
   //    return this.viewRemove(view);
   // }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // the default widget doesn't.
      // only those that actually do, should override this.
      return false;
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "mobile-page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
};


/***/ }),

/***/ 75864:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormButtonCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);

const ABViewFormButtonPropertyComponentDefaults = {
   includeSave: true,
   saveLabel: "",
   includeCancel: false,
   cancelLabel: "",
   includeReset: false,
   resetLabel: "",
   afterCancel: null,
   alignment: "right",
   isDefault: false, // mark default button of form widget
};

const ABViewFormButtonDefaults = {
   key: "mobile-button",
   // {string} unique key for this view

   icon: "square",
   // {string} fa-[icon] reference for this view

   labelKey: "button",
   // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormButtonCore extends ABMobileView {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormButtonDefaults
      );
   }

   static common() {
      return ABViewFormButtonDefaults;
   }

   static defaultValues() {
      return ABViewFormButtonPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   toObj() {
      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      let result = super.toObj();

      return result;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }

   fromValues(values) {
      super.fromValues(values);

      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      this.unTranslate(this.settings, this.settings, labels);

      Object.keys(ABViewFormButtonPropertyComponentDefaults).forEach((k) => {
         let val =
            this.settings[k] ?? ABViewFormButtonPropertyComponentDefaults[k];
         try {
            val = JSON.parse(val);
         } catch (e) {
            // just ignore the error and save val
         }
         this.settings[k] = val;
      });

      // this.settings.includeSave = JSON.parse(
      //    this.settings.includeSave ||
      //       ABViewFormButtonPropertyComponentDefaults.includeSave
      // );
      // this.settings.includeCancel = JSON.parse(
      //    this.settings.includeCancel ||
      //       ABViewFormButtonPropertyComponentDefaults.includeCancel
      // );
      // this.settings.includeReset = JSON.parse(
      //    this.settings.includeReset ||
      //       ABViewFormButtonPropertyComponentDefaults.includeReset
      // );

      // this.settings.isDefault = JSON.parse(
      //    this.settings.isDefault ||
      //       ABViewFormButtonPropertyComponentDefaults.isDefault
      // );
   }
};


/***/ }),

/***/ 95493:
/*!****************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormCheckboxCore.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormCheckboxPropertyComponentDefaults = {};

const ABMobileViewFormCheckboxDefaults = {
   key: "mobile-checkbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "checkbox", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormCheckboxCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormCheckboxDefaults
      );
   }

   static common() {
      return ABMobileViewFormCheckboxDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormCheckboxPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 27140:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormConnectCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormConnectPropertyComponentDefaults = {
   formView: "", // id of form to add new data
   filterConditions: {
      glue: "and",
      rules: [],
   },
   sortFields: [],
   popupWidth: 700,
   popupHeight: 450,
};

const ABMobileViewFormConnectDefaults = {
   key: "mobile-connect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "Connect", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormConnectCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormConnectDefaults
      );
   }

   static common() {
      return ABMobileViewFormConnectDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormConnectPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.filterConditions =
         this.settings.filterConditions ||
         ABMobileViewFormConnectPropertyComponentDefaults.filterConditions;
   }
};


/***/ }),

/***/ 11408:
/*!********************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 95652);
const ABSubmitRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 17004);

const ABViewFormDefaults = {
   key: "mobile-form", // unique key identifier for this ABMobileViewForm
   icon: "list-alt", // icon reference: (without 'fa-' )
   labelKey: "Form", // {string} the multilingual label key for the class label
};

const ABViewFormPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   clearOnLoad: false,
   clearOnSave: false,
   displayRules: [],
   editForm: "none", // The url pointer of ABViewForm

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		values: [
   //			{
   //				fieldId: {UUID},
   //				value: {object}
   //			}
   //		]
   //	}]
   recordRules: [],

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		value: {string}
   //	}]
   submitRules: [],
};

module.exports = class ABMobileViewFormCore extends ABMobileView {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewFormDefaults);
   }

   static common() {
      return ABViewFormDefaults;
   }

   static defaultValues() {
      return ABViewFormPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewFormPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewFormPropertyComponentDefaults.showLabel
      );
      this.settings.clearOnLoad = JSON.parse(
         this.settings.clearOnLoad != null
            ? this.settings.clearOnLoad
            : ABViewFormPropertyComponentDefaults.clearOnLoad
      );
      this.settings.clearOnSave = JSON.parse(
         this.settings.clearOnSave != null
            ? this.settings.clearOnSave
            : ABViewFormPropertyComponentDefaults.clearOnSave
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth == null
            ? ABViewFormPropertyComponentDefaults.labelWidth
            : this.settings.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height == null
            ? ABViewFormPropertyComponentDefaults.height
            : this.settings.height
      );
   }

   // Use this function in kanban
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["mobile-label", "mobile-button", "mobile-text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   /**
    * @method fieldComponents()
    * return an array of all the ABViewFormField children
    * @param {fn} filter
    *        a filter fn to return a set of ABViewFormField that this fn
    *	       returns true for.
    * @return {array} 	array of ABViewFormField
    */
   fieldComponents(filter) {
      const flattenComponents = (views) => {
         let components = [];

         views.forEach((v) => {
            if (v == null) return;

            components.push(v);

            if (v._views?.length) {
               components = components.concat(flattenComponents(v._views));
            }
         });

         return components;
      };

      if (this._views?.length) {
         const allComponents = flattenComponents(this._views);

         if (filter == null) {
            filter = (comp) =>
               comp instanceof this.AB.Class.ABMobileViewFormItem;
         }

         return allComponents.filter(filter);
      } else {
         return [];
      }
   }

   /**
    * @method addFieldToForm()
    * Create a New Form Item on this Form from a given ABFieldXXX object.
    * @param {ABFieldXXX} field
    * @param {int} yPosition
    * @return {ABMobileViewFormXXX}
    */
   addFieldToForm(field, yPosition) {
      if (field == null) return;

      // TODO: figure out how to decode the Data Field and return a form
      // element.

      var fieldComponent = field.formComponentMobile();
      if (fieldComponent == null) return;

      var newView = fieldComponent.newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings || {};
      newView.settings.fieldId = field.id;
      // TODO : Default settings

      if (yPosition != null) newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      return newView;
   }

   get RecordRule() {
      let object = this.datacollection.datasource;

      if (this._recordRule == null) {
         this._recordRule = new ABRecordRule();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   /**
    * @method recordRulesReady()
    * This returns a Promise that gets resolved when all record rules report
    * that they are ready.
    * @return {Promise}
    */
   async recordRulesReady() {
      return this.RecordRule.rulesReady();
   }

   doRecordRulesPre(rowData) {
      return this.RecordRule.processPre({ data: rowData, form: this });
   }

   doRecordRules(rowData) {
      // validate for record rules
      if (rowData) {
         let object = this.datacollection.datasource;
         let ruleValidator = object.isValidData(rowData);
         let isUpdatedDataValid = ruleValidator.pass();
         if (!isUpdatedDataValid) {
            console.error("Updated data is invalid.", { rowData: rowData });
            return Promise.reject(new Error("Updated data is invalid."));
         }
      }

      return this.RecordRule.process({ data: rowData, form: this });
   }

   doSubmitRules(rowData) {
      var object = this.datacollection.datasource;

      var SubmitRules = new ABSubmitRule();
      SubmitRules.formLoad(this);
      SubmitRules.fromSettings(this.settings.submitRules);
      SubmitRules.objectLoad(object);

      return SubmitRules.process({ data: rowData, form: this });
   }
};


/***/ }),

/***/ 26720:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormCustomCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABViewFormCustomPropertyComponentDefaults = {};

const ABViewFormCustomDefaults = {
   key: "mobile-fieldcustom",
   // {string} unique key for this view
   icon: "object-group",
   // {string} fa-[icon] reference for this view
   labelKey: "custom",
   // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormCustomCore extends ABMobileViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCustomDefaults
      );
   }

   static common() {
      return ABViewFormCustomDefaults;
   }

   static defaultValues() {
      return ABViewFormCustomPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 382:
/*!************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormDateCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormDatepickerPropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormDatepickerDefaults = {
   key: "mobile-date", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "datepicker", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormDatepickerCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormDatepickerDefaults
      );
   }

   static common() {
      return ABMobileViewFormDatepickerDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormDatepickerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
};


/***/ }),

/***/ 26854:
/*!****************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormDatetimeCore.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormDatetimePropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormDatetimeDefaults = {
   key: "mobile-datetime", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "Date and Time", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormDatetimeCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormDatetimeDefaults
      );
   }

   static common() {
      return ABMobileViewFormDatetimeDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormDatetimePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
};


/***/ }),

/***/ 73630:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormEmailCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormEmailPropertyComponentDefaults = {
   timepicker: false,
};

const ABMobileViewFormEmailDefaults = {
   key: "mobile-email", // {string} unique key for this view
   icon: "envelope", // {string} fa-[icon] reference for this view
   labelKey: "Email", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormEmailCore extends ABMobileViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormEmailDefaults
      );
   }

   static common() {
      return ABMobileViewFormEmailDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormEmailPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///
};


/***/ }),

/***/ 96453:
/*!************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormFileCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABViewFormFilePropertyComponentDefaults = {};

const ABViewFormFileDefaults = {
   key: "mobile-file",
   // {string} unique key for this view
   icon: "file",
   // {string} fa-[icon] reference for this view
   labelKey: "file",
   // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormFileCore extends ABMobileViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormFileDefaults
      );
   }

   static common() {
      return ABViewFormFileDefaults;
   }

   static defaultValues() {
      return ABViewFormFilePropertyComponentDefaults;
   }
};


/***/ }),

/***/ 21754:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormFormulaCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABViewFormFormulaPropertyComponentDefaults = {};

const ABViewFormFormulaDefaults = {
   key: "mobile-formula",
   // {string} unique key for this view
   icon: "circle-o-notch",
   // {string} fa-[icon] reference for this view
   labelKey: "Formula",
   // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormFormulaCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormFormulaDefaults
      );
   }

   static common() {
      return ABViewFormFormulaDefaults;
   }

   static defaultValues() {
      return ABViewFormFormulaPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 33397:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormImageCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormFile = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormFile */ 57078);

const ABViewFormImagePropertyComponentDefaults = {};

const ABViewImageFileDefaults = {
   key: "mobile-image",
   // {string} unique key for this view
   icon: "file-image-o",
   // {string} fa-[icon] reference for this view
   labelKey: "Image",
   // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormImageCore extends ABMobileViewFormFile {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewImageFileDefaults
      );
   }

   static common() {
      return ABViewImageFileDefaults;
   }

   static defaultValues() {
      return ABViewFormImagePropertyComponentDefaults;
   }
};


/***/ }),

/***/ 62591:
/*!************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormItemCore.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);

const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

module.exports = class ABMobileViewFormItemCore extends ABMobileView {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      let form = this.parentFormComponent();
      if (form == null) return null;

      let datacollection = form.datacollection;
      if (datacollection == null) return null;

      return datacollection;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
};


/***/ }),

/***/ 65407:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormNumberCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormNumberPropertyComponentDefaults = {
   isStepper: 0,
};

const ABMobileViewFormNumberDefaults = {
   key: "mobile-numberbox", // {string} unique key for this view
   icon: "hashtag", // {string} fa-[icon] reference for this view
   labelKey: "number", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormNumberCore extends ABMobileViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormNumberDefaults
      );
   }

   static common() {
      return ABMobileViewFormNumberDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormNumberPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewFormText instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "formLabel"]);

      var obj = super.toObj();
      obj.views = []; // no subviews
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      this.settings.isStepper =
         this.settings.isStepper ||
         ABMobileViewFormNumberPropertyComponentDefaults.isStepper;

      // convert from "0" => 0
      this.settings.isStepper = parseInt(this.settings.isStepper);
   }
};


/***/ }),

/***/ 42847:
/*!****************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormReadonlyCore.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormCustom = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormCustom */ 54111);

const ABMobileViewFormReadonlyPropertyComponentDefaults = {};

const ABMobileViewFormReadonlyDefaults = {
   key: "mobile-fieldreadonly", // {string} unique key for this view
   icon: "calculator", // {string} fa-[icon] reference for this view
   labelKey: "readonly", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormReadonly extends ABMobileViewFormCustom {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormReadonlyDefaults
      );
   }

   static common() {
      return ABMobileViewFormReadonlyDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormReadonlyPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 98438:
/*!**********************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormSelectMultipleCore.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormSelectSingle = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormSelectSingle */ 28131);

const ABMobileViewFormSelectMultiplePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABMobileViewFormSelectMultipleDefaults = {
   key: "mobile-selectmultiple", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "selectmultiple", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormSelectMultipleCore extends (
   ABMobileViewFormSelectSingle
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormSelectMultipleDefaults
      );
   }

   static common() {
      return ABMobileViewFormSelectMultipleDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormSelectMultiplePropertyComponentDefaults;
   }
};


/***/ }),

/***/ 61882:
/*!********************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormSelectSingleCore.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABMobileViewFormSelectSinglePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABMobileViewFormSelectSingleDefaults = {
   key: "mobile-selectsingle", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "selectsingle", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormSelectSingleCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABMobileViewFormSelectSingleDefaults
      );
   }

   static common() {
      return ABMobileViewFormSelectSingleDefaults;
   }

   static defaultValues() {
      return ABMobileViewFormSelectSinglePropertyComponentDefaults;
   }
};


/***/ }),

/***/ 27200:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewFormTextboxCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItem = __webpack_require__(/*! ../../platform/mobile/ABMobileViewFormItem */ 21579);

const ABViewFormTextboxPropertyComponentDefaults = {
   type: "single", // 'single', 'multiple' or 'rich'
   placeholder: "", // default placeholder text
};

const ABViewFormTextboxDefaults = {
   key: "mobile-textbox", // {string} unique key for this view
   icon: "i-cursor", // {string} fa-[icon] reference for this view
   labelKey: "textbox", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewFormTextboxCore extends (
   ABMobileViewFormItem
) {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormTextboxDefaults
      );
   }

   static common() {
      return ABViewFormTextboxDefaults;
   }

   static defaultValues() {
      return ABViewFormTextboxPropertyComponentDefaults;
   }

   toObj() {
      // placeholder is a multilingual value:
      this.unTranslate(this.settings, this.settings, ["placeholder"]);

      return super.toObj();
   }

   fromValues(values) {
      super.fromValues(values);

      // placeholder is a multilingual value:
      this.unTranslate(this.settings, this.settings, ["placeholder"]);
   }
};


/***/ }),

/***/ 52999:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewLabelCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);

const ABViewLabelPropertyComponentDefaults = {
   text: "",
   format: 0, // 0 - normal, 1 - title, 2 - description
   alignment: "left",
};

const ABViewDefaults = {
   key: "mobile-label", // {string} unique key for this view
   icon: "font", // {string} fa-[icon] reference for this view
   labelKey: "Label", // {string} the multilingual label key for the class label
};

module.exports = class ABMobileViewLabelCore extends ABMobileView {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewLabelPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "text"]);

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values); // <-- this performs the translations

      // if this is being instantiated on a read from the Property UI,
      // .text is coming in under .settings.label
      this.text = values.text || values.settings.text || "*text";

      this.settings.format =
         this.settings.format || ABViewLabelPropertyComponentDefaults.format;
      this.settings.alignment =
         this.settings.alignment ||
         ABViewLabelPropertyComponentDefaults.alignment;

      // we are not allowed to have sub views:
      this._views = [];

      // convert from "0" => 0
      this.settings.format = parseInt(this.settings.format);

      this.translate(this, this, ["label", "text"]);
   }

   //// Allow external interface to manipulate our settings:

   /**
    * @method formatNormal
    * display text in the normal format.
    */
   formatNormal() {
      this.settings.format = 0;
   }

   /**
    * @method formatTitle
    * display text as a Title.
    */
   formatTitle() {
      this.settings.format = 1;
   }

   /**
    * @method formatDescription
    * display text as a description.
    */
   formatDescription() {
      this.settings.format = 2;
   }
};


/***/ }),

/***/ 45334:
/*!********************************************************!*\
  !*** ./AppBuilder/core/mobile/ABMobileViewListCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileView = __webpack_require__(/*! ../../platform/mobile/ABMobileView */ 94197);

const ABViewListPropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
   hideTitle: 0,
   hideTabs: 0,
};

const ABViewDefaults = {
   key: "mobile-list", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "List", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLabelCore extends ABMobileView {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewListPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   field() {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.field);
   }

   /**
    * @method wantsAdd()
    * Some widgets can indicate to their containing ABMobilePage that
    * it wants to provide an [Add] feature.
    * @return {bool}
    */
   get wantsAdd() {
      // we do if we have a setting for linkPageAdd
      return this.settings.linkPageAdd != "";
   }
};


/***/ }),

/***/ 71506:
/*!******************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessLaneCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessLane
 * manages the lanes in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */
const ABProcessParticipant = __webpack_require__(/*! ../../platform/process/ABProcessParticipant */ 98618);

const ABProcessLaneDefaults = {
   type: "process.lane",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key"
   // {string} .icon
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

module.exports = class ABProcessLaneCore extends ABProcessParticipant {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessLaneDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.type = attributes.type || ABProcessLaneDefaults.type;
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   // toObj() {
   //     // default label value
   //     if (!this.label && this.name && this.name != "") {
   //         this.label = this.name;
   //     }

   //     // untranslate this object:
   //     var data = super.toObj();

   //     var fieldsToSave = [
   //         "id",
   //         "name",
   //         "type",
   //         "processID",
   //         "diagramID",
   //         "where"
   //     ];
   //     fieldsToSave.forEach((f) => {
   //         data[f] = this[f];
   //     });

   //     return data;
   // }
};


/***/ }),

/***/ 21500:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessParticipantCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system, and provide a way to lookup a SiteUser.
 */
const ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 70504);

const ABProcessParticipantDefaults = {
   type: "process.participant",
   // {string} .type
   // unique key to reference this specific object

   // icon: "key" // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
};

module.exports = class ABProcessParticipantCore extends ABMLClass {
   constructor(attributes, process, AB) {
      super(["label"], AB);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }

      this.fromValues(attributes);

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
   }

   static defaults() {
      return ABProcessParticipantDefaults;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // These Values are needed By ABDefinition:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || ABProcessParticipantDefaults.type;
      this.key = attributes.key || ABProcessParticipantDefaults.type;

      // Process Values:
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneIDs = attributes.laneIDs || [];
      this.stashed = false;
      if (attributes.stashed && attributes.stashed != "") {
         this.stashed = attributes.stashed;
      }

      function validChecker(attribute) {
         return typeof attribute != "undefined" && attribute != null;
      }

      this.useRole = 0;
      if (validChecker(attributes.useRole)) {
         this.useRole = parseInt(attributes.useRole);
      }

      this.role = 0;
      if (validChecker(attributes.role)) {
         this.role = attributes.role;
      }

      this.useAccount = 0;
      if (validChecker(attributes.useAccount)) {
         this.useAccount = parseInt(attributes.useAccount);
      }

      this.account = 0;
      if (validChecker(attributes.account)) {
         this.account = attributes.account;
      }

      this.useField = 0;
      if (validChecker(attributes.useField)) {
         this.useField = parseInt(attributes.useField);
      }

      this.userField = [];
      if (validChecker(attributes.userField)) {
         this.userField = attributes.userField;
      }

      // depreciated
      this.fields = [];
      if (validChecker(attributes.fields)) {
         this.fields = attributes.fields;
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneIDs",
         "where",
         "useRole",
         "role",
         "useAccount",
         "account",
         "useField",
         "userField",
         "fields",
         "stashed",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   /**
    * @method onProcessReady()
    * perform any tasks/checks necessary after the parent Process is
    * setup and ready.
    */
   onProcessReady() {}
};


/***/ }),

/***/ 78949:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/process/ABProcessTaskManager.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABProcessTaskManager
 *
 * An interface for managing the different ABProcessTasks in AppBuilder.
 *
 */

/*
 * Tasks
 * A name => ABProcessElement hash of the different ABProcessElements available.
 */
var Tasks = {};

/*
 * DEFINITIONTYPES
 * a hash of BPMN:Element.type to Default values
 * for each of our Process Objects.
 *
 * NOTE: For Tasks, the key should be target.type,
 * for Triggers or End elements, the key should be
 * the target.eventDefinitionType
 */
var DEFINITIONTYPES = {};

var AllProcessElements = [
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessEnd */ 39864),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessGatewayExclusive */ 15372),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskEmail */ 93563),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskService */ 2353),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing */ 97915),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPClose */ 10727),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose */ 3746),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceAccountingJEArchive */ 69305),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceCalculate */ 21374),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceInsertRecord */ 94417),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceQuery */ 17378),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl */ 78320),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskSubProcess */ 39966),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUser */ 46146),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUserApproval */ 31063),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTaskUserExternal */ 60986),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTrigger */ 19010),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTriggerLifecycle */ 16642),
   __webpack_require__(/*! ../../platform/process/tasks/ABProcessTriggerTimer */ 39009),
];

AllProcessElements.forEach((ELEMENT) => {
   Tasks[ELEMENT.defaults().key] = ELEMENT;

   switch (ELEMENT.defaults().category) {
      case "start":
      case "end":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.eventDefinitionType] =
            ELEMENT.defaults();
         break;

      case "gateway":
      case "task":
         DEFINITIONTYPES[ELEMENT.DiagramReplace().target.type] =
            ELEMENT.defaults();
         break;
   }
});

module.exports = {
   /*
    * @function allTasks
    * return all the currently defined ABProcessTasks in an array.
    * @return [{ABProcessTask},...]
    */
   allTasks: function () {
      var tasks = [];
      for (var t in Tasks) {
         tasks.push(Tasks[t]);
      }
      return tasks;
   },

   /*
    * @function newTask
    * return an instance of an ABProcessTask based upon the values.type value.
    * @return {ABProcessTask}
    */
   newTask: function (values, process, AB) {
      if (values.key) {
         return new Tasks[values.key](values, process, AB);
      } else {
         //// TODO: what to do here?
      }
   },

   DiagramReplaceDefinitionsForType: function (type) {
      var definitions = AllProcessElements.filter((e) => {
         return e.defaults().category == type;
      }).map((e) => {
         return e.DiagramReplace();
      });
      return definitions;
   },

   StartEvents: function () {
      return this.DiagramReplaceDefinitionsForType("start");
   },

   Gateways: function () {
      return this.DiagramReplaceDefinitionsForType("gateway");
   },

   Tasks: function () {
      return this.DiagramReplaceDefinitionsForType("task");
   },

   EndEvents: function () {
      return this.DiagramReplaceDefinitionsForType("end");
   },

   definitionForElement: function (element) {
      // pull the key from the embedded .eventDefinition
      // if there is one
      var key = null;
      if (element.businessObject.eventDefinitions) {
         var def = element.businessObject.eventDefinitions[0];
         if (def) {
            key = def.$type;
         }
      }

      // if not, then just use the base .type
      if (!key) {
         key = element.type;
      }

      return DEFINITIONTYPES[key];
   },
};


/***/ }),

/***/ 43409:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessElementCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ABMLClass = __webpack_require__(/*! ../../../platform/ABMLClass */ 70504);

module.exports = class ABProcessTaskCore extends ABMLClass {
   constructor(attributes, process, AB, defaultValues) {
      super(["label"], AB);

      this.defaults = defaultValues || { key: "core", icon: "core" };
      // {obj} .defaults
      // a value hash of default values for an ABProcessTask
      // NOTE: needs to be set before .fromValues()

      this.fromValues(attributes);

      this.process = process;
      if (!this.processID) {
         this.processID = process.id;
      }
      // {ABProcess} .process
      // The parent ABProcess this process element is a part of.

      //// Runtime Values
      //// these are not stored in the Definition, but rather
      //// loaded and used from a running process instance.
      this.state = null;
   }

   ///
   /// Static Methods
   ///

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      // ABDefinition Related fields:
      this.id = attributes.id;
      this.name = attributes.name || "";
      this.type = attributes.type || "process.task.unknown";

      // ABProcess related fields:
      this.key = attributes.key || this.defaults.key || "?key?";
      this.processID = attributes.processID || null;
      this.diagramID = attributes.diagramID || "?diagramID?";
      this.laneDiagramID = attributes.laneDiagramID || "?laneID?";
      // laneDiagramID : connects to the parent object that defines any
      //      default User information for the Task.  In our case, it
      //      might be a {ABProcessParticipant} object, or a {ABProcessLane}
      //      object.  by default, a diagram's Participant obj doesn't define
      //      any lanes, and therefore can provide that info.  Once a lane
      //      is added, however, an object is assigned to it, and the
      //      Lane will provide that info.

      // initialize any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            if (typeof attributes[s] == "undefined") this[s] = null;
            else this[s] = attributes[s];
         });
      }

      super.fromValues(attributes); // perform translation on this object.
      // NOTE: keep this at the end of .fromValues();

      if (!this.label) {
         this.label = this.name;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      // default label value
      if (!this.label && this.name && this.name != "") {
         this.label = this.name;
      }

      // untranslate this object:
      var data = super.toObj();

      var fieldsToSave = [
         "id",
         "name",
         "type",
         "processID",
         "diagramID",
         "laneDiagramID",
         "key",
      ];
      fieldsToSave.forEach((f) => {
         data[f] = this[f];
      });

      // save any defined settings
      if (this.defaults && this.defaults.settings) {
         this.defaults.settings.forEach((s) => {
            data[s] = this[s];
         });
      }

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * errorConfig()
    * Respond with an error when expected configuration parameters do not
    * pull data.
    * @param {obj} instance
    *        the instance data of this task
    * @param {string} msg
    *        the display message for this error.
    * @param {array[string]} fields
    *        an array of parameter keys that should be included in the error
    *        for additional information.
    * @return {Promise.reject(error)}
    */
   errorConfig(instance, msg, fields = []) {
      this.log(instance, msg);
      var error = new Error(`${this.type}: ${msg}`);
      var info = { task: this };
      if (!Array.isArray(fields)) fields = [fields];
      fields.forEach((field) => {
         info[field] = this[field];
      });
      this.AB.notify.builder(error, info);
      return Promise.reject(error);
   }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context
    *        the context data of the process instance
    * @param {obj} defaults
    *        any values to include from our child classes
    * @param {obj} val
    *        any values to override the default state
    */
   initState(context, defaults, val) {
      defaults = defaults || {};
      if (!val) {
         val = defaults;
         defaults = {};

         // in this case, then auto initi blank instanceValues:
         if (this.defaults && this.defaults.instanceValues) {
            this.defaults.instanceValues.forEach((v) => {
               defaults[v] = null;
            });
         }
      }

      context.taskState = context.taskState || {};

      // don't overwrite your settings if they already exist:
      if (!context.taskState[this.diagramID]) {
         context.taskState[this.diagramID] = {
            initialized: true,
            status: "initialized",
         };
         for (var d in defaults) {
            context.taskState[this.diagramID][d] = defaults[d];
         }
         for (var v in val) {
            context.taskState[this.diagramID][v] = val[v];
         }
      }
   }

   /*
    * @function isEndTask
    * return true if the current type of task is an End task. False otherwise.
    * @return {bool}
    */
   isEndTask() {
      return false;
   }

   /**
    * log()
    * enter a log in the current process instance
    * @param {obj} instance  the current ABProcessInstance
    * @param {...} ...allArgs the remaining parameters sent to the log
    */
   log(instance, ...allArgs) {
      var text = `${this.diagramID} : ${
         this.name ? this.name : this.key
      } : ${allArgs.join(" ")}`;
      instance.log.push(text);
   }

   /**
    * myLane()
    * return the ABProcessParticipant | ABProcessLane element we are
    * in.
    * @return {ABProcessParticipant|ABProcessLane}
    */
   myLane() {
      return this.process.elementForDiagramID(this.laneDiagramID);
   }

   /**
    * myState()
    * return the current state values for this ABProcessTask
    * @param {obj} instance  the current ABProcessInstance
    * @return {obj}
    */
   myState(instance) {
      return instance.context.taskState[this.diagramID];
   }

   /**
    * nextTasks()
    * follow the current instance diagram and return the next task(s)
    * after this task.
    * @param {obj} instance  the current ABProcessInstance
    * @return {array}  [ABProcessTask, ...] or {null} if an error
    */
   nextTasks(instance) {
      var nextTasks = [];

      var myDiagramObj = instance.hashDiagramObjects[this.diagramID];
      if (!myDiagramObj) {
         let error = new Error(
            `Configuration Error: Did not find my definition for dID[${this.diagramID}]`
         );
         this.onError(instance, error);
         return null;
      }

      // myDiagramObj :
      // {
      //     "bpmn2:outgoing": [{"_text": "SequenceFlow_00fbxm3"} ...],
      //     "_attributes": {id: "StartEvent_1"},
      //     "_type": "start"
      // }

      // find my possible exits:
      var exitFlows = myDiagramObj["bpmn2:outgoing"];
      if (!exitFlows) {
         let error = new Error(
            `Configuration Error: Did not find any outgoing flows for dID[${this.diagramID}]`
         );
         this.AB.notify.builder(error, { task: this });
         this.onError(instance, error);
         return null;
      }

      if (!Array.isArray(exitFlows)) {
         exitFlows = [exitFlows];
      }

      var tasksFromFlow = (flow) => {
         // follow a flow and grab each of it's exit tasks
         // place them into nextTasks[];

         var flowObj = instance.hashDiagramObjects[flow["_text"]];
         if (!flowObj) return;

         var targetIDs = flowObj["_attributes"]["targetRef"];
         if (!targetIDs) return;

         if (!Array.isArray(targetIDs)) {
            targetIDs = [targetIDs];
         }

         targetIDs.forEach((tid) => {
            var targetTask = this.process.elementForDiagramID(tid);
            if (targetTask) {
               if (nextTasks) {
                  nextTasks.push(targetTask);
               }
            } else {
               let error = new Error(
                  `Configuration Error: No ProcessTask instance for diagramID[${tid}]`
               );
               this.AB.notify.builder(error, { task: this });
               this.onError(instance, error);
               nextTasks = null;
            }
         });
      };

      exitFlows.forEach((f) => {
         tasksFromFlow(f);
      });

      return nextTasks;
   }

   /**
    * onError()
    * perform the following actions (log it) on an error.
    * @param {obj} instance  the current ABProcessInstance
    * @param {Error} error
    */
   onError(instance, error) {
      if (error) {
         var text = `${error.toString()}`;
         this.log(instance, text);
      }
      var myState = this.myState(instance);
      myState.status = "error";
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can request from other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return null;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      return null;
   }

   /**
    * hashProcessDataValues()
    * return a hash of live Process Data Values
    * @param {obj} instance
    * @return {array} | null
    */
   hashProcessDataValues(instance) {
      var listDataFields = this.process.processDataFields(this);
      var currentProcessValues = {};
      listDataFields.forEach((f) => {
         currentProcessValues[f.key] = this.process.processData(this, [
            instance,
            f.key,
         ]);
      });
      return currentProcessValues;
   }

   /**
    * reset()
    * prepare this task to run again if it was already completed.
    *
    * This might happen in a process where a loop is formed and tasks
    * are repeated until a certain outcome.
    *
    * @param {obj} instance  the current ABProcessInstance
    */
   reset(instance) {
      // a task wants to run me.  Possibly again.
      var myState = this.myState(instance);

      // if I haven't setup my state (why?) then just
      // do that again:
      if (!myState) {
         this.initState(instance.context);
      } else {
         // if I have already "completed" and we are being
         // asked to run again (it's possible)
         if (myState.status == "completed" || myState.status == "error") {
            // remove my current state
            delete instance.context.taskState[this.diagramID];

            // store a new state in the context
            this.initState(instance.context);

            // remember our previous state
            var newState = this.myState(instance);
            newState._prevState = myState;
            this.log(instance, " Reset() called. Running again. ");
         }
      }
   }

   /**
    * stateCompleted()
    * mark this task has having completed.
    * @param {obj} instance  the current ABProcessInstance
    */
   stateCompleted(instance) {
      var myState = this.myState(instance);
      myState.status = "completed";
   }

   /**
    * stateUpdate()
    * update my state values with the given values data
    * @param {obj} instance  the current ABProcessInstance
    * @param {obj} values    the new state values
    */
   stateUpdate(instance, values) {
      values = values || {};
      var myState = this.myState(instance);
      for (var v in values) {
         myState[v] = values[v];
      }
   }

   /**
    * wantToDoSomething()
    * determine if this task still has something to do.
    * @param {obj} instance  the instance data of the process we are working on
    * @return {bool} true if there is still pending actions
    */
   wantToDoSomething(instance) {
      var state = this.myState(instance);
      if (state) {
         return state.status != "completed" && state.status != "error";
      } else {
         // my state wasn't defined?
         console.warn(
            "ABProcessTaskCore:wantToDoSomething(): called without having initialized our state first.",
            instance
         );
         // initialize our state and try again
         this.initState(instance.context);
         return this.wantToDoSomething(instance);
      }
   }

   /**
    * @method onProcessReady()
    * Perform any setup actions after the parent process has indicated it is "ready"
    */
   onProcessReady() {}

   get startElements() {
      let startElems =
         this.process.elements(
            (elem) =>
               elem && elem.defaults && elem.defaults.category === "start"
         ) || [];
      return startElems;
   }

   get previousElements() {
      return this.process.connectionPreviousTask(this);
   }

   get objectOfStartElement() {
      const startElem = this.startElements[0];
      if (!startElem) return null;

      return this.AB.objectByID(startElem.objectID);
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElements[0];
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }
};


/***/ }),

/***/ 69569:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessEndCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessTaskEndDefaults = {
   category: "end",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "stop",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to
   // reference 'fa-user'

   key: "End",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTaskEndCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.end";
      super(attributes, process, AB, ABProcessTaskEndDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEndDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Terminate End Event",
         actionName: "replace-with-terminate-end",
         className: "bpmn-icon-end-event-terminate",
         target: {
            type: "bpmn:EndEvent",
            eventDefinitionType: "bpmn:TerminateEventDefinition",
         },
      };
   }

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         triggered: false,
      };

      super.initState(context, myDefaults, val);
   }

   /*
    * @function isEndTask
    * return true if the current type of task is an End task. False otherwise.
    * @return {bool}
    */
   isEndTask() {
      return true;
   }

   /**
    * nextTasks()
    * return the next tasks to be run after this task is complete.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve([])
    */
   nextTasks(instance) {
      // I'm an End Event.  There are no nextTasks()
      return [];
   }
};


/***/ }),

/***/ 2406:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessGatewayExclusiveCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessGatewayExclusiveDefaults = {
   category: "gateway",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to
   // reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GatewayExclusive",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["conditions"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessGatewayExclusiveCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.gateway.exclusive";
      super(attributes, process, AB, ABProcessGatewayExclusiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessGatewayExclusiveDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Exclusive Gateway",
         actionName: "replace-with-exclusive-gateway",
         className: "bpmn-icon-gateway-xor",
         target: {
            type: "bpmn:ExclusiveGateway",
         },
      };
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      this.conditions = this.conditions || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessGatewayExclusiveDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 85772:
/*!*****************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskEmailCore.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessTaskEmailDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "to",
      "from",
      "subject",
      "message",
      "toCustom",
      "fromCustom",
      "toUsers",
      "fromUsers",
      "toCustomFields",
      "fromCustomFields",
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "email", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Email",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTaskEmailCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.email";
      super(attributes, process, AB, ABProcessTaskEmailDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskEmailDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Send Task",
         actionName: "replace-with-send-task",
         className: "bpmn-icon-send",
         target: {
            type: "bpmn:SendTask",
         },
      };
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         this[f] = attributes[f];
      });
   }

   /**
    * onProcessReady()
    * Perform our warnings checks once the parent Process is ready
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      ABProcessTaskEmailDefaults.fields.forEach((f) => {
         data[f] = this[f];
      });

      return data;
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         to: [],
         from: [],
         subject: this.subject,
         message: this.message,
      };

      super.initState(context, myDefaults, val);
   }
};


/***/ }),

/***/ 39163:
/*!********************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var AccountingBatchProcessingDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingBatchProcessing",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectBatch",
      "processBatchValue",
      "fieldBatchEntries",
      "fieldBatchFinancialPeriod",
      "objectJE",
      "fieldJEAccount",
      "fieldJERC",
      "fieldJEStatus",
      "fieldJEStatusComplete",
      "objectBR",
      "fieldBRFinancialPeriod",
      "fieldBRAccount",
      "fieldBRRC",
      "fieldBREntries",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingBatchProcessingCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.batchProcessing";
      super(attributes, process, AB, AccountingBatchProcessingDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingBatchProcessingDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 25144:
/*!************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var AccountingFPCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPValue",
      "objectFP",
      "objectGL",
      "objectAcc",
      "fieldFPStart",
      "fieldFPOpen",
      "fieldFPStatus",
      "fieldFPActive",
      "fieldGLStarting",
      "fieldGLRunning",
      "fieldGLAccount",
      "fieldGLRc",
      "fieldGLDebit",
      "fieldGLCredit",
      "fieldAccType",
      "fieldAccAsset",
      "fieldAccExpense",
      "fieldAccLiabilities",
      "fieldAccEquity",
      "fieldAccIncome",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingFPCloseCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpClose";
      super(attributes, process, AB, AccountingFPCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 93071:
/*!****************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var AccountingFPYearCloseDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingFPYearClose",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processFPYearValue",
      "objectFPYear",
      "objectFPMonth",
      "objectGL",
      "objectAccount",
      "valueFundBalances",
      "valueNetIncome",
      "fieldFPYearStart",
      "fieldFPYearEnd",
      "fieldFPYearStatus",
      "fieldFPYearActive",
      "fieldFPMonthStart",
      "fieldFPMonthEnd",
      "fieldGLStartBalance",
      "fieldGLRunningBalance",
      "fieldGLrc",
      "fieldAccNumber",
      "fieldAccType",
      "fieldAccTypeIncome",
      "fieldAccTypeExpense",
      "fieldAccTypeEquity",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingFPYearCloseCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.fpYearClose";
      super(attributes, process, AB, AccountingFPYearCloseDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingFPYearCloseDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingFPCloseDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingFPCloseDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 308:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

let AccountingJEArchiveDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "archive", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "AccountingJEArchive",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "processBatchValue",
      "objectBatch",
      "objectBalance",
      "objectJE",
      "objectJEArchive",

      "fieldBatchFiscalMonth",
      "fieldJeAccount",
      "fieldJeRC",
      "fieldJeArchiveBalance",
      "fieldBrFiscalMonth",
      "fieldBrAccount",
      "fieldBrRC",
      "fieldsMatch",
   ],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class AccountingJEArchiveCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.accounting.jeArchive";
      super(attributes, process, AB, AccountingJEArchiveDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return AccountingJEArchiveDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        AccountingBatchProcessingDefaults.settings.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.[someInstanceVariableHere]`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 4070:
/*!****************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceCalculateCore.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

let CalculateDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "calculator", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Calculate",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["formulaText"],
};

module.exports = class CalculateTaskCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.calculate";
      super(attributes, process, AB, CalculateDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return CalculateDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      const label = `${this.label}->Value`;
      // this is a calculate task, so let's include a fake ABFieldNumber
      // for the .field value, so other tasks that limit their operations
      // to fields can use this as a number
      if (!this._fakeNum) {
         this._fakeObj = this.AB.objectNew({});
         this._fakeNum = this.AB.fieldNew(
            { key: "number", name: label, label },
            this._fakeObj
         );
      }
      return {
         key: `${this.id}.value`,
         label,
         field: this._fakeNum,
      };
   }
};


/***/ }),

/***/ 95824:
/*!*******************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceCore.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessTaskServiceCore
 *
 * This defines the base Service Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a ServiceTask performs a dedicated operation on the server.
 *  - performing a query, looking up data, etc...
 *
 */
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessTaskServiceDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskService",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskServiceCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service";
      super(attributes, process, AB, ABProcessTaskServiceDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Service Task",
         actionName: "replace-with-service-task",
         className: "bpmn-icon-service",
         target: {
            type: "bpmn:ServiceTask",
         },
      };
   }

   /*
    fromValues(attributes) {
        /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        * /
        super.fromValues(attributes);

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            this[f] = attributes[f];
        });
    }
    */

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
    toObj() {
        var data = super.toObj();

        ABProcessTaskServiceDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
    */

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {
            userFormID: null,
            userFormResponse: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   /*
    processDataFields() {
        // in this Task, we can return the Response to the UserForm
        return [
            {
                key: `${this.id}.userFormResponse`,
                label: `${this.label}->Response`
            }
        ];
    }
    */

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   /*
    processData(instance, key) {
        var parts = key.split(".");
        if (parts[0] == this.id) {
            var myState = this.myState(instance);
            return myState[parts[1]];
        }
        return null;
    }
    */
};


/***/ }),

/***/ 13925:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

const ABProcessTaskGetResetPasswordUrlDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "GetResetPasswordUrl",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["email"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskGetResetPasswordUrlCore extends (
   ABProcessElement
) {
   constructor(attributes, process, AB) {
      attributes.type =
         attributes.type || "process.task.service.getResetPasswordUrl";
      super(attributes, process, AB, ABProcessTaskGetResetPasswordUrlDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskGetResetPasswordUrlDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return {
         key: `${this.id}.url`,
         label: `${this.label}->URL`,
      };
   }
};


/***/ }),

/***/ 7739:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceInsertRecordCore.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

let InsertRecordDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "InsertRecord",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "objectID",
      "fieldValues",
      "isRepeat",
      "repeatMode",
      "repeatColumn",
   ],
};

module.exports = class InsertRecordCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.insertRecord";
      super(attributes, process, AB, InsertRecordDefaults);

      this.results = [];

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return InsertRecordDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.isRepeat = JSON.parse(attributes.isRepeat || false);
   }

   get startElement() {
      let startElem = null;
      let currProcess = this.process;

      // Find the start (trigger) task
      while (!startElem && currProcess) {
         startElem = currProcess.elements(
            (elem) => elem?.defaults?.category == "start"
         )[0];

         // If .currProcess is a sub task, then go to the parent process for get the start task
         currProcess = currProcess.process;
      }

      return startElem;
   }

   get previousElement() {
      return this.process.connectionPreviousTask(this)[0];
   }

   get objectOfStartElement() {
      let startElem = this.startElement;
      if (!startElem) return null;

      let startElemObj = this.AB.objectByID(startElem.objectID);
      return startElemObj;
   }

   get objectOfPrevElement() {
      let prevElem = this.previousElement;
      if (!prevElem) return null;

      let objectID;
      switch (prevElem.type) {
         case "process.task.service.query":
            objectID = prevElem.qlObj ? prevElem.qlObj.objectID : null;
            break;
         case "process.task.service.insertRecord":
         default:
            objectID = prevElem.objectID;
            break;
      }

      return this.AB.objectByID(objectID);
   }

   get fieldRepeat() {
      let obj = this.objectOfStartElement;
      if (!obj) return null;

      return obj.fields((f) => f.id == this.repeatColumn)[0];
   }

   /**
    * processDataFields()
    * return a single available data field from this element
    * this will be the record inserted by this task
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return [
         {
            key: `${this.id}.[PK]`,
            label: `${this.label}-> Inserted record [PK]`,
            field: {
               id: this.id,
               object: { id: this.objectID },
               key: "InsertedRecord",
               columnName: "uuid",
            },
            object: this.objectID,
            set: true,
         },
      ];
   }
   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   /*
     toObj() {
         var data = super.toObj();
 
         AccountingBatchProcessingDefaults.settings.forEach((f) => {
             data[f] = this[f];
         });
 
         return data;
     }
     */

   ////
   //// Process Instance Methods
   ////
};


/***/ }),

/***/ 84224:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskServiceQueryCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

const ABQLManager = __webpack_require__(/*! ../../../platform/ql/ABQLManager.js */ 25433);

const ABProcessTaskServiceQueryDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskServiceQuery",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["qlObj"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskServiceQueryCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.query";
      super(attributes, process, AB, ABProcessTaskServiceQueryDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskServiceQueryDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Before we make instances of qlObj:
      this._datasources = [];

      // comvert our qlObj into an ABQLxxx instance.
      if (this.qlObj) {
         this.qlObj = ABQLManager.fromAttributes(this.qlObj, this, this.AB);
      }
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      const data = super.toObj();

      // convert qlObj into obj format:
      if (this.qlObj) data.qlObj = this.qlObj.toObj();

      return data;
   }

   registerDatasource(obj) {
      this._datasources.push(obj);
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        const myDefaults = {
            instanceVariable1: null,
            instanceVariable2: null
        };

        super.initState(context, myDefaults, val);
    }
    */

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // in this Task, we can return the Response to the UserForm
      let fields = null;

      if (this._datasources.length > 0) {
         fields = [];

         this._datasources.forEach((s) => {
            const param = s.processDataField(this.id, this.label);

            if (param) {
               fields.push(param);
            }
         });
      }

      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      const parts = key.split(".");

      if (parts[0] === this.id) {
         const myState = this.myState(instance);

         return myState[parts[1]];
      }

      return null;
   }
};


/***/ }),

/***/ 12307:
/*!**********************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskSubProcessCore.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

let SubProcessDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "object-group", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "SubProcess",
   // key: {string}
   // unique key to reference this specific Task

   settings: [
      "isEnable",
      "parameterId",
      "connectionAttrs",
      "elementIDs",
      "loopType",
   ],
};

const NOSPAM = {
   /*message : bool */
};
// prevent sending the same message over and over.

module.exports = class SubProcessCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.service.subProcess";
      super(attributes, process, AB, SubProcessDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return SubProcessDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "Sub Process",
         actionName: "replace-with-subprocess",
         className: "bpmn-icon-subprocess-expanded",
         target: {
            type: "bpmn:SubProcess",
            isExpanded: true,
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      // Convert string to boolean
      this.isEnable = this.isEnable == null ? true : JSON.parse(this.isEnable);

      let currElements = this._elements || {};
      this._unknownElementIDs = [];
      this._elements = {};
      (attributes.elementIDs || []).forEach((eID) => {
         let ele = this.AB.processElementNew(eID, this);
         if (ele) {
            this._elements[eID] = ele;
         } else {
            // current eID isn't one of our definitions yet, so might be
            // a temporary .diagramID from an unsaved task:
            if (currElements[eID]) {
               this._elements[eID] = currElements[eID];
            } else {
               this._unknownElementIDs.push(eID);
            }
         }
      });

      this._unknownElementIDs.forEach((eID) => {
         let key = `Process[${this.processID}] Task[${this.label}] is referencing an unknown element id:[${eID}]`;
         if (!NOSPAM[key]) {
            let err = new Error(key);
            this.AB.notify.builder(err, { processTask: this.id, eID });
            NOSPAM[key] = true;
         }
      });

      this._connections = attributes.connectionAttrs || {};
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      let data = super.toObj();

      data.elementIDs = [];
      for (let e in this._elements) {
         data.elementIDs.push(this._elements[e].id);
      }

      data.connectionAttrs = this._connections;

      return data;
   }

   /**
    * @method processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processDataFields(currElement) {
      if (this.parameterId == null) return [];

      // only call processDataFields once, filter it to get the different queries
      let dataFieldsAll = this.process.processDataFields(this) || [];

      // get the subtask data
      let dataFieldOpt = dataFieldsAll.filter(
         (opt) => opt.key === this.parameterId
      )[0];

      // get data from insert tasks
      let dataFieldsAllInserted = dataFieldsAll.filter(
         (opt) => (opt?.field?.key ?? opt?.field) === "InsertedRecord"
      );

      if (dataFieldOpt == null) return [];

      let result = [];

      // Connect field type
      if (
         dataFieldOpt.field &&
         dataFieldOpt.field.key == "connectObject" &&
         dataFieldOpt.field.datasourceLink &&
         dataFieldOpt.field.datasourceLink.fields
      ) {
         result.push({
            key: `${this.id}.uuid`,
            label: `${this.label}->Repeat Data.ID`,
            object: dataFieldOpt.field.datasourceLink,
         });

         dataFieldOpt.field.datasourceLink.fields().forEach((f) => {
            result.push({
               key: `${this.id}.${f.id}`,
               label: `${this.label}->Repeat Data.${f.label}`,
               field: f,
               object: f.object,
            });
         });
      }
      // Other field types
      else {
         result.push({
            key: dataFieldOpt.field
               ? `${this.id}.${dataFieldOpt.field.id}`
               : `${this.id}.subProcess`,
            label: `${this.label}->Repeat Data`,
            field: dataFieldOpt.field,
            object: dataFieldOpt.object,
         });
      }

      dataFieldsAllInserted.forEach((opt) => {
         result.push({
            key: `${opt.key || opt.id}`,
            label: `Parent Process Data->${opt.label}`,
            field: opt.field,
            object: opt.object,
         });
      });

      // Get any tasks that exist inside the subprocess
      let previousFields = this.process.processDataFields.call(
         this,
         currElement
      );
      if (previousFields && previousFields.length > 0) {
         result = result.concat(previousFields);
      }

      return result;
   }

   /**
    * @method processData()
    * return an array of avaiable ABObjects that are represented
    * by the data previous ProcessElements are working with.
    * @param {ABProcessElement} currElement
    *        the ABProcessElement that is requesting the data.
    * @return {array} | null
    */
   processData(currElement, params) {
      let instance = params[0];
      let key = params[1];
      let data;

      if (instance && key?.startsWith?.(this.id)) {
         let fieldId = key.split(".")[1];
         let myState = this.myState(instance);
         let stateData = myState ? myState.data : null;
         data = stateData;

         if (stateData && fieldId) {
            let dataFieldOpt = (
               this.process.processDataFields(this) || []
            ).filter((opt) => opt.key == this.parameterId)[0];

            if (dataFieldOpt?.field?.key == "connectObject") {
               if (!Array.isArray(stateData)) stateData = [stateData];

               // Extract data
               data = stateData.map((item) => {
                  if (fieldId == "uuid" || fieldId == "id") {
                     return item.uuid || item.id || item;
                  } else if (dataFieldOpt.field.datasourceLink) {
                     let returnField = dataFieldOpt.field.datasourceLink.fields(
                        (f) => f.id == fieldId
                     )[0];
                     if (returnField) return item[returnField.columnName];
                     else return item;
                  }
               });
            }
         }
      }

      // Filter none data items
      if (Array.isArray(data)) data = data.filter((d) => d != null);

      if (data == null || !data.length)
         data = this.process.processData.call(this, currElement, params);

      if (data == null || !data.length)
         data = this.process.processData(this, params);

      return data;
   }

   allPreviousTasks(...params) {
      return this.process.allPreviousTasks.call(this, ...params);
   }

   allPreviousConnectionsForElement(...params) {
      return this.process.allPreviousConnectionsForElement.call(
         this,
         ...params
      );
   }

   allPreviousConnectionsForConnection(...params) {
      return this.process.allPreviousConnectionsForConnection.call(
         this,
         ...params
      );
   }

   //
   // Diagram Elements
   //

   /**
    * @method connections()
    * return an array of connections that describe the relationships between
    * our process elements.
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return [{SimpleConnectionObj}]
    */
   connections(fn) {
      return this.process.connections.call(this, fn);
   }

   /**
    * @method connectionForDiagramID()
    * return the connection for the given diagram id
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionForDiagramID(dID) {
      if (!dID) return;

      return this.process.connectionForDiagramID.call(this, dID);
   }

   /**
    * @method connectionsIncoming()
    * return the connections that are entering this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsIncoming(dID) {
      if (!dID) return;

      return this.process.connectionsIncoming.call(this, dID);
   }

   /**
    * @method connectionsOutgoing()
    * return the connections that are leaving this Element
    * @param {string} dID
    *        the bpmn:Element diagram id
    */
   connectionsOutgoing(dID) {
      if (!dID) return;

      return this.process.connectionsOutgoing.call(this, dID);
   }

   /**
    * @method connectionRemove()
    * remove the connection info for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionRemove(element) {
      if (!element) return;

      this.process.connectionRemove.call(this, element);
   }

   /**
    * @method connectionSimplyElement()
    * given a BPMN diagram element, return a simplified object that describes
    * the connection between two elements.
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    * @return {SimpleConnectionObj}
    *        .id : {string} diagram id of the connection element
    *        .type : {string} the type of connection
    *        .from : {string} the diagram id of the source element
    *        .to : {string} the diagram id of the dest element
    */
   connectionSimplyElement(element) {
      if (!element) return;

      return this.process.connectionSimplyElement.call(this, element);
   }

   /**
    * @method connectionUpsert()
    * add or update the connection information for the given bpmn:element
    * @param {BMPNDiagramOBJ} element
    *        the {element} returned from the BPMN.io modeling library event.
    */
   connectionUpsert(element) {
      if (!element) return;

      this.process.connectionUpsert.call(this, element);
   }

   /**
    * @method connectionPreviousTask()
    * return the ABProcessElement(s) that was a previous Element
    * (eg connects to) this element.
    * @param {ABProcessElement} currElement
    * @return {array}
    */
   connectionPreviousTask(currElement) {
      if (!currElement) return;

      return this.process.connectionPreviousTask.call(this, currElement);
   }

   /**
    * @method elements()
    * return an array of elements that match the given filter (or all elements
    * if no filter is provided).
    * @param {fn} fn an iterator that returns true if the provided element
    *                should be returned.
    * @return {[ABProcessTask, ABProcessParticipant, etc...]}
    */
   elements(fn = () => true) {
      return this.process.elements.call(this, fn);
   }

   /**
    * @method elementAdd()
    * insert an element to be tracked by this process.
    * @param {ABProcessElement} element
    *        the full instance of an ABProcessElement to track.
    */
   elementAdd(element) {
      if (!element) return;

      this.process.elementAdd.call(this, element);
   }

   /**
    * @method elementForDiagramID()
    * return the object that is tied to the given xml diagram ID.
    * @param {string} dID the diagram ID
    * @return {ABProcess[OBJ]}
    */
   elementForDiagramID(dID) {
      if (!dID) return null;

      return this.process.elementForDiagramID.call(this, dID);
   }

   /**
    * @method elementRemove()
    * remove an element from being tracked by this process.
    * @param {obj|ABProcessElement} def
    *        a definition of, or full Object instance of the ABProcessElement
    *        to remove.
    */
   elementRemove(def) {
      if (!def) return;

      this.process.elementRemove.call(this, def);
   }
};


/***/ }),

/***/ 92940:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserApprovalCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

const ABFieldList = __webpack_require__(/*! ../../../platform/dataFields/ABFieldList.js */ 34963);

var ABProcessTaskApprovalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "check-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "Approval",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "formBuilder"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskUserApprovalCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user.approval";
      super(attributes, process, AB, ABProcessTaskApprovalDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskApprovalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   fromValues(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */
      super.fromValues(attributes);

      function fixBoolean(obj) {
         if (obj) {
            Object.keys(obj).forEach((k) => {
               if (obj[k] == "false") {
                  obj[k] = false;
               } else if (obj[k] == "true") {
                  obj[k] = true;
               } else if (typeof obj[k] == "object") {
                  fixBoolean(obj[k]);
               }
            });
         }
      }
      fixBoolean(this.formBuilder);
   }

   /**
    * @method toObj()
    * properly compile the current state of this object instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   /*     
    toObj() {
        var data = super.toObj();

        ABProcessTaskApprovalDefaults.fields.forEach((f) => {
            data[f] = this[f];
        });

        return data;
    }
*/
   ////
   //// Process Instance Methods
   ////

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   /*
    initState(context, val) {
        var myDefaults = {};
        ABProcessTaskApprovalDefaults.instanceValues.forEach((v) => {
            myDefaults[v] = null;
        });

        super.initState(context, myDefaults, val);
    }
*/

   /*
    * preProcessFormIOComponents()
    * we need to parse the form.io components to ensure the proper columnName
    * and labels are being used. We also will translate the columnNames at this
    * point in the code
    */
   preProcessFormIOComponents() {
      var fields = this.process.processDataFields(this);
      if (fields && this.formBuilder && this.formBuilder.components) {
         this.formBuilder.components.forEach((c) => {
            if (c.abFieldID) {
               fields.filter((entry) => {
                  if (entry.field?.id == c.abFieldID) {
                     c.label = entry.field.label;
                     c.key = entry.key;
                     if (c.data?.values && entry.field.settings.options) {
                        var vals = [];
                        entry.field.settings.options.forEach((opt) => {
                           vals.push({
                              label: opt.text,
                              value: opt.id,
                           });
                        });
                        c.data.values = vals;
                     }
                  }
               });
            } else if (c.components && c.components.length) {
               c.key = c.path;
               c.components.forEach((o) => {
                  if (o.abFieldID) {
                     // these are plucked conneted values
                     // gather up all their fields to be used
                     var pluck = fields.filter((f) => {
                        return f.key == c.path;
                     })[0];
                     if (!pluck) return;
                     pluck.object.fields().filter((entry) => {
                        if (entry?.id == o.abFieldID) {
                           o.label = entry.label;
                           o.key = entry.columnName;
                           if (o.data?.values && entry.settings.options) {
                              var vals = [];
                              entry.settings.options.forEach((opt) => {
                                 vals.push({
                                    label: opt.text,
                                    value: opt.id,
                                 });
                              });
                              o.data.values = vals;
                           }
                        }
                     });
                  }
               });
            }
         });
      }
      return this.formBuilder;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      // we need to get the button events defined by the form.io formBuilder
      var options = [];
      this.formBuilder.components.forEach((comp) => {
         if (comp.type == "button" && comp.action == "event" && comp.event) {
            options.push({
               id: comp.event,
               text: comp.label,
            });
         }
      });
      // in this Task, we can return the Response to the UserForm
      // The Response can be in the form of a List Field, with one or more
      // return options.

      var myID = this.diagramID;

      // create an ABFieldList object:
      // make sure the options follow what is currently defined for our
      // responses:
      var myObj = this.AB.objectNew({});
      var listField = new ABFieldList(
         {
            id: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            columnName: `${myID}.userFormResponse`,
            settings: {
               options: options,
            },
         },
         myObj
      );

      // NOTE: We are pretending our response is a type of ABFieldList. But our
      // ABField objects no longer allow "." in our columnNames:
      //    ( https://github.com/digi-serve/appbuilder_class_core/blob/212cf5fa1c1d5c959aa246c730582ed50809ee0f/dataFields/ABFieldCore.js#L262 )
      // But our Process tasks really will be expecting it there so lets put
      // it back:
      listField.columnName = `${myID}.userFormResponse`;

      return [
         {
            key: `${myID}.userFormResponse`,
            label: `${this.label}->Response`,
            field: listField,
            object: null,
         },
      ];
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      if (key) {
         var parts = key.split(".");
         if (parts[0] == this.diagramID) {
            var myState = this.myState(instance);
            return myState[parts[1]];
         }
      }
      return null;
   }
};


/***/ }),

/***/ 50271:
/*!****************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserCore.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessTaskUserCore
 *
 * This defines the base User Task element that can be placed on a BPMN
 * diagram.  In our system, we will let the designer choose a sub class
 * to make active for this element.
 *
 * Currently a UserTask expects a human user to perform an action.  These
 * actions are in the possible forms:
 *  - confirm offline action
 *  - approve data
 *  - fill out a form
 *
 */

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessTaskUserDefaults = {
   category: "task",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "user", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: [],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "TaskUser",
   // key: {string}
   // unique key to reference this specific Task

   settings: [],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

module.exports = class ABProcessTaskUserCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "process.task.user";
      super(attributes, process, AB, ABProcessTaskUserDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserDefaults;
   }

   static DiagramReplace() {
      // taken from "bpmn-js/lib/features/replace/ReplaceOptions"
      return {
         label: "User Task",
         actionName: "replace-with-user-task",
         className: "bpmn-icon-user",
         target: {
            type: "bpmn:UserTask",
         },
      };
   }

   ////
   //// Process Instance Methods
   ////

   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // for testing:
   //         var myState = this.myState(instance);
   //         myState.status = "completed";
   //         this.log(instance, "Email Sent successfully");
   //         resolve(true);
   //     });
   // }

   /**
    * initState()
    * setup this task's initial state variables
    * @param {obj} context  the context data of the process instance
    * @param {obj} val  any values to override the default state
    */
   initState(context, val) {
      var myDefaults = {
         roles: [],
         ui: null,
      };

      super.initState(context, myDefaults, val);
   }
};


/***/ }),

/***/ 10153:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTaskUserExternalCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

const ABProcessTaskUserExternalDefaults = {
   category: null,
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   icon: "plus-circle", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   instanceValues: ["userFormID", "userFormResponse"],
   // instanceValues: {array}
   // a list of values this element tracks as it is operating in a process.

   key: "External",
   // key: {string}
   // unique key to reference this specific Task

   settings: ["who", "toUsers", "url"],
   // settings: {array}
   // a list of internal setting values this Element tracks. These are the
   // values set by the platform .propertiesStash()
};

const settings = {
   who: 0,
   toUsers: null,
   url: "",
};

module.exports = class ABProcessTaskUserExternalCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      for (const key in settings)
         attributes[key] = attributes[key] ?? settings[key];
      super(
         Object.assign(
            {
               type: "process.task.service.external",
            },
            attributes
         ),
         process,
         AB,
         ABProcessTaskUserExternalDefaults
      );

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskUserExternalDefaults;
   }

   static DiagramReplace() {
      return null;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      return [
         {
            key: `${this.id}.userFormResponse`,
            label: `${this.label}->Response`,
         },
      ];
   }
};


/***/ }),

/***/ 44310:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElement = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessElement.js */ 25330);

var ABProcessTriggerDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "Trigger",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTriggerCore extends ABProcessElement {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTriggerDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTriggerDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Signal Start Event",
         actionName: "replace-with-signal-start",
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "bpmn:SignalEventDefinition",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.triggerKey = attributes.triggerKey || "triggerKey.??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.triggerKey = this.triggerKey;

      return data;
   }
};


/***/ }),

/***/ 86555:
/*!************************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerLifecycleCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTrigger = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 19010);

var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "objectID",
      "lifecycleKey" /* , "triggerKey" is tracked in ABProcessTrigger */,
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "key",
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TriggerLifecycle",
   // key: {string}
   // unique key to reference this specific Task
};

module.exports = class ABProcessTriggerLifecycle extends ABProcessTrigger {
   constructor(attributes, process, AB) {
      attributes.type = attributes.type || "trigger";
      super(attributes, process, AB, ABProcessTaskTriggerLifecycleDefaults);

      // listen
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Object Lifecycle Trigger",
         actionName: "replace-with-signal-lifecycle-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-signal",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalLifecycle",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.objectID = attributes.objectID || "objID.??";
      this.lifecycleKey = attributes.lifecycleKey || "lifecycle.key??";
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.objectID = this.objectID;
      data.lifecycleKey = this.lifecycleKey;
      return data;
   }

   /**
    * processDataFields()
    * return an array of avaiable data fields that this element
    * can provide to other ProcessElements.
    * Different Process Elements can make data available to other
    * process Elements.
    * @return {array} | null
    */
   processDataFields() {
      var fields = null;
      if (this.objectID) {
         fields = [];
         var object = this.AB.objectByID(this.objectID);
         if (object) {
            var myID = this.diagramID;
            object.fields().forEach((field) => {
               fields.push({
                  key: `${myID}.${field.id}`,
                  label: `${this.label}->${object.label}->${field.label}`,
                  field,
                  object,
               });
            });
            fields.push({
               key: `${myID}.uuid`,
               label: `${this.label}->${object.label}`,
               field: null,
               object,
            });
         } else {
            // OK, so we have an this.objectID defined, but we can't find it.
            // that's something we need to alert:
            var error = new Error(
               `ABProcessTriggerLifecycleCore.processDataFields():TaskID[${this.id}]: could not find referenced object by ID [${this.objectID}]`
            );
            this.AB.notify.builder(error, {
               task: this.id,
               objID: this.objectID,
            });
         }
      }
      return fields;
   }

   /**
    * processData()
    * return the current value requested for the given data key.
    * @param {obj} instance
    * @return {mixed} | null
    */
   processData(instance, key) {
      var parts = key.split(".");
      if (parts[0] == this.diagramID) {
         var myState = this.myState(instance);
         if (myState["data"]) {
            var object = this.AB.objectByID(this.objectID);
            var field = object.fields((f) => {
               return f.id == parts[1];
            })[0];
            if (field) {
               if (parts[2]) {
                  return field[parts[2]].call(field, myState["data"]);
               } else {
                  // instance.context.data[field.column_name];
                  // if field is "calculate" or "TextFormula" data is not stored
                  // in data base and we need to run format method
                  if (["calculate", "TextFormula"].indexOf(field.key) != -1) {
                     return field.format(myState["data"]);
                  } else if (
                     field.key == "connectObject" ||
                     field.key == "user"
                  ) {
                     return (
                        myState["data"][field.relationName()] ||
                        myState["data"][field.columnName]
                     );
                  } else {
                     return myState["data"][field.columnName];
                  }
               }
            } else if (parts[1] == "uuid") {
               return myState["data"]["uuid"];
            } else {
               ///
               /// Questioning the validity of this section of code.
               /// In order to get here, we tried to find field, and it
               /// didn't exist.
               /// then we turn around and REPEAT the same attempt
               /// and check for field again.
               /*
               // parts[1] should be a field.id
               object = this.AB.objectByID(this.objectID);
               field = object.fields((f) => {
                  return f.id == parts[1];
               })[0];
               if (field) {
                  if (parts[2]) {
                     return field[parts[2]].call(field, myState["data"]);
                  } else {
                     // instance.context.data[field.column_name];
                     return myState["data"][field.columnName];
                  }
               }
               */
            }
         }
      }
      return null;
   }

   /**
    * processDataObjects()
    * return an array of avaiable ABObjects that this element
    * can provide to other ProcessElements.
    * @return {array} | null
    */
   processDataObjects() {
      var objects = null;
      if (this.objectID) {
         objects = [this.AB.objectByID(this.objectID)];
      }
      return objects;
   }
};


/***/ }),

/***/ 47843:
/*!********************************************************************!*\
  !*** ./AppBuilder/core/process/tasks/ABProcessTriggerTimerCore.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTrigger = __webpack_require__(/*! ../../../platform/process/tasks/ABProcessTrigger.js */ 19010);

var ABProcessTaskTriggerLifecycleDefaults = {
   category: "start",
   // category: {string} | null
   // if this Element should show up on one of the popup replace menus, then
   // specify one of the categories of elements it should be an option for.
   // Available choices: [ "start", "gateway", "task", "end" ].
   //
   // if it shouldn't show up under the popup menu, then leave this null

   fields: [
      "repeatEvery",
      "repeatTime",
      "repeatDaily",
      "repeatWeekly",
      "repeatMonthly",
      "isEnabled",
   ],
   // fields: {array}
   // a list of internal setting values this Element tracks

   icon: "clock-o", // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'
   // icon: {string}
   // font-awesome icon reference.  (without the 'fa-').  so 'user'  to reference 'fa-user'

   key: "TimerStartEvent",
   // key: {string}
   // unique key to reference this specific Task

   repeatEvery: "daily",
   repeatTime: "01:00",
   repeatDaily: "day",
   repeatWeekly: "FRI",
   repeatMonthly: "last",
   isEnabled: true,
};

module.exports = class ABProcessTriggerTimer extends ABProcessTrigger {
   constructor(attributes, process, application) {
      attributes.type = attributes.type || "trigger";
      super(
         attributes,
         process,
         application,
         ABProcessTaskTriggerLifecycleDefaults
      );
   }

   // return the default values for this DataField
   static defaults() {
      return ABProcessTaskTriggerLifecycleDefaults;
   }

   static DiagramReplace() {
      return {
         label: "Timer Start Event",
         actionName: "replace-with-signal-timer-start",
         // type: {string} a unique key to reference this element
         className: "bpmn-icon-start-event-timer",
         target: {
            type: "bpmn:StartEvent",
            // type: {string} the general bpmn category
            //      "StartEvent", "Task", "EndEvent", "ExclusiveGateway"
            eventDefinitionType: "ab:SignalTriggerTimer",
         },
      };
   }

   fromValues(attributes) {
      super.fromValues(attributes);

      this.repeatEvery =
         attributes.repeatEvery ||
         ABProcessTaskTriggerLifecycleDefaults.repeatEvery;

      this.repeatDaily =
         attributes.repeatDaily ||
         ABProcessTaskTriggerLifecycleDefaults.repeatDaily;

      this.repeatWeekly =
         attributes.repeatWeekly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatWeekly;

      this.repeatMonthly =
         attributes.repeatMonthly ||
         ABProcessTaskTriggerLifecycleDefaults.repeatMonthly;

      // Convert UTC to local time
      if (attributes.repeatTime) {
         let timeVals = attributes.repeatTime.split(":");
         let currDate = new Date();
         currDate.setUTCHours(timeVals[0]);
         currDate.setUTCMinutes(timeVals[1]);
         this.repeatTime = `${currDate.getHours()}:${currDate.getMinutes()}`;
      } else {
         this.repeatTime = ABProcessTaskTriggerLifecycleDefaults.repeatTime;
      }

      if (typeof attributes.isEnabled != "undefined") {
         this.isEnabled = JSON.parse(attributes.isEnabled);
      } else {
         this.isEnabled = ABProcessTaskTriggerLifecycleDefaults.isEnabled;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var data = super.toObj();

      data.repeatEvery = this.repeatEvery;
      data.repeatDaily = this.repeatDaily;
      data.repeatWeekly = this.repeatWeekly;
      data.repeatMonthly = this.repeatMonthly;

      // Convert local time to UTC
      data.repeatTime = this.repeatTime;
      if (data.repeatTime && data.repeatTime instanceof Date) {
         data.repeatTime = `${data.repeatTime.getUTCHours()}:${data.repeatTime.getMinutes()}`;
      }

      data.isEnabled = this.isEnabled;

      return data;
   }

   getCronExpression() {
      let timeVals = this.repeatTime.split(":");
      let second = "*";
      let minute = timeVals[1];
      let hour = timeVals[0];
      let day;
      let month;
      let dayWeek;
      let year = "*";

      switch (this.repeatEvery) {
         case "daily":
            day = "*";
            month = "*";
            dayWeek = this.repeatDaily == "weekday" ? "1-5" : "*";
            break;
         case "weekly":
            day = "*";
            month = "*";
            dayWeek = this.repeatWeekly;
            break;
         case "monthly":
            day = this.repeatMonthly;
            month = "*";
            dayWeek = "*";
            break;
      }

      return `${second} ${minute} ${hour} ${day} ${month} ${dayWeek} ${year}`;
   }
};


/***/ }),

/***/ 61614:
/*!****************************************!*\
  !*** ./AppBuilder/core/ql/ABQLCore.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */
var ABEmitter = __webpack_require__(/*! ../../platform/ABEmitter */ 26263);
class ABQLCore extends ABEmitter {
   constructor(attributes, parameterDefinitions, prevOP, task, AB) {
      super();

      // manage the incoming Parameter Definitions
      if (!Array.isArray(parameterDefinitions)) {
         parameterDefinitions = [parameterDefinitions];
      }

      this.parameterDefinitions = parameterDefinitions;

      this.object = prevOP ? prevOP.object : null;
      // {ABObject}
      // The current {ABObject} the current Query Language Operation is associated
      // with.

      // if the previous Operation defined an .objectOut then our .object is THAT
      // one.
      if (prevOP && prevOP.objectOut) this.object = prevOP.objectOut;

      this.prevOP = prevOP;
      this.task = task;
      // {ABProcessTaskxxx}
      // This is running under a specific ABProcessTaskServiceQuery.  When
      // searching for data from the Process, we must go through this.task
      // to do so.

      this.AB = AB;
      this.next = null;

      this.fromAttributes(attributes);
   }

   ///
   /// Instance Methods
   ///
   initObject(attributes) {}

   fromAttributes(attributes) {
      /*
        {
            id: uuid(),
            name: 'name',
            type: 'xxxxx',
            json: "{json}"
        }
        */

      // super.fromValues(attributes);
      this.key = this.constructor.key ?? null;

      // this.entryComplete = attributes.entryComplete || false;
      this.params = attributes.params ?? {};
      // {hash}
      // The configuration values entered by the AppBuilder UI for this
      // operation.

      this.objectID = attributes.objectID || null;

      // be sure to do a hard lookup if an objectID was saved:
      if (this.objectID) this.object = this.objectLookup(this.objectID);

      this.initObject(attributes);

      // at least dump a warning here:
      if (this.objectID && !this.object)
         this.AB.notify.developer(
            new Error(
               `ABQLCore.fromAttributes(): unable to initialize ABObject [${this.objectID}]`
            ),
            {
               attributes,
               objectID: this.objectID,
            }
         );

      if (attributes.next) {
         let nextOP = null;

         (this.NextQLOps ?? this.constructor.NextQLOps).forEach((OP) => {
            if (OP.key === attributes.next.key) nextOP = OP;
         });

         if (nextOP) {
            // exact match, so add next:
            const qlOP = new nextOP(attributes.next, this, this.task, this.AB);

            this.next = qlOP;
         }
      }
   }

   /**
    * @method objectLookup()
    * return a matching {ABObject} that is represented by the given id.
    * NOTE: we will try to match on: our initial .objectID first, then
    * the given objID.
    * NOTE: this will match an object.id as well as object.label
    * @param {string} objID
    */
   objectLookup(objID) {
      return this.AB.objects((o) => {
         const quotedLabel = `"${o.label}"`;

         return (
            // o.id === this.objectID ||
            o.id === objID || quotedLabel.indexOf(objID) === 0
         );
      })[0];
   }

   /**
    * @method availableProcessDataFieldsHash()
    * return a { "field.key" => {processFieldDef} } hash of the currently
    * available fields in the process.
    * @return {obj}
    */
   availableProcessDataFieldsHash() {
      const availableProcessDataFields =
         this.task.process.processDataFields(this.task) ?? [];
      const hashFieldIDs = {};

      availableProcessDataFields.forEach((f) => {
         if (f.field) {
            hashFieldIDs[f.field.id] = f;
         } else {
            hashFieldIDs[f.key] = f;
         }
      });

      return hashFieldIDs;
   }

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {}

   /**
    * @method toObj()
    * properly compile the current state of this ABQL instance
    * into the values needed for saving to the DB.
    * @return {json}
    */
   toObj() {
      const obj = {
         key: this.constructor.key,
         // entryComplete: this.entryComplete,
         params: this.params,
         // currQuery: this.currQuery,
         // queryValid: this.queryValid,
         objectID: this.object?.id ?? null,
      };

      if (this.next) {
         obj.next = this.next.toObj();
      }

      return obj;
   }
}

module.exports = ABQLCore;


/***/ }),

/***/ 64732:
/*!********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLFindCore.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLFindCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);
const NextQLOps = __webpack_require__(/*! ./ABQLSet.js */ 49830);
// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLFind task is complete.  In this case the {ABQLSet} operations come
// next.  {ABQLSet} operations work on a Set|{Array} or data results.

const ParameterDefinitions = [
   {
      type: "objectConditions",
      name: "cond",
   },
];

class ABQLFindCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLFindCore.key = "find";
ABQLFindCore.label = "find";
ABQLFindCore.NextQLOps = NextQLOps;

module.exports = ABQLFindCore;


/***/ }),

/***/ 45430:
/*!***********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLManagerCore.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLManagerCore
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */

const QLObject = __webpack_require__(/*! ../../platform/ql/ABQLRootObject.js */ 39700);
const QLOps = [QLObject];

const ABQLManagerCore = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current ABFactory we are operating under.
    * @return {ABQL} | null
    */
   fromAttributes: function (attributes, task, AB) {
      if (!attributes) return null;

      const matchingOPs = [];

      ABQLManagerCore.QLOps.forEach((Op) => {
         if (Op.key === attributes.key) matchingOPs.push(Op);
      });

      if (matchingOPs.length === 1) {
         // let this Operation initialize and return the last OP
         // in the chain
         const qlOP = new matchingOPs[0](attributes, task, AB);

         return qlOP;
      } else return null;
   },

   /**
    * @array QLOps
    * An array of the root QL Operations.
    */
   QLOps: QLOps,
};
module.exports = ABQLManagerCore;


/***/ }),

/***/ 45655:
/*!**************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRootObjectCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRootObjectCore
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);

// Define the Operations that can be performed off of a RootObject.
// Each Root Object might have a different set of Operations, so we
// define them here.
const QLFind = __webpack_require__(/*! ../../platform/ql/ABQLFind.js */ 88484);
const NextQLOps = [QLFind];

const ParameterDefinitions = [
   {
      type: "objectName",
      name: "name",
   },
];

class ABQLObjectCore extends ABQL {
   constructor(attributes, task, AB) {
      // NOTE: keep this so we can insert the prevOp == null
      super(attributes, ParameterDefinitions, null, task, AB);
   }

   ///
   /// Instance Methods
   ///
   initObject(/* attributes */) {
      if (!this.object && this.params) {
         const objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type === "objectName";
         });

         if (objNameDef) {
            this.objectID = this.params[objNameDef.name];
            this.object = this.objectLookup(this.objectID);
         }

         if (!this.object) {
            // This function exists on platform_web but not platform_service
            this.warningMessage?.("has no object set.", {
               objectID: this.objectID,
            });
         }
      }
   }

   toObj() {
      const obj = super.toObj();

      // if we don't have an objectID, but we have an objectName parameter
      // definition then save that as our objectID
      if (!obj.objectID && this.params) {
         const objNameDef = this.parameterDefinitions.find((pDef) => {
            return pDef.type === "objectName";
         });

         if (objNameDef) obj.objectID = this.params[objNameDef.name];
      }

      return obj;
   }
}

ABQLObjectCore.key = "object";
ABQLObjectCore.label = "object";
ABQLObjectCore.NextQLOps = NextQLOps;

module.exports = ABQLObjectCore;


/***/ }),

/***/ 2321:
/*!***************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRow.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRow
 *
 * Defines all the QL operations that can be performed on a Row of data. This is a
 * Single row/instance of an object.
 *
 */

const QLUpdate = __webpack_require__(/*! ../../platform/ql/ABQLRowUpdate.js */ 19602);
const QLSave = __webpack_require__(/*! ../../platform/ql/ABQLRowSave */ 63622);
const QLPluck = __webpack_require__(/*! ../../platform/ql/ABQLRowPluck */ 93725);

module.exports = [QLUpdate, QLSave, QLPluck];


/***/ }),

/***/ 38109:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRowPluckCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLRowPluckCore
 *
 * An ABQLRowPluckCore can process a value of data and puck out a specified
 * field to then make an object of values that only contain that field.
 *
 */

// const ABQLValue = require("./ABQLValue.js");
// const ABQLSet = require("./ABQLSet.js");
const ABQLSetPluck = __webpack_require__(/*! ../../platform/ql/ABQLSetPluck.js */ 6517);
const ABQLRowUpdate = __webpack_require__(/*! ../../platform/ql/ABQLRowUpdate.js */ 19602);
const ABQLRowSave = __webpack_require__(/*! ../../platform/ql/ABQLRowSave.js */ 63622);

class ABQLRowPluckCore extends ABQLSetPluck {
   // Dynamic NextQLOps
   get NextQLOps() {
      let nextQLOps = [];

      const field = this.field ?? this.object.fieldByID(this.fieldID) ?? null;

      // Update .NextQLOps WARN: update to static it affects to every ABQLRowPluck instances.
      switch (field?.key) {
         // M:1 M:N connect field, then set ABQLSet to next steps
         case "connectObject":
            if (field.settings.linkType === "many") {
               // NOTE: Could not require("./ABQLSet.js") on the top. It returns an empty object. Why ><
               const ABQLSet = __webpack_require__(/*! ./ABQLSet.js */ 49830);

               nextQLOps = ABQLSet;

               break;
            }

            // return ABQLRow.js
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) =>
                  NextQLOp.key === this.constructor.key ||
                  NextQLOp.key === ABQLRowUpdate.key
            );

            break;

         case "user":
            // TODO set this up corectlys
            if (
               field.settings.linkType === "many" ||
               field.settings.isMultiple // may be unnessicary
            ) {
               // NOTE: Could not require("./ABQLSet.js") on the top. It returns an empty object. Why ><
               const ABQLSet = __webpack_require__(/*! ./ABQLSet.js */ 49830);

               nextQLOps = ABQLSet;

               break;
            }

            // default
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) =>
                  NextQLOp.key === this.constructor.key ||
                  NextQLOp.key === ABQLRowUpdate.key ||
                  NextQLOp.key === ABQLRowSave.key
            );

            break;

         default:
            // Normal field and _PK
            nextQLOps = this.prevOP.constructor.NextQLOps.filter(
               (NextQLOp) => NextQLOp.key === ABQLRowSave.key
            );

            break;
      }

      return nextQLOps;
   }
}

ABQLRowPluckCore.key = "row_pluck";
ABQLRowPluckCore.label = "Read the value from the field";
ABQLRowPluckCore.NextQLOps = []; // Static NextQLOps

module.exports = ABQLRowPluckCore;


/***/ }),

/***/ 39580:
/*!***********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRowSaveCore.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLRowSaveCore
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLSetSave = __webpack_require__(/*! ../../platform/ql/ABQLSetSave.js */ 23698);

class ABQLRowSaveCore extends ABQLSetSave {}

ABQLRowSaveCore.key = "row_save";
ABQLRowSaveCore.label = "Save the value as";
ABQLRowSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

module.exports = ABQLRowSaveCore;


/***/ }),

/***/ 47947:
/*!*************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLRowUpdateCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowUpdateCore
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);
// const ABQLRow = require("./ABQLRow.js");

const ParameterDefinitions = [
   {
      type: "objectValues",
      name: "values",
   },
];

class ABQLRowUpdateCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   }

   ///
   /// Instance Methods
   ///
}

ABQLRowUpdateCore.key = "update";
ABQLRowUpdateCore.label = "Update this record";
ABQLRowUpdateCore.NextQLOps = [];
// NOTE: .NextQLOps => see the #Hack in the constructor

module.exports = ABQLRowUpdateCore;


/***/ }),

/***/ 49830:
/*!***************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSet.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSet
 *
 * Here we define the group of operations that can be performed on a SET of data.
 * A SET is an array of objects/row data.
 *
 */

module.exports = [
   __webpack_require__(/*! ../../platform/ql/ABQLSetFirst.js */ 21790),
   __webpack_require__(/*! ../../platform/ql/ABQLSetPluck.js */ 6517),
   __webpack_require__(/*! ../../platform/ql/ABQLSetSave.js */ 23698),
];


/***/ }),

/***/ 1947:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetFirstCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetFirstCore
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);
const ABQLRow = __webpack_require__(/*! ./ABQLRow.js */ 2321);
// {array} of {ABQLxxx} options
// this is an array of what possible next Operations can come after an
// ABQLSetFirst task is complete.  In this case the {ABQLRow} operations come
// next.  {ABQLRow} operations work on a single row of data.

class ABQLSetFirstCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, [], prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///
}

ABQLSetFirstCore.key = "first";
ABQLSetFirstCore.label = "Select the first record";
ABQLSetFirstCore.NextQLOps = ABQLRow;

module.exports = ABQLSetFirstCore;


/***/ }),

/***/ 93740:
/*!************************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetPluckCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetPluckCore
 *
 * An ABQLSetPluck can process a set (array) of data and puck out a specified
 * field to then make an array of values that only contain that field.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);
// const ABQLSet = require("./ABQLSet.js");

const ParameterDefinitions = [
   {
      type: "objectFields",
      name: "fieldID",
   },
];

class ABQLSetPluckCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      // we need to gather our .field and .objectOut before we
      // allow our base class to continue forward:

      this.fieldID = attributes.fieldID;
      this.field = this.object?.fieldByID(this.fieldID);

      //// TODO: figure out how to dynamically update the next row of options
      //// based upon the current choice of field.
      // // based upon the type of field, we now configure what next steps
      // // are available.
      // if (this.field) {
      //    // if connected, then we can stay with same .NextQLOps
      //    // so we can just leave what we did above.

      //    // if a discreet value, then we need to remove SetPluck
      //    if (!this.field.isConnection) {
      //       this.constructor.NextQLOps = [
      //          ...this.prevOP.constructor.NextQLOps,
      //       ].filter((o) => o.key != this.constructor.key);
      //    }
      // }

      if (attributes.objectOutID)
         this.objectOut = this.objectLookup(attributes.objectOutID);

      super.fromAttributes(attributes);
   }

   toObj() {
      const obj = super.toObj();

      if (this.fieldID) {
         obj.fieldID = this.fieldID;

         if (this.objectOut) obj.objectOutID = this.objectOut.id;
      } else {
         obj.fieldID = this.params.field || null;

         const field = this.object.fieldByID(obj.fieldID);

         if (field?.isConnection) obj.objectOutID = field.datasourceLink.id;
      }

      return obj;
   }
}

ABQLSetPluckCore.key = "set_pluck";
ABQLSetPluckCore.label = "Read the value from the field";
ABQLSetPluckCore.NextQLOps = [];

module.exports = ABQLSetPluckCore;


/***/ }),

/***/ 86918:
/*!***********************************************!*\
  !*** ./AppBuilder/core/ql/ABQLSetSaveCore.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
/*
 * ABQLSetSaveCore
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQL = __webpack_require__(/*! ../../platform/ql/ABQL.js */ 15544);

const ParameterDefinitions = [
   {
      type: "taskParam",
      name: "task_param",
   },
];

class ABQLSetSaveCore extends ABQL {
   constructor(attributes, prevOP, task, AB) {
      super(attributes, ParameterDefinitions, prevOP, task, AB);

      // TODO: register with the task that we can provide data.
      if (this.taskParam) {
         task.registerDatasource(this);
         this.registered = true;
      }
   }

   ///
   /// Instance Methods
   ///

   fromAttributes(attributes) {
      // #Hack! : when an Operation provides the same .NextQlOps that it
      // was defined in, we can't require it again ==> circular dependency.
      // so we manually set it here from the operation that created us:
      this.constructor.NextQLOps = this.prevOP.constructor.NextQLOps;

      super.fromAttributes(attributes);

      this.taskParam = attributes.taskParam || this.params.task_param;
   }

   toObj() {
      const obj = super.toObj();

      obj.taskParam = this.taskParam || this.params.task_param;

      return obj;
   }

   processDataField(id, label) {
      // we have to report back on:
      // key:  id.taskParam
      // label: label->taskParam
      // object: ABObject
      // field: ABField
      // set : {bool}

      let field = null;
      // {ABField}
      // if the value being stored is NOT a connectObject, then it is
      // a particular field in the previous object.

      // if we are saving a specific field of an Object, pass that
      // ABField along:
      if (this.prevOP?.field?.key !== "connectObject")
         field = this?.prevOP?.field;

      return {
         key: `${id}.${this.taskParam || this.params.task_param}`,
         label: `${label}->${this.taskParam || this.params.task_param}`,
         field: field,
         object: this.object,
         set: true,
      };
   }
}

ABQLSetSaveCore.key = "set_save";
ABQLSetSaveCore.label = "Save the value as";
ABQLSetSaveCore.NextQLOps = [];
// NOTE: currently, this is an ending step. but it doesn't have to be...

module.exports = ABQLSetSaveCore;


/***/ }),

/***/ 88076:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCSVExporterCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewCSVExporterDefaults = {
   key: "csvExporter", // unique key identifier for this ABViewForm
   icon: "download", // icon reference: (without 'fa-' )
   labelKey: "CSV Exporter", // {string} the multilingual label key for the class label
};

const ABViewCSVExporterPropertyComponentDefaults = {
   dataviewID: null,
   where: null,
   buttonLabel: "Export CSV",
   filename: "exportCSV",
   hasHeader: true,
   width: 150,
};

module.exports = class ABViewCSVExporterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewCSVExporterDefaults
      );
   }

   static common() {
      return ABViewCSVExporterDefaults;
   }

   static defaultValues() {
      return ABViewCSVExporterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert to boolean
      if (typeof values.settings.hasHeader == "string")
         this.settings.hasHeader = JSON.parse(values.settings.hasHeader);

      if (this.settings.hasHeader == null)
         this.settings.hasHeader =
            ABViewCSVExporterPropertyComponentDefaults.hasHeader;

      // convert from "0" => 0
      this.settings.width = parseInt(
         values.settings.width ||
            ABViewCSVExporterPropertyComponentDefaults.width
      );
   }
};


/***/ }),

/***/ 22152:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCSVImporterCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 95652);

const ABViewCSVImporterDefaults = {
   key: "csvImporter",
   // {string}
   // unique key identifier for this ABViewForm

   icon: "upload",
   // {string}
   // font-awesome icon reference: (without 'fa-' )

   labelKey: "CSV Importer",
   // {string}
   // the multilingual label key for the class label
   // NOTE: will be used as L(labelKey)
};

const ABViewCSVImporterPropertyComponentDefaults = {
   dataviewID: null,
   // {uuid}
   // The ABDataCollection.uuid that we are using to store the data.
   // NOTE: we actually use the DC to get the ABObject it is connected to.

   availableFieldIds: [],
   //{array}
   // A list of ABField.ids that are allowed to be imported using this widget.

   buttonLabel: "Upload CSV",
   // {string}
   // The Label(key) to display on the initial button

   width: 0,
   // {integer}
   // Width of the Popup.

   recordRules: [],
   // {array}  [ {RecordRule}, ... ]
   // A list of ABViewRuleListFormRecordRules that should be performed upon
   // each row of data imported.
   // The Array should look like:
   // [{
   //    action: {string},
   //    when: [
   //       {
   //          fieldId: {UUID},
   //          comparer: {string},
   //          value: {string}
   //       }
   //    ],
   //    values: [
   //       {
   //          fieldId: {UUID},
   //          value: {object}
   //       }
   //    ]
   // }]
};

module.exports = class ABViewCSVImporterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewCSVImporterDefaults
      );
   }

   /**
    * @method common()
    * Provides the default settings for an instance of an ABViewCSVImporter
    * @return {json}
    */
   static common() {
      return ABViewCSVImporterDefaults;
   }

   /**
    * @method defaultValues()
    * Provides the default settings for an instance of an ABViewCSVImporter
    * Component that is displayed on the UI.
    * @return {json}
    */
   static defaultValues() {
      return ABViewCSVImporterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewCSVImporterPropertyComponentDefaults.width
      );
   }

   get RecordRule() {
      let object = this.datacollection?.datasource;
      if (!object) return null;

      if (this._recordRule == null) {
         this._recordRule = new ABRecordRule();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   doRecordRulesPre(rowDatas) {
      if (rowDatas && !Array.isArray(rowDatas)) {
         rowDatas = [rowDatas];
      }

      rowDatas.forEach((row) => {
         this.RecordRule?.processPre({ data: row.data || row, form: this });
      });
   }

   doRecordRules(rowDatas) {
      if (rowDatas && !Array.isArray(rowDatas)) {
         rowDatas = [rowDatas];
      }

      if (!this.RecordRule) return Promise.resolve();

      let tasks = [];

      rowDatas.forEach((row) => {
         tasks.push(
            this.RecordRule.process({ data: row.data || row, form: this })
         );
      });

      return Promise.all(tasks);
   }
};


/***/ }),

/***/ 474:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCarouselCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewCarouselPropertyComponentDefaults = {
   dataviewID: null, // uuid of ABDatacollection
   field: null, // uuid

   width: 460,
   height: 275,
   showLabel: true,
   hideItem: false,
   hideButton: false,
   navigationType: "corner", // "corner" || "side"
   filterByCursor: false,

   detailsPage: null, // uuid
   detailsTab: null, // uuid
   editPage: null, // uuid
   editTab: null, // uuid
};

const ABViewDefaults = {
   key: "carousel", // {string} unique key for this view
   icon: "clone", // {string} fa-[icon] reference for this view
   labelKey: "Carousel", // {string} the multilingual label key for the class label
};

function parseIntOrDefault(_this, key) {
   if (typeof _this.settings[key] != "undefined") {
      _this.settings[key] = parseInt(_this.settings[key]);
   } else {
      _this.settings[key] = ABViewCarouselPropertyComponentDefaults[key];
   }
}

function parseOrDefault(_this, key) {
   try {
      _this.settings[key] = JSON.parse(_this.settings[key]);
   } catch (e) {
      _this.settings[key] = ABViewCarouselPropertyComponentDefaults[key];
   }
}

module.exports = class ABViewCarouselCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewCarouselPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      parseIntOrDefault(this, "width");
      parseIntOrDefault(this, "height");

      // json
      parseOrDefault(this, "showLabel");
      parseOrDefault(this, "hideItem");
      parseOrDefault(this, "hideButton");

      this.settings.navigationType =
         this.settings.navigationType ||
         ABViewCarouselPropertyComponentDefaults.navigationType;

      parseOrDefault(this, "filterByCursor");
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   get imageField() {
      let dc = this.datacollection;
      if (!dc) return null;

      let obj = dc.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.field);
   }
};


/***/ }),

/***/ 47493:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartAreaCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainer = __webpack_require__(/*! ../../platform/views/ABViewChartContainer */ 55988);

const ABViewChartAreaPropertyComponentDefaults = {
   areaType: "area",
   isLegend: 1,
   // chartWidth: 600,
   chartHeight: 200,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "area", // {string} unique key for this view
   icon: "area-chart", // {string} fa-[icon] reference for this view
   labelKey: "Area", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartAreaCore extends ABViewChartContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartAreaPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.areaType =
         this.settings.areaType ||
         ABViewChartAreaPropertyComponentDefaults.areaType;

      this.settings.isLegend = parseInt(
         this.settings.isLegend ??
            ABViewChartAreaPropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartAreaPropertyComponentDefaults.chartWidth);
      this.settings.chartHeight = parseInt(
         this.settings.chartHeight ??
            ABViewChartAreaPropertyComponentDefaults.chartHeight
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ??
            ABViewChartAreaPropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ??
            ABViewChartAreaPropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ??
            ABViewChartAreaPropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["areaLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 5163:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartBarCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainer = __webpack_require__(/*! ../../platform/views/ABViewChartContainer */ 55988);

const ABViewChartBarPropertyComponentDefaults = {
   barType: "bar",
   barPreset: "column",
   isLegend: 1,
   // chartWidth: 600,
   height: 200,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "bar", // {string} unique key for this view
   icon: "bar-chart", // {string} fa-[icon] reference for this view
   labelKey: "Bar", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartBarCore extends ABViewChartContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartBarPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.barType =
         this.settings.barType ||
         ABViewChartBarPropertyComponentDefaults.barType;

      this.settings.barPreset =
         this.settings.barPreset ||
         ABViewChartBarPropertyComponentDefaults.barPreset;

      this.settings.isLegend = parseInt(
         this.settings.isLegend ??
            ABViewChartBarPropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartBarPropertyComponentDefaults.chartWidth);
      this.settings.height = parseInt(
         this.settings.height ?? ABViewChartBarPropertyComponentDefaults.height
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ??
            ABViewChartBarPropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ??
            ABViewChartBarPropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ??
            ABViewChartBarPropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["barLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 34263:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);

const ABViewChartPropertyComponentDefaults = {
   dataviewID: "",
   columnValue: "",
   columnLabel: "",
   columnValue2: "",
   isPercentage: 1,
   showLabel: 1,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   multipleSeries: 0,
};

const ABViewChartDefaults = {
   key: "chart", // {string} unique key for this view
   icon: "bar-chart", // {string} fa-[icon] reference for this view
   labelKey: "Chart", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewChartDefaults);
   }

   static common() {
      return ABViewChartDefaults;
   }

   static defaultValues() {
      return ABViewChartPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.dataviewID =
         this.settings.dataviewID ??
         ABViewChartPropertyComponentDefaults.dataviewID;

      this.settings.columnValue =
         this.settings.columnValue ??
         ABViewChartPropertyComponentDefaults.columnValue;

      this.settings.columnLabel =
         this.settings.columnLabel ??
         ABViewChartPropertyComponentDefaults.columnLabel;

      this.settings.columnValue2 =
         this.settings.columnValue2 ??
         ABViewChartPropertyComponentDefaults.columnValue2;

      this.settings.isPercentage = parseInt(
         this.settings.isPercentage ??
            ABViewChartPropertyComponentDefaults.isPercentage
      );

      this.settings.showLabel = parseInt(
         this.settings.showLabel ??
            ABViewChartPropertyComponentDefaults.showLabel
      );

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewChartPropertyComponentDefaults.labelPosition;

      this.settings.labelWidth = parseInt(
         this.settings.labelWidth ??
            ABViewChartPropertyComponentDefaults.labelWidth
      );

      this.settings.height = parseInt(
         this.settings.height ?? ABViewChartPropertyComponentDefaults.height
      );

      this.settings.multipleSeries = parseInt(
         this.settings.multipleSeries ??
            ABViewChartPropertyComponentDefaults.multipleSeries
      );

      this.translate(this, this, ["chartLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      const viewsToAllow = ["label", "pie", "bar", "line", "area"];
      return this.application.viewAll((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   labelField() {
      const dc = this.datacollection;
      if (!dc) return null;

      const obj = dc.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnLabel);
   }

   valueField() {
      const dc = this.datacollection;
      if (!dc) return null;

      const obj = dc.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnValue);
   }

   valueField2() {
      const dc = this.datacollection;
      if (!dc) return null;

      const obj = dc.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnValue2);
   }
};


/***/ }),

/***/ 86094:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartLineCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainer = __webpack_require__(/*! ../../platform/views/ABViewChartContainer */ 55988);

const ABViewChartLinePropertyComponentDefaults = {
   lineType: "line",
   linePreset: "plot",
   isLegend: 1,
   // chartWidth: 600,
   chartHeight: 200,
   labelFontSize: 12,
   stepValue: 20,
   maxValue: 100,
};

const ABViewDefaults = {
   key: "line", // {string} unique key for this view
   icon: "line-chart", // {string} fa-[icon] reference for this view
   labelKey: "Line", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartLineCore extends ABViewChartContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartLinePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.lineType =
         this.settings.lineType ||
         ABViewChartLinePropertyComponentDefaults.lineType;

      this.settings.linePreset =
         this.settings.linePreset ||
         ABViewChartLinePropertyComponentDefaults.linePreset;

      this.settings.isLegend = parseInt(
         this.settings.isLegend ??
            ABViewChartLinePropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartLinePropertyComponentDefaults.chartWidth);
      this.settings.chartHeight = parseInt(
         this.settings.chartHeight ??
            ABViewChartLinePropertyComponentDefaults.chartHeight
      );

      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ??
            ABViewChartLinePropertyComponentDefaults.labelFontSize
      );
      this.settings.stepValue = parseInt(
         this.settings.stepValue ??
            ABViewChartLinePropertyComponentDefaults.stepValue
      );
      this.settings.maxValue = parseInt(
         this.settings.maxValue ??
            ABViewChartLinePropertyComponentDefaults.maxValue
      );

      this.translate(this, this, ["lineLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 92835:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewChartPieCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainer = __webpack_require__(/*! ../../platform/views/ABViewChartContainer */ 55988);

const ABViewChartPiePropertyComponentDefaults = {
   pieType: "pie",
   isLegend: 1,
   // chartWidth: 600,
   height: 200,
   innerFontSize: 12,
   labelFontSize: 12,
};

const ABViewDefaults = {
   key: "pie", // {string} unique key for this view
   icon: "pie-chart", // {string} fa-[icon] reference for this view
   labelKey: "Pie", // {string} the multilingual label key for the class label
};

module.exports = class ABViewChartPieCore extends ABViewChartContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewChartPiePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.pieType =
         this.settings.pieType ||
         ABViewChartPiePropertyComponentDefaults.pieType;

      this.settings.isLegend = parseInt(
         this.settings.isLegend ??
            ABViewChartPiePropertyComponentDefaults.isLegend
      );

      // this.settings.chartWidth = parseInt(this.settings.chartWidth || ABViewChartPiePropertyComponentDefaults.chartWidth);
      this.settings.height = parseInt(
         this.settings.height ?? ABViewChartPiePropertyComponentDefaults.height
      );

      this.settings.innerFontSize = parseInt(
         this.settings.innerFontSize ??
            ABViewChartPiePropertyComponentDefaults.innerFontSize
      );
      this.settings.labelFontSize = parseInt(
         this.settings.labelFontSize ??
            ABViewChartPiePropertyComponentDefaults.labelFontSize
      );

      this.translate(this, this, ["pieLabel"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 46767:
/*!****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewCommentCore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewCommentPropertyComponentDefaults = {
   dataviewID: null,
   columnUser: null,
   columnComment: null,
   columnDate: null,
   height: 300,
   label: "", // label is required and you can add more if the component needs them
   // format:0  	// 0 - normal, 1 - title, 2 - description
};

const ABViewDefaults = {
   key: "comment", // {string} unique key for this view
   icon: "comments", // {string} fa-[icon] reference for this view
   labelKey: "Comment", // {string} the multilingual label key for the class label
};

module.exports = class ABViewCommentCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewCommentPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      // this.settings.format = parseInt(this.settings.format);
      // if this is being instantiated on a read from the Property UI,
      this.settings.height = parseInt(this.settings.height || 0);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   getCurrentUserId() {
      const userObject = this.getUsers();
      const currentUser = this.AB.Account.username();
      //Anonymous User = 0

      if (!userObject) return;

      return userObject.findIndex((e) => e.value === currentUser) + 1;
   }

   getUsers() {
      return this.AB.Account.userList().map((e) => {
         return {
            id: e.username,
            value: e.username,
            image: e.image_id,
         };
      });
   }

   getUserField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnUser);
   }

   getCommentField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnComment);
   }

   getDateField() {
      var dv = this.datacollection;
      if (!dv) return null;

      var obj = dv.datasource;
      if (!obj) return null;

      return obj.fieldByID(this.settings.columnDate);
   }

   getUserData() {
      let UserImageField = this.AB.objectUser().fieldByID(
         "6383ce19-b344-44ee-87e6-decced7361f8"
      );

      var userObject = this.getUsers();
      var userList = [];

      if (!userObject) return;

      userObject.forEach((item, index) => {
         var imageURL = "";
         if (item.image) {
            imageURL = UserImageField.urlImage(item.image);
         }
         var user = { id: index + 1, value: item.value, image: imageURL };
         userList.push(user);
      });
      return userList;
   }

   model() {
      let dv = this.datacollection;
      if (!dv) return null; // TODO: refactor in v2

      // get ABModel
      let model = dv.model; // already notified
      if (!model) return null;

      return model;
   }
};


/***/ }),

/***/ 14534:
/*!*****************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewConditionalContainerCore.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);

const ABViewPropertyDefaults = {
   dataviewID: null,
   filterConditions: {},
};

const ABViewDefaults = {
   key: "conditionalcontainer", // unique key identifier for this ABView
   icon: "shield", // icon reference: (without 'fa-' )
   labelKey: "Conditional Container", // {string} the multilingual label key for the class label
};

module.exports = class ABViewConditionalContainerCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      const L = (...params) => this.AB.Multilingual.label(...params);

      // the conditional container always has 'If' and 'Else' panels
      if (this.views((v) => v instanceof ABViewContainer).length < 2) {
         this._views = [];

         // 'If' panel
         const ifPanel = application.viewNew(
            {
               key: ABViewContainer.common().key,
               label: L("If"),
               name: "If",
               settings: {
                  removable: false,
               },
            },
            application,
            this
         );

         this._views.push(ifPanel);

         // 'Else' panel
         const elsePanel = application.viewNew(
            {
               key: ABViewContainer.common().key,
               label: L("Else"),
               name: "Else",
               settings: {
                  removable: false,
               },
            },
            application,
            this
         );

         this._views.push(elsePanel);
      }
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * For a Conditional Container, we don't allow any other items to be placed on it.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 51828:
/*!**************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewConnectDataFilterCore.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewConnectDataFilterPropertyComponentDefaults = {
   dataviewID: null, // uuid of ABDatacollection
   field: null, // uuid
};

const ABViewDefaults = {
   key: "connect-data-filter", // {string} unique key for this view
   icon: "filter", // {string} fa-[icon] reference for this view
   labelKey: "Connected Data Filter", // {string} the multilingual label key for the class label
};

module.exports = class ABViewConnectDataFilterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues ?? ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewConnectDataFilterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 67070:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewContainerCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewContainerCore
 *
 * An ABViewContainerCore defines a UI display component.
 *
 * A container might have multiple columns of display info.
 *
 */

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 94784);

// function L(key, altText) {
// 	return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "viewcontainer", // {string} unique key for this view
   icon: "braille", // {string} fa-[icon] reference for this view
   labelKey: "Container", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columns: 1,
   gravity: 1,
   movable: true,
   removable: true,
};

module.exports = class ABViewContainerCore extends ABView {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columns = parseInt(
         this.settings.columns || ABPropertyComponentDefaults.columns
      );

      if (typeof this.settings.gravity != "undefined") {
         this.settings.gravity.map(function (gravity) {
            return parseInt(gravity);
         });
      }

      if (this.settings.removable != null) {
         this.settings.removable = JSON.parse(this.settings.removable); // convert to boolean
      } else {
         this.settings.removable = ABPropertyComponentDefaults.removable;
      }

      if (this.settings.movable != null) {
         this.settings.movable = JSON.parse(this.settings.movable); // convert to boolean
      } else {
         this.settings.movable = ABPropertyComponentDefaults.movable;
      }
   }

   viewsSortByPosition() {
      // Sort views from y, x positions
      return this.views().sort((a, b) => {
         if (a.position.y == b.position.y) return a.position.x - b.position.x;
         else return a.position.y - b.position.y;
      });
   }

   // saveReorder() {
   //    return this.application.viewReorder(this);
   // }
};


/***/ }),

/***/ 2063:
/*!*********************************************!*\
  !*** ./AppBuilder/core/views/ABViewCore.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewCore
 *
 * ABViewCore defines the common ABView structure that is shared between
 * the client and the server.  Mostly how it manages it's internal data, and
 * how it is related to the ABView classes.
 *
 */

var ABMLClass = __webpack_require__(/*! ../../platform/ABMLClass */ 70504);

const ABViewDefaults = {
   key: "view", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.view", // {string} the multilingual label key for the class label
   tabicon: "", // no default tab icons
};

const ABViewPropertyComponentDefaults = {
   label: "",
};

module.exports = class ABViewCore extends ABMLClass {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(["label"], application.AB);

      this.__events = [];
      // keep track of any event listeners attached to this ABView object

      this.defaults = defaultValues || ABViewDefaults;

      this.application = application;

      this.parent = parent || null;

      this.warningsSilent = false;
      // {bool}
      // Should we suppress our configuration warnings?

      this.__missingViews = [];
      // {array}
      // Any ABView.id we have stored that we can't find.

      this.fromValues(values);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPropertyComponentDefaults;
   }

   /**
    * @method newInstance()
    * return a new instance of this ABView.  Most likely called from interfaces
    * that create new UI elements like the ABDesigner.
    * @param {ABApplication} application  	: the root ABApplication this view is under
    * @param {ABView/ABApplication} parent	: the parent object of this ABView.
    * @return {ABView}
    */
   static newInstance(application, parent) {
      // return a new instance from ABViewManager:
      return application.viewNew(
         { key: this.common().key },
         application,
         parent
      );
   }

   viewKey() {
      return this.defaults.key;
   }

   viewIcon() {
      return this.defaults.icon;
   }

   tabIcon() {
      return this.defaults.tabicon;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABView instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      // // NOTE: ensure we have a uuid() set:
      // if (!this.id) {
      //    this.id = this.application.uuid();
      // }

      // this.application.unTranslate(this, this, ["label"]);

      // MLClass translation
      var obj = super.toObj();

      var result = {
         id: this.id,
         type: this.type || "view",
         key: this.key,
         icon: this.icon,
         tabicon: this.tabicon,
         name: this.name,
         settings: this.AB.cloneDeep(this.settings || {}),
         accessLevels: this.accessLevels,
         translations: obj.translations,
      };

      // encode our child view references
      result.viewIDs = (this._views || []).map((v) => v.id).filter((id) => id);
      result.viewIDs = result.viewIDs.concat(this.__missingViews);

      if (this.position) result.position = this.position;

      // encode our .isRoot() reference.
      // (NOTE: this is set so our server side code can distinguish) between a .view
      // and a root page:
      // NOTE: we intentionally do NOT pull this out in .fromValues()
      result.isRoot = this.isRoot();

      return result;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      this.id = values.id; // NOTE: only exists after .save()
      // {string} .id
      // the uuid of this ABObject Definition.

      this.type = values.type || "view";
      // {string} .type
      // the type of ABDefinition this is.

      this.key = values.key || this.viewKey();
      // {string} .key
      // the unique lookup key for our ABViewManager to create new
      // instances of this object.

      this.icon = values.icon || this.viewIcon();
      // {string} .icon
      // the font awesome icon reference for showing an icon for this
      // view in the AppBuilder interface builder.

      this.tabicon = values.tabicon || this.tabIcon();

      this.name = values.name;
      // {string} .name
      // A name reference for this ABView. This is a reference that isn't
      // translateable and will be used for lookups across languages.

      // if this is being instantiated on a read from the Property UI,
      // .label is coming in under .settings.label
      values.settings = values.settings || {};
      this.label = values.label || values.settings.label || "?label?";

      this.settings = values.settings || {};
      // {obj} .settings
      // the property settings for this ABView

      // make sure .settings.height is an int and not a string
      this.settings.height = parseInt(this.settings.height || 0);

      this.accessLevels = values.accessLevels || {};
      // {obj} .accessLevels
      // Hash: { ABRole.id : accessLevel }
      // tracks the Role -> AccessLevel settings of this particular
      // view.
      // accessLevel: 0 : no access, 1 : view only, 2: full access

      // let the MLClass now process the translations:
      super.fromValues(values);

      // If the View / DataCollection does not have a .name already,
      // use the English label translation as the .name instead.
      if (!this.name && Array.isArray(this.translations)) {
         for (var i = 0; i < this.translations.length; i++) {
            if (i == 0) {
               // Use the first label found, in case there is no 'en'
               this.name = this.translations[i].label;
            }
            if (this.translations[i].language_code == "en") {
               // But the 'en' label will have final priority
               this.name = this.translations[i].label;
               break;
            }
         }
      }

      // default value for our label
      if (this.label == "?label?") {
         if (this.parent) {
            this.label = this.parent.label + "." + this.defaults.key;
         }
      }

      var views = [];
      this.__missingViews = this.__missingViews || [];
      (values.viewIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            views.push(this.application.viewNew(def, this.application, this));
         } else {
            this.__missingViews.push(id);
         }
      });
      this._views = views;

      // convert from "0" => 0
      this.position = values.position || {};

      if (this.position.x != null) this.position.x = parseInt(this.position.x);
      if (this.position.y != null) this.position.y = parseInt(this.position.y);

      this.position.dx = parseInt(this.position.dx || 1);
      this.position.dy = parseInt(this.position.dy || 1);
   }

   isRoot() {
      return this.parent == null || this.parent == this.application;
   }

   /**
    * @method allParents()
    * return a flattened array of all the ABViews parents
    * @return {array}      array of ABViews
    */
   allParents() {
      var parents = [];
      var curView = this;

      // add current view to array
      parents.unshift(curView);

      while (!curView.isRoot() && curView.parent) {
         parents.unshift(curView.parent);

         curView = curView.parent;
      }

      return parents;
   }

   /**
    * @method isAccessibleForRoles()
    * return true/false if this ABViewPage is accessible for one of the
    * passed in ABRoles.
    * @param {array[ABRole]} roles
    *        an array of {ABRole} instances.
    * @return {bool}
    */
   isAccessibleForRoles(roles) {
      var foundRole = false;

      var accessibleRoles = Object.keys(this.accessLevels) || [];
      (roles || []).forEach((r) => {
         if (accessibleRoles.indexOf(r.uuid || r) > -1) {
            foundRole = true;
         }
      });

      return foundRole;
   }

   /**
    * @method getUserAccess()
    *
    * return the access level of the current user on the current view
    *
    * @return {integer}  // 0 = No Access // 1 = Read Only // 2 = Full Access
    */
   getUserAccess() {
      // by default everyone has no access
      var accessLevel = 0;

      if (this.application.isAccessManaged) {
         // check to see if the current users is the access manager
         var isAccessManager = false;
         // first check if manager is defined by their role
         if (parseInt(this.application.accessManagers.useRole) == 1) {
            // if so check if any of the user's role match the managers
            this.AB.Account.roles().forEach((role) => {
               if (
                  this.application.accessManagers.role.indexOf(
                     role.id || role.uuid
                  ) > -1
               ) {
                  // if so set the access level to full access
                  isAccessManager = true;
                  accessLevel = 2;
               }
            });
         }
         // if the user isn't already set as the manager and the manager is defined by their account
         if (
            !isAccessManager &&
            parseInt(this.application.accessManagers.useAccount) == 1
         ) {
            // check if the user's account matches the managers
            if (
               this.application.accessManagers.account.indexOf(
                  this.AB.Account.uuid() + ""
               ) > -1
            ) {
               // if so set the access level to full access
               isAccessManager = true;
               accessLevel = 2;
            }
         }

         // if the user is not the manager check if the page has access levels defined for roles
         if (
            this.accessLevels &&
            Object.keys(this.accessLevels).length > 0 &&
            !isAccessManager
         ) {
            // check to see if the user's roles matches one of the roles defined
            this.AB.Account.roles().forEach((role) => {
               var currentRole = this.accessLevels[role.id || role.uuid];
               if (currentRole && parseInt(currentRole) > accessLevel)
                  // if the access level is higher than a previous role set to the new level
                  accessLevel = parseInt(currentRole);
            });
         }
      } else {
         accessLevel = 2;
      }

      return accessLevel;
   }

   /**
    * @method parentFormComponent
    * return the closest form object this component is on.
    */
   parentFormComponent() {
      var form = null;

      var curr = this;
      while (curr.key != "form" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "form") {
         form = curr;
      }

      return form;
   }

   /**
    * @method parentDetailComponent
    * return the closest detail object that this component is on.
    * @returns {ABViewDetail} detail component
    */
   parentDetailComponent() {
      var detail = null;

      var curr = this;
      while (curr.key != "detail" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "detail") {
         detail = curr;
      }

      return detail;
   }

   pageParent(filterFn) {
      if (filterFn == null) filterFn = () => true;

      // if current page is the root page, then return itself.
      if (this.isRoot()) {
         return this;
      }

      var parentPage = this.parent;
      while (
         parentPage &&
         (parentPage.key != "page" || !filterFn(parentPage))
      ) {
         parentPage = parentPage.parent;
      }

      return parentPage;
   }

   pageRoot() {
      var rootPage = this.pageParent();

      while (!rootPage.isRoot()) {
         rootPage = rootPage.pageParent();
      }

      return rootPage;
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlView() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   /**
    * @method urlView
    * return a string pointer to this object's views.
    * @return {string}
    */
   urlView() {
      return this.urlPointer() + "/_views/";
   }

   /**
    * @property datacollection
    * return data source
    *
    * @return {ABDataCollection}
    */
   get datacollection() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) {
         if (
            ["form", "grid", "line", "area", "bar", "gantt", "kanban"].indexOf(
               this.key
            ) > -1
         ) {
            // NOTE: ignore kanban side forms where this is the case:
            if (this.key == "form" && this._currentObject) return null;

            if (this.warningsSilent) return null;

            var errNoDCID = new Error(
               `ABViewCore:get datacollection(): View[${this.key}] didn't define a dataviewID.`
            );
            this.AB.notify.builder(errNoDCID, {
               view: this,
               settings: this.settings,
            });
         } else {
            // These views shouldn't matter if they don't have a datacollection.
            if (
               ["button", "label", "page", "tab", "viewcontainer"].indexOf(
                  this.key
               ) == -1
            ) {
               console.warn(
                  `TODO: figure out which ABView* require a .dataviewID: ${this.key}?`
               );
            }
         }
         return null;
      }

      var dc = this.AB.datacollectionByID(dataviewID);
      if (!dc) {
         var errNoDC = new Error(
            `View[${this.label}][${this.id}] is unable to find associated DataCollection`
         );
         this.AB.notify.builder(errNoDC, {
            view: this,
            dataviewID,
         });
      }
      return dc;
   }

   ///
   /// Update Access accessLevels
   ///

   /**
    * @method updateAccessLevels()
    *
    *
    * @param {string} roleId
    *
    * @param {string} accessLevel
    *
    * @return {Promise}
    *
    */
   updateAccessLevels(roleId, accessLevel) {
      if (parseInt(accessLevel) == 0) {
         if (this.accessLevels[roleId]) delete this.accessLevels[roleId];
      } else {
         this.accessLevels[roleId] = accessLevel;
      }

      return this.save(false, false);
   }

   ///
   /// Views
   ///

   /**
    * @method views()
    *
    * return an array of all the ABViews children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViews that this fn
    *						returns true for.
    * @param {boolean} deep
    *
    * @return {array} 	array of ABViews
    */
   views(filter = () => true, deep = false) {
      var result = [];

      if (!this._views || this._views.length < 1) return result;

      // find into recursively
      if (filter && deep) {
         result = result.concat(this._views.filter(filter));

         this._views.forEach((v) => {
            var subViews = v.views(filter, deep);
            if (subViews && subViews.length > 0) {
               result = result.concat(subViews);
            }
         });
      } else {
         result = this._views.filter(filter);
      }

      return result;
   }

   /**
    * @method viewNew()
    *
    *
    * @return {ABView}
    */
   viewNew(values, application, parent) {
      return this.application.viewNew(
         values,
         application || this.application,
         parent || this
      );
   }

   /**
    * @method viewDestroy()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewDestroy(view) {
      console.error("DEPRECIATED: where is this called?");
      return this.viewRemove(view);
   }

   /**
    * @method viewRemove()
    *
    * remove the current ABView from our list of ._views.
    *
    * @param {ABView} view
    * @return {Promise}
    */
   viewRemove(view) {
      var origLen = this._views.length;
      this._views = this.views(function (v) {
         return v.id != view.id;
      });

      if (this._views.length < origLen) {
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewInsert()
    *
    * persist the current ABView in our list of ._views.
    *
    * @param {ABView} object
    * @return {Promise}
    */
   viewInsert(view) {
      var isIncluded =
         this.views(function (v) {
            return v.id == view.id;
         }).length > 0;
      if (!isIncluded) {
         this._views.push(view);
         return this.save();
      }

      return Promise.resolve();
   }

   /**
    * @method viewReorder()
    *
    * reorder the current ABView in our list of ._views.
    *
    * @param {string} viewId - id of the active view
    * @param {string} toPosition - 'to' postion
    * @return {Promise}
    */
   viewReorder(viewId, toPosition) {
      var from = this._views.findIndex((v) => v.id == viewId);
      if (from < 0) return;

      // move drag item to 'to' position
      this._views.splice(toPosition, 0, this._views.splice(from, 1)[0]);

      // save to database
      return this.save(true);
   }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      // unsubscribe events
      this.eventClear(true);

      return Promise.resolve()
         .then(() => {
            // When deleting an ABView
            // be sure to remove any of it's ABViews as well
            // This cleans out any dangling ABDefinitions

            var allViewDeletes = [];
            var allViews = this.views();
            this._views = [];
            // doing ._views = [] prevents any of my updates when
            // a sub-view is .destroy()ed

            allViews.forEach((v) => {
               allViewDeletes.push(v.destroy());
            });
            return Promise.all(allViewDeletes);
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects
            if (this.parent && !this.pages) {
               return this.parent.viewRemove(this);
            }
         })
         .then(() => {
            return super.destroy();
         })
         .then(() => {
            this.emit("destroyed");
         });
   }

   /**
    * @method save()
    * persist this instance of ABView
    * @return {Promise}
    *		.resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // NOTE: this should not happen on ABViewPage objects:
            if (this.parent && !this.pages) {
               // if we have a .parent, make sure we are included in our .parent's
               // viewIDs
               return this.parent.viewInsert(this);
            }
         })
         .then(() => {
            return this;
         });
   }

   ///
   /// Events
   ///

   /**
    * @method eventAdd()
    *
    *
    *
    * @param {object} evt - {
    * 							emitter: object,
    * 							eventName: string,
    * 							listener: function
    * 						}
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      var exists = this.__events.find((e) => {
         return e.emitter == evt.emitter && e.eventName == evt.eventName;
         // && e.listener == evt.listener;
      });

      if (!exists || exists.length < 1) {
         // add to array
         this.__events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventClear()
    * unsubscribe all events.
    * should do it before destroy a component
    *
    * @param {bool} deep - clear events of child views
    */
   eventClear(deep) {
      if (deep) {
         this.views().forEach((v) => {
            v.eventClear(deep);
         });
      }

      if (this.__events && this.__events.length > 0) {
         this.__events.forEach((e) => {
            e.emitter.removeListener(e.eventName, e.listener);
         });
      }
   }

   /**
    * @method clone()
    * clone the definitions of this ABView object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    * @return {obj}
    *        obj defs of this ABView
    */
   clone(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pages", "views"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.viewNew(config, this.application, parent);

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // copy sub pages
      if (this.pages && !options.ignoreSubPages) {
         result._pages = [];
         this.pages().forEach((p) => {
            let copiedSubPage = p.clone(lookUpIds, result, options);
            copiedSubPage.parent = result;

            result._pages.push(copiedSubPage);
         });
      }

      // copy sub views
      if (this.views && !options.ignoreSubViews) {
         result._views = [];
         this.views().forEach((v) => {
            let copiedView = v.clone(lookUpIds, result, options);

            result._views.push(copiedView);
         });
      }

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABView object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @param {obj} options
    *        option settings for the copy command.
    *        options.ignoreSubPages {bool}
    *             set to true to skip copying any sub pages of this ABView.
    *        options.newName {string}
    *             new user determined name for page
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options = {}) {
      lookUpIds = lookUpIds || {};

      // get settings of the target
      let config = this.toObj();

      // remove sub-elements property
      ["pageIDs", "viewIDs"].forEach((prop) => {
         delete config[prop];
      });

      // update id of linked components
      if (this.copyUpdateProperyList) {
         (this.copyUpdateProperyList() || []).forEach((prop) => {
            if (config && config.settings)
               config.settings[prop] = lookUpIds[config.settings[prop]];
         });
      }

      // copy from settings
      let result = this.application.viewNew(config, this.application, parent);

      // keep the parent
      result.parent = parent || this.parent;

      // change id
      if (parent == null) {
         // the page is getting cloned to root: there is no parent, as parent is the application.
         // pages with null parent ids default to getting put on root
         result.id = null;
      } else {
         result.id = lookUpIds[result.id] || this.AB.uuid();
      }

      // page's name should not be duplicate
      if (this.key == "page") {
         result.name =
            options?.newName ||
            `${result.name}_copied_${this.AB.uuid().slice(0, 3)}`;

         result.label = options?.newName || `${result.label} (copied)`;
      }

      return Promise.resolve()
         .then(() => {
            // copy sub pages
            var allSaves = [];

            if (this._pages && !options.ignoreSubPages) {
               result._pages = [];
               this.pages().forEach((p) => {
                  // this prevents result.save() from happening on each of these
                  // p.copy():
                  if (p.isRoot())
                     this.application._pages.push({ id: lookUpIds[p.id] });

                  allSaves.push(
                     p
                        .copy(lookUpIds, result, options)
                        .then((copiedSubPage) => {
                           copiedSubPage.parent = result;
                           // remove the temp {id:} entry above:
                           this.application._pages =
                              this.application._pages.filter(
                                 (p2) => p2.id != lookUpIds[p.id]
                              );

                           // now add the full copiedSubPage:
                           result._pages.push(copiedSubPage);
                        })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // copy sub views
            var allSaves = [];

            if (this._views && !options.ignoreSubViews) {
               result._views = [];
               this.views().forEach((v) => {
                  allSaves.push(
                     // send a null for parent, so that the .save() wont trigger
                     // a save of the parent.
                     v.copy(lookUpIds, result, options).then((copiedView) => {
                        // now patch up the parent connection:
                        // copiedView.parent = result;
                        if (
                           result._views.filter((vi) => vi.id == copiedView.id)
                              .length < 1
                        ) {
                           result._views.push(copiedView);
                        }
                     })
                  );
               });
            }

            return Promise.all(allSaves);
         })
         .then(() => {
            // now we do 1 save for all the views
            return result.save();
         })
         .then(() => {
            return result;
         });
   }
};


/***/ }),

/***/ 23108:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDataFilterCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewDataFilterPropertyComponentDefaults = {
   dataviewID: null, // uuid of ABDatacollection
   field: null, // uuid,
   viewType: "advanced",
   showFilter: 1,
   showSort: 1,
};

const ABViewDefaults = {
   key: "data-filter", // {string} unique key for this view
   icon: "filter", // {string} fa-[icon] reference for this view
   labelKey: "Data Filter", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDataFilterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues ?? ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewDataFilterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 43786:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDataviewCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetail = __webpack_require__(/*! ../../platform/views/ABViewDetail */ 65862);

const ABViewDataviewPropertyComponentDefaults = {
   xCount: 1, // {int} the number of columns per row (need at least one)
   detailsPage: "",
   detailsTab: "",
   editPage: "",
   editTab: "",
};

const ABViewDataviewDefaults = {
   key: "dataview", // {string} unique key for this view
   icon: "th", // {string} fa-[icon] reference for this view
   labelKey: "Data view", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDataviewCore extends ABViewDetail {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewDataviewDefaults
      );
   }

   static common() {
      return ABViewDataviewDefaults;
   }

   static defaultValues() {
      return ABViewDataviewPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.xCount = parseInt(
         this.settings.xCount || ABViewDataviewPropertyComponentDefaults.xCount
      );
      this.settings.detailsPage =
         this.settings.detailsPage ||
         ABViewDataviewPropertyComponentDefaults.detailsPage;
      this.settings.editPage =
         this.settings.editPage ||
         ABViewDataviewPropertyComponentDefaults.editPage;
      this.settings.detailsTab =
         this.settings.detailsTab ||
         ABViewDataviewPropertyComponentDefaults.detailsTab;
      this.settings.editTab =
         this.settings.editTab ||
         ABViewDataviewPropertyComponentDefaults.editTab;
   }

   parentDetailComponent() {
      let dataview = null;

      let curr = this;
      while (curr.key != "dataview" && !curr.isRoot() && curr.parent) {
         curr = curr.parent;
      }

      if (curr.key == "dataview") {
         dataview = curr;
      }

      return dataview;
   }
};


/***/ }),

/***/ 90065:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCheckboxCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailCheckboxPropertyComponentDefaults = {};

const ABViewDetailCheckboxDefaults = {
   key: "detailcheckbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.checkbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailCheckboxCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues ?? ABViewDetailCheckboxDefaults
      );
   }

   static common() {
      return ABViewDetailCheckboxDefaults;
   }

   static defaultValues() {
      return ABViewDetailCheckboxPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 12126:
/*!**********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailConnectCore.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// const ABViewDetailSelectivity = require("../../platform/views/ABViewDetailSelectivity");
const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailPropertyComponentDefaults = {
   formView: "", // id of form to add new data
};

const ABViewDefaults = {
   key: "detailconnect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.connect", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailConnectCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues ?? ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 89799:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);

const ABViewDetailDefaults = {
   key: "detail", // {string} unique key for this view
   icon: "file-text-o", // {string} fa-[icon] reference for this view
   labelKey: "Detail", // {string} the multilingual label key for the class label
};

const ABViewDetailPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 0,
};

module.exports = class ABViewDetailCore extends ABViewContainer {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues ?? ABViewDetailDefaults);
   }

   static common() {
      return ABViewDetailDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewDetailPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewDetailPropertyComponentDefaults.showLabel
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth ||
            ABViewDetailPropertyComponentDefaults.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height ?? ABViewDetailPropertyComponentDefaults.height
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      let viewsToAllow = ["label", "text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   addFieldToDetail(field, yPosition) {
      if (field == null) return;

      let newView = field.detailComponent().newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings ?? {};
      newView.settings.fieldId = field.id;
      newView.settings.labelWidth =
         this.settings.labelWidth ||
         ABViewDetailPropertyComponentDefaults.labelWidth;

      // keep alias to support Query that contains alias name
      // [alias].[columnName]
      newView.settings.alias = field.alias;

      // TODO : Default settings

      newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      return newView;
   }
};


/***/ }),

/***/ 57839:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailCustomCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailCustomPropertyComponentDefaults = {};

const ABViewDetailCustomDefaults = {
   key: "detailcustom", // {string} unique key for this view
   icon: "dot-circle-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.custom", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailCustomCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues ?? ABViewDetailCustomDefaults
      );
   }

   static common() {
      return ABViewDetailCustomDefaults;
   }

   static defaultValues() {
      return ABViewDetailCustomPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 30825:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailImageCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailImagePropertyComponentDefaults = {
   height: 80,
   width: 120,
};

const ABViewDetailImageDefaults = {
   key: "detailimage", // {string} unique key for this view
   icon: "image", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.image", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailImageCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues ?? ABViewDetailImageDefaults
      );
   }

   static common() {
      return ABViewDetailImageDefaults;
   }

   static defaultValues() {
      return ABViewDetailImagePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height ||
            ABViewDetailImagePropertyComponentDefaults.height
      );
      this.settings.width = parseInt(
         this.settings.width ?? ABViewDetailImagePropertyComponentDefaults.width
      );
   }
};


/***/ }),

/***/ 68488:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailItemCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

module.exports = class ABViewDetailItemCore extends ABViewWidget {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   detailComponent() {
      let detailView = null;

      let curr = this;
      while (
         !curr.isRoot() &&
         curr.parent &&
         curr.key != "detail" &&
         curr.key != "dataview"
      ) {
         curr = curr.parent;
      }

      if (curr.key == "detail" || curr.key == "dataview") {
         detailView = curr;
      }

      return detailView;
   }

   field() {
      let detailComponent = this.detailComponent();
      if (detailComponent == null) return null;

      let datacollection = detailComponent.datacollection;
      if (datacollection == null) return null;

      let object = datacollection.datasource;
      if (object == null) return null;

      let field = object.fields((v) => v.id == this.settings.fieldId)[0];

      // set .alias to support queries that contains alias name
      // [aliasName].[columnName]
      if (field && this.settings.alias) {
         field.alias = this.settings.alias;
      }

      return field;
   }

   getCurrentData() {
      let detailCom = this.detailComponent();
      if (!detailCom) return null;

      let dv = detailCom.datacollection;
      if (!dv) return null;

      let field = this.field();
      if (!field) return null;

      let currData = dv.getCursor();
      if (currData) return currData[field.columnName];
      else return null;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }
};


/***/ }),

/***/ 38208:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailTextCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailTextPropertyComponentDefaults = {
   height: 0,
};

const ABViewDetailTextDefaults = {
   key: "detailtext", // {string} unique key for this view
   icon: "etsy", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.text", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailTextCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues ?? ABViewDetailTextDefaults
      );
   }

   static common() {
      return ABViewDetailTextDefaults;
   }

   static defaultValues() {
      return ABViewDetailTextPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height ||
            ABViewDetailTextPropertyComponentDefaults.height
      );
   }
};


/***/ }),

/***/ 80796:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDetailTreeCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItem = __webpack_require__(/*! ../../platform/views/ABViewDetailItem */ 54325);

const ABViewDetailPropertyComponentDefaults = {};

const ABViewDetailTreeDefaults = {
   key: "detailtree", // {string} unique key for this view
   icon: "sitemap", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.detail.tree", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDetailTextCore extends ABViewDetailItem {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues ?? ABViewDetailTreeDefaults
      );
   }

   static common() {
      return ABViewDetailTreeDefaults;
   }

   static defaultValues() {
      return ABViewDetailPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 26736:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewDocxBuilderCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewDocxBuilderPropertyComponentDefaults = {
   buttonlabel: "Download DOCX",
   dataviewID: null,
   width: 0,
   filename: "", // uuid
   filelabel: "output.docx",
   language: "en", // en
   toolbarBackground: "ab-background-default",
   buttonPosition: "left",
};

const ABViewDefaults = {
   key: "docxBuilder", // {string} unique key for this view
   icon: "file-word-o", // {string} fa-[icon] reference for this view
   labelKey: "DOCX Builder", // {string} the multilingual label key for the class label
};

module.exports = class ABViewDocxBuilderCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewDocxBuilderPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["filelabel", "buttonlabel"]);

      let obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewDocxBuilderPropertyComponentDefaults.width
      );

      this.translate(this, this, ["filelabel", "buttonlabel"]);
   }

   uploadUrl() {
      // TODO: Convert this to use ABFactory.urlFileUpload() or a ABFieldFile
      // to get the URL:

      const object = this.datacollection.datasource;

      // NOTE: file-upload API needs to have the id of ANY field.
      const field = object ? object.fields()[0] : null;

      return `/file/upload/${object?.id}/${field?.id}/1`;
   }

   downloadUrl() {
      return `/file/${this.settings.filename}`;
   }

   get languageCode() {
      return (
         this.settings.language ||
         ABViewDocxBuilderPropertyComponentDefaults.language
      );
   }

   get datacollections() {
      let dataviewID = (this.settings || {}).dataviewID;
      if (!dataviewID) return [];

      let dvList = dataviewID.split(",") || [];

      return this.AB.datacollections((dv) => dvList.indexOf(dv.id) > -1) || [];
   }
};


/***/ }),

/***/ 46816:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormButtonCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 94784);

const ABViewFormButtonPropertyComponentDefaults = {
   includeSave: true,
   saveLabel: "",
   includeCancel: false,
   cancelLabel: "",
   includeReset: false,
   resetLabel: "",
   includeDelete: false,
   deleteLabel: "",
   afterCancel: null,
   alignment: "right",
   isDefault: false, // mark default button of form widget
};

const ABViewFormButtonDefaults = {
   key: "button",
   // {string} unique key for this view

   icon: "square",
   // {string} fa-[icon] reference for this view

   labelKey: "ab.components.button",
   // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormButtonCore extends ABView {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormButtonDefaults
      );
   }

   static common() {
      return ABViewFormButtonDefaults;
   }

   static defaultValues() {
      return ABViewFormButtonPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   toObj() {
      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      if (this.settings.deleteLabel) labels.push("deleteLabel");

      this.unTranslate(this.settings, this.settings, labels);

      let result = super.toObj();

      return result;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }

   fromValues(values) {
      super.fromValues(values);

      // labels are multilingual values:
      let labels = [];

      if (this.settings.saveLabel) labels.push("saveLabel");

      if (this.settings.cancelLabel) labels.push("cancelLabel");

      if (this.settings.resetLabel) labels.push("resetLabel");

      if (this.settings.deleteLabel) labels.push("deleteLabel");

      this.unTranslate(this.settings, this.settings, labels);

      this.settings.includeSave = JSON.parse(
         (this.settings?.includeSave ?? true) &&
            ABViewFormButtonPropertyComponentDefaults.includeSave
      );
      this.settings.includeCancel = JSON.parse(
         this.settings.includeCancel ||
            ABViewFormButtonPropertyComponentDefaults.includeCancel
      );
      this.settings.includeReset = JSON.parse(
         this.settings.includeReset ||
            ABViewFormButtonPropertyComponentDefaults.includeReset
      );
      this.settings.includeDelete = JSON.parse(
         this.settings.includeDelete ||
            ABViewFormButtonPropertyComponentDefaults.includeDelete
      );

      this.settings.isDefault = JSON.parse(
         this.settings.isDefault ||
            ABViewFormButtonPropertyComponentDefaults.isDefault
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 49947:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCheckboxCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormCheckboxPropertyComponentDefaults = {};

const ABViewFormCheckboxDefaults = {
   key: "checkbox", // {string} unique key for this view
   icon: "check-square-o", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.checkbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormCheckboxCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCheckboxDefaults
      );
   }

   static common() {
      return ABViewFormCheckboxDefaults;
   }

   static defaultValues() {
      return ABViewFormCheckboxPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 91623:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormConnectCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormConnectPropertyComponentDefaults = {
   formView: "", // id of form to add new data
   filterConditions: {
      // array of filters to apply to the data table
      glue: "and",
      rules: [],
   },
   sortFields: [],
   // objectWorkspace: {
   //    filterConditions: {
   //       // array of filters to apply to the data table
   //       glue: "and",
   //       rules: [],
   //    },
   // },
   popupWidth: 700,
   popupHeight: 450,
};

const ABViewFormConnectDefaults = {
   key: "connect", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "Connect", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormConnectCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormConnectDefaults
      );
   }

   static common() {
      return ABViewFormConnectDefaults;
   }

   static defaultValues() {
      return ABViewFormConnectPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.filterConditions =
         this.settings.filterConditions ||
         ABViewFormConnectPropertyComponentDefaults.filterConditions;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 31089:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);
const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABRecordRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormRecordRules */ 95652);
const ABSubmitRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 17004);

const ABViewFormDefaults = {
   key: "form", // unique key identifier for this ABViewForm
   icon: "list-alt", // icon reference: (without 'fa-' )
   labelKey: "Form", // {string} the multilingual label key for the class label
};

const ABViewFormPropertyComponentDefaults = {
   dataviewID: null,
   showLabel: true,
   labelPosition: "left",
   labelWidth: 120,
   height: 200,
   clearOnLoad: false,
   clearOnSave: false,
   displayRules: [],
   editForm: "none", // The url pointer of ABViewForm

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		values: [
   //			{
   //				fieldId: {UUID},
   //				value: {object}
   //			}
   //		]
   //	}]
   recordRules: [],

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		value: {string}
   //	}]
   submitRules: [],
};

module.exports = class ABViewFormCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewFormDefaults);
   }

   static common() {
      return ABViewFormDefaults;
   }

   static defaultValues() {
      return ABViewFormPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.labelPosition =
         this.settings.labelPosition ||
         ABViewFormPropertyComponentDefaults.labelPosition;

      // convert from "0" => true/false
      this.settings.showLabel = JSON.parse(
         this.settings.showLabel != null
            ? this.settings.showLabel
            : ABViewFormPropertyComponentDefaults.showLabel
      );
      this.settings.clearOnLoad = JSON.parse(
         this.settings.clearOnLoad != null
            ? this.settings.clearOnLoad
            : ABViewFormPropertyComponentDefaults.clearOnLoad
      );
      this.settings.clearOnSave = JSON.parse(
         this.settings.clearOnSave != null
            ? this.settings.clearOnSave
            : ABViewFormPropertyComponentDefaults.clearOnSave
      );

      // convert from "0" => 0
      this.settings.labelWidth = parseInt(
         this.settings.labelWidth == null
            ? ABViewFormPropertyComponentDefaults.labelWidth
            : this.settings.labelWidth
      );
      this.settings.height = parseInt(
         this.settings.height == null
            ? ABViewFormPropertyComponentDefaults.height
            : this.settings.height
      );
   }

   // Use this function in kanban
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      var viewsToAllow = ["label", "layout", "button", "text"],
         allComponents = this.application.viewAll();

      return allComponents.filter((c) => {
         return viewsToAllow.indexOf(c.common().key) > -1;
      });
   }

   /**
    * @method fieldComponents()
    *
    * return an array of all the ABViewFormField children
    *
    * @param {fn} filter  	a filter fn to return a set of ABViewFormField that this fn
    *						returns true for.
    * @return {array} 	array of ABViewFormField
    */
   fieldComponents(filter) {
      const flattenComponents = (views) => {
         let components = [];

         views.forEach((v) => {
            if (v == null) return;

            components.push(v);

            if (v._views?.length) {
               components = components.concat(flattenComponents(v._views));
            }
         });

         return components;
      };

      if (this._views?.length) {
         const allComponents = flattenComponents(this._views);

         if (filter == null) {
            filter = (comp) => comp instanceof ABViewFormItem;
         }

         return allComponents.filter(filter);
      } else {
         return [];
      }
   }

   addFieldToForm(field, yPosition) {
      if (field == null) return;

      var fieldComponent = field.formComponent();
      if (fieldComponent == null) return;

      var newView = fieldComponent.newInstance(this.application, this);
      if (newView == null) return;

      // set settings to component
      newView.settings = newView.settings || {};
      newView.settings.fieldId = field.id;
      // TODO : Default settings

      if (yPosition != null) newView.position.y = yPosition;

      // add a new component
      this._views.push(newView);

      return newView;
   }

   get RecordRule() {
      let object = this.datacollection.datasource;

      if (this._recordRule == null) {
         this._recordRule = new ABRecordRule();
      }

      this._recordRule.formLoad(this);
      this._recordRule.fromSettings(this.settings.recordRules);
      this._recordRule.objectLoad(object);

      return this._recordRule;
   }

   doRecordRulesPre(rowData) {
      return this.RecordRule.processPre({ data: rowData, form: this });
   }

   doRecordRules(rowData) {
      // validate for record rules
      if (rowData) {
         let object = this.datacollection.datasource;
         let ruleValidator = object.isValidData(rowData);
         let isUpdatedDataValid = ruleValidator.pass();
         if (!isUpdatedDataValid) {
            console.error("Updated data is invalid.", { rowData: rowData });
            return Promise.reject(new Error("Updated data is invalid."));
         }
      }

      return this.RecordRule.process({ data: rowData, form: this });
   }

   doSubmitRules(rowData) {
      var object = this.datacollection.datasource;

      var SubmitRules = new ABSubmitRule();
      SubmitRules.formLoad(this);
      SubmitRules.fromSettings(this.settings.submitRules);
      SubmitRules.objectLoad(object);

      return SubmitRules.process({ data: rowData, form: this });
   }
};


/***/ }),

/***/ 88356:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormCustomCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormCustomPropertyComponentDefaults = {};

const ABViewFormCustomDefaults = {
   key: "fieldcustom",
   // {string} unique key for this view
   icon: "object-group",
   // {string} fa-[icon] reference for this view
   labelKey: "ab.components.custom",
   // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormCustom extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormCustomDefaults
      );
   }

   static common() {
      return ABViewFormCustomDefaults;
   }

   static defaultValues() {
      return ABViewFormCustomPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 28476:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormDatepickerCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormDatepickerPropertyComponentDefaults = {
   timepicker: false,
};

const ABViewFormDatepickerDefaults = {
   key: "datepicker", // {string} unique key for this view
   icon: "calendar", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.datepicker", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormDatepickerCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormDatepickerDefaults
      );
   }

   static common() {
      return ABViewFormDatepickerDefaults;
   }

   static defaultValues() {
      return ABViewFormDatepickerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 68181:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormItemCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 94784);

const ABViewFormFieldPropertyComponentDefaults = {
   required: 0,
   disable: 0,
};

module.exports = class ABViewFormComponentCore extends ABView {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static defaultValues() {
      return ABViewFormFieldPropertyComponentDefaults;
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      let form = this.parentFormComponent();
      if (form == null) return null;

      let datacollection = form.datacollection;
      if (datacollection == null) return null;

      return datacollection;
   }

   field() {
      if (this.settings.objectId) {
         let object = this.AB.objectByID(this.settings.objectId);
         if (!object) return null;

         return object.fieldByID(this.settings.fieldId);
      } else {
         let form = this.parentFormComponent();
         if (form == null) return null;

         let object;
         if (form._currentObject) {
            object = form._currentObject;
         } else {
            let datacollection = form.datacollection;
            if (datacollection == null) return null;

            object = datacollection.datasource;
         }

         if (object == null) return null;

         let field = object.fieldByID(this.settings.fieldId);
         return field;
      }
   }
};


/***/ }),

/***/ 88612:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormJsonCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormJsonPropertyComponentDefaults = {
   type: "string", // 'string', 'systemObject' or 'filter'
};

const ABViewFormJsonDefaults = {
   key: "json", // {string} unique key for this view
   icon: "brackets-curly", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.json", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormJsonCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormJsonDefaults
      );
   }

   static common() {
      return ABViewFormJsonDefaults;
   }

   static defaultValues() {
      return ABViewFormJsonPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 5880:
/*!*******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormNumberCore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormNumberPropertyComponentDefaults = {
   isStepper: 0,
};

const ABViewFormNumberDefaults = {
   key: "numberbox", // {string} unique key for this view
   icon: "hashtag", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.number", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormNumberCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormNumberDefaults
      );
   }

   static common() {
      return ABViewFormNumberDefaults;
   }

   static defaultValues() {
      return ABViewFormNumberPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewFormText instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "formLabel"]);

      var obj = super.toObj();
      obj.views = []; // no subviews
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      this.settings.isStepper =
         this.settings.isStepper ||
         ABViewFormNumberPropertyComponentDefaults.isStepper;

      // convert from "0" => 0
      this.settings.isStepper = parseInt(this.settings.isStepper);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 87771:
/*!*********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormReadonlyCore.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustom = __webpack_require__(/*! ../../platform/views/ABViewFormCustom */ 36365);

const ABViewFormReadonlyPropertyComponentDefaults = {};

const ABViewFormReadonlyDefaults = {
   key: "fieldreadonly", // {string} unique key for this view
   icon: "calculator", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.readonly", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormReadonly extends ABViewFormCustom {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormReadonlyDefaults
      );
   }

   static common() {
      return ABViewFormReadonlyDefaults;
   }

   static defaultValues() {
      return ABViewFormReadonlyPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 15934:
/*!***************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormSelectMultipleCore.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormSelectMultiplePropertyComponentDefaults = {
   type: "multicombo", // 'richselect' or 'radio'
};

const ABSelectMultipleDefaults = {
   key: "selectmultiple", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.selectmultiple", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormSelectMultipleCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABSelectMultipleDefaults
      );
   }

   static common() {
      return ABSelectMultipleDefaults;
   }

   static defaultValues() {
      return ABViewFormSelectMultiplePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 97241:
/*!*************************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormSelectSingleCore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormSelectSinglePropertyComponentDefaults = {
   type: "richselect", // 'richselect' or 'radio'
};

const ABSelectSingleDefaults = {
   key: "selectsingle", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.selectsingle", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormSelectSingleCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABSelectSingleDefaults
      );
   }

   static common() {
      return ABSelectSingleDefaults;
   }

   static defaultValues() {
      return ABViewFormSelectSinglePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 94782:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormTextboxCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItem = __webpack_require__(/*! ../../platform/views/ABViewFormItem */ 48933);

const ABViewFormTextboxPropertyComponentDefaults = {
   type: "single", // 'single', 'multiple' or 'rich'
};

const ABViewFormTextboxDefaults = {
   key: "textbox", // {string} unique key for this view
   icon: "i-cursor", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.textbox", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormTextboxCore extends ABViewFormItem {
   constructor(values, application, parent, defaultValues) {
      super(
         values,
         application,
         parent,
         defaultValues || ABViewFormTextboxDefaults
      );
   }

   static common() {
      return ABViewFormTextboxDefaults;
   }

   static defaultValues() {
      return ABViewFormTextboxPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 68272:
/*!*****************************************************!*\
  !*** ./AppBuilder/core/views/ABViewFormTreeCore.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustom = __webpack_require__(/*! ../../platform/views/ABViewFormCustom */ 36365);

const ABViewFormTreePropertyComponentDefaults = {};

const ABTreeDefaults = {
   key: "formtree", // {string} unique key for this view
   icon: "sitemap", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.tree", // {string} the multilingual label key for the class label
};

module.exports = class ABViewFormTreeCore extends ABViewFormCustom {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABTreeDefaults);
   }

   static common() {
      return ABTreeDefaults;
   }

   static defaultValues() {
      return ABViewFormTreePropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 28181:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewGanttCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewGanttPropertyComponentDefaults = {
   dataviewID: "",
   // {string}
   // {ABDatacollection.id} of the datacollection that contains the data for
   // the Gantt chart.

   titleFieldID: "",
   // {string}
   // {ABFieldXXX.id} of the field that contains the value of the title
   // ABFieldString, ABFieldLongText

   startDateFieldID: "",
   // {string}
   // {ABFieldDate.id} of the field that contains the start date

   endDateFieldID: "",
   // {string}
   // {ABFieldDate.id} of the field that contains the end date

   durationFieldID: "",
   // {string}
   // {ABFieldNumber.id} of the field that contains the duration

   progressFieldID: "",
   // {string}
   // {ABFieldNumber.id} of the field that marks the progress

   notesFieldID: "",
   // {string}
   // {ABFieldXXX.id} of the field that contains the value of the title
   // ABFieldString, ABFieldLongText
};

const ABViewDefaults = {
   key: "gantt", // {string} unique key for this view
   icon: "tasks", // {string} fa-[icon] reference for this view
   labelKey: "Gantt", // {string} the multilingual label key for the class label
};

module.exports = class ABViewGanttCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewGanttPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      Object.keys(ABViewGanttPropertyComponentDefaults).forEach((k) => {
         this.settings[k] =
            this.settings[k] || ABViewGanttPropertyComponentDefaults[k];
      });
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 1063:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewGridCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewGridPropertyComponentDefaults = {
   label: "",
   // {string}
   // label is required and you can add more if the component needs them

   // format:0  	// 0 - normal, 1 - title, 2 - description
   dataviewID: "",
   // {uuid}
   // uuid of ABDataCollection that drives the data for our Grid

   padding: 17,
   // {int}
   // the default padding surrounding the component

   showToolbar: 1,
   // {bool}
   // do we show our toolbar?

   isEditable: 0,
   // {bool}
   // do we allow editing in the grid?

   massUpdate: 0,
   // {bool}
   // do we allow the Mass Update capability? (row checkboxes and the
   // MassUpdate popup)

   allowDelete: 0,
   // {bool}
   // do we allow deleting multiple rows at a time? Mass Delete.

   // isFilterable:0,

   isSortable: 1,
   // {bool}
   // do we allow the sort options.

   isExportable: 0,
   // {bool}
   // do we enable the webix export from grid capabilities?

   // linkedObject:'',
   // linkedField:'',
   // linkedPage:'',
   // linkedPageView:'',
   // linkedEditPage:'',
   // linkedEditPageForm:'',

   detailsPage: "",
   // {ABViewPage.id}
   // the ABViewPage that has the details component.

   detailsTab: "",
   // {ABViewTab.id}
   // the ABViewTab component, that has the details component.
   // NOTE: if your details is embedded on a TAB, we need both the
   // .detailsPage & .detailsTab to successfully show the item.

   editPage: "",
   // {ABViewPage.id}
   // the ABViewPage that has the edit component.

   editTab: "",
   // {ABViewTab.id}
   // the ABViewTab component, that has the edit component.
   // NOTE: if your editor is embedded on a TAB, we need both the
   // .editPage & .editTab to successfully show the form.

   trackView: 0,
   // {bool}
   // Do we offer the ability to track changes to this object/row?

   frozenColumnID: "",
   // {ABField.id}
   // id of column you want to stop freezing the left hand side at.

   hiddenFields: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add hidden:true to

   summaryColumns: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add the SUM footer to

   countColumns: [],
   // {array}  [ ABField.id, ABField.id, ... ]
   // array of [ids] to add the Count footer to

   // TODO: get rid of objectWorkspace!
   objectWorkspace: {
      // sortFields:[], // array of columns with their sort configurations
      // filterConditions:[], // array of filters to apply to the data table
      frozenColumnID: "", // id of column you want to stop freezing
      hiddenFields: [], // array of [ids] to add hidden:true to
      summaryColumns: [],
      countColumns: [],
   },
   gridFilter: {
      filterOption: 1,
      userFilterPosition: "toolbar",
      isGlobalToolbar: 1,
   },
   // summaryFields: [], // array of [field ids] to add the summary column in footer
   // countFields: [], // array of [field ids] to add the summary column in footer

   height: 0,
   // {int}
   // The Height of our Grid.
   // See ../views/ABViewDataview.js

   hideHeader: 0,
   labelAsField: 0,
   hideButtons: 0,
   groupBy: "", // id of field

   // TODO: add to ABDesigner.interface design:
   columnConfig: [],
   // {array} [ {columnHeader}, {columnHeader} ... ]
   // An array of column headers for the grid to display. These should
   // be generated at Design time, and can allow the designer to ORDER the
   // columns, assign column widths, fillspace, etc...
   //    {columnHeader}
   //    The minimum amount of information a Grid needs for it's customization
   //    .id {string} ABField.columnName
   //    .fieldId {string} ABField.id
   //    .width {int}
   //    .fillspace {bool}
   //    .minwidth
   //
   //    When displaying column headers, we will ask the
   //    CurrentObject.columnHeaders(), and then modify them with our settings
   //    here.

   saveLocal: 1,
   // {bool}
   // Allow saving of local changes to our grid display. This will enable
   // a user to modify the Grid display locally.
};

const ABViewDefaults = {
   key: "grid", // {string} unique key for this view
   icon: "table", // {string} fa-[icon] reference for this view
   labelKey: "Grid", // {string} the multilingual label key for the class label
};

/**
 * @function settingsDefault()
 * Verifies a given field is set and if not, defaults to what we havein our
 * ABViewGridPropertyComponentDefaults.
 * NOTE: use this fn() for values that are NOT TRUTHY ... so not for numeric
 * 1 or 0.
 * @param {hash} base
 *        The current settings value hash.
 * @param {string} field
 *        The parameter we are checking.
 */
function settingsDefault(base, field) {
   if (typeof base[field] == "undefined") {
      base[field] = ABViewGridPropertyComponentDefaults[field];
      return;
   }
   base[field] = base[field] || ABViewGridPropertyComponentDefaults[field];
}

/**
 * @function settingsDefaultJSON()
 * Verifies a given field is set and if not, defaults to what we havein our
 * ABViewGridPropertyComponentDefaults.
 * NOTE: use this fn() for values that ARE TRUTHY ... so for numeric 1 or 0
 * @param {hash} base
 *        The current settings value hash.
 * @param {string} field
 *        The parameter we are checking.
 */
function settingsDefaultJSON(base, field) {
   try {
      base[field] = JSON.parse(base[field]);
   } catch (e) {
      base[field] = ABViewGridPropertyComponentDefaults[field];
   }
}

module.exports = class ABViewGridCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewGridPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // if this is being instantiated on a read from the Property UI,
      settingsDefault(this.settings, "dataviewID");

      // Convert to boolean
      // these values are sometimes 0 (number) at this point so the JSON.parse
      // with the || (or) statement was always falling to the default so I am
      // trying to parse the value...if it fails we use the default value
      settingsDefaultJSON(this.settings, "padding");
      settingsDefaultJSON(this.settings, "showToolbar");
      settingsDefaultJSON(this.settings, "isEditable");
      settingsDefaultJSON(this.settings, "massUpdate");
      settingsDefaultJSON(this.settings, "allowDelete");
      // this.settings.isFilterable = JSON.parse(this.settings.isFilterable || ABViewGridPropertyComponentDefaults.isFilterable);
      settingsDefaultJSON(this.settings, "isSortable");
      settingsDefaultJSON(this.settings, "isExportable");
      settingsDefaultJSON(this.settings, "hideHeader");
      settingsDefaultJSON(this.settings, "labelAsField");
      settingsDefaultJSON(this.settings, "hideButtons");
      settingsDefaultJSON(this.settings, "columnConfig");
      settingsDefaultJSON(this.settings, "saveLocal");

      this.settings.gridFilter =
         this.settings.gridFilter ||
         ABViewGridPropertyComponentDefaults.gridFilter;

      try {
         this.settings.gridFilter.filterOption = JSON.parse(
            this.settings.gridFilter.filterOption
         );
      } catch (e) {
         this.settings.gridFilter.filterOption =
            ABViewGridPropertyComponentDefaults.gridFilter.filterOption;
      }

      try {
         this.settings.gridFilter.isGlobalToolbar = JSON.parse(
            this.settings.gridFilter.isGlobalToolbar
         );
      } catch (e) {
         this.settings.gridFilter.isGlobalToolbar =
            ABViewGridPropertyComponentDefaults.gridFilter.isGlobalToolbar;
      }

      // this.settings.linkedObject = this.settings.linkedObject || ABViewGridPropertyComponentDefaults.linkedObject;
      // this.settings.linkedField = this.settings.linkedField || ABViewGridPropertyComponentDefaults.linkedField;
      // this.settings.linkedPage = this.settings.linkedPage || ABViewGridPropertyComponentDefaults.linkedPage;
      // this.settings.linkedPageView = this.settings.linkedPageView || ABViewGridPropertyComponentDefaults.linkedPageView;
      // this.settings.linkedEditPage = this.settings.linkedEditPage || ABViewGridPropertyComponentDefaults.linkedEditPage;
      // this.settings.linkedEditPageForm = this.settings.linkedEditPageForm || ABViewGridPropertyComponentDefaults.linkedEditPageForm;

      settingsDefault(this.settings, "detailsPage");
      settingsDefault(this.settings, "editPage");
      settingsDefault(this.settings, "detailsTab");
      settingsDefault(this.settings, "editTab");
      settingsDefaultJSON(this.settings, "trackView");

      // TODO: remove objectworkspace!
      // this.settings.objectWorkspace =
      //    this.settings.objectWorkspace ||
      //    ABViewGridPropertyComponentDefaults.objectWorkspace;

      // if (typeof this.settings.objectWorkspace != "undefined") {
      //    if (typeof this.settings.objectWorkspace.sortFields == "undefined")
      //       this.settings.objectWorkspace.sortFields = [];
      //    if (
      //       typeof this.settings.objectWorkspace.filterConditions == "undefined"
      //    )
      //       this.settings.objectWorkspace.filterConditions = [];
      //    if (typeof this.settings.objectWorkspace.frozenColumnID == "undefined")
      //       this.settings.objectWorkspace.frozenColumnID = "";
      //    if (typeof this.settings.objectWorkspace.hiddenFields == "undefined")
      //       this.settings.objectWorkspace.hiddenFields = [];
      //    if (typeof this.settings.objectWorkspace.summaryColumns == "undefined")
      //       this.settings.objectWorkspace.summaryColumns = [];
      //    if (typeof this.settings.objectWorkspace.countColumns == "undefined")
      //       this.settings.objectWorkspace.countColumns = [];
      // }

      var owFields = [
         "sortFields",
         "filterConditions",
         "frozenColumnID",
         "hiddenFields",
         "summaryColumns",
         "countColumns",
      ];
      // Transition: if we have an .objectWorkspace, copy those values in here:
      if (this.settings.objectWorkspace) {
         owFields.forEach((f) => {
            if (this.settings[f] == null)
               this.settings[f] = this.settings.objectWorkspace[f];
         });
      }

      // make sure they have actual default values now.
      owFields.forEach((f) => {
         settingsDefault(this.settings, f);
      });

      // we are not allowed to have sub views:
      this._views = [];
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   removeField(field, cb) {
      let shouldSave = false;

      // check to see if there is a frozenColumnID and if it matches the
      // deleted field
      if (this.settings?.frozenColumnID == field.columnName) {
         // remove the column name from the frozen column id
         this.settings.frozenColumnID = "";
         // flag the object to be saved later
         shouldSave = true;
      }

      // check to see if there are hidden fields
      if (this.settings.hiddenFields?.length) {
         // find if the deleted field is in the array
         let index = this.settings.hiddenFields.indexOf(field.columnName);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.hiddenFields.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }

      // check to see if there are Summary fields
      if (this.settings.summaryColumns?.length) {
         // find if the deleted field is in the array
         let index = this.settings.summaryColumns.indexOf(field.id);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.summaryColumns.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }

      // check to see if there are hidden fields
      if (this.settings.countColumns?.length) {
         // find if the deleted field is in the array
         let index = this.settings.countColumns.indexOf(field.id);
         // if so splice it out of the array
         if (index > -1) {
            this.settings.countColumns.splice(index, 1);
            // flag the object to be saved later
            shouldSave = true;
         }
      }
      // if settings were changed call the callback

      cb(null, shouldSave);
   }

   copyUpdateProperyList() {
      return ["detailsPage", "detailsTab", "editPage", "editTab"];
   }
};


/***/ }),

/***/ 94606:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewImageCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewImagePropertyComponentDefaults = {
   filename: "",
   width: 200,
   height: 100,
};

const ABViewDefaults = {
   key: "image", // {string} unique key for this view
   icon: "picture-o", // {string} fa-[icon] reference for this view
   labelKey: "Image", // {string} the multilingual label key for the class label
};

module.exports = class ABViewImageCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewImagePropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.width = parseInt(
         this.settings.width || ABViewImagePropertyComponentDefaults.width
      );
      this.settings.height = parseInt(
         this.settings.height || ABViewImagePropertyComponentDefaults.height
      );
   }
};


/***/ }),

/***/ 42928:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewKanbanCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewKanbanPropertyComponentDefaults = {
   dataviewID: null,
   // {uuid}
   // The ABDataCollection.uuid that we are using to store the data.
   // NOTE: we actually use the DC to get the ABObject it is connected to.

   editFields: [],
   // {array}
   // An array of {ABField.id} that determines which fields should show up
   // in the editor.

   verticalGroupingField: "",
   // {ABField.id}
   // the .id of the ABField instance that determines the Vertical Grouping
   // of the Kanban.

   horizontalGroupingField: "",
   // {ABField.id}
   // the .id of the ABField instance that determines the horizontal Grouping
   // of the Kanban.

   ownerField: "",
   // {ABFieldUser.id}
   // the .id of the ABFieldUser instance that determines the owner of the
   // entries.

   template: "",
   // {json}
   // The {ABViewText} definition used to display the template for this KanBan.
   //
   // A display template used for displaying the information in each Card. The
   // template is a basic string with special placeholders:  {field.id}
   // Given a row of data, the current object will scan the template for any
   // placeholders matching one of it's fields, and then update it with the
   // current value.
};

const ABViewDefaults = {
   key: "kanban",
   // {string}
   // unique key identifier for this ABView object

   icon: "columns",
   // {string}
   // font-awesome icon reference: (without 'fa-' )

   labelKey: "Kanban",
   // {string}
   // the multilingual label key
   // NOTE: will be used as L(labelKey)
};

module.exports = class ABViewKanbanCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   fromValues(values) {
      super.fromValues(values);

      // set a default .template value
      if (!this.settings.template) {
         this.settings.template = { id: `${this.id}_template`, key: "text" };
         this.settings.template.text = this.settings.textTemplate;
      }

      this.TextTemplate = this.AB.viewNewDetatched(this.settings.template);
   }

   toObj() {
      var obj = super.toObj();
      obj.settings.template = this.TextTemplate.toObj();
      // NOTE: this corrects the initial save where this.id == undefined
      // all the rest will set the .id correctly.
      obj.settings.template.id = `${this.id}_template`;
      return obj;
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewKanbanPropertyComponentDefaults;
   }
};


/***/ }),

/***/ 29247:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewLabelCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewLabelPropertyComponentDefaults = {
   text: "",
   format: 0, // 0 - normal, 1 - title, 2 - description
   alignment: "left",
};

const ABViewDefaults = {
   key: "label", // {string} unique key for this view
   icon: "font", // {string} fa-[icon] reference for this view
   labelKey: "Label", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLabelCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewLabelPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, ["label", "text"]);

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values); // <-- this performs the translations

      // if this is being instantiated on a read from the Property UI,
      // .text is coming in under .settings.label
      this.text = values.text || values.settings.text || "*text";

      this.settings.format =
         this.settings.format || ABViewLabelPropertyComponentDefaults.format;
      this.settings.alignment =
         this.settings.alignment ||
         ABViewLabelPropertyComponentDefaults.alignment;

      // we are not allowed to have sub views:
      this._views = [];

      // convert from "0" => 0
      this.settings.format = parseInt(this.settings.format);

      this.translate(this, this, ["label", "text"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   //// Allow external interface to manipulate our settings:

   /**
    * @method formatNormal
    * display text in the normal format.
    */
   formatNormal() {
      this.settings.format = 0;
   }

   /**
    * @method formatTitle
    * display text as a Title.
    */
   formatTitle() {
      this.settings.format = 1;
   }

   /**
    * @method formatDescription
    * display text as a description.
    */
   formatDescription() {
      this.settings.format = 2;
   }
};


/***/ }),

/***/ 79361:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewLayoutCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);
const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const PropertyComponentDefaults = {
   label: "",
   numColumns: 1, // The number of columns for this layout
};

const ABViewDefaults = {
   key: "layout", // {string} unique key for this view
   icon: "columns", // {string} fa-[icon] reference for this view
   labelKey: "Layout", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLayoutCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return PropertyComponentDefaults;
   }

   /**
    * @method addColumn
    * method to actually add a new ABView as one of our columns.
    * This is called by the static .addView() method.
    */
   addColumn() {
      this._views.push(
         this.application.viewNew(
            {
               key: ABViewContainer.common().key,
            },
            this.application,
            this
         )
      );
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      if (isEdited) {
         // if the layout component is being edited in the editor (isEdited == true)
         // then we return [];
         return [];
      } else {
         // the layout view doesn't care what components are offered, it get's
         // the list from it's parent view.
         // ## NOTE: layout views should not be root views.
         if (this.parent) {
            return this.parent.componentList(false);
         } else {
            return [];
         }
      }
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }
};


/***/ }),

/***/ 17145:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewListCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewListPropertyComponentDefaults = {
   dataviewID: null,
   field: null,
   height: 0,
};

const ABViewDefaults = {
   key: "list", // {string} unique key for this view
   icon: "list-ul", // {string} fa-[icon] reference for this view
   labelKey: "List", // {string} the multilingual label key for the class label
};

module.exports = class ABViewLabelCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewListPropertyComponentDefaults;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   field() {
      var dv = this.datacollection;
      if (!dv) return null;

      var object = dv.datasource;
      if (!object) return null;

      return object.fieldByID(this.settings.field);
   }
};


/***/ }),

/***/ 57888:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewMenuCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewMenuPropertyComponentDefaults = {
   orientation: "x",
   buttonStyle: "ab-menu-default",
   menuAlignment: "ab-menu-left",
   menuInToolbar: 1,
   menuPadding: 10,
   menuTheme: "bg_gray",
   menuPosition: "left",
   menuTextLeft: "",
   menuTextRight: "",
   menuTextCenter: "",
   // [
   // 		{
   //			pageId: uuid,
   //			tabId: uuid,
   //			type: string, // "page", "tab"
   //			isChecked: bool,
   //			aliasname: string,
   //			translations: []
   //		}
   // ]
   pages: [],
   order: [],
};

const ABMenuDefaults = {
   key: "menu", // {string} unique key for this view
   icon: "th-large", // {string} fa-[icon] reference for this view
   labelKey: "Menu", // {string} the multilingual label key for the class label
};

module.exports = class ABViewMenuCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABMenuDefaults);
   }

   static common() {
      return ABMenuDefaults;
   }

   static defaultValues() {
      return ABViewMenuPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewMenu instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      this.unTranslate(this, this, [
         "menuTextLeft",
         "menuTextCenter",
         "menuTextRight",
      ]);
      if (this.settings.pages) {
         this.settings.pages.forEach((page) => {
            this.unTranslate(page, page, ["aliasname"]);
         });
      }

      var obj = super.toObj();
      obj.viewIDs = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.translate(this, this, [
         "menuTextLeft",
         "menuTextCenter",
         "menuTextRight",
      ]);

      this.settings.pages =
         this.settings.pages || ABViewMenuPropertyComponentDefaults.pages;

      for (var i = 0; i < this.settings.pages.length; i++) {
         var page = this.settings.pages[i];
         if (page instanceof Object) {
            page.isChecked = JSON.parse(page.isChecked || false);

            this.translate(page, page, ["aliasname"]);
         }
         // Compatible with old data
         else if (typeof page == "string") {
            this.settings.pages[i] = {
               pageId: page,
               isChecked: true,
            };
         }
      }
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   ClearPagesInView(view) {
      // clear menu items
      if (view && view.count() > 1) {
         view.find({}).forEach((item) => {
            view.remove(item.id);
         });
      }
   }

   /**
    * @property datacollection
    * return data source
    * NOTE: this view doesn't track a DataCollection.
    * @return {ABDataCollection}
    */
   get datacollection() {
      return null;
   }

   AddPagesToView(view, pages) {
      if (!view || !pages) return;

      (pages || []).forEach((displayPage) => {
         if (displayPage.isChecked) {
            let existsPage = this.application.pages(
               (p) => p.id == displayPage.pageId,
               true
            )[0];
            if (!existsPage) return;

            var pageAccessLevel = existsPage.getUserAccess();
            if (pageAccessLevel == 0) return;

            if (displayPage.tabId) {
               let existsTab = this.application.views(
                  (v) => v.id == displayPage.tabId,
                  true
               )[0];
               if (!existsTab) return;

               var tabAccessLevel = existsTab.getUserAccess();
               if (tabAccessLevel == 0) return;
            }

            let label = this.getAliasname(displayPage);
            // create a temporaty store for the menu item
            var menuItem;
            // check if page has a parent or not
            if (displayPage.parent && displayPage.parent != "0") {
               // if page has a parent attempt to grab its submenu
               menuItem = view.getSubMenu(displayPage.parent);
            } else {
               // if the page doesn't have parent use the current menu
               menuItem = view;
            }
            // if the menu item doesn't have a menu selected find it
            if (menuItem == null) {
               // get the menu item
               var curMenu = view.getMenuItem(displayPage.parent);
               // create a submenu placeholder
               curMenu.submenu = [];
               // update the menu with the new submenu included
               view.refresh(displayPage.parent);
               // get the submenu we just created
               menuItem = view.getSubMenu(displayPage.parent);
            }
            if (menuItem.exists(displayPage.tabId || displayPage.pageId))
               return;
            // add a new item to the menu/submenu
            menuItem.add(
               {
                  id: displayPage.tabId || displayPage.pageId,
                  value: label,
                  type: displayPage.type,
                  pageId: displayPage.pageId,
                  icon: displayPage.icon
                     ? "fa fa-fw fa-" + displayPage.icon
                     : "",
               },
               displayPage.position ? parseInt(displayPage.position) : 0
            );
         }
      });
   }

   /**
    * @method getAliasname
    * @param pageInfo - an object in settings
    * {
    * 	pageId: uuid,
    * 	tabId: uuid,
    * 	type: string, - "page" or "tab"
    * 	isChecked: bool,
    * 	aliasname: string,
    *	translations: []
    *}
    *
    * @return {string}
    */
   getAliasname(pageInfo) {
      var lang = this.AB.Multilingual.currentLanguage();
      var translation = pageInfo.translations.filter((t) => {
         return t.language_code == lang;
      });

      var label = "";

      if (translation.length) {
         if (translation[0].aliasname) {
            label = translation[0].aliasname;
         } else if (translation[0].label) {
            label = translation[0].label;
         }
      }

      // Just in case there isn't one stored in the translations yet
      if (!label && pageInfo.aliasname) {
         label = pageInfo.aliasname;
      }

      // if alias is empty, then find label of page or tab
      if (
         !label ||
         // remove [en] or [th] etc.
         !label.replace(/\[.{2,}\]/g, "")
      ) {
         // first check to see if we are actually on a page
         // if not recursivly look up for the nearest parent page
         var pageId;
         if (pageInfo.pageId) {
            pageId = pageInfo.pageId;
         } else {
            pageId = this.getParentPageId(pageInfo);
         }
         // find label of the actual page
         var page = this.application.pages((p) => p.id == pageId, true)[0];
         if (page) {
            // find label of the tab view
            if (pageInfo.type == "tab" || pageInfo.key == "viewcontainer") {
               var tabView = page.views(
                  (v) => v.id == pageInfo.tabId || v.id == pageInfo.id,
                  true
               )[0];
               if (tabView) {
                  label = tabView.label;
               }
            } else {
               label = page.label;
            }
         }
      }

      return label;
   }

   getParentPageId(currentView) {
      if (currentView.key != "page") {
         return this.getParentPageId(currentView.parent);
      } else {
         return currentView.id;
      }
   }

   copy(lookUpIds, parent) {
      return super.copy(lookUpIds, parent).then((result) => {
         // update ids of page's settings
         (result.settings.pages || []).forEach((p, i) => {
            let page = result.settings.pages[i];

            // Compatible with old data
            if (typeof page == "string") {
               result.settings.pages[i] = lookUpIds[page];
            } else {
               page.pageId = lookUpIds[page.pageId];
               page.tabId = lookUpIds[page.tabId];
            }
         });

         return result.save().then(() => {
            return result;
         });
      });
   }
};


/***/ }),

/***/ 47497:
/*!********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewPDFImporterCore.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABSubmitRule = __webpack_require__(/*! ../../rules/ABViewRuleListFormSubmitRules */ 17004);

const ABViewPDFImporterPropertyComponentDefaults = {
   dataviewID: null,
   fieldID: null,

   //	[{
   //		action: {string},
   //		when: [
   //			{
   //				fieldId: {UUID},
   //				comparer: {string},
   //				value: {string}
   //			}
   //		],
   //		value: {string}
   //	}]
   submitRules: [],
};

const ABViewDefaults = {
   key: "pdfImporter", // {string} unique key for this view
   icon: "file-pdf-o", // {string} fa-[icon] reference for this view
   labelKey: "PDF Importer", // {string} the multilingual label key for the class label
};

module.exports = class ABViewPDFImporterCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPDFImporterPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.dataviewID =
         this.settings.dataviewID ??
         ABViewPDFImporterPropertyComponentDefaults.dataviewID;

      this.settings.fieldID =
         this.settings.fieldID ??
         ABViewPDFImporterPropertyComponentDefaults.fieldID;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.settings = obj.settings ?? {};

      return obj;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   doSubmitRules(rowDatas) {
      const object = this.datacollection.datasource;

      const SubmitRules = new ABSubmitRule();
      SubmitRules.formLoad(this);
      SubmitRules.fromSettings(this.settings.submitRules);
      SubmitRules.objectLoad(object);

      if (rowDatas && !Array.isArray(rowDatas)) rowDatas = [rowDatas];

      rowDatas?.forEach((rowData) => {
         SubmitRules.process({ data: rowData, form: this });
      });
   }
};


/***/ }),

/***/ 28326:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewPageCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewPage
 *
 * An ABView that represents a "Page" in the system.
 *
 * Pages are
 *	- allowed to be displayed in the interface list
 *	- return a full list of components that can be added to the view editor
 *
 *
 */

const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);
// var ABViewManager = require("../ABViewManager");

// function L(key, altText) {
//     return AD.lang.label.getLabel(key) || altText;
// }

const ABViewDefaults = {
   key: "page", // unique key identifier for this ABView
   icon: "file", // icon reference: (without 'fa-' )
};

const ABPropertyComponentDefaults = {
   type: "page", // 'page', 'popup' or 'reportPage'
   popupWidth: 700,
   popupHeight: 450,
   pageWidth: null,
   fixedPageWidth: 0,
   pageBackground: "ab-background-default",
};

module.exports = class ABViewPageCore extends ABViewContainer {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'viewKey',				// unique key for this View Type
      // 		icon:'font',				// fa-[icon] reference for an icon for this View Type

      //		name: '',					// unique page name

      // 		label:'',					// pulled from translation

      //		settings: {					// unique settings for the type of field
      //		},

      //		translations:[]
      // 	}

      this.parent = null; // will be set by the pageNew() that creates this obj.
      // {obj} .parent
      // this points to the ABView object that manages this object as a child.
      // this param is shared across ABViews as well as ABViewPage, but has
      // different implications ... so we default an ABViewPage.parent = null
      // and the place that Creates the Page must assign the .parent externally.
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   static getPageActionKey(view) {
      return [
         "opstools",
         "AB_" + String(view.application.name).replace(/[^a-z0-9]/gi, ""),
         String(view.name)
            .replace(/[^a-z0-9]/gi, "")
            .toLowerCase(),
         "view",
      ].join(".");
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewPage instance
    * into the values needed for saving to the DB.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.name = this.name;

      obj.myAppID = this.myAppID;

      // icon of popup page
      if (this.settings.type == "popup") obj.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") obj.label = obj.name;

      // compile our pages
      obj.pageIDs = (this._pages || []).map((p) => p.id);

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // icon of popup page
      if (values.settings.type == "popup") this.icon = "clone";

      // set label of the page
      if (!this.label || this.label == "?label?") this.label = this.name;

      // track which application this Page belongs to:
      this.myAppID = values.myAppID;
      if (!this.myAppID && this.application) {
         this.myAppID = this.application.id;
      }

      // now properly handle our sub pages.
      var pages = [];
      (values.pageIDs || []).forEach((id) => {
         var def = this.AB.definitionByID(id);
         if (def) {
            pages.push(this.pageNew(def));
         } else {
            this.AB.error(
               `App[${this.application.name}][${this.application.id}]->Page[${this.name}][${this.id}] referenced an unknown Page[${id}]`
            );
         }
      });
      this._pages = pages;

      // the default columns of ABView is 1
      this.settings.columns = this.settings.columns || 1;
      this.settings.gravity = this.settings.gravity || [1];

      // convert from "0" => 0
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   destroy() {
      return Promise.resolve()
         .then(() => {
            // When deleting an ABViewPage
            // be sure to remove any of it's ABViewPages as well
            // This cleans out any dangling ABDefinitions and cleans up the
            // OpsPortal Permissions:

            var allPageDeletes = [];
            var allPages = this.pages();
            this._pages = [];
            // doing ._pages = [] prevents any of my updates when
            // a sub-page is .destroy()ed

            allPages.forEach((p) => {
               allPageDeletes.push(p.destroy());
            });
            return Promise.all(allPageDeletes);
         })
         .then(() => {
            var parent = this.parent || this.application;

            return parent.pageRemove(this);
         })
         .then(() => {
            return super.destroy();
         });

      // return new Promise((resolve, reject) => {
      //    // verify we have been .save() before:
      //    if (this.id) {
      //       this.application
      //          .viewDestroy(this)
      //          .then(() => {
      //             // remove the page in list
      //             var parent = this.parent || this.application;
      //             var remainingPages = parent.pages((p) => {
      //                return p.id != this.id;
      //             });
      //             parent._pages = remainingPages;

      //             resolve();
      //          })
      //          .catch(reject);
      //    } else {
      //       resolve(); // nothing to do really
      //    }
      // });
   }

   /**
    * @method save()
    * persist this instance of ABViewPage
    * @return {Promise}
    *         .resolve( {this} )
    */
   save() {
      return Promise.resolve()
         .then(() => {
            // this creates our .id
            return super.save();
         })
         .then(() => {
            // now we can persist ourself in our parent
            var parent = this.parent || this.application;

            return parent.pageInsert(this);
         })
         .then(() => {
            return this;
         });
   }

   /**
    * @method refreshInstance()
    * This returns a NEW instance of a ABViewPage based upon the latest
    * version of it's Definition.  It also resolves any current listeners
    * this copy currently has and prepare this to discard itself.
    */
   refreshInstance() {
      console.warn(
         "This version of ABViewPage hasn't updated it's refreshInstance()",
         this
      );
      return this;
   }

   ///
   /// Pages
   ///

   /**
    * @method pages()
    *
    * return an array of all the ABViewPages for this ABViewPage.
    *
    * @param {fn} filter		a filter fn to return a set of ABViewPages that this fn
    *							returns true for.
    * @param {boolean} deep	flag to find in sub pages
    *
    * @return {array}			array of ABViewPages
    */
   pages(filter = () => true, deep = false) {
      var result = [];

      // find into sub-pages recursively
      if (filter && deep) {
         if (this._pages && this._pages.length > 0) {
            result = this._pages.filter(filter);

            if (result.length < 1) {
               this._pages.forEach((p) => {
                  var subPages = p.pages(filter, deep);
                  if (subPages && subPages.length > 0) {
                     result = subPages;
                  }
               });
            }
         }
      }
      // find root pages
      else {
         result = this._pages.filter(filter);
      }

      return result;
   }

   /**
    * @method pageInsert()
    *
    * save the given ABViewPage in our ._pages array and persist the current
    * values if they changed.
    *
    * @param {ABViewPage} page The instance of the page to save.
    * @return {Promise}
    */
   pageInsert(page) {
      var isIncluded = this.pages((o) => o.id === page.id).length > 0;
      if (!isIncluded) {
         // if not already included, then add and save the Obj definition:
         this._pages.push(page);
         return this.save();
      }

      // Nothing was required so return
      return Promise.resolve();
   }

   /**
    * @method pageNew()
    *
    * return an instance of a new (unsaved) ABViewPage that is tied to this
    * ABViewPage.
    *
    * NOTE: this new page is not included in our this.pages until a .save()
    * is performed on the page.
    *
    * @return {ABViewPage}
    */
   pageNew(values) {
      // make sure this is an ABViewPage description
      values.key = ABViewDefaults.key;

      // NOTE: this returns a new ABView component.
      // when creating a new page, the 3rd param should be null, to signify
      // the top level component.
      var page = this.application.viewNew(values, this.application, null);
      page.parent = this;
      return page;
   }

   /**
    * @method pageRemove()
    *
    * remove the given ABViewPage from our ._pages array and persist the current
    * values.
    *
    * @param {ABViewPage} page The instance of the page to remove.
    * @return {Promise}
    */
   pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
      return Promise.resolve();
   }

   /**
    * @method urlView()
    * return the url pointer for views in this application.
    * @return {string}
    */
   urlPage() {
      return this.urlPointer() + "/_pages/";
   }

   /**
    * @method urlPointer()
    * return the url pointer that references this view.  This url pointer
    * should be able to be used by this.application.urlResolve() to return
    * this view object.
    * @return {string}
    */
   urlPointer() {
      if (this.parent) {
         return this.parent.urlPage() + this.id;
      } else {
         return this.application.urlPage() + this.id;
      }
   }

   updateIcon(obj) {
      // icon of page
      if (obj.settings.type == "popup") {
         obj.icon = "clone";
      } else {
         obj.icon = ABViewDefaults.icon;
      }
      return obj;
   }

   /**
    * @method clone()
    * clone the defintions of this ABViewPage object.
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {obj}
    *        defs of the copied ABView
    */
   clone(lookUpIds, parent) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // copy
      let result = super.clone(lookUpIds, parent);

      // page's name should not be duplicate
      result.name = null;

      return result;
   }

   /**
    * @method copy()
    * create a new copy of this ABViewPage object. The resulting ABView should
    * be identical in settings and all sub pages/views, but each new object
    * is a unique view (different ids).
    * @param {obj} lookUpIds
    *        an { oldID : newID } lookup hash for converting ABView objects
    *        and their setting pointers.
    * @param {ABView*} parent
    *        Which ABView should be connected as the parent object of this
    *        copy.
    * @return {Promise}
    *        .resolved with the instance of the copied ABView
    */
   copy(lookUpIds, parent, options) {
      // initial new ids of pages and components
      if (lookUpIds == null) {
         // create a hash of { oldID : newID } of any sub Pages and Views.
         lookUpIds = {};

         let mapNewIdFn = (currView) => {
            if (!lookUpIds[currView.id])
               lookUpIds[currView.id] = this.AB.uuid();

            if (currView.pages) {
               currView.pages().forEach((p) => mapNewIdFn(p));
            }

            if (currView.views) {
               currView.views().forEach((v) => mapNewIdFn(v));
            }
         };

         // start map new ids
         mapNewIdFn(this);
      }

      // now continue with the default .copy()
      return super.copy(lookUpIds, parent, options);
   }
};


/***/ }),

/***/ 89062:
/*!**************************************************!*\
  !*** ./AppBuilder/core/views/ABViewPivotCore.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewPivotPropertyComponentDefaults = {
   dataviewID: null,
   removeMissed: 0,
   totalColumn: 0,
   separateLabel: 0,
   min: 0,
   max: 0,
   height: 0,
};

const ABViewDefaults = {
   key: "pivot", // {string} unique key for this view
   icon: "cube", // {string} fa-[icon] reference for this view
   labelKey: "Pivot", // {string} the multilingual label key for the class label
};

module.exports = class ABViewPivotCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewPivotPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // Convert to boolean
      this.settings.removeMissed = JSON.parse(
         this.settings.removeMissed ||
            ABViewPivotPropertyComponentDefaults.removeMissed
      );
      this.settings.totalColumn = JSON.parse(
         this.settings.totalColumn ||
            ABViewPivotPropertyComponentDefaults.totalColumn
      );
      this.settings.separateLabel = JSON.parse(
         this.settings.separateLabel ||
            ABViewPivotPropertyComponentDefaults.separateLabel
      );
      this.settings.min = JSON.parse(
         this.settings.min || ABViewPivotPropertyComponentDefaults.min
      );
      this.settings.max = JSON.parse(
         this.settings.max || ABViewPivotPropertyComponentDefaults.max
      );

      if (this.settings.structure && typeof this.settings.structure == "string")
         this.settings.structure = JSON.parse(this.settings.structure);

      // "0" -> 0
      this.settings.height = parseInt(
         this.settings.height || ABViewPivotPropertyComponentDefaults.height
      );
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.views = [];
      obj.settings = obj.settings || {};

      if (this.settings.structure)
         obj.settings.structure = JSON.stringify(this.settings.structure);

      return obj;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 78379:
/*!***********************************************************!*\
  !*** ./AppBuilder/core/views/ABViewReportsManagerCore.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewReportManagerPropertyComponentDefaults = {
   dataviewID: "",
   dataviewFields: {
      name: "", // id of a String field
      text: "", // id of a LongText field
      queries: "", // id of a json field
   },
   datacollectionIDs: [],
   editMode: 0,
   hideCommonTab: 0,
   hideDataTab: 0,
   hideViewTab: 0,
};

const ABViewDefaults = {
   key: "reportsManager", // {string} unique key for this view
   icon: "wpforms", // {string} fa-[icon] reference for this view
   labelKey: "Reports Manager", // {string} the multilingual label key for the class label
};

module.exports = class ABViewReportsManagerCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewReportManagerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      const parsedSettings = {};

      Object.keys(ABViewReportManagerPropertyComponentDefaults).forEach(
         (key1) => {
            if (
               typeof ABViewReportManagerPropertyComponentDefaults[key1] ===
                  "object" &&
               !Array.isArray(
                  ABViewReportManagerPropertyComponentDefaults[key1]
               )
            ) {
               parsedSettings[key1] = {};

               Object.keys(
                  ABViewReportManagerPropertyComponentDefaults[key1]
               ).forEach((key2) => {
                  parsedSettings[key1][key2] =
                     this.settings[key1]?.[key2] ??
                     ABViewReportManagerPropertyComponentDefaults[key1][key2];
               });

               return;
            }

            parsedSettings[key1] =
               this.settings[key1] ??
               ABViewReportManagerPropertyComponentDefaults[key1];
         }
      );

      this.settings = parsedSettings;
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      var obj = super.toObj();

      obj.settings = obj.settings || {};

      return obj;
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 47385:
/*!******************************************************!*\
  !*** ./AppBuilder/core/views/ABViewSchedulerCore.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewSchedulerPropertyComponentDefaults = {
   readonly: 0,
   dataviewID: "",
   dataviewFields: {
      name: "", // id of a String field
      start: "", // id of a DateTime field
      end: "", // id of a DateTime field
      allDay: "", // id of a Checkbox field
      repeat: "", // id of a String field
      calendar: "", // id of a String field
      color: "", // id of a String field
      sectionID: "", // id of a String field
      unitID: "", // id of a String field
      notes: "", // id of a LongText field
      originID: "", // id of a LongText field
   },
   calendarDataviewID: "",
   calendarDataviewFields: {
      title: "", // id of a String field
      color: "", // id of a String field
      active: "", // id of a Checkbox field
   },
   timeline: {
      day: 1,
      week: 1,
      month: 1,
      year: 1,
      agenda: 1,
      timeline: 1,
      units: 1,
   },
   timelineSectionList: "",
   unitList: "",
   export: {
      excel: 0,
      csv: 0,
      pdf: 0,
   },
};

const ABViewDefaults = {
   key: "scheduler",
   // {string}
   // unique key for this view

   icon: "calendar",
   // {string}
   // fa-[icon] reference for this view

   labelKey: "Scheduler",
   // {string}
   // the multilingual label key for the class label
};

module.exports = class ABViewSchedulerCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      this._object = null;
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewSchedulerPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.unTranslate(this, this, ["scheduler"]);

      const obj = super.toObj();

      obj.views = [];

      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings = this.settings || {};
      this.settings.dataviewFields = this.settings.dataviewFields || {};
      this.settings.calendarDataviewFields =
         this.settings.calendarDataviewFields || {};
      this.settings.timeline = this.settings.timeline || {};
      this.settings.export = this.settings.export || {};

      const parsedSettings = {};

      Object.keys(ABViewSchedulerPropertyComponentDefaults).forEach((key1) => {
         if (
            typeof ABViewSchedulerPropertyComponentDefaults[key1] === "object"
         ) {
            parsedSettings[key1] = {};

            Object.keys(ABViewSchedulerPropertyComponentDefaults[key1]).forEach(
               (key2) => {
                  parsedSettings[key1][key2] =
                     this.settings[key1][key2] ??
                     ABViewSchedulerPropertyComponentDefaults[key1][key2];
               }
            );

            return;
         }

         parsedSettings[key1] =
            this.settings[key1] ??
            ABViewSchedulerPropertyComponentDefaults[key1];
      });

      this.settings = parsedSettings;

      // if this is being instantiated on a read from the Property UI,
      this.scheduler =
         values.scheduler || ABViewSchedulerPropertyComponentDefaults.scheduler;

      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.translate(this, this, ["scheduler"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 39646:
/*!************************************************!*\
  !*** ./AppBuilder/core/views/ABViewTabCore.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);
const ABViewContainer = __webpack_require__(/*! ../../platform/views/ABViewContainer */ 35798);

const ABViewTabPropertyComponentDefaults = {
   height: 0,
   minWidth: 0,
   stackTabs: 0, // use sidebar view instead of tabview
   darkTheme: 0, // set dark theme css or not
   sidebarWidth: 200, // width of sidebar menu when stacking tabs
   sidebarPos: "left", // the default position of sidebar
   iconOnTop: 0, // do you want to put the icon above the text label?
   hintID: null, // store the ID of a webix hint tutorial for this view
};

const ABViewTabDefaults = {
   key: "tab", // {string} unique key for this view
   icon: "window-maximize", // {string} fa-[icon] reference for this view
   labelKey: "Tab", // {string} the multilingual label key for the class label
};

module.exports = class ABViewTabCore extends ABViewWidget {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewTabDefaults);
   }

   static common() {
      return ABViewTabDefaults;
   }

   static defaultValues() {
      return ABViewTabPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.height = parseInt(this.settings.height);
      this.settings.minWidth = parseInt(this.settings.minWidth || 0);
      this.settings.stackTabs = parseInt(this.settings.stackTabs);
      this.settings.darkTheme = parseInt(this.settings.darkTheme);
      this.settings.sidebarWidth = parseInt(this.settings.sidebarWidth);
      // this.settings.sidebarPos = this.settings.sidebarPos;
      this.settings.iconOnTop = parseInt(this.settings.iconOnTop);
   }

   addTab(tabName, tabIcon) {
      return this.application
         .viewNew(
            {
               key: ABViewContainer.common().key,
               label: tabName,
               tabicon: tabIcon,
            },
            this.application,
            this
         )
         .save();
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }
};


/***/ }),

/***/ 63527:
/*!*************************************************!*\
  !*** ./AppBuilder/core/views/ABViewTextCore.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ../../platform/views/ABViewWidget */ 4814);

const ABViewTextPropertyComponentDefaults = {
   text: "",
   // {string}
   // A multilingual text template that is used to display a given set of
   // values.

   height: 0,
   // {integer}
   // The default height of this widget.

   dataviewID: null,
   // {uuid}
   // The {ABDataCollection.id} of the datacollection this ABViewText is
   // pulling data from.
   // In most usage situations this ABView is tied to the data in an
   // ABDataCollection.  However, it is possible for an ABObject to be
   // directly assigned to the ABView, and that will be used instead.
};

const ABViewDefaults = {
   key: "text",
   // {string}
   // unique key for this view

   icon: "font",
   // {string}
   // fa-[icon] reference for this view

   labelKey: "Text",
   // {string}
   // the multilingual label key for the class label
};

module.exports = class ABViewTextCore extends ABViewWidget {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);

      this._object = null;
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABViewTextPropertyComponentDefaults;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABViewLabel instance
    * into the values needed for saving.
    *
    * @return {json}
    */
   toObj() {
      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.unTranslate(this, this, ["text"]);

      var obj = super.toObj();
      obj.views = [];
      return obj;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings = this.settings || {};

      // convert from "0" => 0
      this.settings.height = parseInt(
         this.settings.height || ABViewTextPropertyComponentDefaults.height
      );

      // if this is being instantiated on a read from the Property UI,
      this.text = values.text || ABViewTextPropertyComponentDefaults.text;

      // NOTE: ABView auto translates/untranslates "label"
      // add in any additional fields here:
      this.translate(this, this, ["text"]);
   }

   /**
    * @method componentList
    * return the list of components available on this view to display in the editor.
    */
   componentList() {
      return [];
   }

   /**
    * @property datacollection
    * return ABDatacollection of this form
    *
    * @return {ABDatacollection}
    */
   get datacollection() {
      if (this.parent?.key == "dataview") {
         return this.AB.datacollectionByID(this.parent.settings.dataviewID);
      } else {
         return this.AB.datacollectionByID(this.settings.dataviewID);
      }
   }

   fieldKey(field) {
      let label = field.label || "";
      label = label.replace(/\(/g, "\\(");
      label = label.replace(/\)/g, "\\)");
      return label;
   }

   displayText(val, componentID) {
      var result = this.text;

      let clearTemplateValue = (result) => {
         return result.replace(/{(.*?)}/g, "");
      };

      var dv = this.datacollection;
      // if (!dv) return clearTemplateValue(result);

      var object = dv?.datasource ?? this._object;
      if (!object) return clearTemplateValue(result);

      const rowData = val || dv.getCursor() || {};

      object.fields().forEach((f) => {
         // add \\ in front of the regular expression special charactors
         // let label = f.label || "";
         // label = label.replace(/\(/g, "\\(");
         // label = label.replace(/\)/g, "\\)");
         let label = this.fieldKey(f);

         var template = new RegExp("{" + label + "}", "g");

         // IDEA: I'd like to keep all the image url logic INSIDE the ABFieldImage
         // object.  Is there some way we can simply call: f.imageTemplate(rowData)
         // and parse the results for the url to display here?

         var data = f.format(rowData);
         if (f.key == "image") {
            var fData = data;
            data = f.urlImage(fData);

            // Question: should we change f.urlImage() to return the defaultImageUrl
            // if fData is "" and .useDefaultImage = true?

            if (
               !fData &&
               f.settings.defaultImageUrl &&
               f.settings.useDefaultImage
            ) {
               data = f.urlImage(f.settings.defaultImageUrl);

               ////
               //// James:  Revisit this and make sure we are handling things ok now.
               // result = result.replace(
               //    "img",
               //    'img onload=\'AD.comm.hub.publish("component.adjust", {"containerID": "' +
               //       componentID +
               //       "\"});' "
               // );
               // } else if (
               //    fData != "" &&
               //    result.indexOf("onload") == -1 &&
               //    componentID
               // ) {
               // result = result.replace(
               //    "img",
               //    'img onload=\'AD.comm.hub.publish("component.adjust", {"containerID": "' +
               //       componentID +
               //       "\"});' "
               // );
            } else {
               ////
               //// James: It looks like this routine assumes the this.text template will
               //// only have 1 <img> tag in it.  Is that necessarilly true?
               ////
               //// If NOT, then we need to rethink this next line:

               result = result.replace(
                  "img",
                  "img onerror='this.parentNode.removeChild(this);' "
               );
            }
         }

         result = result.replace(template, data);
      });

      // Support {uuid} tag in tempalte
      result = result.replace(/{PK}/g, rowData[object.PK()]);

      return result;
   }

   objectLoad(object) {
      this._object = object;
   }
};


/***/ }),

/***/ 8846:
/*!***************************************************!*\
  !*** ./AppBuilder/core/views/ABViewWidgetCore.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABView = __webpack_require__(/*! ../../platform/views/ABView */ 94784);

const ABViewDefaults = {
   key: "viewwidget", // {string} unique key for this view
   icon: "circle-o-notch ", // {string} fa-[icon] reference for this view
   labelKey: "ab.components.widget", // {string} the multilingual label key for the class label
};

const ABPropertyComponentDefaults = {
   columnSpan: 1,
   rowSpan: 1,
};

module.exports = class ABViewWidgetCore extends ABView {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    * @param {obj} defaultValues special sub class defined default values.
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues || ABViewDefaults);
   }

   static common() {
      return ABViewDefaults;
   }

   static defaultValues() {
      return ABPropertyComponentDefaults;
   }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // convert from "0" => 0
      this.settings.columnSpan = parseInt(
         this.settings.columnSpan || ABPropertyComponentDefaults.columnSpan
      );
      this.settings.rowSpan = parseInt(
         this.settings.rowSpan || ABPropertyComponentDefaults.rowSpan
      );
   }
};


/***/ }),

/***/ 95995:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABApplication.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _ = __webpack_require__(/*! lodash */ 53059);

// prettier-ignore
const ABApplicationCore = __webpack_require__(/*! ../core/ABApplicationCore.js */ 45434);

const ABViewPage = __webpack_require__(/*! ./views/ABViewPage */ 2983);
const ABViewManager = __webpack_require__(/*! ./ABViewManager */ 96649);

module.exports = class ABClassApplication extends ABApplicationCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // now listen for any updates to our managed objects
      this._handler_page_updated = (definition) => {
         // we want to keep the same pageID order:
         var newPages = [];
         this.pages().forEach((pg) => {
            if (pg.id === definition.id) {
               newPages.push(pg.refreshInstance(this));
               return;
            }
            newPages.push(pg);
         });

         this._pages = newPages;

         // var currPage = this._pages.find((p) => p.id === definition.id);
         // if (currPage) {
         //    this._pages = this._pages.filter((p) => p.id != currPage.id);
         //    this._pages.push(currPage.refreshInstance());
         // }
      };
      this._pages.forEach((p) => {
         p.on("definition.updated", this._handler_page_updated);
      });
   }

   static applications(/*fn = () => true*/) {
      console.error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      return null;
   }
   static applicationForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.applicationForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   static definitionForID(/*id*/) {
      var errDepreciated = new Error(
         "ABApplication.definitionForID(): Depreciated. Who is doing this?"
      );
      console.error(errDepreciated);
      return null;
   }

   areaKey() {
      return this.AB.kebabCase(`ab-${this.name}`);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABApplication.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.applicationByID(this.id);

      // remove my listeners
      this._pages.forEach((p) => {
         p.removeListener("definition.updated", this._handler_page_updated);
      });

      return newObj;
   }

   ///
   /// Definition
   ///

   /**
    * @method _listInsert()
    * save the given entity into our desired list:
    * @param {varid} entity
    * @param {string} key
    *        the key of the list we are managing
    * @return {Promise}
    */
   async _listInsert(entity, key) {
      var isIncluded = this[key].indexOf(entity.id) != -1;
      if (!isIncluded) {
         this[key].push(entity.id);
         await this.save();
      }
   }

   async _listRemove(entity, key) {
      var begLen = this[key].length;
      this[key] = this[key].filter((id) => {
         return id != entity.id;
      });
      // if there was a change then save this.
      if (begLen != this[key].length) {
         await this.save();
      }
   }

   /**
    * @method datacollectionInsert()
    * persist the current ABDataCollection in our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionInsert(dc) {
      return this._listInsert(dc, "datacollectionIDs");
   }

   /**
    * @method datacollectionRemove()
    * remove the given ABDataCollection from our list of .datacollectionIDs.
    * @param {ABDataCollection} dc
    * @return {Promise}
    */
   datacollectionRemove(dc) {
      return this._listRemove(dc, "datacollectionIDs");
   }

   /**
    * @method objectInsert()
    * persist the current ABObject in our list of .objectIDs.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectInsert(object) {
      return this._listInsert(object, "objectIDs");
   }

   /**
    * @method objectRemove()
    * remove the current ABObject from our list of .objectIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObject} object
    * @return {Promise}
    */
   objectRemove(object) {
      return this._listRemove(object, "objectIDs");
   }

   /**
    * @method processInsert()
    * persist the current ABProcess in our list of .processIDs.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processInsert(process) {
      return this._listInsert(process, "processIDs");
   }

   /**
    * @method processRemove()
    * remove the current ABProcess from our list of .processIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABProcess} process
    * @return {Promise}
    */
   processRemove(process) {
      return this._listRemove(process, "processIDs");
   }

   /**
    * @method queryInsert()
    * persist the current ABObjectQuery in our list of .queryIDs.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryInsert(query) {
      return this._listInsert(query, "queryIDs");
   }

   /**
    * @method queryRemove()
    * remove the current ABObjectQuery from our list of .queryIDs.
    * NOTE: this method persists the changes to the server.
    * @param {ABObjectQuery} query
    * @return {Promise}
    */
   queryRemove(query) {
      return this._listRemove(query, "queryIDs");
   }

   /**
    * @method exportIDs()
    * export any relevant .ids for the necessary operation of this application.
    * @param {array} ids
    *         the array of ids to insert any relevant .ids into
    */
   exportIDs(ids) {
      // make sure we don't get into an infinite loop:
      if (ids.indexOf(this.id) > -1) return;

      ids.push(this.id);

      // start with Objects:
      this.objectsIncluded().forEach((o) => {
         o.exportIDs(ids);
      });

      // get all Hints
      this.hintsIncluded().forEach((h) => {
         h.exportIDs(ids);
      });

      // Queries
      this.queriesIncluded().forEach((q) => {
         q.exportIDs(ids);
      });

      // Datacollections
      // NOTE: currently the server doesn't make instances of DataCollections
      // so we manually parse the related info here:
      this.datacollectionIDs.forEach((dID) => {
         if (ids.indexOf(dID) > -1) return;

         var def = this.AB.definitionByID(dID);
         if (def) {
            ids.push(dID);
            if (def.settings.datasourceID) {
               var object = this.AB.objectByID(def.settings.datasourceID);
               if (object) {
                  object.exportIDs(ids);
               }
            }
         }
      });

      // Processes
      this.processes().forEach((p) => {
         p.exportIDs(ids);
      });

      // Pages
      // NOTE: currently the server doesn't make instances of ABViews
      // so we manually parse the object data here:
      var parseView = (view) => {
         if (ids.indexOf(view.id) > -1) return;
         ids.push(view.id);
         (view.pageIDs || []).forEach((pid) => {
            var pdef = this.AB.definitionByID(pid);
            if (pdef) {
               parseView(pdef);
            }
         });

         (view.viewIDs || []).forEach((vid) => {
            var vdef = this.AB.definitionByID(vid);
            if (vdef) {
               parseView(vdef);
            }
         });
      };

      var pageIDs = this._pages.map((p) => p.id);
      (pageIDs || []).forEach((pid) => {
         var pdef = this.AB.definitionByID(pid);
         if (pdef) {
            parseView(pdef);
         }
      });

      // return only unique entries:
      ids = this.AB.uniq(ids);
   }

   /**
    * @method pageNew()
    * return a new instance of an ABViewPage
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPage}
    */
   pageNew(values) {
      return new ABViewPage(values, this);
   }

   /**
    * @method pageInsert()
    * Insert a new ABViewPage into this Application.
    * @param {ABViewPage} page
    *        The instance of the page to save.
    * @return {Promise}
    */
   async pageInsert(page) {
      // var isIncluded = this.pageByID(page.id);
      var isIncluded = this._pages.filter((p) => p.id == page.id)[0];
      if (!isIncluded) {
         this._pages.push(page);
         // Save our own Info:
         return this.save();
      }
   }

   /**
    * @method pageRemove()
    * remove the current ABViewPage from our list of pages.
    * @param {ABViewPage} page
    * @return {Promise}
    */
   async pageRemove(page) {
      var origLen = this._pages.length;
      this._pages = this.pages(function (p) {
         return p.id != page.id;
      });

      if (this._pages.length < origLen) {
         return this.save();
      }

      // if we get here, then nothing changed so nothing to do.
   }

   save() {
      // if someone just changed the name of our ABApplication, reflect that
      // in our Def.Name
      if (this.name != this.label) {
         this.name = this.label;
      }
      return super.save();
   }

   warningsEval() {
      super.warningsEval();

      //
      // check for valid object references:
      //
      var checks = {
         objectIDs: "object",
         queryIDs: "query",
         datacollectionIDs: "datacollection",
      };

      Object.keys(checks).forEach((k) => {
         this[k].forEach((id) => {
            var def = this.AB.definitionByID(id);
            if (!def) {
               this.warningsMessage(` is referencing a missing ${checks[k]}`, {
                  appID: this.id,
                  id,
               });
            }
         });
      });

      //
      // Make sure there is some way to access this Application:
      //
      if (this.roleAccess.length == 0 && !this.isAccessManaged) {
         this.warningsMessage(" has no Role assigned, and is unaccessible.");
      }

      // do our Role references exist?
      var allRoles = this.AB.Account.rolesAll().map((r) => r.id);
      this.roleAccess.forEach((r) => {
         if (allRoles.indexOf(r) == -1) {
            this.warningsMessage(
               `Specified Role Access [${r}] does not exist in this system`,
               { role: r }
            );
         }
      });

      // Make sure all our Pages perform a new warningsEval();
      this.pages().forEach((p) => {
         p.warningsEval();
      });
   }

   warningsAll() {
      var warnings = [].concat(this._warnings);
      [
         "objectsIncluded",
         "queriesIncluded",
         "datacollectionsIncluded",
         "processes",
         "pages",
         // "views", // <-- these are gathered in "pages"
      ].forEach((k) => {
         this[k]().forEach((o) => {
            warnings = warnings.concat(o.warningsAll());
         });
      });

      return warnings;
   }

   warningsMessage(msg, data = {}) {
      let message = `Application[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   /**
    * @method mobileAppNew()
    *
    * return an instance of a new (unsaved) ABMobileApp that is tied to this
    * ABApplication.
    *
    * @return {ABMobileApp}
    */
   // mobileAppNew(values) {
   //    return new ABMobileApp(values, this);
   // }
};


/***/ }),

/***/ 90804:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/ABApplicationMobile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const _ = __webpack_require__(/*! lodash */ 53059);

// prettier-ignore
const ABApplicationMobileCore = __webpack_require__(/*! ../core/ABApplicationMobileCore.js */ 50085);

const ABViewPageMobile = __webpack_require__(/*! ./mobile/ABMobilePage */ 18315);
const ABViewManager = __webpack_require__(/*! ./ABViewManager */ 96649);

module.exports = class ABClassApplicationMobile extends (
   ABApplicationMobileCore
) {
   constructor(attributes, AB) {
      super(attributes, AB);
   }

   ///
   /// Definition
   ///

   /**
    * @method pageNew()
    * return a new instance of an ABViewPageMobile
    * @param values
    *        The initial settings for the page.
    * @return {ABViewPageMobile}
    */
   pageNew(values) {
      const newPage = new ABViewPageMobile(values, this);
      newPage.parent = this;
      return newPage;
   }

   async setPageDefault(page) {
      if (this.pageDefault != page.id) {
         let oldPage = this.pageByID(this.pageDefault, true);
         if (oldPage) {
            oldPage.defaultPage = 0;
            await oldPage.save();
         }

         this.pageDefault = page.id;
         await this.save();
      }
   }
};


/***/ }),

/***/ 52174:
/*!********************************************!*\
  !*** ./AppBuilder/platform/ABComponent.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABEmitter = __webpack_require__(/*! ./ABEmitter */ 26263);

const CustomComponentManager = __webpack_require__(/*! ../../webix_custom_components/customComponentManager */ 60427);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABComponent extends ABEmitter {
   /**
    * @param {object} App ?what is this?
    * @param {string} idBase Identifier for this component
    * @param {import("../ABFactory").default} AB ABFactory instance
    */
   constructor(App, idBase, AB) {
      super();

      this.AB = AB;
      // Transition Code:
      // make sure we have an this.AB
      if (!AB && App?.AB) {
         this.AB = App.AB;
      }

      if (!App) {
         if (this.AB._App) {
            App = this.AB._App;
         } else {
            App = {
               uuid: this.AB.Webix.uid(),

               /*
                * AB
                * the {ABFactory} for our interface.
                */
               AB: this.AB,

               /*
                * actions:
                * a hash of exposed application methods that are shared among our
                * components, so one component can invoke an action that updates
                * another component.
                */
               actions: {},

               /*
                * config
                * webix configuration settings for our current browser
                */
               config: this.AB.UISettings.config(),

               /*
                * custom
                * a collection of custom components for this App Instance.
                */
               custom: null,

               /*
                * Icons
                * this will provide you with the list of avaialbe font awesome 4.7.0 icons to use in interface building
                */
               icons: this.AB.UISettings.icons,

               Label: L,

               /*
                * labels
                * a collection of labels that are common for the Application.
                */
               labels: {
                  add: L("Add"),
                  create: L("Create"),
                  delete: L("Delete"),
                  edit: L("Edit"),
                  export: L("Export"),
                  formName: L("Name"),
                  import: L("Import"),
                  rename: L("Rename"),
                  ok: L("Ok"),

                  cancel: L("Cancel"),
                  save: L("Save"),

                  yes: L("Yes"),
                  no: L("No"),

                  none: L("None"),
                  close: L("Close"),

                  default: L("Default"),
                  defaultPlaceholder: L("Enter default value"),

                  disable: L("Disable"),

                  required: L("Required"),
                  unique: L("Unique"),

                  invalidMessage: {
                     required: L("This field is required"),
                  },

                  createErrorMessage: L("System could not create <b>{0}</b>."),
                  createSuccessMessage: L("<b>{0}</b> is created."),

                  updateErrorMessage: L("System could not update <b>{0}</b>."),
                  updateSucessMessage: L("<b>{0}</b> is updated."),

                  deleteErrorMessage: L("System could not delete <b>{0}</b>."),
                  deleteSuccessMessage: L("<b>{0}</b> is deleted."),

                  renameErrorMessage: L("System could not rename <b>{0}</b>."),
                  renameSuccessMessage: L("<b>{0}</b> is renamed."),

                  // Data Field  common Property labels:
                  dataFieldHeaderLabel: L("Section Title"),
                  dataFieldHeaderLabelPlaceholder: L("Section Name"),

                  dataFieldLabel: L("Label"),
                  dataFieldLabelPlaceholder: L("Label"),

                  dataFieldColumnName: L("Field Name"),
                  dataFieldColumnNamePlaceholder: L("Database field name"),

                  dataFieldShowIcon: L("show icon?"),

                  componentDropZone: L("add widgets here"),
               },

               /*
                * unique()
                * A function that returns a globally unique Key.
                * @param {string} key   The key to modify and return.
                * @return {string}
                */
               unique: function (key) {
                  return `${key}${this.uuid}`;
               },
            };
            this.AB._App = App;
         }
      }

      if (!App.custom) {
         if (!this.AB.custom) {
            var componentManager = new CustomComponentManager();
            componentManager.initComponents(App);
         } else {
            App.custom = this.AB.custom;
         }
      }

      this.App = App;

      this.idBase = idBase || "?idbase?";
   }

   actions(_actions) {
      console.error("!!! REFACTOR out .actions()");
      if (_actions) {
         for (var a in _actions) {
            this.App.actions[a] = _actions[a];
         }
      }
   }

   Label() {
      return (...params) => {
         // console.error("!! App.label() depreciated.");
         return this.AB.Multilingual.label(...params);
      };
   }

   unique(key) {
      return this.App.unique(`${this.idBase}_${key}`);
   }
};


/***/ }),

/***/ 35122:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ABDataCollection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObjectQuery = __webpack_require__(/*! ./ABObjectQuery */ 76500);
const ABDataCollectionCore = __webpack_require__(/*! ../core/ABDataCollectionCore */ 5179);

module.exports = class ABDataCollection extends ABDataCollectionCore {
   constructor(attributes, AB) {
      super(attributes, AB);
      this.setMaxListeners(0);
   }

   /**
    * @method save()
    *
    * persist this instance of ABDataCollection with it's parent
    *
    *
    * @return {Promise}
    *       .resolve( {this} )
    */
   async save() {
      if (!this.id) {
         this.label = this.label || this.name;
      }
      await super.save();
      this.AB.emit("ab.datacollection.update", {
         datacollectionId: this.id,
      });
      return this;
   }

   isValid() {
      var validator = this.AB.Validation.validator();
      var L = this.AB.Label();

      // label/name must be unique:
      var isNameUnique =
         this.AB.datacollections((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Name must be unique ("{0}" already in use)', [this.name])
         );
      }

      return validator;
   }

   ///
   /// Cursor
   ///

   /**
    * currentUserUsername
    * must return the proper value for the current user that would match a "user" field
    * in an object.
    * This is platform dependent, so must be implemented by a child object.
    * @return {string}
    */
   currentUserUsername() {
      return this.AB.Account.username();
   }

   ///
   /// Data
   ///

   init() {
      // prevent initialize many times
      if (this.initialized) return;
      // this.initialized = true;  // <<---- DO NOT SET THIS HERE

      super.init();

      //// Now connect our platform hub to our Object Triggers:

      // events
      [
         "ab.datacollection.create",
         "ab.datacollection.update",
         "ab.datacollection.stale",
         "ab.datacollection.delete",
      ].forEach((key) => {
         this.AB.on(key, (data) => {
            this.emit(key, data);
         });
      });

      this.bindParentDc();
   }

   bindParentDc() {
      // if we pass the master datacollection and the field it is linked to
      // we want to bind it with that field as second param so dataFeed is
      // used on the slave datacollection
      let dataCollectionLink = this.datacollectionLink;
      let fieldLink = this.fieldLink;
      if (!this.settings.loadAll && dataCollectionLink && fieldLink) {
         let dc = this.__dataCollection;
         // the second param is the field id we bind the data to the master with
         dc.bind(dataCollectionLink.__dataCollection, fieldLink.id);
         // defining dataFeed allows us to query the database when the table is scrolled
         dc.define("dataFeed", (value, params) => {
            let cursorUpdated = false;
            // check if the current cursor was updated
            if (dc.__prevLinkDcCursor != value) {
               cursorUpdated = true;
            }

            dc.__prevLinkDcCursor = this?.datacollectionLink?.getCursor()?.id;

            // NOTE: If no cursor of the parent DC, then show empty list
            if (
               this.datacollectionLink &&
               value == null &&
               dc.__prevLinkDcCursor == null
            ) {
               this.clearAll();
            }
            // this is the same item that was already bound...don't reload data
            else if (cursorUpdated) {
               // now that we have the modified wheres the dataCollections wheres
               // need to be modified for subsequent loads on scroll so lets set them
               // this.reloadWheres(wheres);

               // reload data
               this.reloadData(0, 20);
            }
         });
      }
   }

   loadData(start, limit = 20) {
      return super.loadData(start, limit).catch((err) => {
         // hideProgressOfComponents() is a platform specific action.
         this.hideProgressOfComponents();
         this.emit("loadData", {});

         // propagate the error here:
         if (err) {
            throw err;
         }
      });
   }

   /**
    * processIncomingData()
    * is called from loadData() once the data is returned.  This method
    * allows the platform to make adjustments to the data based upon any
    * platform defined criteria.
    * @param {obj} data  the data as it was returned from the Server
    *        which should be in following format:
    *        {
    *          status: "success", // or "error"
    *          data:[ {ABObjectData}, {ABObjectData}, ...]
    *        }
    */
   processIncomingData(data) {
      // Web Platform:

      // data check:
      if (data.data && !Array.isArray(data.data)) {
         data.data = [data.data];
      }

      // standardize the heights

      /*
       // In v2: we move the row height calculation into the Interface designer.
       //

      // calculate default value of $height of rows
      let obj = this.datasource;
      let defaultHeight = 0;
      let minHeight = 0;
      let imageFields = obj.fields((f) => f.key == "image");
      let hiddenFields = obj.objectWorkspace.hiddenFields;
      imageFields.forEach(function (f) {
         if (hiddenFields.indexOf(f.columnName) == -1) {
            if (
               parseInt(f.settings.useHeight) == 1 &&
               parseInt(f.settings.imageHeight) > minHeight
            ) {
               minHeight = parseInt(f.settings.imageHeight) + 20;
            } else {
               minHeight = 100;
            }
         }
      });
      if (minHeight > 0) {
         defaultHeight = minHeight;
      }

      (data.data || []).forEach((d) => {
         // define $height of rows to render in webix elements
         if (
            d.properties != null &&
            d.properties.height != "undefined" &&
            parseInt(d.properties.height) > 0
         ) {
            d.$height = parseInt(d.properties.height);
         } else if (defaultHeight > 0) {
            d.$height = defaultHeight;
         }
      });
      */

      return super.processIncomingData(data).then(() => {
         // Web Platform:
         // when that is done:
         this.hideProgressOfComponents();
      });
   }

   ///
   /// Components
   ///

   /**
    * @method attachFlexlayout
    *
    *
    * @param {Object} component - a webix flexlayout element instance
    */
   attachFlexlayout(component) {
      var dc = this.__dataCollection;

      // prevent attach many times
      if (this.__flexComponentIds.indexOf(component.config.id) > -1) {
         return;
      } else {
         // keep component id to an array
         this.__flexComponentIds.push(component.config.id);
      }
   }

   /**
    * @method bind
    *
    *
    * @param {Object} component - a webix element instance
    */
   bind(component) {
      var dc = this.__dataCollection;

      // prevent bind many times
      // keep component id to an array
      if (this.__bindComponentIds.indexOf(component.config.id) === -1)
         this.__bindComponentIds.push(component.config.id);

      if ($$(component.config.id).data?.find?.({}).length > 0) return;

      if (
         component.config.view == "datatable" ||
         component.config.view == "dataview" ||
         component.config.view == "treetable" ||
         component.config.view == "kanban"
      ) {
         if (dc) {
            var items = dc.count();
            if (
               items == 0 &&
               (this._dataStatus == this.dataStatusFlag.notInitial ||
                  this._dataStatus == this.dataStatusFlag.initializing) &&
               component.showProgress
            ) {
               component.showProgress({ type: "icon" });
            }

            component.define("datafetch", 20);
            component.define("datathrottle", 500);

            // initial data of treetable
            if (component.config.view == "treetable") {
               if (
                  this.datasource &&
                  this.datasource.isGroup &&
                  this.__treeCollection
               ) {
                  component.define("data", this.__treeCollection);
                  component.refresh();
               } else {
                  // NOTE: tree data does not support dynamic loading when scrolling
                  // https://forum.webix.com/discussion/3078/dynamic-loading-in-treetable
                  component.define("data", []);
                  component.parse(dc.find({}));
               }
            } else {
               component.data.sync(dc);
            }

            // Implement .onDataRequest for paging loading
            if (!this.settings.loadAll) {
               component.___AD = component.___AD || {};
               // if (component.___AD.onDataRequestEvent) component.detachEvent(component.___AD.onDataRequestEvent);
               if (!component.___AD.onDataRequestEvent) {
                  component.___AD.onDataRequestEvent = component.attachEvent(
                     "onDataRequest",
                     (start, count) => {
                        if (component.showProgress)
                           component.showProgress({ type: "icon" });

                        // load more data to the data collection
                        dc.loadNext(count, start);

                        return false; // <-- prevent the default "onDataRequest"
                     }
                  );
               }

               // // NOTE : treetable should use .parse or TreeCollection
               // // https://forum.webix.com/discussion/1694/tree-and-treetable-using-data-from-datacollection
               // if (
               //    component.config.view == "treetable" &&
               //    !this.datasource.isGroup
               // ) {
               //    component.___AD = component.___AD || {};
               //    if (!component.___AD.onDcLoadData) {
               //       component.___AD.onDcLoadData = () => {
               //          component.parse(dc.find({}));
               //       };

               //       this.on("loadData", component.___AD.onDcLoadData);
               //    }
               // }
            }
         } else {
            component.data.unsync();
         }
      } else if (component.bind) {
         if (dc) {
            // Do I need to check if there is any data in the collection before binding?
            component.bind(dc);
         } else {
            component.unbind();
         }

         if (component.refresh) component.refresh();
      }
   }

   unbind(component) {
      if (!component) return;

      component.detachEvent("onDataRequest");
      if (component.___AD) {
         if (component.___AD.onDataRequestEvent)
            delete component.___AD.onDataRequestEvent;

         if (component.___AD.onDcLoadData) {
            if (this.off) this.off("loadData", component.___AD.onDcLoadData);
            delete component.___AD.onDcLoadData;
         }
      }

      if (component.data && component.data.unsync) {
         component.data.unsync();
         component.define("data", []);
      }

      if (component.unbind) component.unbind();

      if (component.refresh) component.refresh();

      // remove from array
      this.__bindComponentIds = (this.__bindComponentIds || []).filter(
         (id) => id != component.config.id
      );
   }

   hideProgressOfComponents() {
      this.__bindComponentIds.forEach((comId) => {
         if ($$(comId) && $$(comId).hideProgress) $$(comId).hideProgress();
      });
   }

   /** Private methods */

   /**
    * @method _dataCollectionNew
    * Get webix.DataCollection
    *
    * @return {webix.DataCollection}
    *
    * @param {Array} data - initial data
    */
   _dataCollectionNew(data) {
      // get a webix data collection
      let dc = new webix.DataCollection({
         data: data || [],
      });

      this._extendCollection(dc);

      return dc;
   }

   /**
    * @method _treeCollectionNew
    * Get webix.TreeCollection
    *
    * @return {webix.TreeCollection}
    *
    */
   _treeCollectionNew() {
      // get a webix data collection
      let treeStore = new webix.TreeCollection();

      this._extendCollection(treeStore);

      return treeStore;
   }

   _extendCollection(dataStore) {
      // Apply this data collection to support multi-selection
      // https://docs.webix.com/api__refs__selectionmodel.html
      webix.extend(dataStore, webix.SelectionModel);

      dataStore.___AD = dataStore.___AD || {};

      // Implement .onDataRequest for paging loading
      if (!this.settings.loadAll) {
         if (!dataStore.___AD.onDataRequestEvent) {
            dataStore.___AD.onDataRequestEvent = dataStore.attachEvent(
               "onDataRequest",
               (start, count) => {
                  if (start < 0) start = 0;

                  // load more data to the data collection
                  this.loadData(start, count);

                  return false; // <-- prevent the default "onDataRequest"
               }
            );
         }

         if (!dataStore.___AD.onAfterLoadEvent) {
            dataStore.___AD.onAfterLoadEvent = dataStore.attachEvent(
               "onAfterLoad",
               () => {
                  this.emit("loadData", {});
               }
            );
         }
      }

      // override unused functions of selection model
      dataStore.addCss = function () {};
      dataStore.removeCss = function () {};
      dataStore.render = function () {};

      if (!dataStore.___AD.onAfterLoad) {
         dataStore.___AD.onAfterLoad = dataStore.attachEvent(
            "onAfterLoad",
            () => {
               this.hideProgressOfComponents();
            }
         );
      }
   }

   parseTreeCollection(data = {}) {
      if (
         !(this.__datasource instanceof ABObjectQuery) ||
         !this.__datasource.isGroup ||
         !this.__treeCollection
      )
         return;

      let addRowToTree = (join = {}, parentAlias = null) => {
         let alias = join.alias;

         (data.data || []).forEach((row) => {
            let dataId = row[`${alias}.uuid`] || row[`${alias}.id`];
            if (!dataId) return;

            // find parent nodes
            let parentItemIds = [];
            let parentId =
               row[`${parentAlias}.uuid`] || row[`${parentAlias}.id`];
            if (parentId) {
               parentItemIds = this.__treeCollection
                  .find(
                     (item) =>
                        item._alias == parentAlias && item._dataId == parentId
                  )
                  .map((item) => item.id);
            }

            // check exists
            let exists = this.__treeCollection.find((item) => {
               return (
                  item._alias == alias &&
                  item._dataId == dataId &&
                  (parentItemIds.length == 0 ||
                     parentItemIds.indexOf(item.$parent) > -1)
               );
            }, true);
            if (exists) return;

            let treeNode = {};
            treeNode._alias = alias;
            treeNode._dataId = dataId;
            treeNode._itemId = row.id; // Keep row id for set cursor to data collection

            Object.keys(row).forEach((propName) => {
               // Pull value from alias
               if (propName.indexOf(`${alias}.`) == 0) {
                  treeNode[propName] = row[propName];
               }
            });

            if (row.translations) treeNode.translations = row.translations;

            // child nodes
            if (parentItemIds.length > 0)
               parentItemIds.forEach((parentItemId) => {
                  this.__treeCollection.add(treeNode, null, parentItemId);
               });
            // root node
            else this.__treeCollection.add(treeNode, null);
         });

         // Sub-joins
         (join.links || []).forEach((link) => {
            addRowToTree(link, alias);
         });
      };

      // Show loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         //// Webix Command here:
         let boundComp = $$(comId);
         if (boundComp && boundComp.showProgress)
            boundComp.showProgress({ type: "icon" });

         if (boundComp.data && boundComp.data.unsync) boundComp.data.unsync();
      });

      addRowToTree(this.__datasource.joins());

      // Hide loading cursor
      (this.__bindComponentIds || []).forEach((comId) => {
         let boundComp = $$(comId);
         if (boundComp && boundComp.hideProgress) boundComp.hideProgress();
         boundComp.define("data", this.__treeCollection);
      });
   }

   warningsEval() {
      super.warningsEval();

      if (!this.datasource) {
         this.warningsMessage(`doesn't have a datasource.`);
      } else if (this.linkDatacollectionID) {
         const linkDC = this.AB.datacollectionById(this.linkDatacollectionID);

         if (!linkDC)
            this.warningsMessage(
               `can't resolve linkDatacollectionID[${this.linkDatacollectionID}]`
            );
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `Datacollection[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   get userScopes() {
      return this.AB.Account.scopes();
   }
};


/***/ }),

/***/ 84650:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/ABDefinition.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ABDefinitionCore = __webpack_require__(/*! ../core/ABDefinitionCore */ 32877);

module.exports = class ABDefinition extends ABDefinitionCore {
   // constructor(attributes, AB) {
   //    super(attributes, AB);
   // }
};


/***/ }),

/***/ 26263:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABEmitter.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABEmitter
 *
 * This is the platform dependent implementation of an Emitter object.
 *
 */

var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);

module.exports = class ABEmitter extends EventEmitter {
   constructor() {
      super(/*{ maxListeners: 0 }*/);
   }
};


/***/ }),

/***/ 17063:
/*!***************************************!*\
  !*** ./AppBuilder/platform/ABHint.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABHintCore = __webpack_require__(/*! ../core/ABHintCore */ 43472);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABHint extends ABHintCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy(App) {
      // debugger;
      // remove all my Elements
      var allSteps = this.steps();
      var allDestroy = [];
      allSteps.forEach((e) => {
         allDestroy.push(e.destroy());
      });
      // remove reference on App and View
      let hintIndex = App.hintIDs.indexOf(this.id);
      if (hintIndex > -1) {
         App.hintIDs.splice(hintIndex, 1);
         App.save();
      }

      let view = App.views((v) => {
         return v.id == this.settings.view;
      })[0];

      if (view) {
         delete view.settings.hintID;
         view.save();
      }

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  webix.message({
                     text: L("Tutorial Deleted"),
                     type: "success",
                     expire: 3000,
                  });
                  resolve();
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }

   createHintUI() {
      // if already loaded skip
      if ($$(this.id)) return;

      let steps = [];
      let next = 0;
      let display = webix.storage.cookie.get(this.id);
      if (display?.hide) return;
      let dontShow = `<label class="dontShow">
                        <input onclick="webix.storage.cookie.put(this.dataset.hintId, {'hide': this.checked});" data-hint-id="${
                           this.id
                        }" type="checkbox">
                        ${L("Don't show this again.")}
                     </label>`;
      this.stepIDs.forEach((step) => {
         next++;
         let newStep = {};
         newStep.id = this._steps[step].id;
         newStep.el = this._steps[step].settings.el;
         newStep.event = this._steps[step].settings.event;
         newStep.title = this._steps[step].name;
         newStep.text = this._steps[step].text + dontShow;
         if (this.stepIDs[next]) {
            newStep.nextEl = this._steps[this.stepIDs[next]].settings.el;
            if (newStep.nextEl) {
               newStep.hintId = this.id;
               newStep.eventEl = "button"; // added this so we do not trigger a second advance on the hint when triggering the click below
               newStep.next = function (event) {
                  let nextEl = this.nextEl;
                  let theNextEl = document.querySelector(nextEl);
                  if (theNextEl && theNextEl.checkVisibility()) {
                     return false;
                  } else {
                     document.querySelector(this.el).click();
                     return false;
                  }
               };
            }
         }
         if (newStep.el) steps.push(newStep);
      });

      let ui = {
         view: "hint",
         id: this.id,
         steps: steps,
         on: {
            onNext: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
            onPrevious: (step) => {
               setTimeout(() => {
                  const boxes = document.querySelectorAll(
                     "input[data-hint-id='" + this.id + "']"
                  );
                  let display = webix.storage.cookie.get(this.id);
                  boxes.forEach((b) => {
                     b.checked = display?.hide || false;
                  });
               }, 100);
            },
         },
      };

      webix.delay(
         () => {
            try {
               webix.ui(ui).start();
            } catch (err) {
               this.AB.notify.developer(err, {
                  context:
                     "ABHint.createUIHint() error calling webix.ui(ui).start()",
                  ui,
               });
            }
         },
         null,
         null,
         2000
      );

      // $$(this.id);
   }
};


/***/ }),

/***/ 97938:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ABIndex.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABIndexCore = __webpack_require__(/*! ../core/ABIndexCore */ 12796);

module.exports = class ABIndex extends ABIndexCore {
   // constructor(attributes, object) {
   //    super(attributes, object);
   // }

   /**
    * @method save()
    * persist this instance of ABIndex with it's parent ABObject
    * @return {Promise}
    */
   save() {
      return super
         .save()
         .then(() => this.object.indexSave(this))
         .then(() => this.migrateCreate());
   }

   /**
    * @method destroy()
    * destroy the current instance of ABIndex
    * also remove it from our parent ABObject
    * @return {Promise}
    */
   destroy() {
      return new Promise((resolve, reject) => {
         if (this.id) {
            this.migrateDrop()
               .then(() => {
                  return super.destroy();
               })
               .then(() => this.object.indexRemove(this))
               .then(resolve)
               .catch(reject);
         } else {
            resolve();
         }
      });
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      if (this.fields.length == 0) {
         this.warningsMessage(`is not referencing any fields`);
      }
   }

   /**
    * @method warningsMessage()
    * generate a commonly formatted warning message for this ABField.
    * This is expected to be called from within a .warningsEval()
    * method when generating warnings.
    * @param {string} msg
    *        the warning string to display
    * @param {json} data
    *        any relevant additional information for a developer to refer to.
    */
   warningsMessage(msg, data = {}) {
      let message = `Index[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
         // data: this.toObj(),
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/index/${this.id}`,
      });
   }
};


/***/ }),

/***/ 70504:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABMLClass.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABMLClass
 * manage the multilingual information of an instance of a AB Defined Class.
 *
 * these classes have certain fields ("label", "description"), that can be
 * represented in different language options as defined by our platform.
 *
 * This platform ABMLClass will define 2 methods that allow for the translation
 * untranslation of this data.
 */
var ABMLClassCore = __webpack_require__(/*! ../core/ABMLClassCore */ 21177);

module.exports = class ABMLClass extends ABMLClassCore {
   constructor(fieldList, AB) {
      super(fieldList, AB);

      this._warnings = [];
      // {array}
      // an array of warning messages for this object.
      // each warning entry should be in the format:
      // WarningMessage: {
      //    message: {string} "message to display"
      //    data: {json} additional debugging information
      // }
   }

   // fromValues(attributes) {
   //    super.fromValues(attributes);
   // }

   /**
    * @method warnings()
    * returns the stored warnings for this ONE object.
    * @return {array} WarningMessage
    */
   warnings() {
      return this._warnings;
   }

   /**
    * @method warningsEval()
    * This method causes an object to re-evaluate it's settings to see if there
    * are any potential errors.
    */
   warningsEval() {
      this._warnings = [];
   }

   /**
    * @method warningsAll()
    * returns all relevant warnings for the current Object. This includes any
    * sub fields, links, views, etc...
    * @return {array} warning structures
    *          [ {WarningMessage}, ... ]
    */
   warningsAll() {
      return this.warnings();
   }

   /**
    * @method languageDefault
    * return a default language code.
    * @return {string}
    */
   languageDefault() {
      return this.AB.Account.language() || "en";
   }

   /**
    * @method destroy()
    * remove this definition.
    * @return {Promise}
    */
   async destroy() {
      var def = this.toDefinition();
      if (def.id) {
         return def.destroy().catch((err) => {
            if (err.toString().indexOf("No record found") > -1) {
               // this is weird, but not breaking:
               console.log(
                  `ABMLClass.destroy(): could not find record for id[${def.id}]`
               );
               console.log(def);
               return;
            }
            throw err;
         });
      }
      return Promise.resolve();
   }

   /**
    * @method save()
    * persist this definition of our {ABxxx} Object
    * @return {Promise}
    */
   async save() {
      var def = this.toDefinition();
      // if not name, try to use our label as the name
      def.name = def.name || this.name || this.label || "name";
      var data = await def.save();
      if (!this.id) {
         this.id = data.id;
      }
   }
};


/***/ }),

/***/ 58174:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ABModel.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABModelCore = __webpack_require__(/*! ../core/ABModelCore */ 69410);

//
// ABModel
//
// Represents the Data interface for an ABObject data.
//
// 2 ways to use an ABModel to load a DataTable:
// 	Method 1:
// 	gather all the data externally and send to the DataTable
//		Model.findAll()
//		.then((data)=>{
//			DataTable.parse(data);
//		})
//
// 	Method 2:
// 	Set the Model object with a condition / skip / limit, then
// 	use it to load the DataTable:
//		Model.where({})
//		.skip(XX)
//		.limit(XX)
//		.loadInto(DataTable);

function errorPopup(error) {
   // Show the pop up
   if (error && error.data && error.data.error == "READONLY") {
      webix.alert({
         title: "Your action is blocked",
         ok: "Ok",
         text: error.data.message || "",
         type: "alert-warning",
      });
   }
}

/*
 * @function no_socket_trigger()
 * a common routine to trigger an update.
 * In the case where our AB.Network.type() isn't a socket implementation
 * we need to manually trigger the expected socket events ourselves.
 * This fn() attempts to simulate the socket responses in such a case.
 * @param {ABModel} model
 *        The ABModel currently processing the network transaction.
 * @param {string} key
 *        The socket update trigger we are simulating.
 * @param {json} data
 *        The relevant response from our network transaction.
 */
function no_socket_trigger(model, key, data) {
   // If we do not have socket updates available, then trigger an
   // update event with this data.
   if (model.AB.Network.type() != "socket") {
      model.AB.emit(key, {
         objectId: model.object.id,
         data,
      });
   }
}

module.exports = class ABModel extends ABModelCore {
   constructor(object) {
      super(object);

      this.handler_create = (...params) => {
         this.handler_common("ab.datacollection.create", ...params);
      };

      this.handler_delete = (...params) => {
         this.handler_common("ab.datacollection.delete", ...params);
      };

      this.handler_findAll = (...params) => {
         this.handler_common(null, ...params);
      };

      this.handler_logs = (context, err, data) => {
         if (err) {
            context.reject?.(err);
            return;
         }
         context.resolve?.(data);
      };

      this.handler_update = (...params) => {
         this.handler_common("ab.datacollection.update", ...params);
      };

      this.handler_common = (key, context, err, data) => {
         // key: {string} the relevant socket event key
         //      can be null if not relevant.
         // context : {obj} any provided context data provided on the
         //           this.AB.Network.get() call.
         // err: {Error} any returned error message from api
         // data: {obj} returned data from the model-get api in format:
         //       {data: [], total_count: 1, pos: 0, offset: 0, limit: 0}
         if (err) {
            context.reject?.(err);
            return;
         }

         // let jobID = this.AB.jobID();
         // console.log(`${jobID} : normalization begin`);
         // let timeFrom = performance.now();
         if (key) {
            // on "update" & "create" we want to normalizeData()
            if (key.indexOf("delete") == -1) {
               this.normalizeData(data);
            }
         } else {
            // on a findAll we normalize data.data
            this.normalizeData(data.data);
         }
         // let timeTo = performance.now();
         // console.log(`${jobID} : normalization end:  ${timeTo - timeFrom}ms`);

         context.resolve?.(data);

         // if (key) {
         //    no_socket_trigger(this, key, data);
         // }
      };
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   // Prepare multilingual fields to be untranslated
   // Before untranslating we need to ensure that values.translations is set.
   prepareMultilingualData(values) {
      // if this object has some multilingual fields, translate the data:
      var mlFields = this.object.multilingualFields();
      // if mlFields are inside of the values saved we want to translate otherwise do not because it will reset the translation field and you may loose unchanged translations
      var shouldTranslate = false;
      if (mlFields.length) {
         mlFields.forEach(function (field) {
            if (values[field] != null) {
               shouldTranslate = true;
            }
         });
      }
      if (shouldTranslate) {
         if (
            values.translations == null ||
            typeof values.translations == "undefined" ||
            values.translations == ""
         ) {
            values.translations = [];
         }
         this.object.unTranslate(values, values, mlFields);
      }
   }

   request(method, params) {
      return this.AB.Network[method](params);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      values.batch.map((vals) => {
         return this.prepareMultilingualData(vals.data);
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err, data) => {
            if (err) {
               reject(err);
               return;
            }
            this.normalizeData(data);
            resolve(data);
            // FIX: now with sockets, the triggers are fired from socket updates.
            // trigger a create event
            // triggerEvent('create', this.object, data);
         });

         this.AB.Network.post(
            {
               url: this.object.urlRestBatch(),
               params: values,
            },
            {
               key: jobID,
               context: {},
            }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // FIX: now with sockets, the triggers are fired from socket updates.
            //    // trigger a create event
            //    // triggerEvent('create', this.object, data);
            // })
            .catch(reject);
      });
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      this.prepareMultilingualData(values);

      // add default values record if no value is passed for column
      this.object.fields().forEach((f) => {
         if (values[f.columnName] === undefined) {
            f.defaultValue(values);
         }
      });

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_create);
         this.AB.Network.post(
            {
               url: this.object.urlRest(),
               params: values,
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         )
            .then((newVal) => {})
            .catch((err) => {
               errorPopup(err);
               reject(err);
            });
      }).then((newVal) => {
         no_socket_trigger(this, "ab.datacollection.create", newVal);
         return newVal;
      });
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_delete);
         this.AB.Network["delete"](
            {
               url: this.object.urlRestItem(id),
            },
            {
               key: jobID,
               id,
               context: { resolve, reject },
            }
         ).catch((err) => {
            errorPopup(err);
            reject(err);
         });
      }).then((res) => {
         // properly issue the delete
         no_socket_trigger(this, "ab.datacollection.delete", id);
         return res;
      });
   }

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   async findAll(cond) {
      cond = cond || {};

      // 		// prepare our condition:
      // 		var newCond = {};

      // 		// if the provided cond looks like our { where:{}, skip:xx, limit:xx } format,
      // 		// just use this one.
      // 		if (cond.where) {
      // 			newCond = cond;
      // 		} else {

      // 			// else, assume the provided condition is the .where clause.
      // 			newCond.where = cond;
      // 		}

      // /// if this is our depreciated format:
      // if (newCond.where.where) {
      // 	OP.Error.log('Depreciated Embedded .where condition.');
      // }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_findAll);
         this.AB.Network.get(
            {
               url: this.object.urlRest(),
               params: cond,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         )
            // .then((data) => {
            //    this.normalizeData(data.data);

            //    resolve(data);
            // })
            .catch((err) => {
               if (err && err.code) {
                  switch (err.code) {
                     case "ER_PARSE_ERROR":
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Parse Error with provided condition",
                           condition: cond,
                        });
                        break;

                     default:
                        this.AB.notify.developer(err, {
                           message:
                              "AppBuilder:ABModel:findAll(): Unknown Error with provided condition",
                           condition: cond,
                        });
                        break;
                  }
               }
               reject(err);
            });
      });
   }

   /**
    * @method loadInto
    * loads the current values into the provided Webix DataTable
    * @param {DataTable} DT  A Webix component that can dynamically load data.
    */
   loadInto(DT) {
      // if a limit was applied, then this component should be loading dynamically
      if (this._limit) {
         DT.define("datafetch", this._limit);
         DT.define("datathrottle", 250); // 250ms???

         // catch the event where data is requested:
         // here we will do our own findAll() so we can persist
         // the provided .where condition.

         // oh yeah, and make sure to remove any existing event handler when we
         // perform a new .loadInto()
         DT.___AD = DT.___AD || {};
         if (DT.___AD.onDataRequestEvent) {
            DT.detachEvent(DT.___AD.onDataRequestEvent);
         }
         DT.___AD.onDataRequestEvent = DT.attachEvent(
            "onDataRequest",
            (start, count) => {
               var cond = {
                  where: this._where,
                  sort: this._sort,
                  limit: count,
                  skip: start,
               };

               if (DT.showProgress) DT.showProgress({ type: "icon" });

               this.findAll(cond).then((data) => {
                  /*
                   // In V2: we move the row height processing into 
                   // the interface designer 

                  data.data.forEach((item) => {
                     if (
                        item.properties != null &&
                        item.properties.height != "undefined" &&
                        parseInt(item.properties.height) > 0
                     ) {
                        item.$height = parseInt(item.properties.height);
                     } else if (parseInt(this._where.height) > 0) {
                        item.$height = parseInt(this._where.height);
                     }
                  });
                  */
                  DT.parse(data);

                  if (DT.hideProgress) DT.hideProgress();
               });

               return false; // <-- prevent the default "onDataRequest"
            }
         );

         DT.refresh();
      }

      // else just load it all at once:
      var cond = {};
      if (this._where) cond.where = this._where;
      if (this._sort) cond.sort = this._sort;
      if (this._limit != null) cond.limit = this._limit;
      if (this._skip != null) cond.skip = this._skip;

      if (DT.showProgress) DT.showProgress({ type: "icon" });

      this.findAll(cond)
         .then((data) => {
            // v2: we no longer process item $height
            /*
            data.data.forEach((item) => {
               if (
                  item.properties != null &&
                  item.properties.height != "undefined" &&
                  parseInt(item.properties.height) > 0
               ) {
                  item.$height = parseInt(item.properties.height);
               } else if (parseInt(this._where.height) > 0) {
                  item.$height = parseInt(this._where.height);
               }
            });
            */

            DT.parse(data);

            if (DT.hideProgress) DT.hideProgress();
         })
         .catch((err) => {
            console.error("!!!!!", err);
         });
   }

   /**
    * @method logs()
    * return the log history related to this model's ABObject.
    * @param {hash} options
    *        a key=>value hash of optional search criteria
    *        .rowId {string} the uuid of the individual entry we are querying
    *        .levelName {string} the type of entry ["insert", "update", "delete"]
    *        .username {string} the entries associated with the given user
    *        .startDate {date} entries that happened ON or AFTER this date
    *        .endDate {date} entries that happened ON or BEFORE this date
    *        .start {integer} paging control: how many entries to skip
    *        .limit {integer} paging control: only return this # entries
    * @return {Promise}
    */
   logs(options) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_logs);
         this.AB.Network.get(
            {
               url: this.object.urlRestLog(),
               params: options,
               // params: newCond
            },
            {
               key: jobID,
               context: { resolve, reject },
            }
         ).catch((err) => {
            if (err && err.code) {
               this.AB.notify.developer(err, {
                  context: "AppBuilder:ABModel:logs(): Error",
                  options,
               });
            }
            reject(err);
         });
      });
   }

   /**
    * @method limit
    * set the limit value for this set of data
    * @param {integer} limit  the number or elements to return in this call
    * @return {ABModel} this object that is chainable.
    */
   limit(limit) {
      this._limit = limit;
      return this;
   }

   /**
    * @method skip
    * set the skip value for this set of data
    * @param {integer} skip  the number or elements to skip
    * @return {ABModel} this object that is chainable.
    */
   skip(skip) {
      this._skip = skip;
      return this;
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      this.prepareMultilingualData(values);

      // remove empty properties
      for (var key in values) {
         if (values[key] == null) delete values[key];
      }

      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, this.handler_update);
         this.AB.Network.put(
            {
               url: this.object.urlRestItem(id),
               params: values,
            },
            { key: jobID, context: { resolve, reject } }
         )
            // .then((data) => {
            //    this.normalizeData(data);

            //    resolve(data);

            //    // If we do not have socket updates available, then trigger an
            //    // update event with this data.
            //    if (this.AB.Network.type() != "socket") {
            //       this.AB.emit("ab.datacollection.update", {
            //          objectId: this.object.id,
            //          data,
            //       });
            //    }
            // })
            .catch((err) => {
               errorPopup(err);
               reject(err);
            });
      }).then((newVal) => {
         // properly issue the update
         no_socket_trigger(this, "ab.datacollection.update", newVal);
         return newVal;
      });
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      return new Promise((resolve, reject) => {
         var jobID = this.AB.jobID();
         this.AB.Network.once(jobID, (context, err /*, data */) => {
            if (err) {
               reject(err);
               return;
            }
            // this.normalizeData(data);
            resolve(true);
            // what about checking for socket updates?
         });
         this.AB.Network.put(
            {
               url: this.object.urlRestBatch(),
               params: {
                  rowIds,
                  values,
               },
            },
            { key: jobID, context: {} }
         )
            // .then(() => {
            //    resolve(true);
            // })
            .catch(reject);
      });
   }
};


/***/ }),

/***/ 34697:
/*!*******************************************!*\
  !*** ./AppBuilder/platform/ABModelApi.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABModelAPI
//
// Represents the Data interface for an ABObjectQuery data.

const ABModel = __webpack_require__(/*! ./ABModel */ 58174);

module.exports = class ABModelAPI extends ABModel {
   ///
   /// Instance Methods
   ///

   /**
    * @method findAll
    * performs a data find with the provided condition.
    */
   async findAll(cond = {}) {
      cond.isAPI = true;
      cond.url = this.object?.request?.url;

      return super.findAll(cond);
   }

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.batchCreate() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   async create(values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.create() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.delete() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.update() does not be implemented."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      const error = new Error(
         "ABObjectApi.ABModelAPI.batchUpdate() does not be implemented."
      );
      return Promise.reject(error);
   }
};


/***/ }),

/***/ 63549:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/ABModelQuery.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABModelQuery
//
// Represents the Data interface for an ABObjectQuery data.

const ABModel = __webpack_require__(/*! ./ABModel */ 58174);

module.exports = class ABModelQuery extends ABModel {
   ///
   /// Instance Methods
   ///

   /**
    * @method batchCreate
    * update model values on the server.
    */
   batchCreate(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchCreate() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method create
    * update model values on the server.
    */
   create(values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.create() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method delete
    * remove this model instance from the server
    * @param {integer|UUID} id  the .id of the instance to remove.
    * @return {Promise}
    */
   delete(id) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.delete() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method update
    * update model values on the server.
    */
   update(id, values) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.update() should not be called."
      );
      return Promise.reject(error);
   }

   /**
    * @method batchUpdate
    * update value to many rows on the server.
    */
   batchUpdate({ rowIds, values }) {
      var error = new Error(
         "ABObjectQuery.ABModelQuery.batchUpdate() should not be called."
      );
      return Promise.reject(error);
   }
};


/***/ }),

/***/ 24869:
/*!*****************************************!*\
  !*** ./AppBuilder/platform/ABObject.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObjectCore = __webpack_require__(/*! ../core/ABObjectCore */ 83899);

let L = (...params) => AB.Multilingual.label(...params);

// NOTE: this has been moved to NetworkRestSocket:
//
// // Start listening for server events for object updates and call triggerEvent as the callback
// if (typeof io != "undefined") {
//    io.socket.on("ab.object.update", function (msg) {
//       AB.emit("ab.object.update", {
//          objectId: msg.objectId,
//          data: msg.data,
//       });
//    });
// } else {
//    console.error("TODO: ABObject: configure Socket.io");
// }

// io.socket.on("ab.object.delete", function (msg) {
// });

module.exports = class ABObject extends ABObjectCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen for our ABFields."definition.updated"
      this.fields().forEach((f) => {
         f.on("definition.updated", (field) => {
            // create a new Field with the updated def
            var def = this.AB.definitionByID(field.id);
            if (!def) return;

            var newField = this.AB.fieldNew(def, this);

            // we want to keep the same fieldID order:
            var newFields = [];
            this.fields().forEach((f) => {
               if (f.id === field.id) {
                  newFields.push(newField);
                  return;
               }
               newFields.push(f);
            });

            this._fields = newFields;
         });
      });

      // listen
      // this.AB.on("ab.object.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });

      this._pendingNetworkRequests = {};
      // {hash}   uuid : {Promise}
      // convert our migrateXXXX() operations to be Relay/offline compatible.
      // if a queued operation is sent after a web browser refresh, then
      // we will NOT have a pending promise to .resolve()/.reject()

      this._handler_object_migrate = (context, err, response) => {
         // NOTE:
         var pending = this._pendingNetworkRequests?.[context.uuid];
         if (err) {
            pending?.reject(err);
            return;
         }
         pending?.resolve(response);
      };
      this.AB.Network.on("object.migrate", this._handler_object_migrate);
   }

   /**
    * @method refreshInstance()
    * Used when a definition.updated message is detected on this ABObject.
    * This method will return a new instance based upon the current definition
    * and properly resolve any handlers and pending network Requests.
    * @return {ABObject}
    */
   refreshInstance() {
      var newObj = this.AB.objectByID(this.id);

      // prevent doing this multiple times:
      if (this._pendingNetworkRequests) {
         // remove object.migrate listener
         this.AB.Network.removeListener(
            "object.migrate",
            this._handler_object_migrate
         );

         // transfer the pending network requests
         newObj._pendingNetworkRequests = this._pendingNetworkRequests;
         this._pendingNetworkRequests = null;
      }

      return newObj;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   fromValues(attributes) {
      /*
		{
			id: uuid(),
			name: 'name',
			labelFormat: 'xxxxx',
			isImported: 1/0,
			isExternal: 1/0,
			urlPath:'string',
			importFromObject: 'string', // JSON Schema style reference:  '#[ABApplication.id]/objects/[ABObject.id]'
										// to get other object:  ABApplication.objectFromRef(obj.importFromObject);
			translations:[
				{}
			],
			fields:[
				{ABDataField}
			]
		}
		*/

      super.fromValues(attributes);

      if (this.workspaceViews) this.workspaceViews.fromObj(attributes);
   }

   //// TODO: Refactor isValid() to ignore op and not error if duplicateName is own .id

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.objects((o) => {
            return (
               o.id != this.id &&
               o.name.toLowerCase() == this.name.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L('Object name must be unique ("{0}" already in use)', [this.name])
         );
      }

      // Check the common validations:
      // TODO:
      // if (!inputValidator.validate(values.label)) {
      // 	_logic.buttonSaveEnable();
      // 	return false;
      // }

      return validator;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an array of any invalid
    * value errors.
    * @param {obj} data a key=>value hash of the inputs to parse.
    * @return {array}
    */
   isValidData(data) {
      var validator = this.AB.Validation.validator();
      this.fields().forEach((f) => {
         // check if value was passed, if so validate it
         if (Object.prototype.hasOwnProperty.call(data, f.columnName))
            f.isValidData(data, validator);
      });

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fieldNew()
    *
    * return an instance of a new (unsaved) ABField that is tied to this
    * ABObject.
    *
    * NOTE: this new field is not included in our this.fields until a .save()
    * is performed on the field.
    *
    * @param {obj} values  the initial values for this field.
    *						{ key:'{string}'} is required
    * @return {ABField}
    */
   // fieldNew ( values ) {
   // 	// NOTE: ABFieldManager returns the proper ABFieldXXXX instance.
   // 	return ABFieldManager.newField( values, this );
   // }

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   async destroy() {
      /*
        return new Promise((resolve, reject) => {
            // Remove the import object, then its model will not be destroyed
            if (this.isImported) {
                this.application
                    .objectDestroy(this)
                    .catch(reject)
                    .then(() => {
                        resolve();
                    });

                return;
            }

            // OK, some of our Fields have special follow up actions that need to be
            // considered when they no longer exist, so before we simply drop this
            // object/table, drop each of our fields and give them a chance to clean up
            // what needs cleaning up.

            // ==> More work, but safer.
            var fieldDrops = [];
            this.fields().forEach((f) => {
                fieldDrops.push(f.destroy());
            });

            Promise.all(fieldDrops)
                .then(() => {
                    return new Promise((next, err) => {
                        // now drop our table
                        // NOTE: our .migrateXXX() routines expect the object to currently exist
                        // in the DB before we perform the DB operations.  So we need to
                        // .migrateDrop()  before we actually .objectDestroy() this.
                        this.migrateDrop()
                            .then(() => {
                                // finally remove us from the application storage
                                return this.application.objectDestroy(this);
                            })
                            .then(next)
                            .catch(err);
                    });
                })

                // flag .disable to queries who contains this removed object
                .then(() => {
                    return new Promise((next, err) => {
                        this.application
                            .queries(
                                (q) =>
                                    q.objects((o) => o.id == this.id).length > 0
                            )
                            .forEach((q) => {
                                q._objects = q.objects((o) => o.id != this.id);

                                q.disabled = true;
                            });

                        next();
                    });
                })
                .then(resolve)
                .catch(reject);
        });
 */

      var removeFromApplications = () => {
         var allRemoves = [];
         this.AB.applications().forEach((app) => {
            allRemoves.push(app.objectRemove(this));
         });
         return Promise.all(allRemoves);
      };

      var disableRelatedQueries = () => {
         return new Promise((next /*, err */) => {
            this.AB.queries(
               (q) => q.objects((o) => o.id == this.id).length > 0
            ).forEach((q) => {
               // q._objects = q.objects((o) => o.id != this.id);

               q.disabled = true;
            });

            next();
         });
      };

      try {
         // 1) remove us from all Application:
         await removeFromApplications();

         // 2) disable any connected Queries
         await disableRelatedQueries();

         // if an imported Object (FederatedTable, Existing Table, etc...)
         // then skip this step
         if (this.isImported) {
            return Promise.resolve();
         }

         // time to remove my table:
         // NOTE: our .migrateXXX() routines expect the object to currently exist
         // in the DB before we perform the DB operations.  So we need to
         // .migrateDrop()  before we actually .destroy() this.
         await this.migrateDrop();

         // now remove my definition

         // start with my fields:
         var fieldDrops = [];

         // Only ABObjects should attempt any fieldDrops.
         // ABObjectQueries can safely skip this step:
         if (this.type == "object") {
            var allFields = this.fields();
            this._fields = []; // clear our field counter so we don't retrigger
            // this.save() on each field.destroy();

            allFields.forEach((f) => {
               fieldDrops.push(f.destroy());
            });
         }
         await Promise.all(fieldDrops);

         await super.destroy();
         this.emit("destroyed");
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.destroy(): error destroying object.",
         });
      }

      // return Promise.resolve()
      //    .then(() => {
      //       // 1) remove us from all Application:
      //       return removeFromApplications();
      //    })
      //    .then(() => {
      //       // 2) disable any connected Queries
      //       return disableRelatedQueries();
      //    })
      //    .then(() => {
      //       // if an imported Object (FederatedTable, Existing Table, etc...)
      //       // then skip this step
      //       if (this.isImported) {
      //          return Promise.resolve();
      //       }

      //       // time to remove my table:
      //       // NOTE: our .migrateXXX() routines expect the object to currently exist
      //       // in the DB before we perform the DB operations.  So we need to
      //       // .migrateDrop()  before we actually .destroy() this.
      //       return this.migrateDrop();
      //    })
      //    .then(() => {
      //       // now remove my definition

      //       // start with my fields:
      //       var fieldDrops = [];

      //       // Only ABObjects should attempt any fieldDrops.
      //       // ABObjectQueries can safely skip this step:
      //       if (this.type == "object") {
      //          var allFields = this.fields();
      //          this._fields = []; // clear our field counter so we don't retrigger
      //          // this.save() on each field.destroy();

      //          allFields.forEach((f) => {
      //             fieldDrops.push(f.destroy());
      //          });
      //       }

      //       return Promise.all(fieldDrops)
      //          .then(() => {
      //             // now me.
      //             return super.destroy();
      //          })
      //          .then(() => {
      //             this.emit("destroyed");
      //          });
      //    });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save(skipMigrate = false) {
      var isAdd = false;

      // if this is our initial save()
      if (!this.id) {
         this.label = this.label || this.name;
         isAdd = true;
      }

      try {
         await super.save();
         if (isAdd && !skipMigrate) {
            await this.migrateCreate();
         }
         return this;
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABObject.save()",
            obj: this.toObj(),
         });
         throw err;
      }
   }

   /**
    * @method toObj()
    *
    * properly compile the current state of this ABApplication instance
    * into the values needed for saving to the DB.
    *
    * Most of the instance data is stored in .json field, so be sure to
    * update that from all the current values of our child fields.
    *
    * @return {json}
    */
   toObj() {
      var result = super.toObj();

      result.objectWorkspaceViews = this.workspaceViews?.toObj();

      return result;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network.post(
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   migrateDrop() {
      return new Promise((resolve, reject) => {
         var uuid = this.AB.uuid();
         this._pendingNetworkRequests[uuid] = { resolve, reject };
         var jobResponse = {
            key: "object.migrate",
            context: { uuid, id: this.id },
         };
         this.AB.Network["delete"](
            {
               url: `/definition/migrate/object/${this.id}`,
            },
            jobResponse
         );
      });
   }

   ///
   /// Working with Client Components:
   ///

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth /*, oldWidth */) {
      var fieldID = null;
      for (var i = 0; i < this._fields.length; i++) {
         if (this._fields[i].columnName == columnName) {
            fieldID = this._fields[i].id;
            break;
            // this._fields[i].settings.width = newWidth;
         }
      }

      // Johnny: This is better but still not right.  the ABObject should not be
      // storing sizes for field widths.  That is a function of the UI and which
      // Grid is being displayed.  THAT GRID should be storing a column width
      // locally.
      // TODO: once we have v2 in place.

      var fieldSettings = this.AB.localSettings(fieldID);
      fieldSettings = fieldSettings || {};
      fieldSettings.width = newWidth;

      return this.AB.localSettings(fieldID, fieldSettings);
      // return this.save();
   }

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      summaryColumns = summaryColumns || [];
      countColumns = countColumns || [];

      var headers = [];
      // var columnNameLookup = {};

      // get the header for each of our fields:
      this.fields().forEach((f) => {
         var header = f.columnHeader({
            isObjectWorkspace: isObjectWorkspace,
            editable: isEditable,
         });

         if (isEditable) {
            header.validationRules = f.settings.validationRules;
         }

         header.alias = f.alias || undefined; // query type
         header.fieldID = f.id;
         // header.fieldURL = f.urlPointer();

         // if the field specifies a width
         if (f.settings.width != 0) {
            header.width = f.settings.width;
         }

         // if the User has already updated a local width for this
         var fieldSettings = this.AB.localSettings(f.id);
         if (fieldSettings && fieldSettings.width) {
            if (!header.width || fieldSettings.width > header.width) {
               // set column width to the customized width
               header.width = fieldSettings.width;
            }
         }

         if (!header.width) {
            // set column width to adjust:true by default;
            header.adjust = true;
         }

         // add the summary footer
         if (summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula") {
               header.footer = { content: "totalColumn", field: f };
            } else {
               header.footer = { content: "summColumn" };
            }
         }
         // add the count footer
         else if (countColumns.indexOf(f.id) > -1)
            header.footer = { content: "countColumn" };

         headers.push(header);
         // columnNameLookup[header.id] = f.columnName; // name => id
      });

      // update our headers with any settings applied in the Object Workspace
      /*
      // In v2: this is handled by the ABDesigner
      //
      if (isObjectWorkspace) {
         let hiddenFieldList = [];

         if (hiddenFieldNames && hiddenFieldNames.length > 0)
            hiddenFieldList = hiddenFieldNames;
         // else if (this.workspaceHiddenFields)
         //    hiddenFieldList = this.workspaceHiddenFields;

         if (hiddenFieldList.length > 0) {
            hiddenFieldList.forEach((hfID) => {
               headers.forEach((h) => {
                  if (columnNameLookup[h.id] == hfID) {
                     h.hidden = true;
                  }
               });
            });
         }
      }
      */

      return headers;
   }

   // after a component has rendered, tell each of our fields to perform
   // any custom display operations
   // @param {Webix.DataStore} data a webix datastore of all the rows effected
   //        by the render.
   customDisplays(data, App, DataTable, rowIds, isEditable) {
      if (!data || !data.getFirstId) return;

      // var fields = this.fields(f => this.workspaceHiddenFields.indexOf(f.columnName) < 0);
      let fields = [];
      DataTable.eachColumn((columnName) => {
         let field = this.fields((f) => f.columnName == columnName)[0];
         if (field) fields.push(field);
      });

      if (rowIds != null) {
         rowIds.forEach((id) => {
            let row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  let node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
         });
      } else {
         let id = data.getFirstId();
         while (id) {
            var row = data.getItem(id);
            if (row) {
               fields.forEach((f) => {
                  var node = DataTable.getItemNode({
                     row: row.id,
                     column: f.columnName,
                  });
                  f.customDisplay(row, App, node, {
                     editable: isEditable,
                  });
               });
            }
            id = data.getNextId(id);
         }
      }
   }

   // Display data with label format of object
   displayData(rowData) {
      if (rowData == null) return "";

      // translate multilingual
      //// TODO: isn't this a MLObject??  use this.translate()
      var mlFields = this.multilingualFields();
      this.translate(rowData, rowData, mlFields);

      var labelData = this.labelFormat || "";

      // default label
      if (!labelData && this.fields().length > 0) {
         var defaultField = this.fields((f) => f.fieldUseAsLabel())[0];
         if (defaultField) labelData = `{${defaultField.id}}`;
         else
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`; // show id of row
      }

      // get column ids in {colId} template
      // ['{colId1}', ..., '{colIdN}']
      var colIds = labelData.match(/\{[^}]+\}/g);

      if (colIds && colIds.forEach) {
         colIds.forEach((colId) => {
            var colIdNoBracket = colId.replace("{", "").replace("}", "");

            var field = this.fieldByID(colIdNoBracket);
            if (field == null) return;

            labelData = labelData.replace(colId, field.format(rowData) || "");
         });
      }

      // if label is empty, then show .id
      if (!labelData.trim()) {
         let labelSettings = this.labelSettings || {};
         if (labelSettings && labelSettings.isNoLabelDisplay) {
            labelData = L(labelSettings.noLabelText || "[No Label]");
         } else {
            // show id of row
            labelData = `${this.AB.isUUID(rowData.id) ? "ID: " : ""}${
               rowData.id
            }`;
         }
      }

      return labelData;
   }

   currentView() {
      return this.workspaceViews.getCurrentView();
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.fields().forEach((f) => {
         if (!f) return;
         allWarnings = allWarnings.concat(f?.warnings());
      });

      this.indexes().forEach((i) => {
         if (!i) return;
         allWarnings = allWarnings.concat(i?.warnings());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allFields = this.fields();

      if (allFields.length == 0) {
         this.warningsMessage("has no fields");
      }

      (this._unknownFieldIDs || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown field id[${id}]`);
      });

      (this._unknownIndex || []).forEach((id) => {
         this.warningsMessage(`is referencing an unknown index id[${id}]`);
      });

      allFields.forEach((f) => {
         f?.warningsEval();
      });

      this.indexes().forEach((i) => {
         i?.warningsEval();
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Object[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
      // this.emit("warning", warnMsg, data);
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }

   async getDbInfo() {
      return this.AB.Network.get({
         url: `/definition/info/object/${this.id}`,
      });
   }

   /**
    * @method formCleanValues()
    * perform a final review of the data a form will try to submit for
    * this object.  The lets individual fields have a chance to update or
    * remove values before they are sent.
    * @param {obj} rowData
    *        The {data} a form has collected and is about to save.
    * @return {undefined}
    */
   formCleanValues(rowData) {
      this.fields().forEach((f) => {
         f.formCleanData(rowData);
      });
   }
};


/***/ }),

/***/ 34532:
/*!********************************************!*\
  !*** ./AppBuilder/platform/ABObjectApi.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const atomicjs = __webpack_require__(/*! atomicjs */ 9853);
const ABObjectApiCore = __webpack_require__(/*! ../core/ABObjectApiCore */ 84227);

module.exports = class ABObjectApi extends ABObjectApiCore {
   constructor(attributes, AB) {
      super(attributes, AB);
   }

   async fetchData(insertDataMax = 20) {
      if (this.isFetched) return;

      const headers = this.headers;

      const response = await atomicjs(this.request.url, {
         method: this.request.verb,
         headers,
         data: {},
         timeout: null,
         withCredentials: false,
      });

      let parsedResponse = this.dataFromKey(response);

      const model = this.model();

      if (parsedResponse.length == null || parsedResponse.length === 0) {
         const data = {};

         this.response.fields.forEach((f) => {
            data[f.columnName] = parsedResponse[f.columnName];
         });

         await model.create(data);

         return;
      }

      let pendingModelCreate = [];

      for (let i = 0; i < parsedResponse.length; i++) {
         const data = {};

         this.response.fields.forEach((f) => {
            data[f.columnName] = parsedResponse[i][f.columnName];
         });

         pendingModelCreate.push(model.create(data));

         if (pendingModelCreate.length % insertDataMax === 0)
            await Promise.all(pendingModelCreate);
      }

      if (pendingModelCreate.length > 0) await Promise.all(pendingModelCreate);

      this.isFetched = true;

      await this.save();
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save() {
      return await super.save(true);
   }
};


/***/ }),

/***/ 2550:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ABObjectExternal.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObject = __webpack_require__(/*! ./ABObject */ 24869);

/**
 * ABObjectExternal
 * These are ABObjects that ... (might need to be refactored out?)
 * NOTE: on the web client, these should function just like ABObjects
 */
module.exports = class ABObjectExternal extends ABObject {};


/***/ }),

/***/ 38968:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ABObjectImport.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObject = __webpack_require__(/*! ./ABObject */ 24869);

/**
 * ABObjectImport
 * These are ABObjects that were Imported from existing Tables in the
 * system.
 *
 * NOTE: on the web client, these should function just like ABObjects
 */
module.exports = class ABObjectImport extends ABObject {};


/***/ }),

/***/ 76500:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABObjectQuery.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABObjectQuery
//
// A type of Object in our system that is based upon a complex relationship of multiple
// existing Objects.
//
// In the QueryBuilder section of App Builder, a new Query Object can be created.
// An initial Object can be chosen from our current list of Objects. After that, additional Objects
// and a specified join type can be specified.
//
// A list of fields from each specified Object can also be included as the data to be returned.
//
// A where statement is also part of the definition.
//

const ABObjectQueryCore = __webpack_require__(/*! ../core/ABObjectQueryCore */ 2732);

var ABFactory = null;
if (typeof io != "undefined") {
   io.socket.on("ab.query.update", function (msg) {
      if (ABFactory) {
         ABFactory.emit("ab.query.update", {
            queryId: msg.queryId,
            data: msg.data,
         });
      } else {
         console.error(
            "ABObjectQuery:: received io.socket msg before ABFactory is defined"
         );
         console.error("TODO: move this to ABFactory!");
      }
   });
} else {
   console.error("TODO: install socket.io client for sails updates.");
}

// io.socket.on("ab.query.delete", function (msg) {
// });

module.exports = class ABObjectQuery extends ABObjectQueryCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      if (!ABFactory) {
         ABFactory = AB;
      }
      // listen
      this.AB.on("ab.query.update", (data) => {
         if (this.id == data.queryId) this.fromValues(data.data);
      });

      // .fromValues() should already have been called in super()
      // so now add in our conditionScan()
      // NOTE: this can be folded into the Core once filterComplex
      // is fully implemented and not on Platform only.

      // now scan our conditions to make sure they are
      // 1) reference fields that exist in our Query
      // 2) completely filled out conditions.
      this.conditionScan(this.where);
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObjectQuery
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   // destroy() {
   //    return super.destroy().then(() => {
   //       console.error("Move .queryRemove() to Appbuilder Designer.");
   //       // return this.AB.queryRemove(this);
   //    });
   // }

   /**
    * @method save()
    *
    * persist this instance of ABObjectQuery with it's parent ABApplication
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   // async save() {
   //    try {
   //       await super.save();
   //       return this;
   //    } catch (err) {
   //       this.AB.notify.developer(err, {
   //          context: "ABObjectQuery.save()",
   //          query: this.toObj(),
   //       });
   //       throw err;
   //    }
   // }

   ///
   /// Fields
   ///

   /**
    * @method importFields
    * instantiate a set of fields from the given attributes.
    * Our attributes are a set of field URLs That should already be created in their respective
    * ABObjects.
    * @param {array} fieldSettings The different field urls for each field
    *             { }
    * @param {bool} shouldAliasColumn
    *        should we add the object alias to the columnNames?
    *        this is primarily used on the web client
    */
   importFields(fieldSettings) {
      super.importFields(fieldSettings);

      this._fields.forEach((fieldEntry) => {
         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         fieldEntry.field.columnName = `${fieldEntry.alias}.${fieldEntry.field.columnName}`;
      });
   }

   /**
    * @method columnResize()
    *
    * save the new width of a column
    *
    * @param {} id The instance of the field to save.
    * @param {int} newWidth the new width of the field
    * @param {int} oldWidth the old width of the field
    * @return {Promise}
    */
   columnResize(columnName, newWidth, oldWidth) {
      let field = this.fields((f) => f.columnName == columnName)[0];
      if (field) {
         field.settings.width = newWidth;

         return this.save();
      } else {
         return Promise.resolve();
      }
   }

   ///
   /// Working with Client Components:
   ///

   // return the column headers for this object
   // @param {bool} isObjectWorkspace  return the settings saved for the object workspace
   columnHeaders(
      isObjectWorkspace,
      isEditable,
      summaryColumns,
      countColumns,
      hiddenFieldNames
   ) {
      var headers = super.columnHeaders(
         isObjectWorkspace,
         isEditable,
         summaryColumns,
         countColumns,
         hiddenFieldNames
      );

      headers.forEach((h) => {
         // pull object by alias
         let object = this.objectByAlias(h.alias);
         if (!object) return;

         let field = object.fieldByID(h.fieldID);
         if (!field) return;

         // NOTE: query v1
         let alias = "";
         if (Array.isArray(this.joins())) {
            alias = field.object.name;
         } else {
            alias = h.alias;
         }

         // include object name {aliasName}.{columnName}
         // to use it in grid headers & hidden fields
         h.id = `${alias}.${field.columnName}`;

         // label
         if (this.settings && this.settings.hidePrefix) {
            h.header = `${field.label || ""}`;
         } else {
            h.header = `${field.object.label || ""}.${field.label || ""}`;
         }

         // icon
         if (field.settings && field.settings.showIcon) {
            h.header = `<span class="webix_icon fa fa-${field.fieldIcon()}"></span>${
               h.header
            }`;
         }

         // If this query supports grouping, then add folder icon to display in grid
         if (this.isGroup) {
            let originTemplate = h.template;

            h.template = (item, common) => {
               if (item[h.id])
                  return (
                     common.icon(item, common) +
                     (originTemplate
                        ? originTemplate(item, common, item[h.id])
                        : item[h.id])
                  );
               else return "";
            };
         }

         h.adjust = true;
         h.minWidth = 220;
      });

      return headers;
   }

   /**
    * @method conditionScan()
    * Scan the provided condition object and determine if there are any
    * configuration issues.
    * @param {obj} rule
    *        the QueryBuilder rule that we are scanning.
    * @param {array} listWarnings
    *        An array of warnings that we should add our notices to.
    */
   conditionScan(rule) {
      if (!rule) {
         return;
      }

      if (rule.glue) {
         (rule.rules || []).forEach((r) => {
            this.conditionScan(r);
         });
         return;
      }

      // 1) we need to have any key as one of our fields.
      let field = this.fieldByID(rule.key);
      if (!field && rule.key != "this_object") {
         this.warningsMessage(
            "condition does not reference one of our fields",
            {
               rule,
            }
         );
      }

      // 2) completely filled out conditions.
      if (!this._conditionCheck) {
         this._conditionCheck = this.AB.filterComplexNew(
            `${this.id}_conditionCheck`
         );
         // {FilterComplex} ._conditionCheck
         // has our .isConditionComplete() method.
      }
      if (!this._conditionCheck.isConditionComplete(rule)) {
         this.warningsMessage("incomplete condition definition", {
            rule,
         });
      }
   }

   warningsEval() {
      super.warningsEval();

      this.conditionScan(this.where);

      /// include importFields() warnings:
      this.__missingObject.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: could not resolve object[${
               f.objectID
            }] for fieldSetting ${JSON.stringify(f)}`,
            {
               fieldInfo: f,
            }
         );
      });

      this.__missingFields.forEach((f) => {
         this.warningsMessage(
            `IMPORT FIELDS: Object[${f.objID}] could not find field[${
               f.fieldID
            }] for fieldSetting ${JSON.stringify(f.fieldInfo)}`,
            {
               object: f.objID,
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__cantFilter.forEach((f) => {
         this.warningsMessage(
            `Field[${f.field.id}] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] did not pass .canFilterField`,
            {
               field: f.field.toObj(),
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__duplicateFields.forEach((f) => {
         this.warningsMessage(
            `Field[${
               f.fieldInfo.fieldID
            }] referenced in fieldSetting[${JSON.stringify(
               f.fieldInfo
            )}] is a duplicate`,
            {
               fieldInfo: f.fieldInfo,
            }
         );
      });

      this.__linkProblems.forEach((f) => {
         this.warningsMessage(f.message, f.data);
      });
   }

   warningsMessage(msg, data = {}) {
      let message = `Query[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   isUuid(text) {
      console.error(
         "ABObject.isUuid(): is depreciated.  directly reference AB.Rules.isUUID() instead."
      );
      return this.AB.isUUID(text);
   }
};


/***/ }),

/***/ 63509:
/*!******************************************!*\
  !*** ./AppBuilder/platform/ABProcess.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessCore = __webpack_require__(/*! ../core/ABProcessCore */ 42260);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcess extends ABProcessCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      this._unknownShapes = [];
      // {array} [ BPMN:Shape, ... ]
      // Generic Shapes that are added to the Process are registered here.
      // We will list these as warnings to the ABDesigner.

      // listen
      this.AB.on("ab.abprocess.update", (data) => {
         if (this.id == data.objectId) this.fromValues(data.data);
      });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // remove all my Elements
      var allElements = this.elements();
      var allDestroy = [];
      allElements.forEach((e) => {
         allDestroy.push(e.destroy());
      });

      return Promise.all(allDestroy).then(() => {
         // now remove myself
         return new Promise((resolve, reject) => {
            this.toDefinition()
               .destroy()
               .then(() => {
                  // allow normal processing to contine now:
                  resolve();
               })
               .then(() => {
                  // in the background
                  // remove this reference from ALL Applications that link
                  // to me:
                  console.error(
                     "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
                  );
                  var appsWithProcess = this.AB.applications().find((a) => {
                     return a.hasProcess(this);
                  });
                  if (appsWithProcess.length > 0) {
                     appsWithProcess.forEach((a) => {
                        a.processRemove(this);
                     });
                  }
               })
               .catch((err) => {
                  reject(err);
               });
         });
      });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // if this is an update:
      // if (this.id) {
      // 	return ABDefinition.update(this.id, this.toDefinition());
      // } else {

      // 	return ABDefinition.create(this.toDefinition());
      // }

      // make sure all our tasks have save()ed.
      var allSaves = [];
      var allTasks = this.elements();
      allTasks.forEach((t) => {
         allSaves.push(t.save());
      });
      return Promise.all(allSaves).then(() => {
         // now we can save our Process definition
         return this.toDefinition()
            .save()
            .then((data) => {
               // if I didn't have an .id then this was a create()
               // and I need to update my data with the generated .id

               if (!this.id) {
                  this.id = data.id;
               }

               // Also, our embedded elements now all have .ids
               // where they might not have before.  So now
               // rebuild our this._elements hash with all id
               var _new = {};
               let _old = this._elements;
               Object.keys(this._elements).forEach((k) => {
                  _new[this._elements[k].id] = this._elements[k];
               });
               this._elements = _new;

               // check to see if an update happened and then make
               // sure we have that saved.
               let needSave = false;
               Object.keys(_new).forEach((k) => {
                  if (!_old[k]) {
                     needSave = true;
                  }
               });

               if (needSave) {
                  return this.save();
               }
            });
      });
   }

   isValid() {
      var validator = this.AB.Validation.validator();

      // label/name must be unique:
      var isNameUnique =
         this.AB.processes((o) => {
            return o.name.toLowerCase() == this.name.toLowerCase();
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "name",
            L(`Process name must be unique ("{0}" already in use)`, [this.name])
         );
      }

      return validator;
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcess[OBJ]}
    */
   elementNewForModelDefinition(element) {
      var task = this.AB.processElementNewForModelDefinition(element, this);
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   /**
    * @method unknownShape()
    * store a reference to a BPMN Shape that is in our XML diagram,
    * but we don't have an element for.
    * @param {BPMN:Shape} shape
    */
   unknownShape(shape) {
      this.unknownShapeRemove(shape);
      this._unknownShapes.push(shape);
   }

   /**
    * @method unknownShapeRemove()
    * make sure we no longer track the provided BPMN Shape as an unknown shape.
    * @param {BPMN:Shape} shape
    */
   unknownShapeRemove(shape) {
      this._unknownShapes = this._unknownShapes.filter((s) => s.id != shape.id);
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = [].concat(this._warnings);
      this.elements().forEach((e) => {
         e.warningsEval();
         allWarnings = allWarnings.concat(e.warnings());
      });

      if (this.elements().length == 0) {
         allWarnings.push({ message: "No process Tasks defined.", data: {} });
      }

      // perform a check of our xml document to see if we have any unknown
      // shapes
      if (!this._DOMParser) {
         if (window.DOMParser) {
            // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
            this._DOMParser = function (xmlStr) {
               return new window.DOMParser().parseFromString(
                  xmlStr,
                  "text/xml"
               );
            };
         } else if (
            typeof window.ActiveXObject != "undefined" &&
            new window.ActiveXObject("Microsoft.XMLDOM")
         ) {
            this._DOMParser = function (xmlStr) {
               var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
               xmlDoc.async = "false";
               xmlDoc.loadXML(xmlStr);
               return xmlDoc;
            };
         } else {
            throw new Error("No XML parser found");
         }
      }

      // find any references to our generic shapes
      let xml = this._DOMParser(this.xmlDefinition);
      const genericShapes = [
         "bpmn2:startEvent",
         "bpmn2:task",
         "bpmn2:endEvent",
      ];
      genericShapes.forEach((s) => {
         let allElements = xml.getElementsByTagName(s);
         for (let x = 0; x < allElements.length; x++) {
            // if we don't know about this shape
            let ele = allElements[x];
            let myEle = this.elementForDiagramID(allElements[x].id);
            if (!myEle) {
               this.unknownShape(allElements[x]);
            }
         }
      });

      // if any unknown shapes have been reported:
      if (this._unknownShapes.length) {
         allWarnings.push({
            message: "Generic Tasks still undefined.",
            data: {},
         });
      }

      return allWarnings;
   }
};


/***/ }),

/***/ 21002:
/*!***************************************!*\
  !*** ./AppBuilder/platform/ABStep.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABStepCore = __webpack_require__(/*! ../core/ABStepCore */ 73323);

// let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABStep extends ABStepCore {
   constructor(attributes, AB) {
      super(attributes, AB);

      // listen
      // this.AB.on("ab.abprocess.update", (data) => {
      //    if (this.id == data.objectId) this.fromValues(data.data);
      // });
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABObject
    *
    * also remove it from our parent application
    *
    * @return {Promise}
    */
   destroy() {
      // debugger;

      return new Promise((resolve, reject) => {
         this.toDefinition()
            .destroy()
            .then(() => {
               resolve();
            })
            .catch((err) => {
               reject(err);
            });
      });

      // remove all my Elements
      // var allElements = this.elements();
      // var allDestroy = [];
      // allElements.forEach((e) => {
      //    allDestroy.push(e.destroy());
      // });

      // return Promise.all(allDestroy).then(() => {
      //    // now remove myself
      //    return new Promise((resolve, reject) => {
      //       this.toDefinition()
      //          .destroy()
      //          .then(() => {
      //             // allow normal processing to contine now:
      //             resolve();
      //          })
      //          .then(() => {
      //             // in the background
      //             // remove this reference from ALL Applications that link
      //             // to me:
      //             console.error(
      //                "TODO: ABProcess.destroy(): refactor to .emit('destroyed') and let containing Apps self remove."
      //             );
      //             var appsWithProcess = this.AB.applications().find((a) => {
      //                return a.hasProcess(this);
      //             });
      //             if (appsWithProcess.length > 0) {
      //                appsWithProcess.forEach((a) => {
      //                   a.processRemove(this);
      //                });
      //             }
      //          })
      //          .catch((err) => {
      //             reject(err);
      //          });
      //    });
      // });
   }

   /**
    * @method save()
    *
    * persist this instance of ABObject with it's parent ABApplication
    *
    *
    * @return {Promise}
    *                .resolve( {this} )
    */
   save() {
      // debugger;
      return this.toDefinition()
         .save()
         .then((data) => {
            // if I didn't have an .id then this was a create()
            // and I need to update my data with the generated .id

            if (!this.id) {
               this.id = data.id;
            }
            return this;
         });
   }

   isValid() {
      // debugger;
      return true;
      // var validator = this.AB.Validation.validator();

      // // label/name must be unique:
      // var isNameUnique =
      //    this.AB.processes((o) => {
      //       return o.name.toLowerCase() == this.name.toLowerCase();
      //    }).length == 0;
      // if (!isNameUnique) {
      //    validator.addError(
      //       "name",
      //       L(`Process name must be unique ("{0}" already in use)`, [this.name])
      //    );
      // }

      // return validator;
   }

   /**
    * @method warningsAll()
    * Return an array of mis configuration warnings for our object or any
    * of our sub elements.
    * @return {array} [ { message: "warning message", data:{} } ]
    */
   warningsAll() {
      // debugger;
      // report both OUR warnings, and any warnings from any of our fields
      // var allWarnings = [].concat(this._warnings);
      // this.elements().forEach((e) => {
      //    e.warningsEval();
      //    allWarnings = allWarnings.concat(e.warnings());
      // });
      // if (this.elements().length == 0) {
      //    allWarnings.push({ message: "No process Tasks defined.", data: {} });
      // }
      // // perform a check of our xml document to see if we have any unknown
      // // shapes
      // if (!this._DOMParser) {
      //    if (window.DOMParser) {
      //       // Handy snippet from https://stackoverflow.com/questions/17604071/parse-xml-using-javascript
      //       this._DOMParser = function (xmlStr) {
      //          return new window.DOMParser().parseFromString(
      //             xmlStr,
      //             "text/xml"
      //          );
      //       };
      //    } else if (
      //       typeof window.ActiveXObject != "undefined" &&
      //       new window.ActiveXObject("Microsoft.XMLDOM")
      //    ) {
      //       this._DOMParser = function (xmlStr) {
      //          var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      //          xmlDoc.async = "false";
      //          xmlDoc.loadXML(xmlStr);
      //          return xmlDoc;
      //       };
      //    } else {
      //       throw new Error("No XML parser found");
      //    }
      // }
      // // find any references to our generic shapes
      // let xml = this._DOMParser(this.xmlDefinition);
      // const genericShapes = [
      //    "bpmn2:startEvent",
      //    "bpmn2:task",
      //    "bpmn2:endEvent",
      // ];
      // genericShapes.forEach((s) => {
      //    let allElements = xml.getElementsByTagName(s);
      //    for (let x = 0; x < allElements.length; x++) {
      //       // if we don't know about this shape
      //       let ele = allElements[x];
      //       let myEle = this.elementForDiagramID(allElements[x].id);
      //       if (!myEle) {
      //          this.unknownShape(allElements[x]);
      //       }
      //    }
      // });
      // // if any unknown shapes have been reported:
      // if (this._unknownShapes.length) {
      //    allWarnings.push({
      //       message: "Generic Tasks still undefined.",
      //       data: {},
      //    });
      // }
      //
      // return allWarnings;
   }
};


/***/ }),

/***/ 96649:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/ABViewManager.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewManagerCore = __webpack_require__(/*! ../core/ABViewManagerCore */ 60979);

module.exports = class ABViewManager extends ABViewManagerCore {};


/***/ }),

/***/ 69155:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/ABViewManagerMobile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewManagerMobileCore = __webpack_require__(/*! ../core/ABViewManagerMobileCore */ 42428);

module.exports = class ABViewManagerMobile extends ABViewManagerMobileCore {};


/***/ }),

/***/ 88708:
/*!********************************************!*\
  !*** ./AppBuilder/platform/CSVImporter.js ***!
  \********************************************/
/***/ ((module) => {

var L = null;
// multilingual Label fn()

module.exports = class CSVImporter {
   constructor(Label) {
      // {ABMultilingual.label()} function.
      //
      if (!L) {
         L = Label;

         // if this was a v1: App param:
         if (Label.Label) {
            L = Label.Label;
         }
      }
   }

   /**
    * @method getSeparateItems()
    * Return the options of how the CSV values are separated.
    * @return {array}  [ {id, value} ... ]
    */
   getSeparateItems() {
      return [
         { id: ",", value: L("Comma (,)") },
         { id: "\t", value: L("Tab (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)") },
         { id: ";", value: L("Semicolon (;)") },
         { id: "s", value: L("Space ( )") },
      ];
   }

   /**
    * @method validateFile
    * Validate file extension
    * @param {*} fileInfo
    *        https://docs.webix.com/api__ui.uploader_onbeforefileadd_event.html
    * @return {boolean}
    */
   validateFile(fileInfo) {
      if (!fileInfo || !fileInfo.file || !fileInfo.file.type) return false;

      // validate file type
      let extensionType = fileInfo.file.type.toLowerCase();
      if (
         extensionType == "text/csv" ||
         extensionType == "application/vnd.ms-excel"
      ) {
         return true;
      } else {
         return false;
      }
   }

   /**
    * @method getDataRows
    * Pull data rows from the CSV file
    *
    * @param {Object} fileInfo - https://docs.webix.com/api__ui.uploader_onbeforefileadd_event.html
    * @param {string} separatedBy
    *
    * @return {Promise} -[
    * 						["Value 1.1", "Value 1.2", "Value 1.3"],
    * 						["Value 2.1", "Value 2.2", "Value 2.3"],
    * 					]
    */
   getDataRows(fileInfo, separatedBy) {
      if (!this.validateFile(fileInfo)) return Promise.reject();

      return new Promise((resolve, reject) => {
         // read CSV file
         let reader = new window.FileReader();
         reader.onload = (e) => {
            let result = [];

            // split lines
            let dataRows = reader.result
               .split(/\r\n|\n|\r/) // CRLF = \r\n; LF = \n; CR = \r;
               .filter((row) => row && row.length > 0);

            // split columns
            (dataRows || []).forEach((row) => {
               let dataCols = [];
               if (separatedBy == ",") {
                  // NOTE: if the file contains ,, .match() can not reconize this empty string
                  row = row.replace(/,,/g, ", ,");

                  // https://stackoverflow.com/questions/11456850/split-a-string-by-commas-but-ignore-commas-within-double-quotes-using-javascript#answer-11457952
                  dataCols = row.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);
               } else {
                  dataCols = row.split(separatedBy);
               }

               result.push(dataCols.map((dCol) => this.reformat(dCol)));
            });

            resolve(result);
         };
         reader.readAsText(fileInfo.file);
      });
   }

   /**
    * @method getGuessDataType
    * return our best guess of what type of data for the requested column.
    * @param {array} dataRows
    *        The data we are evaluating:
    *        [
    *           ["Value 1.1", "Value 1.2", "Value 1.3"],
    *           ["Value 2.1", "Value 2.2", "Value 2.3"],
    * 		 ]
    * @param colIndex {Number}
    * @return {string}
    */
   getGuessDataType(dataRows, colIndex) {
      var data,
         // {various} the data pulled from the requested row/column
         repeatNum = 10;
      // {integer} how many rows do we want to scan trying to find a value

      // Loop to find a value
      for (var i = 1; i <= repeatNum; i++) {
         var line = dataRows[i];
         if (!line) break;

         data = line[colIndex];

         if (data != null && data.length > 0) break;
      }

      if (data == null || data == "") {
         return "string";
      } else if (
         data == 0 ||
         data == 1 ||
         data == true ||
         data == false ||
         data == "checked" ||
         data == "unchecked"
      ) {
         return "boolean";
      } else if (!isNaN(data)) {
         return "number";
      } else if (Date.parse(data)) {
         return "date";
      } else {
         // determine which type of string this might be:
         if (data.length > 100) return "LongText";
         else return "string";
      }
   }

   /**
    * @method reformat
    * @param {string} str
    */
   reformat(str) {
      if (!str) return "";

      return str.trim().replace(/"/g, "").replace(/'/g, "");
   }
};


/***/ }),

/***/ 67483:
/*!**********************************************!*\
  !*** ./AppBuilder/platform/FilterComplex.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const FilterComplexCore = __webpack_require__(/*! ../core/FilterComplexCore */ 78260);

let L = (...params) => AB.Multilingual.label(...params);

/**
 * @function _toInternal()
 * translate our external QB conditions into our internal format that
 * makes the cond.rule unique by adding the field.id to the rule.
 * @param {obj} cond - {
 *                         rules: [
 *                            {
 *                               alias: string || undefined,
 *                               key: uuid,
 *                               rule: string,
 *                               value: object,
 *                            }
 *                         ]
 *                      }
 *        the QB condition format we use exernally in our AB system.
 */
function _toInternal(cond, fields = []) {
   if (!cond) return;
   if (cond.key) {
      // Convert to format
      // {
      //    glue: "and",
      //    rules: [
      //       {
      //          field: "test_col",
      //          condition: { type: "greater", filter: 100 },
      //       },
      //    ],
      // }
      const field = fields.filter((f) => f.id == cond.key)[0];
      cond.field = field?.id;

      cond.condition = {
         type: cond.rule,
         filter: cond.value,
      };

      if (Array.isArray(cond.value)) cond.includes = cond.value;
      else cond.includes = cond.value?.split?.(",") ?? [];

      if (field?.key == "date" || field?.key == "datetime") {
         cond.condition.filter = cond.condition.filter
            ? AB.rules.toDate(cond.condition.filter)
            : null;

         cond.includes = cond.includes.map((v) => AB.rules.toDate(v));
      }

      delete cond.key;
      delete cond.rule;
      delete cond.value;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toInternal(r, fields);
      });
   }
}

/**
 * @function _toExternal()
 * translate our internal QB conditions into our external format that
 * where the cond.rule no longer has the field.id.
 * @param {obj} cond - {
 *                         glue: "and",
 *                         rules: [
 *                            {
 *                               field: "test_col",
 *                               condition: { type: "greater", filter: 100 },
 *                            },
 *                         ],
 *                      }
 *        the QB condition format we use internally
 */
function _toExternal(cond, fields = []) {
   if (!cond) return;
   if (cond.field) {
      let field = fields.filter((f) => f.id == cond.field)[0];
      // cond.alias = alias || undefined;
      cond.key = field?.id ?? cond.field;
      cond.condition = cond.condition ?? {};
      cond.rule = cond.condition.type;

      let values =
         cond.includes.map((v) => (v instanceof Date ? v.toISOString() : v)) ??
         [];

      // Convert multi-values to a string
      if (cond.condition.filter) {
         if (cond.condition.filter instanceof Date) {
            if (values.indexOf(cond.condition.filter.toISOString()) < 0) {
               values.push(cond.condition.filter);
            }
         } else if (values.indexOf(cond.condition.filter) < 0)
            values.push(cond.condition.filter);
      }

      if (cond.rule === "is_current_date") {
         let now = new Date();
         let year = now.getFullYear();
         let month = now.getMonth();
         let date = now.getDate();

         let startOfDay = new Date(year, month, date, 0, 0, 0);
         let endOfDay = new Date(year, month, date, 23, 59, 59);

         // Convert to UTC by subtracting the timezone offset
         let startOfDayUTC = new Date(
            startOfDay.getTime() + startOfDay.getTimezoneOffset() * 60000
         );
         let endOfDayUTC = new Date(
            endOfDay.getTime() + endOfDay.getTimezoneOffset() * 60000
         );
         let formatDate = (date) => {
            let isoString = date.toISOString();
            return `${isoString.slice(0, 10)} ${isoString.slice(11, 19)}`;
         };
         cond.value = formatDate(startOfDayUTC).concat(
            "|",
            formatDate(endOfDayUTC)
         );
      } else {
         cond.value = values
            .map((v) => {
               // Convert date format
               if (field && (field.key === "date" || field.key === "datetime"))
                  return field.exportValue(new Date(v));
               return v;
            })
            .join(",");
      }

      delete cond.field;
      delete cond.type;
      delete cond.includes;
      delete cond.condition;
   }

   if (cond.rules && cond.rules.length) {
      (cond.rules ?? []).forEach((r) => {
         _toExternal(r, fields);
      });
   }
}

module.exports = class FilterComplex extends FilterComplexCore {
   constructor(idBase, AB, options = {}) {
      idBase = idBase ?? "ab_filterComplex";

      super(idBase, AB);

      this._options = options ?? {};

      this._initComplete = false;
      // {bool}
      // trying to prevent multiple .init() from being called due to
      // various ways of initializing the component.

      this.observing = false;
      // {bool}
      // try to prevent multiple observers generating >1 "changed"
      // event.

      let labels = (this.labels = {
         common: (AB._App ?? {}).labels,
         component: {
            and: L("And"),
            or: L("Or"),

            thisObject: L("This Object"),
            inQuery: L("In Query"),
            notInQuery: L("Not In Query"),
            inQueryField: L("By Query Field"),
            notInQueryField: L("Not By Query Field"),

            inQueryFieldQueryPlaceholder: L("Choose a Query"),
            inQueryFieldFieldPlaceholder: L("Choose a Field"),

            sameAsUser: L("Same As User"),
            notSameAsUser: L("Not Same As User"),

            sameAsField: L("Same As Field"),
            notSameAsField: L("Not Field"),

            inDataCollection: L("In Data Collection"),
            notInDataCollection: L("Not In Data Collection"),

            containsCondition: L("contains"),
            notContainsCondition: L("doesn't contain"),
            isCondition: L("is"),
            isNotCondition: L("is not"),
            isEmpty: L("is empty"),
            isNotEmpty: L("is not empty"),
            isCurrentDateCondition: L("is current date"),
            beforeCondition: L("is before"),
            afterCondition: L("is after"),
            onOrBeforeCondition: L("is on or before"),
            onOrAfterCondition: L("is on or after"),
            beforeCurrentCondition: L("is before current date"),
            afterCurrentCondition: L("is after current date"),
            onOrBeforeCurrentCondition: L("is on or before current date"),
            onOrAfterCurrentCondition: L("is on or after current date"),
            onLastDaysCondition: L("last ... days"),
            onNextDaysCondition: L("next ... days"),

            equalCondition: L(":"),
            notEqualCondition: L("≠"),
            lessThanCondition: L("<"),
            moreThanCondition: L(">"),
            lessThanOrEqualCondition: L("≤"),
            moreThanOrEqualCondition: L("≥"),

            equalListCondition: L("equals"),
            notEqualListCondition: L("does not equal"),

            checkedCondition: L("is checked"),
            notCheckedCondition: L("is unchecked"),

            isCurrentUserCondition: L("is current user"),
            isNotCurrentUserCondition: L("is not current user"),
            containsCurrentUserCondition: L("contains current user"),
            notContainsCurrentUserCondition: L("does not contain current user"),

            contextDefaultOption: L("choose option"),
            equalsProcessValue: L("equals process value"),
            notEqualsProcessValueCondition: L("not equals process value"),
            inProcessValueCondition: L("in process value"),
            notInProcessValueCondition: L("not in process value"),
         },
      });

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         popup: this.unique(`${idBase}_popup`),
         querybuilder: this.unique(`${idBase}_querybuilder`),
         save: this.unique(`${idBase}_save`),
      });

      // Set current username
      this.Account.username = this.AB.Account.username();

      this._settings.recordRuleFieldOptions = [];

      // webix UI definition:
      this.ui = {
         rows: [
            {
               view: "layout",
               type: "clean",
               borderless: this._options.borderless ?? true,
               rows: [
                  {
                     id: ids.querybuilder,
                     view: "query",
                     data: () => [],
                     // data: async (field) => await this.pullOptions(field),
                     fields: [],
                     disabled: true,
                     height: this._options.height,
                  },
               ],
            },
            {
               id: ids.save,
               view: "button",
               css: "webix_primary",
               value: L("Save"),
               hidden: this._options.isSaveHidden ?? false,
               click: () => {
                  if (this.myPopup) this.myPopup.hide();
                  this.emit("save", this.getValue());
               },
            },
         ],
      };
   }

   // setting up UI
   init(options) {
      if (this._initComplete) return;

      super.init(options);

      const el = $$(this.ids.querybuilder);

      if (el) {
         if (!this.observing) {
            this.__blockOnChange = true;
            el.getState().$observe("value", (v) => {
               if (this.__blockOnChange) return false;

               this.emit("changed", this.getValue());
            });
            this.__blockOnChange = false;

            // HACK!! The process of setting the $observe() is actually
            // calling the cb() when set.  This is clearing our .condition
            // if we call init() after we have setValues(). which can happen
            // when using the popUp() method.
            let _cond = this.condition;
            this.condition = _cond;
            this.observing = true;
         }
         this._initComplete = true;
      }
   }

   /**
    * @method isValid
    * validate the row data is valid filter condition
    *
    * @param rowData {Object} - data row
    * @param condition {Object} - [Optional] {
    *                                           glue: "and" | "or",
    *                                           rules: []
    *                                        }
    */
   isValid(rowData, condition = this.condition) {
      let helper = () => true;

      let $query = $$(this.ids.querybuilder);
      if ($query) {
         helper = $query.getFilterFunction();
         return helper(rowData);
      } else {
         return super.isValid(rowData, condition);
      }
   }

   /**
    * @method isConditionComplete()
    * Check a given condition entry and indicate if it is fully
    * filled out.
    * @param {obj} cond
    *        The Condition object we are checking.  If a Macro
    *        condition if provided: { glue:"and", rules:[] } then
    *        this method will return True/False if All rules are
    *        complete.
    *        If an individual rule is provided, then it evaluates
    *        the completness of that rule. { key, rule, value }
    * @return {bool}
    */
   isConditionComplete(cond) {
      if (!cond) return false;

      let isComplete = true;
      // start optimistically.

      if (cond?.glue) {
         (cond.rules ?? []).forEach((r) => {
            isComplete = isComplete && this.isConditionComplete(r);
         });
      } else {
         // every condition needs a .key & .rule
         if (!cond.key || cond.key == "") {
            isComplete = false;
         }

         if (!cond.rule || cond.rule == "") {
            isComplete = false;
         }

         if (isComplete) {
            switch (cond.rule) {
               case "is_current_user":
               case "is_not_current_user":
               case "contain_current_user":
               case "not_contain_current_user":
               case "same_as_user":
               case "not_same_as_user":
               case "less_current":
               case "greater_current":
               case "less_or_equal_current":
               case "greater_or_equal_current":
               case "is_empty":
               case "is_not_empty":
               case "checked":
               case "unchecked":
               case "is_current_date":
                  // There are only a few rules that don't need a
                  // value
                  break;

               default:
                  // The rest do need a .value
                  if (!cond.value || cond.value == "") {
                     isComplete = false;
                  }
                  break;
            }
         }
      }

      return isComplete;
   }

   setValue(settings) {
      super.setValue(settings);
      this.condition = settings;

      const el = $$(this.ids.querybuilder);
      if (el) {
         if (!settings) {
            // Clear settings value of webix.query
            el.define("value", {
               glue: "and",
               rules: [],
            });
            return;
         }

         let qbSettings = this.AB.cloneDeep(settings);

         // Settings should match a condition built upon our QB format:
         // {
         //    glue:"and",
         //    rules:[
         //       {
         //          key:"uuid",
         //          rule:"",
         //          value:""
         //       }
         //    ]
         // }
         // externally our key should be the field.id and the rules should be
         // the "contains", "not_contains", "equal" ... keywords.
         // However, internally, we convert these rules into .ids that are
         // unique for each field (see uiInit()).  So when we bring in settings
         // we need to translate them into our internal format:

         _toInternal(qbSettings, this._Fields);

         this.__blockOnChange = true;
         el.define("value", qbSettings);
         this.__blockOnChange = false;
      }
   }

   getValue() {
      if ($$(this.ids.querybuilder)) {
         let settings = this.AB.cloneDeep(
            $$(this.ids.querybuilder).getState().value ?? {}
         );

         // what we pull out of the QB will have .rules in our internal format:
         // {field.id}_{rule}  (see uiInit() )
         // But we need to store them in our generic QB format for use outside
         // our FilterComplex widget.
         _toExternal(settings, this._Fields);
         this.condition = settings;
      }

      return super.getValue();
   }

   fieldsLoad(fields = [], object = null) {
      super.fieldsLoad(fields, object);
      this.uiInit();
   }

   toShortHand() {
      return "Add Filters";
   }

   uiInit() {
      this.uiQueryCustomValue();

      let el = $$(this.ids.querybuilder);
      if (el) {
         // Clear fields
         while (el.config.fields.length > 0) {
            el.config.fields.pop();
         }
         // Set fields
         (this.fieldsToQB() ?? []).forEach((f) => {
            el.config.fields.push(f);
         });
         if (el.config.fields.length) {
            el.enable();
         } else {
            this.setValue("");
            el.disable();
         }
      }
   }

   // HACK: have to overwrite Webix Query's function to support our custom input requirement.
   // HooWoo
   uiQueryCustomValue() {
      const $el = $$(this.ids.querybuilder);
      if (!$el) return;

      // window.query.views.filter.prototype.CreateFilter = (
      $el.$app.require("jet-views", "filter").prototype.CreateFilter = (
         field,
         type,
         format,
         conditions,
         place
      ) => {
         let inputs = this.uiValue(field);

         let ui = {
            id: place.config.id,
            view: "filter",
            localId: "filter",
            conditions: conditions,
            field: field,
            mode: type,
            template: function (o) {
               let str = o[field];
               let parser =
                  format ?? (type == "date" ? webix.i18n.dateFormatStr : null);
               if (parser) str = parser(str);
               return str;
            },
            inputs: inputs,
            margin: 6,
         };

         let filter = webix.ui(ui, place);

         // let data = [];
         // const $query = $$(this.ids.querybuilder);
         // if ($query) {
         //    data = $query.app.getService("backend").data(field);
         // }
         // filter.parse(data);

         return filter;
      };
   }

   uiValue(fieldColumnName) {
      let result;

      // Special case: this_object
      if (fieldColumnName == "this_object") {
         return []
            .concat(this.uiQueryValue("this_object"))
            .concat(this.uiDataCollectionValue("this_object"))
            .concat(this.uiCustomValue("this_object"))
            .concat(this.uiContextValue("this_object", "uuid"));
      }

      let field = (this._Fields ?? []).filter(
         (f) => f.id == fieldColumnName
      )[0];

      switch (field?.key) {
         case "boolean":
            result = this.uiNoneValue(field);
            break;
         case "connectObject":
            result = []
               .concat(this.uiQueryValue(field))
               .concat(this.uiUserValue(field))
               .concat(this.uiDataCollectionValue(field))
               .concat(this.uiContextValue(field))
               .concat(this.uiNoneValue());
            break;
         case "date":
         case "datetime":
            result = ["datepicker", "daterangepicker"]
               .concat(this.uiNoneValue())
               .concat(this.uiContextValue(field));
            break;
         case "list":
            result = this.uiListValue(field);
            break;
         case "user":
            result = []
               .concat(this.uiNoneValue())
               .concat(this.uiUserValue(field));
            break;
         // case "number":
         //    result = ["text"];
         //    break;
         case "string":
         case "LongText":
         case "email":
            result = this.uiNoneValue();
            break;
      }

      // Add filter options to Custom index
      const LinkType = `${field?.settings?.linkType}:${field?.settings?.linkViaType}`;
      if (
         field?.settings?.isCustomFK &&
         // 1:M
         (LinkType == "one:many" ||
            // 1:1 isSource = true
            (LinkType == "one:one" && field?.settings?.isSource))
      ) {
         result = (result ?? []).concat(this.uiTextValue(field));
      } else if (field?.key != "connectObject") {
         result = (result ?? [])
            .concat(this.uiTextValue(field))
            .concat(this.uiQueryFieldValue(field))
            .concat(this.uiContextValue(field));
      }
      // Special case: from Process builder
      // .processFieldsLoad()
      else if (fieldColumnName.indexOf("uuid") > -1) {
         result = this.uiContextValue(null, fieldColumnName);
      }

      if (this._settings.isRecordRule) {
         result = (result ?? []).concat(this.uiRecordRuleValue(field));
      }

      result = (result ?? []).concat(this.uiCustomValue(field));

      return result;
   }

   uiNoneValue() {
      return [
         {
            batch: "none",
            borderless: true,
            view: "template",
            template: "",
         },
      ];
   }

   uiBooleanValue(field) {
      return [
         {
            batch: "boolean",
            view: "checkbox",
         },
      ];
   }

   uiTextValue(field) {
      return [
         {
            batch: "text",
            view: "text",
            on: {
               onAfterRender: function () {
                  // HACK: focus on webix.text and webix.textarea
                  // Why!! If the parent layout has zIndex lower than 101,
                  // then is not able to focus to webix.text and webix.textarea
                  let $layout =
                     this.queryView(function (a) {
                        return !a.getParentView();
                     }, "parent") ?? this;
                  $layout.$view.style.zIndex = 202;
               },
            },
         },
      ];
   }

   uiQueryValue(field) {
      let options = [];

      let isQueryField =
         this._QueryFields?.filter((f) => f.id == field.id).length > 0;

      // populate the list of Queries for this_object:
      if (field == "this_object" && this._Object) {
         options = this.queries((q) => q.canFilterObject(this._Object));
      }
      // populate the list of Queries for a query field
      else if (isQueryField) {
         options = this.queries(
            (q) =>
               (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
               q.canFilterObject(field.datasourceLink)
         );
      }

      options?.forEach((q) => {
         options.push({
            id: q.id,
            value: q.label,
         });
      });

      return [
         {
            batch: "query",
            view: "combo",
            options: options ?? [],
         },
      ];
   }

   uiListValue(field) {
      return [
         {
            batch: "list",
            view: "combo",
            options: field?.settings?.options?.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            }),
         },
      ];
   }

   uiUserValue(field) {
      return [
         {
            batch: "user",
            view: "combo",
            options: this.AB.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            }),
         },
      ];
   }

   uiDataCollectionValue(field) {
      let linkObjectId;
      if (field == "this_object" && this._Object) {
         linkObjectId = this._Object.id;
      } else {
         linkObjectId = field?.settings?.linkObject;
      }

      return [
         {
            batch: "datacollection",
            view: "combo",
            options: linkObjectId
               ? this.AB.datacollections(
                    (dc) => dc?.datasource?.id == linkObjectId
                 ).map((dc) => {
                    return {
                       id: dc.id,
                       value: dc.label,
                    };
                 })
               : [],
         },
      ];
   }

   uiQueryFieldValue(field) {
      return [
         {
            batch: "queryField",
            view: "combo",
            placeholder: this.labels.component.inQueryFieldQueryPlaceholder,
            options: this.queries(
               (q) => this._Object == null || q.id != this._Object.id
            ).map((q) => {
               return {
                  id: q.id,
                  value: q.label,
               };
            }),
         },
      ];
   }

   uiRecordRuleValue(field) {
      return [
         {
            batch: "recordRule",
            view: "select",
            options: this._settings.recordRuleFieldOptions ?? [],
         },
      ];
   }

   uiContextValue(field, processFieldKey = null) {
      const processFields = (this._ProcessFields ?? [])
         .filter((pField) => {
            if (!pField) return false;

            let result = false;
            switch (field) {
               case "this_object":
                  result =
                     this._Object.id === pField.object?.id && !pField.field;

                  break;

               default:
                  switch (field.key) {
                     case "boolean":
                        result = ["boolean"].includes(pField.field?.key);

                        break;

                     case "connectObject":
                        result =
                           field.settings.linkObject ===
                           (pField.field?.object.id ?? pField.object.id);

                        if (!field.settings.isCustomFK) {
                           result = result && !pField.field;

                           break;
                        }

                        result =
                           result &&
                           (field.settings.indexField ||
                              field.settings.indexField2) === pField.field?.id;

                        break;

                     case "date":
                     case "datetime":
                        result = ["date", "datetime"].includes(
                           pField.field?.key
                        );

                        break;

                     case "calculate":
                     case "formula":
                     case "number":
                        result = ["calculate", "formula", "number"].includes(
                           pField.field?.key
                        );

                        break;

                     case "string":
                     case "LongText":
                     case "email":
                     case "AutoIndex":
                     case "list":
                        result = [
                           "string",
                           "LongText",
                           "email",
                           "AutoIndex",
                           "list",
                        ].includes(pField.field?.key);

                        break;

                     case "user":
                        result = ["user"].includes(pField.field?.key);

                        break;

                     default:
                        if (pField.key) {
                           // uuid
                           const processFieldId = pField.key.split(".").pop();

                           result =
                              processFieldId === field.id ||
                              processFieldId === field.key ||
                              processFieldId === processFieldKey ||
                              pField.key === processFieldKey;
                        }

                        break;
                  }

                  break;
            }

            return result;
         })
         .map((e) => {
            return {
               id: e.key,
               value: L("context({0})", [e.label]),
            };
         });

      if (!processFields) return [];

      return [
         {
            batch: "context",
            view: "select",
            options: [
               {
                  id: "empty",
                  value: this.labels.component.contextDefaultOption,
               },
               ...processFields,
            ],
         },
      ];
   }

   uiCustomValue(field) {
      if (!field) return [];

      const customOptions = this._customOptions ?? {};
      const options = customOptions[field.id ?? field] ?? {};
      return options.values ?? [];
   }

   popUp(...options) {
      const condition = Object.assign({}, this.condition);

      if (!this.myPopup) {
         let ui = {
            id: this.ids.popup,
            view: "popup",
            height: 400,
            width: 800,
            body: this.ui,
         };

         if (!$$(this.ids.popup)) {
            this.myPopup = webix.ui(ui);
            this.init(this._settings);
            if (this._Fields) {
               this.fieldsLoad(this._Fields, this._Object);
            }

            // NOTE: do this, before the .setValue() operation, as we need to have
            // our fields and filters defined BEFORE a setValue() is performed.
            // this.uiInit();

            if (condition) {
               this.setValue(condition);
            }

            this.myPopup.show(...options);
         } else {
            $$(this.ids.popup).show(...options);
         }
      } else {
         this.myPopup.show(...options);
      }
   }

   /**
    * @method addCustomOption
    *
    * @param {string|uuid} fieldId
    * @param {Object} options - {
    *                               conditions: [],
    *                               values: []
    *                           }
    */
   addCustomOption(fieldId, options = {}) {
      this._customOptions = this._customOptions ?? {};
      this._customOptions[fieldId] = options;
   }
};


/***/ }),

/***/ 12416:
/*!******************************************!*\
  !*** ./AppBuilder/platform/RowFilter.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RowFilterCore = __webpack_require__(/*! ../core/RowFilterCore */ 87674);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class RowFilter extends RowFilterCore {
   constructor(App, idBase, AB) {
      super(App, idBase, AB);

      console.error("TODO: Switch RowFilter => FilterComplex");

      // internal list of Webix IDs to reference our UI components.
      let ids = (this.ids = {
         component: this.unique(`${idBase}_rowFilter`),
         filterForm: this.unique(`${idBase}_rowFilter_form`),
         addNewFilter: this.unique(`${idBase}_rowFilter_addNewFilter`),

         glue: this.unique(`${idBase}_rowFilter_glue`),
         field: this.unique(`${idBase}_rowFilter_field`),
         rule: this.unique(`${idBase}_rowFilter_rule`),
         inputValue: this.unique(`${idBase}_rowFilter_inputValue`),

         queryCombo: this.unique(`${idBase}_rowFilter_queryCombo`),
         queryFieldCombo: this.unique(`${idBase}_rowFilter_queryFieldCombo`),
         queryFieldComboQuery: this.unique(
            `${idBase}_rowFilter_queryFieldComboQuery`
         ),
         queryFieldComboField: this.unique(
            `${idBase}_rowFilter_queryFieldComboField`
         ),
         fieldMatch: this.unique(`${idBase}_rowFilter_fieldMatchCombo`),

         dataCollection: this.unique(`${idBase}_rowFilter_dataCollection`),

         listOptions: this.unique(`${idBase}_rowFilter_listOptions`),

         datePicker: this.unique(`${idBase}_rowFilter_datePicker`),
      });

      // Set current username
      // this.Account.username = this.AB.Account.username();

      var batchName; // we need to revert to this default when switching away from a in/by query field

      // Default options list to push to all fields
      this.queryFieldOptions = [
         {
            value: L("By Query Field"),
            id: "in_query_field",
         },
         {
            value: L("Not In Query"),
            id: "not_in_query_field",
         },
      ];

      this.recordRuleOptions = [];
      this.recordRuleFieldOptions = [];

      let _logic = this._logic || {};

      /**
       * @method getFieldList
       * return field list to render options
       */
      _logic.getFieldList = () => {
         return (this._Fields || []).map((f) => {
            let label = f.label;

            // include object's name to options
            if (this._settings.showObjectName && f.object) {
               label = f.object.label + "." + f.label;
            }

            return {
               id: f.id,
               value: label,
               alias: f.alias || undefined, // ABObjectQuery
            };
         });
      };

      _logic.getFilterUI = () => {
         let instance = this;
         let config_settings = this.config_settings || {};

         return {
            id: "f" + webix.uid(),
            isolate: true,
            cols: [
               {
                  // Add / Or
                  view: "combo",
                  id: ids.glue,
                  width: 80,
                  value: config_settings.glue || "and",
                  options: [
                     {
                        value: L("And"),
                        id: "and",
                     },
                     {
                        value: L("Or"),
                        id: "or",
                     },
                  ],
                  on: {
                     onChange: function (newVal, oldVal) {
                        _logic.selectCombineCondition(newVal);
                     },
                  },
               },
               {
                  // Field list
                  view: "combo",
                  id: ids.field,
                  suggest: {
                     on: {
                        onBeforeShow: function () {
                           this.define("width", 400);
                           this.resize();
                        },
                     },
                     data: _logic.getFieldList(),
                  },
                  on: {
                     onChange: function (columnId) {
                        var $viewCond = this.getParentView();
                        _logic.selectField(columnId, $viewCond);
                     },
                  },
               },
               // Comparer
               {
                  id: ids.rule,
                  width: 220,
                  cells: [
                     {},
                     // Query
                     {
                        batch: "query",
                        view: "combo",
                        value: "in_query",
                        options: [
                           {
                              value: L("In Query"),
                              id: "in_query",
                           },
                           {
                              value: L("Not In Query"),
                              id: "not_in_query",
                           },
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                           {
                              value: L("is empty"),
                              id: "is_empty",
                           },
                           {
                              value: L("is not empty"),
                              id: "is_not_empty",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                           {
                              value: L("In Data Collection"),
                              id: "in_data_collection",
                           },
                           {
                              value: L("Not In Data Collection"),
                              id: "not_in_data_collection",
                           },
                        ].concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },

                     // Date
                     {
                        batch: "date",
                        view: "combo",
                        value: "less",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("is before"),
                              id: "less",
                           },
                           {
                              value: L("is after"),
                              id: "greater",
                           },
                           {
                              value: L("is on or before"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("is on or after"),
                              id: "greater_or_equal",
                           },
                           {
                              value: L("is before current date"),
                              id: "less_current",
                           },
                           {
                              value: L("is after current date"),
                              id: "greater_current",
                           },
                           {
                              value: L("is on or before current date"),
                              id: "less_or_equal_current",
                           },
                           {
                              value: L("is on or after current date"),
                              id: "greater_or_equal_current",
                           },
                           {
                              value: L("last ... days"),
                              id: "last_days",
                           },
                           {
                              value: L("next ... days"),
                              id: "next_days",
                           },
                           {
                              value: L("is current date"),
                              id: "is_current_date",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L(":"),
                              id: "equals",
                           },
                           {
                              value: L("≠"),
                              id: "not_equal",
                           },
                           {
                              value: L("<"),
                              id: "less",
                           },
                           {
                              value: L(">"),
                              id: "greater",
                           },
                           {
                              value: L("≤"),
                              id: "less_or_equal",
                           },
                           {
                              value: L("≥"),
                              id: "greater_or_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                           {
                              value: L("Same As User"),
                              id: "same_as_user",
                           },
                           {
                              value: L("Not Same As User"),
                              id: "not_same_as_user",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition, oldValue) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "combo",
                        value: "equals",
                        options: [
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        value: "is_current_user",
                        options: [
                           {
                              value: L("is current user"),
                              id: "is_current_user",
                           },
                           {
                              value: L("is not current user"),
                              id: "is_not_current_user",
                           },
                           {
                              value: L("contains current user"),
                              id: "contain_current_user",
                           },
                           {
                              value: L("does not contain current user"),
                              id: "not_contain_current_user",
                           },
                           {
                              value: L("equals"),
                              id: "equals",
                           },
                           {
                              value: L("does not equal"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "combo",
                        value: "contains",
                        options: [
                           {
                              value: L("contains"),
                              id: "contains",
                           },
                           {
                              value: L("doesn't contain"),
                              id: "not_contains",
                           },
                           {
                              value: L("is"),
                              id: "equals",
                           },
                           {
                              value: L("is not"),
                              id: "not_equal",
                           },
                        ]
                           .concat(instance.queryFieldOptions)
                           .concat(instance.recordRuleOptions),
                        on: {
                           onChange: function (condition) {
                              var $viewComparer = this.getParentView();
                              var $viewCond = $viewComparer.getParentView();
                              _logic.onChangeRule(condition, $viewCond);
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               // Value
               {
                  id: ids.inputValue,
                  isolate: true,
                  cells: [
                     {
                        batch: "empty",
                     },

                     // Query
                     {
                        id: ids.queryCombo,

                        batch: "query",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Query Field
                     {
                        id: ids.queryFieldCombo,
                        batch: "queryField",
                        rows: [
                           {
                              id: ids.queryFieldComboQuery,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Query"),
                              on: {
                                 onChange: function (value) {
                                    var $viewComparer = this.getParentView();
                                    var $viewCond = $viewComparer
                                       .getParentView()
                                       .getParentView();
                                    _logic.onChangeQueryFieldCombo(
                                       value,
                                       $viewCond
                                    );

                                    _logic.onChange();
                                 },
                              },
                           },
                           {
                              id: ids.queryFieldComboField,
                              view: "combo",
                              options: [],
                              placeholder: L("Choose a Field"),
                              on: {
                                 onChange: _logic.onChange,
                              },
                           },
                        ],
                     },

                     // Field match
                     {
                        id: ids.fieldMatch,
                        batch: "fieldMatch",
                        view: "combo",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Data collection
                     {
                        id: ids.dataCollection,
                        batch: "dataCollection",
                        view: "richselect",
                        options: [],
                        on: {
                           onChange: _logic.onChange,
                        },
                     },

                     // Date
                     {
                        // inputView.format = field.getDateFormat();
                        batch: "date",
                        id: ids.datePicker,
                        view: "datepicker",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Number
                     {
                        batch: "number",
                        view: "text",
                        validate: webix.rules.isNumber,
                        on: {
                           onTimedKeyPress: function () {
                              if (this.validate()) _logic.onChange();
                           },
                        },
                     },
                     // List
                     {
                        batch: "list",
                        id: ids.listOptions,
                        view: "combo",
                        options: [],
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Boolean
                     {
                        batch: "boolean",
                        view: "checkbox",
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // User
                     {
                        batch: "user",
                        view: "combo",
                        options: this.AB.Account.userList().map((u) => {
                           return {
                              id: u.username,
                              value: u.username,
                           };
                        }),
                        on: {
                           onChange: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // String
                     {
                        batch: "string",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                     // Email
                     {
                        batch: "email",
                        view: "text",
                        on: {
                           onTimedKeyPress: function () {
                              _logic.onChange();
                           },
                        },
                     },
                  ],
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewForm = this.getFormView();

                     var indexView = $viewForm.index(this.getParentView());

                     _logic.addNewFilter(indexView + 1);
                  },
               },
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  autowidth: true,
                  click: function () {
                     var $viewCond = this.getParentView();

                     _logic.removeNewFilter($viewCond);
                  },
               },
            ],
         };
      };

      _logic.getAddButtonUI = () => {
         return {
            view: "button",
            id: ids.addNewFilter,
            css: "webix_primary",
            type: "form",
            label: L("Add a filter"),
            click: () => {
               _logic.addNewFilter();
            },
         };
      };

      _logic.addNewFilter = (index, fieldId) => {
         var viewId;
         var ui = _logic.getFilterUI();

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            viewId = $viewForm.addView(ui, index);

            _logic.toggleAddNewButton();

            // select a option of field
            if (fieldId) _logic.selectField(fieldId, $$(viewId), true);
         }

         return viewId;
      };

      _logic.removeNewFilter = function ($viewCond) {
         var $viewForm = $$(ids.filterForm);

         $viewForm.removeView($viewCond);

         _logic.toggleAddNewButton();

         _logic.onChange();
      };

      _logic.toggleAddNewButton = function () {
         if (!$$(ids.filterForm)) return;

         // Show "Add new filter" button
         if ($$(ids.filterForm).getChildViews().length < 1) {
            $$(ids.filterForm).hide();
            $$(ids.addNewFilter).show();
         }
         // Hide "Add new filter" button
         else {
            $$(ids.filterForm).show();
            $$(ids.addNewFilter).hide();
         }
      };

      _logic.selectCombineCondition = (val, ignoreNotify) => {
         // define combine value to configuration
         this.config_settings.glue = val;

         // update value of every combine conditions
         var $viewConds = $$(ids.filterForm).getChildViews();
         $viewConds.forEach((v) => {
            if (v.$$ && v.$$(ids.glue)) v.$$(ids.glue).setValue(val);
         });

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.selectField = (columnId, $viewCond, ignoreNotify) => {
         if (!this._Fields) return;

         var field = this._Fields.filter((f) => f.id == columnId)[0];
         if (!field) return;

         // switch view
         batchName = field.key;
         if (field.id == "this_object") batchName = "query";
         // Special this object query
         else if (batchName == "LongText" || batchName == "combined")
            batchName = "string";
         else if (field.key == "formula") batchName = "number";
         var isQueryField =
            this._QueryFields.filter((f) => {
               return f.id == field.id;
            }).length > 0;
         if (isQueryField) {
            // we chose a connectField which is now a Query type
            batchName = "query";
         }
         $viewCond.$$(ids.rule).showBatch(batchName);
         $viewCond.$$(ids.inputValue).showBatch(batchName);

         let options = [];
         let Queries = [];

         // populate the list of Queries for this_object:
         if (field.id == "this_object" && this._Object) {
            Queries = this.queries((q) => q.canFilterObject(this._Object));
         }
         // populate the list of Queries for a query field
         else if (isQueryField) {
            Queries = this.queries((q) => {
               return (
                  (this._Object ? this._Object.id : "") != q.id && // Prevent filter looping
                  q.canFilterObject(field.datasourceLink)
               );
            });
         }

         Queries.forEach((q) => {
            options.push({
               id: q.id,
               value: q.label,
            });
         });
         $viewCond
            .$$(ids.inputValue)
            .$$(ids.queryCombo)
            .define("options", options);
         $viewCond.$$(ids.inputValue).$$(ids.queryCombo).refresh();

         // populate options of list
         if (field.key == "list") {
            let listOptions = field.settings.options.map(function (x) {
               return {
                  id: x.id,
                  value: x.text,
               };
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.listOptions)
               .define("options", listOptions);
            $viewCond.$$(ids.inputValue).$$(ids.listOptions).refresh();
         }
         // set format of datepicker
         else if (field.key == "date") {
            $viewCond
               .$$(ids.inputValue)
               .$$(ids.datePicker)
               .define("format", field.getFormat());
            $viewCond.$$(ids.inputValue).$$(ids.datePicker).refresh();
         }

         var rule = null,
            ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.getList) {
            let defaultOpt = ($viewComparer.getList().config.data || [])[0];
            if (defaultOpt) {
               $viewComparer.setValue(defaultOpt.id);
            }

            // rule = $viewComparer.getValue();
            // if (rule == "in_query_field" || rule == "not_in_query_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("queryField");
            // } else if (rule == "same_as_field" || rule == "not_same_as_field") {
            // 	// Show the new value inputs
            // 	$viewCond.$$(ids.inputValue).showBatch("fieldMatch");
            // }
         }

         if (!ignoreNotify) _logic.onChange();
      };

      _logic.onChangeRule = (rule, $viewCond, notify = false) => {
         switch (rule) {
            case "contains":
            case "not_contains":
            case "equals":
            case "not_equal":
               // For "connect_fields" search by CUSTOM index value
               if (batchName == "query") {
                  $viewCond.$$(ids.inputValue).showBatch("string");
               }
               // If want to call notify or call .onChange(), then pass notify is true.
               // _logic.onChange();
               break;

            case "is_current_user":
            case "is_not_current_user":
            case "contain_current_user":
            case "not_contain_current_user":
            case "same_as_user":
            case "not_same_as_user":
            case "less_current":
            case "greater_current":
            case "less_or_equal_current":
            case "greater_or_equal_current":
            case "is_empty":
            case "is_not_empty":
            case "is_current_date":
               // clear and disable the value field
               $viewCond.$$(ids.inputValue).showBatch("empty");
               _logic.onChange();
               break;

            case "last_days":
            case "next_days":
               // Show the number input
               $viewCond.$$(ids.inputValue).showBatch("number");
               break;

            case "in_query_field":
            case "not_in_query_field":
               // populate the list of Queries for this_object:
               var options = [];

               // Get all application's queries
               this.queries(
                  (q) => this._Object == null || q.id != this._Object.id
               ).forEach((q) => {
                  options.push({
                     id: q.id,
                     value: q.label,
                  });
               });

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .define("options", options);
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.queryFieldComboQuery)
                  .refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("queryField");
               break;

            case "same_as_field":
            case "not_same_as_field":
               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.fieldMatch)
                  .define("options", this.recordRuleFieldOptions);
               $viewCond.$$(ids.inputValue).$$(ids.fieldMatch).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("fieldMatch");
               break;

            case "in_data_collection":
            case "not_in_data_collection": {
               let dcOptions = [];

               // pull data collection list

               // get id of the link object
               let linkObjectId,
                  columnId = $viewCond.$$(ids.field).getValue();
               if (columnId == "this_object" && this._Object) {
                  linkObjectId = this._Object.id;
               } else {
                  let field = this._Fields.filter((f) => f.id == columnId)[0];
                  if (field) linkObjectId = field.settings.linkObject;
               }

               if (this._Application && linkObjectId) {
                  this._Application
                     .datacollections(
                        (dc) =>
                           dc.datasource && dc.datasource.id == linkObjectId
                     )
                     .forEach((dc) => {
                        dcOptions.push({
                           id: dc.id,
                           value: dc.label,
                        });
                     });
               }

               $viewCond
                  .$$(ids.inputValue)
                  .$$(ids.dataCollection)
                  .define("options", dcOptions);
               $viewCond.$$(ids.inputValue).$$(ids.dataCollection).refresh();

               // Show the new value inputs
               $viewCond.$$(ids.inputValue).showBatch("dataCollection");
               break;
            }

            default:
               // Show the default value inputs
               $viewCond.$$(ids.inputValue).showBatch(batchName);

               if (notify) _logic.onChange();

               break;
         }
      };

      _logic.onChangeQueryFieldCombo = (value, $viewCond) => {
         // populate the list of Queries for this_object:
         let options = [];
         // Get all queries fields
         let Query = this.queries((q) => {
            return q.id == value;
         })[0];
         if (Query) {
            Query.fields((f) => {
               return !f.isConnection;
            }).forEach((q) => {
               options.push({
                  id: q.id,
                  value: q.object.label + "." + q.label,
               });
            });

            $viewCond
               .$$(ids.inputValue)
               .$$(ids.queryFieldComboField)
               .define("options", options);
            $viewCond.$$(ids.inputValue).$$(ids.queryFieldComboField).refresh();
         }

         // _logic.onChange();
      };

      _logic.onChange = () => {
         if (!this.__blockOnChange) {
            // refresh config settings before notify
            _logic.getValue();

            console.warn("convert RowFilter.callback.onChange() to .emit()");
            _logic.callbacks.onChange();
            this.emit("change");
         }

         return false;
      };

      _logic.blockOnChange = () => {
         this.__blockOnChange = true;
      };

      _logic.unblockOnChange = () => {
         this.__blockOnChange = false;
      };

      /**
       * @method getValue
       *
       * @return {JSON} -
       * {
       * 		glue: '', // 'and', 'or'
       *		rules: [
       *			{
       *				key:	'column name',
       *				rule:	'rule',
       *				value:	'value'
       *			}
       *		]
       * }
       */
      _logic.getValue = () => {
         let config_settings = {
            glue: "and",
            rules: [],
         };

         var $viewForm = $$(ids.filterForm);
         if ($viewForm) {
            $viewForm.getChildViews().forEach(($viewCond, index) => {
               if (index == 0) {
                  config_settings.glue = $viewCond.$$(ids.glue).getValue();
               }

               var $fieldElem = $viewCond.$$(ids.field);
               if (!$fieldElem) return;

               /* field id */
               var fieldId = $fieldElem.getValue();
               if (!fieldId) return;

               /* alias */
               var alias;
               var selectedOpt = $viewCond
                  .$$(ids.field)
                  .getPopup()
                  .config.body.data.filter((opt) => opt.id == fieldId)[0];
               if (selectedOpt) alias = selectedOpt.alias || undefined;

               /* rule */
               var rule = null,
                  ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
                  $viewComparer = $viewCond
                     .$$(ids.rule)
                     .queryView({ id: ruleViewId });
               if ($viewComparer && $viewComparer.getValue)
                  rule = $viewComparer.getValue();

               /* value */
               var value = null,
                  valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
                  $viewConditionValue = $viewCond
                     .$$(ids.inputValue)
                     .queryView({ id: valueViewId });
               if ($viewConditionValue && $viewConditionValue.getValue) {
                  value = $viewConditionValue.getValue();
               } else if (
                  $viewConditionValue &&
                  $viewConditionValue.getChildViews()
               ) {
                  var vals = [];
                  $viewConditionValue.getChildViews().forEach((element) => {
                     vals.push($$(element).getValue());
                  });
                  value = vals.join(":");
               }

               // Convert date format
               if (value instanceof Date) {
                  let dateField = this._Fields.filter(
                     (f) => f.id == fieldId
                  )[0];
                  if (dateField) {
                     value = dateField.exportValue(value);
                  } else {
                     value = value.toISOString();
                  }
               }

               config_settings.rules.push({
                  alias: alias || undefined,
                  key: fieldId,
                  rule: rule,
                  value: value,
               });
            });
         }

         this.config_settings = config_settings;

         return this.config_settings;
      };

      // webix UI definition:
      this.ui = {
         id: ids.component,
         rows: [
            {
               view: "form",
               id: ids.filterForm,
               hidden: true,
               elements: [],
            },
            _logic.getAddButtonUI(),
         ],
      };
   }

   // setting up UI
   init(options = {}) {
      super.init(options);

      // register our callbacks:
      for (var c in this._logic.callbacks) {
         this._logic.callbacks[c] = options[c] || this._logic.callbacks[c];
      }

      if (options.showObjectName)
         this._settings.showObjectName = options.showObjectName;

      if (options.isRecordRule) {
         this.recordRuleOptions = [
            {
               value: L("Same As Field"),
               id: "same_as_field",
            },
            {
               value: L("Not Field"),
               id: "not_same_as_field",
            },
         ];
         this.recordRuleFieldOptions = options.fieldOptions;
      }
   }

   setValue(settings) {
      settings = settings || {};

      super.setValue(settings);

      let ids = this.ids;
      let logic = this._logic;

      // block .onChange event
      logic.blockOnChange();

      let config_settings = this.AB.cloneDeep(settings);
      config_settings.rules = config_settings.rules || [];

      // Redraw form with no elements
      var $viewForm = $$(ids.filterForm);
      if ($viewForm) webix.ui([], $viewForm);

      // Add "new filter" button
      if (config_settings.rules.length == 0) {
         logic.toggleAddNewButton();
      }

      config_settings.rules.forEach((f) => {
         var viewId = logic.addNewFilter(),
            $viewCond = $$(viewId);

         if ($viewCond == null) return;

         var field = this._Fields.filter((col) => col.id == f.key)[0];

         // "and" "or"
         $viewCond.$$(ids.glue).define("value", config_settings.glue);
         $viewCond.$$(ids.glue).refresh();

         // Select Field
         $viewCond.$$(ids.field).define("value", f.key);
         $viewCond.$$(ids.field).refresh();
         logic.selectField(f.key, $viewCond, true);

         // Comparer
         var ruleViewId = $viewCond.$$(ids.rule).getActiveId(),
            $viewComparer = $viewCond
               .$$(ids.rule)
               .queryView({ id: ruleViewId });
         if ($viewComparer && $viewComparer.setValue) {
            $viewComparer.define("value", f.rule);
            $viewComparer.refresh();
         }

         // if (f.rule == "in_query_field" || f.rule == "not_in_query_field" || f.rule == "same_as_field" || f.rule == "not_same_as_field") {
         $viewCond.blockEvent();
         logic.onChangeRule(f.rule, $viewCond);
         $viewCond.unblockEvent();
         // }

         // Input
         var valueViewId = $viewCond.$$(ids.inputValue).getActiveId(),
            $viewConditionValue = $viewCond
               .$$(ids.inputValue)
               .queryView({ id: valueViewId });
         if ($viewConditionValue && $viewConditionValue.setValue) {
            // convert to Date object
            if (
               field &&
               field.key == "date" &&
               f.value &&
               (f.rule == "less" ||
                  f.rule == "greater" ||
                  f.rule == "less_or_equal" ||
                  f.rule == "greater_or_equal")
            ) {
               $viewConditionValue.define("value", new Date(f.value));
            } else {
               $viewConditionValue.define("value", f.value);
            }

            $viewConditionValue.refresh();
         } else if (
            $viewConditionValue &&
            $viewConditionValue.getChildViews()
         ) {
            let vals = (f.value || "").split(":");
            let index = 0;
            $viewConditionValue.getChildViews().forEach((element) => {
               $$(element).blockEvent();
               $$(element).setValue(vals[index]);
               if (index == 0) {
                  logic.onChangeQueryFieldCombo(vals[index], $viewCond);
               }
               $$(element).unblockEvent();
               // $$(element).refresh();
               index++;
            });
         }

         if (field && field.key == "user") {
            $viewCond.blockEvent();
            logic.onChangeRule(f.rule, $viewCond);
            $viewCond.blockEvent();
         }
      });

      // unblock .onChange event
      logic.unblockOnChange();
   }

   /**
    * @method isComplete()
    * returns a truthy value representing whether or not our current condition
    * expression is fully completed.  Then externally checks can be made to
    * verify if the data is complete.
    * @return {bool}
    */
   isComplete() {
      if (!this._completeConditions) {
         this._completeConditions = this.AB.filterComplexNew(
            `${this.ids.component}_iscomplete`
         );
      }

      return this._completeConditions.isConditionComplete(this.getValue());
   }
};


/***/ }),

/***/ 9234:
/*!*******************************************!*\
  !*** ./AppBuilder/platform/RowUpdater.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ui/ClassUI */ 32019);
// const ABComponent = require("./ABComponent");

const ABViewForm = __webpack_require__(/*! ../platform/views/ABViewForm */ 40194);

let L = null;

class RowUpdater extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase, AB) {
      super(idBase, {
         form: `${idBase}_rowUpdaterForm`,
         addNew: `${idBase}_rowUpdaterAddNew`,
         field: `${idBase}_rowUpdaterField`,
      });

      this.idBase = idBase;

      this._Object = null;
      // {ABObject}
      // The ABObject we are building a form for.

      this._mockFormWidget = null;
      // {ABViewForm}
      // When building our form components to display, they need a
      // ABViewForm to be associated with.

      this.AB = AB;

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   /**
    * @method uiItem()
    * Return the webix description of a new field/value row.
    * @return {json}
    */
   uiItem() {
      const self = this;

      return {
         rows: [
            {
               view: "layout",
               isolate: true,
               cols: [
                  {
                     // Label
                     view: "label",
                     width: 40,
                     label: L("Set"),
                  },
                  {
                     // Field list
                     view: "combo",
                     id: this.ids.field,
                     options: this.getFieldList(true),
                     on: {
                        onChange: async function (columnId) {
                           const $viewItem = this.getParentView();

                           await self.selectField(columnId, $viewItem);
                        },
                     },
                  },
                  {
                     // Label
                     view: "label",
                     width: 40,
                     label: L("To"),
                  },
                  {
                     view: "segmented",
                     value: "custom",
                     height: 40,
                     maxWidth: 160,
                     options: [
                        { id: "custom", value: L("Custom") },
                        { id: "process", value: L("Process") },
                     ],
                     hidden:
                        this._extendedOptions == null ||
                        !this._extendedOptions.length,
                     on: {
                        onChange: function (val) {
                           const $viewItem = this.getParentView();

                           self.toggleCustomProcessOption(
                              $viewItem,
                              val == "process"
                           );
                        },
                     },
                  },
                  // Field value
                  {},
                  // Extended value
                  {
                     hidden: true,
                  },
                  {
                     // "Remove" button
                     view: "button",
                     css: "webix_danger",
                     icon: "fa fa-trash",
                     type: "icon",
                     autowidth: true,

                     click: function () {
                        const $viewCond = this.getParentView().getParentView();

                        self.removeItem($viewCond);
                     },
                  },
               ],
            },
         ],
      };
   }

   /**
    * @method ui()
    * return the webix description of our Entry form.
    * @return {json}
    */
   ui() {
      // webix UI definition:
      return {
         rows: [
            {
               view: "form",
               id: this.ids.form,
               hidden: true,
               borderless: true,
               elements: [],
            },
            {
               view: "button",
               id: this.ids.addNew,
               icon: "fa fa-plus",
               type: "iconButton",
               label: L("Add field to edit"),
               click: () => {
                  this.addItem();
               },
            },
         ],
      };
   }

   init(AB) {
      const $form = $$(this.ids.form);
      if ($form) AB.Webix.extend($form, AB.Webix.ProgressBar);

      return Promise.resolve();
   }

   /**
    * @method addItem()
    * Add another field/value entry item to our form.
    * @param {integer} index
    *        which position in the list of form elements do we want to
    *        insert the new row.
    * @return {string} the webix .id of the new row we just added.
    */
   addItem(index) {
      const $form = $$(this.ids.form);
      const remainFields = this.getFieldList(true);

      if (remainFields.length < 1) return;

      const ui = this.uiItem();
      const viewId = $form.addView(ui, index);

      this.toggleForm();

      return viewId;
   }

   /**
    * @method getFieldList()
    * Return an array of options in a webix.list format that represents the
    * possible fields that can be selected on the current ABObject.
    * @param {bool} excludeSelected
    *        should we exclude from the list the fields that are ALREADY
    *        displayed on the form?
    * @return {array} [ { id, value }, ... ]
    *         id: ABField.id
    *         value: ABField.label
    */
   getFieldList(excludeSelected) {
      let options = (this._Object.fields() || []).map((f) => {
         return {
            id: f.id,
            value: f.label,
         };
      });

      if (excludeSelected) {
         const $form = $$(this.ids.form);

         $form.getChildViews().forEach(($viewCond) => {
            // Ignore "Add new" button
            if (!$viewCond || !$viewCond.$$) return;

            const $fieldElem = $viewCond.$$(this.ids.field);

            if (!$fieldElem) return;

            const fieldId = $fieldElem.getValue();

            if (!fieldId) return;

            options = options.filter((opt) => opt.id != fieldId);
         });
      }
      return options;
   }

   /**
    * @method getValue
    * Return an array of field:value results that have been entered on this
    * form.
    * @return {Array}
    *         [
    *            {
    *               fieldId: {UUID}
    *               isProcessValue: {Boolean} - If it is true, then value is from Process parameter
    *               value: {Object}
    *            },
    *            ...
    *         ]
    */
   getValue() {
      const result = [];
      const $form = $$(this.ids.form);

      if ($form) {
         $form.getChildViews().forEach(($viewContainer) => {
            const $viewItem = $viewContainer.getChildViews()[0];

            // Ignore "Add new" button
            if (!$viewItem || !$viewItem.$$) return;

            const $fieldElem = $viewItem.$$(this.ids.field);

            if (!$fieldElem) return;

            const fieldId = $fieldElem.getValue();

            if (!fieldId) return;

            let $customValueElem = $viewItem.getChildViews()[4];
            $customValueElem = this._pullInputElement($customValueElem);

            const $processValueElem = $viewItem.getChildViews()[5];

            if (!$customValueElem && !$processValueElem) return;

            const fieldInfo = this._Object.fieldByID(fieldId);
            const val = {
               fieldId: fieldId,
            };

            // Custom value
            if ($customValueElem && $customValueElem.isVisible()) {
               if (
                  fieldInfo.key === "connectObject" ||
                  fieldInfo.key === "user"
               )
                  val.value = fieldInfo.getValue($customValueElem);
               else if (
                  fieldInfo.key === "date" ||
                  fieldInfo.key === "datetime"
               ) {
                  const currDateCheckbox =
                     $customValueElem.getChildViews()[0] ?? $customValueElem;

                  if (currDateCheckbox.getValue() == true)
                     val.value = "ab-current-date";
                  else {
                     const datePicker =
                        $customValueElem.getChildViews()[1] ?? $customValueElem;

                     val.value = fieldInfo.getValue(datePicker);
                  }
               }
               // Get value from data field manager
               else val.value = fieldInfo.getValue($customValueElem);
            }
            // Process value
            else if ($processValueElem && $processValueElem.isVisible()) {
               val.isProcessValue = true;
               val.value = $processValueElem.getValue();
            }

            // Add to output
            result.push(val);
         });
      }

      return result;
   }

   /**
    * @method objectLoad
    * Load the Object we are currently working with.
    * @param {ABObject} object
    */
   objectLoad(object) {
      this._Object = object;

      this._mockApp = this.AB.applicationNew({});
      this._mockFormWidget = new ABViewForm(
         {
            settings: {
               showLabel: false,
               labelWidth: 0,
            },
         },
         this._mockApp // just need any ABApplication here
      );
      this._mockFormWidget.objectLoad(object);

      this.setValue(null); // clear
   }

   /**
    * @method removeItem
    * Remove the current form row.
    * @param {webix.view} $viewCond
    *        This is the webix.view that contains the whole value row
    *        we are removing.
    */
   removeItem($viewCond) {
      const $form = $$(this.ids.form);

      $form.removeView($viewCond);
      this.toggleForm();
   }

   /**
    * @method selectField
    * Update the value display when a field is selected. Changing to a
    * different field will change the types of values that can be entered.
    * @param {string} columnId
    *        The field.uuid of the object that was selected.
    * @param {webix.view} $viewItem
    *        The webix.view that contains the value expression of the field
    *        that was selected.
    */
   async selectField(columnId, $viewItem) {
      const field = this._Object.fieldByID(columnId);

      if (!field) {
         this.AB.notify.builder(
            new Error(`could not find field for id[${columnId}]`),
            {
               context: "RowUpdater.selectField() could not find a field",
               fieldID: columnId,
            }
         );

         return;
      }

      const fieldComponent = field.formComponent(),
         formFieldWidget = fieldComponent.newInstance(
            this._mockApp,
            this._mockFormWidget
         ),
         formFieldComponent = formFieldWidget.component(
            this.AB._App,
            this.idBase
         );
      const childViews = $viewItem.getChildViews();

      let inputView =
         typeof formFieldComponent.ui == "function"
            ? formFieldComponent.ui()
            : formFieldComponent.ui;

      // Add extended value options
      $viewItem.removeView(childViews[5]);

      if (this._extendedOptions?.length)
         $viewItem.addView(
            {
               view: "richselect",
               options: this._extendedOptions,
               hidden: true,
            },
            5
         );
      else
         $viewItem.addView(
            {
               hidden: true,
            },
            5
         );

      await this.busy();

      // WORKAROUND: add '[Current User]' option to the user data field
      switch (field.key) {
         case "connectObject":
         case "user":
            inputView = inputView.rows[0].rows[0];
            inputView.suggest.body.data =
               (await field.getOptions()).map((e) => {
                  return {
                     id: field.getRelationValue(e),
                     value: e.text,
                  };
               }) ?? [];

            if (field.key === "user")
               inputView.suggest.body.data.unshift({
                  id: "ab-current-user",
                  value: "ab-current-user",
                  // This one is saved with the "value" not "id".
                  // value: L("Current User"),
               });

            break;

         case "date":
         case "datetime":
            inputView = {
               view: "layout",
               rows: [
                  {
                     view: "checkbox",
                     labelWidth: 0,
                     labelRight: L("Current Date/Time"),
                     on: {
                        onChange: function (newVal) {
                           const layout = this.getParentView();

                           if (!layout) return;

                           const datePicker = layout.getChildViews()[1];

                           if (!datePicker) return;

                           newVal ? datePicker.hide() : datePicker.show();
                        },
                     },
                  },
                  inputView,
               ],
            };

            break;
      }

      // Change component to display value
      $viewItem.removeView(childViews[4]);
      $viewItem.addView(inputView, 4);

      formFieldComponent.init();

      // Show custom display of data field
      if (field.customDisplay)
         field.customDisplay({}, this.AB._App, childViews[4].$view);

      this.toggleCustomProcessOption(
         $viewItem,
         childViews[3].getValue() === "process"
      );
      $$($viewItem).adjust();
      $viewItem.getFormView().adjust();

      this.ready();
   }

   /**
    * @method setValue
    * Given the previous settings, redraw the form with the field/value
    * entries.
    * @param {array} settings
    *        [
    *           {
    *              fieldId: {UUID}
    *              value: {Object|String}
    *           }, ...
    *        ]
    */
   setValue(settings) {
      const $form = $$(this.ids.form);

      if (!$form) return;

      // Redraw form with no elements
      webix.ui([], $form);

      settings = settings || [];
      if (settings.length < 1) return;

      settings.forEach(async (item) => {
         const $viewContainer = $$(this.addItem());
         const $viewItem = $viewContainer.getChildViews()[0];
         const $valueTypeButton = $viewItem.queryView(
            { view: "segmented" },
            "self"
         );

         $valueTypeButton.setValue(item.isProcessValue ? "process" : "custom");

         const $field = $viewItem.$$(this.ids.field);

         $field.define("value", item.fieldId);
         $field.refresh();

         await this.selectField(item.fieldId, $viewItem);

         const fieldInfo = this._Object.fieldByID(item.fieldId);

         if (!fieldInfo) return;

         // Set process value
         if (item.isProcessValue) {
            const $processValueElem = $viewItem.getChildViews()[5];

            $processValueElem.setValue?.(item.value);

            return;
         }

         // Set custom value
         let $customValueElem = $viewItem.getChildViews()[4];
         $customValueElem = this._pullInputElement($customValueElem);
         const rowData = {};

         rowData[fieldInfo.columnName] = item.value?.value ?? item.value;
         fieldInfo.setValue($customValueElem, rowData);

         // Set "Current Date/Time" check box
         if (
            (fieldInfo.key == "date" || fieldInfo.key == "datetime") &&
            rowData[fieldInfo.columnName] == "ab-current-date" &&
            $customValueElem.config.view == "checkbox"
         ) {
            $customValueElem.setValue(true);
         }
      });

      this.toggleForm();
   }

   /**
    * @method toggleForm
    * decide if the form with the field/value elements should be displayed.
    */
   toggleForm() {
      const $form = $$(this.ids.form);

      if ($form) {
         const childViews = $form.getChildViews();

         if (childViews && childViews.length) $form.show();
         else $form.hide();
         $form.adjust();
      }
   }

   setExtendedOptions(options) {
      this._extendedOptions = options;
   }

   toggleCustomProcessOption($viewItem, showProcessOption) {
      const $customOption = $viewItem.getChildViews()[4];
      const $processOption = $viewItem.getChildViews()[5];

      if (showProcessOption) {
         $customOption.hide();
         $processOption.show();
      } else {
         $customOption.show();
         $processOption.hide();
      }
   }

   async busy() {
      $$(this.ids.addNew).disable();

      const $form = $$(this.ids.form);

      if (!$form) return;

      if (!$form.showProgress) await this.init(this.AB);

      $form.showProgress({ type: "icon" });
   }

   ready() {
      $$(this.ids.addNew).enable();
      $$(this.ids.form).hideProgress();
   }

   _pullInputElement($elem) {
      if (!$elem?.getValue && $elem?.getChildViews) {
         return (
            $elem
               .getChildViews()
               .filter((childView) => childView.getValue)[0] ?? $elem
         );
      } else {
         return $elem;
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RowUpdater);


/***/ }),

/***/ 34117:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABField.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABField
 *
 * An ABField defines a single unique Field/Column in a ABObject.
 *
 */

const ABFieldCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCore */ 34493);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABField extends ABFieldCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);

      this.AB.on("ab.abdefinition.update", (def) => {
         if (def.id == this.id) {
            this.emit("definition.updated", this);
         }
      });

      //  	// NOTE: setup this first so later we can use .fieldType(), .fieldIcon()
      //  	this.defaults = fieldDefaults;

      // 	{
      // 		id:'uuid',					// uuid value for this obj
      // 		key:'fieldKey',				// unique key for this Field
      // 		icon:'font',				// fa-[icon] reference for an icon for this Field Type
      // 		label:'',					// pulled from translation
      // 		columnName:'column_name',	// a valid mysql table.column name
      //		settings: {					// unique settings for the type of field
      // 			showIcon:true/false,	// only useful in Object Workspace DataTable
      // 			isImported: 1/0,		// flag to mark is import from other object
      // 			required: 1/0,			// field allows does not allow NULL or it does allow NULL
      // 			width: {int}			// width of display column

      // 		// specific for dataField
      // 		},
      // 		translations:[]
      // 	}

      // 	this.fromValues(values);

      // this.object = object;
   }

   ///
   /// Static Methods
   ///
   /// Available to the Class level object.  These methods are not dependent
   /// on the instance values of the Application.
   ///

   static editorValues(settings) {
      const obj = {
         label: settings.label,
         columnName: settings.columnName,
         settings: settings,
      };

      delete settings.label;
      delete settings.columnName;

      return obj;
   }

   addValidation(ids, settings) {
      const App = this.object.application.App;
      const Filter = this.AB.filterComplexNew(
         `${this.id}_field_validation_rules`
      );
      $$(ids.filterComplex).addView({
         view: "form",
         css: "abValidationForm",
         cols: [
            {
               rows: [
                  {
                     view: "text",
                     name: "invalidMessage",
                     labelWidth: this.AB.UISettings.config().labelWidthLarge,
                     value:
                        settings && settings.invalidMessage
                           ? settings.invalidMessage
                           : "",
                     label: L("Invalid Message"),
                  },
                  Filter.ui,
               ],
            },
            {
               view: "button",
               css: "webix_danger",
               icon: "fa fa-trash",
               type: "icon",
               autowidth: true,
               click: function () {
                  const $viewCond = this.getParentView();
                  $$(ids.filterComplex).removeView($viewCond);
               },
            },
         ],
      });
      $$(Filter.ids.save).hide();
      // Filter.applicationLoad(this.object.application);
      Filter.fieldsLoad(this.object.fields());
      if (settings && settings.rules) Filter.setValue(settings.rules);
   }

   /*
    * @method isValid
    * check the current values to make sure they are valid.
    * Here we check the default values provided by ABField.
    *
    * @return null or [{OP.Validation.validator()}] objects.
    */
   isValid() {
      const validator = this.AB.Validation.validator();

      // .columnName must be unique among fileds on the same object
      const isNameUnique =
         this.object.fields((f) => {
            return (
               f.id != this.id &&
               f.columnName.toLowerCase() == this.columnName.toLowerCase()
            );
         }).length == 0;
      if (!isNameUnique) {
         validator.addError(
            "columnName",
            L(
               "Field columnName must be unique ({0} already used in this Object)",
               [this.columnName]
            )
         );
      }

      return validator;
   }

   ///
   /// Instance Methods
   ///

   /// ABApplication data methods

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save() before:
      if (!this.id) return;

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      await this.migrateDrop();

      // the server still references an ABField in relationship to it's
      // ABObject, so we need to destroy the Field 1st, then remove it
      // from it's object.
      await super.destroy();

      await this.object.fieldRemove(this);
   }

   /**
    * @method save()
    *
    * persist this instance of ABField with it's parent ABObject
    *
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   async save(skipMigrate = false) {
      let isAdd = false;
      // if this is our initial save()
      if (!this.id) {
         isAdd = true;
      }

      // Whenever we update our settings, make sure any
      // existing rows that have NULL values for this field
      // are updated to have our current .default value.
      if (!isAdd && this.settings.required && this.settings.default) {
         const model = this.object.model();

         // pull rows that has null value
         const result = await model.findAll({
            where: {
               glue: "and",
               rules: [
                  {
                     key: this.id,
                     rule: "is_null",
                  },
               ],
            },
         });

         const tasks = [];

         // updating ...
         result.data.forEach((d) => {
            if (!d[this.columnName]) d[this.columnName] = this.settings.default;

            tasks.push(model.update(d.id, d));
         });

         await Promise.all(tasks);
      }

      // New ABDefinition method of saving:
      // when this is done, we now have an .id
      await super.save();

      // incase this was an ADD operation, make sure the
      // parent Obj now includes this object:
      // NOTE: must be done after the .save() so we have an .id
      await this.object.fieldAdd(this);

      // perform any server side migrations for this Field:

      // but not connectObject fields:
      // ABFieldConnect.migrateXXX() gets called from the UI popupNewDataField
      // in order to handle the timings of the 2 fields that need to be created
      if (!this.isConnection && !skipMigrate) {
         const fnMigrate = isAdd ? this.migrateCreate() : this.migrateUpdate();
         await fnMigrate;
      }

      return this;
   }

   ///
   /// DB Migrations
   ///

   migrateCreate() {
      return this.AB.Network.post({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateUpdate() {
      return this.AB.Network.put({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   migrateDrop() {
      return this.AB.Network["delete"]({
         url: `/definition/migrate/object/${this.object.id}/field/${this.id}`,
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @function columnHeader
    * Return the column header for a webix grid component for this specific
    * data field.
    * @param {Object} options
    * {
    *    isObjectWorkspace: {bool},  is this being used in the Object workspace.
    *    width: {int},
    *    height: {int},
    *    editable: {bool}
    * }
    * @return {obj}  configuration obj
    */
   columnHeader(options) {
      options = options || {};

      const config = {
         id: this.columnName, // this.id,
         header: this.label,
      };

      if (options.isObjectWorkspace && this.settings.showIcon) {
         config.header = `<span class="webix_icon fa fa-${this.fieldIcon()}"></span>${
            config.header
         }`;
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.  If this isn't
    * a standard value display (think image, Map, graph, etc...) then use this
    * method to create the display in the table/grid cell.
    * @param {object} row
    *        is the {name=>value} hash of the current row of data.
    * @param {App} App
    *        the shared ui App object useful more making globally
    *			 unique id references.
    * @param {HtmlDOM} node
    *        the HTML Dom object for this field's display.
    * @param {object} options
    *        option of additional settings
    */
   customDisplay(row, App, node, options) {}

   /*
    * @function customEdit
    *
    *
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      return true;
   }

   /**
    * @method getValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   getValue(item, rowData) {
      return item.getValue();
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    */
   setValue(item, rowData, defaultValue) {
      if (!item) return;

      let val;

      if (
         (rowData == null || rowData[this.columnName] == null) &&
         defaultValue != null
      ) {
         val = defaultValue;
      } else if (rowData && rowData[this.columnName] != null) {
         val = rowData[this.columnName];
      } else {
         val = rowData;
      }

      try {
         item.setValue(val);
      } catch (err) {
         // this error is fine because we handled it already
      }
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent(formKey) {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.

      let FC = {
         // .common() is used to create the display in the list
         common: () => {
            return {
               key: formKey,

               // // but since this is a common place holder: use the
               // // multilingual label here:
               // labelKey: 'ab.abfield.labelPlaceholder',
               // icon:  'square'
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            application = application ?? this.AB._mockApp;

            // NOTE: in case you were wondering, the base ABField
            // 		 will just return a label with 'ABFieldPlaceholder'
            // 		 as the text.  Any sub class of ABField should overwrite
            // 		 this and return an actual Form Component.

            // store object id and field id to field component
            const values = FC.common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);
            // ABFieldPlaceholder.formatTitle();
            // ABFieldPlaceholder.text = "ABFieldPlaceholder";

            return ABFieldPlaceholder;
         },
      };
      return FC;
   }

   /**
    * @method detailComponent
    */
   detailComponent() {
      return {
         common: () => {
            return {
               icon: "square",
            };
         },

         // .newInstance() is used to create the view instance when the component
         // 		is dropped onto the ABView list.
         newInstance: (application, parent) => {
            application = application ?? this.AB._mockApp;

            // store object id and field id to field component
            const values = this.detailComponent().common();
            values.settings = values.settings || {};
            values.settings.objectId = this.object.id;
            values.settings.fieldId = this.id;

            const ABFieldPlaceholder = application.viewNew(
               values,
               application,
               parent
            ); // ABViewManager.newView(values, application, parent);

            return ABFieldPlaceholder;
         },
      };
   }

   /**
    * @method getSettings()
    * return a copy of this.settings.
    * @return {object}
    */
   getSettings() {
      return Object.assign({}, this.settings);
   }

   /**
    * @method warningsMessage()
    * generate a commonly formatted warning message for this ABField.
    * This is expected to be called from within a .warningsEval()
    * method when generating warnings.
    * @param {string} msg
    *        the warning string to display
    * @param {json} data
    *        any relevant additional information for a developer to refer to.
    */
   warningsMessage(msg, data = {}) {
      let message = `${this.fieldKey()}[${this.label}]: ${msg}`;
      this._warnings.push({ message, data });
   }

   async getDbInfo() {
      return this.AB.Network.get({
         url: `/definition/info/object/${this.object.id}/field/${this.id}`,
      });
   }

   /**
    * @method formCleanData()
    * Review the data a form is about to submit and change/remove it as
    * appropriate.
    * @param {obj} rowData
    *        The {data} a form has collected and is about to save.
    * @return {undefined}
    */
   formCleanData(rowData) {
      // default is to just leave data as is.
   }
};


/***/ }),

/***/ 44322:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldAutoIndex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldAutoIndexCore = __webpack_require__(/*! ../../core/dataFields/ABFieldAutoIndexCore */ 374);

module.exports = class ABFieldAutoIndex extends ABFieldAutoIndexCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldAutoIndex
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 9740:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldBoolean.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldBooleanCore = __webpack_require__(/*! ../../core/dataFields/ABFieldBooleanCore */ 85410);

module.exports = class ABFieldBoolean extends ABFieldBooleanCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = "template";
      config.css = "center";
      config.template = (row, common, value, config) => {
         // Group header
         if (row.$group) return row[this.columnName];

         // editable
         if (options.editable) {
            return (
               '<div class="ab-boolean-display">' +
               common.checkbox(row, common, value, config) +
               "</div>"
            );
         }

         // readonly
         else {
            if (value)
               return "<div class='webix_icon fa fa-check-square-o'></div>";
            else return "<div class='webix_icon fa fa-square-o'></div>";
         }
      };

      return config;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("checkbox");
   }

   formComponentMobile() {
      return super.formComponent("mobile-checkbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcheckbox",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 59675:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldCalculate.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldCalculateCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCalculateCore */ 88238);

module.exports = class ABFieldCalculate extends ABFieldCalculateCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCalculate
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   formComponentMobile() {
      return super.formComponent("mobile-fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 63048:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldCombine.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldCombineCore = __webpack_require__(/*! ../../core/dataFields/ABFieldCombineCore */ 72131);

module.exports = class ABFieldCombine extends ABFieldCombineCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldCombine
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldreadonly");
   }

   formComponentMobile() {
      return super.formComponent("mobile-fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   warningsEval() {
      super.warningsEval();

      (this.settings.combinedFields.split(",") || []).forEach((id) => {
         var field = this.object.fieldByID(id);
         if (!field) {
            this.warningsMessage(`dependent field[${id}] not found.`, {
               fieldID: id,
               combinedFields: this.settings.combinedFields,
            });
         }
      });
   }
};


/***/ }),

/***/ 89981:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldConnect.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldConnectCore = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 63800);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldConnect extends ABFieldConnectCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   /**
    * @method destroy()
    *
    * destroy the current instance of ABApplication
    *
    * also remove it from our _AllApplications
    *
    * @return {Promise}
    */
   async destroy() {
      // verify we have been .save()d before:
      if (!this.id) return Promise.resolve();

      // NOTE: our .migrateXXX() routines expect the object to currently exist
      // in the DB before we perform the DB operations.  So we need to
      // .migrateDrop()  before we actually .objectDestroy() this.
      // this.migrateDrop()
      //    // .then(() => {
      //    //    // NOTE : prevent recursive remove connected fields
      //    //    // - remove this field from JSON
      //    //    this.object._fields = this.object.fields((f) => {
      //    //       return f.id != this.id;
      //    //    });
      //    // })
      //    .then(() => {
      //       // Save JSON of the object
      //       return this.object.fieldRemove(this);
      //    })
      await super.destroy();

      // Now we need to remove our linked Object->field

      const linkObject = this.datasourceLink;
      if (!linkObject) return Promise.resolve(); // already notified

      const linkField = this.fieldLink;
      if (!linkField) return Promise.resolve(); // already notified

      // destroy linked field
      return linkField.destroy();
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method pullRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRelationValues(row) {
      let selectedData = [];

      const data = super.pullRelationValues(row);
      const linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         } else if (typeof data == "string") {
            selectedData = { text: data };
         }
      }

      return selectedData;
   }

   columnHeader(options) {
      options = options || {};
      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      if (options.filters == null) {
         options.filters = {};
      }

      var multiselect = this.settings.linkType == "many";

      config.editor = multiselect ? "multiselect" : "combo";
      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };
      config.template = (row) => {
         var selectedData = field.pullRelationValues(row);
         var values = [];
         values.push('<div class="badgeContainer">');
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               values.push(
                  `<div class='webix_multicombo_value'><span>${val.value}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
               );
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData.value) {
            let clear = "";
            if (options.editable) {
               clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
            }
            values.push(
               `<div class='webix_multicombo_value'>${clear}<span class="ellip">${selectedData.value}</span></div>`
            );
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };

      config.suggest = {
         on: {
            onBeforeShow: function () {
               field.openOptions(this);
            },
         },

         // Support partial matches
         filter: ({ value }, search) =>
            (value ?? "").toLowerCase().includes((search ?? "").toLowerCase()),
      };

      if (multiselect) {
         config.suggest.view = "checksuggest";
         config.suggest.button = true;
      }

      return config;
   }

   openOptions($suggest) {
      // PREVENT repeatedly pull data:
      // If not a x->1 relation and the options list was populated, then skip
      const $list = $suggest.getList();
      if (this.settings.linkViaType != "one") {
         if (($list?.find({}) ?? []).length) return;
      }

      // Listen create/update events of the linked object, then clear data list to re-populate
      ["create", "update"].forEach((key) => {
         if (this[`_dc_${key}_event`]) return;

         this[`_dc_${key}_event`] = this.AB.on(
            `ab.datacollection.${key}`,
            (res) => {
               if (this.datasourceLink.id == res.objectId) $list.clearAll();
            }
         );
      });

      this.getAndPopulateOptions($suggest, null, this);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */

   //// NOTE: why do we pass in row, App, and node?  is this something we do in our external components?
   ////       are these values present when this Object is instanciated? Can't we just pass these into the
   ////       object constructor and have it internally track these things?
   customEdit(row, /*App,*/ node) {
      // var selectedData = this.pullRelationValues(row);
      // this._selectedData = selectedData;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("connect");
   }

   formComponentMobile() {
      if (this.settings.linkType == "many") {
         return super.formComponent("mobile-selectmultiple");
      }
      return super.formComponent("mobile-selectsingle");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailconnect",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method getOptions
    * show options list in selectivity
    *
    * @return {Promise}
    */
   async getOptions(whereClause, term, sort, editor) {
      const theEditor = editor;

      if (theEditor) {
         // PREVENT: repeatly refresh data too often
         if (theEditor._getOptionsThrottle) {
            clearTimeout(theEditor._getOptionsThrottle);
            // NOTE: remove variables that reference the Promise and Resolve to let GC cleans up.
            // https://dev.to/xnimorz/js-promises-3-garbage-collection-and-memory-leaks-2oi7?fbclid=IwAR1wqgNz2KqchaM7eRkclR6YWHT01eva4y5IWpnaY0in6BrxmTAtpNCnEXM
            delete theEditor._timeToPullData;
            delete theEditor._getOptionsResolve;
         }
         theEditor._timeToPullData = await new Promise((resolve) => {
            theEditor._getOptionsResolve = resolve;
            theEditor._getOptionsThrottle = setTimeout(() => {
               resolve(true);
            }, 100);
         });
         if (!theEditor._timeToPullData) return;
      }

      return new Promise((resolve, reject) => {
         let haveResolved = false;
         // {bool}
         // have we already passed back a result?

         const respond = (options) => {
            // filter the raw lookup with the provided search term
            options = options.filter((item) => {
               if (item.text.toLowerCase().includes(term.toLowerCase())) {
                  return true;
               }
            });

            if (!haveResolved) {
               haveResolved = true;
               resolve(options);
            } else {
               // if we have already resolved() then .emit() that we have
               // updated "option.data".
               this.emit("option.data", options);
            }
         };

         // Prepare Where clause

         const where = this.AB.cloneDeep(whereClause || {});
         sort = sort || [];

         if (!where.glue) where.glue = "and";

         if (!where.rules) where.rules = [];

         term = term || "";

         // check if linked object value is not define, should return a empty array
         if (!this.settings.linkObject) return [];

         // if options was cached
         // if (this._options != null) return resolve(this._options);

         const linkedObj = this.datasourceLink;

         // System could not found the linked object - It may be deleted ?
         if (linkedObj == null) throw new Error("No linked object");

         const linkedCol = this.fieldLink;

         // System could not found the linked field - It may be deleted ?
         if (linkedCol == null) throw new Error("No linked column");

         // Get linked object model
         const linkedModel = linkedObj.model();

         // M:1 - get data that's only empty relation value
         if (
            this.settings.linkType == "many" &&
            this.settings.linkViaType == "one" &&
            editor?.config?.showAllOptions != true
         ) {
            where.rules.push({
               key: linkedCol.id,
               rule: "is_null",
            });
            // where[linkedCol.columnName] = null;
         }
         // 1:1
         else if (
            this.settings.linkType == "one" &&
            this.settings.linkViaType == "one" &&
            editor?.config?.showAllOptions != true
         ) {
            // 1:1 - get data is not match link id that we have
            if (this.settings.isSource == true) {
               // NOTE: make sure "haveNoRelation" shows up as an operator
               // the value ":0" doesn't matter, we just need 'haveNoRelation' as an operator.
               // newRule[linkedCol.id] = { 'haveNoRelation': 0 };
               where.rules.push({
                  key: linkedCol.id,
                  rule: "have_no_relation",
               });
            }
            // 1:1 - get data that's only empty relation value by query null value from link table
            else {
               where.rules.push({
                  key: linkedCol.id,
                  rule: "is_null",
               });
               // newRule[linkedCol.id] = 'null';
               // where[linkedCol.id] = null;
            }
         }

         const storageID = this.getStorageID(where);

         Promise.resolve()
            .then(async () => {
               // Mar 23, 2023 disabling local storage of options because users
               // were reporting not seeing the correct options list with either
               // new, updated or deleted records that should or should not appear
               return false;
               // Get Local Storage unless xxx->one connected field
               // if (this?.settings?.linkViaType != "one") {
               //    // We store the .findAll() results locally and return that for a
               //    // quick response:
               //    return await this.AB.Storage.get(storageID);
               // }
            })
            .then(async (storedOptions) => {
               if (storedOptions) {
                  // immediately respond with our stored options.
                  this._options = storedOptions;
                  return respond(this._options);
               }
               // Pull linked object data
               let options = function () {
                  return linkedModel.findAll({
                     where: where,
                     sort: sort,
                     populate: false,
                  });
               };

               // placeholder for selected options
               let selected = function () {
                  return new Promise((resolve, reject) => {
                     // empty data array to pass to all()
                     resolve({ data: [] });
                  });
               };

               // we also need to get selected values of xxx->one connections
               // if we are looking at a field in a form we look at linkViaOneValues
               // if we are looking at a grid we are editing we look at theEditor?.config?.value
               if (
                  this?.settings?.linkViaType == "one" &&
                  (this?.linkViaOneValues || theEditor?.config?.value)
               ) {
                  let values = "";
                  // determine if we are looking in a grid or at a form field
                  if (
                     (theEditor?.config?.view == "multicombo" ||
                        theEditor?.config?.view == "combo") &&
                     this?.linkViaOneValues
                  ) {
                     values = this?.linkViaOneValues;
                  } else if (theEditor?.config?.value) {
                     if (Array.isArray(theEditor.config.value)) {
                        values = theEditor?.config?.value.join();
                     } else {
                        values = theEditor?.config?.value;
                     }
                  }
                  let whereRels = {};
                  let sortRels = [];

                  whereRels.glue = "or";
                  whereRels.rules = [];

                  values.split(",").forEach((v) => {
                     whereRels.rules.push({
                        key: "uuid",
                        rule: "equals",
                        value: v,
                     });
                  });
                  selected = function () {
                     return linkedModel.findAll({
                        where: whereRels,
                        sort: sortRels,
                        populate: false,
                     });
                  };
               }
               try {
                  const results = await Promise.all([options(), selected()]);

                  // combine options and selected items and
                  // put the selected options at the top of the list
                  const result = results[1].data.concat(results[0].data);

                  // store results in _options
                  this._options = result.data || result || [];

                  // populate display text
                  (this._options || []).forEach((opt) => {
                     opt.text = linkedObj.displayData(opt);
                     opt.value = opt.text;
                  });

                  // 8/10/2023 - We are not actually using this (see line 338) - If we need to store
                  // user data in local storage we should encrypt it.
                  // cache options if not a xxx->one connection
                  // if (this?.settings?.linkViaType != "one") {
                  //    this.AB.Storage.set(storageID, this._options);
                  // }
                  return respond(this._options);
               } catch (err) {
                  this.AB.notify.developer(err, {
                     context:
                        "ABFieldConnect:getOptions(): unable to retrieve options from server",
                     field: this.toObj(),
                     where,
                  });

                  haveResolved = true;
                  throw err;
               }
            });
      });
   }

   getStorageID(where) {
      return `${this.id}-${JSON.stringify(where)}`;
   }

   async clearStorage(where) {
      const storageID = this.getStorageID(where);
      await this.AB.Storage.set(storageID, null);
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               if (itemObj && itemObj.id) {
                  vals.push(itemObj.id);
               } else {
                  vals.push(val);
               }
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            } else {
               vals.push(value);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         if (!value) {
            return [];
         } else {
            let returnVals = [];
            let vals = value.split(",");
            vals.forEach((val) => {
               returnVals.push(this.getItemFromVal(val));
            });
            return returnVals;
         }
      } else {
         let item = this.getItemFromVal(value);
         return item;
      }
   }

   getAndPopulateOptions(editor, options, field, form) {
      if (!editor) return Promise.resolve([]);

      const theEditor = editor;
      // if editor has options and is xxx->one store the options on the field
      if (
         this?.settings?.linkViaType == "one" &&
         theEditor.getValue() &&
         !field.linkViaOneValues
      ) {
         field.linkViaOneValues = theEditor.getValue();
      }

      // if we are filtering based off another selectivity's value we
      // need to do it on fetch each time because the value can change
      // copy the filters so we don't add to them every time there is a change
      const combineFilters = options?.filters
         ? Object.assign({}, options.filters)
         : { glue: "and", rules: [] };

      if (options?.filterByConnectValues) {
         const parseFilterByConnectValues = (conditions, values, depth = 0) => {
            const valuesByDepth = values.filter((e) => e?.depth === depth);

            return [
               ...conditions.rules.map((e) => {
                  if (e.glue)
                     return {
                        glue: e.glue,
                        rules: parseFilterByConnectValues(e, values, depth + 1),
                     };

                  const value = valuesByDepth.filter(
                     (ef) => ef.key === e.key && ef.value === e.value
                  )[0];

                  if (!value) return e;

                  const $parentField = value?.filterValue?.config.id
                     ? $$(value.filterValue.config.id)
                     : null;

                  if (!$parentField)
                     throw Error(
                        "Some parent field's view components don't exist"
                     );

                  const parentValue = value?.filterValue
                     ? $parentField.getValue() ?? ""
                     : "";

                  let newVal = "";

                  if (parentValue) {
                     if (value.filterColumn) {
                        const filterField = field.object.fieldByID(
                           value.filterValue.config.dataFieldId
                        );
                        let valItem;

                        // When options does not load yet, then pull select value from DC
                        if (!filterField._options?.length) {
                           const linkedField =
                              (form.datacollection.datasource?.fields(
                                 (f) =>
                                    f.id == value.value ||
                                    f.columnName == value.value
                              ) ?? [])[0];

                           if (linkedField) {
                              // Get values from DC
                              const formVals = form.datacollection?.getCursor();

                              valItem =
                                 formVals[linkedField.relationName()] ??
                                 formVals[value.value];
                           }
                        } else {
                           valItem = filterField.getItemFromVal(parentValue);
                        }

                        if (valItem) {
                           newVal = valItem[value.filterColumn];
                        } else {
                           newVal = parentValue;
                        }
                     } else {
                        newVal = parentValue;
                     }
                  }

                  return {
                     key: e.key,
                     rule: "equals",
                     value: newVal,
                  };
               }),
            ];
         };

         combineFilters.rules = parseFilterByConnectValues(
            combineFilters,
            options.filterByConnectValues
         );
      }

      if (!this.handlerOptionData) {
         this.handlerOptionData = (data) => {
            if (theEditor.$destructed) {
               this.removeListener("option.data", this.handlerOptionData);
               return;
            }
            this.populateOptions(theEditor, data, field, form, true);
         };
      }

      // try to make sure we don't continually add up listeners.
      this.removeListener("option.data", this.handlerOptionData).once(
         "option.data",
         this.handlerOptionData
      );

      return new Promise((resolve, reject) => {
         this.getOptions(
            combineFilters,
            "",
            options?.sort ?? "",
            theEditor
         ).then((data) => {
            this.populateOptions(theEditor, data, field, form, true);
            resolve(data);
         });
      });
   }

   populateOptions(theEditor, data, field, form, addCy) {
      if (theEditor == null || theEditor.$destructed) return;

      theEditor.blockEvent();
      theEditor.getList().clearAll();
      theEditor.getList().define("data", data);
      if (addCy) {
         this.populateOptionsDataCy(theEditor, field, form);
      }
      if (theEditor.getValue?.() && data?.length) {
         let currVal = theEditor.getValue();
         // in a multiselect environment, the current val can be an encoded string:
         // "id1,id2".  Break this into an array:
         if (field.linkType() == "many" && typeof currVal == "string") {
            currVal = currVal.split(",");
         }
         if (!Array.isArray(currVal)) {
            currVal = [currVal];
         }

         let selectedVals = [];
         currVal.forEach((cVal) => {
            // Check exists item
            const isExists = data.some((d) => d.id == cVal);

            if (isExists) {
               selectedVals.push(cVal);
            }

            // if we couldn't find it by it's .id, then check to see
            // if there is a custom index (.indexField  .indexField2)
            // that does match.
            // Select option item from custom index value
            if (
               !isExists &&
               field.isConnection &&
               (field.indexField || field.indexField2)
            ) {
               const selectedItem = data.filter(
                  (d) =>
                     d[field.indexField?.columnName ?? ""] == cVal ||
                     d[field.indexField2?.columnName ?? ""] == cVal
               )[0];

               if (selectedItem) selectedVals.push(selectedItem.id);
            }
         });

         theEditor.setValue(selectedVals);
      }
      theEditor.unblockEvent();
   }

   populateOptionsDataCy(theEditor, field, form) {
      if (theEditor?.$destructed) return;

      // Add data-cy attributes
      if (theEditor?.getList) {
         if (!theEditor.getPopup) return;
         var popup = theEditor.getPopup();
         if (!popup) return;
         theEditor.getList().data.each((option) => {
            if (!option) return;
            var node = popup.$view.querySelector(
               "[webix_l_id='" + option.id + "']"
            );
            if (!node) return;
            node.setAttribute(
               "data-cy",
               `${field.key} options ${option.id} ${field.id} ${form?.id}`
            );
         });
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this._options || [];
      if (options.length > 0) {
         for (let i = 0; i < options.length; i++) {
            if (
               this.indexField &&
               options[i][this.indexField.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else if (
               this.indexField2 &&
               options[i][this.indexField2.object.PK()] == val
            ) {
               item = options[i];
               break;
            } else {
               if (
                  options[i].id == val ||
                  options[i].value == val ||
                  options[i][this.indexField?.columnName ?? ""] == val ||
                  options[i][this.indexField2?.columnName ?? ""] == val
               ) {
                  item = options[i];
                  break;
               }
            }
         }
         return item;
      } else {
         return "";
      }
   }

   getValue(item) {
      let val = item.getValue();
      var multiselect = this.settings.linkType == "many";
      if (multiselect) {
         let vals = [];
         if (val) {
            val = val.split(",");
            val.forEach((record) => {
               // make sure we are returning the .uuid values and
               // not full {Record} values.
               vals.push(
                  this.getRelationValue(item.getList().getItem(record), {
                     forUpdate: true,
                  })
               );
            });
         }

         return vals;
      } else {
         if (val) {
            // return just the .uuid and not the full {Record}
            return this.getRelationValue(item.getList().getItem(val));
         } else {
            return "";
         }
      }
   }

   setValue(item, rowData) {
      if (!item) return;
      // if (AB.isEmpty(rowData)) return; removed because sometimes we will
      // want to set this to empty
      let val = this.pullRelationValues(rowData);
      // put in current values as options so we can display them before
      // the rest of the options are fetched when field is clicked
      if (item.getList && item.getList().count() == 0) {
         if (this.settings.linkType !== "one" && !Array.isArray(val)) {
            val = [val];
         }

         const $list = item.getList();

         $list.define("data", val);
         $list.refresh();
      }

      // try to prevent form flicker:
      // Only reset the value if the value changes:
      let currVal = item.getValue();
      let newVal = Array.isArray(val)
         ? val
              .map(
                 (e) =>
                    this.getRelationValue(e, { forUpdate: true }) ??
                    e.id ??
                    e.uuid ??
                    e
              )
              .join(",")
         : this.getRelationValue(val, { forUpdate: true }) ??
           val.id ??
           val.uuid ??
           val;
      if (currVal != newVal) {
         item.setValue(newVal);
      }
   }

   /**
    * @method pullRecordRelationValues
    *
    * On the Web client, we want our returned relation values to be
    * ready for Webix objects that require a .text and .value field.
    *
    * @param {*} row
    * @return {array}
    */
   pullRecordRelationValues(record) {
      var selectedData = [];

      var data = record;
      var linkedObject = this.datasourceLink;

      if (data && linkedObject) {
         // if this select value is array
         if (Array.isArray(data)) {
            selectedData = data.map(function (d) {
               // display label in format
               if (d) {
                  d.text = d.text || linkedObject.displayData(d);
                  d.value = d.text;
               }

               return d;
            });
         } else if (data.id || data.uuid) {
            selectedData = data;
            selectedData.text =
               selectedData.text || linkedObject.displayData(selectedData);
            selectedData.value = selectedData.text;
         }
      }

      return selectedData;
   }

   warningsEval() {
      super.warningsEval();

      var linkField = this.fieldLink;
      if (!linkField) {
         this.warningsMessage(
            `is unable to find linked field[${this.settings.linkColumn}]`,
            {
               linkColumn: this.settings.linkColumn,
            }
         );
      }

      let linkObj = this.datasourceLink;
      if (!linkObj) {
         this.warningsMessage(
            `is unable to find linked object[${this.settings.linkObject}]`,
            {
               linkObject: this.settings.linkObject,
            }
         );
      }
   }
};


/***/ }),

/***/ 4637:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldDate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldDateCore = __webpack_require__(/*! ../../core/dataFields/ABFieldDateCore */ 36009);

module.exports = class ABFieldDate extends ABFieldDateCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // if (this.settings.includeTime)
      // config.editor = "datetime";
      // else
      config.editor = this.AB.Account?.language() == "th" ? "thaidate" : "date";

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.rules.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("mobile-date");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "mobile-date",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   dateToString(dateFormat, dateData) {
      return webix.Date.dateToStr(dateFormat)(dateData);
   }

   // Overwrite core.format to use webix locales.
   format(rowData) {
      if (!window.webixLocale) return super.format(rowData);
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }
      const dateObj = this.AB.rules.toDate(d);

      const dateFormat = this.settings.dateFormat;
      // @const {int} dateFormat AB Date Format
      // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy

      // Return longdate if option 4 or 5
      if (dateFormat >= 4) {
         return webix.i18n.longDateFormatStr(dateObj);
      } else {
         return webix.i18n.dateFormatStr(dateObj);
      }
   }
};


/***/ }),

/***/ 85690:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldDateTime.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldDateTimeCore = __webpack_require__(/*! ../../core/dataFields/ABFieldDateTimeCore */ 32965);

module.exports = class ABFieldDateTime extends ABFieldDateTimeCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldDate
   columnHeader(options) {
      const config = super.columnHeader(options);

      // Ignore date
      if (this.settings.dateFormat == 1) {
         config.editor = "time";
      } else {
         config.editor =
            this.AB.Account?._config?.languageCode == "th"
               ? "thaidatetime"
               : "datetime";
      }

      // allows entering characters in datepicker input, false by default
      config.editable = true;

      // NOTE: it seems that the default value is a string in ISO format.

      //// NOTE: webix seems unable to parse ISO string into => date here.
      // config.map = '(date)#'+this.columnName+'#';   // so don't use this.

      config.template = (row) => {
         if (row.$group) return row[this.columnName];

         return this.format(row);
      };

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      config.editFormat = (d) => {
         // this routine needs to return a Date() object for the editor to work with.

         if (d == "" || d == null) {
            return "";
         }

         // else retun the actual ISO string => Date() value
         return this.AB.rules.toDate(d);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("datepicker");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "datepicker",
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent("mobile-datetime");

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "mobile-datetime",
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   // Overwrite core.format to use webix locales.
   format(rowData) {
      if (!window.webixLocale) return super.format(rowData);
      const d = this.dataValue(rowData);

      if (d == "" || d == null) {
         return "";
      }
      const dateObj = this.AB.rules.toDate(d);

      const dateFormat = this.settings.dateFormat;
      // @const {int} dateFormat AB Date Format
      // 1 - ignore, 2 - dd/mm/yyyy, 3 - mm/dd/yyyy, 4 - M D, yyyy, 5 - D M, yyyy
      const timeToStr = webix.Date.dateToStr(this.getTimeFormat());

      if (dateFormat >= 4) {
         return `${webix.i18n.longDateFormatStr(dateObj)} ${timeToStr(
            dateObj
         )}`;
      } else {
         return `${webix.i18n.dateFormatStr(dateObj)} ${timeToStr(dateObj)}`;
      }
   }
};


/***/ }),

/***/ 75922:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldEmail.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldEmailCore = __webpack_require__(/*! ../../core/dataFields/ABFieldEmailCore */ 95905);

module.exports = class ABFieldEmail extends ABFieldEmailCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldBoolean
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "mobile-email",
            settings: {},
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 72408:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldFile.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldFileCore = __webpack_require__(/*! ../../core/dataFields/ABFieldFileCore */ 34921);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldFile extends ABFieldFileCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related file.
    */
   async destroy() {
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (!this.id) {
            resolve();
            return;
         }

         // Ask the user what to do about the existing file:
         webix.confirm({
            title: L("Keep Files?"),
            message: L("Do you want to keep the files referenced by {0}?", [
               this.label,
            ]),
            callback: async (result) => {
               // update this setting so the server can respond correctly in
               // ABFieldFile.migrateDrop()
               this.settings.removeExistingData = result ? 0 : 1;

               try {
                  await this.save();

                  // TODO: a reminder that you still got alot on the server to do!
                  webix.alert({
                     title: "!! TODO !!",
                     text: "Tell a Developer to actually pay attention to this!",
                  });

                  // now the default .destroy()
                  await super.destroy();

                  resolve();
               } catch (err) {
                  reject(err);
               }
            },
         });
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFile
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);

      config.editor = false;

      const editable = options.editable;

      // populate our default template:
      config.template = (obj) => {
         if (obj.$group) return this.dataValue(obj);

         const fileDiv = [
            '<div class="ab-file-data-field" style="float: left;">',
            '<div class="webix_view ab-file-holder">',
            '<div class="webix_template">',
            this.fileTemplate(obj, editable),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return fileDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }
      options = options || {};

      let typesList = [];
      let maximumSize = 0;

      if (this.settings.limitFileType && this.settings.fileType) {
         typesList = this.settings.fileType.split(",");
      }

      if (this.settings.limitFileSize && this.settings.fileSize) {
         maximumSize = this.settings.fileSize;
      }

      // 		// safety check:
      // 		// webix seems to crash if you specify a .container that doesn't exists:
      // 		// Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-file-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         // 			// use a webix component for displaying the content.
         // 			// do this so I can use the progress spinner

         const webixContainer = webix.ui({
            view: "template",
            container: parentContainer,

            template: this.fileTemplate(row, options.editable),

            borderless: true,
            width: 160,
            height: 60,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         // 			////
         // 			//// Prepare the Uploader
         // 			////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";

            return;
         }

         const url = this.urlUpload(true);

         const uploader = webix.ui({
            view: "uploader",
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: function (item) {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = typesList;
                  if (acceptableTypes && acceptableTypes != "") {
                     const type = item.type.toLowerCase();
                     if (acceptableTypes.indexOf(type) == -1) {
                        webix.message(
                           L("Only [{0}] files are supported", [
                              acceptableTypes.join(", "),
                           ])
                        );
                        return false;
                     }
                  }

                  //verify file size
                  //Convert to MegaBytes
                  if (maximumSize > 0) {
                     const acceptableSizes = maximumSize * 1000000;
                     if (item.size > acceptableSizes) {
                        webix.message(
                           L("Maximum file size is {0}MB", [maximumSize])
                        );
                        return false;
                     }
                  }

                  // start progress indicator
                  webixContainer.showProgress({
                     type: "icon",
                     delay: 2000,
                  });
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  // this.showFile(idBase, response.data.uuid);

                  const values = {};
                  values[this.columnName] = {};
                  values[this.columnName].uuid = response.data.uuid;
                  values[this.columnName].filename = item.name;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldFile.onFileUpload(): Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error loading file"), {
                     message:
                        "ABFieldFile:onFileUploadError(): Error loading file",
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // open file upload dialog when's click
         node.addEventListener("click", (e) => {
            if (e.target.className.indexOf("delete-image") > -1) {
               this.deleteFile = true;
            }
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node) {
      if (this.deleteFile == true) {
         // remove the property because it is only needed to prevent the file dialog from showing
         delete this.deleteFile;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: "",
            text: L("Are you sure you want to remove this file?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};

                  values[this.columnName] = {};

                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if ($$(node) && $$(node).updateItem)
                           $$(node).updateItem(row.id, values);
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           message:
                              "ABFieldFile:customEdit(): Error updating our entry.",
                           row: row,
                           values: values,
                        });
                     }
                  }
                  // update value in the form component
                  else {
                     this.setValue($$(node), values);
                  }
               }
            },
         });
      } else {
         const rowData = this.dataValue(row);
         if (!rowData || !rowData.uuid) {
            const uploaderId = node.dataset["uploaderId"],
               uploader = $$(uploaderId);

            if (uploader && uploader.fileDialog)
               uploader.fileDialog({ rowid: row.id });
         }
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   formComponentMobile() {
      return super.formComponent("mobile-file");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailcustom",
         };
      };

      return detailComponentSetting;
   }

   //File Template

   fileTemplate(obj, editable) {
      let iconDisplay = "";
      let fileDisplay = "display:none;";
      let fileURL = "";

      let value = "";
      let name = "";

      const rowData = this.dataValue(obj);
      if (rowData) {
         value = rowData.uuid;
         name = rowData.filename;
      }

      if (value && name) {
         iconDisplay = "display:none;";
         fileDisplay = "";
         fileURL = "/file/" + value;
      }

      const html = [
         `<div class="file-data-field-icon" style="text-align: center; height: inherit; display: table-cell; vertical-align: middle; border: 2px dotted #CCC; background: #FFF; border-radius: 10px; font-size: 11px; line-height: 13px; padding: 0 10px; ${iconDisplay}"><i class="fa fa-file fa-2x" style="opacity: 0.6; font-size: 32px; margin-top: 3px; margin-bottom: 5px;"></i>${
            editable ? `<br/>${L("Drag and drop or click here")}` : ""
         }</div>`,
         `<div class="file-data-field-name" style=" width:100%; height:100%; position:relative; "><a target="_blank" href="${fileURL}">${
            name || ""
         }</a>${
            editable
               ? `<a style="${fileDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
               : ""
         }</div>`,
      ].join("");

      return html;
   }

   getValue(item, rowData) {
      const file = item.$view.querySelector(".file-data-field-name");
      const fileLink = file.querySelector("a");

      return {
         uuid: file.getAttribute("file-uuid"),
         filename: fileLink.innerHTML,
      };
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const fileicon = domNode.querySelector(".file-data-field-icon");
      if (fileicon) fileicon.style.display = val && val.uuid ? "none" : "block";

      const file = domNode.querySelector(".file-data-field-name");
      if (file) {
         const fileDeleteIcon = file.querySelector(".ab-delete-photo");
         if (fileDeleteIcon)
            fileDeleteIcon.style.display = val && val.uuid ? "block" : "none";

         file.style.display = val && val.uuid ? "block" : "none";
         if (val && val.uuid) file.setAttribute("file-uuid", val.uuid);
         else file.removeAttribute("file-uuid");

         const fileLink = file.querySelector("a");
         const fileURL = "/file/" + (val ? val.uuid : "");
         fileLink.href = fileURL;
         fileLink.innerHTML = val ? val.filename : "";
      }
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = true) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }

   /**
    * @method urlFile
    * return the url to use to reference the file by it's id.
    * @param {string} id uuid reference of this file.
    * @return {string}
    */
   urlFile(id) {
      return `/file/${id}`;
   }
};


/***/ }),

/***/ 37900:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldFormula.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldFormulaCore = __webpack_require__(/*! ../../core/dataFields/ABFieldFormulaCore */ 75193);

module.exports = class ABFieldFormula extends ABFieldFormulaCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         if (rowData.$group) return rowData[this.columnName];

         return this.format(rowData);
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return super.formComponent("fieldreadonly");
   }

   formComponentMobile() {
      return super.formComponent("mobile-fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 15884:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldImage.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldImageCore = __webpack_require__(/*! ../../core/dataFields/ABFieldImageCore */ 93355);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldImage extends ABFieldImageCore {
   constructor(values, object) {
      super(values, object);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @function destroy
    * On a destroy operation, ask if the user wants to keep the related images.
    */
   async destroy() {
      return new Promise((resolve, reject) => {
         // verify we have been .save()d before:
         if (this.id) {
            // Ask the user what to do about the existing images:
            webix.confirm({
               title: L("Keep Images?"),
               message: L("Do you want to keep the images referenced by {0}?", [
                  this.label,
               ]),
               callback: async (result) => {
                  // update this setting so the server can respond correctly in
                  // ABFieldImage.migrateDrop()
                  this.settings.removeExistingData = result ? 0 : 1;

                  try {
                     await this.save();

                     // TODO: a reminder that you still got alot on the server to do!
                     webix.alert({
                        title: "!! TODO !!",
                        text: "ABFieldImage.destroy(): Tell a Developer to actually pay attention to this!",
                     });

                     await super.destroy();

                     resolve();
                  } catch (err) {
                     reject(err);
                  }
               },
            });
         } else {
            resolve(); // nothing to do really
         }
      });
   }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj, formId) {
      // if formId is passed the field is in a form view not a grid and
      // we won't have the obj and each time this
      // field is in a form it will conflict with the last one rendered
      if (formId) {
         return `${this.columnName.replace(/ /g, "_")}-${formId}-image`;
      } else {
         return `${this.columnName.replace(/ /g, "_")}-${obj.id}-image`;
      }
   }

   // return the grid column header definition for this instance of ABFieldImage
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;

      config.editor = false; // 'text';  // '[edit_type]'   for your unique situation
      // config.sort   = 'string' // '[sort_type]'   for your unique situation

      let containerHeight = "100%";
      let imageHeight = "100%";
      let width = "100%";
      let imageSrcHeight = "100%";
      if (field.settings.useWidth) {
         config.width = field.settings.imageWidth || 100;
         const heightVal =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight + 20
               : 80;
         containerHeight = `${heightVal}px`;
         width = `${field.settings.imageWidth || 100}px`;
         imageHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 80;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight =
            field.settings.useHeight && field.settings.imageHeight
               ? field.settings.imageHeight
               : 60;
         imageSrcHeight = `${imageSrcHeight}px`;
      } else if (options.width) {
         config.width = options.width || 100;
         width = `${options.width || 100}px`;
         imageHeight = options.width;
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = options.width;
         imageSrcHeight = `${imageSrcHeight}px`;
      }
      if (
         field.settings.useHeight &&
         field.settings.imageHeight &&
         field.settings.imageHeight != "NaN"
      ) {
         config.height = field.settings.imageHeight || 0;
         containerHeight = parseInt(config.height) + 20;
         containerHeight = `${containerHeight}px`;
         imageHeight = parseInt(config.height);
         imageHeight = `${imageHeight}px`;
         imageSrcHeight = parseInt(config.height);
         imageSrcHeight = `${imageSrcHeight}px`;
      }

      const editable = options.editable;

      // populate our default template:
      // debugger;
      config.template = (obj) => {
         if (obj.$group) return obj[this.columnName];

         const widthStyle = `width: ${width}; height: ${containerHeight}`;

         const imageStyle = `width: ${width}; height: ${imageHeight}`;

         const imgDiv = [
            `<div class="ab-image-data-field" style="float: left; ${widthStyle}">`,
            `<div class="webix_view ab-image-holder" style="${imageStyle}">`,
            '<div class="webix_template">',
            this.imageTemplate(obj, {
               editable: editable,
               height: imageSrcHeight,
               width: width,
            }),
            "</div>",
            "</div>",
            "</div>",
         ].join("");

         return imgDiv;
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    * @param {object} options - {
    * 		editable {Bool}   where or not this field is currently editable
    * 		formId {string}   the id of the presenting form if any
    * }
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      // safety check:
      // webix seems to crash if you specify a .container that doesn't exists:
      // Note: when the template is first created, we don't have App.unique()
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.innerHTML = "";
         // parentContainer.id = idBase;	// change it to the unique one.

         let imgHeight = 0;
         if (this.settings.useHeight) {
            imgHeight = parseInt(this.settings.imageHeight) || imgHeight;
         }

         let imgWidth = 0;
         if (this.settings.useWidth) {
            imgWidth = parseInt(this.settings.imageWidth) || imgWidth;
         }

         if (options.height) imgHeight = options.height;

         if (options.width) imgWidth = options.width;
         //// TODO: actually pay attention to the height and width when
         //// displaying the images.

         // use a webix component for displaying the content.
         // do this so I can use the progress spinner
         const webixContainer = webix.ui({
            view: "template",
            css: "ab-image-holder",
            // id: ids.container,
            container: parentContainer,

            template: this.imageTemplate(row, {
               editable: options.editable,
               height: imgHeight ? imgHeight + "px" : 0,
               width: imgWidth ? imgWidth + "px" : 0,
            }),

            borderless: true,
            height: imgHeight,
            width: imgWidth,
         });
         webix.extend(webixContainer, webix.ProgressBar);

         ////
         //// Prepare the Uploader
         ////

         if (!options.editable) {
            const domNode = parentContainer.querySelector(".delete-image");
            if (domNode) domNode.style.display = "none";
            return;
         }

         const url = this.urlUpload();

         const uploader = webix.ui({
            view: "uploader",
            // id:ids.uploader,
            apiOnly: true,
            upload: url,
            inputName: "file",
            multiple: false,
            status: (f) => {
               if (f.percent) {
                  webixContainer.hideProgress();
                  webixContainer.showProgress({
                     type: "top",
                     position: f.percent / 100,
                  });
               }
            },
            // formData:{
            // 	appKey:application.name,
            // 	permission:actionKey,
            // 	isWebix:true,
            // 	imageParam:'upload'
            // },
            on: {
               // when a file is added to the uploader
               onBeforeFileAdd: (item) => {
                  node.classList.remove("webix_invalid");
                  node.classList.remove("webix_invalid_cell");

                  // verify file type
                  const acceptableTypes = [
                     "jpg",
                     "jpeg",
                     "bmp",
                     "png",
                     "gif",
                     "webp",
                  ];
                  const type = item.type.toLowerCase();
                  if (acceptableTypes.indexOf(type) == -1) {
                     webix.message(
                        L("Only [{0}] images are supported", [
                           acceptableTypes.join(", "),
                        ])
                     );
                     return false;
                  }
                  this.uploadInProgress = true;
                  // Display the image from local file
                  var reader = new FileReader();
                  reader.onload = (e) => {
                     this.showImage(null, node, e.target.result);
                     webixContainer.showProgress({
                        type: "top",
                        delay: 2000,
                     });
                  };
                  reader.readAsDataURL(item.file);
               },

               // when upload is complete:
               onFileUpload: async (item, response) => {
                  webixContainer.hideProgress();
                  this.showImage(response.data.uuid, node);
                  this.uploadInProgress = false;

                  const values = {};
                  values[this.columnName] = response.data.uuid;

                  // update just this value on our current object.model
                  if (row.id) {
                     try {
                        await this.object.model().update(row.id, values);

                        // update the client side data object as well so other data changes won't cause this save to be reverted
                        if (
                           $$(node) &&
                           $$(node).getItem &&
                           $$(node).getItem(row.id)
                        ) {
                           $$(node).updateItem(row.id, values);
                        } else {
                           // if you scroll the table the connection to the datatable is lost so we need to find it again
                           const dataTable =
                              document.querySelector(".webix_dtable");
                           if ($$(dataTable) && $$(dataTable).getItem(row.id))
                              $$(dataTable).updateItem(row.id, values);
                        }
                     } catch (err) {
                        node.classList.add("webix_invalid");
                        node.classList.add("webix_invalid_cell");

                        this.AB.notify.developer(err, {
                           context:
                              "ABFieldImage.onFileUpload(): model.update(): error updating our entry",
                           field: this.toObj(),
                           row,
                           values,
                        });
                     }
                  }

                  // update value in the form component
                  this.setValue($$(node), values);
               },

               // if an error was returned
               onFileUploadError: (item, response) => {
                  this.AB.notify.developer(new Error("Error uploading image"), {
                     context: "ABFieldImage. uploader. onFileUploadError():",
                     field: this.toObj(),
                     response,
                  });
                  webixContainer.hideProgress();
               },
            },
         });
         uploader.addDropZone(webixContainer.$view);

         // store upload id into html element (it will be used in .customEdit)
         node.dataset["uploaderId"] = uploader.config.id;

         // if we are working in a datagrid we need to add a click event to
         // check if the user is clicking on the delete button
         if (node.className == "webix_cell") {
            node.addEventListener("click", (e) => {
               if (e.target.className.indexOf("delete-image") > -1) {
                  this.deleteImage = true;
               }
            });
         }
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, id, evt) {
      if (
         (evt && evt.target.className.indexOf("delete-image") > -1) ||
         this.deleteImage
      ) {
         delete this.deleteImage;
         if (!row.removeDefaultImage) {
            row.removeDefaultImage = [];
         }
         row.removeDefaultImage[this.columnName] = true;

         // Ask the user if they really want to delete the photo
         webix.confirm({
            title: L("Are you sure you want to remove this image?"),
            callback: async (result) => {
               const confirmDelete = result ? 1 : 0;
               if (confirmDelete) {
                  // update just this value on our current object.model
                  const values = {};
                  values[this.columnName] = ""; // removing the reference to the image here

                  try {
                     await this.object.model().update(row.id, values);

                     // update the client side data object as well so other data changes won't cause this save to be reverted
                     if ($$(node) && $$(node).updateItem)
                        $$(node).updateItem(row.id, values);

                     // update value in the form component
                     this.setValue($$(node), values);
                  } catch (err) {
                     node.classList.add("webix_invalid");
                     node.classList.add("webix_invalid_cell");

                     this.AB.notify.developer(err, {
                        context:
                           "ABFieldImage: customEdit(): Error updating our entry",
                        field: this.toObj(),
                        row: row,
                        values: values,
                     });
                  }
               }
            },
         });
      } else {
         const uploaderId = node.dataset["uploaderId"],
            uploader = $$(uploaderId);

         if (uploader && uploader.fileDialog)
            uploader.fileDialog({ rowid: row.id });
      }

      return false;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("fieldcustom");
   }

   formComponentMobile() {
      return super.formComponent("mobile-image");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailimage",
         };
      };

      return detailComponentSetting;
   }

   imageTemplate(obj, options) {
      options = options || {};
      options.height = options.height || "100%";
      options.width = options.width || "100%";

      // deault view is icon:
      let iconDisplay = "";
      let imageDisplay = "display:none;";
      let imageURL = "";

      let value = "";
      let isRemoveDefaultImage = false;
      if (obj[this.columnName]) {
         value = obj[this.columnName];
      }
      if (obj.removeDefaultImage) {
         if (obj.removeDefaultImage[this.columnName]) {
            isRemoveDefaultImage = obj.removeDefaultImage[this.columnName];
         }
      }

      if (value) {
         iconDisplay = "display:none;";
         imageDisplay = "";
         imageURL = `background-image:url('${this.urlImage(value)}');`;
      } else {
         if (this.settings.useDefaultImage && !isRemoveDefaultImage) {
            iconDisplay = "display:none;";
            imageDisplay = "";
            imageURL = `background-image:url('${this.urlImage(
               this.settings.defaultImageUrl
            )}');`;
         }
      }

      let html = [
         `<div class="image-data-field-icon" style="${iconDisplay}">#drag#</div>` +
            `<div class="image-data-field-image" style="${imageDisplay} height:${options.height}; ${imageURL}">#remove#</div>`,
      ].join("");

      html = html.replace(
         "#drag#",
         options.editable
            ? `<div>${L("Drag and drop or click here")}</div>`
            : ""
      );
      html = html.replace(
         "#remove#",
         options.editable
            ? `<a style="${imageDisplay}" class="ab-delete-photo" href="javascript:void(0);"><i class="fa fa-times delete-image"></i></a>`
            : ""
      );

      return html;
   }

   showImage(uuid, node, url) {
      const parentContainer = node.querySelector(".ab-image-holder");
      if (parentContainer) {
         parentContainer.querySelector(".image-data-field-icon").style.display =
            "none";
         const image = parentContainer.querySelector(".image-data-field-image");
         image.style.display = "";
         image.style.backgroundImage = `url('${url ?? this.urlImage(uuid)}')`;
         image.setAttribute("image-uuid", uuid);
      }
   }

   getValue(item, rowData) {
      const image = item.$view.querySelector(".image-data-field-image");
      return image.getAttribute("image-uuid");
   }

   setValue(item, rowData) {
      if (!item) return;

      const domNode = item.$view;
      if (!domNode) return;

      let val = null;
      if (rowData) {
         val = this.dataValue(rowData);

         // if (val == null) {
         // 	// assume they just sent us a single value
         // 	val = rowData;
         // }
      }

      const imageIcon = domNode.querySelector(".image-data-field-icon");
      if (imageIcon) imageIcon.style.display = val ? "none" : "";

      const image = domNode.querySelector(".image-data-field-image");
      if (image) {
         const imageDeleteIcon = image.querySelector(".ab-delete-photo");
         if (imageDeleteIcon)
            imageDeleteIcon.style.display = val ? "block" : "none";

         image.style.display = val ? "block" : "none";

         if (val) {
            image.style.backgroundImage = `url('${this.urlImage(val)}')`;
            image.setAttribute("image-uuid", val);
         } else {
            image.removeAttribute("image-uuid");
         }
      }
   }

   /**
    * @method toBase64
    *
    * @param {Object} rowData
    *
    * @return {Promise} - {
    * 		data: string,
    * 		width: number,
    * 		height: number
    * }
    */
   toBase64(rowData) {
      return new Promise((resolve, reject) => {
         if (!rowData[this.columnName]) return resolve(null);

         const img = new Image();
         img.crossOrigin = "Anonymous";
         img.onerror = function (err) {
            reject(err);
         };
         img.onload = function () {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const dataURL = canvas.toDataURL();
            const imageData = {
               data: dataURL,
               width: img.width,
               height: img.height,
            };
            resolve(imageData);
         };

         img.src = this.urlImage(rowData[this.columnName]);
      });
   }

   /**
    * @method urlImage()
    * return the url to use to reference the image by it's id.
    * @param {string} id
    *        the file.uuid reference of this image.
    * @return {string}
    */
   urlImage(id) {
      return `/file/${id}`;
   }

   /**
    * @method urlUpload()
    * return the url for uploading a file.
    * When used in a webix widget, the response is different than our normal
    * API, so we can pass in a param to indicate a response compatible with
    * webix.
    * @param {bool} isWebix
    *        Is this url being used by a webix component?
    * @return {string}
    */
   urlUpload(isWebix = true) {
      return `/file/upload/${this.object.id}/${this.id}/${isWebix ? "1" : "0"}`;
   }

   /**
    * @method isValidData
    * Parse through the given data and return an error if this field's
    * data seems invalid.
    * @param {obj} data  a key=>value hash of the inputs to parse.
    * @param {OPValidator} validator  provided Validator fn
    * @return {array}
    */
   isValidData(data, validator) {
      super.isValidData(data, validator);
      if (this.uploadInProgress)
         validator.addError(this.columnName, L("Image still uploading"));
   }

   rotateLeft(imgFile) {
      return this.AB.Network.put({
         url: `/image/rotate/${imgFile}?direction=left`,
      });
   }

   rotateRight(imgFile) {
      return this.AB.Network.put({
         url: `/image/rotate/${imgFile}?direction=right`,
      });
   }
};


/***/ }),

/***/ 4213:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldJson.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldJsonCore = __webpack_require__(/*! ../../core/dataFields/ABFieldJsonCore */ 97972);

module.exports = class ABFieldJson extends ABFieldJsonCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldJson
   columnHeader(options) {
      const config = super.columnHeader(options);

      // config.editor = null; // read only for now
      config.editor = "text";
      config.css = "textCell";

      // when called by ABViewFormCustom, will need a .template() fn.
      // currently we don't need to return anything so ...
      config.template = () => "";

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // read-only for now
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "json",
            settings: {
               type: "string",
            },
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      return super.formComponent("mobile-fieldreadonly");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   setValue(item, rowData) {
      super.setValue(item, rowData, "");
      if (item) {
         item.config.value = rowData[this.columnName];
      }
   }

   /**
    * @method formCleanData()
    * Review the data a form is about to submit and change/remove it as
    * appropriate.
    * @param {obj} rowData
    *        The {data} a form has collected and is about to save.
    * @return {undefined}
    */
   formCleanData(rowData) {
      let val = rowData[this.columnName];
      if (val === "") {
         // "" isn't a valid json value, so just remove the data and
         // let the DB handle the default value.
         delete rowData[this.columnName];
      }
   }
};


/***/ }),

/***/ 34963:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldList.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldListCore = __webpack_require__(/*! ../../core/dataFields/ABFieldListCore */ 86430);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldList extends ABFieldListCore {
   constructor(values, object) {
      super(values, object);

      // this._Selectivity = new ABFieldSelectivity(values, object);
   }

   ///
   /// Instance Methods
   ///

   save() {
      return super.save().then(() => {
         // Now we want to clear out any entries that had values == to item removed from our list:
         if (this.pendingDeletions.length) {
            const model = this.object.model();

            if (this.settings.isMultiple == true) {
               // find all the entries that have one of the deleted values:
               // use Promise to prevent issues with data being loaded before it is deleted on client side
               return new Promise((resolve, reject) => {
                  let numDone = 0;
                  let numToDo = 0;

                  model
                     .findAll({})
                     .then((list) => {
                        list = list.data || list;

                        // for each list item
                        list.forEach((item) => {
                           if (Array.isArray(item[this.columnName])) {
                              // get fields not in pendingDeletions
                              let remainingFields = item[
                                 this.columnName
                              ].filter((i) => {
                                 return (
                                    this.pendingDeletions.indexOf(i.id) == -1
                                 );
                              });

                              if (
                                 remainingFields.length !=
                                 item[this.columnName].length
                              ) {
                                 numToDo++;

                                 // update value to new field list
                                 if (remainingFields.length == 0) {
                                    remainingFields = "";
                                 }
                                 const value = {};
                                 value[this.columnName] = remainingFields;
                                 model.update(item.id, value).then(() => {
                                    // if ($$(node) && $$(node).updateItem)
                                    //    $$(node).updateItem(value.id, value);
                                    numDone++;
                                    if (numDone >= numToDo) {
                                       resolve();
                                    }
                                 });
                              }
                           }
                        });
                        if (numToDo == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            } else {
               // find all the entries that have one of the deleted values:
               const where = {};
               where[this.columnName] = this.pendingDeletions;
               return new Promise((resolve, reject) => {
                  let numDone = 0;

                  model
                     .findAll(where)
                     .then((list) => {
                        // make sure we just work with the { data:[] } that was returned
                        list = list.data || list;

                        // for each one, set the value to ''
                        // NOTE: jQuery ajax routines filter out null values, so we can't
                        // set them to null. :(
                        // const numDone = 0;
                        const value = {};
                        value[this.columnName] = "";

                        list.forEach((item) => {
                           model.update(item.id, value).then(() => {
                              numDone++;
                              if (numDone >= list.length) {
                                 resolve();
                              }
                           });
                        });
                        if (list.length == 0) {
                           resolve();
                        }
                     })
                     .catch(reject);
               });
            }
         }
      });
   }

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldList
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;
      const App = field.AB._App;

      var formClass = "";
      var placeHolder = "";
      if (options.editable) {
         formClass = " form-entry";
         placeHolder = `<span style='color: #CCC; padding: 0 5px;'>${L(
            "Select item"
         )}</span>`;
      }
      var isRemovable = options.editable && !this.settings.required;

      config.editFormat = (value) => {
         return this.editFormat(value);
      };
      config.editParse = (value) => {
         return this.editParse(value);
      };

      config.template = (rowData) => {
         let selectedData = rowData[this.columnName];
         if (selectedData == null) return "";
         if (this.settings.isMultiple) {
            selectedData = _getSelectedOptions(this, rowData);
         }
         var values = [];
         values.push('<div class="badgeContainer">');
         let hasCustomColor = "";
         let optionHex = "";
         if (
            selectedData &&
            Array.isArray(selectedData) &&
            selectedData.length
         ) {
            selectedData.forEach((val) => {
               if (this.settings.hasColors && val.hex) {
                  hasCustomColor = "hascustomcolor";
                  optionHex = `background: ${val.hex};`;
               }
               if (val.text) {
                  values.push(
                     `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'><span>${val.text}</span><!-- span data-uuid="${val.id}" class="webix_multicombo_delete" role="button" aria-label="Remove item"></span --></div>`
                  );
               }
            });
            if (selectedData.length > 1) {
               values.push(
                  `<span class="webix_badge selectivityBadge">${selectedData.length}</span>`
               );
            }
         } else if (selectedData) {
            let selectedObj = selectedData;
            if (typeof selectedData == "string") {
               selectedObj = this.getItemFromVal(selectedData);
            }
            if (!selectedObj) return "";
            if (this.settings.hasColors && selectedObj.hex) {
               hasCustomColor = "hascustomcolor";
               optionHex = `background: ${selectedObj.hex};`;
            }
            if (selectedObj.text) {
               let clear = "";
               if (options.editable && !this.settings.required) {
                  clear = `<span class="webix_multicombo_delete clear-combo-value" role="button" aria-label="Remove item"></span>`;
               }
               values.push(
                  `<div style="${optionHex}" class='webix_multicombo_value ${hasCustomColor}'>${clear}<span class="ellip">${selectedObj.text}</span></div>`
               );
            }
         } else {
            return "";
         }
         values.push("</div>");
         return values.join("");
      };
      config.editor = this.settings.isMultiple ? "multiselect" : "combo";
      config.suggest = {
         button: true,
         data: this.settings.options.map(function (opt) {
            return {
               id: opt.id,
               value: opt.text,
               hex: opt.hex,
            };
         }),
      };
      if (this.settings.isMultiple) {
         config.suggest.view = "checksuggest";
      }

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      if (!node.querySelector) return;

      var clearButton = node.querySelector(
         ".selectivity-single-selected-item-remove"
      );
      if (clearButton) {
         clearButton.addEventListener("click", (e) => {
            e.stopPropagation();
            var values = {};
            values[this.columnName] = "";
            this.object
               .model()
               .update(row.id, values)
               .then(() => {
                  // update the client side data object as well so other data changes won't cause this save to be reverted
                  $$(node)?.updateItem?.(row.id, values);
               })
               .catch((err) => {
                  node.classList.add("webix_invalid");
                  node.classList.add("webix_invalid_cell");

                  this.AB.notify.developer(err, {
                     message:
                        "ABFieldList:customDisplay(): Error updating our entry.",
                     row: row,
                     values: "",
                     field: this.toObj(),
                  });
               });
         });
      }
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customEdit(row, App, node) {
   //    return super.customEdit(row, App, node);
   // }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "selectmultiple" : "selectsingle",
            settings: {
               options: this.settings.options.map(function (opt) {
                  return {
                     id: opt.id,
                     value: opt.text,
                     hex: opt.hex,
                  };
               }),
            },
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple
               ? "mobile-selectmultiple"
               : "mobile-selectsingle",
            settings: {
               options: this.settings.options.map(function (opt) {
                  return {
                     id: opt.id,
                     value: opt.text,
                     hex: opt.hex,
                  };
               }),
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: this.settings.isMultiple ? "detailtext" : "detailtext",
         };
      };

      return detailComponentSetting;
   }

   editFormat(value) {
      if (!value) return "";
      let vals = [];
      if (Array.isArray(value)) {
         value.forEach((val) => {
            if (typeof val == "object") {
               vals.push(val.id);
            } else {
               let itemObj = this.getItemFromVal(val);
               vals.push(itemObj.id);
            }
         });
      } else {
         if (typeof value == "object") {
            vals.push(value.id);
         } else {
            let itemObj = this.getItemFromVal(value);
            if (itemObj && itemObj.id) {
               vals.push(itemObj.id);
            }
         }
      }
      return vals.join();
   }

   editParse(value) {
      if (this.settings.isMultiple) {
         let returnVals = [];
         let vals = value.split(",");
         vals.forEach((val) => {
            returnVals.push(this.getItemFromVal(val));
         });
         return returnVals;
      } else {
         return value;
      }
   }

   getItemFromVal(val) {
      let item;
      let options = this.options();
      if (options.length > 1) {
         options.forEach((option) => {
            if (option.id == val) {
               item = option;
               return false;
            }
         });
         return item;
      } else {
         return "";
      }
   }

   getValue(item, rowData) {
      return this.editParse(item.getValue());
   }

   getSelectedOptions(field, rowData = {}) {
      let result = [];
      if (rowData[this.columnName] != null) {
         result = rowData[this.columnName];
      } else if (rowData) {
         if (Array.isArray(rowData)) {
            result = rowData;
         } else {
            result.push(rowData);
         }
      }
      if (result.length) {
         if (typeof result == "string") result = JSON.parse(result);

         // Pull text with current language
         if (this.settings) {
            result = (this.settings.options || []).filter((opt) => {
               return (
                  (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                     .length > 0
               );
            });
         }
      }

      return result;
   }

   setValue(item, rowData) {
      if (!item) return;

      if (this.settings.isMultiple) {
         // do we need anything here?
      } else {
         super.setValue(item, rowData);
      }
   }
};

// == Private methods ==
function _getSelectedOptions(field, rowData = {}) {
   let result = [];
   if (rowData[field.columnName] != null) {
      result = rowData[field.columnName];

      if (typeof result == "string") result = JSON.parse(result);

      // Pull text with current language
      if (field.settings) {
         result = (field.settings.options || []).filter((opt) => {
            return (
               (result || []).filter((v) => (opt.id || opt) == (v.id || v))
                  .length > 0
            );
         });
      }
   }

   return result;
}


/***/ }),

/***/ 26331:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldLongText.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldLongTextCore = __webpack_require__(/*! ../../core/dataFields/ABFieldLongTextCore */ 81213);

module.exports = class ABFieldLongText extends ABFieldLongTextCore {
   constructor(values, object) {
      super(values, object);

      /*
		{
			settings: {
				default: 'string',
				supportMultilingual: 1/0
			}
		}
		*/
   }

   ///
   /// Instance Methods
   ///

   isValid() {
      const validator = super.isValid();

      // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

      return validator;
   }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldLongText
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text"; // '[edit_type]'   for your unique situation
      // config.sort = 'string' // '[sort_type]'   for your unique situation
      config.template = (obj, common, value, col, ind) => {
         return (value || "").toString().replace(/[<]/g, "&lt;");
      };

      return config;
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "multiple",
            },
         };
      };

      return formComponentSetting;
   }

   formComponentMobile() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "mobile-textbox",
            settings: {
               type: "multiple",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
};


/***/ }),

/***/ 18799:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldNumber.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldNumberCore = __webpack_require__(/*! ../../core/dataFields/ABFieldNumberCore */ 42686);

let INIT_EDITOR = false;
// {bool} INIT_EDITOR
// Transition code between previous Framework and current.
// we now need to wait until webix is declared or accessible globally.

module.exports = class ABFieldNumber extends ABFieldNumberCore {
   constructor(values, object) {
      if (!INIT_EDITOR) {
         // NOTE: if you need a unique [edit_type] by your returned config.editor above:
         webix.editors.number = webix.extend(
            {
               // TODO : Validate number only
            },
            webix.editors.text
         );
         INIT_EDITOR = true;
      }
      super(values, object);
   }

   ///
   /// Working with Actual Object Values:
   ///

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   // return the grid column header definition for this instance of ABFieldNumber
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "number"; // [edit_type] simple inline editing.

      config.format = (d) => {
         const rowData = {};
         rowData[this.columnName] = d;

         return this.format(rowData);
      };

      return config;
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("numberbox");
   }

   formComponentMobile() {
      return super.formComponent("mobile-numberbox");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 53317:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldSelectivity.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABFieldSelectivity
 *
 * An ABFieldSelectivity defines a single unique Field/Column in a ABObject.
 *
 */

const ABField = __webpack_require__(/*! ./ABField */ 34117);

const defaultSettings = {
   allowClear: true,
   removeOnly: false,
   readOnly: false,
   showDropdown: true,
   placeholder: "",
   multiple: false,
};

const ABFieldSelectivityDefaults = {
   key: "selectivity",
};

module.exports = class ABFieldSelectivity extends ABField {
   constructor(values, object, fieldDefaults = ABFieldSelectivityDefaults) {
      super(values, object, fieldDefaults);
   }

   // return the default values for this DataField
   static defaults() {
      return {
         key: "selectivity",
         icon: "bars",
         menuName: "",
         description: "",
      };
   }

   selectivityRender(domNode, settings, App, row) {
      if (domNode == null) return;

      const cypress = settings.dataCy || "";
      domNode.setAttribute("data-cy", cypress);

      // setting up our specific settings:
      settings = settings || {};
      for (const dv in defaultSettings) {
         if (settings[dv] === null) {
            settings[dv] = null;
         } else {
            settings[dv] = settings[dv] || defaultSettings[dv];
         }
      }

      if (
         settings.multiple &&
         settings.items &&
         settings.data &&
         settings.data.length
      ) {
         settings.data.forEach(function (d) {
            settings.items.map(function (i) {
               if (i.id == d.id) d.hex = i.hex;
            });
         });
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      } else if (settings["data"] == null || settings["data"] == "") {
         settings["data"] = this.prepareData([], settings.multiple);
      } else {
         settings["data"] = this.prepareData(
            settings["data"],
            settings.multiple
         );
      }

      // store the field id so we can look it up on click events later
      settings["field"] = this.id;

      // Prevent render selectivity duplicate
      if (domNode.selectivity != null) {
         // Refresh selectivity settings
         domNode.selectivity.setOptions(settings);

         return;
      }

      settings.element = domNode;

      // Render selectivity
      let selectivityInput;
      if (settings.multiple) {
         if (settings.isUsers) {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: #eee !important; color: #666 !important; box-shadow: inset 0px 1px 1px #333;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
								<i class="fa fa-user" style="color: #666; opacity: 0.6;"></i> 
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
								${!settings.isLabelHidden ? options.text : ""}
								${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove" style="color: #333;"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         } else {
            settings.templates = {
               multipleSelectedItem: function (options) {
                  return `<span class="selectivity-multiple-selected-item ${
                     options.highlighted ? " highlighted" : ""
                  }"
								style="background-color: ${options.hex} !important;"
								data-item-id="${options.uuid}" data-field-id="${settings.field}">
                        ${
                           settings.editPage
                              ? ` <a class="selectivity-multiple-selected-item-edit"><i class="fa fa-edit"></i></a>`
                              : ""
                        }
                        ${
                           settings.additionalText
                              ? settings.additionalText(options)
                              : ""
                        }
                        ${!settings.isLabelHidden ? options.text : ""}
                        ${
                           options.removable
                              ? ` <a class="selectivity-multiple-selected-item-remove"><i class="fa fa-remove"></i></a>`
                              : ""
                        }
							</span>`;
               },
            };
         }
         selectivityInput = new Selectivity.Inputs.Multiple(settings);

         domNode.selectivity = selectivityInput;
         this.selectivitySetBadge(domNode, App, row);
      } else {
         settings.templates = {
            singleSelectedItem: function (options) {
               return `<span class="selectivity-single-selected-item" data-item-id="${
                  options.uuid
               }" data-field-id="${settings.field}">
							${
                        settings.editPage
                           ? '<a class="selectivity-single-selected-item-edit"><i class="fa fa-edit"></i></a>'
                           : ""
                     }
                     ${
                        settings.additionalText
                           ? settings.additionalText(options)
                           : ""
                     }
                     ${!settings.isLabelHidden ? options.text : ""}
                     ${
                        options.removable
                           ? '<a class="selectivity-single-selected-item-remove"><i class="fa fa-remove"></i></a>'
                           : ""
                     }
						</span>`;
            },
         };

         selectivityInput = new Selectivity.Inputs.Single(settings);
         domNode.selectivity = selectivityInput;
      }

      if (settings.editPage) {
         const trigerEditPageEvent = () => {
            const instance = this;
            const editMenus = document.querySelectorAll(
               ".selectivity-single-selected-item-edit, .selectivity-multiple-selected-item-edit"
            );
            for (let i = 0; i < editMenus.length; i++) {
               const eMenu = editMenus[i];
               if (eMenu && !eMenu.__hasClickEvent) {
                  eMenu.addEventListener(
                     "click",
                     function (e) {
                        e.stopPropagation();
                        e.preventDefault();

                        const parentElm = this.parentElement;
                        if (!parentElm) return;

                        const rowId = parentElm.getAttribute("data-item-id");
                        if (!rowId) return;

                        const fieldId = parentElm.getAttribute("data-field-id");
                        if (!fieldId) return;

                        const thisField = instance.object.fieldByID(fieldId);
                        if (!thisField) return;

                        thisField.emit("editPage", rowId);
                     },
                     true
                  );
                  eMenu.__hasClickEvent = true;
               }
            }
         };

         setTimeout(() => {
            trigerEditPageEvent();

            domNode.addEventListener("change", () => {
               trigerEditPageEvent();
            });
         }, 500);
      }

      // WORKAROUND : remove caret icon of selectivity
      if (settings.readOnly) {
         const caretElems = domNode.getElementsByClassName("selectivity-caret");
         for (let i = 0; i < caretElems.length; i++) {
            const caretElm = caretElems[i];
            if (caretElm) {
               caretElm.parentNode.removeChild(caretElm);
            }
         }
      }

      // remember our settings values
      this.selectivitySettings = settings;
   }

   selectivityGet(domNode) {
      if (domNode && domNode.selectivity) {
         if (this.selectivitySettings && this.selectivitySettings.multiple) {
            // on a multiple select, return an array of results, or empty array
            return domNode.selectivity.getData() || [];
         } else {
            // if a single select, return the object or null
            return domNode.selectivity.getData() || null;
         }
      } else {
         if (this.selectivitySettings && this.selectivitySettings.multiple)
            return [];
         else return null;
      }
   }

   selectivitySet(domNode, data) {
      if (!domNode || !domNode.selectivity) return;

      data = this.prepareData(data, domNode.selectivity.options.multiple);

      if (
         (Array.isArray(data) && data[0]) || // Check Array
         (data && data.id)
      )
         // Check a object
         domNode.selectivity.setData(data);
      else domNode.selectivity.clear();
   }

   selectivityDestroy(domNode) {
      if (domNode && domNode.selectivity) {
         domNode.selectivity.destroy();

         delete domNode.selectivity;
      }
   }

   prepareData(data, multiple = true) {
      if (!data && multiple) {
         return [];
      } else if (multiple && data && Array.isArray(data) && data.length == 0) {
         return [];
      } else if (!multiple && data && Array.isArray(data) && data.length == 0) {
         return null;
      } else if (!data && !multiple) {
         return null;
      }

      if (typeof data == "string" && data.length > 0) {
         try {
            data = JSON.parse(data);
         } catch (e) {
            // not JSON parsable, so convert to
            data = { id: data, text: data };
         }
      }

      // if single select, then it should be object
      if (!multiple && Array.isArray(data)) {
         data = data[0];
      } else if (multiple && !Array.isArray(data)) {
         data = [data];
      }

      // check to see if id is present on each item
      if (multiple) {
         data.forEach((d) => {
            if (!d.id && d.uuid) {
               d.id = d.uuid;
            }
         });
      } else {
         if (!data.id && data.uuid) data.id = data.uuid;
      }

      if (data == null && multiple) {
         data = [];
      }

      return data;
   }

   selectivitySetBadge(domNode) {
      if (!domNode.clientHeight) return;
      const innerHeight = domNode.clientHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         let values = [];
         if (domNode && domNode.selectivity)
            values = domNode.selectivity.getValue() || [];

         count = values.length;
         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               // v2: this just updated the $height property for this row
               // we don't do that anymore:
               // anchor.addEventListener("click", function () {
               //    App.actions.onRowResizeAuto(row.id, innerHeight);
               // });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }
};


/***/ }),

/***/ 2163:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldString.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldStringCore = __webpack_require__(/*! ../../core/dataFields/ABFieldStringCore */ 5254);

module.exports = class ABFieldString extends ABFieldStringCore {
   // constructor(values, object) {
   //    super(values, object);

   // {
   //   settings: {
   // 	  default: 'string',
   // 	  supportMultilingual: 1/0
   //   }
   // }

   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldString
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = "text";
      config.css = "textCell";
      // config.sort   = 'string'
      config.template = (obj, common, value /* , col, ind */) => {
         // if this isn't part of a group header display the default format
         if (!obj.$group) {
            return (value || "").toString().replace(/[<]/g, "&lt;");
         } else {
            return "";
         }
      };

      return config;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      // if no default value is set, then don't insert a value.
      if (!values[this.columnName]) {
         // Set default string
         if (this.settings.default) {
            if (this.settings.default.indexOf("{uuid}") >= 0) {
               values[this.columnName] = this.AB.uuid();
            } else {
               values[this.columnName] = this.settings.default;
            }
         }
      }
   }

   /**
    * @method formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   // formComponentMobile() {
   //    // NOTE: what is being returned here needs to mimic an ABView CLASS.
   //    // primarily the .common() and .newInstance() methods.
   //    const formComponentSetting = super.formComponent();

   //    // .common() is used to create the display in the list
   //    formComponentSetting.common = () => {
   //       return {
   //          key: "mobile-textbox",
   //          settings: {
   //             type: "single",
   //          },
   //       };
   //    };

   //    return formComponentSetting;
   // }

   /**
    * @method formComponentMobile
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponentMobile() {
      // NOTE: what is being returned here needs to mimic an ABView CLASS.
      // primarily the .common() and .newInstance() methods.
      const formComponentSetting = super.formComponent();

      // .common() is used to create the display in the list
      formComponentSetting.common = () => {
         return {
            key: "mobile-textbox",
            settings: {
               type: "single",
            },
         };
      };

      return formComponentSetting;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }

   /**
    * @method setValue
    * this function uses for form component and mass update popup
    * to get value of fields that apply custom editor
    *
    * @param {Object} item - Webix element
    * @param {Object} rowData - data of row
    *
    * @return {Object}
    */
   setValue(item, rowData) {
      super.setValue(item, rowData, "");
   }
};


/***/ }),

/***/ 81961:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldTextFormula.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldTextFormulaCore = __webpack_require__(/*! ../../core/dataFields/ABFieldTextFormulaCore */ 35756);

module.exports = class ABFieldTextFormula extends ABFieldTextFormulaCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   // return the grid column header definition for this instance of ABFieldTextFormula
   columnHeader(options) {
      const config = super.columnHeader(options);

      config.editor = null; // read only
      config.css = "textCell";
      config.template = (rowData) => {
         // if this isn't part of a group header display the default format
         if (!rowData.$group) {
            return this.format(rowData);
         } else {
            return "";
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(/* row, App, node, options */) {}

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      // not support in the form widget
      return null;
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtext",
         };
      };

      return detailComponentSetting;
   }
};


/***/ }),

/***/ 10567:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldTreeCore = __webpack_require__(/*! ../../core/dataFields/ABFieldTreeCore */ 8514);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABFieldTree extends ABFieldTreeCore {
   // constructor(values, object) {
   //    super(values, object);
   // }

   ///
   /// Instance Methods
   ///

   // isValid() {
   //    const validator = super.isValid();

   //    // validator.addError('columnName', L('ab.validation.object.name.unique', 'Field columnName must be unique (#name# already used in this Application)').replace('#name#', this.name) );

   //    return validator;
   // }

   ///
   /// Working with Actual Object Values:
   ///

   idCustomContainer(obj) {
      return `${this.columnName.replace(/ /g, "_")}-${obj.id}-tree`;
   }

   // return the grid column header definition for this instance of ABFieldTree
   columnHeader(options) {
      options = options || {};

      const config = super.columnHeader(options);
      const field = this;

      let formClass = "";
      let placeHolder = "";
      if (options.isForm) {
         formClass = " form-entry";
         placeHolder =
            "<span style='color: #CCC; padding: 0 5px;'>" +
            L("Select items") +
            "</span>";
      }

      const width = options.width;

      config.template = (obj) => {
         if (obj.$group) return obj[field.columnName];

         const branches = [];
         let selectOptions = this.AB.cloneDeep(field.settings.options);
         selectOptions = new webix.TreeCollection({
            data: selectOptions,
         });

         let values = obj;
         if (obj[field.columnName] != null) {
            values = obj[field.columnName];
         }

         selectOptions.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  selectOptions.data.each(function (par) {
                     if (selectOptions.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values'>";
         if (branches.length == 0) {
            nodeHTML += placeHolder;
         } else {
            branches.forEach(function (item) {
               nodeHTML +=
                  '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
                  myHex +
                  ' !important;">' +
                  item +
                  "</span>";
            });
         }
         nodeHTML += "</div>";

         // field.setBadge(node, App, row);

         if (width) {
            return (
               '<div style="margin-left: ' +
               width +
               'px;" class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         } else {
            return (
               '<div class="list-data-values' +
               formClass +
               '">' +
               nodeHTML +
               "</div>"
            );
         }
      };

      return config;
   }

   /*
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customDisplay(row, App, node, options) {
      // sanity check.
      if (!node) {
         return;
      }

      options = options || {};

      const field = this;

      if (options.isForm) {
         if (!row || row.length == 0) {
            node.innerHTML =
               "<div class='list-data-values form-entry'><span style='color: #CCC; padding: 0 5px;'>" +
               L("Select items") +
               "</span></div>";
            return;
         }

         const branches = [];
         options = this.AB.cloneDeep(field.settings.options);
         options = new webix.TreeCollection({
            data: options,
         });

         let values = row;
         if (row[field.columnName] != null) {
            values = row[field.columnName];
         }

         options.data.each(function (obj) {
            if (
               typeof values.indexOf != "undefined" &&
               values.indexOf(obj.id) != -1
            ) {
               let html = "";

               let rootid = obj.id;
               while (this.getParentId(rootid)) {
                  options.data.each(function (par) {
                     if (options.data.getParentId(rootid) == par.id) {
                        html = par.text + ": " + html;
                     }
                  });
                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";
         let nodeHTML = "";
         nodeHTML += "<div class='list-data-values form-entry'>";
         branches.forEach(function (item) {
            nodeHTML +=
               '<span class="selectivity-multiple-selected-item rendered" style="background-color:' +
               myHex +
               ' !important;">' +
               item +
               "</span>";
         });
         nodeHTML += "</div>";

         node.innerHTML = nodeHTML;
      }

      field.setBadge(node, App, row);
   }

   /*
    * @function customEdit
    *
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *					unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   customEdit(row, App, node, component) {
      const idBase = App.unique(this.idCustomContainer(row));
      const idPopup = `${idBase}-popup`;
      const idTree = `${idBase}-tree`;
      const view = $$(node);
      const field = this;
      const parentComponent = component;
      let values = {};
      let firstRender = true;

      function getValues(field, row) {
         let values = {};
         if (
            typeof field != "undefined" &&
            typeof field.columnName != "undefined" &&
            typeof row[field.columnName] != "undefined"
         ) {
            values = row[field.columnName];
         }
         return values;
      }

      function populateTree(field, vals) {
         values = getValues(field, vals);

         const $Tree = $$(idTree);
         $Tree.blockEvent(); // prevents endless loop

         const options = field.AB.cloneDeep(field.settings.options);
         $Tree.clearAll();
         $Tree.parse(options);
         $Tree.refresh();
         $Tree.uncheckAll();
         $Tree.openAll();

         if (values != null && values.length) {
            values.forEach(function (id) {
               if ($Tree.exists(id)) {
                  $Tree.checkItem(id);
                  const dom = $Tree.getItemNode(id);
                  dom.classList.add("selected");
               }
            });
         }
         $Tree.unblockEvent();
      }

      if ($$(idPopup)) {
         $$(idPopup).show();
         populateTree(this, row);
      } else {
         webix
            .ui({
               id: idPopup,
               view: "popup",
               width: 500,
               height: 400,
               on: {
                  onShow: () => {
                     if (firstRender == true) populateTree(this, row);

                     firstRender = false;
                  },
               },
               body: {
                  id: idTree,
                  view: "tree",
                  css: "ab-data-tree",
                  template: function (obj, common) {
                     return (
                        "<label>" +
                        common.checkbox(obj, common) +
                        "&nbsp;" +
                        obj.text +
                        "</label>"
                     );
                  },
                  on: {
                     onItemCheck: async function (id, value, event) {
                        const dom = this.getItemNode(id);
                        const tree = this;
                        if (value == true) {
                           dom.classList.add("selected");
                        } else {
                           dom.classList.remove("selected");
                        }
                        // works for the same-level children only
                        // except root items
                        if (this.getParentId(id)) {
                           tree.blockEvent(); // prevents endless loop

                           let rootid = id;
                           while (this.getParentId(rootid)) {
                              rootid = this.getParentId(rootid);
                              if (rootid != id) tree.uncheckItem(rootid);
                           }

                           this.data.eachSubItem(rootid, function (item) {
                              if (item.id != id) tree.uncheckItem(item.id);
                           });

                           tree.unblockEvent();
                        } else {
                           tree.blockEvent(); // prevents endless loop
                           this.data.eachSubItem(id, function (obj) {
                              if (obj.id != id) tree.uncheckItem(obj.id);
                           });
                           tree.unblockEvent();
                        }
                        const values = {};
                        values[field.columnName] = $$(idTree).getChecked();

                        if (row.id) {
                           // pass null because it could not put empty array in REST api
                           if (values[field.columnName].length == 0)
                              values[field.columnName] = "";

                           try {
                              await field.object.model().update(row.id, values);

                              // update the client side data object as well so other data changes won't cause this save to be reverted
                              if (view && view.updateItem) {
                                 view.updateItem(row.id, values);
                              }
                           } catch (err) {
                              node.classList.add("webix_invalid");
                              node.classList.add("webix_invalid_cell");

                              this.AB.notify.developer(err, {
                                 message:
                                    "ABFieldTree:onItemClick(): Error updating our entry.",
                                 row: row,
                                 values: values,
                              });
                           }
                        } else {
                           const rowData = {};
                           rowData[field.columnName] = $$(idTree).getChecked();

                           field.setValue($$(parentComponent.ui.id), rowData);
                        }
                     },
                  },
               },
            })
            .show(node, {
               x: -7,
            });
      }
      return false;
   }

   setBadge(domNode, row) {
      const field = this;
      domNode = domNode.querySelector(".list-data-values");
      const innerHeight = domNode.scrollHeight;
      const outerHeight = domNode.parentElement.clientHeight;
      if (innerHeight - outerHeight > 5) {
         let count = 0;
         if (row[field.columnName] && row[field.columnName].length)
            count = row[field.columnName].length;
         else count = 0;

         if (count > 1) {
            const badge = domNode.querySelector(
               ".webix_badge.selectivityBadge"
            );
            if (badge != null) {
               badge.innerHTML = count;
            } else {
               const anchor = document.createElement("A");
               anchor.href = "javascript:void(0);";
               anchor.addEventListener("click", function (event) {
                  // v2: this was just saving the new height to the
                  // field properties. We don't do that anymore:
                  // App.actions.onRowResizeAuto(row.id, innerHeight);
                  event.stopPropagation();
               });
               const node = document.createElement("SPAN");
               const textnode = document.createTextNode(count);
               node.classList.add("webix_badge", "selectivityBadge");
               node.appendChild(textnode);
               anchor.appendChild(node);
               domNode.appendChild(anchor);
            }
         }
      }
   }

   /*
    * @funciton formComponent
    * returns a drag and droppable component that is used on the UI
    * interface builder to place form components related to this ABField.
    *
    * an ABField defines which form component is used to edit it's contents.
    * However, what is returned here, needs to be able to create an instance of
    * the component that will be stored with the ABViewForm.
    */
   formComponent() {
      return super.formComponent("formtree");
   }

   detailComponent() {
      const detailComponentSetting = super.detailComponent();

      detailComponentSetting.common = () => {
         return {
            key: "detailtree",
         };
      };

      return detailComponentSetting;
   }

   getValue(item, rowData) {
      let values = {};
      values = item.getValues();
      return values;
   }

   setValue(item, rowData) {
      if (!item) return false;

      const val = rowData[this.columnName] || [];

      item.setValues(val);
      // get dom
      const dom = item.$view.querySelector(".list-data-values");

      if (!dom) return false;

      // set value to selectivity
      this.customDisplay(val, this.App, dom, {
         editable: true,
         isForm: true,
      });

      setTimeout(function () {
         let height = 33;
         if (dom.scrollHeight > 33) {
            height = dom.scrollHeight;
         }
         item.config.height = height + 5;
         item.resize();
      }, 200);
   }
};


/***/ }),

/***/ 78025:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/dataFields/ABFieldUser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABFieldConnectCore = __webpack_require__(/*! ../../core/dataFields/ABFieldConnectCore */ 63800);
const ABFieldUserCore = __webpack_require__(/*! ../../core/dataFields/ABFieldUserCore */ 58706);

module.exports = class ABFieldUser extends ABFieldUserCore {
   constructor(values, object, fieldDefaults) {
      super(values, object, fieldDefaults);
   }

   ///
   /// Working with Actual Object Values:
   ///

   async save() {
      // Add new
      if (this.id == null) {
         const SiteUser = this.AB.objectUser();
         const Defaults = ABFieldUserCore.defaults();

         this.settings.linkObject = SiteUser.id;
         this.settings.isCustomFK = 1;

         if (this.settings.isMultiple) {
            this.settings.indexField2 = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "many";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         } else {
            this.settings.indexField = Defaults.USERNAME_FIELD_ID;
            this.settings.linkType = "one";
            this.settings.linkViaType = "many";
            this.settings.isSource = 1;
         }

         // TODO: .fieldCustomNew() for saving "local" changes.
         // NOTE: The Object adding this Field sees it's data as a ABFieldUser
         //       connection.
         //       However, the SiteUser will see the data as a ABFieldConnect
         //       connection
         const linkCol = SiteUser.fieldNew({
            key: ABFieldConnectCore.defaults().key,
            columnName: `${this.object.name}_${this.label}`,
            label: this.object.label,
            settings: {
               showIcon: this.settings.showIcon,
               linkObject: this.object.id,
               linkType: this.settings.linkViaType,
               linkViaType: this.settings.linkType,
               isCustomFK: this.settings.isCustomFK,
               indexField: this.settings.indexField,
               indexField2: this.settings.indexField2,
               isSource: 0,
            },
         });

         // // Create definitions of the connected fields
         // // NOTE: skip directly to the ABMLClass.save() to avoid the
         // // migrations caused during the ABField.save() operations.
         // await ABFieldUserCore.prototype.save.call(this);

         // linkCol.settings.linkColumn = this.id;
         // await ABFieldUserCore.prototype.save.call(linkCol);

         // // Update the id value of linked field to connect together
         // this.settings.linkColumn = linkCol.id;
         // await ABFieldUserCore.prototype.save.call(this);

         let newDef = await this.toDefinition().save();
         this.id = newDef.id;

         linkCol.settings.linkColumn = this.id;
         let newLinkDef = await linkCol.toDefinition().save();
         linkCol.id = newLinkDef.id;

         this.settings.linkColumn = linkCol.id;
         await this.toDefinition().save();

         // Add fields to Objects
         await this.object.fieldAdd(this);

         await SiteUser.fieldAdd(linkCol);

         // Create column to DB
         await this.migrateCreate();

         await linkCol.migrateCreate();

         return this;
      } else {
         return super.save();
      }
   }

   // return the grid column header definition for this instance of ABFieldUser

   columnHeader(options) {
      // debugger;
      options = this.setDisplayOptions(options);
      return super.columnHeader(options);
   }

   /**
    * @function customDisplay
    * perform any custom display modifications for this field.
    * @param {object} row is the {name=>value} hash of the current row of data.
    * @param {App} App the shared ui App object useful more making globally
    *             unique id references.
    * @param {HtmlDOM} node  the HTML Dom object for this field's display.
    */
   // customDisplay(row, App, node, options = {}) {
   //    debugger;
   //    options = this.setDisplayOptions(options);
   //
   //    return super.customDisplay(row, App, node, options);
   // }

   setDisplayOptions(options) {
      options = options || {};
      options.editable =
         this.settings.editable != null ? this.settings.editable : true;

      options.isLabelHidden =
         this.settings.isShowUsername != null
            ? !this.settings.isShowUsername
            : false;

      options.additionalText = (opt) => {
         if (!this.settings.isShowProfileImage) return "";

         if (opt.image_id)
            return `<img src='/file/${opt.image_id}' style='border-radius:100%; object-fit: cover; margin: 0 5px 0 -10px;' width='28' height='28' />`;
         else return '<i style="opacity: 0.6;" class="fa fa-user"></i> ';
      };

      return options;
   }

   /**
    * @method defaultValue
    * insert a key=>value pair that represent the default value
    * for this field.
    * @param {obj} values a key=>value hash of the current values.
    */
   defaultValue(values) {
      if (this.settings.isCurrentUser) {
         if (this.settings.isMultiple) {
            values[this.columnName] = [
               {
                  id: this.AB.Account.username(),
                  text: this.AB.Account.username(),
               },
            ];
         } else {
            values[this.columnName] = this.AB.Account.username();
         }
      }
   }

   getValue(item) {
      let val = super.getValue(item);

      if (val) {
         if (typeof val == "string")
            val = val.replace(/ab-current-user/g, this.AB.Account.username());
         else if (Array.isArray(val))
            val = val.map((v) =>
               (v?.username ?? v?.uuid ?? v?.id ?? v)?.replace(
                  /ab-current-user/g,
                  this.AB.Account.username()
               )
            );
      }

      return val;
   }

   setValue(item, rowData) {
      let val = rowData[this.columnName];
      if (val === "") {
         // this means this value isn't set.
         // can we remove this from the data?
         delete rowData[this.columnName];
         super.setValue(item, rowData);
         return;
      }

      if (this.linkType() == "many") {
         // val should be an array.
         if (!Array.isArray(val)) {
            val = [val];
         }
         // if any of those contain "ab-current-user" replace it:
         val = val.map((v) =>
            v == "ab-current-user" ? this.AB.Account.username() : v
         );
      } else {
         // val is a single entry string
         // Select "[Current user]" to update
         if (val == "ab-current-user") val = this.AB.Account.username();
      }

      rowData[this.columnName] = val;

      super.setValue(item, rowData);
   }

   getUsers() {
      return this.AB.Account.userList().map((u) => {
         const result = {
            id: u.username,
            image: u.image_id,
         };

         if (this.settings.isMultiple) {
            result.text = u.username;
         } else {
            result.value = u.username;
         }

         return result;
      });
   }

   getOptions(...params) {
      return super.getOptions(...params).then((options) => {
         // in a ABFieldUser, our options.id elements need to have
         // the username, not the .uuid:
         (options || []).forEach((o) => {
            if (o.username) {
               o.id = o.username;
            }
         });

         return options;
      });
   }

   pullRelationValues(row) {
      let values = super.pullRelationValues(row);

      // remember, our .id == .username
      if (Array.isArray(values)) {
         // prevent any null or undefined:
         values = values.filter((v) => v);
         values = values.map((v) => {
            v.id = v.username || v.id;
            return v;
         });
      } else {
         if (values) {
            values.id = values.username || values.id;
         }
      }

      return values;
   }

   pullRecordRelationValues(record) {
      let data = super.pullRecordRelationValues(record);
      if (Array.isArray(data)) {
         data = data.map((d) => {
            d.id = d.username ?? d.id;
            return d;
         });
      } else {
         data.id = data.username || data.id;
      }

      return data;
   }
};


/***/ }),

/***/ 18315:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobilePage.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobilePageCore = __webpack_require__(/*! ../../core/mobile/ABMobilePageCore */ 73134);

module.exports = class ABMobilePage extends ABMobilePageCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      // check to see if I've been updated, if so, alert my parent:
      this.__Handler_ABDEF_UPDATED = (def) => {
         if (def.id == this.id) {
            this.emit("definition.updated", this);
            this.AB.off("ab.abdefinition.update", this.__Handler_ABDEF_UPDATED);
         }
      };
      this.AB.on("ab.abdefinition.update", this.__Handler_ABDEF_UPDATED);

      // check to see if any of my child pages have been updated and
      // update my defintion of them:
      this.__Handler_DEF_UPDATED = (page) => {
         // create a new Field with the updated def
         var def = this.AB.definitionByID(page.id);
         if (!def) return;

         var newPage = this.pageNew(def);

         // we want to keep the same pageID order:
         var newPages = [];
         this.pages().forEach((pg) => {
            if (pg.id === page.id) {
               newPages.push(newPage);
               return;
            }
            newPages.push(pg);
         });

         this._pages = newPages;

         page.off("definition.updated", this.__Handler_DEF_UPDATED);
      };
      this.pages().forEach((p) => {
         p.on("definition.updated", this.__Handler_DEF_UPDATED);
      });
   }

   /**
    * @method refreshInstance()
    * This returns a NEW instance of a ABMobilePage based upon the latest
    * version of it's Definition.  It also resolves any current listeners
    * this copy currently has and prepare this to discard itself.
    */
   refreshInstance(parent) {
      // create a new Field with the updated def
      var def = this.AB.definitionByID(this.id);
      if (!def) return;

      var newPage = (parent ?? this.parent)?.pageNew(def);

      try {
         // detatch ourself from other emitters:
         this.AB.off("ab.abdefinition.update", this.__Handler_ABDEF_UPDATED);
         this.pages().forEach((pg) => {
            pg.removeAllListeners("definition.updated");
         });
      } catch (e) {
         // debugger;
         console.error(e);
      }

      return newPage;
   }

   warningsEval() {
      super.warningsEval();
      let allViews = this.views();
      if (allViews.length == 0) {
         this.warningsMessage("has no widgets");
      }
      (this.pages() || []).forEach((p) => {
         p.warningsEval();
      });
   }
};


/***/ }),

/***/ 94197:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileView.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewCore.js */ 86501);

module.exports = class ABMobileView extends ABMobileViewCore {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**


   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         "mobile-view",
         "mobile-page",
         // "formpanel",
         // "viewcontainer",
         // // not allowed Detail's widgets
         // "detailcheckbox",
         // "detailcustom",
         // "detailconnect",
         // "detailimage",
         // "detailselectivity",
         // "detailtext",
         // "detailtree",
         // // not allowed Form's widgets
         // "button",
         // "checkbox",
         // "connect",
         // "datepicker",
         // "fieldcustom",
         // "textbox",
         // "numberbox",
         // "selectsingle",
         // "selectmultiple",
         // "formtree",
         // "fieldreadonly",
         // // not allowed Chart's Widgets
         // "pie",
         // "bar",
         // "line",
         // "area",
         // // not allowed Report page
         // "report",
         // "reportPage",
         // "reportPanel",
      ];

      var allComponents = this.application.viewAll();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our sub views
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
};


/***/ }),

/***/ 55957:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewForm.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCore */ 11408);

const ABMobileViewFormButton = __webpack_require__(/*! ./ABMobileViewFormButton */ 85507);

module.exports = class ABMobileViewForm extends ABMobileViewFormCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method refreshDefaultButton()
    * On the ABDesigner once a Form Field is added/removed from a form, we want
    * to make sure the default Form Button is pushed down to the bottom of the
    * list of form Items.
    * @param {obj} ids
    *        The id hash of the webix widgets that show the fields.
    * @return {ABMobileViewFormButton}
    */
   refreshDefaultButton(ids) {
      // If default button is not exists, then skip this
      let defaultButton = this.views(
         (v) => v instanceof ABMobileViewFormButton && v.settings.isDefault
      )[0];

      // Add a default button
      if (defaultButton == null) {
         defaultButton = ABMobileViewFormButton.newInstance(
            this.application,
            this
         );
         defaultButton.settings.isDefault = true;
      }
      // Remove default button from array, then we will add it to be the last item later (.push)
      else {
         this._views = this.views((v) => v.id != defaultButton.id);
      }

      // Calculate position Y of the default button
      let yList = this.views().map((v) => (v.position.y || 0) + 1);
      yList.push(this._views.length || 0);
      yList.push($$(ids.fields).length || 0);
      let posY = Math.max(...yList);

      // Update to be the last item
      defaultButton.position.y = posY;

      // Keep the default button is always the last item of array
      this._views.push(defaultButton);

      return defaultButton;
   }

   warningsEval() {
      super.warningsEval();

      if (!this.settings.dataviewID) {
         this.warningsMessage(`does not have a DataCollection assigned.`);
      } else {
         let DC = this.datacollection;
         if (!DC) {
            this.warningsMessage(
               `references an unknown DataCollection [${this.settings.dataviewID}].`
            );
         }
      }
   }
};


/***/ }),

/***/ 85507:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormButton.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormButtonCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormButtonCore */ 75864);

module.exports = class ABMobileViewFormButton extends (
   ABMobileViewFormButtonCore
) {};


/***/ }),

/***/ 82097:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormCheckbox.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormCheckboxCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCheckboxCore */ 95493);

module.exports = class ABMobileViewFormCheckbox extends (
   ABMobileViewFormCheckboxCore
) {};


/***/ }),

/***/ 89274:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormConnect.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormConnectCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormConnectCore */ 27140);

// const ABViewPropertyAddPage =
//    require("./viewProperties/ABViewPropertyAddPage").default;
// const ABViewPropertyEditPage =
//    require("./viewProperties/ABViewPropertyEditPage").default;

// const ABViewFormConnectPropertyComponentDefaults =
//    ABMobileViewFormConnectCore.defaultValues();

// const ABPopupSort = require("../../../ABDesigner/ab_work_object_workspace_popupSortFields");

// let FilterComponent = null;
// let SortComponent = null;

module.exports = class ABMobileViewFormConnect extends (
   ABMobileViewFormConnectCore
) {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      // Set filter value
      this.__filterComponent = this.AB.filterComplexNew(
         `${this.id}__filterComponent`
      );
      // this.__filterComponent.applicationLoad(application);
      this.__filterComponent.fieldsLoad(
         this.datasource ? this.datasource.fields() : [],
         this.datasource ? this.datasource : null
      );

      this.__filterComponent.setValue(
         this.settings.filterConditions
         /* ??
            ABViewFormConnectPropertyComponentDefaults.filterConditions
         */
      );
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // Does this do anything here?
      // this.addPageTool.fromSettings(this.settings);
      // this.editPageTool.fromSettings(this.settings);
   }

   // static get addPageProperty() {
   //    return ABViewPropertyAddPage.propertyComponent(this.App, this.idBase);
   // }

   // static get editPageProperty() {
   //    return ABViewPropertyEditPage.propertyComponent(this.App, this.idBase);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   // component() {
   //    return new ABViewFormConnectComponent(this);
   // }

   // get addPageTool() {
   //    if (this.__addPageTool == null)
   //       this.__addPageTool = new ABViewPropertyAddPage();

   //    return this.__addPageTool;
   // }

   // get editPageTool() {
   //    if (this.__editPageTool == null)
   //       this.__editPageTool = new ABViewPropertyEditPage();

   //    return this.__editPageTool;
   // }
};


/***/ }),

/***/ 54111:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormCustom.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormCustomCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormCustomCore */ 26720);

module.exports = class ABMobileViewFormCustom extends (
   ABMobileViewFormCustomCore
) {};


/***/ }),

/***/ 32747:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormDate.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormDateCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormDateCore */ 382);

module.exports = class ABMobileViewFormDate extends ABMobileViewFormDateCore {};


/***/ }),

/***/ 24207:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormDatetime.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormDatetimeCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormDatetimeCore */ 26854);

module.exports = class ABMobileViewFormDatetime extends (
   ABMobileViewFormDatetimeCore
) {};


/***/ }),

/***/ 81854:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormEmail.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormEmailCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormEmailCore */ 73630);

module.exports = class ABMobileViewFormEmail extends (
   ABMobileViewFormEmailCore
) {};


/***/ }),

/***/ 57078:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormFile.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormFileCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormFileCore */ 96453);

module.exports = class ABMobileViewFormFile extends ABMobileViewFormFileCore {};


/***/ }),

/***/ 11228:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormFormula.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormFormulaCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormFormulaCore */ 21754);

module.exports = class ABMobileViewFormFormula extends (
   ABMobileViewFormFormulaCore
) {};


/***/ }),

/***/ 79880:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormImage.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormImageCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormImageCore */ 33397);

module.exports = class ABMobileViewFormImage extends (
   ABMobileViewFormImageCore
) {};


/***/ }),

/***/ 21579:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormItem.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormItemCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormItemCore */ 62591);

module.exports = class ABMobileViewFormItem extends ABMobileViewFormItemCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }
   // warningsEval() {
   //    super.warningsEval();
   //    this.warningsMessage(`FormItem Test Warning.`);
   // }
};


/***/ }),

/***/ 80585:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormNumber.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormNumberCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormNumberCore */ 65407);

module.exports = class ABMobileViewFormNumber extends (
   ABMobileViewFormNumberCore
) {};


/***/ }),

/***/ 12767:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormReadonly.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormReadonlyCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormReadonlyCore */ 42847);

module.exports = class ABMobileViewFormReadonly extends (
   ABMobileViewFormReadonlyCore
) {};


/***/ }),

/***/ 32763:
/*!**********************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormSelectMultiple.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormSelectMultipleCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormSelectMultipleCore */ 98438);

module.exports = class ABMobileViewFormSelectMultiple extends (
   ABMobileViewFormSelectMultipleCore
) {};


/***/ }),

/***/ 28131:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormSelectSingle.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormSelectSingleCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormSelectSingleCore */ 61882);

module.exports = class ABMobileViewFormSelectSingle extends (
   ABMobileViewFormSelectSingleCore
) {};


/***/ }),

/***/ 78310:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewFormTextbox.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewFormTextboxCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewFormTextboxCore */ 27200);

module.exports = class ABMobileViewFormTextbox extends (
   ABMobileViewFormTextboxCore
) {
   // warningsEval() {
   //    super.warningsEval();
   //    this.warningsMessage(`${k} references an unknown Page.`);
   // }
};


/***/ }),

/***/ 98534:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewLabel.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewLabelCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewLabelCore */ 52999);
// const ABViewLabelComponent = require("./viewComponent/ABViewLabelComponent");

module.exports = class ABMobileViewLabel extends ABMobileViewLabelCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   // component() {

   //    // return new ABViewLabelComponent(this);
   // }

   warningsEval() {
      super.warningsEval();

      if (!this.text) {
         this.warningsMessage("has no text value set.");
      }
   }
};


/***/ }),

/***/ 76944:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/mobile/ABMobileViewList.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABMobileViewListCore = __webpack_require__(/*! ../../core/mobile/ABMobileViewListCore */ 45334);

module.exports = class ABMobileViewList extends ABMobileViewListCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }
   warningsEval() {
      super.warningsEval();

      ["linkPageAdd", "linkPageDetail"].forEach((k) => {
         if (this.settings[k]) {
            let page = this.application.pageByID(this.settings[k], true);
            if (!page) {
               this.warningsMessage(`${k} references an unknown Page.`);
            }
         }
      });
   }
};


/***/ }),

/***/ 94410:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/process/ABProcessLane.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessLane
 * manages a lane in a Process Diagram.
 *
 * Lanes manage users in the system, and provide a way to lookup a SiteUser.
 */
var ABProcessLaneCore = __webpack_require__(/*! ../../core/process/ABProcessLaneCore */ 71506);

module.exports = class ABProcessLane extends ABProcessLaneCore {
   // constructor(attributes, process, application) {
   //    super(attributes, process, application);
   // }

   ////
   //// Modeler Instance Methods
   ////

   transferParticipantWhereToMe(id) {
      var myParticipant = this.process.elementForDiagramID(id);
      if (myParticipant) {
         // if I haven't already set my where clause, and my Participant
         // has one, then take it:
         if (!this.stashed && myParticipant.stashed) {
            var copyParams = [
               "stashed",
               "useRole",
               "role",
               "useAccount",
               "account",
            ];
            copyParams.forEach((p) => {
               var swap = this[p];
               this[p] = myParticipant[p];
               myParticipant[p] = swap; // ?? do this ??
            });
         }
      }
   }

   /**
    * fromElement()
    * initialize this Lane's values from the given BPMN:Lane
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;

      // on creation, if I have child objects, then move the .where definition
      // from my parent Participant to ME
      if (element.children && element.children.length > 0) {
         if (element.parent && element.parent.type == "bpmn:Participant") {
            this.transferParticipantWhereToMe(element.parent.id);
         }
      } else {
         // this info might just reside in the .parent.children[]
         if (
            element.parent &&
            element.parent.children &&
            element.parent.children.length > 0
         ) {
            element.parent.children.forEach((child) => {
               if (child.type != "bpmn:Lane") {
                  // if child has lanes
                  if (
                     child.businessObject.lanes &&
                     child.businessObject.lanes.length > 0
                  ) {
                     // if lane is me
                     var myLane = child.businessObject.lanes.find((l) => {
                        return l.id == this.diagramID;
                     });
                     if (myLane) {
                        this.transferParticipantWhereToMe(element.parent.id);

                        // tell child I'm it's lane:
                        var objChild = this.process.elementForDiagramID(
                           child.id
                        );
                        if (objChild) {
                           objChild.setLane(this);
                        }
                     }
                  }
               }
            });
         }
      }

      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Lane with information that was relevant
    * from the provided BPMN:Lane
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // if I picked up a new task, inform it I am it's lane:
   }
};


/***/ }),

/***/ 98618:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/process/ABProcessParticipant.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * ABProcessParticipant
 * manages the participant lanes in a Process Diagram.
 *
 * Participants manage users in the system (when there are no lanes defined)
 * and provide a way to lookup a SiteUser.
 */
var ABProcessParticipantCore = __webpack_require__(/*! ../../core/process/ABProcessParticipantCore */ 21500);

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessParticipant extends ABProcessParticipantCore {
   // constructor(attributes, process, AB) {
   //    super(attributes, process, AB);
   // }

   ////
   //// Modeler Instance Methods
   ////

   /**
    * fromElement()
    * initialize this Participant's values from the given BPMN:Participant
    * @param {BPMNParticipant}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Participant with information that was relevant
    * from the provided BPMN:Participant
    * @param {BPMNParticipant}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Participant_185ljkg",
                "width": 958,
                "height": 240,
                "type": "bpmn:Participant",
                "x": -810,
                "y": -2010,
                "order": {
                    "level": -2
                },
               "businessObject": {
                    "$type": "bpmn:Participant",
                    "id": "Participant_185ljkg",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": -810,
                            "y": -2010,
                            "width": 958,
                            "height": 240
                        },
                        "id": "Participant_185ljkg_di",
                        "isHorizontal": true
                    },
                    "processRef": {
                        "$type": "bpmn:Process",
                        "id": "Process_0x3sul5"
                    }
                }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      if (defElement.children) {
         var laneIDs = [];
         defElement.children.forEach((c) => {
            if (c.type == "bpmn:Lane") {
               laneIDs.push(c.id);
            }
         });
         this.laneIDs = laneIDs;
      }
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this objec.
    * @return {json}
    */
   diagramProperties() {
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
   }
};


/***/ }),

/***/ 25330:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessElement.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessElementCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessElementCore.js */ 43409);

module.exports = class ABProcessElement extends ABProcessElementCore {
   // constructor(attributes, process, AB, defaultValues) {
   //    super(attributes, process, AB, defaultValues);

   //    // listen
   // }

   /**
    * @method destroy()
    * remove this task definition.
    * @return {Promise}
    */
   destroy() {
      ////
      //// TODO: once our core conversion is complete, this .save() can be
      //// moved to ABProcessTaskCore, and our ABDefinition.save() can take
      //// care of the proper method to save depending on the current Platform.
      ////
      // return this.toDefinition()
      //     .destroy()

      return super.destroy().then(() => {
         return this.process.elementRemove(this);
      });
   }

   isValid() {
      /*
        var validator = OP.Validation.validator();

        // label/name must be unique:
        var isNameUnique =
            this.AB.processes((o) => {
                return o.name.toLowerCase() == this.name.toLowerCase();
            }).length == 0;
        if (!isNameUnique) {
            validator.addError(
                "name",
                L(
                    "ab.validation.object.name.unique",
                    `Process name must be unique ("${this.name}"" already used in this Application)`
                )
            );
        }

        return validator;
        */

      // var isValid =
      //     this.AB.processes((o) => {
      //         return o.name.toLowerCase() == this.name.toLowerCase();
      //     }).length == 0;
      // return isValid;

      return true;
   }

   ////
   //// Modeler Instance Methods
   ////

   findLane(curr, cb) {
      if (!curr) {
         cb(null, null);
         return;
      }

      // if current object has a LANE definition, use that one:
      if (curr.lanes && curr.lanes.length > 0) {
         cb(null, curr.lanes[0]);
      } else if (curr.$type == "bpmn:Participant") {
         // if the current is a Participant, take that one
         cb(null, curr);
      } else {
         // else move upwards and check again:
         curr = curr.$parent;
         this.findLane(curr, cb);
      }
   }

   setLane(Lane) {
      this.laneDiagramID = Lane.diagramID;
   }

   /**
    * fromElement()
    * initialize this Task's values from the given BPMN:Element
    * @param {BPMNElement}
    */
   fromElement(element) {
      this.diagramID = element.id || this.diagramID;
      this.onChange(element);
   }

   /**
    * onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      /*
        Sample DefElement:
            {
                "labels": [],
                "children": [],
                "id": "Task_08j07ni",
                "width": 100,
                "height": 80,
                "type": "bpmn:SendTask",
                "x": 20,
                "y": -2130,
                "order": {
                    "level": 5
                },
                "businessObject": {
                    "$type": "bpmn:SendTask",
                    "id": "Task_08j07ni",
                    "name": "ffff",
                    "di": {
                        "$type": "bpmndi:BPMNShape",
                        "bounds": {
                            "$type": "dc:Bounds",
                            "x": 20,
                            "y": -2130,
                            "width": 100,
                            "height": 80
                        },
                        "id": "SendTask_0iidv6o_di"
                    }

                    // Some elements (like EndEvents) have:
                    .eventDefinitions: [
                        {
                            $type: "actual bpmn:ElementType",
                            ...
                        }
                    ]
                },
                "incoming":[],
                "outgoing":[]
            }
         */

      // from the BPMI modeler we can gather a label for this:
      if (
         defElement.businessObject.name &&
         defElement.businessObject.name != ""
      ) {
         this.label = defElement.businessObject.name;
      }

      // our lane may have changed:
      var currObj = defElement.businessObject;
      this.findLane(currObj, (err, obj) => {
         if (obj) {
            this.laneDiagramID = obj.id;
         } else {
            // if my parent shape is a Participant, then use that:
            if (
               defElement.parent &&
               defElement.parent.type == "bpmn:Participant"
            ) {
               this.laneDiagramID = defElement.parent.id;
            } else {
               this.laneDiagramID = null;
            }
         }
      });
   }

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      const warnings = this.warnings();
      return [
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
            warn: warnings.length ? warnings : null,
         },
      ];
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ui = {
         id: id,
         view: "label",
         label: "this task has not implement properties yet...",
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {}

   /**
    * property()
    * return the specific property value if it exists.
    * @return {mixed} | undefined
    */
   property(id) {
      if ($$(id)) {
         return $$(id).getValue();
      }
   }

   /**
    * switchTo()
    * replace this object with an instance of one of our child classes:
    * @param {ABProcessTask*} child
    *        an instance of the new Process Task we are replaced with.
    * @param {string} propertiesID
    *        the webix ui.id container for the properties panel.
    */
   switchTo(child, propertiesID) {
      // remove myself from our containing process's elements
      this.process.elementRemove(this);

      // add the new Process WITH the same id
      this.process.elementAdd(child);

      // show the child properties:
      child.propertiesShow(propertiesID);

      this.emit("switchTo", child);
   }

   /**
    * @method warningsEval()
    * re-evaluate our warnings for this Process Task.
    * Most of our ProcessTasks need to also verify data related to
    * other available tasks, so we need to call the onProcessReady()
    * so we can access those values.
    */
   warningsEval() {
      super.warningsEval();
      this.onProcessReady();

      // if this isn't an end type of task, then there must be
      // > 0 next tasks
      if (!this.isEndTask()) {
         const myOutgoingConnections = this.process.connectionsOutgoing(
            this.diagramID
         );
         if (myOutgoingConnections.length < 1) {
            this.warningMessage("should have another task after this one");
         }
      }
   }

   /**
    * @method warningMessage(message)
    * Save a warning message in a common format for our ProcessTasks.
    */
   warningMessage(msg, data = {}) {
      let message = `${this.defaults.key}[${
         this.label ? this.label : this.name
      }]: ${msg}`;
      this._warnings.push({ message, data });
   }
};


/***/ }),

/***/ 39864:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessEnd.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessEndCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessEndCore.js */ 69569);

module.exports = class ABProcessEnd extends ABProcessEndCore {
   /**
    * do()
    * this method actually performs the action for this task.
    * @param {obj} instance  the instance data of the running process
    * @return {Promise}
    *      resolve(true/false) : true if the task is completed.
    *                            false if task is still waiting
    */
   // do(instance) {
   //     return new Promise((resolve, reject) => {
   //         // An End Event doesn't perform any other actions
   //         // than to signal it has successfully completed.
   //         // But it provides no Additional Tasks to work on.
   //         // for testing:
   //         this.stateCompleted(instance);
   //         this.log(instance, "End Event Reached");
   //         resolve(true);
   //     });
   // }
};


/***/ }),

/***/ 15372:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessGatewayExclusive.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessGatewayExclusiveCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessGatewayExclusiveCore.js */ 2406);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessGatewayExclusive extends (
   ABProcessGatewayExclusiveCore
) {
   ////
   //// Process Instance Methods
   ////

   /**
    * diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties() {
      // the first entry is for the gateway element itself
      var properties = super.diagramProperties();
      /*[
         {
            id: this.diagramID,
            def: {
               name: this.name,
            },
         },
      ];
      */

      // now add any additional updates for each of our connections:
      var myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      myOutgoingConnections.forEach((conn) => {
         properties.push({
            id: conn.id,
            def: {
               name: this.conditions[conn.id]?.label ?? "",
            },
         });
      });
      return properties;
   }

   warningsEval() {
      super.warningsEval();

      // make sure we have > 1 connection.
      const myOutgoingConnections = this.process.connectionsOutgoing(
         this.diagramID
      );
      if (myOutgoingConnections.length < 2) {
         this.warningMessage("should have multiple outgoing connections");
      }

      // make sure there is no more then 1 connection that doesn't have
      // a condition:
      let numCondWithOne = 0;
      myOutgoingConnections.forEach((c) => {
         if ((this.conditions[c.id]?.filterValue.rules?.length ?? 0) == 0) {
            numCondWithOne++;
         }
      });

      if (numCondWithOne > 1) {
         this.warningMessage(
            "should not have more than 1 unfiltered connection."
         );
      }
   }
};


/***/ }),

/***/ 93563:
/*!*****************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskEmail.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskEmailCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskEmailCore.js */ 85772);

module.exports = class ABProcessTaskEmail extends ABProcessTaskEmailCore {
   ////
   //// Process Instance Methods
   ////

   warningsEval() {
      super.warningsEval();

      // check for warnings:

      if (!this.subject) {
         this.warningMessage("is missing a subject");
      }

      if (!this.message) {
         this.warningMessage("is missing a message");
      }

      this.verifySetting("to");
      this.verifySetting("from");
      this.verifyNextLane("to");
      if (this.from == "0") {
         let thisLane = this.myLane();
         if (!thisLane) {
            this.warningMessage(
               "can not resolve the lane participant for [.from] field."
            );
         }
      }
      this.verifyRoleAccount("to", "toUsers");
      this.verifyRoleAccount("from", "fromUsers");
   }

   /**
    * @method verifySetting()
    * make sure the given field key has a value assigned.
    * @param {string} key
    *        the property of this object to check. (to, from)
    */
   verifySetting(key) {
      if (this[key] == "") {
         this.warningMessage(`does not have a [${key}] setting.`);
      }
   }

   /**
    * @method verifyNextLane()
    * make sure we can access a Lane for the given property key.
    * The "to" field can reference the "Next Participant". This checks to
    * see if we can reference a lane for the next task.
    * @param {string} key
    *        the property that has the value for Next Participant. [to]
    */
   verifyNextLane(key) {
      if (this[key] === "0") {
         // Next Participant
         // we need to resolve our next task and see if we can pull the participant info from it.

         let nextTasks = this.process.connectionNextTask(this);
         let nextLanesResolved = true;
         nextTasks.forEach((t) => {
            let lane = t.myLane();
            if (!lane) {
               nextLanesResolved = false;
            }
         });
         if (!nextLanesResolved || nextTasks.length == 0) {
            this.warningMessage(
               `can not resolve next lane participant for [${key}] field.`
            );
         }
      }
   }

   /**
    * @method verifyRoleAccount()
    * Check to see if the provided property is set to use a Role/Account for
    * the email, and make sure there are values set for what is chosen.
    * @param {string} key
    *        the property we are currently validating.
    * @param {string} valKey
    *        the property that contains the specific value object.
    */
   verifyRoleAccount(key, valKey) {
      if (this[key] == "1") {
         if (this[valKey]) {
            if (this[valKey].useRole) {
               if (this[valKey].role.length == 0) {
                  this.warningMessage(`can not resolve [${key}] Role setting.`);
               }
            }
            if (this[valKey].useAccount) {
               if (this[valKey].account.length == 0) {
                  this.warningMessage(
                     `can not resolve [${key}] Account setting.`
                  );
               }
            }
            // TODO:
            // if (this[valKey].userFields.length > 0) {
            //    // how to know if this is a problem?
            // }
         }
      }
   }
};


/***/ }),

/***/ 2353:
/*!*******************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskService.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskServiceCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCore.js */ 95824);

module.exports = class ABProcessTaskService extends ABProcessTaskServiceCore {};


/***/ }),

/***/ 97915:
/*!********************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingBatchProcessing.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingBatchProcessingCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingBatchProcessingCore.js */ 39163);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingBatchProcessing extends (
   AccountingBatchProcessingCore
) {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         fieldBatchEntries: `${id}_fieldBatchEntries`,
         fieldBatchFinancialPeriod: `${id}_fieldBatchFinancialPeriod`,
         objectJE: `${id}_objectJE`,
         fieldJEAccount: `${id}_fieldJEAccount`,
         fieldJERC: `${id}_fieldJERC`,
         fieldJEStatus: `${id}_fieldJEStatus`,
         fieldJEStatusComplete: `${id}_fieldJEStatusComplete`,
         objectBR: `${id}_objectBR`,
         fieldBRFinancialPeriod: `${id}_fieldBRFinancialPeriod`,
         fieldBRAccount: `${id}_fieldBRAccount`,
         fieldBRRC: `${id}_fieldBRRC`,
         fieldBREntries: `${id}_fieldBREntries`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      //
      // set up field settings:
      //

      var blankField = {
         id: 0,
         value: L("Select a Field"),
      };
      // blankField : generic Select a field entry

      function defaultFields(objID) {
         // create a new options array of Field Choices for the given obj.id

         var fields = [blankField];
         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      }

      function updateFields(fieldPickers, fieldValues, defaultValue) {
         // update the list of field select choices with the new field choices

         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               // if (defaultValue) {
               //    picker.define("value", defaultValue);
               // } else {
               //    picker.define("value", fieldValues[0].value);
               // }
               picker.refresh();
               picker.show();
            }
         });
      }

      var batchFields = defaultFields(this.objectBatch);
      // batchFields : the default list of fields for the Batch Object

      var fieldPickersBatch = [
         ids.fieldBatchEntries,
         ids.fieldBatchFinancialPeriod,
      ];
      // fieldPickersBatch : the list of field selects to update for the Batch
      //      object.

      var jeFields = defaultFields(this.objectJE);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersJE = [
         ids.fieldJEAccount,
         ids.fieldJERC,
         ids.fieldJEStatus,
      ];
      // fieldPickersJE : the list of field selects to update for the Journal Entry
      //      object.

      function compileStatusValues(statusField) {
         var values = [{ id: 0, value: L("Select the Complete Value") }];
         if (statusField && statusField.options) {
            statusField.options().forEach((o) => {
               values.push({ id: o.id, value: o.text });
            });
         }
         return values;
      }

      function updatePickerStatusComplete(values) {
         var wbxComplete = $$(ids.fieldJEStatusComplete);
         if (wbxComplete) {
            // update fieldJEStatusComplete options
            wbxComplete.define("options", values);
            wbxComplete.refresh();
            // show fieldJEStatusComplete
            wbxComplete.show();
         }
      }

      function onStatusComplete(newVal) {
         // pull the ABField object from newValue
         var jeEntryID = $$(ids.objectJE).getValue();
         var jeEntry = objectList.find((o) => o.id == jeEntryID);
         if (jeEntry && jeEntry.object) {
            var statusField = jeEntry.object.fieldByID(newVal);
            if (statusField && statusField.options) {
               // get the options as an []
               jeFieldStatusValues = compileStatusValues(statusField);

               updatePickerStatusComplete(jeFieldStatusValues);
            }
         }
      }

      var jeFieldStatusValues = compileStatusValues();
      // jeFieldStatusValues : the list of status options from the fieldJEStatus
      //      selected entry.

      var brFields = defaultFields(this.objectBR);
      // jeFields : the default list of fields for the Journal Entry Object

      var fieldPickersBR = [
         ids.fieldBRFinancialPeriod,
         ids.fieldBRAccount,
         ids.fieldBRRC,
         ids.fieldBREntries,
      ];
      // fieldPickersBR : the list of field selects to update for the Balance Record
      //      object.

      var ui = {
         id: id,
         view: "form",
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        batchFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBatch, batchFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBatchEntries,
               view: "select",
               label: L("Batch->JE[]"),
               value: this.fieldBatchEntries,
               name: "fieldBatchEntries",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.fieldBatchFinancialPeriod,
               view: "select",
               label: L("Batch->FinancialPeriod"),
               value: this.fieldBatchFinancialPeriod,
               name: "fieldBatchFinancialPeriod",
               options: batchFields,
               hidden: true,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("Journal Entry Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        jeFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersJE, jeFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEAccount,
               view: "select",
               label: L("JE->Account"),
               value: this.fieldJEAccount,
               name: "fieldJEAccount",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJERC,
               view: "select",
               label: L("JE->RC"),
               value: this.fieldJERC,
               name: "fieldJERC",
               options: jeFields,
               hidden: true,
            },
            {
               id: ids.fieldJEStatus,
               view: "select",
               label: L("JE->Status"),
               value: this.fieldJEStatus,
               name: "fieldJEStatus",
               options: jeFields,
               hidden: true,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        onStatusComplete(newVal);
                     }
                  },
               },
            },
            {
               id: ids.fieldJEStatusComplete,
               view: "select",
               label: L("JE->Status->Complete"),
               value: this.fieldJEStatusComplete,
               name: "fieldJEStatusComplete",
               options: jeFieldStatusValues,
               hidden: true,
            },
            {
               id: ids.objectBR,
               view: "select",
               label: L("Balance Record"),
               value: this.objectBR,
               name: "objectBR",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of jeFields
                        brFields = defaultFields(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFields(fieldPickersBR, brFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldBRFinancialPeriod,
               view: "select",
               label: L("BR->FP"),
               value: this.fieldBRFinancialPeriod,
               name: "fieldBRFinancialPeriod",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRAccount,
               view: "select",
               label: L("BR->Account"),
               value: this.fieldBRAccount,
               name: "fieldBRAccount",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBRRC,
               view: "select",
               label: L("BR->RC"),
               value: this.fieldBRRC,
               name: "fieldBRRC",
               options: brFields,
               hidden: true,
            },
            {
               id: ids.fieldBREntries,
               view: "select",
               label: L("BR->Entries"),
               value: this.fieldBREntries,
               name: "fieldBREntries",
               options: brFields,
               hidden: true,
            },
         ],
      };

      webix.ui(ui, $$(id));

      // if there are already default values for our Objects,
      // unhide the field selectors:
      if (this.objectBatch && this.objectBatch != 0) {
         updateFields(fieldPickersBatch, batchFields);
      }

      if (this.objectJE && this.objectJE != 0) {
         updateFields(fieldPickersJE, jeFields);
      }

      if (this.fieldJEStatus) {
         onStatusComplete(this.fieldJEStatus);
      }

      if (this.objectBR && this.objectBR != 0) {
         updateFields(fieldPickersBR, brFields);
      }

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 10727:
/*!************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPClose.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingFPCloseCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPCloseCore.js */ 25144);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingFPClose extends AccountingFPCloseCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPValue: `${id}_processFPValue`,
         objectFP: `${id}_objectFP`,
         objectGL: `${id}_objectGL`,
         objectAcc: `${id}_objectAcc`,
         fieldFPStart: `${id}_fieldFPStart`,
         fieldFPOpen: `${id}_fieldFPOpen`,
         fieldFPStatus: `${id}_fieldFPStatus`,
         fieldFPActive: `${id}_fieldFPActive`,
         fieldGLStarting: `${id}_fieldGLStarting`,
         fieldGLRunning: `${id}_fieldGLRunning`,
         fieldGLAccount: `${id}_fieldGLAccount`,
         fieldGLRc: `${id}_fieldGLRc`,
         fieldGLDebit: `${id}fieldGLDebit`,
         fieldGLCredit: `${id}_fieldGLCredit`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccAsset: `${id}_fieldAccAsset`,
         fieldAccExpense: `${id}_fieldAccExpense`,
         fieldAccLiabilities: `${id}_fieldAccLiabilities`,
         fieldAccEquity: `${id}_fieldAccEquity`,
         fieldAccIncome: `${id}_fieldAccIncome`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object.fields().forEach((f) => {
                  fields.push({ id: f.id, value: f.label, field: f });
               });
            }
         }
         return fields;
      };

      let getStatusFieldOptions = (statusFieldId) => {
         let result = [];
         let fpObject = this.AB.objectByID(this.objectFP);
         if (!fpObject) return result;

         let fpStatusField = fpObject.fieldByID(statusFieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateFPFields = (fpFields) => {
         [ids.fieldFPStart, ids.fieldFPOpen, ids.fieldFPStatus].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", fpFields);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateFPStatusFields = (fpStatusOptions) => {
         $$(ids.fieldFPActive).define("options", fpStatusOptions);
         $$(ids.fieldFPActive).refresh();
      };

      let updateGLFields = (glFields) => {
         [
            ids.fieldGLRunning,
            ids.fieldGLAccount,
            ids.fieldGLRc,
            ids.fieldGLDebit,
            ids.fieldGLCredit,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", glFields);
            $$(fieldGLElem).refresh();
         });
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccAsset,
            ids.fieldAccExpense,
            ids.fieldAccLiabilities,
            ids.fieldAccEquity,
            ids.fieldAccIncome,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let fpFields = getFieldOptions(this.objectFP);
      let glFields = getFieldOptions(this.objectGL);
      let accFields = getFieldOptions(this.objectAcc);
      let fpStatusFields = getStatusFieldOptions(this.fieldFPStatus);
      let accTypeOptions = getListOptions(this.objectAcc, this.fieldAccType);

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPValue,
               view: "select",
               label: L("Process Fiscal Period Value"),
               value: this.processFPValue,
               name: "processFPValue",
               options: processValues,
            },
            {
               id: ids.objectFP,
               view: "select",
               label: L("FP Object"),
               value: this.objectFP,
               name: "objectFP",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        fpFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateFPFields(fpFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("GL Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        // gather new set of batchFields
                        glFields = getFieldOptions(newVal);
                        // rebuild the associated list of Fields to pick
                        updateGLFields(glFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAcc,
               view: "select",
               label: L("Account Object"),
               value: this.objectAcc,
               name: "objectAcc",
               options: objectList,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        accFields = getFieldOptions(newVal);
                        updateAccFields(accFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPStart,
               view: "select",
               label: L("FP -> Start"),
               value: this.fieldFPStart,
               name: "fieldFPStart",
               options: fpFields,
            },
            {
               id: ids.fieldFPOpen,
               view: "select",
               label: L("FP -> Open"),
               value: this.fieldFPOpen,
               name: "fieldFPOpen",
               options: fpFields,
            },
            {
               id: ids.fieldFPStatus,
               view: "select",
               label: L("FP -> Status"),
               value: this.fieldFPStatus,
               name: "fieldFPStatus",
               options: fpFields,
               on: {
                  onChange(newVal, oldVal) {
                     if (newVal != oldVal) {
                        fpStatusFields = getStatusFieldOptions(newVal);
                        updateFPStatusFields(fpStatusFields);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPActive,
               view: "select",
               label: L("FP -> Active"),
               value: this.fieldFPActive,
               name: "fieldFPActive",
               options: fpStatusFields,
            },
            {
               id: ids.fieldGLStarting,
               view: "select",
               label: L("GL -> Starting BL"),
               value: this.fieldGLStarting,
               name: "fieldGLStarting",
               options: glFields,
            },
            {
               id: ids.fieldGLRunning,
               view: "select",
               label: L("GL -> Running BL"),
               value: this.fieldGLRunning,
               name: "fieldGLRunning",
               options: glFields,
            },
            {
               id: ids.fieldGLAccount,
               view: "select",
               label: L("GL -> Account"),
               value: this.fieldGLAccount,
               name: "fieldGLAccount",
               options: glFields,
            },
            {
               id: ids.fieldGLRc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLRc,
               name: "fieldGLRc",
               options: glFields,
            },
            {
               id: ids.fieldGLDebit,
               view: "select",
               label: L("GL -> Debit"),
               value: this.fieldGLDebit,
               name: "fieldGLDebit",
               options: glFields,
            },
            {
               id: ids.fieldGLCredit,
               view: "select",
               label: L("GL -> Credit"),
               value: this.fieldGLCredit,
               name: "fieldGLCredit",
               options: glFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAcc || $$(ids.objectAcc).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccAsset,
               view: "select",
               label: L("Acc -> Asset"),
               value: this.fieldAccAsset,
               name: "fieldAccAsset",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccExpense,
               name: "fieldAccExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccLiabilities,
               view: "select",
               label: L("Acc -> Liabilities"),
               value: this.fieldAccLiabilities,
               name: "fieldAccLiabilities",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccEquity,
               name: "fieldAccEquity",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccIncome,
               name: "fieldAccIncome",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 3746:
/*!****************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingFPYearClose.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingFPYearCloseCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingFPYearCloseCore.js */ 93071);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingFPYearClose extends AccountingFPYearCloseCore {
   ////
   //// Process Instance Methods
   ////
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processFPYearValue: `${id}_processFPYearValue`,
         objectFPYear: `${id}_objectFPYear`,
         objectFPMonth: `${id}_objectFPMonth`,
         objectGL: `${id}_objectGL`,
         objectAccount: `${id}_objectAccount`,
         valueFundBalances: `${id}_valueFundBalances`,
         valueNetIncome: `${id}_valueNetIncome`,
         fieldFPYearStart: `${id}_fieldFPYearStart`,
         fieldFPYearEnd: `${id}_fieldFPYearEnd`,
         fieldFPYearStatus: `${id}_fieldFPYearStatus`,
         fieldFPYearActive: `${id}_fieldFPYearActive`,
         fieldFPMonthStart: `${id}_fieldFPMonthStart`,
         fieldFPMonthEnd: `${id}_fieldFPMonthEnd`,
         fieldGLStartBalance: `${id}_fieldGLStartBalance`,
         fieldGLRunningBalance: `${id}_fieldGLRunningBalance`,
         fieldGLrc: `${id}_fieldGLrc`,
         fieldAccNumber: `${id}_fieldAccNumber`,
         fieldAccType: `${id}_fieldAccType`,
         fieldAccTypeIncome: `${id}_fieldAccTypeIncome`,
         fieldAccTypeExpense: `${id}_fieldAccTypeExpense`,
         fieldAccTypeEquity: `${id}_fieldAccTypeEquity`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      var ids = this.propertyIDs(id);

      var processValues = [{ id: 0, value: L("Select a Process Value") }];
      var processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      var objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });
      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getFieldOptions = (objID, fieldKey) => {
         let fields = [
            {
               id: 0,
               value: L("Select a Field"),
            },
         ];

         if (objID) {
            var entry = objectList.find((o) => o.id == objID);
            if (entry && entry.object) {
               entry.object
                  .fields((f) => f.key == fieldKey)
                  .forEach((f) => {
                     fields.push({ id: f.id, value: f.label, field: f });
                  });
            }
         }
         return fields;
      };

      let getListOptions = (objectId, fieldId) => {
         let result = [];
         let object = this.AB.objectByID(objectId);
         if (!object) return result;

         let fpStatusField = object.fieldByID(fieldId);
         if (
            !fpStatusField ||
            !fpStatusField.settings ||
            !fpStatusField.settings.options
         )
            return result;

         result = (fpStatusField.settings.options || []).map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
            };
         });

         return result;
      };

      let updateAccNumberFields = (accNumberFields) => {
         $$(ids.fieldAccNumber).define("options", accNumberFields);
         $$(ids.fieldAccNumber).refresh();
      };

      let updateAccFields = (accFields) => {
         $$(ids.fieldAccType).define("options", accFields);
         $$(ids.fieldAccType).refresh();
      };

      let updateAccTypeOptions = (accTypeOptions) => {
         [
            ids.fieldAccTypeIncome,
            ids.fieldAccTypeExpense,
            ids.fieldAccTypeEquity,
         ].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", accTypeOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearDateOptions = (fpYearDateOptions) => {
         [ids.fieldFPYearStart, ids.fieldFPYearEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpYearDateOptions);
            $$(fieldGLElem).refresh();
         });
      };

      let updateFPYearStatusOptions = (fpYearStatusFields) => {
         $$(ids.fieldFPYearStatus).define("options", fpYearStatusFields);
         $$(ids.fieldFPYearStatus).refresh();
      };

      let updateFPYearActiveOptions = (fpYearStatusOptions) => {
         $$(ids.fieldFPYearActive).define("options", fpYearStatusOptions);
         $$(ids.fieldFPYearActive).refresh();
      };

      let updateFPMonthDateFields = (fpMonthDateOpts) => {
         [ids.fieldFPMonthStart, ids.fieldFPMonthEnd].forEach((fieldGLElem) => {
            $$(fieldGLElem).define("options", fpMonthDateOpts);
            $$(fieldGLElem).refresh();
         });
      };

      let updateGlNumberFields = (glNumberOptions) => {
         [ids.fieldGLStartBalance, ids.fieldGLRunningBalance].forEach(
            (fieldGLElem) => {
               $$(fieldGLElem).define("options", glNumberOptions);
               $$(fieldGLElem).refresh();
            }
         );
      };

      let updateGlConnectFields = (glRcOptions) => {
         $$(ids.fieldGLrc).define("options", glRcOptions);
         $$(ids.fieldGLrc).refresh();
      };

      let fpYearDateFields = getFieldOptions(this.objectFPYear, "date");
      let fpYearStatusFields = getFieldOptions(this.objectFPYear, "list");
      let fpYearStatusOptions = getListOptions(
         this.objectFPYear,
         this.fieldFPYearStatus
      );
      let fpMonthDateFields = getFieldOptions(this.objectFPMonth, "date");
      let glNumberFields = getFieldOptions(this.objectGL, "number");
      let glRcFields = getFieldOptions(this.objectGL, "connectObject");
      let accNumberFields = getFieldOptions(this.objectAccount, "number");
      let accTypeFields = getFieldOptions(this.objectAccount, "list");
      let accTypeOptions = getListOptions(
         this.objectAccount,
         this.fieldAccType
      );

      var ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 200,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processFPYearValue,
               view: "select",
               label: L("Process Fiscal Period Year Value"),
               value: this.processFPYearValue,
               name: "processFPYearValue",
               options: processValues,
            },
            {
               id: ids.objectFPYear,
               view: "select",
               label: L("FP Year Object"),
               value: this.objectFPYear,
               name: "objectFPYear",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearDateFields = getFieldOptions(newVal, "date");
                        updateFPYearDateOptions(fpYearDateFields);

                        accTypeFields = getFieldOptions(newVal, "list");
                        updateFPYearStatusOptions(accTypeFields);
                     }
                  },
               },
            },
            {
               id: ids.objectFPMonth,
               view: "select",
               label: L("FP Month Object"),
               value: this.objectFPMonth,
               name: "objectFPMonth",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpMonthDateFields = getFieldOptions(newVal, "date");
                        updateFPMonthDateFields(fpMonthDateFields);
                     }
                  },
               },
            },
            {
               id: ids.objectGL,
               view: "select",
               label: L("Balance Object"),
               value: this.objectGL,
               name: "objectGL",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        glNumberFields = getFieldOptions(newVal, "number");
                        updateGlNumberFields(glNumberFields);

                        glRcFields = getFieldOptions(newVal, "connectObject");
                        updateGlConnectFields(glRcFields);
                     }
                  },
               },
            },
            {
               id: ids.objectAccount,
               view: "select",
               label: L("Account Object"),
               value: this.objectAccount,
               name: "objectAccount",
               options: objectList,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeFields = getFieldOptions(newVal, "list");
                        updateAccFields(accTypeFields);

                        accNumberFields = getFieldOptions(newVal, "number");
                        updateAccNumberFields(accNumberFields);
                     }
                  },
               },
            },
            {
               id: ids.valueFundBalances,
               view: "text",
               label: L("Fund Balances Code"),
               value: this.valueFundBalances,
               name: "valueFundBalances",
            },
            {
               id: ids.valueNetIncome,
               view: "text",
               label: L("Net Income Code"),
               value: this.valueNetIncome,
               name: "valueNetIncome",
            },
            {
               id: ids.fieldFPYearStart,
               view: "select",
               label: L("FP Year -> Start"),
               value: this.fieldFPYearStart,
               name: "fieldFPYearStart",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearEnd,
               view: "select",
               label: L("FP Year -> End"),
               value: this.fieldFPYearEnd,
               name: "fieldFPYearEnd",
               options: fpYearDateFields,
            },
            {
               id: ids.fieldFPYearStatus,
               view: "select",
               label: L("FP Year -> Status"),
               value: this.fieldFPYearStatus,
               name: "fieldFPYearStatus",
               options: fpYearStatusFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        fpYearStatusOptions = getListOptions(
                           this.objectFPYear || $$(ids.objectFPYear).getValue(),
                           newVal
                        );
                        updateFPYearActiveOptions(fpYearStatusOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldFPYearActive,
               view: "select",
               label: L("FP Year -> Active"),
               value: this.fieldFPYearActive,
               name: "fieldFPYearActive",
               options: fpYearStatusOptions,
            },
            {
               id: ids.fieldFPMonthStart,
               view: "select",
               label: L("FP Month -> Start"),
               value: this.fieldFPMonthStart,
               name: "fieldFPMonthStart",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldFPMonthEnd,
               view: "select",
               label: L("FP Month -> End"),
               value: this.fieldFPMonthEnd,
               name: "fieldFPMonthEnd",
               options: fpMonthDateFields,
            },
            {
               id: ids.fieldGLStartBalance,
               view: "select",
               label: L("GL -> Start Balance"),
               value: this.fieldGLStartBalance,
               name: "fieldGLStartBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLRunningBalance,
               view: "select",
               label: L("GL -> Running Balance"),
               value: this.fieldGLRunningBalance,
               name: "fieldGLRunningBalance",
               options: glNumberFields,
            },
            {
               id: ids.fieldGLrc,
               view: "select",
               label: L("GL -> RC"),
               value: this.fieldGLrc,
               name: "fieldGLrc",
               options: glRcFields,
            },
            {
               id: ids.fieldAccNumber,
               view: "select",
               label: L("Acc -> Account Number"),
               value: this.fieldAccNumber,
               name: "fieldAccNumber",
               options: accNumberFields,
            },
            {
               id: ids.fieldAccType,
               view: "select",
               label: L("Acc -> Type"),
               value: this.fieldAccType,
               name: "fieldAccType",
               options: accTypeFields,
               on: {
                  onChange: (newVal, oldVal) => {
                     if (newVal != oldVal) {
                        accTypeOptions = getListOptions(
                           this.objectAccount ||
                              $$(ids.objectAccount).getValue(),
                           newVal
                        );
                        updateAccTypeOptions(accTypeOptions);
                     }
                  },
               },
            },
            {
               id: ids.fieldAccTypeIncome,
               view: "select",
               label: L("Acc -> Income"),
               value: this.fieldAccTypeIncome,
               name: "fieldAccTypeIncome",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeExpense,
               view: "select",
               label: L("Acc -> Expense"),
               value: this.fieldAccTypeExpense,
               name: "fieldAccTypeExpense",
               options: accTypeOptions,
            },
            {
               id: ids.fieldAccTypeEquity,
               view: "select",
               label: L("Acc -> Equity"),
               value: this.fieldAccTypeEquity,
               name: "fieldAccTypeEquity",
               options: accTypeOptions,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      var ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         this[s] = this.property(ids[s]);
      });
   }
};


/***/ }),

/***/ 69305:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceAccountingJEArchive.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const AccountingJEArchiveCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceAccountingJEArchiveCore.js */ 308);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class AccountingJEArchive extends AccountingJEArchiveCore {
   ////
   //// Process Instance Methods
   ////

   propertyIDs(id) {
      return {
         name: `${id}_name`,
         processBatchValue: `${id}_processBatchValue`,
         objectBatch: `${id}_objectBatch`,
         objectBalance: `${id}_objectBalance`,
         objectJE: `${id}_objectJE`,
         objectJEArchive: `${id}_objectJEArchive`,

         fieldBatchFiscalMonth: `${id}_fieldBatchFiscalMonth`,
         fieldJeAccount: `${id}_fieldJeAccount`,
         fieldJeRC: `${id}_fieldJeRC`,
         fieldJeArchiveBalance: `${id}_fieldJeArchiveBalance`,
         fieldBrFiscalMonth: `${id}_fieldBrFiscalMonth`,
         fieldBrAccount: `${id}_fieldBrAccount`,
         fieldBrRC: `${id}_fieldBrRC`,

         fieldsMatch: `${id}_fieldsMatch`,
      };
   }

   /**
    * propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      let processValues = [{ id: 0, value: L("Select a Process Value") }];
      let processDataFields = this.process.processDataFields(this);
      (processDataFields || []).forEach((row) => {
         processValues.push({ id: row.key, value: row.label });
      });

      let objectList = this.AB.objects().map((o) => {
         return { id: o.id, value: o.label || o.name, object: o };
      });

      objectList.unshift({
         id: 0,
         value: L("Select an Object"),
      });

      let getConnectFieldOptions = (objectId) => {
         let object = this.AB.objectByID(objectId);
         if (!object) return [];

         let options = object
            .fields((f) => f.isConnection)
            .map((f) => {
               return {
                  id: f.id,
                  value: f.label,
               };
            });

         options.unshift({
            id: 0,
            value: L("Select a Field"),
         });

         return options;
      };

      let updateFields = (fieldPickers, fieldValues) => {
         fieldPickers.forEach((fp) => {
            var picker = $$(fp);
            if (picker) {
               picker.define("options", fieldValues);
               picker.refresh();
               picker.show();
            }
         });
      };

      let refreshBatchFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldBatchFiscalMonth], options);
      };

      let refreshBRFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields(
            [ids.fieldBrAccount, ids.fieldBrFiscalMonth, ids.fieldBrRC],
            options
         );
      };

      let refreshJeFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeAccount, ids.fieldJeRC], options);
      };

      let refreshJeArchiveFields = (objectId) => {
         let options = getConnectFieldOptions(objectId);
         updateFields([ids.fieldJeArchiveBalance], options);
      };

      let refreshFieldsMatch = () => {
         let $fieldsMatch = $$(ids.fieldsMatch);
         if (!$fieldsMatch) return;

         // clear form
         webix.ui([], $fieldsMatch);

         let JEObj = this.AB.objectByID(this.objectJE);
         if (!JEObj) return;

         let JEArchiveObj = this.AB.objectByID(this.objectJEArchive);
         if (!JEArchiveObj) return;

         // create JE acrhive field options to the form
         JEArchiveObj.fields().forEach((f) => {
            let jeFields = [];

            if (f.isConnection) {
               jeFields = JEObj.fields((fJe) => {
                  return (
                     fJe.isConnection &&
                     fJe.settings &&
                     f.settings &&
                     fJe.settings.linkObject == f.settings.linkObject &&
                     fJe.settings.linkType == f.settings.linkType &&
                     fJe.settings.linkViaType == f.settings.linkViaType &&
                     fJe.settings.isCustomFK == f.settings.isCustomFK
                  );
               });
            } else {
               jeFields = JEObj.fields((fJe) => fJe.key == f.key);
            }

            jeFields = jeFields.map((fJe) => {
               return {
                  id: fJe.id,
                  value: fJe.label,
               };
            });

            $fieldsMatch.addView({
               view: "select",
               name: f.id,
               label: f.label,
               options: jeFields,
            });
         });

         $fieldsMatch.setValues(this.fieldsMatch || {});
      };

      let fieldBatchList = getConnectFieldOptions(this.objectBatch);
      let fieldBalanceList = getConnectFieldOptions(this.objectBalance);
      let fieldJeList = getConnectFieldOptions(this.objectJE);
      let fieldJeArchiveList = getConnectFieldOptions(this.objectJEArchive);

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 180,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.processBatchValue,
               view: "select",
               label: L("Process Batch Value"),
               value: this.processBatchValue,
               name: "processBatchValue",
               options: processValues,
            },
            {
               id: ids.objectBatch,
               view: "select",
               label: L("Batch Object"),
               value: this.objectBatch,
               name: "objectBatch",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBatch = newVal;
                     refreshBatchFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBatchFiscalMonth,
               view: "select",
               label: L("Batch -> Fiscal Month"),
               value: this.fieldBatchFiscalMonth,
               name: "fieldBatchFiscalMonth",
               options: fieldBatchList,
            },
            {
               id: ids.objectBalance,
               view: "select",
               label: L("BR Object"),
               value: this.objectBalance,
               name: "objectBalance",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectBalance = newVal;
                     refreshBRFields(newVal);
                  },
               },
            },
            {
               id: ids.fieldBrFiscalMonth,
               view: "select",
               label: L("BR -> Fiscal Month"),
               value: this.fieldBrFiscalMonth,
               name: "fieldBrFiscalMonth",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrAccount,
               view: "select",
               label: L("BR -> Account"),
               value: this.fieldBrAccount,
               name: "fieldBrAccount",
               options: fieldBalanceList,
            },
            {
               id: ids.fieldBrRC,
               view: "select",
               label: L("BR -> RC"),
               value: this.fieldBrRC,
               name: "fieldBrRC",
               options: fieldBalanceList,
            },
            {
               id: ids.objectJE,
               view: "select",
               label: L("JE Object"),
               value: this.objectJE,
               name: "objectJE",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJE = newVal;
                     refreshJeFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeAccount,
               view: "select",
               label: L("JE -> Account"),
               value: this.fieldJeAccount,
               name: "fieldJeAccount",
               options: fieldJeList,
            },
            {
               id: ids.fieldJeRC,
               view: "select",
               label: L("JE -> RC"),
               value: this.fieldJeRC,
               name: "fieldJeRC",
               options: fieldJeList,
            },
            {
               id: ids.objectJEArchive,
               view: "select",
               label: L("JE Archive Object"),
               value: this.objectJEArchive,
               name: "objectJEArchive",
               options: objectList,
               on: {
                  onChange: (newVal) => {
                     this.objectJEArchive = newVal;
                     refreshJeArchiveFields(newVal);
                     refreshFieldsMatch();
                  },
               },
            },
            {
               id: ids.fieldJeArchiveBalance,
               view: "select",
               label: L("JE Archive -> BR"),
               value: this.fieldJeArchiveBalance,
               name: "fieldJeArchiveBalance",
               options: fieldJeArchiveList,
            },
            {
               view: "fieldset",
               label: "Fields Matching",
               body: {
                  id: ids.fieldsMatch,
                  view: "form",
                  borderless: true,
                  elements: [],
               },
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();

      refreshFieldsMatch();
   }

   /**
    * propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    */
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);

      // TIP: keep the .settings entries == ids[s] keys and this will
      // remain simple:
      this.defaults.settings.forEach((s) => {
         if (s === "fieldsMatch") {
            this[s] = $$(ids.fieldsMatch).getValues();
         } else {
            this[s] = this.property(ids[s]);
         }
      });
   }
};


/***/ }),

/***/ 21374:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceCalculate.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CalculateTaskCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceCalculateCore.js */ 4070);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class CalculateTask extends CalculateTaskCore {
   ////
   //// Process Instance Methods
   ////

   warningsEval() {
      super.warningsEval();

      if (!this.formulaText) {
         this.warningMessage("is missing a formula.");
      }

      if (this.formulaText) {
         const hash = {};
         (this.process.processDataFields(this) || []).forEach((item) => {
            hash[`{${item.label}}`] = item;
         });

         let exp = new RegExp(`{[^}]*}`, "g");
         let entries = this.formulaText.match(exp) || [];
         entries.forEach((entry) => {
            if (!hash[entry]) {
               this.warningMessage(
                  `could not resolve process value [${entry}]`
               );
            }
         });
      }
   }
};


/***/ }),

/***/ 78320:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceGetResetPasswordUrl.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskServiceGetResetPasswordUrlCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceGetResetPasswordUrlCore.js */ 13925);

module.exports = class ABProcessTaskServiceGetResetPasswordUrl extends (
   ABProcessTaskServiceGetResetPasswordUrlCore
) {
   warningsEval() {
      super.warningsEval();

      if (!this.email) {
         this.warningMessage("is missing the email address.");
      }

      const processData = (this.process.processDataFields(this) ?? [])
         .filter((item) => item.field?.key == "email")
         .map((item) => {
            return {
               id: item.key,
               value: item.label,
            };
         });

      if (processData.length == 0) {
         this.warningMessage("has no previous tasks exporting email fields.");
      }
   }
};


/***/ }),

/***/ 94417:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceInsertRecord.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const InsertRecordTaskCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceInsertRecordCore.js */ 7739);

module.exports = class InsertRecordTask extends InsertRecordTaskCore {
   warningsEval() {
      super.warningsEval();

      if (!this.objectID) {
         this.warningMessage("has no Object set.");
      }

      const fv = Object.keys(this.fieldValues || {}) || [];
      if (fv.length == 0) {
         this.warningMessage("has no fields set");
      } else {
         let isSet = false;
         fv.forEach((f) => {
            if (
               this.fieldValues[f]?.set != "0" &&
               this.fieldValues[f]?.value != null
            ) {
               isSet = true;
            }
         });
         if (!isSet) {
            this.warningMessage("has no fields set");
         }
      }
   }
};


/***/ }),

/***/ 17378:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskServiceQuery.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskServiceQueryCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskServiceQueryCore.js */ 84224);

const ABQLManager = __webpack_require__(/*! ../../ql/ABQLManager.js */ 25433);

module.exports = class ABProcessTaskServiceQuery extends (
   ABProcessTaskServiceQueryCore
) {
   constructor(attributes, process, AB) {
      super(attributes, process, AB);

      this.attributes = attributes;
   }

   ABQLManager() {
      return ABQLManager;
   }

   warnings() {
      // first get all our embedded QL Command warnings
      let qlWarnings = [];
      if (this.qlObj) {
         qlWarnings = qlWarnings.concat(this.qlObj.warnings());
      }
      // run the QL Warnings through our .warningMessage() to get a message
      // that includes this task's name:
      qlWarnings.forEach((w) => {
         if (w?.message) this.warningMessage(w.message);
      });
      let myWarnings = super.warnings();
      return myWarnings.filter((w) => w); // filter out any undefined.
   }

   warningsEval() {
      super.warningsEval();
      if (this.qlObj) {
         this.qlObj.warningsEval();
      } else {
         this.warningMessage(`has no Query defined.`);
      }

      if (!this.name) {
         this.warningMessage("does not have a name.", {
            attributes: this.attributes,
         });
      }

      let hasSave = false;
      let curr = this.qlObj;
      while (curr) {
         if (curr.key === "row_save" || curr.key === "set_save") {
            hasSave = true;
            curr = null; // just stop here.
         } else {
            curr = curr.next;
         }
      }

      if (!hasSave) {
         this.warningMessage("requires at least one Save operation.");
      }
   }
};


/***/ }),

/***/ 39966:
/*!**********************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskSubProcess.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SubProcessCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskSubProcessCore.js */ 12307);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class SubProcess extends SubProcessCore {
   ////
   //// Process Instance Methods
   ////

   /*
   propertyIDs(id) {
      return {
         name: `${id}_name`,
         isEnable: `${id}_isEnable`,
         parameterId: `${id}_parameterId`,
      };
   }

   /**
    * @method propertiesShow()
    * display the properties panel for this Process Element.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesShow(id) {
      let ids = this.propertyIDs(id);

      // Pull query tasks option list
      let parameterOptions = (this.process.processDataFields(this) || []).map(
         (item) => {
            return {
               id: item.key,
               value: item.label,
            };
         }
      );

      let ui = {
         id: id,
         view: "form",
         elementsConfig: {
            labelWidth: 120,
         },
         elements: [
            {
               id: ids.name,
               view: "text",
               label: L("Name"),
               name: "name",
               value: this.name,
            },
            {
               id: ids.isEnable,
               view: "switch",
               label: L("Enable"),
               value: this.isEnable,
            },
            {
               id: ids.parameterId,
               view: "richselect",
               label: L("Repeat for"),
               options: parameterOptions,
               value: this.parameterId,
            },
         ],
      };

      webix.ui(ui, $$(id));

      $$(id).show();
   }

   /**
    * @method propertiesStash()
    * pull our values from our property panel.
    * @param {string} id
    *        the webix $$(id) of the properties panel area.
    * /
   propertiesStash(id) {
      let ids = this.propertyIDs(id);
      this.name = this.property(ids.name);
      this.isEnable = this.property(ids.isEnable);
      this.parameterId = this.property(ids.parameterId);
   }
   */

   /**
    * @method diagramProperties()
    * return a set of values for the XML shape definition based upon
    * the current values of this object.
    * @return {json}
    */
   diagramProperties(bpmnModeler) {
      let props = super.diagramProperties();
      props = props || [{}];
      props[0].def = props[0].def || {};

      if (this.parameterId != null) {
         props[0].def = props[0].def || {};
         props[0].def.loopCharacteristics = bpmnModeler
            .get("moddle")
            .create("bpmn:MultiInstanceLoopCharacteristics");
         props[0].def.loopCharacteristics.isSequential = true;
      }

      return props;
   }

   /**
    * @method onChange()
    * update the current Task with information that was relevant
    * from the provided BPMN:Element
    * @param {BPMNElement}
    */
   onChange(defElement) {
      let loopCharacteristics =
         defElement.loopCharacteristics ||
         defElement.businessObject.loopCharacteristics ||
         {};

      switch (loopCharacteristics.$type) {
         case "bpmn:MultiInstanceLoopCharacteristics":
            this.loopType = loopCharacteristics.isSequential
               ? "sequential"
               : "parallel";
            break;
         case "bpmn:StandardLoopCharacteristics":
            this.loopType = "looping";
            break;
      }
   }

   /**
    * @method destroy()
    * destroy this sub process and inside tasks
    *
    * @return {Promise}
    */
   destroy() {
      // reuse .destroy function of ABProcess
      // to clear tasks within this sub process
      return this.process.destroy.call(this);
   }

   /**
    * @method save()
    * persist this sub process
    *
    * @return {Promise}
    *						.resolve( {this} )
    */
   save() {
      // reuse .save function of ABProcess
      // to update tasks within this sub process
      return this.process.save.call(this);
   }

   /**
    * @method elementNewForModelDefinition()
    * create a new process element defined by the given BPMN:Element
    *
    * the BPMN:Element definition comes from the BPMN Modeler when a new
    * diagram element is created.
    *
    * @param {BPMN:Element} element
    *        the BPMN modeler diagram element definition
    * @return {ABProcessParticipant|ABProcessLane|ABProcessElement}
    *
    */
   elementNewForModelDefinition(element) {
      let task = this.AB.processElementNewForModelDefinition(element, this);

      // Add a new task to this sub process
      if (task) {
         this.elementAdd(task);
      }
      return task;
   }

   warningsEval() {
      super.warningsEval();

      (this._unknownElementIDs || []).forEach((eID) => {
         this.warningMessage(
            `is referencing an unknown process element id[${eID}]`,
            { process: this.id, eID }
         );
      });
   }
};


/***/ }),

/***/ 46146:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskUserCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserCore.js */ 50271);

module.exports = class ABProcessTaskUser extends ABProcessTaskUserCore {};


/***/ }),

/***/ 31063:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUserApproval.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTaskUserApprovalCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserApprovalCore.js */ 92940);

module.exports = class ABProcessTaskUserApproval extends (
   ABProcessTaskUserApprovalCore
) {};


/***/ }),

/***/ 60986:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTaskUserExternal.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTaskUserExternalCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTaskUserExternalCore.js */ 10153);

module.exports = class ABProcessTaskUserExternal extends (
   ABProcessTaskUserExternalCore
) {};


/***/ }),

/***/ 19010:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTrigger.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// import ABApplication from "./ABApplication"
// const ABApplication = require("./ABApplication"); // NOTE: change to require()
const ABProcessTriggerCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerCore.js */ 44310);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTrigger extends ABProcessTriggerCore {};


/***/ }),

/***/ 16642:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTriggerLifecycle.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTriggerLifecycleCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerLifecycleCore.js */ 86555);

module.exports = class ABProcessTriggerLifecycle extends (
   ABProcessTriggerLifecycleCore
) {};


/***/ }),

/***/ 39009:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/process/tasks/ABProcessTriggerTimer.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABProcessTriggerTimerCore = __webpack_require__(/*! ../../../core/process/tasks/ABProcessTriggerTimerCore.js */ 47843);

const START_URL = "/process/timer/#id#/start";
const STOP_URL = "/process/timer/#id#/stop";

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABProcessTriggerTimer extends ABProcessTriggerTimerCore {
   /**
    * @method save()
    * persist this instance of ABObject with it's parent ABApplication
    * @return {Promise}
    */
   save() {
      return (
         Promise.resolve()
            .then(() => super.save())
            // Restart the timer
            .then((result) => {
               return this.AB.Network.put({
                  url: (this.isEnabled ? START_URL : STOP_URL).replace(
                     "#id#",
                     this.id
                  ),
               });
            })
      );
   }
};


/***/ }),

/***/ 15544:
/*!****************************************!*\
  !*** ./AppBuilder/platform/ql/ABQL.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */
const ABQLCore = __webpack_require__(/*! ../../core/ql/ABQLCore.js */ 61614);
const RowUpdater = (__webpack_require__(/*! ../RowUpdater.js */ 9234)["default"]);

const L = (...params) => AB.Multilingual.label(...params);

class ABQL extends ABQLCore {
   constructor(attributes, parameterDefinitions, prevOP, task, AB) {
      super(attributes, parameterDefinitions, prevOP, task, AB);

      this.on("warning", (message, data) => {
         this._warnings.push({ message, data });
      });
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      // const allColumns = row.getChildViews();
      // allColumns.shift(); // remove selector
      this.parameterDefinitions.forEach((pDef) => {
         // const col = allColumns.shift();
         const myID = this.uiID(id);

         this.ids = this.toIDs(myID);
         this.params = this.params ?? {};

         let $uiCondition = null;

         switch (pDef.type) {
            case "objectFields":
               this.params[pDef.name] = $$(this.ids.objectfields).getValue();

               break;

            case "objectName":
               this.params[pDef.name] = $$(this.ids.objectname).getValue();

               break;

            case "objectConditions":
            case "objectValues":
               $uiCondition = $$(this.ids.condition);

               if ($uiCondition) {
                  const condition = $uiCondition.getValue();

                  if (condition && condition !== "") {
                     this.params[pDef.name] = JSON.parse(condition);
                  }
               }

               break;

            case "taskParam":
               this.params[pDef.name] = $$(this.ids.taskparam).getValue();

               break;
         }
      });
   }

   /*
    * @method toIDs()
    * generate a set of unique webix ids to use for our UI.
    * @param {string} myID
    *        the unique id generated by .uiID()
    */
   toIDs(myID) {
      return {
         condition: `${myID}_condition`,
         objectfields: `${myID}_objectfields`,
         objectname: `${myID}_objname`,
         popup: `${myID}_popup`,
         select: `${myID}_select`,
         shorthand: `${myID}_shorthand`,
         taskparam: `${myID}_taskparam`,
         spacer: `${myID}_spacer`,
      };
   }

   /**
    * @method uiAddParamForDef()
    * Add an operation parameter for each parameterDefinition we have defined.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParamForDef(pDef, id, ui) {
      // params are added to a .col[] definition.
      // if our ui isn't down to the current .col element, then drill down
      if (!ui.cols) {
         if (ui.rows) {
            for (let i = 0; i < ui.rows.length; i++)
               if (ui.rows[i].cols) {
                  this.uiAddParamForDef(pDef, id, ui.rows[i]);

                  break;
               }
         } else throw new Error("provided ui is not able to add a parameter!");

         return;
      }

      const paramUI = this.uiParamUI(pDef, id);

      if (paramUI) {
         // if we only have 1 param
         if (this.parameterDefinitions.length === 1) {
            ui.cols.pop();
            ui.cols.push(paramUI);
         }
         // if we haven't already added a parameter
         else {
            // create a row stack of parameters:
            if (ui.cols.length < 3)
               ui.cols.push({
                  rows: [paramUI],
               });
            // add to the current stack of parameters
            else ui.cols[2].rows.push(paramUI);
         }
      }
   }

   /**
    * @method uiAddNext()
    * Add the next row selector for this operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddNext(id, ui) {
      const uiRow = this.uiNextRow(id);

      // if we have a next operation defined, then add on the ui definitions
      // for that operation:
      if (this.next) {
         this.next.uiAddParams(id, uiRow);
         ui.rows.push(uiRow);
         this.next.uiAddNext(id, ui);
      }
      // otherwise we just leave the selector:
      else ui.rows.push(uiRow);
   }

   /**
    * @method uiAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParams(id, ui) {
      this.parameterDefinitions.forEach((pDef) => {
         this.uiAddParamForDef(pDef, id, ui);
      });
   }

   /*
    * @method uiID()
    * generate a unique webix id for this operation.
    * @param {string} id
    *        the webix id of the base property.query holder
    */
   uiID(id) {
      if (this.prevOP) return `${this.prevOP.uiID(id)}_${this.constructor.key}`;

      return `${id}_${this.constructor.key}`;
   }

   /*
    * uiXXX Operations:
    * are UI building operations that are performed BEFORE the webix UI
    * is generated.  They work by filling out a {ui} object definition
    * that webix will eventually create into the DOM.
    *
    * viewXXX Operations:
    * are UI building operations that are performed AFTER the webix UI
    * is generated. They work by adding in child views to an existing
    * DOM.
    */

   /**
    * @method uiNextRow()
    * return the webix UI definition for the next of UI chaining.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiNextRow(id) {
      const options = this.constructor.NextQLOps.map((op) => {
         return { id: op.key, value: op.label };
      });

      options.unshift({ id: 0, value: L("choose next operation") });

      const myID = this.uiID(id);
      const ids = this.toIDs(myID);

      const uiRow = {
         cols: [
            {
               id: ids.select,
               view: "select",
               value: this.next ? this.next.constructor.key : 0,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     const resetValue = () => {
                        const select = $$(ids.select);

                        select.blockEvent();
                        select.setValue(oldValue);
                        select.unblockEvent();
                     };

                     if (newValue === oldValue) return;

                     const newOP = this.constructor.NextQLOps.find(
                        (op) => op.key === newValue
                     );

                     if (!newOP) {
                        resetValue();

                        return;
                     }

                     const thisRow = $$(ids.select).getParentView();
                     const thisQuery = thisRow.getParentView();
                     const addOP = () => {
                        if (newOP) {
                           const nextOP = new newOP(
                              {},
                              this,
                              this.task,
                              this.AB
                           );

                           this.next = nextOP;

                           nextOP.viewAddParams(id, thisRow);
                           nextOP.viewAddNext(id, thisQuery);
                        }
                     };

                     // if there are rows after this one, then warn
                     // about changing
                     const allRows = thisQuery.getChildViews();

                     if (allRows.length - 1 > allRows.indexOf(thisRow))
                        webix.confirm({
                           title: L("continue?"),
                           text: L(
                              "changing this rule will reset any following rules."
                           ),
                           ok: L("Yes"),
                           cancel: L("No"),
                           callback: (result) => {
                              if (result) {
                                 // remove the current additional Rows:
                                 let ir = allRows.length - 1;

                                 while (
                                    allRows[ir].config.id !== thisRow.config.id
                                 ) {
                                    thisQuery.removeView(allRows[ir]);
                                    ir--;
                                 }

                                 // now remove the parameters
                                 const allCols = thisRow.getChildViews();

                                 let ic = allCols.length;

                                 while (ic > 1) {
                                    thisRow.removeView(allCols[ic - 1]);
                                    ic--;
                                 }

                                 addOP();
                              } else resetValue();
                           },
                        });
                     else addOP();
                  },
               },
            },
            {
               id: ids.spacer,
            },
         ],
      };

      return uiRow;
   }

   uiNextRowSelectorRefresh(id) {
      const $select = $$(this.ids.select);

      if (!$select) return;

      const uiNextRow = this.uiNextRow(id);

      const uiNextCol =
         uiNextRow.cols.filter((c) => c.id == $select.config.id)[0] ??
         uiNextRow.cols[1];

      if (uiNextCol) AB.Webix.ui(uiNextCol, $select);
   }

   /**
    * @method uiParamUI()
    * return the webix UI definition for the parameter entry of this current
    * operation.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiParamUI(pDef, id) {
      const uiConfig = AB.Config.uiSettings();

      let myID = this.uiID(id);

      this.ids = this.toIDs(myID);

      let paramUI = null;
      let options = null;
      let Filter = null;
      let hashFieldIDs = null;
      let initialCond = null;
      let displayLabel = null;
      let initialValue = null;
      let Updater = null;
      let popUp = null;

      // now add the parameter
      switch (pDef.type) {
         case "objectFields":
            // an objectFields parameter returns a select list of fields
            // available on an Object.
            if (this.object)
               options = this.object.fields().map((f) => {
                  return { id: f.id, value: f.label, icon: `fa fa-${f.icon}` };
               });

            options.unshift({
               id: "_PK",
               value: "[PK]",
            });

            // if not set, default .fieldID to the 1st entry in options
            // so we will have a default.  In use, if a user sees the
            // 1st item and continues on, then we will have chosen it.
            if (!this.fieldID && options.length > 0) {
               // act like it was selected:
               this.params[pDef.name] = options[0].id;
               this.paramChanged(pDef, id);
            }

            paramUI = {
               id: this.ids.objectfields,
               view: "richselect",
               label: L("Field"),
               labelWidth: 70,
               value: this.fieldID,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;

         case "objectName":
            // an objectName parameter returns a select list of available
            // objects in this ABFactory.
            options = this.AB.objects().map((o) => {
               return { id: o.id, value: o.label };
            });

            if (!this.objectID && options.length > 0) {
               this.objectID = options[0].id;
               this.params[pDef.name] = this.objectID;
               this.paramChanged(pDef);
            }

            paramUI = {
               id: this.ids.objectname,
               view: "select",
               label: L("Data Source"),
               labelWidth: uiConfig.labelWidthLarge,
               value: this.objectID,
               options: options,
               on: {
                  onChange: (newValue /*, oldValue */) => {
                     this.params = this.params ?? {};

                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef);
                     }
                  },
               },
            };

            break;

         case "objectConditions":
            // objectConditions: returns a filter text summary, that when
            // clicked, pops up a Filter Entry Popup.
            // the actual value is stored in a hidden field.

            // we will create a new FilterComplex() object to use for our
            // filtering.
            // Our goal is to create a special filter entry for each avaiable
            // process data value that is available.
            // A filter entry needs to look like:
            // {
            //     id: `{string}`,      // A unique id selector for this filter
            //     name: `{string}`,    // the operation name displayed
            //     type, {obj}          // an object defining the editor to show
            //     fn: ()=>{}           // a function used for filtering elements
            // }
            //
            // In our filters, we are assigning filters to EACH field by the
            // field.id.  So the type definition needs to look like:
            // {
            //     "uniqueID of the field (field.id)" : {webixUI definition}
            // }

            Filter = this.AB.filterComplexNew(id);
            hashFieldIDs = this.availableProcessDataFieldsHash();

            if (this.object) {
               Filter.fieldsLoad(this.object.fields(), this.object);
               // NOTE: this will create default filters based upon the
               // object fields() and their types

               // Now we need to add in the Process Data Fields:
               // for each Process Data Field that matches our same object
               const foundFields = Object.keys(hashFieldIDs).map(
                  (f) => hashFieldIDs[f]
               );

               Filter.processFieldsLoad(foundFields);
               /*
               (foundFields ?? []).forEach((processField) => {
                  const type = {};
                  if (processField.field) {
                     type[processField.field.id] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  } else {
                     // if there is no .field, it is probably an embedded special field
                     // like: .uuid
                     const key = processField.key.split(".").pop();
                     type[key] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  }

                  // add an "equals" and "not equals" filter for each:
                  Filter.filterAdd([
                     {
                        id: `context_equals`,
                        name: `equals`,
                        type,
                        fn: (a, b) => {
                           return a === b;
                        }
                     },
                     {
                        id: `context_not_equal`,
                        name: `not equals`,
                        type,
                        fn: (a, b) => {
                           return a !== b;
                        }
                     }
                  ]);
                  
               }); */
            }

            // every time the Filter "saves" it's data, it emits this event:
            // take the given condition and store it in our hidden element.
            Filter.on("save", (condition) => {
               // @param {obj} condition an object describing the filter
               // condition.

               this.params = this.params ?? {};
               this.params[pDef.name] = condition;

               const shortHand = $$(this.ids.shorthand);

               shortHand.define({
                  label: Filter.toShortHand(),
               });
               shortHand.refresh();

               // NOTE: the hidden element is a text field, so convert the
               // {condition object} => a string
               const elCondition = $$(this.ids.condition);

               elCondition.define({
                  value: JSON.stringify(this.params[pDef.name]),
               });
               elCondition.refresh();
            });

            // create the initial condition value from our inputs.
            initialCond = "";

            if (this.params && this.params[pDef.name]) {
               Filter.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            } else {
               Filter.setValue(null);
            }

            // what we show on the panel, is a text representation
            // of the current condition.
            displayLabel = Filter.toShortHand();

            paramUI = {
               rows: [
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: displayLabel,
                     on: {
                        onItemClick: () => {
                           Filter.popUp($$(this.ids.shorthand), null, {
                              pos: "center",
                           });
                        },
                     },
                  },
                  // have a hidden field to contain the condition
                  // value we will parse out later
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true,
                  },
               ],
            };

            break;

         case "objectValues":
            // objectValues : shows a condenced textual representation of the
            // field => value changes.  Clicking on the text will show a popup
            // that allows you to add/remove additional field updates for
            // the current object.

            initialValue = "";
            Updater = new RowUpdater(myID, this.AB);

            if (this.object) Updater.objectLoad(this.object);

            // Set processed data key to value options
            Updater.setExtendedOptions(
               (this.task.process.processDataFields(this.task) ?? []).map(
                  (item) => {
                     return {
                        id: item.key,
                        value: item.label,
                     };
                  }
               )
            );

            // NOTE: .setValue() must be called once the RowUpdater is already
            // displayed.  See the end of popUp() below:
            if (this.params && this.params[pDef.name]) {
               Updater.setValue(this.params[pDef.name]);
               initialValue = JSON.stringify(this.params[pDef.name]);
            }

            popUp = () => {
               // show the RowUpdater in a popup:
               const ui = {
                  id: this.ids.popup,
                  view: "popup",
                  position: "center",
                  minWidth: 700,
                  modal: true,
                  resize: true,
                  body: {
                     rows: [
                        {
                           height: 30,
                           borderless: true,
                           cols: [
                              { fillspace: true },
                              {
                                 view: "button",
                                 value: "X",
                                 width: 30,
                                 click: () => {
                                    $$(this.ids.popup).hide();
                                 },
                              },
                           ],
                        },
                        Updater.ui(),
                        {
                           view: "button",
                           value: L("Save"),
                           css: "webix_primary",
                           click: () => {
                              this.params = this.params ?? {};
                              this.params[pDef.name] = Updater.getValue();
                              const sh = $$(this.ids.shorthand);

                              sh.define({
                                 badge: this.params[pDef.name].length,
                              });
                              sh.refresh();

                              const cond = $$(this.ids.condition);

                              cond.define({
                                 value: JSON.stringify(this.params[pDef.name]),
                              });
                              cond.refresh();

                              $$(this.ids.popup).hide();
                           },
                        },
                     ],
                  },
               };

               // create and show the popup
               this._myPopup = webix.ui(ui);
               this._myPopup.show();

               // NOTE: on a RowUpdater, the values need to be set
               // AFTER it is displayed:
               if (this.params && this.params[pDef.name])
                  Updater.setValue(this.params[pDef.name]);
            };

            paramUI = {
               rows: [
                  // the textual shorthand for these values
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: L("Update Popout"),
                     badge: this.params[pDef.name]?.length,
                     on: {
                        onItemClick: () => {
                           popUp();
                        },
                     },
                  },
                  // the hidden field that contains the results
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialValue,
                     hidden: true,
                  },
               ],
            };

            break;

         case "taskParam":
            paramUI = {
               id: this.ids.taskparam,
               view: "text",
               label: L("Variable"),
               labelWidth: 70,
               value: this.params[pDef.name],
               placeholder: L("Enter parameter name"),
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;
      }

      return paramUI;
   }

   /**
    * @method viewAddNext()
    * Add the next selector row After this Operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} topView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the top container that is adding a new
    *        row for each operation.
    */
   viewAddNext(id, topView) {
      const uiRow = this.uiNextRow(id);

      topView.addView(uiRow);
   }

   /**
    * @method viewAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} rowView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the ROW that the parameters are added to
    */
   viewAddParams(id, rowView) {
      const params = [];

      this.parameterDefinitions.forEach((pDef) => {
         // get the definition from .uiParamUI()
         params.push(this.uiParamUI(pDef, id));
      });

      let toInsert = null;

      // stack parameters in a row if there are more than 1
      if (params.length > 1)
         toInsert = {
            rows: params,
         };
      else toInsert = params.pop();

      if (toInsert) {
         rowView.removeView(rowView.getChildViews()[1]);
         rowView.addView(toInsert);
      }
   }

   warnings() {
      let myWarnings = this._warnings || [];
      if (this.next)
         myWarnings = myWarnings.concat(this.next.warnings()).filter((w) => w);
      return this.AB.uniq(myWarnings);
   }

   warningsEval() {
      this._warnings = [];
      if (this.next) this.next.warningsEval();
   }

   // warningsAll() {
   //    let myWarnings = this.warnings();
   //    if (this.next) {
   //       myWarnings = myWarnings.concat(this.next.warningsAll());
   //    }
   //    return myWarnings;
   // }

   /**
    * @method warningMessage(message)
    * Save a warning message in a common format for our ProcessTasks.
    */
   warningMessage(message) {
      // this.emit("warning", `${this.key}: ${message}`);
      this._warnings = this._warnings || [];
      this._warnings.push({ message: `${this.key}: ${message}` });
   }

   ////
   //// QueryString Parser routines:
   ////
}

module.exports = ABQL;


/***/ }),

/***/ 88484:
/*!********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLFind
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */
const ABQLFindCore = __webpack_require__(/*! ../../core/ql/ABQLFindCore.js */ 64732);

class ABQLFind extends ABQLFindCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}

module.exports = ABQLFind;


/***/ }),

/***/ 25433:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLManager.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLManager
 *
 * An interface for managing the different ABQL Operations available in our
 * AppBuilder.
 *
 */

const ABQLManagerCore = __webpack_require__(/*! ../../core/ql/ABQLManagerCore.js */ 45430);
const ABQLRootObject = __webpack_require__(/*! ./ABQLRootObject.js */ 39700);

const ABQLManager = {
   /**
    * @method fromAttributes()
    * return an {ABQL} object that represents the given attributes that
    * were saved from the previous .toObj()
    * @param {object} attributes
    *		  the values returned from the previous .toObj() call
    * @param {ABProcessTask***} task
    *		  the current ABProcessTaskServiceQuery that contains this QL
    * @param {ABFactory} AB
    *		  the current {ABFactory} active for this interface.
    * @return {ABQL} | null
    */
   fromAttributes: ABQLManagerCore.fromAttributes,

   /**
    * @method ids()
    * return a set of unique webix ids for the ui portions of this object.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @return {object}
    */
   ids: (id) => {
      return {
         root: `${id}_root`,
         select: `${id}_root_select`,
         options: `${id}_root_options`,
      };
   },

   /**
    * @method builder
    * return a UI component like object that will display the QL builder.
    * The component will support:
    *		.ui(id) : returns a webix ui definition for the current builder
    *		.init(id) : performs any special actions to prepare the webix ui
    * @param {object} rootOP
    *		  the root ABQLxxxx operation
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} active for this display.
    * @return {object}
    */
   builder: (rootOP, task, AB) => {
      // const rootOP = this.fromAttributes(attributes, task, AB);
      // const L = (...params) => AB.Multilingual.label(...params);

      return {
         ui: (id) => {
            rootOP = rootOP ?? new ABQLRootObject({}, task, AB);

            const ids = ABQLManager.ids(id);
            const ui = {
               rows: [
                  {
                     id: ids.root,
                     cols: [],
                  },
               ],
            };

            rootOP.uiAddParams(id, ui);
            rootOP.uiAddNext(id, ui);

            return ui;
         },
         init: (id) => {},
      };
   },

   /**
    * @method parse
    * step through the current properties panel and decode the QL objects
    * and their parameters.
    * Return the .toOBJ() attributes definition as a result.
    * @param {string} id
    *		  the webix base id of the parameters panel.
    * @param {ABProcessTask***} task
    *		  the current Process Task that is requesting the data.
    * @param {ABFactory} AB
    *		  the {ABFactory} object that is currently active.
    * @return {object}
    */
   parse: (id, task, AB) => {
      const ids = ABQLManager.ids(id);
      const root = $$(ids.root);

      if (!root) {
         console.warn("ABQLManager.parse(): unable to find root element");

         return;
      }

      // get all the input rows
      const rows = root.getParentView().getChildViews();

      const parseCurrent = (rows, options, prevOP) => {
         if (rows.length === 0) return null;

         const row = rows.shift();

         // get which operation was selected
         // find the operation selector (skip any indents)
         const views = row.getChildViews();

         let selector = views.shift();

         while (!selector?.getValue) selector = views.shift();

         const value = selector.getValue();

         // figure out the QLOP object
         const OP = options.find((o) => {
            return o.key === value || o.key === ABQLRootObject.key;
         });

         if (OP) {
            let currOP = null;

            if (prevOP) currOP = new OP({}, prevOP, task, AB);
            else currOP = new OP({}, task, AB);

            // now get currOP to initialize from it's parameters:
            currOP.parseRow(row, id);

            // carry forward any .object info if not already established
            // by the .parseRow():
            if (!currOP.object && prevOP) {
               currOP.object = prevOP.object;
               currOP.objectID = currOP.object?.id ?? null;
            }

            const nextRow = parseCurrent(
               rows,
               currOP.constructor.NextQLOps,
               currOP
            );

            currOP.next = nextRow;

            return currOP;
         }

         return null;
      };

      const operation = parseCurrent(rows, ABQLManagerCore.QLOps, null);

      return operation;
   },
};

module.exports = ABQLManager;


/***/ }),

/***/ 39700:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRootObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRootObject
 *
 * An ABQL defines a Query Language Operation. A QL Operation
 * is intended to be evaluated at run time and return a value that can be
 * assigned to form value or an object.
 *
 *
 */

const ABQLRootObjectCore = __webpack_require__(/*! ../../core/ql/ABQLRootObjectCore.js */ 45655);

class ABQLObject extends ABQLRootObjectCore {
   // constructor(attributes, task, application) {
   //     // NOTE: keep this so we can insert the prevOp === null
   //     super(attributes, ParameterDefinitions, null, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "name") {
         this.objectID = this.params[pDef.name];
         this.object = this.objectLookup(this.objectID);

         // ?? is this correct?
         // if we already have created a .next operation, and we have
         // just changed our .object, pass that information forward.
         if (this.next) this.next.object = this.object;
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      // for an Object operation, we need to set our .objectID after
      // the values are parsed.

      if (this.params.name) {
         this.objectID = this.params.name;
         this.object = this.objectLookup(this.params.name);
      }
   }

   warningsEval() {
      super.warningsEval();
      if (!this.object) {
         this.warningMessage("has no object set.", {
            objectID: this.objectID,
         });
      }
   }
}

module.exports = ABQLObject;


/***/ }),

/***/ 93725:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowPluck.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABQLRowPluckCore = __webpack_require__(/*! ../../core/ql/ABQLRowPluckCore.js */ 38109);

class ABQLRowPluck extends ABQLRowPluckCore {
   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef, id) {
      super.paramChanged(pDef);

      // Re-generate next select options
      if (pDef.name === "fieldID") this.uiNextRowSelectorRefresh(id);
   }
}

module.exports = ABQLRowPluck;


/***/ }),

/***/ 63622:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowSave.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowSave
 *
 * An ABQLRowSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLRowSaveCore = __webpack_require__(/*! ../../core/ql/ABQLRowSaveCore.js */ 39580);

class ABQLRowSave extends ABQLRowSaveCore {
   paramChanged(pDef, id) {
      super.paramChanged(pDef);
   }
}

module.exports = ABQLRowSave;


/***/ }),

/***/ 19602:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLRowUpdate.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLRowUpdate
 *
 * An ABQLRow Update allows you to update the values on the current
 * Row of data.
 *
 */

const ABQLRowUpdateCore = __webpack_require__(/*! ../../core/ql/ABQLRowUpdateCore.js */ 47947);

class ABQLRowUpdate extends ABQLRowUpdateCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, ParameterDefinitions, prevOP, task, application);
   //     // #Hack! : when an Operation provides the same .NextQlOps that it
   //     // was defined in, we can't require it again ==> circular dependency.
   //     // so we manually set it here from the operation that created us:
   //     this.constructor.NextQLOps = prevOP.constructor.NextQLOps;
   // }
   ///
   /// Instance Methods
   ///
}

module.exports = ABQLRowUpdate;


/***/ }),

/***/ 21790:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetFirst.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetFirst
 *
 * An ABQLFind depends on a BASE QL object (Object, Datacollection, Query)
 * and can perform a DB query based upon that BASE object.
 *
 */

const ABQLSetFirstCore = __webpack_require__(/*! ../../core/ql/ABQLSetFirstCore.js */ 1947);

class ABQLSetFirst extends ABQLSetFirstCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///
}

module.exports = ABQLSetFirst;


/***/ }),

/***/ 6517:
/*!************************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetPluck.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetPluck
 *
 * An ABQLSetPluck can process a set (array) of data and pluck out a specified
 * field from each row to then make an array of values that only contain that 
 * field.
 * 
 * Example: 
array = [
 {
	name: "Neo",
	email: "neo@thematrix.com",
	relationships: [ { morpheous}, {trinity} ]
 },
 {
	name: "trinity",
	email: "trinity@thematrix.com",
	relationships: [ {neo}, {morpheous} ]
 },
 {
	name: "morpheous",
	email: "morpheous@thematrix.com",
	relationships: [ {neo}, {trinity}]
 }

]

pluck("email") :
	[
		"neo@thematrix.com",
		"trinity@thematrix.com",
		"morpheous@thematrix.com"
	]

pluck("relationships"):
	[
		{neo},
		{trinity},
		{morpheous}
	]
 *
 */

const ABQLSetPluckCore = __webpack_require__(/*! ../../core/ql/ABQLSetPluckCore.js */ 93740);

class ABQLSetPluck extends ABQLSetPluckCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "fieldID") {
         // debugger;
         this.fieldID = this.params[pDef.name];
         // v2 method:
         // this.field = this.object.fieldByID(this.fieldID);
         this.field = this.object.fieldByID(this.fieldID);

         // v2 method:
         // if (this.field && this.field.isConnected) {
         if (this.field && this.field.key === "connectObject") {
            this.objectOut = this.field.datasourceLink;
            this.objectOutID = this.objectOut.id;

            // ?? is this correct?
            // if we already have created a .next operation, and we have
            // just changed our .object, pass that information forward.
            if (this.next) this.next.object = this.objectOut;
         }
      }
   }

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * NOTE: in this process our .object and .objectOut isn't as simple
    * as the other QL node types.  We'll have to interpolate our values
    * from the given fieldID in our property panel.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      super.parseRow(row, id);

      this.fieldID = this.params.fieldID;

      // we now have to build backwards from the current fieldID to set our
      // relevant .object and .objectOut
      this.AB.objects((o) => {
         if (!this.field) {
            // const field = o.fieldByID(this.fieldID);
            const field = o.fieldByID(this.fieldID);

            if (field) this.field = field;
         }
      });

      if (this.field) {
         this.object = this.field.object;

         // v2 method:
         // if (this.field.isConnected) {
         if (this.field && this.field.key === "connectObject") {
            this.objectOut = this.field.datasourceLink;
            this.objectOutID = this.objectOut.id;
         }
      }
   }
}

module.exports = ABQLSetPluck;


/***/ }),

/***/ 23698:
/*!***********************************************!*\
  !*** ./AppBuilder/platform/ql/ABQLSetSave.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABQLSetSave
 *
 * An ABQLSetSave can store the current Data set into the Process Task it is
 * in, so that this data can be made available to other Process Tasks.
 *
 */

const ABQLSetSaveCore = __webpack_require__(/*! ../../core/ql/ABQLSetSaveCore.js */ 86918);

class ABQLSetSave extends ABQLSetSaveCore {
   // constructor(attributes, prevOP, task, application) {
   //     super(attributes, [], prevOP, task, application);
   // }
   ///
   /// Instance Methods
   ///

   /*
    * @method paramChanged()
    * respond to an update to the given parameter.
    * NOTE: the value will ALREADY be saved in this.params[pDef.name].
    * @param {obj} pDef
    *        the this.parameterDefinition entry of the parameter that was
    *        changed.
    */
   paramChanged(pDef) {
      if (pDef.name === "task_param") {
         this.taskParam = this.params[pDef.name];
      }
   }

   parseRow(row, id) {
      super.parseRow(row, id);

      this.taskParam = this.params["task_param"];

      if (!this.registered) {
         this.task.registerDatasource(this);
         this.registered = true;
      }
   }

   warningsEval() {
      super.warningsEval();
      if (!this.taskParam || this.taskParam === "") {
         this.warningMessage("requires a name to save our data as.");
      }
   }
}

module.exports = ABQLSetSave;


/***/ }),

/***/ 94784:
/*!*********************************************!*\
  !*** ./AppBuilder/platform/views/ABView.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCore = __webpack_require__(/*! ../../core/views/ABViewCore.js */ 2063);
const ABViewComponent = (__webpack_require__(/*! ./viewComponent/ABViewComponent */ 44363)["default"]);

module.exports = class ABView extends ABViewCore {
   // constructor(attributes, application, parent) {
   //    super(attributes, application, parent);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewComponent(this);
   }

   /*
    * @method componentList
    * return the list of components available on this view to display in the editor.
    * @param {bool} isEdited  is this component currently in the Interface Editor
    * @return {array} of ABView objects.
    */
   componentList(isEdited) {
      // views not allowed to drop onto this View:
      var viewsToIgnore = [
         "view",
         "page",
         "formpanel",
         "viewcontainer",
         // not allowed Detail's widgets
         "detailcheckbox",
         "detailcustom",
         "detailconnect",
         "detailimage",
         "detailselectivity",
         "detailtext",
         "detailtree",
         // not allowed Form's widgets
         "button",
         "checkbox",
         "connect",
         "datepicker",
         "fieldcustom",
         "textbox",
         "numberbox",
         "selectsingle",
         "selectmultiple",
         "formtree",
         "fieldreadonly",
         // not allowed Chart's Widgets
         "pie",
         "bar",
         "line",
         "area",
         // not allowed Report page
         "report",
         "reportPage",
         "reportPanel",
      ];

      var allComponents = this.application.viewAll(); // ABViewManager.allViews();
      var allowedComponents = allComponents.filter((c) => {
         return viewsToIgnore.indexOf(c.common().key) == -1;
      });

      return allowedComponents;
   }

   changePage(pageId) {
      this.emit("changePage", pageId);
   }

   warningsAll() {
      // report both OUR warnings, and any warnings from any of our fields
      var allWarnings = super.warningsAll();
      this.views().forEach((v) => {
         allWarnings = allWarnings.concat(v.warningsAll());
      });

      (this.pages?.() || []).forEach((p) => {
         allWarnings = allWarnings.concat(p.warningsAll());
      });

      return allWarnings.filter((w) => w);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      (this.__missingViews || []).forEach((id) => {
         this.warningsMessage(`references unknown View[${id}]`);
      });

      allViews.forEach((v) => {
         v.warningsEval();
      });

      // if a datacollection is specified, verify it can be accessed.
      if (this.settings.dataviewID) {
         let dc = this.datacollections || this.datacollection;
         if (!dc) {
            this.warningsMessage(
               `references unknown dataviewID[${this.settings.dataviewID}]`
            );
         }
      }
   }

   warningsMessage(msg, data = {}) {
      let message = `${this.key}[${this.name}]: ${msg}`;
      this._warnings.push({ message, data });
   }
};


/***/ }),

/***/ 11200:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCSVExporter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCSVExporterCore = __webpack_require__(/*! ../../core/views/ABViewCSVExporterCore */ 88076);
const ABViewCSVExporterComponent = __webpack_require__(/*! ./viewComponent/ABViewCSVExporterComponent */ 26822);

module.exports = class ABViewCSVExporter extends ABViewCSVExporterCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj } UI component
    */
   component() {
      return new ABViewCSVExporterComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
};


/***/ }),

/***/ 74841:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCSVImporter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCSVImporterCore = __webpack_require__(/*! ../../core/views/ABViewCSVImporterCore */ 22152);
const ABViewCSVImporterComponent = __webpack_require__(/*! ./viewComponent/ABViewCSVImporterComponent */ 67090);

module.exports = class ABViewCSVImporter extends ABViewCSVImporterCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component(idBase) {
      return new ABViewCSVImporterComponent(this, idBase);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }

      if (!this.settings.availableFieldIds?.length) {
         this.warningsMessage("has no fields set for matching import data");
      }
   }
};


/***/ }),

/***/ 64422:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewCarousel.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCarousel)
/* harmony export */ });
/* harmony import */ var _viewComponent_ABViewCarouselComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewComponent/ABViewCarouselComponent */ 67511);
/* harmony import */ var _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyFilterData */ 43348);
/* harmony import */ var _viewProperties_ABViewPropertyLinkPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 25733);
const ABViewCarouselCore = __webpack_require__(/*! ../../core/views/ABViewCarouselCore */ 474);


// const ABViewPropertyFilterData = require("./viewProperties/ABViewPropertyFilterData");
// const ABViewPropertyLinkPage = require("./viewProperties/ABViewPropertyLinkPage");




let PopupCarouselFilterMenu = null;

class ABViewCarousel extends ABViewCarouselCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // filter property
      this.filterHelper.fromSettings(this.settings.filter);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      var dv = this.datacollection;
      if (dv) {
         this.filterHelper.objectLoad(dv.datasource);
         this.filterHelper.fromSettings(this.settings.filter);
      }

      return new _viewComponent_ABViewCarouselComponent__WEBPACK_IMPORTED_MODULE_0__["default"](this);
   }

   get idBase() {
      return `ABViewCarousel_${this.id}`;
   }

   get filterHelper() {
      if (this.__filterHelper == null)
         this.__filterHelper = new _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_1__["default"](
            this.AB,
            this.idBase
         );

      return this.__filterHelper;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new _viewProperties_ABViewPropertyLinkPage__WEBPACK_IMPORTED_MODULE_2__["default"]();

      return this.__linkPageHelper;
   }

   warningsEval() {
      super.warningsEval();

      let field = this.imageField;
      if (!field) {
         this.warningsMessage(
            `can't resolve image field[${this.settings.field}]`
         );
      }
   }
}


/***/ }),

/***/ 73936:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChart.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartCore = __webpack_require__(/*! ../../core/views/ABViewChartCore */ 34263);
const ABViewChartComponent = __webpack_require__(/*! ./viewComponent/ABViewChartComponent */ 26869);

module.exports = class ABViewChart extends ABViewChartCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartComponent(this);
   }

   fromValues(values) {
      super.fromValues(values);
      this.refreshData();
   }

   getDCChart() {
      if (!this._dcChart) this._dcChart = new webix.DataCollection();

      return this._dcChart;
   }

   refreshData() {
      const dc = this.datacollection;
      if (dc == null) return this.dcChart;

      const labelCol = this.labelField();
      const valueCol = this.valueField();
      const valueCol2 = this.valueField2();

      if (!labelCol || !valueCol) return this.dcChart;

      // const labelColName = labelCol.columnName;
      const numberColName = valueCol.columnName;

      let numberColName2 = "";

      if (this.settings.multipleSeries && valueCol2) {
         numberColName2 = valueCol2.columnName;
      }

      const colorList = [
         "#ee4339",
         "#ee9336",
         "#eed236",
         "#d3ee36",
         "#a7ee70",
         "#58dccd",
         "#36abee",
         "#476cee",
         "#a244ea",
         "#e33fc7",
      ];

      const dInfo = dc.getData();

      let results = [];
      let sumData = {};
      let sumNumber = 0;
      let sumNumber2 = 0;
      let countNumber = dInfo.length;

      dInfo.forEach((item) => {
         const labelKey = labelCol.format(item) || item.id;

         let numberVal = parseFloat(item[numberColName] || 0);
         let numberVal2 = null;

         if (this.settings.multipleSeries)
            numberVal2 = parseFloat(item[numberColName2]) || 0;

         switch (valueCol.key) {
            //Formula Datatype
            case "formula":
               numberVal = valueCol.format(item);

               break;

            //Calcualte Datatype
            case "calculate":
               numberVal = parseFloat(
                  valueCol.constructor.convertToJs(
                     valueCol.object,
                     valueCol.settings.formula,
                     item,
                     valueCol.settings.decimalPlaces
                  )
               );

               break;

            default:
               break;
         }

         if (sumData[labelKey] == null) {
            let label = labelKey;

            // Get label of the connect field
            if (labelCol.isConnection) {
               let relateValues = labelCol.pullRelationValues(item);
               if (relateValues != null) {
                  if (Array.isArray(relateValues))
                     label = relateValues
                        .map((val) => val.text || "")
                        .join(", ");
                  else label = relateValues.text;
               }
            }

            if (this.settings.multipleSeries) {
               sumData[labelKey] = {
                  label: label || item.id,
                  value: 0,
                  value2: 0,
               };
            } else {
               sumData[labelKey] = {
                  label: label || item.id,
                  value: 0,
               };
            }
         }

         sumData[labelKey].value += numberVal;
         sumNumber += numberVal;

         if (this.settings.multipleSeries) {
            sumData[labelKey].value2 += numberVal2;
            sumNumber2 += numberVal2;
         }
      });

      let index = 0;

      for (const key in sumData) {
         let val = sumData[key].value;

         if (val <= 0) continue;

         // Display to percent values
         if (this.settings.isPercentage) {
            val = (val / sumNumber) * 100;
            val = Math.round(val * 100) / 100; // round decimal 2 digits
            val = val + " %";
         }

         if (this.settings.multipleSeries) {
            let val2 = sumData[key].value2;

            if (val2 <= 0) continue;

            // Display to percent values
            if (this.settings.isPercentage) {
               val2 = (val2 / sumNumber2) * 100;
               val2 = Math.round(val2 * 100) / 100; // round decimal 2 digits
               val2 = val2 + " %";
            }

            results.push({
               label: sumData[key].label,
               value: val,
               value2: val2,
               color: colorList[index % colorList.length],
               count: countNumber,
            });
         } else {
            results.push({
               label: sumData[key].label,
               value: val,
               color: colorList[index % colorList.length],
               count: countNumber,
            });
         }

         index += 1;
      }

      const dcChart = this.getDCChart();

      dcChart.clearAll();
      dcChart.parse(results);
   }

   warningsEval() {
      super.warningsEval();

      let labelField = this.labelField();
      if (!labelField) {
         this.warningsMessage(
            `can't resolve label field[${this.settings.columnLabel}]`
         );
      }

      let valueField = this.valueField();
      if (!valueField) {
         this.warningsMessage(
            `can't resolve value field[${this.settings.columnValue}]`
         );
      }
   }
};


/***/ }),

/***/ 2909:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartArea.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartAreaCore = __webpack_require__(/*! ../../core/views/ABViewChartAreaCore */ 47493);
const ABViewChartAreaComponent = __webpack_require__(/*! ./viewComponent/ABViewChartAreaComponent */ 80651);

module.exports = class ABViewChartArea extends ABViewChartAreaCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartAreaComponent(this);
   }
};


/***/ }),

/***/ 69623:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartBar.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartBarCore = __webpack_require__(/*! ../../core/views/ABViewChartBarCore */ 5163);
const ABViewChartBarComponent = __webpack_require__(/*! ./viewComponent/ABViewChartBarComponent */ 87139);

module.exports = class ABViewChartBar extends ABViewChartBarCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartBarComponent(this);
   }
};


/***/ }),

/***/ 55988:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartContainer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidget = __webpack_require__(/*! ./ABViewWidget */ 4814);
const ABViewChartContainerComponent = __webpack_require__(/*! ./viewComponent/ABViewChartContainerComponent */ 71233);

module.exports = class ABViewChartContainer extends ABViewWidget {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartContainerComponent(this);
   }

   get datacollection() {
      return this.parent.datacollection;
   }
};


/***/ }),

/***/ 6765:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartLine.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartLineCore = __webpack_require__(/*! ../../core/views/ABViewChartLineCore */ 86094);
const ABViewChartLineComponent = __webpack_require__(/*! ./viewComponent/ABViewChartLineComponent */ 52564);

module.exports = class ABViewChartLine extends ABViewChartLineCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartLineComponent(this);
   }
};


/***/ }),

/***/ 28280:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewChartPie.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartPieCore = __webpack_require__(/*! ../../core/views/ABViewChartPieCore */ 92835);
const ABViewChartPieComponent = __webpack_require__(/*! ./viewComponent/ABViewChartPieComponent */ 48370);

module.exports = class ABViewChartPie extends ABViewChartPieCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewChartPieComponent(this);
   }
};


/***/ }),

/***/ 39058:
/*!****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewComment.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewCommentCore = __webpack_require__(/*! ../../core/views/ABViewCommentCore */ 46767);
const ABViewCommentComponent = __webpack_require__(/*! ./viewComponent/ABViewCommentComponent */ 29405);

module.exports = class ABViewComment extends ABViewCommentCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewCommentComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      let field = this.getUserField();
      if (!field) {
         this.warningsMessage(
            `can't resolve user field[${this.settings.columnUser}]`
         );
      }

      field = this.getCommentField();
      if (!field) {
         this.warningsMessage(
            `can't resolve comment field[${this.settings.columnComment}]`
         );
      }

      field = this.getDateField();
      if (!field) {
         this.warningsMessage(
            `can't resolve date field[${this.settings.columnDate}]`
         );
      }
   }
};


/***/ }),

/***/ 45025:
/*!*****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewConditionalContainer.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewConditionalContainerCore = __webpack_require__(/*! ../../core/views/ABViewConditionalContainerCore */ 14534);
const ABViewConditionalContainerComponent = __webpack_require__(/*! ./viewComponent/ABViewConditionalContainerComponent */ 54112);

module.exports = class ABViewConditionalContainer extends (
   ABViewConditionalContainerCore
) {
   /**
    * @function component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewConditionalContainerComponent(this);
   }

   async save() {
      const viewIf = this.views().find((v) => v.name === "If");
      const viewElse = this.views().find((v) => v.name === "Else");
      const pendingSave = [];

      if (viewIf) pendingSave.push(viewIf.save());

      if (viewElse) pendingSave.push(viewElse.save());

      await Promise.all(pendingSave);

      await super.save();
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }

      if (
         !this.settings.filterConditions ||
         this.settings.filterConditions?.rules?.length == 0
      ) {
         this.warningsMessage("has no filter conditions set");
      }
   }
};


/***/ }),

/***/ 57111:
/*!**************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewConnectDataFilter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewConnectDataFilter)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewConnectDataFilterCore */ 51828);
/* harmony import */ var _core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _viewComponent_ABViewConnectDataFilterComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewConnectDataFilterComponent */ 46683);



class ABViewConnectDataFilter extends (_core_views_ABViewConnectDataFilterCore__WEBPACK_IMPORTED_MODULE_0___default()) {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewConnectDataFilterComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }
}


/***/ }),

/***/ 35798:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewContainer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainerCore = __webpack_require__(/*! ../../core/views/ABViewContainerCore */ 67070);
const ABViewContainerComponent = __webpack_require__(/*! ./viewComponent/ABViewContainerComponent */ 91219);

module.exports = class ABViewContainer extends ABViewContainerCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewContainerComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no content");
      }

      // NOTE: this is done in ABView:
      // (allViews || []).forEach((v) => {
      //    v.warningsEval();
      // });
   }
};


/***/ }),

/***/ 97814:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDataFilter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDataFilter)
/* harmony export */ });
/* harmony import */ var _core_views_ABViewDataFilterCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/views/ABViewDataFilterCore */ 23108);
/* harmony import */ var _core_views_ABViewDataFilterCore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_views_ABViewDataFilterCore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _viewComponent_ABViewDataFilterComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewComponent/ABViewDataFilterComponent */ 3912);



class ABViewDataFilter extends (_core_views_ABViewDataFilterCore__WEBPACK_IMPORTED_MODULE_0___default()) {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewDataFilterComponent__WEBPACK_IMPORTED_MODULE_1__["default"](this);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      } else {
         if (this.settings.viewType == "connected") {
            const object = DC.datasource;
            const [field] = object.fields(
               (f) => f.columnName === this.settings.field
            );
            if (!field) {
               this.warningsMessage(`can't resolve field reference`);
            }
         }
      }
   }
}


/***/ }),

/***/ 24216:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDataview.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDataviewCore = __webpack_require__(/*! ../../core/views/ABViewDataviewCore */ 43786);
const ABViewDataviewComponent = __webpack_require__(/*! ./viewComponent/ABViewDataviewComponent */ 93349);

const ABViewDataviewDefaults = ABViewDataviewCore.defaultValues();

const L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewDataview extends ABViewDataviewCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.settings.detailsPage =
         this.settings.detailsPage ?? ABViewDataviewDefaults.detailsPage;
      this.settings.editPage =
         this.settings.editPage ?? ABViewDataviewDefaults.editPage;
      this.settings.detailsTab =
         this.settings.detailsTab ?? ABViewDataviewDefaults.detailsTab;
      this.settings.editTab =
         this.settings.editTab ?? ABViewDataviewDefaults.editTab;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj } v1App
    * @param {string} idPrefix - define to support in 'Datacollection' widget
    *
    * @return {obj } UI component
    */
   component() {
      return new ABViewDataviewComponent(this);
   }
};


/***/ }),

/***/ 65862:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetail.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCore = __webpack_require__(/*! ../../core/views/ABViewDetailCore */ 89799);
const ABViewDetailComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailComponent */ 97346);

module.exports = class ABViewDetail extends ABViewDetailCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj } v1App
    * @param {string} idPrefix - define to support in 'Datacollection' widget
    *
    * @return {obj } UI component
    */
   component() {
      return new ABViewDetailComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
};


/***/ }),

/***/ 11865:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailCheckbox.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCheckboxCore = __webpack_require__(/*! ../../core/views/ABViewDetailCheckboxCore */ 90065);
const ABViewDetailCheckboxComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailCheckboxComponent */ 78781);

module.exports = class ABViewDetailCheckbox extends ABViewDetailCheckboxCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailCheckboxComponent(this);
   }
};


/***/ }),

/***/ 6101:
/*!**********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailConnect.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailConnectCore = __webpack_require__(/*! ../../core/views/ABViewDetailConnectCore */ 12126);
const ABViewPropertyAddPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyAddPage */ 71695)["default"]);

const ABViewDetailConnectComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailConnectComponent */ 84704);

module.exports = class ABViewDetailConnect extends ABViewDetailConnectCore {
   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);
      this.addPageTool.fromSettings(this.settings);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailConnectComponent(this);
   }

   get addPageTool() {
      if (this.__addPageTool == null)
         this.__addPageTool = new ABViewPropertyAddPage();

      return this.__addPageTool;
   }
};


/***/ }),

/***/ 52378:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailCustom.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailCustomCore = __webpack_require__(/*! ../../core/views/ABViewDetailCustomCore */ 57839);
const ABViewDetailCustomComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailCustomComponent */ 99484);

module.exports = class ABViewDetailCustom extends ABViewDetailCustomCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailCustomComponent(this);
   }
};


/***/ }),

/***/ 71951:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailImage.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailImageCore = __webpack_require__(/*! ../../core/views/ABViewDetailImageCore */ 30825);
const ABViewDetailImageComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailImageComponent */ 28805);

module.exports = class ABViewDetailImage extends ABViewDetailImageCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailImageComponent(this);
   }
};


/***/ }),

/***/ 54325:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailItem.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemCore = __webpack_require__(/*! ../../core/views/ABViewDetailItemCore */ 68488);
const ABViewDetailItemComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailItem extends ABViewDetailItemCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailItemComponent(this);
   }
};


/***/ }),

/***/ 97654:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailText.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailTextCore = __webpack_require__(/*! ../../core/views/ABViewDetailTextCore */ 38208);
const ABViewDetailTextComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailTextComponent */ 53676);

module.exports = class ABViewDetailText extends ABViewDetailTextCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailTextComponent(this);
   }
};


/***/ }),

/***/ 18745:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDetailTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailTreeCore = __webpack_require__(/*! ../../core/views/ABViewDetailTreeCore */ 80796);
const ABViewDetailTreeComponent = __webpack_require__(/*! ./viewComponent/ABViewDetailTreeComponent */ 72666);

module.exports = class ABViewDetailTree extends ABViewDetailTreeCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDetailTreeComponent(this);
   }
};


/***/ }),

/***/ 84648:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewDocxBuilder.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDocxBuilderCore = __webpack_require__(/*! ../../core/views/ABViewDocxBuilderCore */ 26736);
const ABViewDocxBuilderComponent = __webpack_require__(/*! ./viewComponent/ABViewDocxBuilderComponent */ 19454);

module.exports = class ABViewDocxBuilder extends ABViewDocxBuilderCore {
   /**
    * @function component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewDocxBuilderComponent(this);
   }

   letUserDownload(blob, filename) {
      const url = window.URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
      a.click();
      a.remove(); //afterwards we remove the element again

      window.URL.revokeObjectURL(url);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollections || this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }

      if (!this.settings.filename) {
         this.warningsMessage("is missing a DOCX template file");
      } else {
         // TODO: should we check for the existance of the file?
         // this isn't currently an async friendly fn, so how?
         // let url = this.downloadUrl();
      }
   }
};


/***/ }),

/***/ 40194:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewForm.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCore = __webpack_require__(/*! ../../core/views/ABViewFormCore */ 31089);
const ABViewFormComponent = __webpack_require__(/*! ./viewComponent/ABViewFormComponent */ 68759);
const ABViewFormButton = __webpack_require__(/*! ./ABViewFormButton */ 44388);
const ABViewFormCustom = __webpack_require__(/*! ./ABViewFormCustom */ 36365);
const ABViewFormConnect = __webpack_require__(/*! ./ABViewFormConnect */ 55030);
const ABViewFormDatepicker = __webpack_require__(/*! ./ABViewFormDatepicker */ 31223);
const ABViewFormSelectMultiple = __webpack_require__(/*! ./ABViewFormSelectMultiple */ 87262);
const ABViewFormTextbox = __webpack_require__(/*! ./ABViewFormTextbox */ 83743);
const ABViewFormJson = __webpack_require__(/*! ./ABViewFormJson */ 51533);

const L = (...params) => AB.Multilingual.label(...params);

// const ABRecordRule = require("../../rules/ABViewRuleListFormRecordRules");
// const ABSubmitRule = require("../../rules/ABViewRuleListFormSubmitRules");

// let PopupRecordRule = null;
// let PopupSubmitRule = null;

const ABViewFormPropertyComponentDefaults = ABViewFormCore.defaultValues();

module.exports = class ABViewForm extends ABViewFormCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      this._callbacks = {
         onBeforeSaveData: () => true,
      };
   }

   superComponent() {
      if (this._superComponent == null)
         this._superComponent = super.component();

      return this._superComponent;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormComponent(this);
   }

   refreshDefaultButton(ids) {
      // If default button is not exists, then skip this
      let defaultButton = this.views(
         (v) => v instanceof ABViewFormButton && v.settings.isDefault
      )[0];

      // Add a default button
      if (defaultButton == null) {
         defaultButton = ABViewFormButton.newInstance(this.application, this);
         defaultButton.settings.isDefault = true;
      }
      // Remove default button from array, then we will add it to be the last item later (.push)
      else {
         this._views = this.views((v) => v.id != defaultButton.id);
      }

      // Calculate position Y of the default button
      let yList = this.views().map((v) => (v.position.y || 0) + 1);
      yList.push(this._views.length || 0);
      yList.push($$(ids.fields).length || 0);
      let posY = Math.max(...yList);

      // Update to be the last item
      defaultButton.position.y = posY;

      // Keep the default button is always the last item of array
      this._views.push(defaultButton);

      return defaultButton;
   }

   /**
    * @method getFormValues
    *
    * @param {webix form} formView
    * @param {ABObject} obj
    * @param {ABDatacollection} dc
    * @param {ABDatacollection} dcLink [optional]
    */
   getFormValues(formView, obj, dc, dcLink) {
      // get the fields that are on this form
      const visibleFields = ["id"]; // we always want the id so we can udpate records
      formView.getValues(function (obj) {
         visibleFields.push(obj.config.name);
      });

      // only get data passed from form
      const allVals = formView.getValues();
      const formVals = {};
      visibleFields.forEach((val) => {
         formVals[val] = allVals[val];
      });

      // get custom values
      this.fieldComponents(
         (comp) =>
            comp instanceof ABViewFormCustom ||
            comp instanceof ABViewFormConnect ||
            comp instanceof ABViewFormDatepicker ||
            comp instanceof ABViewFormSelectMultiple ||
            (comp instanceof ABViewFormJson && comp.settings.type == "filter")
      ).forEach((f) => {
         const vComponent = this.viewComponents[f.id];
         if (vComponent == null) return;

         const field = f.field();
         if (field) {
            const getValue = vComponent.getValue ?? vComponent.logic.getValue;
            if (getValue)
               formVals[field.columnName] = getValue.call(vComponent, formVals);
         }
      });

      // remove connected fields if they were not on the form and they are present in the formVals because it is a datacollection
      obj.connectFields().forEach((f) => {
         if (
            visibleFields.indexOf(f.columnName) == -1 &&
            formVals[f.columnName]
         ) {
            delete formVals[f.columnName];
            delete formVals[f.relationName()];
         }
      });

      // clear undefined values or empty arrays
      for (const prop in formVals) {
         if (formVals[prop] == null || formVals[prop].length == 0)
            formVals[prop] = "";
      }

      // Add parent's data collection cursor when a connect field does not show
      let linkValues;

      if (dcLink) {
         linkValues = dcLink.getCursor();
      }

      if (linkValues) {
         const objectLink = dcLink.datasource;

         const connectFields = obj.connectFields();
         connectFields.forEach((f) => {
            const formFieldCom = this.fieldComponents(
               (fComp) => fComp?.field?.()?.id === f?.id
            );

            if (
               objectLink.id == f.settings.linkObject &&
               formFieldCom.length < 1 && // check field does not show
               formVals[f.columnName] === undefined
            ) {
               const linkColName = f.indexField
                  ? f.indexField.columnName
                  : objectLink.PK();

               formVals[f.columnName] = {};
               formVals[f.columnName][linkColName] =
                  linkValues[linkColName] ?? linkValues.id;
            }
         });
      }

      // NOTE: need to pull data of current cursor to calculate Calculate & Formula fields
      // .formVals variable does not include data that does not display in the Form widget
      const cursorFormVals = Object.assign(dc.getCursor() ?? {}, formVals);

      // Set value of calculate or formula fields to use in record rule
      obj.fields((f) => f.key == "calculate" || f.key == "formula").forEach(
         (f) => {
            if (formVals[f.columnName] == null) {
               let reCalculate = true;

               // WORKAROUND: If "Formula" field will have Filter conditions,
               // Then it is not able to re-calculate on client side
               // because relational data is not full data so FilterComplex will not have data to check
               if (f.key == "formula" && f.settings?.where?.rules?.length > 0) {
                  reCalculate = false;
               }

               formVals[f.columnName] = f.format(cursorFormVals, reCalculate);
            }
         }
      );

      if (allVals.translations?.length > 0)
         formVals.translations = allVals.translations;

      // give the Object a final chance to review the data being handled.
      obj.formCleanValues(formVals);

      return formVals;
   }

   /**
    * @method validateData
    *
    * @param {webix form} formView
    * @param {ABObject} object
    * @param {object} formVals
    *
    * @return {boolean} isValid
    */
   validateData($formView, object, formVals) {
      let list = "";

      // validate required fields
      const requiredFields = this.fieldComponents(
         (fComp) =>
            fComp?.field?.().settings?.required == true ||
            fComp?.settings?.required == true
      ).map((fComp) => fComp.field());

      // validate data
      const validator = object.isValidData(formVals);
      let isValid = validator.pass();

      // $$($formView).validate();
      $formView.validate();
      /**
       * helper function to fix the webix ui after adding an validation error
       * message.
       * @param {string} col - field.columnName
       */
      const fixInvalidMessageUI = (col) => {
         const $forminput = $formView.elements[col];
         if (!$forminput) return;
         // Y position
         const height = $forminput.$height;
         if (height < 56) {
            $forminput.define("height", 60);
            $forminput.resize();
         }

         // X position
         const domInvalidMessage = $forminput.$view.getElementsByClassName(
            "webix_inp_bottom_label"
         )[0];
         if (!domInvalidMessage?.style["margin-left"]) {
            domInvalidMessage.style.marginLeft = `${
               this.settings.labelWidth ??
               ABViewFormPropertyComponentDefaults.labelWidth
            }px`;
         }
      };

      // Display required messages
      requiredFields.forEach((f) => {
         if (!f) return;

         const fieldVal = formVals[f.columnName];
         if (fieldVal == "" || fieldVal == null || fieldVal.length < 1) {
            $formView.markInvalid(f.columnName, L("This is a required field."));
            list += `<li>${L("Missing Required Field")} ${f.columnName}</li>`;
            isValid = false;

            // Fix position of invalid message
            fixInvalidMessageUI(f.columnName);
         }
      });

      // if data is invalid
      if (!isValid) {
         const saveButton = $formView.queryView({
            view: "button",
            type: "form",
         });

         // error message
         if (validator?.errors?.length) {
            validator.errors.forEach((err) => {
               $formView.markInvalid(err.name, err.message);
               list += `<li>${err.name}: ${err.message}</li>`;
               fixInvalidMessageUI(err.name);
            });

            saveButton?.disable();
         } else {
            saveButton?.enable();
         }
      }
      if (list) {
         webix.alert({
            type: "alert-error",
            title: L("Problems Saving"),
            width: 400,
            text: `<ul style='text-align:left'>${list}</ul>`,
         });
      }

      return isValid;
   }

   /**
    * @method recordRulesReady()
    * This returns a Promise that gets resolved when all record rules report
    * that they are ready.
    * @return {Promise}
    */
   async recordRulesReady() {
      return this.RecordRule.rulesReady();
   }

   /**
    * @method saveData
    * save data in to database
    * @param $formView - webix's form element
    *
    * @return {Promise}
    */
   async saveData($formView) {
      // call .onBeforeSaveData event
      // if this function returns false, then it will not go on.
      if (!this._callbacks?.onBeforeSaveData?.()) return;

      $formView.clearValidation();

      // get ABDatacollection
      const dv = this.datacollection;
      if (dv == null) return;

      // get ABObject
      const obj = dv.datasource;
      if (obj == null) return;

      // get ABModel
      const model = dv.model;
      if (model == null) return;

      // show progress icon
      $formView.showProgress?.({ type: "icon" });

      // get update data
      const formVals = this.getFormValues(
         $formView,
         obj,
         dv,
         dv.datacollectionLink
      );

      // form ready function
      const formReady = (newFormVals) => {
         // clear cursor after saving.
         if (dv) {
            if (this.settings.clearOnSave) {
               dv.setCursor(null);
               $formView.clear();
            } else {
               if (newFormVals && newFormVals.id) dv.setCursor(newFormVals.id);
            }
         }

         $formView.hideProgress?.();

         // if there was saved data pass it up to the onSaveData callback
         // if (newFormVals) this._logic.callbacks.onSaveData(newFormVals);
         if (newFormVals) this.emit("saved", newFormVals); // Q? is this the right upgrade?
      };

      const formError = (err) => {
         const $saveButton = $formView.queryView({
            view: "button",
            type: "form",
         });

         // mark error
         if (err) {
            if (err.invalidAttributes) {
               for (const attr in err.invalidAttributes) {
                  let invalidAttrs = err.invalidAttributes[attr];
                  if (invalidAttrs && invalidAttrs[0])
                     invalidAttrs = invalidAttrs[0];

                  $formView.markInvalid(attr, invalidAttrs.message);
               }
            } else if (err.sqlMessage) {
               webix.message({
                  text: err.sqlMessage,
                  type: "error",
               });
            } else {
               webix.message({
                  text: L("System could not save your data"),
                  type: "error",
               });
               this.AB.notify.developer(err, {
                  message: "Could not save your data",
                  view: this.toObj(),
               });
            }
         }

         $saveButton?.enable();

         $formView?.hideProgress?.();
      };

      // Load data of DCs that use in record rules
      await this.loadDcDataOfRecordRules();

      // wait for our Record Rules to be ready before we continue.
      await this.recordRulesReady();

      // update value from the record rule (pre-update)
      this.doRecordRulesPre(formVals);

      // validate data
      if (!this.validateData($formView, obj, formVals)) {
         // console.warn("Data is invalid.");
         $formView.hideProgress?.();
         return;
      }

      let newFormVals;
      // {obj}
      // The fully populated values returned back from service call
      // We use this in our post processing Rules

      try {
         // is this an update or create?
         if (formVals.id) {
            newFormVals = await model.update(formVals.id, formVals);
         } else {
            newFormVals = await model.create(formVals);
         }
      } catch (err) {
         formError(err.data);
         throw err;
      }

      /*
      // OLD CODE:
      try {
         await this.doRecordRules(newFormVals);
         // make sure any updates from RecordRules get passed along here.
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return newFormVals;
      } catch (err) {
         this.AB.notify.developer(err, {
            message: "Error processing Record Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
         // Question:  how do we respond to an error?
         // ?? just keep going ??
         this.doSubmitRules(newFormVals);
         formReady(newFormVals);
         return;
      }
      */

      try {
         await this.doRecordRules(newFormVals);
      } catch (err) {
         this.AB.notify.developer(err, {
            message: "Error processing Record Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
      }

      // make sure any updates from RecordRules get passed along here.
      try {
         this.doSubmitRules(newFormVals);
      } catch (errs) {
         this.AB.notify.developer(errs, {
            message: "Error processing Submit Rules.",
            view: this.toObj(),
            newFormVals: newFormVals,
         });
      }

      formReady(newFormVals);
      return newFormVals;
   }

   focusOnFirst() {
      let topPosition = 0;
      let topPositionId = "";
      this.views().forEach((item) => {
         if (item.key == "textbox" || item.key == "numberbox") {
            if (item.position.y == topPosition) {
               // topPosition = item.position.y;
               topPositionId = item.id;
            }
         }
      });
      let childComponent = this.viewComponents[topPositionId];
      if (childComponent && $$(childComponent.ui.id)) {
         $$(childComponent.ui.id).focus();
      }
   }

   async loadDcDataOfRecordRules() {
      const tasks = [];

      (this.settings?.recordRules ?? []).forEach((rule) => {
         (rule?.actionSettings?.valueRules?.fieldOperations ?? []).forEach(
            (op) => {
               if (op.valueType !== "exist") return;

               const pullDataDC = this.AB.datacollectionByID(op.value);

               if (
                  pullDataDC?.dataStatus ===
                  pullDataDC.dataStatusFlag.notInitial
               )
                  tasks.push(pullDataDC.loadData());
            }
         );
      });

      await Promise.all(tasks);

      return true;
   }

   get viewComponents() {
      const superComponent = this.superComponent();
      return superComponent.viewComponents;
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }

      if (this.settings.recordRules) {
         // TODO: scan recordRules for warnings
      }

      if (this.settings.submitRules) {
         // TODO: scan submitRules for warnings.
      }
   }

   /**
    * @method deleteData
    * delete data in to database
    * @param $formView - webix's form element
    *
    * @return {Promise}
    */
   async deleteData($formView) {
      // get ABDatacollection
      const dc = this.datacollection;
      if (dc == null) return;

      // get ABObject
      const obj = dc.datasource;
      if (obj == null) return;

      // get ABModel
      const model = dc.model;
      if (model == null) return;

      // get update data
      const formVals = $formView.getValues();

      if (formVals?.id) {
         const result = await model.delete(formVals.id);

         // clear form
         if (result) {
            dc.setCursor(null);
            $formView.clear();
         }

         return result;
      }
   }
};


/***/ }),

/***/ 44388:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormButton.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormButtonCore = __webpack_require__(/*! ../../core/views/ABViewFormButtonCore */ 46816);
const ABViewFormButtonComponent = __webpack_require__(/*! ./viewComponent/ABViewFormButtonComponent */ 5793);

module.exports = class ABViewFormButton extends ABViewFormButtonCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormButtonComponent(this);
   }
};


/***/ }),

/***/ 93452:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormCheckbox.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCheckboxCore = __webpack_require__(/*! ../../core/views/ABViewFormCheckboxCore */ 49947);
const ABViewFormCheckboxComponent = __webpack_require__(/*! ./viewComponent/ABViewFormCheckboxComponent */ 90418);

module.exports = class ABViewFormCheckbox extends ABViewFormCheckboxCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormCheckboxComponent(this);
   }
};


/***/ }),

/***/ 55030:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormConnect.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormConnectCore = __webpack_require__(/*! ../../core/views/ABViewFormConnectCore */ 91623);
const ABViewFormConnectComponent = __webpack_require__(/*! ./viewComponent/ABViewFormConnectComponent */ 40500);
const ABViewPropertyAddPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyAddPage */ 71695)["default"]);
const ABViewPropertyEditPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyEditPage */ 39747)["default"]);

const ABViewFormConnectPropertyComponentDefaults =
   ABViewFormConnectCore.defaultValues();

module.exports = class ABViewFormConnect extends ABViewFormConnectCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABView} parent the ABView this view is a child of. (can be null)
    */
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);

      // Set filter value
      this.__filterComponent = this.AB.filterComplexNew(
         `${this.id}__filterComponent`
      );
      // this.__filterComponent.applicationLoad(application);
      this.__filterComponent.fieldsLoad(
         this.datasource ? this.datasource.fields() : [],
         this.datasource ? this.datasource : null
      );

      // NOTE: .objectWorkspace is a v1 setting
      // if (
      //    !this.settings.objectWorkspace ||
      //    !this.settings.objectWorkspace.filterConditions
      // ) {
      //    this.AB.error("Error: filter conditions do not exist", {
      //       error: "filterConditions do not exist",
      //       viewLocation: {
      //          application: this.application.name,
      //          id: this.id,
      //          name: this.label,
      //       },
      //       view: this,
      //    });
      //    // manually place an empty filter
      //    this.settings["objectWorkspace"] = {};
      //    this.settings["objectWorkspace"]["filterConditions"] = { glue: "and" };
      // }

      this.__filterComponent.setValue(
         this.settings.filterConditions ??
            ABViewFormConnectPropertyComponentDefaults.filterConditions
      );
   }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      this.addPageTool.fromSettings(this.settings);
      this.editPageTool.fromSettings(this.settings);
   }

   static get addPageProperty() {
      return ABViewPropertyAddPage.propertyComponent(this.App, this.idBase);
   }

   static get editPageProperty() {
      return ABViewPropertyEditPage.propertyComponent(this.App, this.idBase);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormConnectComponent(this);
   }

   get addPageTool() {
      if (this.__addPageTool == null)
         this.__addPageTool = new ABViewPropertyAddPage();

      return this.__addPageTool;
   }

   get editPageTool() {
      if (this.__editPageTool == null)
         this.__editPageTool = new ABViewPropertyEditPage();

      return this.__editPageTool;
   }
};


/***/ }),

/***/ 36365:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormCustom.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormCustomCore = __webpack_require__(/*! ../../core/views/ABViewFormCustomCore */ 88356);
const ABViewFormCustomComponent = __webpack_require__(/*! ./viewComponent/ABViewFormCustomComponent */ 12213);

module.exports = class ABViewFormCustom extends ABViewFormCustomCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormCustomComponent(this);
   }
};


/***/ }),

/***/ 31223:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormDatepicker.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormDatepickerCore = __webpack_require__(/*! ../../core/views/ABViewFormDatepickerCore */ 28476);
const ABViewFormDatepickerComponent = __webpack_require__(/*! ./viewComponent/ABViewFormDatepickerComponent */ 37264);

module.exports = class ABViewFormDatepicker extends ABViewFormDatepickerCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormDatepickerComponent(this);
   }
};


/***/ }),

/***/ 48933:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormItem.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemCore = __webpack_require__(/*! ../../core/views/ABViewFormItemCore */ 68181);
const ABViewFormItemComponent = __webpack_require__(/*! ./viewComponent/ABViewFormItemComponent */ 13097);

const ABViewFormFieldPropertyComponentDefaults =
   ABViewFormItemCore.defaultValues();

module.exports = class ABViewFormItem extends ABViewFormItemCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   static get componentUI() {
      return ABViewFormItemComponent;
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormItemComponent(this);
   }

   /**
    * @method parentFormUniqueID
    * return a unique ID based upon the closest form object this component is on.
    * @param {string} key  The basic id string we will try to make unique
    * @return {string}
    */
   parentFormUniqueID(key) {
      var form = this.parentFormComponent();
      var uniqueInstanceID;
      if (form) {
         uniqueInstanceID = form.uniqueInstanceID;
      } else {
         uniqueInstanceID = webix.uid();
      }

      return key + uniqueInstanceID;
   }
};


/***/ }),

/***/ 51533:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormJson.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormJsonCore = __webpack_require__(/*! ../../core/views/ABViewFormJsonCore */ 88612);
const ABViewFormJsonComponent = __webpack_require__(/*! ./viewComponent/ABViewFormJsonComponent */ 35986);

module.exports = class ABViewFormJson extends ABViewFormJsonCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormJsonComponent(this);
   }
};


/***/ }),

/***/ 54045:
/*!*******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormNumber.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormNumberCore = __webpack_require__(/*! ../../core/views/ABViewFormNumberCore */ 5880);
const ABViewFormNumberComponent = __webpack_require__(/*! ./viewComponent/ABViewFormNumberComponent */ 14956);

module.exports = class ABViewFormNumber extends ABViewFormNumberCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormNumberComponent(this);
   }
};


/***/ }),

/***/ 26314:
/*!*********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormReadonly.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormReadonlyCore = __webpack_require__(/*! ../../core/views/ABViewFormReadonlyCore */ 87771);
const ABViewFormReadonlyComponent = __webpack_require__(/*! ./viewComponent/ABViewFormReadonlyComponent */ 26050);

module.exports = class ABViewFormReadonly extends ABViewFormReadonlyCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormReadonlyComponent(this);
   }
};


/***/ }),

/***/ 87262:
/*!***************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormSelectMultiple.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormSelectMultipleCore = __webpack_require__(/*! ../../core/views/ABViewFormSelectMultipleCore */ 15934);
const ABViewFormSelectMultipleComponent = __webpack_require__(/*! ./viewComponent/ABViewFormSelectMultipleComponent */ 70215);

module.exports = class ABViewFormSelectMultiple extends (
   ABViewFormSelectMultipleCore
) {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormSelectMultipleComponent(this);
   }
};


/***/ }),

/***/ 24215:
/*!*************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormSelectSingle.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormSelectSingleCore = __webpack_require__(/*! ../../core/views/ABViewFormSelectSingleCore */ 97241);
const ABViewFormSelectSingleComponent = __webpack_require__(/*! ./viewComponent/ABViewFormSelectSingleComponent */ 35111);

module.exports = class ABViewFormSelectSingle extends (
   ABViewFormSelectSingleCore
) {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormSelectSingleComponent(this);
   }
};


/***/ }),

/***/ 83743:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormTextbox.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormTextboxCore = __webpack_require__(/*! ../../core/views/ABViewFormTextboxCore */ 94782);
const ABViewFormTextboxComponent = __webpack_require__(/*! ./viewComponent/ABViewFormTextboxComponent */ 96936);

module.exports = class ABViewFormTextbox extends ABViewFormTextboxCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormTextboxComponent(this);
   }
};


/***/ }),

/***/ 20297:
/*!*****************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewFormTree.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormTreeCore = __webpack_require__(/*! ../../core/views/ABViewFormTreeCore */ 68272);
const ABViewFormTreeComponent = __webpack_require__(/*! ./viewComponent/ABViewFormTreeComponent */ 72708);

module.exports = class ABViewFormTree extends ABViewFormTreeCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component() {
      return new ABViewFormTreeComponent(this);
   }
};


/***/ }),

/***/ 62171:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGantt.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGantt)
/* harmony export */ });
/* harmony import */ var _viewComponent_ABViewGanttComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewComponent/ABViewGanttComponent */ 20757);


const ABViewGanttCore = __webpack_require__(/*! ../../core/views/ABViewGanttCore */ 28181);

class ABViewGantt extends ABViewGanttCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewGanttComponent__WEBPACK_IMPORTED_MODULE_0__["default"](this);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      } else {
         if (!this.settings.startDateFieldID) {
            this.warningsMessage(`doesn't have a start date field set.`);
         } else {
            let field = DC.datasource?.fieldByID(
               this.settings.startDateFieldID
            );
            if (!field) {
               this.warningsMessage(
                  `can't lookup field: startDate[${this.settings.startDateFieldID}]`
               );
            }
         }
      }
   }
}


/***/ }),

/***/ 77574:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGrid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGrid)
/* harmony export */ });
/* harmony import */ var _viewComponent_ABViewGridComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewComponent/ABViewGridComponent */ 24151);
/* harmony import */ var _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewProperties/ABViewPropertyFilterData */ 43348);
const ABViewGridCore = __webpack_require__(/*! ../../core/views/ABViewGridCore */ 1063);


const ABViewPropertyLinkPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 25733)["default"]);

class ABViewGrid extends ABViewGridCore {
   /**
    * @param {obj} values  key=>value hash of ABView values
    * @param {ABApplication} application the application object this view is under
    * @param {ABViewWidget} parent the ABViewWidget this view is a child of. (can be null)
    */
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   ///
   /// Instance Methods
   ///

   /**
    * @method fromValues()
    *
    * initialze this object with the given set of values.
    * @param {obj} values
    */
   fromValues(values) {
      super.fromValues(values);

      // filter property
      this.filterHelper.fromSettings(this.settings.gridFilter);
   }

   propertyGroupByList(ids, groupBy) {
      let colNames = groupBy || [];
      if (typeof colNames == "string") {
         colNames = colNames.split(",");
      }

      let options = $$(ids.groupBy).getList().data.find({});

      $$(ids.groupByList).clearAll();
      colNames.forEach((colName) => {
         let opt = options.filter((o) => o.id == colName)[0];
         if (opt) {
            $$(ids.groupByList).add(opt);
         }
      });
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new _viewComponent_ABViewGridComponent__WEBPACK_IMPORTED_MODULE_0__["default"](this);
   }

   get filterHelper() {
      if (this.__filterHelper == null) {
         this.__filterHelper = new _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_1__["default"](
            this.AB,
            `${this.id}_filterHelper`
         );
      }

      return this.__filterHelper;
   }

   get linkPageHelper() {
      if (this.__linkPageHelper == null)
         this.__linkPageHelper = new ABViewPropertyLinkPage();

      return this.__linkPageHelper;
   }

   warningsEval() {
      super.warningsEval();
      let origWS = this.warningsSilent;
      this.warningsSilent = true;
      let DC = this.datacollection;
      this.warningsSilent = origWS;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
}


/***/ }),

/***/ 69829:
/*!************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupExport.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABWorkObjectPopupExport)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32019);
/*
 * ABViewGridPopupExport.js
 * Manage the Popup that allows you to export data into one of our supported
 * formats.
 */



class ABWorkObjectPopupExport extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase) {
      idBase = idBase || "abviewgridpopupExport";

      super({
         popupExport: `${idBase}_popupExport`,
         list: `${idBase}_popupExport_list`,
      });

      this._currentObject = null;
      // {ABObject}
      // The ABObject of the data we will export.  We can find out the fields
      // from the object.

      this._dataCollection = null;
      // {ABDatacCollection}
      // The ABDataCollection that contains the data we are going to export.

      this._grid = null;
      // {webix.grid}
      // the current webix.grid that contains the data we are going to export.

      this._filename = null;
      // {string}
      // the name of the desired output file.

      this._hiddenFields = [];
      // {array}
      // An array of ABField.columnName(s) that we are not wanting to export
   }

   ui() {
      var self = this;

      // webix UI definition:
      return {
         view: "popup",
         id: this.ids.popupExport,
         width: 160,
         height: 0, //150,
         select: false,
         hidden: true,
         body: {
            id: this.ids.list,
            view: "list",
            autoheight: true,
            data: [
               { name: "CSV", icon: "file-excel-o" },
               { name: "Excel", icon: "file-excel-o" },
               { name: "PDF", icon: "file-pdf-o" },
               { name: "PNG", icon: "file-image-o" },
            ],
            template:
               "<div><i class='fa fa-#icon# webix_icon_btn' aria-hidden='true'></i> #name#</div>",
            on: {
               onItemClick: function (id /*, e, node */) {
                  var component = this.getItem(id);
                  self.export(component.name);
               },
            },
         },
      };
   }

   async init(AB) {
      if (AB) {
         this.AB = AB;
      }
      webix.ui(this.ui());
      $$(this.ids.popupExport).resize();
   }

   // internal business logic

   /**
    * @method dataCollectionLoad()
    * the current ABDataCollection we are working with.
    * @param {ABDataCollection} dc
    */
   dataCollectionLoad(dc) {
      this._dataCollection = dc;
   }

   /**
    * @method objectLoad()
    * The current ABObject we are working with.
    * @param {ABObject} object
    */
   objectLoad(object) {
      this._currentObject = object;
   }

   /**
    * @method setHiddenFields
    * Register Fields we don't want exported in our data.
    * @param {array} fields
    *        An array of ABField.columnName(s) to exclude from our export.
    */
   setHiddenFields(fields = []) {
      this._hiddenFields = fields ?? [];
   }

   /**
    * @method setFilename()
    * Register the name of the file we want our data to export as.
    * @param {string} filename
    */
   setFilename(filename) {
      this._filename = filename;
   }

   /**
    * @method setGridComponent()
    * Register the webix.grid that currently stores the data we are
    * exporting.
    * @param {webix.grid} $grid
    */
   setGridComponent($grid) {
      this._grid = $grid;
   }

   /**
    * @function show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    */
   show($view) {
      $$(this.ids.popupExport).show($view);
   }

   async export(name) {
      let fnExport;

      let columns = {};

      let dc = this._dataCollection;
      let _currentObject = this._currentObject;
      let _grid = this._grid;
      let _filename = this._filename;

      if (
         dc &&
         (!dc.settings.loadAll || dc.dataStatus == dc.dataStatusFlag.notInitial)
      ) {
         // Load all data
         await dc.reloadData(0, null);
         dc.settings.loadAll = true;
      }

      // client filter data
      // template of report
      if (_currentObject) {
         _currentObject.fields().forEach((f) => {
            // hidden fields
            if (this._hiddenFields.indexOf(f.columnName) > -1) return;

            columns[f.columnName] = {
               template: (rowData) => {
                  return f.format(rowData);
               },
            };
         });
      }

      // If there are checked items, then export them only
      // Otherwise export all items
      const noCheckedRow =
         _grid.data.find({ appbuilder_select_item: 1 }).length < 1;
      const filterRow = (row) =>
         noCheckedRow || row?.appbuilder_select_item == 1;

      switch (name) {
         case "CSV":
            webix.csv.delimiter.cols = ",";

            fnExport = webix.toCSV(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               columns: columns,
               filter: filterRow,
            });
            break;
         case "Excel":
            fnExport = webix.toExcel(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               name:
                  _filename || (_currentObject ? _currentObject.label : null),
               columns: columns,
               filterHTML: true,
               filter: filterRow,
            });
            break;
         case "PDF":
            fnExport = webix.toPDF(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               filterHTML: true,
               filter: filterRow,
            });
            break;
         case "PNG":
            fnExport = webix.toPNG(_grid, {
               filename:
                  _filename || (_currentObject ? _currentObject.label : null),
               // filter: NOT SUPPORT
            });
            break;
      }

      try {
         await fnExport;
         $$(this.ids.popupExport).hide();
      } catch (err) {
         this.AB.notify.developer(err, {
            message: `ABViewGridPopupExport:export(): System could not export: ${name}`,
            exportType: name,
            columns,
            fileName: _filename,
         });
      }
   }

   // this.dataCollectionLoad = _logic.dataCollectionLoad;
   // this.objectLoad = _logic.objectLoad;
   // this.setGridComponent = _logic.setGridComponent;
   // this.setFilename = _logic.setFilename;
   // this.setHiddenFields = _logic.setHiddenFields;
   // this.show = _logic.show;
}


/***/ }),

/***/ 32953:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupMassUpdate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGridPopupMassUpdate)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32019);
/* harmony import */ var _RowUpdater__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RowUpdater */ 9234);
/*
 * ABViewGridPopupMassUpdate
 *
 * An ABViewGrid can offer a mass update feature.  This is a ui component
 * to help with the processing of the update.
 *
 */




var L = null;

class ABViewGridPopupMassUpdate extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   //.extend(idBase, function(App) {

   constructor(ABViewGridComponent, idBase) {
      idBase = idBase || "abviewgridpopupMassUpdate";

      super({
         component: `${idBase}_popupMassUpdate`,
         submit: `${idBase}_submitMassUpdate`,
      });

      this.CurrentObject = null;
      // {ABObject}
      // Which ABObject are we currently working with.

      this.GridComponent = ABViewGridComponent;
      // {ABViewGridComponent}
      // The current ABViewGridComponent we are working with.

      this.AB = ABViewGridComponent.AB;
      // {ABFactory}

      this.rowUpdater = new _RowUpdater__WEBPACK_IMPORTED_MODULE_1__["default"](idBase, this.AB);
      // {RowUpdater}
      // An instance of our RowUpdater form builder.

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }
   }

   ui() {
      var ids = this.ids;

      // Our webix UI definition:
      return {
         view: "popup",
         id: ids.component,
         // modal: true,
         body: {
            width: 500,
            rows: [
               // Update panel
               this.rowUpdater.ui(),
               { height: 15 },
               {
                  cols: [
                     {},
                     {
                        view: "button",
                        value: L("Cancel"),
                        width: 100,
                        click: () => {
                           this.hide();
                        },
                     },
                     {
                        id: ids.submit,
                        css: "webix_primary",
                        view: "button",
                        label: L("Update"),
                        type: "form",
                        width: 120,
                        click: () => {
                           this.submit();
                        },
                     },
                  ],
               },
            ],
         },
         on: {
            onShow: () => {
               this.onShow();
            },
         },
      };
   }

   async init(AB) {
      webix.ui(this.ui());
      this.rowUpdater.init(AB);

      return Promise.resolve();
   }

   /**
    * @method hide()
    * Hide the popup.
    */
   hide() {
      $$(this.ids.component).hide();
   }

   /**
    * @function objectLoad
    * Ready the Popup according to the current object & datatable
    * @param {ABObject} object
    *        the currently selected object.
    * @param {webix.datatable} dataTable
    *        the dataTable we need to run the mass update on...trust me this
    *        will be good
    */
   objectLoad(object, dataTable) {
      this.CurrentObject = object;
      this.rowUpdater.objectLoad(object);
      this.DataTable = dataTable;
   }

   onShow() {}

   /**
    * @method show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    * @param {json} options
    *        Additional webix options related to the .show() method.
    */
   show($view, options = null) {
      if (options != null) {
         $$(this.ids.component).show($view, options);
      } else {
         $$(this.ids.component).show($view);
      }
   }

   /**
    * @method submit()
    * Process the submit action by getting the values to change and then
    * running a batchUpdate() on the items in our datatable that were selected.
    */
   submit() {
      // Update values to records
      let update_button = $$(this.ids.submit),
         update_items = this.rowUpdater.getValue() || [];

      update_button.disable();

      if (!this.GridComponent) {
         // TODO : Message
         // console.log("no data collection to update");
         update_button.enable();
         return;
      } else if (update_items.length < 1) {
         // TODO : Message
         update_button.enable();
         return;
      }

      let $datatable = this.GridComponent.getDataTable(); // $$(DataTable.ui.id);
      let updatedRowIds = [];
      $datatable.data.each(function (row) {
         if (
            row &&
            Object.prototype.hasOwnProperty.call(
               row,
               "appbuilder_select_item"
            ) &&
            row.appbuilder_select_item == 1
         ) {
            updatedRowIds.push(row.id);
         }
      });

      let vals = {};
      update_items.forEach((item) => {
         let fieldInfo = this.CurrentObject.fieldByID(item.fieldId);
         if (!fieldInfo) return;

         vals[fieldInfo.columnName] = item.value;
      });

      if (updatedRowIds.length > 0) {
         webix.confirm({
            title: L("Updating Multiple Records"),
            text: L("Are you sure you want to update the selected records?"),
            callback: (result) => {
               if (result) {
                  if ($datatable && $datatable.showProgress)
                     $datatable.showProgress({ type: "icon" });

                  let objModel = this.CurrentObject.model();
                  objModel
                     .batchUpdate({
                        rowIds: updatedRowIds,
                        values: vals,
                     })
                     .then(() => {
                        // Update webix.datatable
                        (updatedRowIds ?? []).forEach((rowId) => {
                           $datatable.updateItem(rowId, vals);
                        });

                        // Anything we need to do after we are done.
                        update_button.enable();
                        this.hide();

                        if ($datatable && $datatable.hideProgress)
                           $datatable.hideProgress();
                     })
                     .catch((err) => {
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewGridPopupMassUpdate:submit(): Error during batchUpdate",
                           rowIds: updatedRowIds,
                           values: vals,
                        });
                     });
               } else {
                  update_button.enable();
               }
            },
         });
      } else {
         webix.alert({
            title: L("No Records Selected"),
            text: L(
               "You need to select at least one record...did you drink your coffee today?"
            ),
         });
         update_button.enable();
         this.hide();
      }
   }
}


/***/ }),

/***/ 83595:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewGridPopupSortFields.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AB_Work_Object_Workspace_PopupSortFields)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ui/ClassUI */ 32019);
/*
 * ABViewGridPopupSortFields
 *
 * Manage the Sort Fields popup.
 *
 */



var L = null;

class AB_Work_Object_Workspace_PopupSortFields extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(idBase) {
      idBase = idBase || "abviewgridpopupSortFields";

      super({
         component: `${idBase}_popupSort`,
         list: `${idBase}_popupSort_list`,
         form: `${idBase}_popupSort_form`,
      });

      this.CurrentObject = null;
      // {ABObject}
      // The current ABObject we are working with.

      this._blockOnChange = false;
      // {bool}
      // Should we skip the onChange handler processing at this time?

      this._settings = null;
      // {json}
      // default sort settings.

      if (!L) {
         L = (...params) => {
            return (this.AB ?? AB).Multilingual.label(...params);
         };
      }
   }

   uiForm() {
      const compId = this.ids.component;
      return {
         view: "form",
         id: this.ids.form,
         borderless: true,
         elements: [
            {
               view: "button",
               type: "form",
               css: "webix_primary",
               value: L("Add new sort"),
               on: {
                  onItemClick: (/* id, e, node */) => {
                     this.clickAddNewSort();
                     this.triggerOnChange();
                  },
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        `${compId} add sort button`
                     );
                  },
               },
            },
         ],
      };
   }

   ui() {
      return {
         view: "popup",
         id: this.ids.component,
         // autoheight:true,
         width: 600,
         body: this.uiForm(),
         on: {
            onShow: () => {
               this.onShow();
            },
         },
      };
   }

   // Our init() function for setting up our UI
   async init(AB) {
      if (AB) {
         this.AB = AB;
      }

      (this.AB.Webix ?? webix).ui(this.ui());
   }

   /**
    * @function clickAddNewSort
    * When the user clicks the "Add New Sort" button, this routine will
    * add another row to the sort form.
    * @param {string} fieldId
    *        The ABField.id of the field to auto select in this new row.
    * @param {string} dir
    *        The sort order to auto select in this new row.
    */
   // clickAddNewSort: function(by, dir, isMulti, id) {
   clickAddNewSort(fieldId, dir) {
      var self = this;
      var sort_form = $$(this.ids.form);

      var viewIndex = sort_form.getChildViews().length - 1;
      var listFields = this.getFieldList(true);
      sort_form.addView(
         {
            id: `sort_${viewIndex + 1}`,
            cols: [
               {
                  view: "combo",
                  width: 220,
                  options: listFields,
                  on: {
                     onChange: function (columnId) {
                        var el = this;
                        self.onChangeCombo(columnId, el);
                     },
                  },
               },
               this._valueElement(),
               {
                  view: "button",
                  css: "webix_danger",
                  icon: "fa fa-trash",
                  type: "icon",
                  width: 30,
                  on: {
                     onItemClick: function () {
                        sort_form.removeView(this.getParentView());
                        self.refreshFieldList(true);
                        self.triggerOnChange();
                     },
                  },
               },
            ],
         },
         viewIndex
      );

      // Select field
      if (fieldId) {
         var fieldsCombo = sort_form
            .getChildViews()
            [viewIndex].getChildViews()[0];
         fieldsCombo.setValue(fieldId);
      }
      // select direction
      if (dir) {
         var dirElem = sort_form.getChildViews()[viewIndex].getChildViews()[1];
         dirElem.setValue?.(dir);

         // [ABFieldList] Sorting following order
         dirElem.sort?.((a, b) => {
            return (dir ?? "").indexOf(a.id ?? a) >
               (dir ?? "").indexOf(b.id ?? b)
               ? 1
               : -1;
         });
      }
   }

   /**
    * @function getFieldList
    * return field list so we can present a custom UI for view
    * @param {bool} excludeSelected
    *        Should we ignore fields that already exist in the form?
    * @return {array} [ { id, value } ]
    *         an array that is compatible with the webix.list
    *         widget.
    */
   getFieldList(excludeSelected) {
      var sort_form = $$(this.ids.form),
         listFields = [];

      var allFields = this.CurrentObject.fields();
      if (!allFields || !allFields.length) return listFields;

      // Get all fields include hidden fields
      allFields.forEach((f) => {
         if (f.fieldIsSortable()) {
            listFields.push({
               id: f.id,
               value: f.label,
            });
         }
      });

      // Remove selected field
      if (excludeSelected) {
         var childViews = sort_form.getChildViews();
         if (childViews.length > 1) {
            // Ignore 'Add new sort' button
            childViews.forEach(function (cView, index) {
               if (childViews.length - 1 <= index) return false;

               var selectedValue = cView.getChildViews()[0].getValue();
               if (selectedValue) {
                  listFields = listFields.filter((f) => f.id != selectedValue);
               }
            });
         }
      }
      return listFields;
   }

   /**
    * @function objectLoad
    * Ready the Popup according to the current object
    * @param {ABObject} object  the currently selected object.
    */
   objectLoad(object) {
      this.CurrentObject = object;
   }

   /**
    * @method setSettings
    * Initialize the form with a set of conditions.
    * @param {Array} settings
    *        The default settings for this form.
    *        [
    *           {
    *              key: uuid,     // ABField.id
    *              dir: string,   // 'asc' or 'desc'
    *           }
    *        ]
    */
   setSettings(settings) {
      this._settings = this.AB.cloneDeep(settings);
   }

   /**
    * @method getSettings
    * return the current sort settings stored by this form.
    * @return {Array} -
    *         [
    *            {
    *               key: uuid,     // ABField.id
    *               dir: string,   // 'asc' or 'desc'
    *            }
    *         ]
    */
   getSettings() {
      var sort_form = $$(this.ids.form),
         sortFields = [];

      var childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach(function (cView, index) {
            if (childViews.length - 1 <= index) return false;

            var fieldId = cView.getChildViews()[0].getValue();
            const dirElem = cView.getChildViews()[1];
            var dir =
               dirElem?.getValue?.() ??
               dirElem?.data?.getRange?.()?.map((opt) => opt.id) ?? // Select list field type
               "";
            sortFields.push({
               key: fieldId,
               dir: dir,
            });
         });
      }
      return sortFields;
   }

   /**
    * @method onChangeCombo()
    * Update the display once they have chosen a field to sort by.
    * We now need to offer the appropriate sort direction chooser.
    * @param {string} fieldID
    *        The value of the combo box now.
    * @param {webix.$view} el
    *        The current Webix.$view that was the combo box that just
    *        changed.
    */
   onChangeCombo(fieldID, el) {
      var allFields = this.CurrentObject.fields();
      var chosenField = null,
         sortDir = el.getParentView().getChildViews()[1],
         // isMultiLingual = el.getParentView().getChildViews()[2],
         // isMulti = 0,
         options = null;

      chosenField = allFields.find((f) => f.id == fieldID);
      if (!chosenField) return;

      switch (chosenField.key) {
         case "date":
            options = [
               { id: "asc", value: L("Before -> After") },
               { id: "desc", value: L("After -> Before") },
            ];
            break;
         case "number":
            options = [
               { id: "asc", value: L("1 -> 9") },
               { id: "desc", value: L("9 -> 1") },
            ];
            break;
         case "string":
         default:
            options = [
               { id: "asc", value: L("A -> Z") },
               { id: "desc", value: L("Z -> A") },
            ];
            break;
      }

      if (chosenField.key == "list") {
         AB.Webix.ui(this._valueListElement(chosenField), sortDir);
      } else {
         const valElem = this._valueElement();
         valElem.options = options;
         AB.Webix.ui(valElem, sortDir);
      }

      // if (columnConfig.settings.supportMultilingual)
      //    isMulti = columnConfig.settings.supportMultilingual;

      // isMultiLingual.setValue(isMulti);

      this.refreshFieldList();
      this.triggerOnChange();
   }

   /**
    * @function onShow
    * Rebuild the form when an onShow() is called.
    */
   onShow(view, options) {
      var sort_form = $$(this.ids.form);

      // clear field options in the form
      webix.ui(this.uiForm(), sort_form);

      var sorts = this._settings;
      if (sorts && sorts.forEach) {
         sorts.forEach((s) => {
            this.clickAddNewSort(s.key, s.dir);
         });
      }

      if (sorts == null || sorts.length == 0) {
         this.clickAddNewSort();
      }

      const $popup = $$(this.ids.component);
      $popup?.blockEvent();
      $popup?.show(view, options);
      $popup?.unblockEvent();
   }

   /**
    * @method refreshFieldList
    * return an updated field list so you cannot duplicate a sort
    * @param {bool} ignoreRemoveViews
    *
    */
   refreshFieldList(ignoreRemoveViews) {
      var sort_form = $$(this.ids.form),
         listFields = this.getFieldList(false),
         selectedFields = [],
         removeChildViews = [];

      var childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach(function (cView, index) {
            if (childViews.length - 1 <= index) return false;

            let fieldId = cView.getChildViews()[0].getValue(),
               // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId });
               fieldObj = listFields.filter((f) => {
                  return f.id == fieldId;
               });

            if (fieldObj.length > 0) {
               // Add selected field to list
               selectedFields.push(fieldObj[0]);
            } else {
               // Add condition to remove
               removeChildViews.push(cView);
            }
         });
      }

      // Remove filter conditions when column is deleted
      if (!ignoreRemoveViews) {
         removeChildViews.forEach((cView /*, index */) => {
            sort_form.removeView(cView);
         });
      }

      // Field list should not duplicate field items
      childViews = sort_form.getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach((cView, index) => {
            if (childViews.length - 1 <= index) return false;

            let fieldId = cView.getChildViews()[0].getValue(),
               // fieldObj = $.grep(listFields, function (f) { return f.id == fieldId }),
               fieldObj = listFields.filter((f) => {
                  return f.id == fieldId;
               });

            // var selectedFieldsExcludeCurField = $(selectedFields).not(fieldObj);
            var selectedFieldsExcludeCurField = selectedFields.filter((x) => {
               if (Array.isArray(fieldObj) && fieldObj.indexOf(x) !== -1) {
                  return false;
               }
               return true;
            });

            // var enableFields = $(listFields).not(selectedFieldsExcludeCurField).get();
            var enableFields = listFields.filter((x) => {
               if (
                  Array.isArray(selectedFieldsExcludeCurField) &&
                  selectedFieldsExcludeCurField.indexOf(x) !== -1
               ) {
                  return false;
               }
               return true;
            });

            // Update field list
            cView.getChildViews()[0].define("options", enableFields);
            cView.getChildViews()[0].refresh();
         });
      }
   }

   /**
    * @function triggerOnChange
    * This parses the sort form to build in order the sorts then saves to the application object workspace
    */
   triggerOnChange() {
      // block .onChange callback
      if (this._blockOnChange) return;

      this._settings = this.getSettings();

      this.emit("changed", this._settings);
   }

   blockOnChange() {
      this._blockOnChange = true;
   }

   unblockOnChange() {
      this._blockOnChange = false;
   }

   /**
    * @function show()
    * Show this component.
    * @param {obj} $view
    *        the webix.$view to hover the popup around.
    * @param {uuid} fieldId
    *        the ABField.id we want to prefill the sort with
    * @param {json} options
    *        Additional webix.show() options parameters.
    */
   show($view, fieldId, options) {
      this.blockOnChange();

      this.onShow($view, options || null);

      if (fieldId) {
         this.clickAddNewSort(fieldId);
      }

      this.unblockOnChange();
   }

   /**
    * @function sort()
    * client sort data in list
    *
    * @param {Object} a
    * @param {Object} b
    */
   sort(a, b) {
      let result = 0;

      const childViews = $$(this.ids.form).getChildViews();
      if (childViews.length > 1) {
         // Ignore 'Add new sort' button
         childViews.forEach((cView, index) => {
            if (childViews.length - 1 <= index || result != 0) return;

            const fieldId = cView.getChildViews()[0].getValue();
            const dirElem = cView.getChildViews()[1];
            const dir =
               dirElem?.getValue?.() ??
               dirElem?.data?.getRange?.()?.map((opt) => opt.id) ?? // Select list field type
               "";

            const field = this.CurrentObject.fieldByID(fieldId);
            if (!field) return;

            const by = field.columnName; // column name

            let aValue = a[by],
               bValue = b[by];

            if (field.key == "list") {
               aValue = dir.indexOf(aValue);
               bValue = dir.indexOf(bValue);
            }

            if (Array.isArray(aValue)) {
               aValue = (aValue || [])
                  .map((item) => item.text || item)
                  .join(" ");
            }

            if (Array.isArray(bValue)) {
               bValue = (bValue ?? [])
                  .map((item) => item.text || item)
                  .join(" ");
            }

            if (aValue != bValue) {
               if (dir == "asc" || field.key == "list") {
                  result = aValue > bValue ? 1 : -1;
               } else {
                  result = aValue < bValue ? 1 : -1;
               }
            }
         });
      }

      return result;
   }

   _valueElement() {
      return {
         view: "segmented",
         width: 200,
         options: [
            {
               id: "",
               value: L("Please select field"),
            },
         ],
         on: {
            onChange: (/* newv, oldv */) => {
               // 'asc' or 'desc' values
               this.triggerOnChange();
            },
         },
      };
   }

   _valueListElement(field) {
      return {
         view: "list",
         template: "<div class='webix_drag_handle'></div> #text#",
         type: {
            height: 35,
         },
         height: 150,
         select: true,
         drag: "order",
         data: field.options(),
         on: {
            onChange: () => {
               this.triggerOnChange();
            },
            onAfterDrop: () => {
               this.triggerOnChange();
            },
         },
      };
   }
}


/***/ }),

/***/ 44998:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewImage.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewImageCore = __webpack_require__(/*! ../../core/views/ABViewImageCore */ 94606);
const ABViewImageComponent = __webpack_require__(/*! ./viewComponent/ABViewImageComponent */ 58942);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewImage extends ABViewImageCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewImageComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      if (!this.settings.filename) {
         this.warningsMessage(`has no image set`);
      }
   }
};


/***/ }),

/***/ 13665:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewKanban.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewKanban)
/* harmony export */ });
const ABViewKanbanCore = __webpack_require__(/*! ../../core/views/ABViewKanbanCore */ 42928);
const ABViewKanbanComponent = __webpack_require__(/*! ./viewComponent/ABViewKanbanComponent */ 3893);

const ABViewPropertyLinkPage =
   (__webpack_require__(/*! ./viewProperties/ABViewPropertyLinkPage */ 25733)["default"]);

class ABViewKanban extends ABViewKanbanCore {
   //
   //	Editor Related
   //

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */

   component() {
      return new ABViewKanbanComponent(this);
   }

   get linkPageHelper() {
      return (this.__linkPageHelper =
         this.__linkPageHelper || new ABViewPropertyLinkPage());
   }

   warningsEval() {
      super.warningsEval();
      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
}


/***/ }),

/***/ 47304:
/*!****************************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewKanbanFormSidePanel.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * ABViewKanbanFormSidePanel
 *
 * Provide a form area for editing data in the Kan Ban view.
 *
 */

const ABViewComponent = (__webpack_require__(/*! ./viewComponent/ABViewComponent */ 44363)["default"]);
const ABViewForm = __webpack_require__(/*! ./ABViewForm */ 40194);
const ABViewFormButton = __webpack_require__(/*! ./ABViewFormButton */ 44388);

var L = null;
// multilingual Label fn()

module.exports = class ABWorkObjectKanBan extends ABViewComponent {
   constructor(comKanBan, idBase, editFields) {
      idBase = idBase || `${comKanBan.view?.id}_formSidePanel`;
      super(idBase, {
         form: "",
      });

      if (!L) {
         L = (...params) => {
            return this.AB.Multilingual.label(...params);
         };
      }

      this.AB = comKanBan.AB;

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.editFields = editFields;
      // {array}
      // An array of {ABField.id} that determines which fields should show up
      // in the editor.

      this._mockApp = this.AB.applicationNew({});
      // {ABApplication}
      // Any ABViews we create are expected to be in relation to
      // an ABApplication, so we create a "mock" app for our
      // workspace views to use to display.
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }

   ui() {
      var ids = this.ids;

      // Our webix UI definition:
      return {
         id: ids.component,
         width: 300,
         hidden: true,
         rows: [
            {
               view: "toolbar",
               css: "webix_dark",
               cols: [
                  {
                     view: "label",
                     label: L("Edit Record"),
                  },
                  {
                     view: "icon",
                     icon: "wxi-close",
                     align: "right",
                     click: (/* id */) => {
                        this.hide();
                     },
                  },
               ],
            },
            {
               view: "scrollview",
               body: {
                  rows: [
                     {
                        id: ids.form,
                        view: "form",
                        borderless: true,
                        rows: [],
                     },
                  ],
               },
            },
         ],
      };
   }

   async init(AB) {
      this.AB = AB;
   }

   objectLoad(object) {
      this.CurrentObjectID = object.id;
   }

   hide() {
      $$(this.ids.component)?.hide();

      this.emit("close");
   }

   show(data) {
      $$(this.ids.component)?.show();

      this.refreshForm(data);
   }

   isVisible() {
      return $$(this.ids.component)?.isVisible() ?? false;
   }

   refreshForm(data) {
      var ids = this.ids;
      let $formView = $$(ids.form);
      let CurrentObject = this.CurrentObject;

      if (!CurrentObject || !$formView) return;

      data = data || {};

      let formAttrs = {
         id: `${this.ids.component}_sideform`,
         key: ABViewForm.common().key,
         settings: {
            columns: 1,
            labelPosition: "top",
            showLabel: 1,
            clearOnLoad: 0,
            clearOnSave: 0,
            labelWidth: 120,
            height: 0,
         },
      };

      // let form = new ABViewForm(formAttrs, this._mockApp);
      let form = this.AB.viewNewDetatched(formAttrs);

      form.objectLoad(CurrentObject);

      // Populate child elements
      CurrentObject.fields().forEach((f, index) => {
         // if this is one of our .editFields
         if (!this.editFields || this.editFields.indexOf(f.id) > -1) {
            form.addFieldToForm(f, index);
         }
      });

      // add default button (Save button)
      form._views.push(
         new ABViewFormButton(
            {
               settings: {
                  includeSave: true,
                  includeCancel: false,
                  includeReset: false,
               },
               position: {
                  y: CurrentObject.fields().length, // yPosition
               },
            },
            this._mockApp,
            form
         )
      );

      // add temp id to views
      form._views.forEach(
         (v, index) => (v.id = `${form.id}_${v.key}_${index}`)
      );

      let formCom = form.component(this.AB._App);

      // Rebuild form
      webix.ui(formCom.ui().rows.concat({}), $formView);
      webix.extend($formView, webix.ProgressBar);

      formCom.init(
         this.AB,
         2,
         {
            onBeforeSaveData: () => {
               // get update data
               var formVals = form.getFormValues($formView, CurrentObject);

               // validate data
               if (!form.validateData($formView, CurrentObject, formVals))
                  return false;

               // show progress icon
               $formView?.showProgress({ type: "icon" });

               if (formVals.id) {
                  CurrentObject.model()
                     .update(formVals.id, formVals)
                     .then((updateVals) => {
                        this.emit("update", updateVals);
                        // _logic.callbacks.onUpdateData(updateVals);

                        $formView?.hideProgress({ type: "icon" });
                     })
                     .catch((err) => {
                        // TODO : error message
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewKanbanFormSidePanel:onBeforeSaveData():update(): Error updating value",
                           formVals,
                        });
                        $formView?.hideProgress({ type: "icon" });
                     });
               }
               // else add new row
               else {
                  CurrentObject.model()
                     .create(formVals)
                     .then((newVals) => {
                        // _logic.callbacks.onAddData(newVals);
                        this.emit("add", newVals);

                        $formView?.hideProgress({ type: "icon" });
                     })
                     .catch((err) => {
                        // TODO : error message
                        this.AB.notify.developer(err, {
                           context:
                              "ABViewKanbanFormSidePanel:onBeforeSaveData():.create(): Error creating value",
                           formVals,
                        });

                        $formView?.hideProgress({ type: "icon" });
                     });
               }

               return false;
            },
         },
         2 /* NOTE: if you can see this KanBan, you should be able to see the side form? */
      );

      // display data
      $formView.clear();
      $formView.parse(data);

      formCom.onShow(data);
   }
};


/***/ }),

/***/ 47935:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewLabel.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewLabelCore = __webpack_require__(/*! ../../core/views/ABViewLabelCore */ 29247);
const ABViewLabelComponent = __webpack_require__(/*! ./viewComponent/ABViewLabelComponent */ 97922);

module.exports = class ABViewLabel extends ABViewLabelCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewLabelComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      if (!this.text) {
         this.warningsMessage("has no text value set.");
      }
   }
};


/***/ }),

/***/ 90427:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewLayout.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewLayoutCore = __webpack_require__(/*! ../../core/views/ABViewLayoutCore */ 79361);
const ABViewLayoutComponent = __webpack_require__(/*! ./viewComponent/ABViewLayoutComponent */ 30909);

module.exports = class ABViewLayout extends ABViewLayoutCore {
   /**
    * @function component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewLayoutComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      if (this._views.length == 0) {
         this.warningsMessage("has no columns set.");
      }
   }
};


/***/ }),

/***/ 94116:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewList.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewListCore = __webpack_require__(/*! ../../core/views/ABViewListCore */ 17145);
const ABViewListComponent = __webpack_require__(/*! ./viewComponent/ABViewListComponent */ 4030);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewList extends ABViewListCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewListComponent(this);
   }

   warningsEval() {
      super.warningsEval();
      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
};


/***/ }),

/***/ 85342:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewMenu.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewMenuCore = __webpack_require__(/*! ../../core/views/ABViewMenuCore */ 57888);
const ABViewMenuComponent = __webpack_require__(/*! ./viewComponent/ABViewMenuComponent */ 46078);

module.exports = class ABViewMenu extends ABViewMenuCore {
   /**
    * @function component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewMenuComponent(this);
   }
};


/***/ }),

/***/ 7617:
/*!********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewPDFImporter.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewPDFImporterCore = __webpack_require__(/*! ../../core/views/ABViewPDFImporterCore */ 47497);
const ABViewPDFImporterComponent = __webpack_require__(/*! ./viewComponent/ABViewPDFImporterComponent */ 90510);

module.exports = class ABViewPDFImporter extends ABViewPDFImporterCore {
   /**
    * @function component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewPDFImporterComponent(this);
   }
};


/***/ }),

/***/ 2983:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewPage.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewPageCore = __webpack_require__(/*! ../../core/views/ABViewPageCore */ 28326);

const ABPropertyComponentDefaults = ABViewPageCore.defaultValues();

module.exports = class ABViewPage extends ABViewPageCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} v1App
    * @return {obj} UI component
    */
   component(v1App = false) {
      var component = super.component();

      component._ui = component.ui();

      // wrap our ABViewContainer in our Page scrollview
      component.ui = () => {
         return {
            view: "scrollview",
            borderless: true,
            css:
               this.settings.pageBackground ||
               ABPropertyComponentDefaults.pageBackground,
            body: component._ui,
         };
      };

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: component.ui(),
            init: (options, accessLevel) => {
               accessLevel = accessLevel ?? this.getUserAccess();
               return newComponent.init(this.AB, accessLevel, options);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no sub views");
      }

      (this.pages() || []).forEach((p) => {
         p.warningsEval();
      });
   }
};


/***/ }),

/***/ 40912:
/*!**************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewPivot.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewPivotCore = __webpack_require__(/*! ../../core/views/ABViewPivotCore */ 89062);
const ABViewPivotComponent = __webpack_require__(/*! ./viewComponent/ABViewPivotComponent */ 5740);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewPivot extends ABViewPivotCore {
   constructor(values, application, parent, defaultValues) {
      super(values, application, parent, defaultValues);
   }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewPivotComponent(this);
   }

   warningsEval() {
      super.warningsEval();

      let DC = this.datacollection;
      if (!DC) {
         this.warningsMessage(
            `can't resolve it's datacollection[${this.settings.dataviewID}]`
         );
      }
   }
};


/***/ }),

/***/ 25583:
/*!***********************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewReportsManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewReportsManagerCore = __webpack_require__(/*! ../../core/views/ABViewReportsManagerCore */ 78379);
const ABViewReportsManagerComponent = __webpack_require__(/*! ./viewComponent/ABViewReportsManagerComponent */ 33188);

module.exports = class ABViewReportsManager extends ABViewReportsManagerCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   //
   //	Editor Related
   //

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewReportsManagerComponent(this);
   }
};


/***/ }),

/***/ 68695:
/*!******************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewScheduler.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewSchedulerCore = __webpack_require__(/*! ../../core/views/ABViewSchedulerCore */ 47385);
const ABViewSchedulerComponent = __webpack_require__(/*! ./viewComponent/ABViewSchedulerComponent */ 79608);

module.exports = class ABViewScheduler extends ABViewSchedulerCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component() {
      return new ABViewSchedulerComponent(this);
   }

   warningsEval() {
      super.warningsEval();
   }
};


/***/ }),

/***/ 69366:
/*!************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewTab.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewTabCore = __webpack_require__(/*! ../../core/views/ABViewTabCore */ 39646);

const ABViewTabComponent = __webpack_require__(/*! ./viewComponent/ABViewTabComponent */ 59724);

module.exports = class ABViewTab extends ABViewTabCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(v1App = false) {
      let component = new ABViewTabComponent(this);

      // if this is our v1Interface
      if (v1App) {
         const newComponent = component;

         component = {
            ui: newComponent.ui(),
            init: (options, accessLevel) => {
               return newComponent.init(this.AB);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
         };
      }

      return component;
   }

   warningsEval() {
      super.warningsEval();

      let allViews = this.views();

      if (allViews.length == 0) {
         this.warningsMessage("has no tabs set");
      }

      // NOTE: this is done in ABView:
      // (this.views() || []).forEach((v) => {
      //    v.warningsEval();
      // });
   }
};


/***/ }),

/***/ 69330:
/*!*************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewText.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewTextCore = __webpack_require__(/*! ../../core/views/ABViewTextCore */ 63527);

const ABViewTextComponent = __webpack_require__(/*! ./viewComponent/ABViewTextComponent */ 97669);

module.exports = class ABViewText extends ABViewTextCore {
   /**
    * @method component()
    * return a UI component based upon this view.
    * @return {obj} UI component
    */
   component(parentId) {
      return new ABViewTextComponent(this, parentId);
   }
};


/***/ }),

/***/ 4814:
/*!***************************************************!*\
  !*** ./AppBuilder/platform/views/ABViewWidget.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewWidgetCore = __webpack_require__(/*! ../../core/views/ABViewWidgetCore */ 8846);

const ABPropertyComponentDefaults = ABViewWidgetCore.defaultValues();

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewWidget extends ABViewWidgetCore {
   // constructor(values, application, parent, defaultValues) {
   //    super(values, application, parent, defaultValues);
   // }

   /**
    * @function component()
    * return a UI component based upon this view.
    * @param {obj} App
    * @return {obj} UI component
    */
   component(App) {
      let base = super.component(App);

      base.onShow = (viewId) => {
         let dv = this.datacollection; // get from a function or a (get) property
         if (dv && dv.dataStatus == dv.dataStatusFlag.notInitial) {
            // load data when a widget is showing
            dv.loadData();
         }
      };

      return base;
   }
};


/***/ }),

/***/ 26822:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewCSVExporterComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewCSVExporterComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABCSVExporter_${baseView.id}`,
         Object.assign(
            {
               button: "",
               buttonFilter: "",
               filterComplex: "",
            },
            ids
         )
      );

      this.clientFilter = null;
   }

   ui() {
      const ids = this.ids;
      const settings = this.settings;
      const defaultSettings = this.view.constructor.defaultValues();
      const _ui = super.ui([
         {
            view: "layout",
            type: "clean",
            borderless: true,
            cols: [
               {
                  id: ids.buttonFilter,
                  view: "button",
                  css: "webix_transparent",
                  type: "icon",
                  icon: "fa fa-filter",
                  borderless: true,
                  width: 50,
                  label: "",
                  click: () => {
                     this.showFilterPopup();
                  },
               },
               {
                  id: ids.button,
                  view: "button",
                  css: "webix_primary",
                  type: "icon",
                  icon: "fa fa-download",
                  borderless: true,
                  width: settings.width || defaultSettings.width,
                  label: settings.buttonLabel ?? defaultSettings.buttonLabel,
                  click: () => {
                     this.downloadCsvFile();
                  },
               },
               { fillspace: true },
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      if (!this.clientFilter) {
         const clientFilter = AB.filterComplexNew(this.ids.filterComplex);

         const dc = this.datacollection;

         if (dc) {
            const obj = dc.datasource;

            clientFilter.fieldsLoad(obj?.fields?.() ?? []);
         }

         clientFilter.init();
         clientFilter.on("change", (val) => {
            this.onFilterChange(val);
         });

         this.clientFilter = clientFilter;
      }
   }

   downloadCsvFile() {
      let url = `/appbuilder/csv-export/${this.view.id}`;

      const where = {
         glue: "and",
         rules: [],
      };

      const whereWidget = this.view.settings?.where;
      if ((whereWidget?.rules ?? []).length) {
         where.rules.push(whereWidget);
      }

      const whereClient = this.clientFilter.getValue();
      if ((whereClient?.rules ?? []).length) {
         where.rules.push(whereClient);
      }

      if ((where?.rules || []).length) {
         let qsWhere = JSON.stringify(where);

         qsWhere = encodeURIComponent(qsWhere);
         url = `${url}?where=${qsWhere}`;
      }

      window.open(url);
   }

   showFilterPopup() {
      const $buttonFilter = $$(this.ids.buttonFilter);

      this.clientFilter.popUp($buttonFilter ? $buttonFilter.$view : null);
   }

   onFilterChange() {
      const $buttonFilter = $$(this.ids.buttonFilter);

      if (!$buttonFilter) return;

      const where = this.clientFilter.getValue();

      $buttonFilter.define("badge", (where.rules || []).length || null);
      $buttonFilter.refresh();
   }
};


/***/ }),

/***/ 67090:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewCSVImporterComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);
const CSVImporter = __webpack_require__(/*! ../../CSVImporter */ 88708);

module.exports = class ABViewCSVImporterComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABCSVImporter_${baseView.id}`,
         Object.assign(
            {
               button: "",
               popup: "",

               form: "",
               uploader: "",
               uploadFileList: "",
               separatedBy: "",
               headerOnFirstLine: "",
               columnList: "",

               search: "",
               datatable: "",

               statusMessage: "",
               progressBar: "",

               linkedDataButton: "",
               importButton: "",
               rules: "",
            },
            ids
         )
      );

      this.csvImporter = new CSVImporter((...args) => this.label(...args));
      // {CSVImporter}
      // An instance of the object that imports the CSV data.

      this.validationError = false;

      this._dataRows = null;
      this._csvFileInfo = null;
   }

   ui() {
      const settings = this.settings;
      const defaultSettings = this.view.constructor.defaultValues();
      const _ui = super.ui([
         {
            cols: [
               {
                  view: "button",
                  css: "webix_primary",
                  type: "icon",
                  icon: "fa fa-upload",
                  label: this.label(
                     settings.buttonLabel || defaultSettings.buttonLabel
                  ),
                  width: settings.width || defaultSettings.width,
                  click: () => {
                     this.showPopup();
                  },
               },
               {
                  fillspace: true,
               },
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   uiConfig() {
      const ids = this.ids;

      return {
         id: ids.form,
         view: "form",
         type: "clean",
         borderless: true,
         minWidth: 400,
         gravity: 1,
         elements: [
            {
               rows: [
                  {
                     id: ids.uploader,
                     view: "uploader",
                     name: "csvFile",
                     css: "webix_primary",
                     value: this.label("Choose a CSV file"),
                     accept: "text/csv",
                     multiple: false,
                     autosend: false,
                     link: ids.uploadFileList,
                     on: {
                        onBeforeFileAdd: (fileInfo) => {
                           this._csvFileInfo = fileInfo;

                           return this.loadCsvFile();
                        },
                     },
                  },
                  {
                     id: ids.uploadFileList,
                     name: "uploadedFile",
                     view: "list",
                     type: "uploader",
                     autoheight: true,
                     borderless: true,
                     onClick: {
                        webix_remove_upload: (e, id /*, trg */) => {
                           this.removeCsvFile(id);
                        },
                     },
                  },
                  {
                     padding: 10,
                     rows: [
                        {
                           id: ids.separatedBy,
                           view: "richselect",
                           name: "separatedBy",
                           label: this.label("Separated by"),
                           labelWidth: 140,
                           options: this.csvImporter.getSeparateItems(),
                           value: ",",
                           on: {
                              onChange: () => {
                                 this.loadCsvFile();
                              },
                           },
                        },
                        {
                           id: ids.headerOnFirstLine,
                           view: "checkbox",
                           name: "headerOnFirstLine",
                           label: this.label("Header on first line"),
                           labelWidth: 140,
                           disabled: true,
                           value: true,
                           on: {
                              onChange: (/*newVal, oldVal*/) => {
                                 this.populateColumnList();
                              },
                           },
                        },
                     ],
                  },
                  {
                     type: "space",
                     rows: [
                        {
                           view: "scrollview",
                           minHeight: 300,
                           body: {
                              padding: 10,
                              id: ids.columnList,
                              rows: [],
                           },
                        },
                     ],
                  },
               ],
            },
         ],
      };
   }

   uiRecordsView() {
      const ids = this.ids;

      return {
         gravity: 2,
         rows: [
            {
               view: "toolbar",
               css: "bg_gray",
               cols: [
                  { width: 5 },
                  {
                     id: ids.search,
                     view: "search",
                     value: "",
                     label: "",
                     placeholder: this.label("Search records..."),
                     keyPressTimeout: 200,
                     on: {
                        onTimedKeyPress: () => {
                           this.search($$(ids.search).getValue());
                        },
                     },
                  },
                  { width: 2 },
               ],
            },
            {
               id: ids.datatable,
               view: "datatable",
               resizeColumn: true,
               editable: true,
               editaction: "dblclick",
               css: "ab-csv-importer",
               borderless: false,
               tooltip: (obj) => {
                  const tooltip = obj._errorMsg
                     ? obj._errorMsg
                     : "No validation errors";
                  return tooltip;
               },
               minWidth: 650,
               columns: [],
               on: {
                  onValidationError: (id, obj, details) => {
                     // console.log(`item ${id} invalid`);
                     let errors = "";

                     Object.keys(details).forEach((key) => {
                        this.$view.complexValidations[key].forEach((err) => {
                           errors += err.invalidMessage + "</br>";
                        });
                     });

                     const $dt = $$(ids.datatable);

                     $dt.blockEvent();
                     $dt.updateItem(id, {
                        _status: "invalid",
                        _errorMsg: errors,
                     });
                     $dt.unblockEvent();

                     this.validationError = true;
                  },
                  onValidationSuccess: (id, obj, details) => {
                     // console.log(`item ${id} valid`);
                     const $dt = $$(ids.datatable);

                     $dt.blockEvent();
                     $dt.updateItem(id, {
                        _status: "valid",
                        _errorMsg: "",
                     });
                     $dt.unblockEvent();
                     this.validationError = false;
                  },
                  onCheck: () => {
                     const selected = $$(ids.datatable).find({
                        _included: true,
                     });
                     const $importButton = $$(ids.importButton);

                     $importButton.setValue(this.labelImport(selected));

                     if (this.overLimitAlert(selected)) $importButton.disable();
                     else $importButton.enable();
                  },
               },
            },
            {
               id: ids.progressBar,
               height: 6,
            },
            {
               cols: [
                  {
                     id: ids.linkedDataButton,
                     view: "button",
                     label: this.label("Linked Data"),
                     type: "icon",
                     icon: "fa fa-info",
                     maxWidth: 180,
                     click: () => {
                        this.showLinkedData();
                     },
                  },
                  {
                     view: "button",
                     name: "import",
                     id: ids.importButton,
                     label: this.label("Import"),
                     css: "webix_primary",
                     disabled: true,
                     type: "icon",
                     icon: "fa fa-upload",
                     click: () => {
                        this.import();
                     },
                  },
               ],
            },
         ],
      };
   }

   uiPopup() {
      const ids = this.ids;

      return {
         id: ids.popup,
         view: "window",
         hidden: true,
         position: "center",
         modal: true,
         resize: true,
         head: {
            view: "toolbar",
            css: "webix_dark",
            cols: [
               {},
               {
                  view: "label",
                  label: this.label("CSV Importer"),
                  autowidth: true,
               },
               {},
               {
                  view: "button",
                  width: 35,
                  css: "webix_transparent",
                  type: "icon",
                  icon: "nomargin fa fa-times",
                  click: () => {
                     this.hide();
                  },
               },
            ],
         },
         body: {
            type: "form",
            rows: [
               {
                  type: "line",
                  cols: [
                     this.uiConfig(),
                     { width: 20 },
                     this.uiRecordsView(),
                     { width: 1 },
                  ],
               },
               {
                  id: ids.statusMessage,
                  view: "label",
                  align: "right",
                  hidden: true,
               },
               {
                  hidden: true,
                  margin: 5,
                  cols: [
                     { fillspace: true },
                     {
                        view: "button",
                        name: "cancel",
                        value: this.label("Cancel"),
                        css: "ab-cancel-button",
                        autowidth: true,
                        click: () => {
                           this.hide();
                        },
                     },
                     /*,
                        {
                           view: "button",
                           name: "import",
                           id: ids.importButton,
                           value: labels.component.import,
                           css: "webix_primary",
                           disabled: true,
                           autowidth: true,
                           type: "form",
                           click: () => {
                              _logic.import();
                           }
                        }*/
                  ],
               },
            ],
         },
      };
   }

   async init(AB) {
      await super.init(AB);

      const ids = this.ids;

      // Populate values to rules

      const dc = this.datacollection;

      if (dc) this.objectLoad(dc.datasource);

      const abWebix = AB.Webix;

      abWebix.ui(this.uiPopup());

      const $form = $$(ids.form);

      if ($form) abWebix.extend($form, abWebix.ProgressBar);

      const $progressBar = $$(ids.progressBar);

      if ($progressBar) abWebix.extend($progressBar, abWebix.ProgressBar);
   }

   showPopup() {
      const ids = this.ids;

      $$(ids.popup)?.show();

      this.formClear();

      // open file dialog to upload
      $$(ids.uploader).fileDialog();
   }

   hide() {
      $$(this.ids.popup)?.hide();
   }

   formClear() {
      const ids = this.ids;

      this._dataRows = null;
      this._csvFileInfo = null;

      const $form = $$(ids.form);

      $form.clearValidation();
      $form.clear();

      $$(ids.separatedBy).setValue(",");

      this.AB.Webix.ui([], $$(ids.columnList));

      $$(ids.headerOnFirstLine).disable();
      $$(ids.importButton).disable();

      $$(ids.search).setValue("");
      $$(ids.uploadFileList).clearAll();
      $$(ids.datatable).clearAll();

      const $statusMessage = $$(ids.statusMessage);

      $statusMessage.setValue("");
      $statusMessage.hide();
   }

   search(searchText) {
      const $datatable = $$(this.ids.datatable);

      if (!$datatable) return;

      searchText = (searchText || "").toLowerCase();

      const matchFields = this.getMatchFields();

      $datatable.filter((row) => {
         let exists = false;

         (matchFields || []).forEach((f) => {
            if (exists) return;

            exists =
               (row[`${f.columnIndex}`] || "")
                  .toString()
                  .toLowerCase()
                  .indexOf(searchText) > -1;
         });

         return exists;
      });
   }

   statusTemplate(item) {
      let template = "";

      if (!item) return template;

      switch (item._status) {
         case "in-progress":
            template = "<span class='fa fa-refresh'></span>";
            break;
         case "invalid":
            template = "<span class='fa fa-exclamation-triangle'></span>";
            break;
         case "valid":
            template = "<span class='fa fa-check'></span>";
            break;
         case "done":
            template = "<span class='fa fa-check'></span>";
            break;
         case "fail":
            template = "<span class='fa fa-remove'></span>";
            break;
      }

      return template;
   }

   async loadCsvFile() {
      const _csvFileInfo = this._csvFileInfo;

      if (!_csvFileInfo) return false;

      const csvImporter = this.csvImporter;

      if (!csvImporter.validateFile(_csvFileInfo)) {
         this.AB.Webix.alert({
            title: this.label("This file extension is not allowed"),
            text: this.label("Please only upload CSV files"),
            ok: this.label("Ok"),
         });

         return false;
      }

      const ids = this.ids;

      // show loading cursor
      const $form = $$(ids.form);

      $form?.showProgress?.({ type: "icon" });

      // read CSV file
      const $headerOnFirstLine = $$(ids.headerOnFirstLine);
      const $importButton = $$(ids.importButton);

      $headerOnFirstLine.enable();
      $importButton.enable();

      this._dataRows = await csvImporter.getDataRows(
         _csvFileInfo,
         $$(ids.separatedBy).getValue()
      );

      const _dataRows = this._dataRows;

      let length = _dataRows.length;

      if ($headerOnFirstLine.getValue()) length = _dataRows.length - 1;

      $importButton.setValue(this.labelImport(length));
      this.populateColumnList();
      $form?.hideProgress?.();

      return true;
   }

   removeCsvFile(fileId) {
      $$(this.ids.uploadFileList).remove(fileId);
      this.formClear();

      return true;
   }

   populateColumnList() {
      const self = this;
      const ids = this.ids;
      const abWebix = this.AB.Webix;

      // clear list
      const $columnList = $$(ids.columnList);

      abWebix.ui([], $columnList);

      const _dataRows = this._dataRows;

      if (!_dataRows) return;

      // check first line of CSV
      const firstLine = _dataRows[0];

      if (!firstLine) return;

      const csvColumnList = [];
      const fieldList = [];
      const currentObject = this.CurrentObject;

      if (currentObject)
         fieldList.push(
            ...currentObject.fields((f) => {
               // available fields
               if (
                  this.settings.availableFieldIds?.length &&
                  this.settings.availableFieldIds.indexOf(f.id) < 0
               ) {
                  return false;
               }

               // filter editable fields
               const formComp = f.formComponent();

               if (!formComp) return true;

               const formConfig = formComp.common();

               if (!formConfig) return true;

               return formConfig.key != "fieldreadonly";
            })
         );

      const csvImporter = this.csvImporter;

      // check first line be header columns
      if ($$(ids.headerOnFirstLine).getValue())
         csvColumnList.push(
            ...firstLine.map((colName, index) => {
               return {
                  id: index + 1, // webix .options list disallow value 0
                  value: colName,
                  key: csvImporter.getGuessDataType(_dataRows, index),
               };
            })
         );
      else
         firstLine.forEach((e, i) => {
            csvColumnList.push({
               id: i + 1, // webix .options list disallow value 0
               value: this.label("Column {0}", [i + 1]),
               key: csvImporter.getGuessDataType(_dataRows, i),
            });
         });

      // Add unselect item
      csvColumnList.unshift({
         id: "none",
         value: this.label("None"),
      });

      // populate columns to UI
      const uiColumns = [];
      const selectedCsvCols = [];

      fieldList.forEach((f) => {
         // match up by data type
         const matchCol = csvColumnList.filter(
            (c) => c.key == f.key && selectedCsvCols.indexOf(c.id) < 0
         )[0];

         let selectVal = "none";

         if (matchCol) {
            selectVal = matchCol.id;

            // cache
            selectedCsvCols.push(selectVal);
         }

         let columnOptUI = {
            view: "richselect",
            gravity: 2,
            options: csvColumnList,
            fieldId: f.id,
            abName: "columnIndex",
            value: selectVal,
            on: {
               onChange: function () {
                  self.toggleLinkFields(this);
                  self.loadDataToGrid();
               },
            },
         };

         // Add date format options
         if (f.key === "date") {
            const dateSeparatorOptions = ["/", "-", ".", ",", " "];
            const dayFormatOptions = [
               { value: this.label("1 to 31"), id: "D" },
               { value: this.label("01 to 31"), id: "DD" },
            ];
            const monthFormatOptions = [
               { value: this.label("1 to 12"), id: "M" },
               { value: this.label("01 to 12"), id: "MM" },
            ];
            const yearFormatOptions = [
               { value: this.label("00 to 99"), id: "YY" },
               { value: this.label("2000 to 2099"), id: "YYYY" },
            ];
            const dateOrderOptions = [
               {
                  value: this.label("D-M-Y"),
                  id: 1,
               },
               {
                  value: this.label("M-D-Y"),
                  id: 2,
               },
               {
                  value: this.label("Y-M-D"),
                  id: 3,
               },
               {
                  value: this.label("Y-D-M"),
                  id: 4,
               },
            ];

            columnOptUI = {
               gravity: 2,
               rows: [
                  columnOptUI,
                  {
                     view: "richselect",
                     label: this.label("Separator"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "separator",
                     abName: "columnDateFormat",
                     options: dateSeparatorOptions,
                     value: "/",
                  },
                  {
                     view: "richselect",
                     label: this.label("Day"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "day",
                     abName: "columnDateFormat",
                     options: dayFormatOptions,
                     value: "D",
                  },
                  {
                     view: "richselect",
                     label: this.label("Month"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "month",
                     abName: "columnDateFormat",
                     options: monthFormatOptions,
                     value: "M",
                  },
                  {
                     view: "richselect",
                     label: this.label("Year"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "year",
                     abName: "columnDateFormat",
                     options: yearFormatOptions,
                     value: "YY",
                  },
                  {
                     view: "richselect",
                     label: this.label("Order"),
                     labelWidth: 100,
                     on: {
                        onChange: () => {
                           this.loadDataToGrid();
                        },
                     },
                     name: "order",
                     abName: "columnDateFormat",
                     options: dateOrderOptions,
                     value: 1,
                  },
               ],
            };
         }

         // Add connected field options
         if (f.isConnection) {
            let linkFieldOptions = [];

            if (f.datasourceLink) {
               linkFieldOptions = f.datasourceLink
                  .fields((fld) => !fld.isConnection)
                  .map((fld) => {
                     return {
                        id: fld.id,
                        value: fld.label,
                     };
                  });
            }

            columnOptUI = {
               gravity: 2,
               rows: [
                  columnOptUI,
                  {
                     view: "richselect",
                     label: "=",
                     labelWidth: 20,
                     abName: "columnLinkData",
                     hidden: true,
                     options: linkFieldOptions,
                     value: linkFieldOptions[0] ? linkFieldOptions[0].id : null,
                  },
               ],
            };
         }

         uiColumns.push({
            view: "layout",
            borderless: true,
            cols: [
               {
                  view: "template",
                  gravity: 1,
                  borderless: true,
                  css: { "padding-top": 10 },
                  template: `<span class="fa fa-${f.icon}"></span> ${f.label}`,
               },
               columnOptUI,
            ],
         });
      });
      abWebix.ui(uiColumns, $columnList);

      this.loadDataToGrid();
   }

   toggleLinkFields($columnOption) {
      if (!$columnOption) return;

      const $optionPanel = $columnOption.getParentView();
      const $linkFieldOption = $optionPanel.queryView(
         { abName: "columnLinkData" },
         "all"
      )[0];

      if (!$linkFieldOption) return;

      if ($columnOption.getValue() === "none") $linkFieldOption.hide();
      else $linkFieldOption.show();
   }

   overLimitAlert(data) {
      const limit = 1000;

      if (data.length > limit) {
         // we only allow 1000 record imports
         this.AB.Webix.alert({
            title: this.label("Too many records"),
            ok: this.label("Ok"),
            text: this.label(
               "Due to browser limitations we only allow imports of {0} records. Please upload a new CSV or deselect records to import.",
               [limit]
            ),
         });

         return true;
      }

      return false;
   }

   loadDataToGrid() {
      const ids = this.ids;
      const $datatable = $$(ids.datatable);
      const ab = this.AB;

      if (!$datatable) return;

      $datatable.clearAll();

      // show loading cursor
      $datatable.showProgress?.({ type: "icon" });

      /** Prepare Columns */
      const matchFields = this.getMatchFields();
      const columns = [];

      // add "status" column
      columns.push({
         id: "_status",
         header: "",
         template: this.statusTemplate,
         width: 30,
      });

      // add "checkbox" column
      columns.push({
         id: "_included",
         header: { content: "masterCheckbox" },
         template: "{common.checkbox()}",
         width: 30,
      });

      const fieldValidations = [];
      const rulePops = [];

      // populate columns
      (matchFields || []).forEach((f) => {
         let validationRules = f.field.settings.validationRules;
         // parse the rules because they were stored as a string
         // check if rules are still a string...if so lets parse them
         if (validationRules && typeof validationRules === "string")
            validationRules = JSON.parse(validationRules);

         if (validationRules?.length) {
            const validationUI = [];

            // there could be more than one so lets loop through and build the UI
            validationRules.forEach((rule) => {
               const Filter = ab.filterComplexNew(
                  `${f.field.id}_${ab.Webix.uid()}`
               );
               // add the new ui to an array so we can add them all at the same time
               validationUI.push(Filter.ui);
               // store the filter's info so we can assign values and settings after the ui is rendered
               fieldValidations.push({
                  filter: Filter,
                  view: Filter.ids.querybuilder,
                  columnName: f.field.id,
                  validationRules: rule.rules,
                  invalidMessage: rule.invalidMessage,
                  columnIndex: f.columnIndex,
               });
            });

            // create a unique view id for popup
            const popUpId = `${ids.rules}_${f.field.id}_${ab.Webix.uid()}`;

            // store the popup ids so we can remove the later
            rulePops.push(popUpId);
            // add the popup to the UI but don't show it
            ab.Webix.ui({
               view: "popup",
               css: "ab-rules-popup",
               id: popUpId,
               body: {
                  rows: validationUI,
               },
            });
         }

         const editor = f.field?.key == "number" ? "number" : "text";

         columns.push({
            id: f.columnIndex,
            header: f.field.label,
            editor: editor,
            template: (obj, common, value /*, col, ind */) =>
               value.replace(/[<]/g, "&lt;"),
            minWidth: 150,
            fillspace: true,
         });
      });

      if (fieldValidations.length) {
         // we need to store the rules for use later so lets build a container array
         const complexValidations = [];

         fieldValidations.forEach((f) => {
            // init each ui to have the properties (app and fields) of the object we are editing
            // f.filter.applicationLoad(App);
            f.filter.fieldsLoad(this.CurrentObject.fields());
            // now we can set the value because the fields are properly initialized
            f.filter.setValue(f.validationRules);
            // if there are validation rules present we need to store them in a lookup hash
            // so multiple rules can be stored on a single field
            if (!Array.isArray(complexValidations[f.columnName]))
               complexValidations[f.columnName] = [];

            // now we can push the rules into the hash
            complexValidations[f.columnName].push({
               filters: $$(f.view).getFilterHelper(),
               values: $datatable.getSelectedItem(),
               invalidMessage: f.invalidMessage,
               columnIndex: f.columnIndex,
            });
         });

         const rules = {};

         // store the rules in a data param to be used later
         $datatable.$view.complexValidations = complexValidations;

         // use the lookup to build the validation rules
         Object.keys(complexValidations).forEach((key) => {
            rules[key] = (value, data) => {
               // default valid is true
               let isValid = true;

               $datatable.$view.complexValidations[key].forEach((filter) => {
                  const rowValue = {};
                  // use helper funtion to check if valid
                  // map the column names to the index numbers of data
                  // reformat data to display

                  (matchFields || []).forEach((f) => {
                     const record = data[f.columnIndex];

                     if (
                        f.field.key === "date" &&
                        record.includes("Invalid date")
                     )
                        isValid = false;

                     rowValue[f.field.id] = record;
                  });

                  const ruleValid = filter.filters(rowValue);

                  // if invalid we need to tell the field
                  if (!ruleValid) {
                     isValid = false;
                     // this.AB.Webix.message({
                     //    type: "error",
                     //    text: invalidMessage
                     // });
                  }
               });

               return isValid;
            };
         });
         // define validation rules
         $datatable.define("rules", rules);
         // store the array of view ids on the webix object so we can get it later
         $datatable.config.rulePops = rulePops;
         $datatable.refresh();
      } else {
         // check if the previous datatable had rule popups and remove them
         if ($datatable.config.rulePops) {
            $datatable.config.rulePops.forEach((popup) => {
               const $popup = $$(popup);

               if (!$popup) return;

               $popup.destructor();
            });
         }

         // remove any validation rules from the previous table
         $datatable.define("rules", {});
         $datatable.refresh();
      }

      /** Prepare Data */
      const parsedData = [];

      (this._dataRows || []).forEach((row, index) => {
         const rowValue = {
            id: index + 1,
         };

         // reformat data to display
         (matchFields || []).forEach((f) => {
            const data = row[f.columnIndex - 1];

            if (f.field.key === "date") {
               // let dateFormat = moment(data, f.format).format(
               //    "YYYY-MM-DD"
               // );
               // debugger;
               let dateFormat = ab.rules.toDate(data, {
                  format: f.format,
               });
               dateFormat = ab.rules.toDateFormat(dateFormat, {
                  format: "YYYY-MM-DD",
               });

               if (dateFormat === "Invalid date")
                  dateFormat = dateFormat + " - " + data;

               rowValue[f.columnIndex] = dateFormat;
            } else rowValue[f.columnIndex] = data; // array to object
         });

         // insert "true" value of checkbox
         rowValue["_included"] = true;

         parsedData.push(rowValue);
      });

      // skip the first line
      const isSkipFirstLine = $$(ids.headerOnFirstLine).getValue();

      if (isSkipFirstLine && parsedData.length > 1) parsedData.shift();

      const $importButton = $$(ids.importButton);

      $importButton.setValue(this.labelImport(parsedData));
      $datatable.refreshColumns(columns);
      $datatable.parse(parsedData);

      if (this.overLimitAlert(parsedData)) $importButton.disable();
      else $importButton.enable();

      // hide loading cursor
      $datatable.hideProgress?.();
   }

   refreshRemainingTimeText(startUpdateTime, total, index) {
      const ids = this.ids;

      // Calculate remaining time
      const spentTime = new Date() - startUpdateTime; // milliseconds that has passed since last completed record since start

      const averageRenderTime = spentTime / index; // average milliseconds per single render at this point

      const remainTime = averageRenderTime * (total - index);

      let result = "";

      // Convert milliseconds to a readable string
      const days = (remainTime / 86400000).toFixed(0);
      const hours = (remainTime / 3600000).toFixed(0);
      const minutes = (remainTime / 60000).toFixed(0);
      const seconds = (remainTime / 1000).toFixed(0);

      if (seconds < 1) result = "";
      else if (seconds < 60)
         result = this.label("Approximately {0} second(s) remaining", [
            seconds,
         ]);
      // result = `Approximately ${seconds} second${
      //    seconds > 1 ? "s" : ""
      // }`;
      else if (minutes == 1)
         result = this.label("Approximately 1 minute {0} seconds remaining", [
            seconds - 60,
         ]);
      // result = `Approximately 1 minute ${seconds - 60} seconds`;
      else if (minutes < 60)
         result = this.label("Approximately {0} minutes remaining", [minutes]);
      else if (hours < 24)
         result = this.label("Approximately {0} hour(s) remaining", [hours]);
      else result = this.label("Approximately {0} day(s) remaining", [days]);

      if (result) {
         $$(ids.importButton)?.setValue(result);
      } else {
         const selected = $$(ids.datatable)?.find({ _included: true });
         $$(ids.importButton)?.setValue(this.labelImport(selected));
      }
   }

   /**
    * @method getMatchFields
    *
    * @return {Object} - [
    *                      {
    *                         columnIndex: {number},
    *                         field: {ABField},
    *                         searchField: {ABField} [optional]
    *                      },
    *                      ...
    *                    ]
    */
   getMatchFields() {
      const result = [];
      const ids = this.ids;

      // get richselect components
      const $selectorViews = $$(ids.columnList)
         .queryView({ abName: "columnIndex" }, "all")
         .filter((selector) => selector.getValue() != "none");

      ($selectorViews || []).forEach(($selector) => {
         const currentObject = this.CurrentObject;

         if (!currentObject) return;

         // webix .options list disallow value 0
         const field = currentObject.fieldByID($selector.config.fieldId);

         if (!field) return;

         const colIndex = $selector.getValue();
         const fieldData = {
            columnIndex: colIndex,
            field: field,
         };

         if (field.key === "date") {
            const $optionPanel = $selector.getParentView();
            const $dateFormatSelectors = $optionPanel.queryView(
               { abName: "columnDateFormat" },
               "all"
            );

            // define the column to compare data to search .id
            if ($dateFormatSelectors) {
               $dateFormatSelectors.forEach((selector) => {
                  fieldData[selector.config.name] = selector.getValue();
               });

               // convert all dates into mysql date format YYYY-DD-MM
               let format;

               switch (fieldData.order) {
                  case "1":
                     format =
                        fieldData.day +
                        fieldData.separator +
                        fieldData.month +
                        fieldData.separator +
                        fieldData.year;
                     break;
                  case "2":
                     format =
                        fieldData.month +
                        fieldData.separator +
                        fieldData.day +
                        fieldData.separator +
                        fieldData.year;
                     break;
                  case "3":
                     format =
                        fieldData.year +
                        fieldData.separator +
                        fieldData.month +
                        fieldData.separator +
                        fieldData.day;
                     break;
                  case "4":
                     format =
                        fieldData.year +
                        fieldData.separator +
                        fieldData.day +
                        fieldData.separator +
                        fieldData.month;
               }

               fieldData.format = format;
            }
         }

         if (field.isConnection) {
            const $optionPanel = $selector.getParentView();
            const $linkDataSelector = $optionPanel.queryView(
               { abName: "columnLinkData" },
               "all"
            )[0];

            // define the column to compare data to search .id
            if ($linkDataSelector) {
               const searchField = field.datasourceLink.fieldByID(
                  $linkDataSelector.getValue()
               );

               fieldData.searchField = searchField;
            }
         }

         result.push(fieldData);
      });

      return result;
   }

   labelImport(selected) {
      let length = selected;

      if (Array.isArray(selected)) length = selected.length;

      return this.label("Import {0} Records", [length]);
   }

   /**
    * @method import
    *
    * @return {Promise}
    */
   async import() {
      // if (dv == null) return Promise.resolve();

      // // get ABObject
      // let obj = dv.datasource;

      // Make sure we are connected to an Object
      const currentObject = this.CurrentObject;

      if (!currentObject) return;

      // get ABModel
      // let model = dv.model;
      // if (model == null) return Promise.resolve();

      const ids = this.ids;
      const $importButton = $$(ids.importButton);

      $importButton.disable();

      // Show loading cursor
      const $form = $$(ids.form);
      const $progressBar = $$(ids.progressBar);

      $form.showProgress({ type: "icon" });
      $progressBar.showProgress({
         type: "top",
         position: 0.0001,
      });

      // get richselect components
      const matchFields = this.getMatchFields();

      // Get object's model
      const objModel = currentObject.model();
      const $datatable = $$(ids.datatable);
      const selectedRows = $datatable.find({ _included: true });

      let _currProgress = 0;

      const increaseProgressing = () => {
         _currProgress += 1;
         $progressBar.showProgress({
            type: "bottom",
            position: _currProgress / selectedRows.length,
         });
      };
      const itemFailed = (itemId, errMessage) => {
         if ($datatable) {
            // set "fail" status
            $datatable.addRowCss(itemId, "row-fail");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "fail",
               _errorMsg: errMessage,
            });
            $datatable.unblockEvent();
         }

         increaseProgressing();

         console.error(errMessage);
      };
      const abWebix = this.AB.Webix;
      const itemInvalid = (itemId, errors = []) => {
         if ($datatable) {
            // combine all error messages to display in tooltip
            const errorMsg = [];
            // mark which column are invalid
            errors.forEach((err) => {
               if (!err?.name) return;

               const fieldInfo = matchFields.filter(
                  (f) => f.field && f.field.columnName == err.name
               )[0];

               errorMsg.push(err.name + ": " + err.message);
               // we also need to define an error message
               // abWebix.message({
               //    type: "error",
               //    text: err.name + ": " + err.message
               // });
            });

            // set "fail" status
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "invalid",
               _errorMsg: errorMsg.join("</br>"),
            });
            $datatable.unblockEvent();
            $datatable.addRowCss(itemId, "webix_invalid");
         }
         // increaseProgressing();
      };
      const itemPass = (itemId) => {
         if ($datatable) {
            // set "done" status
            $datatable.removeRowCss(itemId, "row-fail");
            $datatable.addRowCss(itemId, "row-pass");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "done",
               _errorMsg: "",
            });
            $datatable.unblockEvent();
         }

         increaseProgressing();
      };
      const itemValid = (itemId) => {
         if ($datatable) {
            // mark all columns valid (just in case they were invalid before)
            // matchFields.forEach((f) => {
            //    $datatable.removeCellCss(
            //       itemId,
            //       f.columnIndex,
            //       "webix_invalid_cell"
            //    );
            // });
            // highlight the row
            $datatable.removeRowCss(itemId, "webix_invalid");
            $datatable.blockEvent();
            $datatable.updateItem(itemId, {
               _status: "",
               _errorMsg: "",
            });
            $datatable.unblockEvent();
            // $datatable.addRowCss(itemId, "row-pass");
         }
      };
      const $statusMessage = $$(ids.statusMessage);
      const uiCleanUp = () => {
         // To Do anyUI updates
         // console.log("ui clean up now");
         $importButton.enable();

         // Hide loading cursor
         $form.hideProgress();
         $progressBar.hideProgress();

         $statusMessage.setValue("");
         $statusMessage.hide();

         const selected = $datatable.find({ _included: true });

         $importButton.setValue(this.labelImport(selected));
         this.emit("done");
      };

      const validRows = [];

      let allValid = true;

      // Pre Check Validations of whole CSV import
      // update row to green if valid
      // update row to red if !valid
      (selectedRows || []).forEach((data, index) => {
         const newRowData = this.getParentValues();

         matchFields.forEach((f) => {
            if (!f.field?.key) return;

            switch (f.field.key) {
               // case "connectObject":
               //    // skip
               //    break;
               case "number":
                  if (typeof data[f.columnIndex] !== "number") {
                     newRowData[f.field.columnName] = (
                        data[f.columnIndex] || ""
                     ).replace(/[^-0-9.]/gi, "");

                     break;
                  }

                  newRowData[f.field.columnName] = data[f.columnIndex];

                  break;

               default:
                  newRowData[f.field.columnName] = data[f.columnIndex];

                  break;
            }
         });

         let isValid = false;
         let errorMsg = "";

         // first check legacy and server side validation
         const validator = currentObject.isValidData(newRowData);

         isValid = validator.pass();
         errorMsg = validator.errors;

         if (isValid)
            // now check complex field validation rules
            isValid = $datatable.validate(data.id);
         else {
            allValid = false;

            itemInvalid(data.id, errorMsg);
         }

         if (isValid) {
            itemValid(data.id);
            validRows.push({ id: data.id, data: newRowData });
         } else allValid = false;

         // $datatable.unblockEvent();
      });

      if (!allValid) {
         // To Do anyUI updates
         // $importButton.enable();
         //
         // // Hide loading cursor
         // $form.hideProgress();
         // $progressBar.hideProgress();
         // $statusMessage.setValue("");
         // $statusMessage.hide();
         //
         // // _logic.hide();
         //
         // if (_logic.callbacks && _logic.callbacks.onDone)
         //    _logic.callbacks.onDone();
         uiCleanUp();

         abWebix.alert({
            title: this.label("Invalid Data"),
            ok: this.label("Ok"),
            text: this.label(
               "The highlighted row has invalid data. Please edit in the window or update the CSV and try again."
            ),
         });

         return;
      }

      // if pass, then continue to process each row
      // ?? : can we process in Parallel?
      // ?? : implement hash Lookups for connected Fields
      const hashLookups = {};
      // {obj}  /*  { connectField.id : { 'searchWord' : "uuid"}}
      // use this hash to reduce the # of lookups needed to fill in our
      // connected entries

      const connectedFields = matchFields.filter(
         (f) => f && f.field?.isConnection && f.searchField
      );

      const throttledSize = 10;
      let startUpdateTime;
      let numDone = 0;

      try {
         // forEach connectedFields in csv
         const allLookups = [];

         (connectedFields || []).forEach((f) => {
            const connectField = f.field;
            // const searchWord = newRowData[f.columnIndex];
            const connectObject = connectField.datasourceLink;

            if (!connectObject) return;

            const connectModel = connectObject.model();

            if (!connectModel) return;

            const linkIdKey = connectField.indexField
               ? connectField.indexField.columnName
               : connectField.object.PK();

            // prepare default hash entry:
            hashLookups[connectField.id] = {};

            // load all values of connectedField entries
            const gethashLookup = async () => {
               try {
                  const list = await connectModel.findAll({
                     where: {}, // !!!
                     populate: false,
                  });
                  const data = list.data || list;

                  (data || []).forEach((row) => {
                     // store in hash[field.id] = { 'searchKey' : "uuid" }

                     hashLookups[connectField.id][
                        row[f.searchField.columnName]
                     ] = row[linkIdKey];
                  });
               } catch (err) {
                  console.error(err);
               }
            };

            allLookups.push(gethashLookup());
         });

         await Promise.all(allLookups);

         // forEach validRow
         validRows.forEach((data) => {
            const newRowData = data.data;

            // update the datagrid row to in-progress
            $datatable.blockEvent();
            $datatable.updateItem(data.id, {
               _status: "in-progress",
               _errorMsg: "",
            });
            $datatable.unblockEvent();

            // forEach ConnectedField
            (connectedFields || []).forEach((f) => {
               // find newRowData[field.columnName] = { field.PK : hash[field.id][searchWord] }
               const connectField = f.field;
               const linkIdKey = connectField.indexField
                  ? connectField.indexField.columnName
                  : connectField.object.PK();
               const uuid =
                  hashLookups[connectField.id][
                     newRowData[connectField.columnName]
                  ];

               if (!uuid) {
                  itemInvalid(data.id, [{ name: connectField.columnName }]);
                  allValid = false;
               }

               newRowData[connectField.columnName] = {};
               newRowData[connectField.columnName][linkIdKey] = uuid;
            });
         });

         if (!allValid) {
            abWebix.alert({
               title: this.label("Invalid Data"),
               ok: this.label("Ok"),
               text: this.label(
                  "The highlighted row has invalid data. Please edit in the window or update the CSV and try again."
               ),
            });
            uiCleanUp();

            return;
         }

         // NOTE: Parallel exectuion of all these:
         const allSaves = [];
         const createRecord = (objModel, newRowsData, element, total) =>
            new Promise((resolve, reject) => {
               element.doRecordRulesPre(newRowsData);

               const processResult = async () => {
                  try {
                     const result = await objModel.batchCreate({
                        batch: newRowsData,
                     });
                     const resultErrors = result.errors;

                     // Show errors of each row
                     Object.keys(resultErrors).forEach((rowIndex) => {
                        const error = resultErrors[rowIndex];

                        if (error) {
                           itemFailed(
                              rowIndex,
                              error.message || error.sqlMessage || error
                           );
                        }
                     });

                     const resultData = result.data;
                     const penddingRecordRules = [];

                     Object.keys(resultData).forEach((rowIndex) => {
                        penddingRecordRules.push(
                           new Promise((resolve, reject) => {
                              // Process Record Rule
                              const processRowData = async () => {
                                 try {
                                    await element.doRecordRules(
                                       resultData[rowIndex]
                                    );

                                    itemPass(rowIndex);
                                    resolve();
                                 } catch (err) {
                                    itemFailed(rowIndex, err);
                                    reject("that didn't work");
                                 }
                              };

                              processRowData();
                           })
                        );
                     });

                     const waitPenddingRecordRules = async () => {
                        try {
                           await Promise.all(penddingRecordRules);

                           newRowsData.forEach((row) => {
                              // itemPass(row.id);
                              numDone++;
                              if (numDone % throttledSize == 0) {
                                 this.refreshRemainingTimeText(
                                    startUpdateTime,
                                    validRows.length,
                                    numDone
                                 );
                              }
                           });

                           if (numDone === total) {
                              uiCleanUp();
                              $importButton.disable();
                           }

                           resolve();
                        } catch (err) {
                           // newRowsData.forEach((row) => {
                           //    itemFailed(row.id, err);
                           // });
                           // throw err;
                           reject(err);
                        }
                     };

                     await waitPenddingRecordRules();
                  } catch (err) {
                     console.error(err);
                     reject(err);
                  }
               };

               processResult();
            });

         validRows.forEach((data) => {
            allSaves.push({ id: data.id, data: data.data });
         });

         // we are going to store these promises in an array of
         // arrays with 50 in each sub array
         const throttledSaves = [];
         const total = allSaves.length;

         let index = 0;

         while (allSaves.length) {
            throttledSaves[index] = allSaves.splice(0, throttledSize);

            index++;
         }

         // execute the array of array of 100 promises one at at time
         const performThrottledSaves = (
            currentRecords,
            remainingRecords,
            importer,
            total
         ) =>
            new Promise((resolve, reject) => {
               // execute the next 100
               // const requests = currentRecords.map((data) => {
               //    return createRecord(
               //       objModel,
               //       data.record,
               //       data.data,
               //       importer
               //    );
               // });

               const processRequest = async () => {
                  try {
                     await createRecord(
                        objModel,
                        currentRecords,
                        importer,
                        total
                     );

                     // when done get the next 10
                     const nextRecords = remainingRecords.shift();

                     // if there are any remaining in the group call performThrottledSaves
                     if (nextRecords?.length) {
                        await performThrottledSaves(
                           nextRecords,
                           remainingRecords,
                           importer,
                           total
                        );
                     } else {
                        // uiCleanUp();
                        resolve();
                     }
                  } catch (err) {
                     // Handle errors here
                     reject(err);
                  }
               };

               processRequest();
            });

         // now we are going to processes these new containers one at a time
         // $datatable.blockEvent();
         // this is when the real work starts so lets begin our countdown timer now
         startUpdateTime = new Date();
         // get the first group of Promises out of the collection
         const next = throttledSaves.shift();

         // execute our Promise iterator
         await performThrottledSaves(next, throttledSaves, this.view, total);
      } catch (err) {
         // resolve Error UI
         abWebix.alert({
            title: this.label("Error Creating Records"),
            ok: this.label("Ok"),
            text: this.label("One or more records failed upon creation."),
         });
         // $datatable.unblockEvent();
         uiCleanUp();
         console.error(err);
      }
   }

   // Display linked data
   uiLinkedData() {
      const dcLink = this.datacollection?.datacollectionLink;
      const linkedData = dcLink?.getCursor();
      if (!linkedData) return;

      return {
         view: "window",
         modal: true,
         resize: false,
         head: {
            view: "toolbar",
            cols: [
               {},
               {
                  view: "button",
                  width: 35,
                  css: "webix_transparent",
                  type: "icon",
                  icon: "nomargin fa fa-times",
                  click: () => {
                     this.hideLinkedData();
                  },
               },
            ],
         },
         body: {
            view: "property",
            id: "sets",
            editable: false,
            width: 400,
            height: 200,
            elements: [
               { label: this.label("Linked Data"), type: "label" },
               {
                  label: "ID",
                  type: "text",
                  value: linkedData.uuid ?? linkedData.id,
               },
               {
                  label: "Label",
                  type: "text",
                  value: dcLink.datasource.displayData(linkedData),
               },
            ],
         },
      };
   }

   showLinkedData() {
      const ui = this.uiLinkedData();
      this._info_popup = this.AB.Webix.ui(ui);
      this._info_popup.show($$(this.ids.linkedDataButton).$view, {
         pos: "top",
      });
   }

   hideLinkedData() {
      this._info_popup?.hide();
   }

   getParentValues() {
      const result = {};

      // get ABDatacollection
      const dc = this.datacollection;
      const currentObject = this.CurrentObject;

      // Set parent's data collection cursor
      const dcLink = dc?.datacollectionLink;
      const linkConnectFields = [];

      let objectLink;
      let linkValues;

      if (dcLink?.getCursor()) {
         objectLink = dcLink.datasource;

         linkConnectFields.push(
            ...currentObject.fields(
               (f) => f.isConnection && f.settings.linkObject === objectLink.id
            )
         );

         linkValues = dcLink.getCursor();
      }

      // Set parent's data collection cursor
      if (objectLink && linkConnectFields.length && linkValues) {
         linkConnectFields.forEach((f) => {
            const linkColName = f.indexField
               ? f.indexField.columnName
               : objectLink.PK();

            result[f.columnName] = result[f.columnName] ?? {};
            result[f.columnName][linkColName] =
               linkValues[linkColName] ?? linkValues.id;
         });
      }

      return result;
   }
};


/***/ }),

/***/ 67511:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewCarouselComponent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewCarouselComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 44363);


class ABViewCarouselComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewCarousel_${baseView.id}`,
         Object.assign(
            {
               carousel: "",
            },
            ids
         )
      );

      this._handler_doOnShow = () => {
         this.onShow();
      };

      this._handler_doReload = () => {
         // this.datacollection?.reloadData();
      };

      this._handler_doFilter = (fnFilter, filterRules) => {
         // NOTE: fnFilter is depreciated and will be removed.

         // this.onShow(filterRules);
         const dv = this.datacollection;

         if (!dv) return;

         dv.filterCondition(filterRules);
         dv.reloadData();
      };

      this._handler_busy = () => {
         this.busy();
      };

      this._handler_ready = () => {
         this.ready();
      };
   }

   ui() {
      const ids = this.ids;

      const baseView = this.view;

      this.filterUI = baseView.filterHelper; // component(/* App, idBase */);
      this.linkPage = baseView.linkPageHelper.component(/* App, idBase */);

      const spacer = {};
      const settings = this.settings;

      if (settings.width === 0)
         Object.assign(spacer, {
            width: 1,
         });

      const _ui = super.ui([
         {
            borderless: true,
            cols: [
               spacer, // spacer
               {
                  borderless: true,
                  rows: [
                     this.filterUI.ui(), // filter UI
                     {
                        id: ids.carousel,
                        view: "carousel",
                        cols: [],
                        width: settings.width,
                        height: settings.height,
                        navigation: {
                           items: !settings.hideItem,
                           buttons: !settings.hideButton,
                           type: settings.navigationType,
                        },
                        on: {
                           onShow: () => {
                              const activeIndex = $$(
                                 ids.carousel
                              ).getActiveIndex();

                              this.switchImage(activeIndex);
                           },
                        },
                     },
                  ],
               },
               spacer, // spacer
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   // make sure each of our child views get .init() called
   async init(AB) {
      await super.init(AB);

      const dv = this.datacollection;

      if (!dv) {
         AB.notify.builder(`Datacollection is ${dv}`, {
            message: "This is an invalid datacollection",
         });

         return;
      }

      const object = dv.datasource;

      if (!object) {
         AB.notify.developer(`Object is ${dv}`, {
            message: "This is an invalid object",
         });

         return;
      }

      dv.removeListener("loadData", this._handler_doOnShow);
      dv.on("loadData", this._handler_doOnShow);

      dv.removeListener("update", this._handler_doReload);
      dv.on("update", this._handler_doReload);

      dv.removeListener("delete", this._handler_doReload);
      dv.on("delete", this._handler_doReload);

      dv.removeListener("create", this._handler_doReload);
      dv.on("create", this._handler_doReload);

      dv.removeListener("initializingData", this._handler_busy);
      dv.on("initializingData", this._handler_busy);

      dv.removeListener("initializedData", this._handler_ready);
      dv.on("initializedData", this._handler_ready);

      if (this.settings.filterByCursor) {
         ["changeCursor", "cursorStale"].forEach((key) => {
            dv.removeListener(key, this._handler_doOnShow);
            dv.on(key, this._handler_doOnShow);
         });
      }

      const baseView = this.view;

      // filter helper
      baseView.filterHelper.objectLoad(object);
      baseView.filterHelper.viewLoad(this);

      this.filterUI.init(this.AB);
      this.filterUI.removeListener("filter.data", this._handler_doFilter);
      this.filterUI.on("filter.data", this._handler_doFilter);

      // link page helper
      this.linkPage.init({
         view: baseView,
         datacollection: dv,
      });

      // set data-cy
      const $carouselView = $$(this.ids.carousel)?.$view;

      if ($carouselView) {
         $carouselView.setAttribute(
            "data-cy",
            `${baseView.key} ${baseView.id}`
         );
         $carouselView
            .querySelector(".webix_nav_button_prev")
            ?.firstElementChild?.setAttribute(
               "data-cy",
               `${baseView.key} button previous ${baseView.id}`
            );
         $carouselView
            .querySelector(".webix_nav_button_next")
            ?.firstElementChild?.setAttribute(
               "data-cy",
               `${baseView.key} button next ${baseView.id}`
            );
      }
   }

   /**
    * @method detatch()
    * Will make sure all our handlers are removed from any object
    * we have attached them to.
    *
    * You'll want to call this in situations when we are dynamically
    * creating and recreating instances of the same Widget (like in
    * the ABDesigner).
    */
   detatch() {
      const dv = this.datacollection;

      if (!dv) return;

      dv.removeListener("loadData", this._handler_doOnShow);

      if (this._handler_doReload) {
         dv.removeListener("update", this._handler_doReload);
         dv.removeListener("delete", this._handler_doReload);
         dv.removeListener("create", this._handler_doReload);
      }

      dv.removeListener("initializingData", this._handler_busy);

      dv.removeListener("initializedData", this._handler_ready);

      if (this.settings.filterByCursor)
         ["changeCursor", "cursorStale"].forEach((key) => {
            dv.removeListener(key, this._handler_doOnShow);
         });

      this.filterUI.removeListener("filter.data", this._handler_doOnShow);
   }

   myTemplate(row) {
      if (row?.src) {
         const settings = this.settings;

         return `<div class="ab-carousel-image-container">
            <link rel="preload" href="${
               row.src
            }" as="image" fetchpriotity="low"/>
            <img id="${this.ids.component}-${row.id}" src="${
            row.src
         }" class="content" ondragstart="return false" loading="lazy" />
            ${
               settings.showLabel
                  ? `<div class="ab-carousel-image-title">${
                       row.label || ""
                    }</div>`
                  : ""
            }
            <div class="ab-carousel-image-icon">
            ${
               settings.detailsPage || settings.detailsTab
                  ? `<span ab-row-id="${row.id}" class="ab-carousel-detail webix_icon fa fa-eye"></span>`
                  : ""
            }
            ${
               settings.editPage || settings.editTab
                  ? `<span ab-row-id="${row.id}" class="ab-carousel-edit webix_icon fa fa-pencil"></span>`
                  : ""
            }
            <span class="webix_icon ab-carousel-zoom-in fa fa-search-plus"></span>
            <span class="webix_icon ab-carousel-zoom-out fa fa-search-minus"></span>
                  <span ab-row-id="${row.id}" ab-img-file="${
            row.imgFile
         }" class="webix_icon ab-carousel-rotate-left fa fa-rotate-left"></span>
               <span ab-row-id="${row.id}" ab-img-file="${
            row.imgFile
         }" class="webix_icon ab-carousel-rotate-right fa fa-rotate-right"></span>
               <span class="webix_icon ab-carousel-fullscreen fa fa-arrows-alt"></span>
               <span style="display: none;" class="webix_icon ab-carousel-exit-fullscreen fa fa-times"></span>
            </div>
         </div>`;
      }
      // empty image
      else return "";
   }

   busy() {
      const $carousel = $$(this.ids.carousel);

      $carousel?.disable();
      $carousel?.showProgress?.({ type: "icon" });
   }

   ready() {
      const $carousel = $$(this.ids.carousel);

      $carousel?.enable();
      $carousel?.hideProgress?.();
   }

   async switchImage(currentPosition) {
      const dv = this.datacollection;

      if (!dv) return;

      // Check want to load more images
      if (
         currentPosition >= this._imageCount - 1 && // check last image
         dv.totalCount > this._rowCount
      ) {
         // loading cursor
         this.busy();

         try {
            await dv.loadData(this._rowCount || 0);
         } catch (err) {
            this.AB.notify.developer(err, {
               message:
                  "ABViewCarousel:switchImage():Error when load data from a Data collection",
            });
         }

         this.ready();
      }
   }

   onShow(fnFilter = this.filterUI.getFilter()) {
      const ids = this.ids;
      const dv = this.datacollection;

      if (!dv) return;

      const obj = dv.datasource;

      if (!obj) return;

      const field = this.view.imageField;

      if (!field) return;

      if (dv.dataStatus == dv.dataStatusFlag.notInitial) {
         // load data when a widget is showing
         dv.loadData();

         // it will call .onShow again after dc loads completely
         return;
      }

      const settings = this.settings;

      let rows = dv.getData(fnFilter);

      // Filter images by cursor
      if (settings.filterByCursor) {
         const cursor = dv.getCursor();

         if (cursor)
            rows = rows.filter(
               (r) =>
                  (r[obj.PK()] || r.id || r) ===
                  (cursor[obj.PK()] || cursor.id || cursor)
            );
      }

      const images = [];

      rows.forEach((r) => {
         const imgFile = r[field.columnName];

         if (imgFile) {
            const imgData = {
               id: r.id,
               src: `/file/${imgFile}`,
               imgFile,
            };

            // label of row data
            if (settings.showLabel) imgData.label = obj.displayData(r);

            images.push({
               css: "image",
               borderless: true,
               template: (...params) => {
                  return this.myTemplate(...params);
               },
               data: imgData,
            });
         }
      });

      const ab = this.AB;

      // insert the default image to first item
      if (field.settings.defaultImageUrl)
         images.unshift({
            css: "image",
            template: (...params) => this.myTemplate(...params),
            data: {
               id: ab.uuid(),
               src: `/file/${field.settings.defaultImageUrl}`,
               label: this.label("Default image"),
            },
         });

      // empty image
      if (images.length < 1)
         images.push({
            rows: [
               {
                  view: "label",
                  align: "center",
                  height: settings.height,
                  label: "<div style='display: block; font-size: 180px; background-color: #666; color: transparent; text-shadow: 0px 1px 1px rgba(255,255,255,0.5); -webkit-background-clip: text; -moz-background-clip: text; background-clip: text;' class='fa fa-picture-o'></div>",
               },
               {
                  view: "label",
                  align: "center",
                  label: this.label("No image"),
               },
            ],
         });

      // store total of rows
      this._rowCount = rows.length;

      // store total of images
      this._imageCount = images.length;

      const $carousel = $$(ids.carousel);
      const abWebix = ab.Webix;

      if ($carousel) {
         // re-render
         abWebix.ui(images, $carousel);

         // add loading cursor
         abWebix.extend($carousel, abWebix.ProgressBar);

         // link pages events
         const editPage = settings.editPage;
         const detailsPage = settings.detailsPage;

         // if (detailsPage || editPage) {
         $carousel.$view.onclick = async (e) => {
            if (e.target.className) {
               if (e.target.className.indexOf("ab-carousel-edit") > -1) {
                  abWebix.html.removeCss($carousel.getNode(), "fullscreen");
                  abWebix.fullscreen.exit();
                  let rowId = e.target.getAttribute("ab-row-id");
                  this.linkPage.changePage(editPage, rowId);
               } else if (
                  e.target.className.indexOf("ab-carousel-detail") > -1
               ) {
                  abWebix.html.removeCss($carousel.getNode(), "fullscreen");
                  abWebix.fullscreen.exit();
                  let rowId = e.target.getAttribute("ab-row-id");
                  this.linkPage.changePage(detailsPage, rowId);
               } else if (
                  e.target.className.indexOf("ab-carousel-fullscreen") > -1
               ) {
                  $carousel.define("css", "fullscreen");
                  abWebix.fullscreen.set(ids.carousel, {
                     head: {
                        view: "toolbar",
                        css: "webix_dark",
                        elements: [
                           {},
                           {
                              view: "icon",
                              icon: "fa fa-times",
                              click: function () {
                                 abWebix.html.removeCss(
                                    $carousel.getNode(),
                                    "fullscreen"
                                 );
                                 abWebix.fullscreen.exit();
                              },
                           },
                        ],
                     },
                  });
               } else if (
                  e.target.className.indexOf("ab-carousel-rotate-left") > -1
               ) {
                  const rowId = e.target.getAttribute("ab-row-id");
                  const imgFile = e.target.getAttribute("ab-img-file");
                  this.rotateImage(rowId, imgFile, field, "left");
               } else if (
                  e.target.className.indexOf("ab-carousel-rotate-right") > -1
               ) {
                  const rowId = e.target.getAttribute("ab-row-id");
                  const imgFile = e.target.getAttribute("ab-img-file");
                  this.rotateImage(rowId, imgFile, field, "right");
               } else if (
                  e.target.className.indexOf("ab-carousel-zoom-in") > -1
               ) {
                  this.zoom("in");
               } else if (
                  e.target.className.indexOf("ab-carousel-zoom-out") > -1
               ) {
                  this.zoom("out");
               }
            }
         };
      }
   }

   showFilterPopup($view) {
      this.filterUI.showPopup($view);
   }

   async rotateImage(rowId, imgFile, field, direction = "right") {
      this.busy();

      // call api to rotate
      if (direction == "left") await field.rotateLeft(imgFile);
      else await field.rotateRight(imgFile);

      // refresh image
      const imgElm = document.getElementById(`${this.ids.component}-${rowId}`);
      if (imgElm) {
         await fetch(imgElm.src, { cache: "reload", mode: "no-cors" });
         imgElm.src = `${imgElm.src}#${new Date().getTime()}`;
      }

      this.ready();
   }

   zoom(inOrOut = "in") {
      const imgContainer = document.getElementsByClassName(
         "ab-carousel-image-container"
      )[0];
      if (!imgContainer) return;

      const imgElem = imgContainer.getElementsByTagName("img")[0];
      if (!imgElem) return;

      const step = 15;
      const height = parseInt(
         (imgElem.style.height || 100).toString().replace("%", "")
      );
      const newHeight = inOrOut == "in" ? height + step : height - step;
      imgElem.style.height = `${newHeight}%`;

      imgContainer.style.overflow = newHeight > 100 ? "auto" : "";
   }
}


/***/ }),

/***/ 80651:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartAreaComponent.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainerComponent = __webpack_require__(/*! ./ABViewChartContainerComponent */ 71233);

module.exports = class ABViewChartAreaComponent extends (
   ABViewChartContainerComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewChartArea_${baseView.id}`, ids);
   }

   ui() {
      const settings = this.settings;

      return super.ui({
         view: "chart",
         type: settings.areaType,
         yAxis: {
            start: 0,
            step: settings.stepValue, //"#stepValue#",
            end: settings.maxValue, //"#maxValue#"
         },
         xAxis: {
            template: settings.isLegend
               ? `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`
               : "",
         },
         legend: settings.isLegend
            ? {
                 template: `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`,
                 values: [], // TODO : bug in webix 5.1.7
              }
            : null,
         series: [
            {
               alpha: 0.7,
               value: "#value#",
               color: "#ee4339",
            },
            {
               alpha: 0.4,
               value: "#value2#",
               color: "#a7ee70",
            },
         ],
         height: settings.chartHeight,
         // width: settings.chartWidth,
      });
   }

   async init(AB) {
      await super.init(AB);
   }

   onShow() {
      super.onShow();
   }
};


/***/ }),

/***/ 87139:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartBarComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainerComponent = __webpack_require__(/*! ./ABViewChartContainerComponent */ 71233);

module.exports = class ABViewChartBarComponent extends (
   ABViewChartContainerComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewChartBar_${baseView.id}`, ids);
   }

   ui() {
      const settings = this.settings;

      return super.ui({
         view: "chart",
         type: settings.barType,
         preset: settings.barPreset,
         value: "#value#",
         color: "#color#",
         yAxis: {
            start: 0,
            step: settings.stepValue, //"#stepValue#",
            end: settings.maxValue, //"#maxValue#"
         },
         xAxis: {
            template: settings.isLegend
               ? `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`
               : "",
         },
         legend:
            settings.barType === "bar" || !settings.barType
               ? settings.isLegend
                  ? `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`
                  : ""
               : settings.isLegend
               ? {
                    template: `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`,
                    values: [], // TODO : bug in webix 5.1.7
                 }
               : null,
         height: settings.height,
         // width: settings.chartWidth,
      });
   }

   async init(AB) {
      await super.init(AB);
   }

   onShow() {
      super.onShow();
   }
};


/***/ }),

/***/ 26869:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartComponent.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainerComponent = __webpack_require__(/*! ./ABViewContainerComponent */ 91219);

module.exports = class ABViewChartComponent extends ABViewContainerComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewChart_${baseView.id}`, ids);
   }

   async init(AB, accessLevel) {
      await super.init(AB, accessLevel);

      const $component = $$(this.ids.component);
      const abWebix = this.AB.Webix;

      if ($component) abWebix.extend($component, abWebix.ProgressBar);

      const baseView = this.view;
      const dc = this.datacollection;

      if (dc) {
         const eventNames = [
            "changeCursor",
            "cursorStale",
            "create",
            "update",
            "delete",
            "initializedData",
         ];

         ["changeCursor", "cursorStale"].forEach((key) => {
            // QUESTION: is this a problem if the check !(key in (...)) finds
            // an event that some OTHER widget has added and not this one?
            if (
               dc.datacollectionLink &&
               !(key in (dc.datacollectionLink._events ?? []))
            )
               baseView.eventAdd({
                  emitter: dc.datacollectionLink,
                  eventName: key,
                  listener: () => {
                     baseView.refreshData();
                  },
               });
         });

         eventNames.forEach((evtName) => {
            baseView.eventAdd({
               emitter: dc,
               eventName: evtName,
               listener: () => {
                  baseView.refreshData();
               },
            });
         });
      }

      baseView.refreshData();
   }

   onShow() {
      super.onShow();
   }
};


/***/ }),

/***/ 71233:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartContainerComponent.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewChartContainerComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewChartContainer_${baseView.id}`,
         Object.assign(
            {
               chartContainer: "",
            },
            ids
         )
      );
   }

   ui(uiChartComponent) {
      const _ui = super.ui([
         Object.assign({ id: this.ids.chartContainer }, uiChartComponent ?? {}),
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);
   }

   onShow() {
      super.onShow();
      // if (!this._isShow) {

      // Mark this widget is showing
      const baseView = this.view;

      baseView._isShow = true;

      this.refreshData(baseView.parent.getDCChart());
      // }
   }

   refreshData(dcChart) {
      const $chartContainer = $$(this.ids.chartContainer);
      const $chartComponent = $$(this.ids.component);

      if ($chartContainer?.data) $chartContainer.data.sync(dcChart);

      setTimeout(() => {
         $chartComponent?.adjust();
         $chartContainer?.adjust();
      }, 160);
   }
};


/***/ }),

/***/ 52564:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartLineComponent.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainerComponent = __webpack_require__(/*! ./ABViewChartContainerComponent */ 71233);

module.exports = class ABViewChartLineComponent extends (
   ABViewChartContainerComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewChartLine_${baseView.id}`, ids);
   }

   ui() {
      const settings = this.settings;

      return super.ui({
         view: "chart",
         type: settings.lineType,
         preset: settings.linePreset,
         value: "#value#",
         color: "#color#",
         yAxis: {
            start: 0,
            step: settings.stepValue,
            end: settings.maxValue, //"#maxValue#"
         },
         xAxis: {
            template: settings.isLegend
               ? `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`
               : "",
         },
         legend: settings.isLegend
            ? {
                 template: `<div style='font-size:${settings.labelFontSize}px;'>#label#</div>`,
                 values: [], // TODO : bug in webix 5.1.7
              }
            : null,
         height: settings.chartHeight,
         // width: settings.chartWidth,
      });
   }
};


/***/ }),

/***/ 48370:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewChartPieComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewChartContainerComponent = __webpack_require__(/*! ./ABViewChartContainerComponent */ 71233);

module.exports = class ABViewChartPieComponent extends (
   ABViewChartContainerComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewChartPie_${baseView.id}`, ids);
   }

   ui() {
      const settings = this.settings;

      return super.ui({
         view: "chart",
         type: settings.pieType,
         value: "#value#",
         color: "#color#",
         legend: settings.isLegend
            ? {
                 width: this.view.parent.settings.labelWidth,
                 template: `<div style='font-size: ${settings.labelFontSize}px;'>#label#</div>`,
              }
            : null,
         pieInnerText: `<div style='font-size: ${settings.innerFontSize}px;'>#value#</div>`,
         shadow: 1,
         height: settings.height,
         // width: settings.chartWidth,
      });
   }
};


/***/ }),

/***/ 29405:
/*!***************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewCommentComponent.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewCommentComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewComment_${baseView.id}`,
         Object.assign(
            {
               comment: "",
            },
            ids
         )
      );
   }

   ui() {
      const baseView = this.view;
      const _ui = super.ui([
         {
            id: this.ids.comment,
            view: "comments",
            users: baseView.getUserData(),
            currentUser: baseView.getCurrentUserId(),
            height: this.settings.height,
            data: this.getCommentData(),
            on: {
               onBeforeAdd: (id, obj, index) => {
                  this.addComment(obj.text, new Date());
               },
               // NOTE: no update event of comment widget !!
               // Updating event handles in .init function
               // https://docs.webix.com/api__ui.comments_onbeforeeditstart_event.html#comment-4509366150

               // onAfterEditStart: function (rowId) {
               //    let item = this.getItem(rowId);

               //    _logic.updateComment(rowId, item);
               // },
               onAfterDelete: (rowId) => {
                  this.deleteComment(rowId);
               },
            },
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const baseView = this.view;

      baseView.__dvEvents = baseView.__dvEvents || {};

      const ids = this.ids;
      const $comment = $$(ids.comment);

      if ($comment) {
         const $commentList = $comment.queryView({ view: "list" });

         if ($commentList) {
            // Updating comment event
            if (!baseView.__dvEvents.onStoreUpdated)
               baseView.__dvEvents.onStoreUpdated =
                  $commentList.data.attachEvent(
                     "onStoreUpdated",
                     (rowId, data, operate) => {
                        if (operate === "update") {
                           this.updateComment(rowId, (data || {}).text);
                        }
                     }
                  );

            // Implement progress bar
            webix.extend($commentList, webix.ProgressBar);
         }
      }

      const dv = this.datacollection;

      if (!dv) return;

      // bind dc to component
      // dv.bind($$(ids.comment));

      if (!baseView.__dvEvents.create)
         baseView.__dvEvents.create = dv.on("create", () =>
            this.refreshComment()
         );

      if (!baseView.__dvEvents.update)
         baseView.__dvEvents.update = dv.on("update", () =>
            this.refreshComment()
         );

      if (!baseView.__dvEvents.delete)
         baseView.__dvEvents.delete = dv.on("delete", () =>
            this.refreshComment()
         );

      if (!baseView.__dvEvents.loadData)
         baseView.__dvEvents.loadData = dv.on("loadData", () =>
            this.refreshComment()
         );

      $comment.refresh();
   }

   getCommentData() {
      const baseView = this.view;
      const dv = this.datacollection;

      if (!dv) return null;

      const userCol = baseView.getUserField();
      const commentCol = baseView.getCommentField();
      const dateCol = baseView.getDateField();

      if (!userCol || !commentCol) return null;

      const userColName = userCol.columnName;
      const commentColName = commentCol.columnName;
      const dateColName = dateCol ? dateCol.columnName : null;
      const dataObject = dv.getData();
      const dataList = [];

      dataObject.forEach((item, index) => {
         if (item[commentColName]) {
            const user = baseView.getUserData().find((user) => {
               return user.value === item[userColName];
            });
            const data = {
               id: item.id,
               user_id: user ? user.id : 0,
               date: item[dateColName] ? new Date(item[dateColName]) : null,
               default_date: new Date(item["created_at"]),
               text: item[commentColName],
            };

            dataList.push(data);
         }
      });

      dataList.sort(function (a, b) {
         if (dateColName)
            return new Date(a.date).getTime() - new Date(b.date).getTime();
         else
            return (
               new Date(a.default_date).getTime() -
               new Date(b.default_date).getTime()
            );
      });

      return dataList;
   }

   refreshComment() {
      const baseView = this.view;

      if (baseView.__refreshTimeout) clearTimeout(baseView.__refreshTimeout);

      this.busy();

      const ids = this.ids;

      baseView.__refreshTimeout = setTimeout(() => {
         const $comment = $$(ids.comment);

         if (!$comment) return;

         // clear comments
         const $commentList = $comment.queryView({ view: "list" });

         if ($commentList) $commentList.clearAll();

         // populate comments
         const commentData = this.getCommentData();

         if (commentData) {
            $comment.parse(commentData);
         }

         // scroll to the last item
         if ($commentList) $commentList.scrollTo(0, Number.MAX_SAFE_INTEGER);

         delete baseView.__refreshTimeout;

         this.ready();
      }, 90);
   }

   addComment(commentText, dateTime) {
      this.saveData(commentText, dateTime);
   }

   async updateComment(rowId, commentText) {
      const baseView = this.view;
      const model = baseView.model();

      if (!model) return; // already notified

      const commentField = baseView.getCommentField();

      if (!commentField) return; // already notified

      const values = {};

      values[commentField.columnName] = commentText ?? "";

      return await model.update(rowId, values);
   }

   async deleteComment(rowId) {
      const baseView = this.view;
      const model = baseView.model();

      if (!model) return;

      return await model.delete(rowId);
   }

   busy() {
      const ids = this.ids;
      const $comment = $$(ids.comment);

      if (!$comment) return;

      const $commentList = $comment.queryView({ view: "list" });

      if (!$commentList) return;

      $commentList.disable();

      if ($commentList.showProgress)
         $commentList.showProgress({ type: "icon" });
   }

   ready() {
      const ids = this.ids;
      const $comment = $$(ids.comment);

      if (!$comment) return;

      const $commentList = $comment.queryView({ view: "list" });

      if (!$commentList) return;

      $commentList.enable();

      if ($commentList.hideProgress) $commentList.hideProgress();
   }

   async saveData(commentText, dateTime) {
      if (!commentText) return;

      const dv = this.datacollection;

      if (!dv) return;

      const baseView = this.view;
      const model = baseView.model();
      const ab = this.AB;

      if (!model) {
         ab.notify.builder(
            {},
            {
               message:
                  "ABViewComment.saveData(): could not pull a model to work with.",
               viewName: baseView.label,
            }
         );

         return;
      }

      const comment = {};
      const userField = baseView.getUserField();

      if (userField) comment[userField.columnName] = ab.Account.username();

      const commentField = baseView.getCommentField();

      if (commentField) comment[commentField.columnName] = commentText;

      const dateField = baseView.getDateField();

      if (dateField) comment[dateField.columnName] = dateTime;

      // add parent cursor to default
      const dvLink = dv.datacollectionLink;

      if (dvLink?.getCursor()) {
         const objectLink = dvLink.datasource;
         const fieldLink = dv.fieldLink;

         if (objectLink && fieldLink) {
            comment[fieldLink.columnName] = {};
            comment[fieldLink.columnName][objectLink.PK()] =
               dvLink.getCursor().id;
         }
      }

      return await model.create(comment);
   }
};


/***/ }),

/***/ 44363:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewComponent.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewComponent)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../ui/ClassUI */ 32019);
/**
 * ABViewComponent
 * A common UI component class for our UI widgets.
 */


class ABViewComponent extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(idBase || `ABView_${baseView.id}`, ids);

      this.view = baseView;
      this.settings = baseView.settings;
      this.AB = baseView.AB;
      this.datacollection = baseView.datacollections || baseView.datacollection;

      this.__events = [];
      // {array}
      // A collection of any listeners we are managing.
      // {
      //   emitter:   {EventEmitter} the object we are listening on
      //   eventName: {string} the event key we are listening for
      //   listener:  {fn} the function to call on
      // }

      this.CurrentObjectID = null;
      // {string}
      // the ABObject.id of the object we are working with.

      this.CurrentDatacollectionID = null;
      // {string}
      // the ABDataCollection.id of the DC we are working with
   }

   /**
    * @method CurrentObject()
    * A helper to return the current ABObject we are working with.
    * @return {ABObject}
    */
   get CurrentObject() {
      return this.AB.objectByID(this.CurrentObjectID);
   }
   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      return this.AB.datacollectionByID(this.CurrentDatacollectionID);
   }

   ui(uiComponents = []) {
      // an ABView is a collection of rows:
      const _ui = {
         id: this.ids.component,
         view: "layout",
         type: "space",
         rows: uiComponents,
      };

      // if this form is empty, then force a minimal row height
      // so the component isn't completely hidden on the screen.
      // (important in the editor so we don't loose the ability to edit the
      // component)
      if (!_ui.rows.length) _ui.height = 30;

      return _ui;
   }

   async init(AB) {
      this.AB = AB;
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      this.CurrentDatacollectionID = datacollection?.id;
   }

   objectLoad(object) {
      this.CurrentObjectID = object?.id;
   }

   /**
    * @method eventAdd()
    * Create a new listener on an object. Note, this will prevent multiple
    * listeners being applied to the same Object.
    * @param {object} evt
    *        The definition of the event we are adding:
    *        {
    *           emitter:   {EventEmitter} the object we are listening on
    *           eventName: {string} the event key we are listening for
    *           listener:   {fn} the function to call on
    *        }
    */
   eventAdd(evt) {
      if (!evt || !evt.emitter || !evt.listener) return;

      // make sure we haven't done this before:
      const __events = this.__events;
      const exists = __events.filter(
         (e) => e.emitter === evt.emitter && e.eventName === evt.eventName
         // && e.listener === evt.listener
      );

      if (!exists.length) {
         // add to array
         __events.push({
            emitter: evt.emitter,
            eventName: evt.eventName,
            listener: evt.listener,
         });

         // listening this event
         evt.emitter.on(evt.eventName, evt.listener);
      }
   }

   /**
    * @method eventsClear()
    * Remove all the attached event listeners and reset our tracking.
    */
   eventsClear() {
      this.__events.forEach((evt) => {
         evt.emitter.removeListener(evt.eventName, evt.listener);
      });

      this.__events = [];
   }

   /**
    * @method waitInitializingDCEvery()
    * Wait until the DC is initialized, checking every millisecond as specified by the parameter
    * @param {number} milliSeconds
    * The amount of milliseconds to recheck DC status.
    * @param {object} dc
    * the AB DC instance.
    */

   async waitInitializingDCEvery(milliSeconds, dc) {
      if (!this.__isShowing || dc == null) return;
      // if we manage a datacollection, then make sure it has started
      // loading it's data when we are showing our component.
      // load data when a widget is showing
      if (dc.dataStatus === dc.dataStatusFlag.notInitial) await dc.loadData();

      return await new Promise((resolve) => {
         if (dc.dataStatus === dc.dataStatusFlag.initialized) {
            resolve();

            return;
         }

         const interval = setInterval(() => {
            if (dc.dataStatus === dc.dataStatusFlag.initialized) {
               clearInterval(interval);

               resolve();
            }
         }, milliSeconds);
      });
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      // check if tab has a hint
      if (this?.view?.settings?.hintID) {
         // fetch the steps for the hint
         let hint = this.AB.hintID(this.view.settings.hintID);
         if (hint.settings.active) {
            hint.createHintUI();
         }
      }
      // if we manage a datacollection, then make sure it has started
      // loading it's data when we are showing our component.
      const dc = this.datacollection;

      if (!dc) return;

      if (Array.isArray(dc)) {
         dc.forEach((item) => {
            if (item.dataStatus === item.dataStatusFlag.notInitial)
               // load data when a widget is showing
               item.loadData();
         });
      } else {
         if (dc.dataStatus === dc.dataStatusFlag.notInitial)
            // load data when a widget is showing
            dc.loadData();
      }
   }
}


/***/ }),

/***/ 54112:
/*!****************************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewConditionalContainerComponent.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewContainerComponent = __webpack_require__(/*! ./ABViewContainerComponent */ 91219);

module.exports = class ABViewConditionalContainerComponent extends (
   ABViewContainerComponent
) {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewConditionalContainer_${baseView.id}`,
         Object.assign(
            {
               batch: "",
            },
            ids
         )
      );

      this._ifComponent = null;
      this._elseComponent = null;

      // Set filter value
      this.__filterComponent = baseView.AB.filterComplexNew(
         `${baseView.id}_filterComponent`
      );
      // this.__filterComponent.applicationLoad(application);
      this.populateFilterComponent();
   }

   ui() {
      const _uiConditionalContainer = {
         id: this.ids.batch,
         view: "multiview",
         cells: [
            {
               batch: "wait",
               view: "layout",
               rows: [
                  {
                     view: "label",
                     label: this.label("Please wait..."),
                  },
               ],
            },
         ],
      };
      const _ui = super.ui([_uiConditionalContainer]);

      _uiConditionalContainer.cells.push(
         Object.assign({ batch: "if" }, this.ifComponent.ui()),
         Object.assign({ batch: "else" }, this.elseComponent.ui())
      );

      delete _ui.type;

      return _ui;
   }

   async init(AB, accessLevel) {
      await super.init(AB, accessLevel);

      await Promise.all([
         this.ifComponent.init(AB, accessLevel),
         this.elseComponent.init(AB, accessLevel),
      ]);

      this.populateFilterComponent();

      const dc = this.datacollection;

      if (dc) {
         const baseView = this.view;

         // listen DC events
         baseView.eventAdd({
            emitter: dc,
            eventName: "loadData",
            listener: () => this.displayView(), // Q? does this need to remain empty param?
         });

         baseView.eventAdd({
            emitter: dc,
            eventName: "initializedData",
            listener: () => this.displayView(), // Q? does this need to remain empty param?
         });

         ["changeCursor", "cursorStale"].forEach((key) => {
            baseView.eventAdd({
               emitter: dc,
               eventName: key,
               listener: (...p) => this.displayView(...p),
            });
         });
      }

      this.displayView();
   }

   onShow() {
      super.onShow();

      this.populateFilterComponent();
      this.displayView();
   }

   get ifComponent() {
      return (this._ifComponent =
         this._ifComponent ||
         this.view
            .views()
            .find((v) => v?.name === "If")
            .component());
   }

   get elseComponent() {
      return (this._elseComponent =
         this._elseComponent ||
         this.view
            .views()
            .find((v) => v?.name === "Else")
            .component());
   }

   displayView(currData) {
      const dc = this.datacollection;
      const ids = this.ids;
      const $batch = $$(ids.batch);

      if (dc) {
         if (!currData) currData = dc.getCursor();

         // show 'waiting' panel
         if (
            !currData &&
            (dc.dataStatus === dc.dataStatusFlag.notInitial ||
               dc.dataStatus === dc.dataStatusFlag.initializing)
         ) {
            $batch?.showBatch("wait");

            return;
         }
      }

      const isValid = this.__filterComponent.isValid(currData);

      if (isValid) {
         // if (isValid && currData) {
         $batch?.showBatch("if");
         this.ifComponent?.onShow?.();
      } else {
         $batch?.showBatch("else");
         this.elseComponent?.onShow?.();
      }
   }

   populateFilterComponent() {
      const dc = this.datacollection;
      const __filterComponent = this.__filterComponent;

      if (dc?.datasource) __filterComponent.fieldsLoad(dc.datasource.fields());
      else __filterComponent.fieldsLoad([]);

      __filterComponent.setValue(
         this.settings.filterConditions ??
            this.view.constructor.defaultValues().filterConditions
      );
   }
};


/***/ }),

/***/ 46683:
/*!*************************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewConnectDataFilterComponent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewConnectDataFilterComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 44363);


class ABViewConnectDataFilterComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idbase, ids) {
      super(
         baseView,
         idbase || `ABViewConnectDataFilter_${baseView.id}`,
         Object.assign(
            {
               filter: "",
               reset: "",
            },
            ids
         )
      );

      this.field = null;
   }

   ui() {
      const ids = this.ids;
      const _ui = super.ui([
         {
            type: "space",
            borderless: true,
            cols: [
               {
                  view: "icon",
                  icon: "fa fa-filter",
                  align: "left",
                  disabled: true,
               },
               {
                  view: "combo",
                  id: ids.filter,
                  labelWidth: this.AB.UISettings.config().labelWidthXLarge,
                  disabled: true,
                  on: {
                     onChange: (id) => this.applyConnectFilter(id),
                  },
               },
               {
                  view: "icon",
                  id: ids.reset,
                  icon: "fa fa-times",
                  align: "left",
                  disabled: true,
                  tooltip: this.label("Renmove this filter"),
                  on: {
                     onItemClick: () => this.resetConnectFilter(),
                  },
               },
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const dv = this.datacollection;

      if (!dv) return;

      const object = dv.datasource;

      if (!object) return;

      const [field] = object.fields(
         (f) => f.columnName === this.settings.field
      );

      if (!field) {
         this.AB.notify.developer(
            `Cannot find field "${this.settings.field}" in ${object.name}`,
            {
               context: "ABViewConnectDataFilterComponent.init()",
               data: { settings: this.settings },
            }
         );

         return;
      }

      this.field = field;

      const ids = this.ids;
      const suggest = webix.ui({
         view: "suggest",
         filter: ({ value }, search) =>
            value.toLowerCase().includes(search.toLowerCase()),
         on: {
            onShow: () => {
               field.populateOptionsDataCy($$(ids.filter), field, {});
            },
         },
      });
      field.getAndPopulateOptions(suggest, null, field);

      const $filter = $$(ids.filter);

      $filter.define("suggest", suggest);
      $filter.define("label", `${this.label("Filter by")} ${field.label}`);
      $filter.enable();
      $filter.refresh();
   }

   resetConnectFilter() {
      const ids = this.ids;
      const dc = this.datacollection;

      dc.filterCondition({ glue: "and", rules: [] });
      dc.reloadData();
      // Block applyConnectFields() from triggering

      const $filter = $$(ids.filter);

      $filter.blockEvent();
      $filter.setValue();
      $filter.unblockEvent();
      $$(ids.reset).disable();
   }

   applyConnectFilter(connectId) {
      const filterRule = {
         key: this.field.id,
         rule: "equals",
         value: connectId,
      };
      const dc = this.datacollection;

      dc.filterCondition({ glue: "and", rules: [filterRule] });
      dc.reloadData();
      $$(this.ids.reset).enable();
   }
}


/***/ }),

/***/ 91219:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewContainerComponent.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewContainerComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewContainer_${baseView.id}`, ids);

      this.idBase = idBase;
      this.options = null;

      this.viewComponents = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child views that we manage

      this.viewComponentIDs = {
         /* view.id : {viewComponent} */
      };
      // {hash}
      // a reference of all our child.ui().ids of the views we manage

      this._handlerChangePage = (pageId) => {
         baseView.changePage(pageId);
      };
   }

   ui(uiComponents) {
      // Generate rows & cols of views to .layout
      const views = this.view.viewsSortByPosition();
      const rowViews = this.getElements(views);
      const _ui = super.ui(uiComponents || rowViews);

      delete _ui.type;

      return _ui;
   }

   // make sure each of our child views get .init() called
   async init(AB, accessLevel = 0, options = {}) {
      await super.init(AB);

      this.options = options;

      const allInits = [];

      // // register our callbacks:
      // if (options) {
      //    for (var c in _logic.callbacks) {
      //       _logic.callbacks[c] = options[c] || _logic.callbacks[c];
      //    }
      // }

      // see access by CSS class
      $$(this.ids.component)?.define("css", `accessLevel-${accessLevel}`);

      const viewComponents = this.viewComponents;

      // attach all the .UI views:
      for (const key in viewComponents) {
         // skip when the view is removed.
         if (
            !viewComponents[key] ??
            !this.view.views((v) => v.id === key).length
         )
            continue;

         // Initial component along with options in case there are callbacks we need to listen for
         if (accessLevel) {
            allInits.push(viewComponents[key].init(AB, accessLevel, options));

            continue;
         }

         $$(this.viewComponentIDs[key])?.hide();
      }

      await Promise.all(allInits);
   }

   getElements(views) {
      const rows = [];
      const componentMap = {};

      let curRowIndex;
      let curColIndex;

      const settings = this.settings;
      const defaultSettings = this.view.constructor.defaultValues();

      views.forEach((v) => {
         // let component = v.component(/* App, idPrefix */);
         // NOTE: PONG - Just temporary to be compatible old & new versions
         let component;

         try {
            component = v.component(this.idBase);
            // make sure any existing handlers for changePage are removed.
            v.removeAllListeners("changePage");
         } catch (err) {
            component = v.component(this.idBase);

            const ui = component.ui;

            component.ui = (() => ui).bind(component);
         }

         this.viewComponents[v.id] = component;

         ////
         //// TODO: figure out the embedded Callbacks => emit()
         ////
         // if key == "form" or "button" register the callbacks to the parent
         // NOTE this will only work on the last form of a page!
         // if (v.key == "form" && v._logic.callbacks) {
         //    _logic.callbacks = v._logic.callbacks;
         // }

         // Create a new row
         if (v.position.y == null || v.position.y !== curRowIndex) {
            curRowIndex = v.position.y || rows.length;
            curColIndex = 0;

            const rowNew = {
               cols: [],
            };

            // Create columns following setting value
            const colNumber = settings.columns || defaultSettings.columns;

            for (let i = 0; i < colNumber; i++)
               rowNew.cols.push({
                  gravity: settings.gravity?.[i]
                     ? parseInt(settings.gravity[i])
                     : defaultSettings.gravity,
               });

            rows.push(rowNew);
         }

         // Get the last row
         const rowIndx = rows.length - 1;
         const curRow = rows[rowIndx];
         const newPos = v.position.x ?? 0;
         const mapKey = `${rowIndx}-${newPos}`;

         let getGrav = 1;

         if (componentMap[mapKey])
            console.error(
               `Component[${component?.ids?.component}] is overwriting component[${componentMap[mapKey].ids?.component}]. <-- Reorder them to fix.`
            );

         componentMap[mapKey] = component;

         if (curRow.cols[newPos]?.gravity)
            getGrav = curRow.cols[newPos].gravity;

         const _ui = component.ui();

         this.viewComponentIDs[v.id] = _ui.id;
         _ui.gravity = getGrav;

         // Add ui of sub-view to column
         curRow.cols[newPos] = _ui;

         // Trigger 'changePage' event to parent
         this.eventAdd({
            emitter: v,
            eventName: "changePage",
            listener: this._handlerChangePage,
         });

         curColIndex++;
      });

      return rows;
   }

   onShow() {
      super.onShow();

      // calll .onShow in child components
      Object.values(this.viewComponents).forEach((val) => {
         val.onShow?.();
      });
   }
};


/***/ }),

/***/ 3912:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDataFilterComponent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewDataFilterComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewComponent */ 44363);
/* harmony import */ var _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ABViewGridPopupSortFields */ 83595);
/* harmony import */ var _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../viewProperties/ABViewPropertyFilterData */ 43348);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ 53059);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);





class ABViewDataFilterComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(baseView, idbase, ids) {
      super(
         baseView,
         idbase || `ABViewDataFilter_${baseView.id}`,
         Object.assign(
            {
               filter: "",
               reset: "",
               sortButton: "",
               filterButton: "",
               globalSearchToolbar: "",
            },
            ids
         )
      );

      this._handler_filterData = (fnFilter, filterRules) => {
         this.callbackFilterData(fnFilter, filterRules); // be notified when there is a change in the filter
      };

      this.field = null;
      const ab = this.AB;

      // {ABViewGridPopupSortFields}
      // The popup for adding sort criteria to our grid.
      this.PopupSortComponent = new _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_2__["default"](
         `ABViewDataFilter_Sort_Popup_${this.settings.dataviewID}`
      );
      this.PopupSortComponent.init(ab);
      this.PopupSortComponent.on("changed", (sortOptions) => {
         this.callbackSortData(sortOptions);
      });

      this.filterHelper = new _viewProperties_ABViewPropertyFilterData__WEBPACK_IMPORTED_MODULE_3__["default"](
         this.AB,
         `ABViewDataFilter_Filter_Popup_${this.settings.dataviewID}`
      );
      this.filterHelper.settings = {
         filterOption: 1,
         userFilterPosition: "toolbar",
         isGlobalToolbar: 1,
      };
      this.filterHelper.init(ab);
      this.detatch();
      this.filterHelper.on("filter.data", this._handler_filterData);
   }

   advancedUI() {
      const compId = this.ids.component;
      return [
         {
            css: "bg_gray",
            maxHeight: 60,
            rows: [
               {},
               {
                  cols: [
                     {
                        width: 18,
                     },
                     {
                        view: "button",
                        type: "icon",
                        icon: "fa fa-filter",
                        width: 40,
                        id: this.ids.filterButton,
                        css: `webix_primary abFilterButton${this.settings.dataviewID}`,
                        click: (id, event) => {
                           this.toolbarFilter($$(this.ids.filterButton).$view);
                        },
                        on: {
                           onAfterRender: function () {
                              this.getInputNode().setAttribute(
                                 "data-cy",
                                 `${compId} filter button`
                              );
                           },
                        },
                     },
                     {
                        view: "button",
                        type: "icon",
                        icon: "fa fa-sort",
                        width: 40,
                        id: this.ids.sortButton,
                        css: `webix_primary abSortButton${this.settings.dataviewID}`,
                        click: (id, event) => {
                           this.openSort($$(this.ids.sortButton).$view);
                        },
                        on: {
                           onAfterRender: function () {
                              this.getInputNode().setAttribute(
                                 "data-cy",
                                 `${compId} sort button`
                              );
                           },
                        },
                     },
                     {
                        id: this.ids.globalSearchToolbar,
                        view: "search",
                        placeholder: this.label("Search.."),
                        css: `abGlobalSearchField${this.settings.dataviewID}`,
                        width: 0,
                        attributes: {
                           "data-cy": `${this.ids.component} global search`,
                           datacollection: this.settings.dataviewID,
                        },
                        on: {
                           onTimedKeyPress: () => {
                              const searchText = $$(
                                 this.ids.globalSearchToolbar
                              ).getValue();
                              // store search text in datacollection because
                              // it is shared amoung the similar filterHelpers
                              const dc = this.datacollection;
                              dc.settings.objectWorkspace.searchText =
                                 searchText;

                              this.filterHelper.externalSearchText(searchText);
                           },
                        },
                     },
                     {
                        width: 18,
                     },
                  ],
               },
               {},
            ],
         },
      ];
   }

   connectedFieldUI() {
      return [
         {
            css: "bg_gray",
            maxHeight: 60,
            cols: [
               {
                  width: 18,
               },
               {
                  rows: [
                     {},
                     {
                        view: "abslayout",
                        cells: [
                           {
                              css: "bg_gray",
                              view: "combo",
                              id: this.ids.filter,
                              labelWidth: 0,
                              relative: true,
                              disabled: true,
                              on: {
                                 onChange: (id) => this.applyConnectFilter(id),
                              },
                           },
                           {
                              view: "icon",
                              id: this.ids.reset,
                              icon: "fa fa-times",
                              right: 24,
                              top: 7,
                              width: 24,
                              height: 24,
                              hidden: true,
                              tooltip: this.label("Remove this filter"),
                              on: {
                                 onItemClick: () =>
                                    $$(this.ids.filter).setValue(),
                              },
                           },
                        ],
                     },
                     {},
                  ],
               },
               {
                  width: 18,
               },
            ],
         },
      ];
   }

   ui() {
      if (
         !this.settings?.dataviewID ||
         (this.settings?.viewType !== "advanced" && !this.settings?.field)
      )
         return { height: 1, id: this.ids.component };

      const ui =
         this.settings.viewType == "advanced"
            ? this.advancedUI()
            : this.connectedFieldUI();
      const _ui = super.ui(ui);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const dv = this.datacollection;

      if (!dv) return;

      const object = dv.datasource;

      if (!object) return;

      if (this.settings.viewType == "advanced") {
         if (this.settings.showSort) {
            this.PopupSortComponent.objectLoad(object);
            // if there are some preset sorts show them to user
            this.PopupSortComponent.setSettings(
               dv?.settings?.objectWorkspace?.sortFields
            );
         } else {
            $$(this.ids.sortButton).hide();
         }
         if (this.settings.showFilter) {
            this.filterHelper.objectLoad(object);
         } else {
            $$(this.ids.filterButton).hide();
         }
      } else if (this.settings.viewType == "connected") {
         const [field] = object.fields(
            (f) => f.columnName === this.settings.field
         );

         if (!field) {
            this.AB.notify.developer(
               `Cannot find field "${this.settings.field}" in ${object.name}`,
               {
                  context: "ABViewDataFilterComponent.init()",
                  data: { settings: this.settings },
               }
            );

            return;
         }

         this.field = field;

         const ids = this.ids;
         const suggest = webix.ui({
            view: "suggest",
            filter: ({ value }, search) =>
               value.toLowerCase().includes(search.toLowerCase()),
            on: {
               onShow: () => {
                  field.populateOptionsDataCy($$(ids.filter), field, {});
               },
            },
            showAllOptions: true,
         });
         field.getAndPopulateOptions(suggest, null, field);

         const $filter = $$(ids.filter);

         $filter.define("suggest", suggest);
         $filter.define(
            "placeholder",
            `${this.label("Filter by")} ${field.label}`
         );
         $filter.enable();
         $filter.refresh();
      }
   }

   onShow() {
      super.onShow();
      this.updateUI();
   }

   applyConnectFilter(connectId) {
      let filterRule = [];
      if (connectId) {
         $$(this.ids.reset).show();
         filterRule = [
            {
               key: this.field.id,
               rule: "equals",
               value: connectId,
            },
         ];
      } else {
         $$(this.ids.reset).hide();
      }
      const dc = this.datacollection;

      dc.filterCondition({ glue: "and", rules: filterRule });
      dc.reloadData();
   }

   openSort($view) {
      this.PopupSortComponent.show($view);
   }

   /**
    * @method callbackSortData()
    * Process the provided sort options from our sort ui.
    * @param {array} sortRules
    *        Any Sort Rules added by the user.
    */
   async callbackSortData(sortRules = []) {
      const dc = this.datacollection;
      if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isEqual(dc?.settings?.objectWorkspace?.sortFields, sortRules)) {
         dc.settings.objectWorkspace.sortFields = sortRules;
         await this.datacollection.reloadData();
      }
      this.updateUI();
   }

   /**
    * @method callbackFilterData()
    * Process the provided filter options from our filterHelper.
    * @param {fn} fnFilter
    *        A function that returns true/false for each row of data
    *        to determine if is should exist.
    * @param {array} filterRules
    *        Any Filter Rules added by the user.
    */
   callbackFilterData(fnFilter, filterRules = []) {
      const dc = this.datacollection;
      if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isEqual(dc?.__filterCond, filterRules)) {
         dc.filterCondition(filterRules);
         dc.reloadData();
         this.updateUI();
      }
   }

   toolbarFilter($view) {
      this.filterHelper.showPopup($view);
   }

   updateUI() {
      const dc = this.datacollection;

      if (!dc) return;

      var filterButtons = document.getElementsByClassName(
         `abFilterButton${this.settings.dataviewID}`
      );

      const onlyFilterRules = this.filterHelper.filterRules();
      let filterBadge =
         onlyFilterRules?.rules?.length > 0
            ? onlyFilterRules?.rules?.length
            : null;
      for (let b of filterButtons) {
         $$(b).define("badge", filterBadge);
         $$(b).refresh();
      }

      var sortButtons = document.getElementsByClassName(
         `abSortButton${this.settings.dataviewID}`
      );

      const onlySortRules = dc.settings.objectWorkspace.sortFields;
      let sortBadge = onlySortRules?.length > 0 ? onlySortRules?.length : null;

      for (let b of sortButtons) {
         $$(b).define("badge", sortBadge);
         $$(b).refresh();
      }

      var searchFields = document.getElementsByClassName(
         `abGlobalSearchField${this.settings.dataviewID}`
      );

      const searchText = dc.settings.objectWorkspace.searchText;
      if (searchText != null) {
         for (let s of searchFields) {
            var activeElement = document.activeElement;
            if (
               activeElement?.attributes?.datacollection?.value ==
                  this.settings.dataviewID &&
               activeElement == s.getElementsByTagName("input")[0]
            ) {
               // skip the already selected input
            } else {
               $$(s).setValue(searchText);
            }
         }
      }
   }

   detatch() {
      this.filterHelper.removeListener("filter.data", this._handler_filterData);
      // this.datacollection?.removeListener("changeCursor", this.handler_select);
   }
}


/***/ }),

/***/ 93349:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDataviewComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);
const ABViewDetailComponent = __webpack_require__(/*! ./ABViewDetailComponent */ 97346);
const ABViewPropertyLinkPage =
   (__webpack_require__(/*! ../viewProperties/ABViewPropertyLinkPage */ 25733)["default"]);

module.exports = class ABViewDataviewComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewDataview_${baseView.id}`,
         Object.assign(
            {
               dataview: "",
            },
            ids
         )
      );

      this.linkPage = null;
   }

   ui() {
      // NOTE: need to initial the detail component here
      // because its dom width & height values are used .template function
      this.initDetailComponent();

      const ids = this.ids;
      const _ui = super.ui([
         {
            id: ids.dataview,
            view: "dataview",
            scroll: "y",
            sizeToContent: true,
            css: "borderless transparent",
            xCount: this.settings.xCount,
            template: (item) => this.itemTemplate(item),
            on: {
               onAfterRender: () => {
                  this.applyClickEvent();
                  this.addCyAttribute();
               },
            },
         },
      ]);

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const dc = this.datacollection;
      if (!dc) return;

      // Initial the link page helper
      this.linkPage = this.linkPageHelper.component();
      this.linkPage.init({
         view: this.view,
         datacollection: dc,
      });

      const ids = this.ids;
      const $dataView = $$(ids.dataview);
      AB.Webix.extend($dataView, AB.Webix.ProgressBar);
      dc.bind($dataView);

      window.addEventListener("resize", () => {
         clearTimeout(this._resizeEvent);
         this._resizeEvent = setTimeout(() => {
            this.resize($dataView.getParentView());
            delete this._resizeEvent;
         }, 20);
      });
   }

   onShow() {
      super.onShow();

      this.resize();
   }

   resize(base_element) {
      const $dataview = $$(this.ids.dataview);
      $dataview.resize();

      const item_width = this.getItemWidth(base_element);
      $dataview.customize({ width: item_width });
      $dataview.getTopParentView?.().resize?.();
   }

   initDetailComponent() {
      const detailUI = this.getDetailUI();
      this._detail_ui = this.AB.Webix.ui(detailUI);

      // 2 - Always allow access to components inside data view
      this.detailComponent.init(null, 2);
   }

   getDetailUI() {
      const detailCom = this.detailComponent;
      const editPage = this.settings.editPage;
      const detailsPage = this.settings.detailsPage;

      const _ui = detailCom.ui();
      // adjust the UI to make sure it will look like a "card"
      _ui.type = "clean";
      _ui.css = "ab-detail-view";

      if (detailsPage || editPage) {
         _ui.css += ` ab-detail-hover ab-record-#itemId#`;

         if (detailsPage) _ui.css += " ab-detail-page";
         if (editPage) _ui.css += " ab-edit-page";
      }

      return _ui;
   }

   itemTemplate(item) {
      const detailCom = this.detailComponent;
      const $dataview = $$(this.ids.dataview);
      const $detail_item = this._detail_ui;

      // Mock up data to initialize height of item
      if (!item || !Object.keys(item).length) {
         item = item ?? {};
         this.datacollection?.datasource?.fields().forEach((f) => {
            switch (f.key) {
               case "string":
               case "LongText":
                  item[f.columnName] = "Lorem Ipsum";
                  break;
               case "date":
               case "datetime":
                  item[f.columnName] = new Date();
                  break;
               case "number":
                  item[f.columnName] = 7;
                  break;
            }
         });
      }
      detailCom.displayData(item);

      const itemWidth =
         $dataview.data.count() > 0
            ? $dataview.type.width
            : ($detail_item.$width - 20) / this.settings.xCount;

      const itemHeight =
         $dataview.data.count() > 0
            ? $dataview.type.height
            : $detail_item.getChildViews()?.[0]?.$height;

      const tmp_dom = document.createElement("div");
      tmp_dom.appendChild($detail_item.$view);

      $detail_item.define("width", itemWidth - 24);
      $detail_item.define("height", itemHeight + 15);
      $detail_item.adjust();

      // Add cy attributes
      this.addCyItemAttributes(tmp_dom, item);

      return tmp_dom.innerHTML.replace(/#itemId#/g, item.id);
   }

   getItemWidth(base_element) {
      const $dataview = $$(this.ids.dataview);

      let currElem = base_element ?? $dataview;
      let parentWidth = currElem?.$width;
      while (currElem) {
         if (
            currElem.config.view == "scrollview" ||
            currElem.config.view == "layout"
         )
            parentWidth =
               currElem?.$width < parentWidth ? currElem?.$width : parentWidth;

         currElem = currElem?.getParentView?.();
      }

      if (!parentWidth)
         parentWidth = $dataview?.getParentView?.().$width || window.innerWidth;

      if (parentWidth > window.innerWidth) parentWidth = window.innerWidth;

      // check if the browser window minus webix default padding is the same as the parent window
      // if so we need to check to see if there is a sidebar and reduce the usable space by the
      // width of the sidebar
      if (window.innerWidth - 19 <= parentWidth) {
         const $sidebar = this.getTabSidebar();
         if ($sidebar) {
            parentWidth -= $sidebar.$width;
         }
      }

      const recordWidth = Math.floor(parentWidth / this.settings.xCount);

      return recordWidth;
   }

   getTabSidebar() {
      const $dataview = $$(this.ids.dataview);
      let $sidebar;
      let currElem = $dataview;
      while (currElem && !$sidebar) {
         $sidebar = (currElem.getChildViews?.() ?? []).filter(
            (item) => item?.config?.view == "sidebar"
         )[0];

         currElem = currElem?.getParentView?.();
      }

      return $sidebar;
   }

   applyClickEvent() {
      const editPage = this.settings.editPage;
      const detailsPage = this.settings.detailsPage;
      if (!detailsPage && !editPage) return;

      const $dataview = $$(this.ids.dataview);
      if (!$dataview) return;

      $dataview.$view.onclick = (e) => {
         let clicked = false;
         let divs = e.path ?? [];

         // NOTE: Some web browser clients do not support .path
         if (!divs.length) {
            divs.push(e.target);
            divs.push(e.target.parentNode);
         }

         if (editPage) {
            for (let p of divs) {
               if (
                  p.className &&
                  p.className.indexOf("webix_accordionitem_header") > -1
               ) {
                  clicked = true;
                  p.parentNode.parentNode.classList.forEach((c) => {
                     if (c.indexOf("ab-record-") > -1) {
                        // var record = parseInt(c.replace("ab-record-", ""));
                        const record = c.replace("ab-record-", "");
                        this.linkPage.changePage(editPage, record);
                        // com.logic.toggleTab(detailsTab, ids.component);
                     }
                  });
                  break;
               }
            }
         }

         if (detailsPage && !clicked) {
            for (let p of divs) {
               if (
                  p.className &&
                  p.className.indexOf("webix_accordionitem") > -1
               ) {
                  p.parentNode.parentNode.classList.forEach((c) => {
                     if (c.indexOf("ab-record-") > -1) {
                        // var record = parseInt(c.replace("ab-record-", ""));
                        const record = c.replace("ab-record-", "");
                        this.linkPage.changePage(detailsPage, record);
                        // com.logic.toggleTab(detailsTab, ids.component);
                     }
                  });

                  break;
               }
            }
         }
      };
   }

   addCyAttribute() {
      const baseView = this.view;
      const $dataview = $$(this.ids.dataview);
      const name = (baseView.name ?? "").replace(".dataview", "");

      $dataview.$view.setAttribute(
         "data-cy",
         `dataview container ${name} ${baseView.id}`
      );
   }

   addCyItemAttributes(dom, item) {
      const baseView = this.view;
      const uuid = item.uuid;
      const name = (baseView.name ?? "").replace(".dataview", "");
      dom.querySelector(".webix_accordionitem_body")?.setAttribute(
         "data-cy",
         `dataview item ${name} ${uuid} ${baseView.id}`
      );
      dom.querySelector(".webix_accordionitem_button")?.setAttribute(
         "data-cy",
         `dataview item button ${name} ${uuid} ${baseView.id}`
      );
   }

   get detailComponent() {
      return (this._detailComponent =
         this._detailComponent ??
         new ABViewDetailComponent(
            this.view,
            `${this.ids.component}_detail_view`
         ));
   }

   get linkPageHelper() {
      return (this.__linkPageHelper =
         this.__linkPageHelper || new ABViewPropertyLinkPage());
   }
};


/***/ }),

/***/ 78781:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailCheckboxComponent.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailCheckboxComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailCheckbox_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();

      return super.ui({
         on: {
            //Add data-cy attribute for Cypress Testing
            onAfterRender: () => {
               const dataCy = `detail checkbox ${field?.columnName} ${
                  field?.id
               } ${baseView.parentDetailComponent()?.id ?? baseView.parent.id}`;

               $$(this.ids.detailItem)?.$view.setAttribute("data-cy", dataCy);
            },
         },
      });
   }

   setValue(val) {
      let checkbox = "";

      // Check
      if (val && JSON.parse(val))
         checkbox =
            '<span class="check webix_icon fa fa-check-square-o"></span>';
      // Uncheck
      else checkbox = '<span class="check webix_icon fa fa-square-o"></span>';

      super.setValue(checkbox);
   }
};


/***/ }),

/***/ 97346:
/*!**************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailComponent.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABObjectQuery = __webpack_require__(/*! ../../ABObjectQuery */ 76500);
const ABViewContainerComponent = __webpack_require__(/*! ./ABViewContainerComponent */ 91219);

module.exports = class ABViewDetailComponent extends ABViewContainerComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetail_${baseView.id}`, ids);
      this.idBase = idBase;
   }

   ui() {
      let _ui = super.ui();

      // this wrapper allows the detail view to have a
      // card appearance as well as enables the edit and
      // details functions to work when clicked
      return {
         type: "form",
         id: this.ids.component,
         borderless: true,
         rows: [
            {
               body: _ui,
            },
         ],
      };
   }

   onShow() {
      const baseView = this.view;

      try {
         const dataCy = `Detail ${baseView.name?.split(".")[0]} ${baseView.id}`;

         $$(this.ids.component).$view.setAttribute("data-cy", dataCy);
      } catch (e) {
         console.warn("Problem setting data-cy", e);
      }

      // listen DC events
      const dv = this.datacollection;

      if (dv) {
         const currData = dv.getCursor();

         if (currData) this.displayData(currData);

         ["changeCursor", "cursorStale", "collectionEmpty"].forEach((key) => {
            this.eventAdd({
               emitter: dv,
               eventName: key,
               listener: (...p) => this.displayData(...p),
            });
         });

         this.eventAdd({
            emitter: dv,
            eventName: "create",
            listener: (createdRow) => {
               const currCursor = dv.getCursor();

               if (currCursor?.id === createdRow.id)
                  this.displayData(createdRow);
            },
         });

         this.eventAdd({
            emitter: dv,
            eventName: "update",
            listener: (updatedRow) => {
               const currCursor = dv.getCursor();

               if (currCursor?.id === updatedRow.id)
                  this.displayData(updatedRow);
            },
         });
      }

      super.onShow();
   }

   displayData(rowData = {}) {
      const views = (this.view.views() || []).sort((a, b) => {
         if (!a?.field?.() || !b?.field?.()) return 0;

         // NOTE: sort order of calculated fields.
         // FORMULA field type should be calculated before CALCULATE field type
         if (a.field().key === "formula" && b.field().key === "calculate")
            return -1;
         else if (a.field().key === "calculate" && b.field().key === "formula")
            return 1;

         return 0;
      });

      views.forEach((f) => {
         let val;

         if (f.field) {
            const field = f.field();

            if (!field) return;

            // get value of relation when field is a connect field
            switch (field.key) {
               case "connectObject":
                  val = field.pullRelationValues(rowData);

                  break;

               case "list":
                  val = rowData?.[field.columnName];

                  if (!val) {
                     val = "";

                     break;
                  }

                  if (field.settings.isMultiple === 0) {
                     let myVal = "";

                     field.settings.options.forEach((options) => {
                        if (options.id === val) myVal = options.text;
                     });

                     if (field.settings.hasColors) {
                        let myHex = "#66666";
                        let hasCustomColor = "";

                        field.settings.options.forEach((h) => {
                           if (h.text === myVal) {
                              myHex = h.hex;
                              hasCustomColor = "hascustomcolor";
                           }
                        });

                        myVal = `<span class="webix_multicombo_value ${hasCustomColor}" style="background-color: ${myHex} !important;"><span>${myVal}</span></span>`;
                     }

                     val = myVal;
                  } else {
                     const items = [];

                     let myVal = "";

                     val.forEach((value) => {
                        let hasCustomColor = "";
                        let optionHex = "";

                        if (field.settings.hasColors && value.hex) {
                           hasCustomColor = "hascustomcolor";
                           optionHex = `background: ${value.hex};`;
                        }

                        field.settings.options.forEach((options) => {
                           if (options.id === value.id) myVal = options.text;
                        });
                        items.push(
                           `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${value.id}"><span>${myVal}</span></span>`
                        );
                     });

                     val = items.join("");
                  }

                  break;

               case "user":
                  val = field.pullRelationValues(rowData);

                  break;

               case "file":
                  val = rowData?.[field.columnName];

                  if (!val) {
                     val = "";

                     break;
                  }

                  break;

               case "formula":
                  if (rowData) {
                     // const dv = this.datacollection;
                     // const ds = dv ? dv.datasource : null;
                     // const needRecalculate =
                     //    !ds || ds instanceof ABObjectQuery ? false : true;

                     // NOTE: Could not to re-calculate because `__relation` data is extracted from full data at the moment
                     // rowData.__relation format
                     // {
                     //    id: "string"
                     //    text: "string"
                     //    translations: []
                     //    uuid:  "0cb52669-d626-4c9d-85ea-2d931751d0ce"
                     //    value: "LABEL"
                     // }
                     const needRecalculate = false;

                     val = field.format(rowData, needRecalculate);
                  }

                  break;

               default:
                  val = field.format(rowData);
               // break;
            }
         }

         // set value to each components
         const vComponent = f.component(this.idBase);

         // vComponent?.onShow();

         vComponent?.setValue?.(val);
         vComponent?.displayText?.(rowData);
      });
   }
};


/***/ }),

/***/ 84704:
/*!*********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailConnectComponent.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailConnectComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailConnect_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const settings = this.settings;

      return super.ui({
         on: {
            //Add data-cy attribute for Cypress Testing
            onAfterRender: () => {
               const columnName =
                  baseView.field((fld) => fld.id === settings.fieldId)
                     ?.columnName ?? "";
               const dataCy = `detail connected ${columnName} ${
                  settings.fieldId
               } ${baseView.parentDetailComponent()?.id || baseView.parent.id}`;

               $$(this.ids.detailItem)?.$view.setAttribute("data-cy", dataCy);
            },
         },
      });
   }

   setValue(val) {
      const vals = [];

      if (Array.isArray(val))
         val.forEach((record) => {
            vals.push(
               `<span class="webix_multicombo_value">${record.text}</span>`
            );
         });
      else vals.push(`<span class="webix_multicombo_value">${val.text}</span>`);

      super.setValue(vals.join(""));
   }
};


/***/ }),

/***/ 99484:
/*!********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailCustomComponent.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailCustomComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailCustom_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();
      const detailView = baseView.detailComponent();

      let template = field ? field.columnHeader().template({}) : "";

      return super.ui({
         minHeight: 45,
         height: 60,
         template,
         on: {
            //Add data-cy attribute for Cypress Testing
            onAfterRender: () => {
               const dataCy = `detail custom ${field?.columnName} ${
                  field?.id
               } ${baseView.parentDetailComponent()?.id || baseView.parent.id}`;

               $$(this.ids.detailItem)?.$view.setAttribute("data-cy", dataCy);
            },
         },
      });
   }

   onShow() {
      super.onShow();

      const baseView = this.view;
      const field = baseView.field();

      if (!field) return;

      const $detailItem = $$(this.ids.detailItem);

      if (!$detailItem) return;

      const detailCom = baseView.detailComponent(),
         rowData = detailCom.datacollection.getCursor() || {},
         node = $detailItem.$view;

      field.customDisplay(rowData, null, node, {
         editable: false,
      });
      // Hack: remove the extra webix_template class here, which adds padding so
      // the item is not alligned with the others
      node
         .getElementsByClassName("webix_template")[1]
         ?.removeAttribute("class");
   }

   setValue(val) {
      const field = this.view.field();

      if (!field) return;

      const $detailItem = $$(this.ids.detailItem);

      if (!$detailItem) return;

      const rowData = {};

      rowData[field.columnName] = val;

      field.setValue($detailItem, rowData);
   }
};


/***/ }),

/***/ 28805:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailImageComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailImageComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailImage_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();
      const _ui = {
         on: {
            //Add data-cy attribute for Cypress Testing
            onAfterRender: () => {
               const dataCy = `detail image ${field?.columnName} ${field?.id} ${
                  baseView.parentDetailComponent()?.id || baseView.parent.id
               }`;

               $$(this.ids.detailItem)?.$view.setAttribute("data-cy", dataCy);
            },
         },
      };
      const settings = this.settings;

      if (settings.height) _ui.height = settings.height;

      return super.ui(_ui);
   }

   setValue(val) {
      const field = this.view.field();

      if (!field) {
         super.setValue("");

         return;
      }

      const parsedImageUrl = val || field.settings.defaultImageUrl;

      if (!parsedImageUrl) {
         super.setValue("");

         return;
      }

      const imageUrl = field.urlImage(parsedImageUrl);
      const settings = this.settings;
      const width = settings.width || field.settings.imageWidth || 200;
      const height = settings.height
         ? `${settings.height}px`
         : field.settings.imageHeight
         ? `${field.settings.imageHeight}px`
         : "100%";
      const imageTemplate = [
         `<div class="ab-image-data-field">`,
         `<div style="float: left; background-size: cover; background-position: center center; background-image:url('${imageUrl}');  width: ${width}px; height: ${height}; position:relative;">`,
         `<a href="${imageUrl}" target="_blank" title="" class="fa fa-download ab-image-data-field-download"></a>`,
         `</div></div>`,
      ].join("");

      super.setValue(imageTemplate);
   }
};


/***/ }),

/***/ 57076:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailItemComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

const SAFE_HTML_TAGS = [
   "abbr",
   "acronym",
   "b",
   "blockquote",
   "br",
   "code",
   "div",
   "em",
   "i",
   "li",
   "ol",
   "p",
   "span",
   "strong",
   "table",
   "td",
   "tr",
   "ul",
   "h1",
   "h2",
   "h3",
   "h4",
   "h5",
];

module.exports = class ABViewDetailItemComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewDetailItem_${baseView.id}`,
         Object.assign(
            {
               detailItem: "",
               detailItemLabel: "",
            },
            ids
         )
      );
   }

   ui(uiDetailItemComponent = {}) {
      const baseView = this.view;

      // setup 'label' of the element
      const settings = baseView.detailComponent()?.settings ?? {};
      const field = baseView.field();

      const isLabelTop = settings.labelPosition == "top";

      const group = [];
      /** @const group will be used later as rows or cols depending on label position */
      if (settings.showLabel) {
         const templateLabel = isLabelTop
            ? "<label style='display:block; text-align: left; line-height: 32px;' class='webix_inp_top_label'>#label#</label>"
            : "<label style='display: inline-block; float: left; line-height: 32px; width:#width#px;'>#label#</label>";

         const labelUi = {
            id: this.ids.detailItemLabel,
            view: "template",
            borderless: true,
            height: 38,
            template: templateLabel,
            data: { label: field?.label ?? "" },
         };
         if (!isLabelTop) labelUi.width = settings.labelWidth + 24; // Add 24px to compensate for webix padding
         group.push(labelUi);
      }

      let height;
      if (field?.settings?.useHeight === 1)
         height = parseInt(field.settings.imageHeight) || height;

      const valueUi = Object.assign(
         {
            id: this.ids.detailItem,
            view: "template",
            borderless: true,
            autowidth: true,
            height,
            isUsers: field?.key === "user",
            template: isLabelTop
               ? "<div style='min-height: 38px'>#display#</div>"
               : "<div class='ab-detail-component-holder'>#display#</div>",
            data: { display: "" }, // show empty data in template
         },
         uiDetailItemComponent
      );
      // height = 0 behaves a bit differently then autoheight here.
      if (!valueUi.height || valueUi.height == 0) {
         delete valueUi.height;
         valueUi.autoheight = true;
      }
      group.push(valueUi);
      const itemUi = {};
      settings.labelPosition == "top"
         ? (itemUi.rows = group)
         : (itemUi.cols = group);
      const _ui = super.ui([itemUi]);

      delete _ui.type;

      return _ui;
   }

   // async init(AB) {
   //    await super.init(AB);
   // }

   setValue(val, detailId) {
      const $detailItem = $$(detailId ?? this.ids.detailItem);

      if (!$detailItem) return;

      const field = this.view.field();

      switch (field?.key) {
         case "string":
         case "LongText": {
            const strVal = val
               // Sanitize all of HTML tags
               .replace(/[<]/gm, "&lt;")
               // Allow safe HTML tags
               .replace(
                  new RegExp(`(&lt;(/)?(${SAFE_HTML_TAGS.join("|")}))`, "gm"),
                  "<$2$3"
               );

            $detailItem.setValues({ display: strVal });
            break;
         }
         default:
            $detailItem.setValues({ display: val });
            break;
      }
   }
};


/***/ }),

/***/ 53676:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailTextComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailTextComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailText_${baseView.id}`, ids);
   }

   ui() {
      const field = this.view.field();
      const _ui = {
         css: "ab-text",
         on: {
            //Add data-cy attribute for Cypress Testing
            onAfterRender: () => {
               const dataCy = `detail text ${field?.columnName} ${field?.id} ${
                  this.view.parentDetailComponent()?.id || this.view.parent.id
               }`;

               $$(this.ids.component)?.$view.setAttribute("data-cy", dataCy);
            },
         },
      };
      const settings = this.settings;

      if (settings.height) _ui.height = settings.height;

      return super.ui(_ui);
   }
};


/***/ }),

/***/ 72666:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDetailTreeComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewDetailItemComponent = __webpack_require__(/*! ./ABViewDetailItemComponent */ 57076);

module.exports = class ABViewDetailTreeComponent extends (
   ABViewDetailItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewDetailTree_${baseView.id}`, ids);
   }

   get className() {
      return "ab-detail-tree";
   }

   async init(AB) {
      await super.init(AB);

      // add div of tree to detail
      this.setValue(`<div class="${this.className}"></div>`);
   }

   getDomTree() {
      const $detailItem = $$(this.ids.detailItem);

      if (!$detailItem) return;

      return $detailItem.$view.getElementsByClassName(this.className)[0];
   }

   setValue(val) {
      // convert value to array
      const vals = [];

      if (val && !Array.isArray(val)) vals.push(val);

      setTimeout(() => {
         // get tree dom
         const domTree = this.getDomTree();

         if (!domTree) return false;

         const field = this.view.field();
         const branches = [];

         if (typeof field.settings.options.data === "undefined")
            field.settings.options = new this.AB.Webix.TreeCollection({
               data: field.settings.options,
            });

         field.settings.options.data.each(function (obj) {
            if (vals.indexOf(obj.id) !== -1) {
               let html = "";
               let rootid = obj.id;

               while (this.getParentId(rootid)) {
                  field.settings.options.data.each(function (par) {
                     if (
                        field.settings.options.data.getParentId(rootid) ===
                        par.id
                     ) {
                        html = `${par.text}: ${html}`;
                     }
                  });

                  rootid = this.getParentId(rootid);
               }

               html += obj.text;
               branches.push(html);
            }
         });

         const myHex = "#4CAF50";

         let nodeHTML = "<div class='list-data-values'>";

         branches.forEach(function (item) {
            nodeHTML += `<span class="selectivity-multiple-selected-item rendered" style="background-color: ${myHex} !important;">${item}</span>`;
         });

         nodeHTML += "</div>";
         domTree.innerHTML = nodeHTML;

         let height = 33;

         if (domTree.scrollHeight > 33) height = domTree.scrollHeight;

         const $detailItem = $$(this.ids.detailItem);

         $detailItem.config.height = height;
         $detailItem.resize();
      }, 50);
   }
};


/***/ }),

/***/ 19454:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewDocxBuilderComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Docxtemplater = __webpack_require__(/*! ../../../../js/docxtemplater.v3.0.12.min.js */ 11824);
const ImageModule = __webpack_require__(/*! ../../../../js/docxtemplater-image-module.v3.0.2.min.js */ 11619);
const JSZipUtils = __webpack_require__(/*! jszip-utils/dist/jszip-utils.min.js */ 63075);
const JSZip = __webpack_require__(/*! ../../../../js/jszip.min.js */ 58296);
const sizeOf = __webpack_require__(/*! image-size */ 91137);

const ABFieldConnect = __webpack_require__(/*! ../../dataFields/ABFieldConnect */ 89981);
const ABFieldImage = __webpack_require__(/*! ../../dataFields/ABFieldImage */ 15884);
const ABObjectQuery = __webpack_require__(/*! ../../ABObjectQuery */ 76500);

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewDocxBuilderComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewDocxBuilder_${baseView.id}`,
         Object.assign(
            {
               downloadButton: "",
               noFileLabel: "",
            },
            ids
         )
      );
   }

   ui() {
      const baseView = this.view;
      const settings = this.settings;
      const defaultSettings = baseView.constructor.defaultValues();
      const buttonWidth = settings.width ?? defaultSettings.width;

      let autowidth = false;

      if (buttonWidth === 0) autowidth = true;

      let leftSpacer = {
         type: "spacer",
         width: 1,
      };
      let rightSpacer = {
         type: "spacer",
         width: 1,
      };

      switch (settings.buttonPosition ?? defaultSettings.buttonPosition) {
         case "left":
            break;
         case "center":
            leftSpacer = {
               type: "spacer",
            };
            rightSpacer = {
               type: "spacer",
            };
            break;
         case "right":
            leftSpacer = {
               type: "spacer",
            };
            break;
      }

      const buttonLabelText =
         baseView.buttonlabel ||
         settings.buttonlabel ||
         defaultSettings.buttonlabel; // Use || to check empty string ""
      const ids = this.ids;
      const _ui = super.ui([
         {
            view: "toolbar",
            css:
               settings.toolbarBackground ?? defaultSettings.toolbarBackground,
            cols: [
               leftSpacer,
               {
                  id: ids.downloadButton,
                  view: "button",
                  css: "webix_primary",
                  type: "icon",
                  icon: "fa fa-file-word-o",
                  label: buttonLabelText,
                  width: settings.width || defaultSettings.width,
                  autowidth: autowidth,
                  click: () => {
                     this.renderFile();
                  },
                  on: {
                     // Add data-cy attribute for cypress tests
                     onAfterRender: () => {
                        const name = baseView.name?.replace(".docxBuilder", "");
                        const dataCy = `docx download ${name} ${baseView.id}`;
                        $$(ids.downloadButton)
                           ?.$view.querySelector("button")
                           .setAttribute("data-cy", dataCy);
                     },
                  },
               },
               {
                  id: ids.noFileLabel,
                  view: "label",
                  label: this.label("No template file"),
               },
               {
                  type: "spacer",
               },
               rightSpacer,
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const ids = this.ids;
      const $downloadButton = $$(ids.downloadButton);
      const $noFileLabel = $$(ids.noFileLabel);

      if (this.view.settings.filename) {
         $downloadButton.show();
         $noFileLabel.hide();
      } else {
         $downloadButton.hide();
         $noFileLabel.show();
      }
   }

   async onShow() {
      super.onShow();

      const tasks = [];

      this.view.datacollections.forEach((dc) => {
         if (dc.dataStatus === dc.dataStatusFlag.notInitial)
            // load data when a widget is showing
            tasks.push(dc.loadData());
      });

      // Show loading cursor
      if (tasks.length > 0) this.busy();

      await Promise.all(tasks);

      // Hide loading cursor
      this.ready();
   }

   busy() {
      const $downloadButton = $$(this.ids.downloadButton);

      if (!$downloadButton) return;

      $downloadButton.disable();
      $downloadButton.define("icon", "fa fa-refresh fa-spin");
      $downloadButton.refresh();
   }

   ready() {
      const $downloadButton = $$(this.ids.downloadButton);

      if (!$downloadButton) return;

      $downloadButton.enable();
      $downloadButton.define("icon", "fa fa-file-word-o");
      $downloadButton.refresh();
   }

   async renderFile() {
      this.busy();

      const reportValues = await this.getReportData();

      // console.log("DOCX data: ", reportValues);

      // Download images
      const images = await this.downloadImages();

      // Download the template file
      const contentTemplateFile = await this.downloadTemplateFile();

      // Generate Docx file
      const blobFile = this.generateDocxFile(
         contentTemplateFile,
         reportValues,
         images
      );

      const baseView = this.view;

      // Let user download the output file
      baseView.letUserDownload(blobFile, baseView.filelabel);

      // Final step
      this.ready();
   }

   async getReportData() {
      const result = {};
      const tasks = [];

      // Get current cursor
      const datacollections = this.view.datacollections;
      const isDcLabelAdded = datacollections.length > 1;

      datacollections
         .filter((dc) => dc?.datasource)
         .forEach(async (dc) => {
            tasks.push(
               new Promise((resolve, reject) => {
                  const obj = dc.datasource;
                  const objModel = obj.model();
                  const dcCursor = dc.getCursor();
                  const dcValues = [];
                  // const dataList = [];

                  // merge cursor to support dc and tree cursor in the report
                  // if (dcCursor) {
                  //    const treeCursor = dc.getCursor(true);

                  //    dataList.push(this.AB.merge({}, dcCursor, treeCursor));
                  // } else {
                  //    dataList.push(...this.AB.cloneDeep(dc.getData()));
                  // }

                  let where = {};
                  if (dcCursor) {
                     where = {
                        glue: "and",
                        rules: [
                           {
                              key: obj.PK(),
                              rule: "equals",
                              value: dcCursor[obj.PK()],
                           },
                        ],
                     };
                  } else {
                     where = this.AB.merge(
                        where,
                        dc.settings?.objectWorkspace?.filterConditions ?? {}
                     );
                  }

                  // Pull data that have full relation values.
                  // NOTE: When get data from DataCollection, those data is pruned.
                  objModel
                     .findAll({
                        disableMinifyRelation: true,
                        populate: true,
                        skip: 0,
                        where,
                     })
                     .then((dataList) => {
                        // update property names to column labels to match format names in docx file
                        const mlFields = obj.multilingualFields();

                        dataList?.data.forEach((data) => {
                           let resultData;

                           // For support label of columns every languages
                           obj.fields().forEach((f) => {
                              const fieldLabels = [];

                              // Query Objects
                              if (obj instanceof ABObjectQuery) {
                                 if (typeof f.object.translations === "string")
                                    f.object.translations = JSON.parse(
                                       f.object.translations
                                    );

                                 if (typeof f.translations === "string")
                                    f.translations = JSON.parse(f.translations);

                                 (f.object.translations || []).forEach(
                                    (objTran) => {
                                       const fieldTran = (
                                          f.translations || []
                                       ).filter(
                                          (fieldTran) =>
                                             fieldTran.language_code ===
                                             objTran.language_code
                                       )[0];

                                       if (!fieldTran) return;

                                       const objectLabel = objTran.label;
                                       const fieldLabel = fieldTran.label;

                                       // Replace alias with label of object
                                       fieldLabels.push(
                                          `${objectLabel}.${fieldLabel}`
                                       );
                                    }
                                 );
                              }
                              // Normal Objects
                              else if (typeof f.translations === "string")
                                 f.translations = JSON.parse(f.translations);

                              f.translations.forEach((tran) => {
                                 fieldLabels.push(tran.label);
                              });

                              resultData = Object.assign(
                                 resultData ?? {},
                                 this.setReportValues(
                                    data,
                                    f,
                                    fieldLabels,
                                    mlFields
                                 ) ?? {}
                              );

                              // Keep ABObject into .scope of DOCX templater
                              resultData._object = obj;
                           });

                           dcValues.push(resultData);
                        });

                        // If data sources have more than 1 or the result data more than 1 items, then add label of data source
                        const datacollectionData =
                           dcValues.length > 1 ? dcValues : dcValues[0];

                        if (
                           isDcLabelAdded ||
                           (Array.isArray(datacollectionData) &&
                              datacollectionData.length > 1)
                        )
                           (dc.translations || []).forEach((tran) => {
                              result[tran.label] = datacollectionData;
                           });
                        else Object.assign(result, datacollectionData);

                        resolve();
                     });
               })
            );
         });

      await Promise.all(tasks);

      return result;
   }

   setReportValues(data, field, fieldLabels = [], multilinguageFields) {
      const result = {};

      let val = null;

      result.id = data.id;
      result[`${field.columnName}_ORIGIN`] = data[field.columnName]; // Keep origin value for compare value with custom index

      const baseView = this.view;

      // Translate multilinguage fields
      if (multilinguageFields.length) {
         const transFields = (multilinguageFields || []).filter(
            (fieldName) => data[fieldName] != null
         );

         baseView.translate(data, data, transFields, baseView.languageCode);
      }

      // Pull value
      if (field instanceof ABFieldConnect) {
         // If field is connected field, then
         // {
         //    fieldName: {Object} or [Array]
         // }
         val = data[this.AB.rules.toFieldRelationFormat(field.columnName)];

         if (val?.forEach)
            val.forEach((v) => {
               if (!v) return;

               // Sentry Fix: sometimes v is just the uuid
               // Q: what should we do in this case?
               if (typeof v == "string") return;

               // format relation data
               if (field.datasourceLink) {
                  field.datasourceLink
                     .fields((f) => !f.isConnection)
                     .forEach((f) => {
                        v[`${f.columnName}_ORIGIN`] = v[f.columnName];

                        v[f.columnName] = f.format(v, {
                           languageCode: baseView.languageCode,
                        });
                     });
               }

               // Keep ABObject to relation data
               if (v && typeof v === "object") v._object = field.datasourceLink;
            });

         // TODO
         // data[label + '_label'] = field.format(baseData);
      } else
         val = field.format(data, {
            languageCode: baseView.languageCode,
         });

      // Set value to report with every languages of label
      fieldLabels.forEach((label) => {
         if (val) result[label] = val;
         else if (!result[label]) result[label] = "";
      });

      // normalize child items
      if (data.data?.length) {
         result.data = result.data || [];

         (data.data || []).forEach((childItem, index) => {
            // add new data item
            result.data[index] = this.setReportValues(
               childItem,
               field,
               fieldLabels,
               multilinguageFields
            );
         });
      }

      return result;
   }

   async downloadImages() {
      const images = {};
      const tasks = [];
      const addDownloadTask = (fieldImage, data = []) => {
         data.forEach((d) => {
            const imageVal = fieldImage.format(d);

            if (imageVal && !images[imageVal]) {
               tasks.push(
                  new Promise((resolve, reject) => {
                     const imgUrl = fieldImage.urlImage(imageVal); // `/opsportal/image/${this.application.name}/${imageVal}`;

                     JSZipUtils.getBinaryContent(imgUrl, (error, content) => {
                        if (error) return reject(error);

                        // store binary of image
                        images[imageVal] = content;

                        resolve();
                     });
                  })
               );
            }

            // download images of child items
            addDownloadTask(fieldImage, d.data || []);
         });
      };

      this.view.datacollections
         .filter((dc) => dc?.datasource)
         .forEach((dc) => {
            const obj = dc.datasource;

            let currCursor = dc.getCursor();

            if (currCursor) {
               // Current cursor
               const treeCursor = dc.getCursor(true);

               currCursor = [this.AB.merge({}, currCursor, treeCursor)];
            } // List of data
            else currCursor = dc.getData();

            obj.fields((f) => f instanceof ABFieldImage).forEach((f) => {
               addDownloadTask(f, currCursor);
            });
         });

      await Promise.all(tasks);

      return images;
   }

   downloadTemplateFile() {
      const url = this.view.downloadUrl();

      return new Promise((resolve, reject) => {
         JSZipUtils.getBinaryContent(url, (error, content) => {
            if (error) return reject(error);

            resolve(content);
         });
      });
   }

   generateDocxFile(contentFile, data, images) {
      const summaries = {}; // { varName: sum number, ..., varName2: number2 }
      const zip = new JSZip(contentFile);
      const doc = new Docxtemplater();
      const imageModule = new ImageModule({
         centered: false,
         getImage: (tagValue, tagName) => {
            // NOTE: .getImage of version 3.0.2 does not support async
            //       we can buy newer version to support it
            //       https://docxtemplater.com/modules/image/

            return images[tagValue] || "";
         },
         getSize: (imgBuffer, tagValue, tagName) => {
            const defaultVal = [300, 160];
            const baseView = this.view;
            const dc = baseView.datacollection;

            if (!dc) {
               const dcs = baseView.datacollections;

               if (dcs) {
                  dcs.forEach((dc) => {
                     let obj = dc.datasource;

                     if (!obj) return false;

                     // This is a query object
                     if (tagName.indexOf(".") > -1) {
                        let tagNames = tagName.split(".");

                        if (!obj.objects) return false; // not a query

                        obj = obj.objects((o) => o.label === tagNames[0])[0]; // Label of object

                        if (!obj) return false;

                        tagName = tagNames[1]; // Field name
                     }

                     const imageField = obj.fields(
                        (f) => f.columnName === tagName
                     )[0];

                     if (!imageField?.settings) return false;

                     if (
                        imageField.settings.useWidth &&
                        imageField.settings.imageWidth
                     )
                        defaultVal[0] = imageField.settings.imageWidth;

                     if (
                        imageField.settings.useHeight &&
                        imageField.settings.imageHeight
                     )
                        defaultVal[1] = imageField.settings.imageHeight;

                     return false;
                  });
               }
            } else {
               let obj = dc.datasource;

               if (!obj) return defaultVal;

               // This is a query object
               if (tagName.indexOf(".") > -1) {
                  const tagNames = tagName.split(".");

                  obj = obj.objects((o) => o.label === tagNames[0])[0]; // Label of object

                  if (!obj) return defaultVal;

                  tagName = tagNames[1]; // Field name
               }

               const imageField = obj.fields(
                  (f) => f.columnName === tagName
               )[0];

               if (!imageField?.settings) return defaultVal;

               if (
                  imageField.settings.useWidth &&
                  imageField.settings.imageWidth
               )
                  defaultVal[0] = imageField.settings.imageWidth;

               if (
                  imageField.settings.useHeight &&
                  imageField.settings.imageHeight
               )
                  defaultVal[1] = imageField.settings.imageHeight;
            }
            // Find aspect ratio image dimensions
            try {
               var img = new Uint8Array(imgBuffer);
               var image = sizeOf(img);
               var ratio = Math.min(
                  defaultVal[0] / image.width,
                  defaultVal[1] / image.height
               );

               return [image.width * ratio, image.height * ratio];
            } catch (err) {
               // if invalid image, then should return 0, 0 sizes
               return defaultVal;
            }
         },
         // getSize: function (imgBuffer, tagValue, tagName) {
         //    if (imgBuffer) {
         //       var maxWidth = 300;
         //       var maxHeight = 160;

         //       // Find aspect ratio image dimensions
         //       try {
         //          var image = sizeOf(imgBuffer);
         //          var ratio = Math.min(maxWidth / image.width, maxHeight / image.height);

         //          return [image.width * ratio, image.height * ratio];
         //       }
         //       // if invalid image, then should return 0, 0 sizes
         //       catch (err) {
         //          return [0, 0];
         //       }

         //    }
         //    else {
         //       return [0, 0];
         //    }
         // }
      });

      try {
         doc.attachModule(imageModule)
            .loadZip(zip)
            .setData(data)
            .setOptions({
               parser: function (tag) {
                  return {
                     get: function (scope, context) {
                        // NOTE: AppBuilder custom filter : no return empty items
                        if (tag.indexOf("data|") === 0) {
                           const prop = (tag.split("|")[1] || "").trim();

                           return (scope["data"] || []).filter(function (item) {
                              return item[prop] ? true : false;
                           });
                        }
                        // Mark number to add to a variable
                        else if (tag.indexOf("|$sum?") > -1) {
                           const prop = tag.split("|$sum?")[0];
                           const varName = tag.split("|$sum?")[1];

                           let number = scope[prop];

                           if (typeof number === "string")
                              number = number.replace(
                                 /[^\d.]/g, // return only number and dot
                                 ""
                              );

                           if (!summaries[varName]) summaries[varName] = 0.0;

                           summaries[varName] += parseFloat(number);

                           return scope[prop];
                        }
                        // Show sum value ^
                        else if (tag.indexOf("$sum?") === 0) {
                           const varName = tag.replace("$sum?", "");

                           return summaries[varName] || 0;
                        }
                        // // Sum number of .data (Grouped query)
                        // else if (tag.indexOf("$sum|") === 0) {
                        //    const prop = (
                        //       tag.split("|")[1] || ""
                        //    ).trim();

                        //    let sum = 0;
                        //    (scope["data"] || []).forEach(
                        //       (childItem) => {
                        //          if (!childItem[prop]) return;

                        //          let number = childItem[prop];
                        //          if (typeof number === "string") {
                        //             number = number.replace(
                        //                /[^\d.]/g, // return only number and dot
                        //                ""
                        //             );
                        //          }

                        //          try {
                        //             sum += parseFloat(
                        //                number || 0
                        //             );
                        //          } catch (e) {}
                        //       }
                        //    );

                        //    // Print number with commas
                        //    if (sum) {
                        //       sum = sum
                        //          .toString()
                        //          .replace(
                        //             /\B(?=(\d{3})+(?!\d))/g,
                        //             ","
                        //          );
                        //    }

                        //    return sum;
                        // }
                        // NOTE: AppBuilder custom filter of another data source
                        else if (tag.indexOf("$") === 0) {
                           const props = tag.replace("$", "").split("|");
                           const propSource = props[0].trim();
                           const propFilter = props[1].trim(); // column name of ABFieldConnect

                           if (!propSource || !propFilter) return "";

                           // Pull Index field of connect field
                           let indexColName;

                           const obj = scope._object;

                           if (obj) {
                              const connectedField = obj.fields(
                                 (f) => f.columnName === propFilter
                              )[0];

                              if (connectedField) {
                                 const indexField = connectedField.indexField;

                                 indexColName = indexField
                                    ? indexField.columnName
                                    : null;
                              }
                           }

                           let sourceVals = data[propSource];

                           if (sourceVals && !Array.isArray(sourceVals))
                              sourceVals = [sourceVals];

                           const getVal = (data) =>
                              data[`${indexColName}_ORIGIN`] || // Pull origin data to compare by custom index
                              data[indexColName] ||
                              data.id ||
                              data;

                           return (sourceVals || []).filter(function (item) {
                              // Pull data of parent to compare
                              let comparer = scope[propFilter];

                              if (Array.isArray(comparer))
                                 return (
                                    comparer.filter(
                                       (c) => getVal(c) === getVal(item)
                                    ).length > 0
                                 );
                              else return getVal(item) === getVal(comparer);
                           });
                        }
                        // ์NOTE : Custom filter
                        else if (tag.indexOf("?") > -1) {
                           const result = scope;
                           const prop = tag.split("?")[0];
                           const condition = tag.split("?")[1];

                           if (prop && condition) {
                              let data = scope[prop];

                              if (data) {
                                 if (!Array.isArray(data)) data = [data];

                                 return data.filter((d) =>
                                    eval(condition.replace(/\./g, "d."))
                                 );
                              }
                           }
                           return result;
                        } else if (tag === ".") return scope;
                        else return scope[tag];
                     },
                  };
               },
            })
            .render(); // render the document
      } catch (error) {
         return error;
      }

      // Output the document using Data-URI
      const docxFile = doc.getZip().generate({
         type: "blob",
         mimeType:
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      });

      return docxFile;
   }
};


/***/ }),

/***/ 5793:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormButtonComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormButton extends ABViewFormItemComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormButton_${baseView.id}`, ids);
   }

   ui() {
      const self = this;
      const baseView = this.view;
      const form = baseView.parentFormComponent();
      const settings = baseView.settings ?? {};

      const alignment =
         settings.alignment || baseView.constructor.defaultValues().alignment;

      const _ui = {
         cols: [],
      };

      // spacer
      if (alignment === "center" || alignment === "right") {
         _ui.cols.push({});
      }

      // delete button
      if (settings.includeDelete) {
         _ui.cols.push(
            {
               view: "button",
               autowidth: true,
               value: settings.deleteLabel || this.label("Delete"),
               css: "webix_danger",
               click: function () {
                  self.onDelete(this);
               },
               on: {
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        `button delete ${form.id}`
                     );
                  },
               },
            },
            {
               width: 10,
            }
         );
      }

      // cancel button
      if (settings.includeCancel) {
         _ui.cols.push(
            {
               view: "button",
               autowidth: true,
               value: settings.cancelLabel || this.label("Cancel"),
               click: function () {
                  self.onCancel(this);
               },
               on: {
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        `button cancel ${form.id}`
                     );
                  },
               },
            },
            {
               width: 10,
            }
         );
      }

      // reset button
      if (settings.includeReset) {
         _ui.cols.push(
            {
               view: "button",
               autowidth: true,
               value: settings.resetLabel || this.label("Reset"),
               click: function () {
                  self.onClear(this);
               },
               on: {
                  onAfterRender: function () {
                     this.getInputNode().setAttribute(
                        "data-cy",
                        `button reset ${form.id}`
                     );
                  },
               },
            },
            {
               width: 10,
            }
         );
      }

      // save button
      if (settings.includeSave) {
         _ui.cols.push({
            view: "button",
            type: "form",
            css: "webix_primary",
            autowidth: true,
            value: settings.saveLabel || this.label("Save"),
            click: function () {
               self.onSave(this);
            },
            on: {
               onAfterRender: function () {
                  this.getInputNode().setAttribute(
                     "data-cy",
                     `button save ${form.id}`
                  );
               },
            },
         });
      }

      // spacer
      if (alignment === "center" || alignment === "left") _ui.cols.push({});

      return super.ui(_ui);
   }

   onCancel(cancelButton) {
      const baseView = this.view;
      const settings = baseView.settings ?? {};

      // get form component
      const form = baseView.parentFormComponent();

      // get ABDatacollection
      const dc = form.datacollection;

      // clear cursor of DC
      dc?.setCursor(null);

      cancelButton?.getFormView?.().clear();

      if (settings.afterCancel) form.changePage(settings.afterCancel);
      // If the redirect page is not defined, then redirect to parent page
      else {
         const noPopupFilter = (p) => p.settings && p.settings.type != "popup";

         const pageCurr = this.view.pageParent();
         if (pageCurr) {
            const pageParent = pageCurr.pageParent(noPopupFilter) ?? pageCurr;

            if (pageParent) form.changePage(pageParent.id);
         }
      }
   }

   onClear(resetButton) {
      // get form component
      const form = this.view.parentFormComponent();

      // get ABDatacollection
      const dc = form.datacollection;

      // clear cursor of DC
      if (dc) {
         dc.setCursor(null);
      }

      resetButton?.getFormView?.().clear();
   }

   onSave(saveButton) {
      if (!saveButton) {
         console.error("Require the button element");
         return;
      }
      // get form component
      const form = this.view.parentFormComponent();
      const formView = saveButton.getFormView();

      // disable the save button
      saveButton.disable?.();

      // save data
      form
         .saveData(formView)
         .then(() => {
            saveButton.enable?.();

            //Focus on first focusable component
            form.focusOnFirst();
         })
         .catch((err) => {
            console.error(err);
            // Catch uncaught error reported in Sentry and add context
            // APPBUILDER-WEB-1A3(https://appdev-designs.sentry.io/issues/4631880265/)
            try {
               saveButton.enable?.();
            } catch (e) {
               this.AB.notify.developer(e, {
                  context:
                     "formButton.onSave > catch err > saveButton.enable()",
                  buttonID: this?.view?.id,
                  formID: this?.view?.parent?.id,
               });
            }
         });
   }

   onDelete(deleteButton) {
      this.AB.Webix.confirm({
         title: this.label("Delete data"),
         text: this.label("Do you want to delete this data?"),
         callback: async (confirm) => {
            if (!confirm) return;

            deleteButton.disable?.();

            try {
               // get form component
               const form = this.view.parentFormComponent();
               const $formView = deleteButton.getFormView();

               // delete a record row
               await form.deleteData($formView);
            } catch (err) {
               console.error(err);
            } finally {
               deleteButton.enable?.();
            }
         },
      });
   }
};


/***/ }),

/***/ 90418:
/*!********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormCheckboxComponent.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormCheckboxComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormCheckbox_${baseView.id}`, ids);
   }

   ui() {
      return super.ui({
         view: "checkbox",
      });
   }
};


/***/ }),

/***/ 68759:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormComponent.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);
const ABViewFormItem = __webpack_require__(/*! ../ABViewFormItem */ 48933);
const ABViewFormConnect = __webpack_require__(/*! ../ABViewFormConnect */ 55030);
const ABViewFormCustom = __webpack_require__(/*! ../ABViewFormCustom */ 36365);
const ABViewFormTextbox = __webpack_require__(/*! ../ABViewFormTextbox */ 83743);
const ABViewFormJson = __webpack_require__(/*! ../ABViewFormJson */ 51533);

async function timeout(ms) {
   return new Promise((resolve) => setTimeout(resolve, ms));
}

const fieldValidations = [];

module.exports = class ABViewFormComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewForm_${baseView.id}`,
         Object.assign(
            {
               form: "",

               layout: "",
               filterComplex: "",
            },
            ids
         )
      );

      this.timerId = null;
      this._showed = false;
   }

   ui() {
      const baseView = this.view;
      const superComponent = baseView.superComponent();
      const rows = superComponent.ui().rows ?? [];
      const fieldValidationsHolder = this.uiValidationHolder();
      const _ui = super.ui([
         {
            id: this.ids.form,
            view: "form",
            abid: baseView.id,
            rows: rows.concat(fieldValidationsHolder),
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   uiValidationHolder() {
      const result = [
         {
            hidden: true,
            rows: [],
         },
      ];

      // NOTE: this._currentObject can be set in the KanBan Side Panel
      const baseView = this.view;
      const object = this.datacollection?.datasource ?? baseView._currentObject;

      if (!object) return result;

      const validationUI = [];
      const existsFields = baseView.fieldComponents();

      object
         // Pull fields that have validation rules
         .fields((f) => f?.settings?.validationRules)
         .forEach((f) => {
            const view = existsFields.find(
               (com) => f.id === com.settings.fieldId
            );
            if (!view) return;

            // parse the rules because they were stored as a string
            // check if rules are still a string...if so lets parse them
            if (typeof f.settings.validationRules === "string") {
               f.settings.validationRules = JSON.parse(
                  f.settings.validationRules
               );
            }

            // there could be more than one so lets loop through and build the UI
            f.settings.validationRules.forEach((rule, indx) => {
               const Filter = this.AB.filterComplexNew(
                  `${f.columnName}_${indx}`
               );
               // add the new ui to an array so we can add them all at the same time
               if (typeof Filter.ui === "function") {
                  validationUI.push(Filter.ui());
               } else {
                  // Legacy v1 method:
                  validationUI.push(Filter.ui);
               }

               // store the filter's info so we can assign values and settings after the ui is rendered
               fieldValidations.push({
                  filter: Filter,
                  view: Filter.ids.querybuilder,
                  columnName: f.columnName,
                  validationRules: rule.rules,
                  invalidMessage: rule.invalidMessage,
               });
            });
         });

      result.rows = validationUI;

      return result;
   }

   async init(AB, accessLevel, options = {}) {
      await super.init(AB);

      this.view.superComponent().init(AB, accessLevel, options);

      this.initCallbacks(options);
      this.initEvents();
      this.initValidationRules();

      const abWebix = this.AB.Webix;
      const $form = $$(this.ids.form);

      if ($form) {
         abWebix.extend($form, abWebix.ProgressBar);
      }

      if (accessLevel < 2) $form.disable();
   }

   initCallbacks(options = {}) {
      // ? We need to determine from these options whether to clear on load?
      if (options?.clearOnLoad) {
         // does this need to be a function?
         this.view.settings.clearOnLoad = options.clearOnLoad();
      }
      // Q: Should we use emit the event instead ?
      const baseView = this.view;

      if (options.onBeforeSaveData)
         baseView._callbacks.onBeforeSaveData = options.onBeforeSaveData;
      else baseView._callbacks.onBeforeSaveData = () => true;
   }

   initEvents() {
      // bind a data collection to form component
      const dc = this.datacollection;

      if (!dc) return;

      // listen DC events
      ["changeCursor", "cursorStale"].forEach((key) => {
         this.eventAdd({
            emitter: dc,
            eventName: key,
            listener: (rowData) => {
               const baseView = this.view;
               const linkViaOneConnection = baseView.fieldComponents(
                  (comp) => comp instanceof ABViewFormConnect
               );
               // clear previous xxx->one selections and add new from
               // cursor change
               linkViaOneConnection.forEach((f) => {
                  const field = f.field();
                  if (
                     field?.settings?.linkViaType == "one" &&
                     field?.linkViaOneValues
                  ) {
                     delete field.linkViaOneValues;
                     const relationVals =
                        rowData?.[field.relationName()] ??
                        rowData?.[field.columnName];
                     if (relationVals) {
                        if (Array.isArray(relationVals)) {
                           const valArray = [];
                           relationVals.forEach((v) => {
                              valArray.push(
                                 field.getRelationValue(v, { forUpdate: true })
                              );
                           });
                           field.linkViaOneValues = valArray.join(",");
                        } else {
                           field.linkViaOneValues = field.getRelationValue(
                              relationVals,
                              { forUpdate: true }
                           );
                        }
                     }
                  }
               });

               this.displayData(rowData);
            },
         });
      });

      const ids = this.ids;

      this.eventAdd({
         emitter: dc,
         eventName: "initializingData",
         listener: () => {
            const $form = $$(ids.form);

            if ($form) {
               $form.disable();

               $form.showProgress?.({ type: "icon" });
            }
         },
      });

      this.eventAdd({
         emitter: dc,
         eventName: "initializedData",
         listener: () => {
            const $form = $$(ids.form);

            if ($form) {
               $form.enable();

               $form.hideProgress?.();
            }
         },
      });

      // I think this case is currently handled by the DC.[changeCursor, cursorStale]
      // events:
      // this.eventAdd({
      //    emitter: dc,
      //    eventName: "ab.datacollection.update",
      //    listener: (msg, data) => {
      //       if (!data?.objectId) return;

      //       const object = dc.datasource;

      //       if (!object) return;

      //       if (
      //          object.id === data.objectId ||
      //          object.fields((f) => f.settings.linkObject === data.objectId)
      //             .length > 0
      //       ) {
      //          const currData = dc.getCursor();

      //          if (currData) this.displayData(currData);
      //       }
      //    },
      // });

      // bind the cursor event of the parent DC
      const linkDv = dc.datacollectionLink;

      if (linkDv)
         // update the value of link field when data of the parent dc is changed
         ["changeCursor", "cursorStale"].forEach((key) => {
            this.eventAdd({
               emitter: linkDv,
               eventName: key,
               listener: (rowData) => {
                  this.displayParentData(rowData);
               },
            });
         });
   }

   initValidationRules() {
      const dc = this.datacollection;

      if (!dc) return;

      if (!fieldValidations.length) return;

      // we need to store the rules for use later so lets build a container array
      const complexValidations = [];

      fieldValidations.forEach((f) => {
         // init each ui to have the properties (app and fields) of the object we are editing
         f.filter.applicationLoad(dc.datasource.application);
         f.filter.fieldsLoad(dc.datasource.fields());
         // now we can set the value because the fields are properly initialized
         f.filter.setValue(f.validationRules);

         // if there are validation rules present we need to store them in a lookup hash
         // so multiple rules can be stored on a single field
         if (!Array.isArray(complexValidations[f.columnName]))
            complexValidations[f.columnName] = [];

         // now we can push the rules into the hash
         complexValidations[f.columnName].push({
            filters: $$(f.view).getFilterHelper(),
            // values: $$(ids.form).getValues(),
            invalidMessage: f.invalidMessage,
         });
      });

      const ids = this.ids;

      // use the lookup to build the validation rules
      Object.keys(complexValidations).forEach((key) => {
         // get our field that has validation rules
         const formField = $$(ids.form).queryView({
            name: key,
         });

         // store the rules in a data param to be used later
         formField.$view.complexValidations = complexValidations[key];
         // define validation rules
         formField.define("validate", function (nval, oval, field) {
            // get field now that we are validating
            const fieldValidating = $$(ids.form).queryView({
               name: field,
            });

            // default valid is true
            let isValid = true;

            // check each rule that was stored previously on the element
            fieldValidating.$view.complexValidations.forEach((filter) => {
               const object = dc.datasource;
               const data = this.getValues();

               // convert rowData from { colName : data } to { id : data }
               const newData = {};

               (object.fields() || []).forEach((field) => {
                  newData[field.id] = data[field.columnName];
               });

               // for the case of "this_object" conditions:
               if (data.uuid) newData["this_object"] = data.uuid;

               // use helper funtion to check if valid
               const ruleValid = filter.filters(newData);

               // if invalid we need to tell the field
               if (!ruleValid) {
                  isValid = false;
                  // we also need to define an error message
                  fieldValidating.define(
                     "invalidMessage",
                     filter.invalidMessage
                  );
               }
            });

            return isValid;
         });

         formField.refresh();
      });
   }

   async onShow(data) {
      this.saveButton?.disable();

      this._showed = true;

      const baseView = this.view;

      // call .onShow in the base component
      const superComponent = baseView.superComponent();
      await superComponent.onShow();

      const $form = $$(this.ids.form);
      const dc = this.datacollection;

      if (dc) {
         // clear current cursor on load
         // if (this.settings.clearOnLoad || _logic.callbacks.clearOnLoad() ) {
         const settings = this.settings;

         if (settings.clearOnLoad) {
            dc.setCursor(null);
         }

         // pull data of current cursor
         const rowData = dc.getCursor();

         if ($form) dc.bind($form);

         // do this for the initial form display so we can see defaults
         await this.displayData(rowData);
      }
      // show blank data in the form
      else await this.displayData(data ?? {});

      //Focus on first focusable component
      this.focusOnFirst();

      if ($form) $form.adjust();

      // Load data of DCs that are use in record rules here
      // no need to wait until they are done. (Let the save button enable)
      // It will be re-check again when saving.
      baseView.loadDcDataOfRecordRules();

      this.saveButton?.enable();
   }

   async displayData(rowData) {
      // If setTimeout is already scheduled, no need to do anything
      if (this.timerId) return;
      else this.timerId = await timeout(80);

      const baseView = this.view;
      const customFields = baseView.fieldComponents(
         (comp) =>
            comp instanceof ABViewFormCustom ||
            // rich text
            (comp instanceof ABViewFormTextbox &&
               comp.settings.type === "rich") ||
            (comp instanceof ABViewFormJson && comp.settings.type === "filter")
      );

      const normalFields = baseView.fieldComponents(
         (comp) =>
            comp instanceof ABViewFormItem &&
            !(comp instanceof ABViewFormCustom)
      );

      // Set default values
      if (!rowData) {
         customFields.forEach((f) => {
            const field = f.field();
            if (!field) return;

            const comp = baseView.viewComponents[f.id];
            if (!comp) return;

            // var colName = field.columnName;
            if (this._showed) comp?.onShow?.();

            // set value to each components
            const defaultRowData = {};

            field.defaultValue(defaultRowData);
            field.setValue($$(comp.ids.formItem), defaultRowData);

            comp?.refresh?.(defaultRowData);
         });

         normalFields.forEach((f) => {
            if (f.key === "button") return;

            const field = f.field();
            if (!field) return;

            const comp = baseView.viewComponents[f.id];
            if (!comp) return;

            const colName = field.columnName;

            // set value to each components
            const values = {};

            field.defaultValue(values);
            $$(comp.ids.formItem)?.setValue(values[colName] ?? "");
         });

         // select parent data to default value
         const dc = this.datacollection;
         const linkDv = dc.datacollectionLink;

         if (linkDv) {
            const parentData = linkDv.getCursor();

            this.displayParentData(parentData);
         }
      }

      // Populate value to custom fields
      else {
         customFields.forEach((f) => {
            const comp = baseView.viewComponents[f.id];
            if (!comp) return;

            if (this._showed) comp?.onShow?.();

            // set value to each components
            f?.field()?.setValue($$(comp.ids.formItem), rowData);

            comp?.refresh?.(rowData);
         });

         normalFields.forEach((f) => {
            if (f.key === "button") return;

            const field = f.field();
            if (!field) return;

            const comp = baseView.viewComponents[f.id];
            if (!comp) return;

            field.setValue($$(comp.ids.formItem), rowData);
         });
      }

      this.timerId = null;
   }

   displayParentData(rowData) {
      const dc = this.datacollection;

      // If the cursor is selected, then it will not update value of the parent field
      const currCursor = dc.getCursor();
      if (currCursor) return;

      const relationField = dc.fieldLink;
      if (!relationField) return;

      const baseView = this.view;
      // Pull a component of relation field
      const relationFieldCom = baseView.fieldComponents((comp) => {
         if (!(comp instanceof ABViewFormItem)) return false;

         return comp.field()?.id === relationField.id;
      })[0];
      if (!relationFieldCom) return;

      const relationFieldView = baseView.viewComponents[relationFieldCom.id];
      if (!relationFieldView) return;

      const $relationFieldView = $$(relationFieldView.ids.formItem),
         relationName = relationField.relationName();

      // pull data of parent's dc
      const formData = {};

      formData[relationName] = rowData;

      // set data of parent to default value
      relationField.setValue($relationFieldView, formData);
   }

   detatch() {
      // TODO: remove any handlers we have attached.
   }

   focusOnFirst() {
      const baseView = this.view;

      let topPosition = 0;
      let topPositionId = "";

      baseView.views().forEach((item) => {
         if (item.key === "textbox" || item.key === "numberbox")
            if (item.position.y === topPosition) {
               topPosition = item.position.y;
               topPositionId = item.id;
            }
      });

      const childComponent = baseView.viewComponents[topPositionId];

      if (childComponent && $$(childComponent.ids.formItem))
         $$(childComponent.ids.formItem).focus();
   }

   get saveButton() {
      return $$(this.ids.form)?.queryView({
         view: "button",
         type: "form",
      });
   }
};


/***/ }),

/***/ 40500:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormConnectComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormConnectComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewFormConnect_${baseView.id}`,
         Object.assign(
            {
               popup: "",
               editpopup: "",
            },
            ids
         )
      );

      this.addPageComponent = null;
      this.editPageComponent = null;
   }

   get field() {
      return this.view.field();
   }

   get multiselect() {
      return this.field?.settings.linkType == "many";
   }

   ui() {
      const field = this.field;
      const baseView = this.view;
      const form = baseView.parentFormComponent();
      const settings = this.settings;

      if (!field) {
         console.error(`This field could not found : ${settings.fieldId}`);

         return super.ui({
            view: "label",
            label: "",
         });
      }

      const multiselect = this.multiselect; // field.settings.linkType == "many";
      const formSettings = form?.settings || {};
      const ids = this.ids;

      let _ui = {
         id: ids.formItem,
         view: multiselect ? "multicombo" : "combo",
         name: field.columnName,
         required:
            field?.settings?.required || parseInt(settings?.required) || false,
         // label: field.label,
         // labelWidth: settings.labelWidth,
         dataFieldId: field.id,
         on: {
            onItemClick: (id, e) => {
               if (
                  e.target.classList.contains("editConnectedPage") &&
                  e.target.dataset.itemId
               ) {
                  const rowId = e.target.dataset.itemId;
                  if (!rowId) return;
                  this.goToEditPage(rowId);
               }
            },
            onChange: (data) => {
               this._onChange(data);
            },
         },
      };

      if (formSettings.showLabel) {
         _ui.label = field.label;
         _ui.labelWidth = formSettings.labelWidth;
         _ui.labelPosition = formSettings.labelPosition;
      }

      this.initAddEditTool();

      _ui.suggest = {
         button: true,
         selectAll: multiselect ? true : false,
         body: {
            data: [],
            template: `${
               baseView?.settings?.editForm
                  ? '<i data-item-id="#id#" class="fa fa-cog editConnectedPage"></i>'
                  : ""
            }#value#`,
         },
         on: {
            onShow: () => {
               field.populateOptionsDataCy($$(ids.formItem), field, form);
            },
         },
         // Support partial matches
         filter: ({ value }, search) =>
            value.toLowerCase().includes(search.toLowerCase()),
      };

      _ui.onClick = {
         customField: (id, e, trg) => {
            if (settings.disable === 1) return;

            const rowData = {};
            const $formItem = $$(ids.formItem);

            if ($formItem) {
               const node = $formItem.$view;

               field.customEdit(rowData, /* App,*/ node);
            }
         },
      };

      let apcUI = this.addPageComponent?.ui;
      if (apcUI) {
         // reset some component vals to make room for button
         _ui.label = "";
         _ui.labelWidth = 0;

         // add click event to add new button
         apcUI.on = {
            onItemClick: (/*id, evt*/) => {
               // let $form = $$(id).getFormView();
               this.addPageComponent?.onClick(form.datacollection);

               return false;
            },
         };

         if (_ui.labelPosition == "top") {
            _ui.labelPosition = "left";
            _ui = {
               inputId: ids.formItem,
               rows: [
                  {
                     view: "label",
                     label: field.label,
                     // height: 22,
                     align: "left",
                  },
                  {
                     cols: [apcUI, _ui],
                  },
               ],
            };
         } else {
            _ui = {
               inputId: ids.formItem,
               rows: [
                  {
                     cols: [
                        {
                           view: "label",
                           label: field.label,
                           width: formSettings.labelWidth,
                           align: "left",
                        },
                        apcUI,
                        _ui,
                     ],
                  },
               ],
            };
         }

         _ui = super.ui(_ui);
      } else {
         _ui = {
            inputId: ids.formItem,
            rows: [_ui],
         };

         _ui = super.ui(_ui);

         delete _ui.rows[0].id;
      }

      return _ui;
   }

   async _onChange(data) {
      const ids = this.ids;
      const field = this.field;
      const baseView = this.view;

      if (this.multiselect) {
         if (typeof data == "string") {
            data = data.split(",");
         }
      }

      let selectedValues;
      if (Array.isArray(data)) {
         selectedValues = [];
         data.forEach((record) => {
            selectedValues.push(record.id || record);
            // let recordObj = record;
            // if (typeof record != "object") {
            //    // we need to convert either index or uuid to full data object
            //    recordObj = field.getItemFromVal(record);
            // }
            // if (recordObj?.id) selectedValues.push(recordObj.id);
         });
      } else {
         selectedValues = data;
         if (typeof data != "object") {
            // we need to convert either index or uuid to full data object
            selectedValues = field.getItemFromVal(data);
         }
         // selectedValues = field.pullRecordRelationValues(selectedValues);
         if (selectedValues?.id) {
            selectedValues = selectedValues.id;
         } else {
            selectedValues = data;
         }
      }

      // We can now set the new value but we need to block event listening
      // so it doesn't trigger onChange again
      const $formItem = $$(ids.formItem);

      // Q: if we don't have a $formItem, is any of the rest valid?
      if ($formItem) {
         // for xxx->one connections we need to populate again before setting
         // values because we need to use the selected values to add options
         // to the UI
         if (this?.field?.settings?.linkViaType == "one") {
            this.busy();
            await field.getAndPopulateOptions(
               $formItem,
               baseView.options,
               field,
               baseView.parentFormComponent()
            );
            this.ready();
         }

         $formItem.blockEvent();

         const prepedVals = selectedValues.join
            ? selectedValues.join()
            : selectedValues;

         $formItem.setValue(prepedVals);
         $formItem.unblockEvent();
      }
   }

   async init(AB, options) {
      await super.init(AB);

      const $formItem = $$(this.ids.formItem);
      if ($formItem) webix.extend($formItem, webix.ProgressBar);

      this.initAddEditTool();
   }

   initAddEditTool() {
      const baseView = this.view;

      // Initial add/edit page tools
      const addFormID = baseView?.settings?.formView;
      if (addFormID && baseView && !this.addPageComponent) {
         this.addPageComponent = baseView.addPageTool.component(
            this.AB,
            `${baseView.id}_${addFormID}`
         );
         this.addPageComponent.applicationLoad(baseView.application);
         this.addPageComponent.init({
            onSaveData: this.callbackSaveData.bind(this),
            onCancelClick: this.callbackCancel.bind(this),
            clearOnLoad: this.callbackClearOnLoad.bind(this),
         });
      }

      const editFormID = baseView?.settings?.editForm;
      if (editFormID && baseView && !this.editPageComponent) {
         this.editPageComponent = baseView.editPageTool.component(
            this.AB,
            `${baseView.id}_${editFormID}`
         );
         this.editPageComponent.applicationLoad(baseView.application);
         this.editPageComponent.init({
            onSaveData: this.callbackSaveData.bind(this),
            onCancelClick: this.callbackCancel.bind(this),
            clearOnLoad: this.callbackClearOnLoad.bind(this),
         });
      }
   }

   async callbackSaveData(saveData) {
      if (saveData == null) return;
      else if (!Array.isArray(saveData)) saveData = [saveData];

      const ids = this.ids;
      const field = this.field;

      // find the select component
      const $formItem = $$(ids.formItem);
      if (!$formItem) return;

      // Refresh option list
      this.busy();
      field.clearStorage(this.view.settings.filterConditions);
      const data = await field.getAndPopulateOptions(
         $formItem,
         this.view.options,
         field,
         this.view.parentFormComponent()
      );
      this.ready();

      // field.once("option.data", (data) => {
      data.forEach((item) => {
         item.value = item.text;
      });

      $formItem.getList().clearAll();
      $formItem.getList().define("data", data);

      if (field.settings.linkType === "many") {
         let selectedItems = $formItem.getValue();
         saveData.forEach((sData) => {
            if (selectedItems.indexOf(sData.id) === -1)
               selectedItems = selectedItems
                  ? `${selectedItems},${sData.id}`
                  : sData.id;
         });

         $formItem.setValue(selectedItems);
      } else {
         $formItem.setValue(saveData[0].id);
      }
      // close the popup when we are finished
      // $$(ids.popup)?.close();
      // $$(ids.editpopup)?.close();
      // });

      // field.getOptions(this.settings.filterConditions, "");
      // .then(function (data) {
      //    // we need new option that will be returned from server (above)
      //    // so we will not set this and then just reset it.
      // });
   }

   callbackCancel() {
      $$(this.ids?.popup)?.close?.();

      return false;
   }

   callbackClearOnLoad() {
      return true;
   }

   getValue(rowData) {
      return this.field.getValue($$(this.ids.formItem), rowData);
   }

   formBusy($form) {
      if (!$form) return;

      $form.disable?.();
      $form.showProgress?.({ type: "icon" });
   }

   formReady($form) {
      if (!$form) return;

      $form.enable?.();
      $form.hideProgress?.();
   }

   goToEditPage(rowId) {
      const settings = this.settings;

      if (!settings.editForm) return;

      const editForm = this.view.application.urlResolve(settings.editForm);

      if (!editForm) return;

      const $form = $$(this.ids.formItem).getFormView() || null;

      // Open the form popup
      this.editPageComponent.onClick().then(() => {
         const dc = editForm.datacollection;

         if (dc) {
            dc.setCursor(rowId);

            this.__editFormDcEvent =
               this.__editFormDcEvent ||
               dc.on("initializedData", () => {
                  dc.setCursor(rowId);
               });
         }
      });
   }

   async onShow() {
      const ids = this.ids;
      const $formItem = $$(ids.formItem);

      if (!$formItem) return;

      const field = this.field;

      if (!field) return;

      const node = $formItem.$view;

      if (!node) return;

      const $node = $$(node);

      if (!$node) return;

      const settings = this.settings;
      let filterConditions = {
         glue: "and",
         rules: [],
      };

      if (settings?.filterConditions?.rules?.length) {
         filterConditions = this.AB.cloneDeep(
            this.view.settings.filterConditions
         );
      }

      // NOTE: compatible with version 1. This code should not be here too long.
      if (
         !filterConditions?.rules?.length &&
         settings?.objectWorkspace?.filterConditions?.rules?.length
      ) {
         filterConditions = this.AB.cloneDeep(
            settings.objectWorkspace.filterConditions
         );
      }

      // Add the filter connected value
      if ((settings?.filterConnectedValue ?? "").indexOf(":") > -1) {
         const values = settings.filterConnectedValue.split(":"),
            uiConfigName = values[0],
            connectFieldId = values[1];

         filterConditions.rules.push({
            key: connectFieldId,
            rule: "filterByConnectValue",
            value: uiConfigName,
         });
      }

      const getFilterByConnectValues = (conditions, depth = 0) => {
         return [
            ...conditions.rules
               .filter((e) => e.rule === "filterByConnectValue")
               .map((e) => {
                  const filterByConnectValue = Object.assign({}, e);

                  filterByConnectValue.depth = depth;

                  return filterByConnectValue;
               }),
         ].concat(
            ...conditions.rules
               .filter((e) => e.glue)
               .map((e) => getFilterByConnectValues(e, depth + 1))
         );
      };

      const baseView = this.view;
      const filterByConnectValues = getFilterByConnectValues(
         filterConditions
      ).map((e) => {
         for (const key in baseView.parent.viewComponents) {
            if (
               !(
                  baseView.parent.viewComponents[key] instanceof
                  this.constructor
               )
            )
               continue;

            const $ui = $$(
               baseView.parent.viewComponents[key]
                  .ui()
                  .rows.find((vc) => vc.inputId)?.inputId
            );

            if ($ui?.config?.name === e.value) {
               // we need to use the element id stored in the settings to find out what the
               // ui component id is so later we can use it to look up its current value
               e.filterValue = $ui;

               break;
            }
         }

         const ab = this.AB;
         const field = ab
            .objectByID(settings.objectId)
            .fieldByID(settings.fieldId);
         const linkedObject = ab.objectByID(field.settings.linkObject);
         const linkedField = linkedObject.fieldByID(e.key);

         if (linkedField?.settings?.isCustomFK) {
            // finally if this is a custom foreign key we need the stored columnName by
            // default uuid is passed for all non CFK
            e.filterColumn = ab
               .objectByID(linkedField.settings.linkObject)
               .fields(
                  (filter) =>
                     filter.id === linkedField.settings.indexField ||
                     linkedField.settings.indexField2
               )[0].columnName;
         } else e.filterColumn = null;

         return e;
      });

      baseView.options = {
         formView: settings.formView,
         filters: filterConditions,
         // NOTE: settings.objectWorkspace.xxx is a depreciated setting.
         // We will be phasing this out.
         sort: settings.sortFields ?? settings.objectWorkspace?.sortFields,
         editable: settings.disable === 1 ? false : true,
         editPage:
            !settings.editForm || settings.editForm === "none" ? false : true,
         filterByConnectValues,
      };

      // if this field's options are filtered off another field's value we need
      // to make sure the UX helps the user know what to do.
      // fetch the options and set placeholder text for this view
      if (baseView.options.editable) {
         const parentFields = [];

         filterByConnectValues.forEach((fv) => {
            if (fv.filterValue && fv.key) {
               const $filterValueConfig = $$(fv.filterValue.config.id);

               let parentField = null;

               if (!$filterValueConfig) {
                  // this happens in the Interface Builder when only the single form UI is displayed
                  parentField = {
                     id: "perentElement",
                     label: this.label("PARENT ELEMENT"),
                  };
               } else {
                  const value = field.getValue($filterValueConfig);

                  if (!value) {
                     // if there isn't a value on the parent select element set this one to readonly and change placeholder text
                     parentField = {
                        id: fv.filterValue.config.id,
                        label: $filterValueConfig.config.label,
                     };
                  }

                  $filterValueConfig.attachEvent(
                     "onChange",
                     async (e) => {
                        const parentVal = $filterValueConfig.getValue();

                        if (parentVal) {
                           $node.define("disabled", false);
                           $node.define(
                              "placeholder",
                              this.label("Select items")
                           );
                           this.busy();
                           await field.getAndPopulateOptions(
                              $node,
                              baseView.options,
                              field,
                              baseView.parentFormComponent()
                           );
                           this.ready();
                        } else {
                           $node.define("disabled", true);
                           $node.define(
                              "placeholder",
                              this.label("Must select item from '{0}' first.", [
                                 $filterValueConfig.config.label,
                              ])
                           );
                        }

                        // TODO: Do we need to clear selected value?
                        // $node.setValue("");
                        $node.refresh();
                     },
                     false
                  );
               }

               if (
                  parentField &&
                  parentFields.findIndex((e) => e.id === parentField.id) < 0
               )
                  parentFields.push(parentField);
            }
         });

         if (parentFields.length && !$node.getValue()) {
            $node.define("disabled", true);
            $node.define(
               "placeholder",
               this.label(`Must select item from '{0}' first.`, [
                  parentFields.map((e) => e.label).join(", "),
               ])
            );
         } else {
            $node.define("disabled", false);
            $node.define("placeholder", this.label("Select items"));
         }
      } else {
         $node.define("placeholder", "");
         $node.define("disabled", true);
      }

      $node.refresh();

      // Add data-cy attributes
      const dataCy = `${field.key} ${field.columnName} ${field.id} ${baseView.parent.id}`;
      node.setAttribute("data-cy", dataCy);

      this.busy();
      try {
         await field.getAndPopulateOptions(
            // $node,
            $formItem,
            baseView.options,
            field,
            baseView.parentFormComponent()
         );
      } catch (err) {
         this.AB.notify.developer(err, {
            context:
               "ABViewFormConnectComponent > onShow() error calling field.getAndPopulateOptions",
         });
      }
      this.ready();

      // Need to refresh selected values when they are custom index
      this._onChange($formItem.getValue());
   }

   busy() {
      const $formItem = $$(this.ids.formItem);

      $formItem?.disable();
      $formItem?.showProgress?.({ type: "icon" });
   }

   ready() {
      const $formItem = $$(this.ids.formItem);

      $formItem?.enable();
      $formItem?.hideProgress?.();
   }
};


/***/ }),

/***/ 12213:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormCustomComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);
const ABFieldImage = __webpack_require__(/*! ../../dataFields/ABFieldImage */ 15884);
const FocusableTemplate = __webpack_require__(/*! ../../../../webix_custom_components/focusableTemplate */ 79119);

const DEFAULT_HEIGHT = 80;

module.exports = class ABViewFormCustomComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormCustom_${baseView.id}`, ids);
   }

   get new_width() {
      const baseView = this.view;
      const form = baseView.parentFormComponent();
      const formSettings = form?.settings ?? {};
      const settings = baseView.settings ?? {};

      let newWidth = formSettings.labelWidth;

      if (settings.formView) newWidth += 40;
      else if (formSettings.showLabel && formSettings.labelPosition === "top")
         newWidth = 0;

      return newWidth;
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();
      const form = baseView.parentFormComponent();
      const formSettings = form?.settings ?? {};
      const settings = field?.settings ?? baseView.settings ?? {};

      const requiredClass =
         field?.settings?.required || this.settings.required
            ? "webix_required"
            : "";

      let templateLabel = "";

      if (formSettings.showLabel) {
         if (formSettings.labelPosition === "top")
            templateLabel = `<label style="box-sizing: border-box; display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; color: #313131;" class="webix_inp_top_label ${requiredClass}">#label#</label>`;
         else
            templateLabel = `<label style="box-sizing: border-box; width: #width#px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 8px 0 0; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; color: #313131;" class="${requiredClass}">#label#</label>`;
      }

      let height = 38;
      let width = this.new_width;

      if (typeof field == "undefined") {
         console.warn(
            `BaseView[${baseView.id}] returned an undefined field()`,
            baseView.toObj()
         );
      }

      if (field instanceof ABFieldImage) {
         if (settings.useHeight) {
            if (formSettings.labelPosition === "top") {
               height = parseInt(settings.imageHeight) || DEFAULT_HEIGHT;
               height += 38;
            } else {
               height = parseInt(settings.imageHeight) || DEFAULT_HEIGHT;
            }
         } else if (formSettings.labelPosition === "top") {
            height = DEFAULT_HEIGHT + 38;
         } else {
            if (DEFAULT_HEIGHT > 38) {
               height = DEFAULT_HEIGHT;
            }
         }
         width =
            settings.useWidth && settings.imageWidth ? settings.imageWidth : 0;
      } else if (formSettings.showLabel && formSettings.labelPosition === "top")
         height = DEFAULT_HEIGHT;

      let template = `<div class="customField ${formSettings.labelPosition}">${
         formSettings.labelPosition == "top" ? "" : templateLabel
      }#template#</div>`
         .replace(/#width#/g, formSettings.labelWidth)
         .replace(/#label#/g, field?.label ?? "")
         .replace(
            /#template#/g,
            field
               ?.columnHeader({
                  width: width,
                  height: height,
                  editable: true,
               })
               .template({}) ?? ""
         );

      if (settings.useWidth == 0) {
         template = template.replace(
            /"ab-image-data-field" style="float: left; width: 100%/g,
            '"ab-image-data-field" style="float: left; width: calc(100% - ' +
               formSettings.labelWidth +
               "px)"
         );
      }

      return super.ui({
         view: "forminput",
         labelWidth: 0,
         paddingY: 0,
         paddingX: 0,
         css: "ab-custom-field",
         // label:  field.label,
         // labelPosition: settings.labelPosition, // webix.forminput does not have .labelPosition T T
         // labelWidth: settings.labelWidth,
         body: {
            view: new FocusableTemplate(this.AB._App).key,
            css: "customFieldCls",
            borderless: true,
            template: template,
            height: height,
            onClick: {
               customField: (evt, e, trg) => {
                  if (settings.disable === 1) return;

                  let rowData = {};

                  const formView =
                     this?.parentFormComponent?.() ||
                     this.view?.parentFormComponent?.();

                  if (formView) {
                     const dv = formView.datacollection;
                     if (dv) rowData = dv.getCursor() || {};
                  }

                  // var node = $$(ids.formItem).$view;
                  let node = $$(trg).getParentView().$view;
                  field?.customEdit(
                     rowData,
                     this.AB_App,
                     node,
                     this.ids.formItem,
                     evt
                  );
               },
            },
         },
      });
   }

   onShow() {
      const ids = this.ids;
      const $formItem = $$(ids.formItem);

      if (!$formItem) return;

      const baseView = this.view;
      const field = baseView.field(),
         rowData = {},
         node = $formItem.$view;

      // Add data-cy attributes
      const dataCy = `${baseView.key} ${field.key} ${field.columnName} ${baseView.id} ${baseView.parent.id}`;
      node.setAttribute("data-cy", dataCy);

      const options = {
         formId: ids.formItem,
         editable: baseView.settings.disable === 1 ? false : true,
      };

      if (field instanceof ABFieldImage) {
         options.height = field.settings.useHeight
            ? parseInt(field.settings.imageHeight) || DEFAULT_HEIGHT
            : DEFAULT_HEIGHT;
         options.width = field.settings.useWidth
            ? parseInt(field.settings.imageWidth) || 0
            : 0;
      }

      field.customDisplay(rowData, this.AB._App, node, options);
   }

   getValue(rowData) {
      const field = this.view.field();
      const $formItem = $$(this.ids.formItem);

      return field.getValue($formItem, rowData);
   }
};


/***/ }),

/***/ 37264:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormDatepickerComponent.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormDatepickerComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormDatepicker_${baseView.id}`, ids);
   }

   ui() {
      const self = this;
      const field = this.view.field();

      const _ui = {
         view: "datepicker",
         suggest: {
            body: {
               view:
                  this.AB.Account?._config?.languageCode == "th"
                     ? "thaicalendar"
                     : "calendar",
               type: field.settings?.dateFormat === 1 ? "time" : "",
               timepicker:
                  field.key === "datetime" && field.settings?.timeFormat !== 1
                     ? true
                     : false,
               editable: true,
               on: {
                  onAfterDateSelect: function (date) {
                     this.getParentView().setMasterValue({
                        value: date,
                     });
                  },
                  onTodaySet: function (date) {
                     this.getParentView().setMasterValue({
                        value: date,
                     });
                  },
                  onDateClear: function (date) {
                     this.getParentView().setMasterValue({
                        value: date,
                     });
                  },
               },
            },
            on: {
               onShow: function () {
                  const text = this.getMasterValue();
                  const field = self.view.field();
                  if (!text || !field) return true;

                  const vals = {};
                  vals[field.columnName] = text;
                  const date = self.getValue(vals);

                  const $calendar = this.getChildViews()[0];
                  $calendar.setValue(date);
               },
            },
         },
      };

      if (!field) return _ui;

      // Ignore date - Only time picker
      if (field.settings?.dateFormat === 1) _ui.type = "time";

      // Date & Time picker
      if (field.key === "datetime" && field.settings?.timeFormat !== 1)
         _ui.timepicker = true;

      // allows entering characters in datepicker input, false by default
      _ui.editable = true;

      // default value
      if (_ui.value && !(_ui.value instanceof Date))
         _ui.value = new Date(_ui.value);

      // if we have webix locale set, will use the date format form there.
      if (!window.webixLocale) _ui.format = field.getFormat();

      return super.ui(_ui);
   }

   getValue(rowData) {
      const field = this.view.field();
      const text = rowData[field.columnName];
      if (!field || !text) return null;

      // Sentry Fix: caught an error where this.AB was not set, but this.view was...
      // attempt to catch this situation and post more data:
      if (!this.AB) {
         if (this.view.AB) {
            this.AB = this.view.AB;
         } else {
            let errNoAB = new Error(
               "ABViewFormDatePicerComponent:getValue(): AB was not set."
            );
            // sentry logs the console before the error, so dump the offending view here:
            console.log("view:", JSON.stringify(this.view.toObj()));
            throw errNoAB;
         }
      }
      const date = this.AB.Webix.Date.strToDate(field.getFormat())(text);

      if (
         this.AB.Account?._config?.languageCode == "th" &&
         field.settings?.dateFormat !== 1
      )
         date.setFullYear(date.getFullYear() - 543);

      return date;
   }
};


/***/ }),

/***/ 13097:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormItemComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewFormItemComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewFormItem_${baseView.id}`,
         Object.assign({ formItem: "" }, ids)
      );
   }

   ui(uiFormItemComponent = {}) {
      // setup 'label' of the element
      const baseView = this.view;
      const form = baseView.parentFormComponent(),
         field = baseView.field?.() || null,
         label = "";
      const settings = form?.settings || {};
      const _uiFormItem = {
         id: this.ids.formItem,
         labelPosition: settings.labelPosition,
         labelWidth: settings.labelWidth,
         label,
      };

      if (field) {
         _uiFormItem.name = field.columnName;

         // default value
         const data = {};

         field.defaultValue(data);

         if (data[field.columnName]) _uiFormItem.value = data[field.columnName];

         if (settings.showLabel) _uiFormItem.label = field.label;

         if (field.settings.required || baseView.settings?.required)
            _uiFormItem.required = 1;

         if (baseView.settings?.disable === 1) _uiFormItem.disabled = true;

         // add data-cy to form element for better testing code
         _uiFormItem.on = {
            onAfterRender() {
               if (this.getList) {
                  const popup = this.getPopup();

                  if (!popup) return;

                  this.getList().data.each((option) => {
                     if (!option) return;

                     // our option.ids are based on builder input and can include the ' character
                     const node = popup.$view.querySelector(
                        `[webix_l_id='${(option?.id ?? "")
                           .toString()
                           .replaceAll("'", "\\'")}']`
                     );

                     if (!node) return;

                     node.setAttribute(
                        "data-cy",
                        `${field.key} options ${option.id} ${field.id} ${
                           form?.id || "nf"
                        }`
                     );
                  });
               }

               this.getInputNode?.().setAttribute?.(
                  "data-cy",
                  `${field.key} ${field.columnName} ${field.id} ${
                     form?.id || "nf"
                  }`
               );
            },
         };

         // this may be needed if we want to format data at this point
         // if (field.format) data = field.format(data);

         _uiFormItem.validate = (val, data, colName) => {
            const validator = this.AB.Validation.validator();

            field.isValidData(data, validator);

            return validator.pass();
         };
      }

      const _ui = super.ui([
         Object.assign({}, _uiFormItem, uiFormItemComponent),
      ]);

      delete _ui.type;

      return _ui;
   }
};


/***/ }),

/***/ 35986:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormJsonComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormJsonComponent extends ABViewFormItemComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormJson_${baseView.id}`, ids);
      if (this.settings.type == "filter") {
         this.rowFilter = this.AB.filterComplexNew(
            `${baseView.id}_filterComplex`,
            {
               isSaveHidden: true,
               height: 300,
               borderless: false,
               showObjectName: true,
            }
         );
      }
   }

   getFilterField(instance) {
      if (
         instance?.settings?.filterField &&
         instance?.view?.parent?.viewComponents
      ) {
         let filterField = "";
         for (const [key, value] of Object.entries(
            instance.view.parent.viewComponents
         )) {
            if (value.settings.fieldId == instance.settings.filterField) {
               filterField = value;
            }
         }

         if (filterField?.ids?.formItem) {
            return filterField.ids.formItem;
         } else {
            return "";
         }
      } else {
         return "";
      }
   }

   get getSystemObjects() {
      // get list of all objects in the app
      let objects = this.AB.objects();
      // reformat objects into simple array for Webix multicombo
      // if you do not the data causes a maximum stack error
      let objectsArray = [];
      objects.forEach((obj) => {
         objectsArray.push({ id: obj.id, label: obj.label });
      });
      // return the simple array
      return objectsArray;
   }

   refreshFilter(values) {
      if (values) {
         let fieldDefs = [];
         values.forEach((obj) => {
            let object = this.AB.objectByID(obj);
            let fields = object.fields();
            if (fields.length) {
               fields.forEach((f) => {
                  fieldDefs.push(f);
               });
            }
         });
         this.rowFilter.fieldsLoad(fieldDefs);
         if ($$(this.ids.formItem).config.value)
            this.rowFilter.setValue($$(this.ids.formItem).config.value);
      } else {
         this.rowFilter.fieldsLoad([]);
         if ($$(this.ids.formItem).config.value)
            this.rowFilter.setValue($$(this.ids.formItem).config.value);
      }
   }

   getValue() {
      return this.rowFilter.getValue();
   }

   setValue(formVals) {
      $$(this.ids.formItem).config.value = formVals;
   }

   ui() {
      const _ui = {};

      switch (
         this.settings.type ||
         this.view.settings.type ||
         this.view.constructor.defaultValues().type
      ) {
         case "string":
            _ui.view = "textarea";
            _ui.disabled = true;
            _ui.height = 200;
            _ui.format = {
               parse: function (parsed) {
                  try {
                     parsed = JSON.parse(parsed);
                  } catch (err) {
                     // already parsed
                  }
                  return parsed;
               },
               edit: function (stringify) {
                  try {
                     stringify = JSON.stringify(stringify);
                  } catch (err) {
                     // already a string
                  }
                  return stringify;
               },
            };
            break;
         case "systemObject":
            _ui.view = "multicombo";
            _ui.placeholder = this.label("Select one or more system objects");
            _ui.button = false;
            _ui.stringResult = false;
            _ui.suggest = {
               selectAll: true,
               body: {
                  data: this.getSystemObjects,
                  template: webix.template("#label#"),
               },
            };
            break;
         case "filter":
            _ui.view = "forminput";
            _ui.css = "ab-custom-field";
            _ui.body = this.rowFilter.ui;
            break;
      }

      return super.ui(_ui);
   }

   init() {
      // if (this.settings.type == "filter") {
      //    this.rowFilter.init({ showObjectName: true });
      // }
   }

   onShow() {
      const _ui = this.ui();
      if (this?.settings?.type == "filter") {
         let filterField = this.getFilterField(this);
         if (!$$(filterField)) return;
         $$(filterField).detachEvent("onChange");
         $$(filterField).attachEvent("onChange", (values) => {
            this.refreshFilter(values);
         });
         this.rowFilter.init({ showObjectName: true });
         this.rowFilter.on("changed", (val) => {
            this.setValue(val);
         });
         if ($$(this.ids.formItem).config.value) {
            this.rowFilter.setValue($$(this.ids.formItem).config.value);
         } else {
            this.rowFilter.setValue("");
         }
      }
   }
};


/***/ }),

/***/ 14956:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormNumberComponent.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);
const NumberTextInput = __webpack_require__(/*! ../../../../webix_custom_components/numbertext */ 65179);

module.exports = class ABViewFormNumberComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormNumber_${baseView.id}`, ids);

      this._numberTextInputKey = null;
   }

   get numberTextInputKey() {
      return (this._numberTextInputKey =
         this._numberTextInputKey || new NumberTextInput(this.AB._App).key);
   }

   ui() {
      return super.ui({
         view: this.settings.isStepper ? "counter" : this.numberTextInputKey,
         type: "number",
         validate: (val) => !isNaN(val * 1),
      });
   }
};


/***/ }),

/***/ 26050:
/*!********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormReadonlyComponent.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormReadonlyComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewFormReadonly_${baseView.id}`,
         Object.assign(
            {
               template: "",
            },
            ids
         )
      );
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();

      const _ui = {
         view: "forminput",
         labelWidth: 0,
         paddingY: 0,
         paddingX: 0,
         readonly: true,
         css: "ab-readonly-field",
         // name: component.ui.name,
         // label:  field.label,
         // labelPosition: settings.labelPosition, // webix.forminput does not have .labelPosition T T
         // labelWidth: settings.labelWidth,
         body: {
            id: this.ids.template,
            view: "label",
            borderless: true,
            css: { "background-color": "#fff" },
            label: "",
         },
      };

      const settings = baseView.parentFormComponent().settings || {};

      if (settings.showLabel == true && settings.labelPosition == "top") {
         _ui.body.height = 80;
      } else if (field.settings.useHeight) {
         _ui.body.height = parseInt(field.settings.imageHeight) || 38;
      } else _ui.body.height = 38;

      return super.ui(_ui);
   }

   async init(AB) {
      await super.init(AB);

      const $formItem = $$(this.ids.formItem);
      if (!$formItem) return;

      const $form = $formItem.getFormView();
      const rowData = $form?.getValues() ?? {};

      this.refresh(rowData);
      $form?.attachEvent("onChange", (newv, oldv) => {
         const rowData = $form?.getValues() ?? {};

         this.refresh(rowData);
      });
   }

   onShow() {
      const $formItem = $$(this.ids.formItem);
      if (!$formItem) return;

      const $form = $formItem.getFormView();
      const rowData = $form?.getValues() ?? {};

      this.refresh(rowData);
   }

   getValue(rowData) {
      const field = this.view.field();
      if (!field) return null;

      return rowData[field.columnName];
   }

   refresh(rowData) {
      const baseView = this.view;
      const form = baseView.parentFormComponent(),
         field = baseView.field();

      const formSettings = form.settings || {};

      let templateLabel = "";

      if (formSettings.showLabel) {
         if (formSettings.labelPosition === "top")
            templateLabel = `<label style="display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="webix_inp_top_label">${field.label}</label>`;
         else
            templateLabel = `<label style="width: ${formSettings.labelWidth}px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;">${field.label}</label>`;
      }

      let newWidth = formSettings.labelWidth;

      if (this.settings.formView) newWidth += 40;
      else if (formSettings.showLabel && formSettings.labelPosition === "top")
         newWidth = 0;

      const template =
         `<div class="readonlyField">${templateLabel}#template#</div>`.replace(
            /#template#/g,
            field
               .columnHeader({
                  width: newWidth,
                  editable: true,
               })
               .template(rowData)
         );

      // Re-build template element
      $$(this.ids.template)?.setHTML(template);
   }
};


/***/ }),

/***/ 70215:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormSelectMultipleComponent.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormSelectMultipleComponentComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormSelectMultiple_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field(),
         settings = this.settings;
      const options = [];

      if (field?.key === "user") options.push(...field.getUsers());
      else if (field)
         options.push(...(field.settings.options ?? settings.options ?? []));

      const ids = this.ids;
      const _ui = {
         id: ids.formItem,
         view: settings.type || baseView.constructor.defaultValues().type,
         options: options.map((opt) => {
            return {
               id: opt.id,
               value: opt.text,
               hex: opt.hex,
            };
         }),
      };

      switch (_ui.view) {
         case "multicombo":
            _ui.tagMode = false;
            _ui.css = "hideWebixMulticomboTag";
            _ui.tagTemplate = (values) => {
               const selectedOptions = [];
               const $formItem = $$(ids.formItem) ?? $$(_ui.id);

               values.forEach((val) => {
                  selectedOptions.push($formItem.getList().getItem(val));
               });

               let vals = selectedOptions;

               if (field.getSelectedOptions)
                  vals = field.getSelectedOptions(field, selectedOptions);

               const items = [];

               vals.forEach((val) => {
                  let hasCustomColor = "";
                  let optionHex = "";

                  if (field.settings.hasColors && val.hex) {
                     hasCustomColor = "hascustomcolor";
                     optionHex = `background: ${val.hex};`;
                  }

                  const text = val.text ? val.text : val.value;

                  items.push(
                     `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${val.id}"><span>${text}</span><span class="webix_multicombo_delete" role="button" aria-label="Remove item"></span></span>`
                  );
               });

               return items.join("");
            };

            break;

         case "checkbox":
            // radio element could not be empty options
            _ui.options.push({
               id: "temp",
               value: this.label("Option"),
            });

            break;
      }

      return super.ui(_ui);
   }

   getValue(rowData) {
      const field = this.view.field(),
         $formItem = $$(this.ids.formItem);

      return field.getValue($formItem, rowData);
   }
};


/***/ }),

/***/ 35111:
/*!************************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormSelectSingleComponent.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormSelectSingleComponentComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormSelectSingle_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field(),
         settings = baseView.settings;
      const options = [];

      if (field?.key === "user") options.push(...field.getUsers());
      else if (field)
         options.push(...(field.settings.options ?? settings.options ?? []));
      else options.push(...(settings.options ?? []));

      const _ui = {
         view: settings.type || baseView.constructor.defaultValues().type,
      };

      if (field?.settings.hasColors) {
         _ui.css = "combowithcolors";
         _ui.options = {
            view: "suggest",
            body: {
               view: "list",
               data: options.map((opt) => {
                  return {
                     id: opt.id,
                     value: opt.text || opt.value,
                     hex: field.settings.hasColors ? opt.hex : "",
                  };
               }),
               template: function (value) {
                  const items = [];

                  let hasCustomColor = "";
                  let optionHex = "";

                  if (value.hex) {
                     hasCustomColor = "hascustomcolor";
                     optionHex = `background: ${value.hex};`;
                  }

                  items.push(
                     `<span class="webix_multicombo_value ${hasCustomColor}" style="${optionHex}" optvalue="${value.id}"><span>${value.value}</span></span>`
                  );

                  return items.join("");
               },
            },
         };
      } else
         _ui.options = options.map((opt) => {
            return {
               id: opt.id,
               value: opt.text || opt.value,
            };
         });

      // radio element could not be empty options
      if (_ui.view === "radio" && _ui.options.length < 1)
         _ui.options.push({
            id: "temp",
            value: this.label("Option"),
         });

      return super.ui(_ui);
   }
};


/***/ }),

/***/ 96936:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormTextboxComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormTextboxComponent extends (
   ABViewFormItemComponent
) {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormTextbox_${baseView.id}`, ids);
      this.type =
         this.settings.type ||
         this.view.settings.type ||
         this.view.constructor.defaultValues().type;
   }

   ui() {
      const _ui = {};

      switch (this.type) {
         case "single":
            _ui.view = "text";
            break;
         case "multiple":
            _ui.view = "textarea";
            _ui.height = 200;
            break;
         case "rich":
            _ui.view = "forminput";
            _ui.height = 200;
            _ui.css = "ab-rich-text";
            _ui.body = {
               view: "tinymce-editor",
               value: "",
               cdn: "/js/webix/extras/tinymce",
               config: {
                  plugins: "link",
                  menubar: "format edit",
                  toolbar:
                     "undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | fontsizeselect | link",
               },
            };
            break;
      }

      return super.ui(_ui);
   }

   async onShow() {
      if (this.type !== "rich") return;
      await this.initTinyMCE();
      const _ui = this.ui();
      const _uiFormItem = _ui.rows[0];
      let $formItem = $$(this.ids.formItem);

      // WORKAROUND : to fix breaks TinyMCE when switch pages/tabs
      // https://forum.webix.com/discussion/6772/switching-tabs-breaks-tinymce
      if ($formItem) {
         // recreate rich editor
         $formItem = this.AB.Webix.ui(_uiFormItem, $formItem);

         // Add dataCy to TinyMCE text editor
         const baseView = this.view;

         $formItem
            .getChildViews()[0]
            .getEditor(true)
            .then((editor) => {
               const dataCy = `${baseView.key} rich ${_uiFormItem.name} ${
                  baseView.id ?? ""
               } ${baseView.parent?.id ?? ""}`;

               editor.contentAreaContainer.setAttribute("data-cy", dataCy);
            });
      }
   }

   /**
    * Ensure TinyMCE has been loaded and initialized.
    */
   async initTinyMCE() {
      await this.AB.custom["tinymce-editor"].init();
   }
};


/***/ }),

/***/ 72708:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewFormTreeComponent.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewFormItemComponent = __webpack_require__(/*! ./ABViewFormItemComponent */ 13097);

module.exports = class ABViewFormTreeComponent extends ABViewFormItemComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewFormTree_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;
      const field = baseView.field();

      const _ui = {};

      // this field may be deleted
      if (!field) return super.ui(_ui);

      const formSettings = baseView.parentFormComponent().settings || {};

      const requiredClass =
         field.settings.required === 1 ? "webix_required" : "";

      let templateLabel = "";

      if (formSettings.showLabel) {
         if (formSettings.labelPosition === "top")
            templateLabel = `<label style="display:block; text-align: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="webix_inp_top_label ${requiredClass}">#label#</label>`;
         else
            templateLabel = `<label style="width: #width#px; display: inline-block; line-height: 32px; float: left; margin: 0; padding:1px 7.5px 0 3px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap;" class="${requiredClass}">#label#</label>`;
      }

      let newWidth = formSettings.labelWidth;

      if (this.settings.formView) newWidth += 40;

      const template = `${templateLabel}#template#`
         .replace(/#width#/g, formSettings.labelWidth)
         .replace(/#label#/g, field.label)
         .replace(
            /#template#/g,
            field.columnHeader({
               width: newWidth,
            }).template
         );

      _ui.view = "template";
      _ui.css = "webix_el_box";
      _ui.height =
         field.settings.useHeight === 1
            ? parseInt(field.settings.imageHeight)
            : 38;
      _ui.borderless = true;

      _ui.template = `<div class="customField">${template}</div>`;

      _ui.onClick = {
         customField: (id, e, trg) => {
            const rowData = {},
               node = $$(this.ids.formItem).$view;

            rowData[field.columnName] = this.getValue();
            field.customEdit(rowData, this.AB._App, node, this);
         },
      };

      return super.ui(_ui);
   }

   getValue(rowData) {
      let vals = $$(this.ids.formItem).getValues();

      // Pass empty string if the returned values is empty array
      if (Array.isArray(vals) && vals.length === 0) vals = "";

      return vals;
   }
};


/***/ }),

/***/ 20757:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewGanttComponent.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGanttComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 44363);


class ABViewGanttComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewGantt_${baseView.id}`,
         Object.assign(
            {
               menu: "",
               gantt: "",
            },
            ids
         )
      );

      this._tempDC = null;
      // {ABDataCollection}
      // A link to a DC that was passed in.  NOTE: this is only for
      // the temp DCs created in the AppBuilder Designer and passed
      // in.  Normal DCs are handled by the default CurrentDatacollection
      // methods.

      this.TitleField = null;
      this.StartDateField = null;
      this.EndDateField = null;
      this.DurationField = null;
      this.ProgressField = null;
      this.NotesField = null;

      this.originalStartDate = null;
      this.originalEndDate = null;

      this.pendingAdds = {};
      // {Promise}  /* id : {Promise} */
      // In order to prevent a race condition where multiple adds can be
      // generated on the same item, we catch the repeats and just return
      // the same data for each.

      const idGantt = this.ids.gantt;

      this.ganttElement = {
         isExistsTask: (taskId) => {
            const localService = $$(idGantt).getService("local");
            if (!localService) return false;

            const tasksData = localService.tasks();
            if (!tasksData || !tasksData.exists) return false;

            return tasksData.exists(taskId);
         },
         removeTask: (taskId) => {
            if (!this.ganttElement.isExistsTask(taskId)) return;

            const opsService = $$(idGantt).getService("operations");
            if (!opsService) return;

            return opsService.removeTask(taskId);
         },
      };
   }

   ui() {
      const ids = this.ids;
      const self = this;
      const { YEAR_SCALE, MONTH_SCALE, DAY_SCALE } = this.getConstantScales;
      const _ui = super.ui([
         {
            cols: [
               { fillspace: true },
               {
                  view: "menu",
                  id: ids.menu,
                  layout: "x",
                  width: 300,
                  data: [
                     {
                        id: "day",
                        value: this.label("Day"),
                     },
                     {
                        id: "week",
                        value: this.label("Week"),
                     },
                     {
                        id: "month",
                        value: this.label("Month"),
                     },
                     {
                        id: "year",
                        value: this.label("Year"),
                     },
                  ],
                  on: {
                     onItemClick: (id /* , e, node */) => {
                        this.setScale(id);
                     },
                  },
               },
            ],
         },
         {
            id: ids.gantt,
            view: "gantt",
            scales: [YEAR_SCALE, MONTH_SCALE, DAY_SCALE],
            override: new Map([
               [
                  gantt.services.Backend,
                  // global webix gantt object
                  class MyBackend extends gantt.services.Backend {
                     async tasks() {
                        const DC = self.CurrentDatacollection;
                        if (!DC) return [];

                        // if (DC.dataStatus != DC.dataStatusFlag.initialized) {
                        //    await DC.loadData().catch((err) => {
                        //       console.error(err);
                        //    });
                        // }
                        return (DC.getData() || []).map((d, indx) =>
                           self.convertFormat(d, indx)
                        );
                     }
                     links() {
                        return Promise.resolve([]);
                     }
                     async addTask(obj, index, parent) {
                        if (!self.pendingAdds[obj.id]) {
                           self.pendingAdds[obj.id] = self.taskAdd(obj);
                        }
                        const newTask = await self.pendingAdds[obj.id];
                        delete self.pendingAdds[obj.id];
                        return {
                           id: (newTask || {}).id,
                        };
                     }
                     async updateTask(id, obj) {
                        return await self.taskUpdate(obj.id, obj);
                     }
                     async removeTask(id) {
                        return await self.taskRemove(id);
                     }
                  },
               ],
            ]),
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      // #HACK!: as of webix v.8.1.1 there is a visual glitch of the Gantt
      // object if you replace a gantt widget with a new definition (like in
      // the ABDesigner you can switch from Gantt1 to Gantt2 in the object
      // workspace).  In that one case, the menu would disappear even though
      // the data is present.  So this makes sure the menu is shown
      const $menu = $$(this.ids.menu);

      if ($menu) $menu.showItem("day");
   }

   /**
    * @method CurrentDatacollection()
    * A helper to return the current ABDataCollection we are working with.
    * @return {ABDataCollection}
    */
   get CurrentDatacollection() {
      return super.CurrentDatacollection || this._tempDC;
   }

   /**
    * @method convertFormat()
    * Convert an ABObject's row value into a gantt task data format.
    * @param {obj} row
    *        The current row of data returned from an ABObject.
    * @param {int} index
    *        The order of this task.
    * @return {obj}
    *         A key=>value hash corresponding to the gantt task that
    *         represents this row of data.
    */
   convertFormat(row = {}, index = null) {
      const data = {};
      const StartDateField = this.StartDateField;
      const EndDateField = this.EndDateField;
      const DurationField = this.DurationField;

      if (!StartDateField || (!EndDateField && !DurationField)) return data;

      const currDate = new Date();

      data["id"] = row.id || row.uuid;
      data["type"] = "task";
      data["parent"] = 0;
      data["open"] = true;

      // define label
      const TitleField = this.TitleField;
      const ProgressField = this.ProgressField;
      const NotesField = this.NotesField;

      data["text"] = TitleField
         ? row[TitleField.columnName] || ""
         : this.CurrentObject.displayData(row);
      data["start_date"] = row[StartDateField.columnName] || currDate;
      data["progress"] = ProgressField
         ? parseFloat(row[ProgressField.columnName] || 0)
         : 0;

      if (NotesField) data["details"] = row[NotesField.columnName] || "";

      if (EndDateField)
         data["end_date"] = row[EndDateField.columnName] || currDate;

      if (DurationField) data["duration"] = row[DurationField.columnName] || 1;

      // Default values
      if (!data["end_date"] && !data["duration"]) {
         data["end_date"] = currDate;
         data["duration"] = 1;
      }

      if (index) data["order"] = index;

      return data;
   }

   /**
    * @method convertValues()
    * Convert a Gantt task into a set of values for our ABObject.
    * @param {obj} task
    *        The current gantt task data.
    * @return {obj}
    *         A key=>value hash corresponding to the ABObject that
    *         is tied to this gantt.
    */
   convertValues(task) {
      const patch = {};
      const TitleField = this.TitleField;
      const StartDateField = this.StartDateField;
      const ProgressField = this.ProgressField;
      const NotesField = this.NotesField;
      const EndDateField = this.EndDateField;
      const DurationField = this.DurationField;

      if (TitleField) patch[TitleField.columnName] = task["text"] || "";

      if (StartDateField) patch[StartDateField.columnName] = task["start_date"];

      if (ProgressField)
         patch[ProgressField.columnName] = parseFloat(task["progress"] || 0);

      if (NotesField) patch[NotesField.columnName] = task["details"];

      if (EndDateField) patch[EndDateField.columnName] = task["end_date"];

      if (DurationField) patch[DurationField.columnName] = task["duration"];

      return patch;
   }

   /**
    * @method objectLoad
    * @param {ABObject} object
    */
   objectLoad(object) {
      super.objectLoad(object);

      // const baseView = this.view;
      const settings = this.settings;

      if (object) {
         this.TitleField = object.fieldByID(settings.titleFieldID);
         this.StartDateField = object.fieldByID(settings.startDateFieldID);
         this.EndDateField = object.fieldByID(settings.endDateFieldID);
         this.DurationField = object.fieldByID(settings.durationFieldID);
         this.ProgressField = object.fieldByID(settings.progressFieldID);
         this.NotesField = object.fieldByID(settings.notesFieldID);
      }
   }

   /**
    * @method datacollectionLoad
    * @param {ABDatacollection} datacollection
    */
   datacollectionLoad(datacollection) {
      super.datacollectionLoad(datacollection);

      const dc = this.CurrentDatacollection || datacollection;
      if (!dc) return;

      // NOTE: this can happen in the ABDesigner object workspace.
      // we send in a temp DC with no .id
      this._tempDC = datacollection;

      // NOTE: keep .objectLoad() before any .initData() is called.
      this.objectLoad(dc.datasource);

      const eventNames = ["create", "update", "delete", "initializedData"];

      eventNames.forEach((e) => {
         if (
            e in dc._events &&
            this.__events.findIndex((eo) => eo.eventName === e) !== -1
         )
            return;

         switch (e) {
            case "delete":
               this.eventAdd({
                  emitter: dc,
                  eventName: "delete",
                  listener: (taskId) => {
                     // remove this task in gantt
                     if (this.ganttElement.isExistsTask(taskId))
                        this.ganttElement.removeTask(taskId);
                  },
               });

               break;

            default:
               this.eventAdd({
                  emitter: dc,
                  eventName: e,
                  listener: () => {
                     this.initData();
                  },
               });

               break;
         }
      });
   }

   /**
    * @function hide()
    * hide this component.
    */
   hide() {
      $$(this.ids.component)?.hide();
   }

   initData() {
      const ganttElem = $$(this.ids.gantt);
      if (!ganttElem) return;

      const dataService = ganttElem.getService("local");
      if (!dataService) return;

      const dcTasks = dataService.tasks();
      if (!dcTasks) return;

      // gantt v 8.1.1
      // Note: there is a race condition that can happen here.
      // dataService.tasks() calls the MyBackend.tasks() above which
      // returns a Promise.
      // when you call dcTasks.clearAll() before the promise
      // is resolved, the gantt internally throws an error.
      //
      // So give webix some time to internally complete it's process
      // before we do .clearAll();
      setTimeout(() => {
         dcTasks.clearAll();

         const DC = this.CurrentDatacollection;
         const gantt_data = {
            data: DC
               ? (DC.getData() || []).map((d, index) =>
                    this.convertFormat(d, index)
                 )
               : [],
         };

         // check required fields before parse
         if (this.StartDateField && (this.EndDateField || this.DurationField)) {
            dcTasks.parse(gantt_data);
         }

         // Keep original start and end dates for calculate scale to display
         const currScale = dataService.getScales();

         this.originalStartDate = currScale.start;
         this.originalEndDate = currScale.end;

         this.sort();
      }, 10);
   }

   get getConstantScales() {
      const DAY_SCALE = { unit: "day", format: "%d" },
         WEEK_SCALE = {
            unit: "week",
            format: (start) => {
               const parser = webix.Date.dateToStr("%d %M");
               const wstart = webix.Date.weekStart(start);
               const wend = webix.Date.add(
                  webix.Date.add(wstart, 1, "week", true),
                  -1,
                  "day",
                  true
               );

               return parser(wstart) + " - " + parser(wend);
            },
         },
         MONTH_SCALE = { unit: "month", format: "%F" },
         YEAR_SCALE = { unit: "year", format: "%Y" };

      return {
         DAY_SCALE,
         WEEK_SCALE,
         MONTH_SCALE,
         YEAR_SCALE,
      };
   }

   setScale(scale) {
      const ganttElem = $$(this.ids.gantt);
      if (!ganttElem) return;

      const ganttData = ganttElem.getService("local");
      if (!ganttData) return;

      const newScales = [];
      const { YEAR_SCALE, MONTH_SCALE, WEEK_SCALE, DAY_SCALE } =
         this.getConstantScales;

      switch (scale) {
         case "day":
            newScales.push(YEAR_SCALE, MONTH_SCALE, DAY_SCALE);
            break;

         case "week":
            newScales.push(YEAR_SCALE, MONTH_SCALE, WEEK_SCALE);
            break;

         case "month":
            newScales.push(YEAR_SCALE, MONTH_SCALE);
            break;

         case "year":
            newScales.push(YEAR_SCALE);
            break;
      }

      const abWebix = this.AB.Webix;
      const currScale = ganttElem.getService("local").getScales(),
         start = abWebix.Date.add(this.originalStartDate, -1, scale, true),
         end = abWebix.Date.add(this.originalEndDate, 1, scale, true);

      ganttData.setScales(
         start,
         end,
         currScale.precise,
         currScale.cellWidth,
         currScale.cellHeight,
         newScales
      );
      ganttElem.$app.refresh();
      ganttElem.getState().$batch({ top: 0, left: 0 });
   }

   /**
    * @function show()
    * Show this component.
    */
   onShow() {
      super.onShow();
      this.datacollectionLoad(this.datacollection);

      $$(this.ids.component)?.show();
   }

   sort() {
      // TODO: sorting;
      return;
      // const gantt = $$(ids.gantt).getGantt();
      // if (!gantt) return;

      // // default sort
      // const MAX_date = new Date(8640000000000000);
      // gantt.sort(function(a, b) {
      //    const aStartDate = a["start_date"],
      //       aEndDate = a["end_date"],
      //       aDuration = a["duration"] || 1,
      //       bStartDate = b["start_date"],
      //       bEndDate = b["end_date"],
      //       bDuration = b["duration"] || 1;

      //    // if no start date, then be a last item
      //    if (
      //       a[this.StartDateField.columnName] == null ||
      //       b[this.StartDateField.columnName] == null
      //    ) {
      //       return (
      //          (a[this.StartDateField.columnName] || MAX_date) -
      //          (b[this.StartDateField.columnName] || MAX_date)
      //       );
      //    } else if (aStartDate != bStartDate) {
      //       return aStartDate - bStartDate;
      //    } else if (aEndDate != bEndDate) {
      //       return aEndDate - bEndDate;
      //    } else if (aDuration != bDuration) {
      //       return bDuration - aDuration;
      //    }
      // }, false);
   }

   async taskAdd(taskData) {
      const patch = this.convertValues(taskData);
      const ab = this.AB;

      try {
         // this method is being used in MyBackend addTask() method
         // On Webix documents, the method addTask() have to return the added object so we have to pass the data we add through this method.
         return await this.CurrentObject?.model().create(patch);
      } catch (e) {
         ab.Webix.alert({
            title: this.label("Error Saving Item"),
            ok: this.label("Okay"),
            text: this.label("Unable to save this item."),
         });
         ab.notify.developer(e, {
            context: "ABViewGantt:taskAdd(): Error Saving Item",
            patch,
         });

         throw e;
      }
   }

   async taskRemove(rowId) {
      const ab = this.AB;

      try {
         // this method is being used in MyBackend removeTask() method
         // On Webix documents, the method removeTask() return {} (an empty object) so we return {} in removeTask() instead.
         await this.CurrentObject.model().delete(rowId);

         return {};
      } catch (e) {
         ab.Webix.alert({
            title: this.label("Error Removing Item"),
            ok: this.label("Okay"),
            text: this.label("Unable to remove this item."),
         });
         ab.notify.developer(e, {
            context: "ABViewGantt:taskRemove(): Error Removing Item",
            rowId,
         });

         throw e;
      }
   }

   async taskUpdate(rowId, updatedTask) {
      const patch = this.convertValues(updatedTask);
      const ab = this.AB;

      try {
         // this method is being used in MyBackend updateTask() method
         // On Webix documents, the method updateTask() return {} (an empty object) so we return {} in updateTask() instead.
         await this.CurrentObject.model().update(rowId, patch);

         return {};
      } catch (e) {
         ab.Webix.alert({
            title: this.label("Error Updating Item"),
            ok: this.label("Okay"),
            text: this.label("Unable to update this item."),
         });
         ab.notify.developer(e, {
            context: "ABViewGantt:taskUpdate(): Error Updating Item",
            patch,
         });

         throw e;
      }
   }
}


/***/ }),

/***/ 24151:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewGridComponent.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewGridComponent)
/* harmony export */ });
/* harmony import */ var _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewComponent */ 44363);
/* harmony import */ var _ABViewGridPopupExport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ABViewGridPopupExport */ 69829);
/* harmony import */ var _ABViewGridPopupMassUpdate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ABViewGridPopupMassUpdate */ 32953);
/* harmony import */ var _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ABViewGridPopupSortFields */ 83595);





class ABViewGridComponent extends _ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewGrid_${baseView.id}`,
         Object.assign(
            {
               table: "",

               // component: `${base}_component`,
               toolbar: "",
               buttonDeleteSelected: "",

               buttonFilter: "",
               buttonMassUpdate: "",
               buttonSort: "",
               buttonExport: "",

               globalSearchToolbar: "",

               datatable: "",
            },
            ids
         )
      );

      this._handler_filterData = (fnFilter, filterRules) => {
         this.callbackFilterData(fnFilter, filterRules); // be notified when there is a change in the filter
      };

      this.handler_select = (...params) => {
         this.selectRow(...params);
      };
      // {fn} .handler_select
      // the callback fn for our selectRow()
      // We want this called when the .datacollection we are linked to
      // emits an "onChange" event.

      this.detatch();
      baseView.filterHelper.on("filter.data", this._handler_filterData);

      // derive these from viewGrid
      this.id = baseView.id;

      /////
      ///// For TEsting:
      /////
      // this.settings.showToolbar = 1;
      // this.settings.isEditable = 1;
      // this.settings.isExportable = 1;
      // this.settings.gridFilter = {
      //    filterOption: 1,
      //    userFilterPosition: "form",
      //    isGlobalToolbar: 1,
      // };

      // this.settings.detailsPage = "some-uuid";
      // this.settings.detailTab = "some_uuid_2";
      // this.settings.trackView = 1;
      /////
      ///// end testing
      /////

      this.columnSplitLeft = 0;
      // {integer}
      // Which column to "split"/"freeze" from the left side of the grid.

      this.columnSplitRight = 0;
      // {integer}
      // The # columns to the right to freeze.

      // this.datacollection = null;
      // // {ABDataCollection}
      // // The Webix DataCollection that manages the data we are displaying.

      this.validationError = false;
      // {bool}
      // Has a Validation Error occured?

      this.linkPage = baseView.linkPageHelper.component();
      // {ABViewPropertyLinkPage}
      //

      const idTable = this.ids.table;
      const ab = this.AB;

      this.PopupExport = new _ABViewGridPopupExport__WEBPACK_IMPORTED_MODULE_1__["default"](idTable);
      this.PopupExport.init(ab);
      // {ABViewGridPopupExport}
      // Popup for managing how to export our data.

      this.PopupMassUpdateComponent = new _ABViewGridPopupMassUpdate__WEBPACK_IMPORTED_MODULE_2__["default"](this, idTable);
      this.PopupMassUpdateComponent.init(ab);
      // this.PopupMassUpdateComponent.on("")
      // {}
      // The popup for performing a Mass Edit operation.

      this.PopupSortDataTableComponent = new _ABViewGridPopupSortFields__WEBPACK_IMPORTED_MODULE_3__["default"](idTable);
      this.PopupSortDataTableComponent.init(ab);
      this.PopupSortDataTableComponent.on("changed", (sortOptions) => {
         this.callbackSortData(sortOptions);
      });
      // {ABViewGridPopupSortFields}
      // The popup for adding sort criteria to our grid.

      this.skippableColumns = [
         "appbuilder_select_item",
         "appbuilder_view_detail",
         "appbuilder_view_track",
         "appbuilder_view_edit",
         "appbuilder_trash",
      ];
      // {array}
      // An array of column names that should be skipped from some of our
      // event handlers.

      // this.EditField = null;
      // // {ABFieldXXX}
      // // Which ABField is the focus of our PopupHeader menu?

      // this.EditNode = null;
      // // {HTML DOM}
      // // The webix.$node where the ABField Header is that our PopupHeader
      // // should be displayed at.

      this.ignoreLocalSettings = false;
      // {bool}
      // should we ignore our local settings in our current context?
      // (used in ABDesigner when our settings will change as we need to
      // use those instead of the saved settings.)

      this._gridSettings = null;
      // {hash} { grid.id : [ {columnHeader}, {columnHeader} ...]}
      // Keep a global copy of our local Grid settings, so we can optimize the header
      // sizes.

      this._isDatacollectionLoaded = false;
   }

   // {string}
   // the unique key for ABViewGrids to store/retrieve their local settings
   get keyStorageSettings() {
      return "abviewgrid_settings";
   }

   detatch() {
      this.view.filterHelper.removeAllListeners("filter.data");
      ["changeCursor", "cursorStale", "cursorSelect"].forEach((key) => {
         this.datacollection?.removeListener(key, this.handler_select);
      });
   }

   /**
    * @method getColumnIndex()
    * return the Datatable.getColumnIndex() value
    * @param {string} id
    *        the uuid of the column we are referencing.
    * @return {integer}
    */
   getColumnIndex(id) {
      let indx = this.getDataTable().getColumnIndex(id);
      if (!this.settings.massUpdate) {
         // the index is 0 based. So if the massUpdate feature isn't
         // enabled, we need to add 1 to the result so they look like
         // a 1, 2, ...

         indx++;
      }
      return indx;
   }

   uiDatatable() {
      const ids = this.ids;
      const settings = this.settings;
      const self = this;

      let view = "datatable";

      if (settings.isTreeDatable || settings.groupBy)
         // switch datatable to support tree
         view = "treetable";

      let selectType = "cell";

      if (!settings.isEditable && (settings.detailsPage || settings.editPage))
         selectType = "row";

      return {
         view,
         id: ids.datatable,
         resizeColumn: { size: 10 },
         resizeRow: { size: 10 },
         prerender: false,
         editable: settings.isEditable,
         fixedRowHeight: false,
         height: settings.height || 0,
         editaction: "custom",
         select: selectType,
         footer:
            // show footer when there are summary columns
            settings.summaryColumns.length > 0 ||
            settings.countColumns.length > 0,
         tooltip: true,
         // tooltip: {
         //    // id: ids.tooltip,
         //    template: (obj, common) => {
         //       return this.toolTip(obj, common);
         //    },
         //    on: {
         //       // When showing a larger image preview the tooltip sometime displays part of the image off the screen...this attempts to fix that problem
         //       onBeforeRender: function () {
         //          self.toolTipOnBeforeRender(this.getNode());
         //       },
         //       onAfterRender: function (data) {
         //          self.toolTipOnAfterRender(this.getNode());
         //       },
         //    },
         // },
         dragColumn: true,
         on: {
            onBeforeSelect: function (data, preserve) {
               if (self.skippableColumns.indexOf(data.column) != -1) {
                  return false;
               } else if (settings.isEditable) {
                  const currObject = self.datacollection.datasource;
                  const selectField = currObject.fields(
                     (f) => f.columnName === data.column
                  )[0];

                  if (selectField == null) return true;

                  const cellNode = this.getItemNode({
                        row: data.row,
                        column: data.column,
                     }),
                     rowData = this.getItem(data.row);

                  return selectField.customEdit(rowData, null, cellNode);
               } else if (!settings.detailsPage && !settings.editPage)
                  return false;
            },
            onAfterSelect: (data, preserve) => {
               // {ABObject} data
               //            the selected object
               // {bool} prevent
               //        indicates whether the previous selection state should
               //        be saved. (is multiselect and they are holding SHIFT)
               if (this.settings.isEditable) {
                  this.onAfterSelect(data, preserve);
               }
            },
            // onBeforeEditStart: function (/*id*/) {
            //    // Not sure what this is suposed to check, but this condition
            //    // will always be false.
            //    if (!this.getItem(id) == "appbuilder_select_item") return false;
            // },
            onCheck: function (row, col, val) {
               // Update checkbox data
               if (col == "appbuilder_select_item") {
                  // do nothing because we will parse the table once we decide
                  // if we are deleting or updating rows
                  self.toggleUpdateDelete();
               } else {
                  if (settings.isEditable) {
                     // if the colum is not the select item column move on to
                     // the next step to save
                     const state = {
                        value: val,
                     };
                     const editor = {
                        row: row,
                        column: col,
                        config: null,
                     };

                     self.onAfterEditStop(state, editor);
                  } else {
                     const node = this.getItemNode({
                        row: row,
                        column: col,
                     });
                     const checkbox = node.querySelector(
                        'input[type="checkbox"]'
                     );

                     if (val == 1) {
                        checkbox.checked = false;
                     } else {
                        checkbox.checked = true;
                     }
                  }
               }
            },
            onBeforeEditStop: function (state, editor) {
               // Check if data loading is complete
               const oldValue = state.old;
               let newValue = state.value;
               if (!Array.isArray(newValue)) newValue = [newValue];
               if (
                  oldValue != null &&
                  oldValue != "" &&
                  // If options does not load completely, then Webix returns state.value as ['', '', '']
                  newValue.filter((val) => val != null && val != "").length <
                     1 &&
                  // Check if no data load to the option
                  editor.getPopup?.().getList?.().data?.find({}).length < 1
               ) {
                  return false;
               }
            },
            onAfterEditStop: (state, editor, ignoreUpdate) => {
               if (this.validationError == false)
                  this.onAfterEditStop(state, editor, ignoreUpdate);
            },
            onValidationError: function () {
               this.validationError = true;
            },
            onValidationSuccess: function () {
               this.validationError = false;
            },

            // We are sorting with server side requests now so we can remove this
            // onAfterLoad: function () {
            //    _logic.onAfterLoad();
            // },
            onColumnResize: function (
               columnName,
               newWidth,
               oldWidth,
               user_action
            ) {
               // if we resize the delete column we want to resize the last
               // column but Webix will not allow since the column is split
               const rightSplitItems = [
                  "appbuilder_view_detail",
                  "appbuilder_view_track",
                  "appbuilder_view_edit",
                  "appbuilder_trash",
               ];

               if (rightSplitItems.indexOf(columnName) != -1) {
                  // Block events so we can leave the delete column alone
                  this.blockEvent();
                  // keeps original width
                  this.setColumnWidth(columnName, oldWidth);
                  this.unblockEvent();
                  // Listen to events again

                  // find the last column's config
                  const column = self.getLastColumn();

                  columnName = column.id;

                  // determine if we are making the column larger or smaller
                  if (newWidth < oldWidth) {
                     newWidth = column.width + 40;
                     // add 40 because there is not any more space to drag so we
                     // will allow 40px increments
                  } else {
                     newWidth = column.width - (newWidth - 40);
                     // take the column's width and subtrack the difference of
                     // the expanded delet column drag
                  }
                  // we don't want columns to be smaller than 50 ?? do we ??
                  // I could be wrong maybe a checkbox could be smaller so this
                  // could change
                  if (newWidth < 50) {
                     newWidth = 50;
                  }
                  // minWidth is important because we are using fillspace:true
                  column.minWidth = newWidth;
                  // Sets the UI
                  this.setColumnWidth(columnName, newWidth);
               }
               // Saves the new width
               if (user_action) {
                  self.onColumnResize(
                     columnName,
                     newWidth,
                     oldWidth,
                     user_action
                  );
               }
            },
            onRowResize: (rowId) => {
               // V2: we no longer do anything onRowResize()
               // before we saved the row height in the record.
               // this.onRowResize(rowId);
            },
            onBeforeColumnDrag: (sourceId, event) =>
               !(this.skippableColumns.indexOf(sourceId) !== -1),
            onBeforeColumnDrop: (sourceId, targetId, event) =>
               // Make sure we are not trying to drop onto one of our special
               // columns ...
               !(this.skippableColumns.indexOf(targetId) !== -1),
            onAfterColumnDrop: (sourceId, targetId, event) =>
               this.onAfterColumnDrop(sourceId, targetId, event),
            // onAfterColumnShow: function (id) {
            //    // console.warn("!! ToDo: onAfterColumnShow()");
            //    // $$(self.webixUiId.visibleFieldsPopup).showField(id);
            // },
            // onAfterColumnHide: function (id) {
            //    // console.warn("!! ToDo: onAfterColumnHide()");
            //    // $$(self.webixUiId.visibleFieldsPopup).hideField(id);
            // },

            onHeaderClick: (id, e, node) => {
               /* if (settings.configureHeaders) */
               this.onHeaderClick(id, e, node);
            },
         },
      };
   }

   uiFilter() {
      return this.view.filterHelper.ui();

      // make sure onFilterData is now .emit()ed instead of passing in a callback.
   }

   /**
    * @method uiToolbar()
    * Return the webix definition for the toolbar row for our Grids.
    * @return {json}
    */
   uiToolbar() {
      const ids = this.ids;
      const self = this;

      return {
         view: "toolbar",
         id: ids.toolbar,
         hidden: true,
         css: "ab-data-toolbar",
         cols: [
            {
               view: "button",
               id: ids.buttonMassUpdate,
               css: "webix_transparent",
               label: this.label("Edit"),
               icon: "fa fa-pencil-square-o",
               type: "icon",
               disabled: true,
               autowidth: true,
               click: function () {
                  self.toolbarMassUpdate(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonDeleteSelected,
               css: "webix_transparent",
               label: this.label("Delete"),
               icon: "fa fa-trash",
               type: "icon",
               disabled: true,
               autowidth: true,
               click: function () {
                  self.toolbarDeleteSelected(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonFilter,
               css: "webix_transparent",
               label: this.label("Filters"),
               icon: "fa fa-filter",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarFilter(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonSort,
               css: "webix_transparent",
               label: this.label("Sort"),
               icon: "fa fa-sort",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarSort(this.$view);
               },
            },
            {
               view: "button",
               id: ids.buttonExport,
               css: "webix_transparent",
               label: this.label("Export"),
               icon: "fa fa-print",
               type: "icon",
               autowidth: true,
               click: function () {
                  self.toolbarExport(this.$view);
               },
            },
            {},
            {
               id: ids.globalSearchToolbar,
               view: "search",
               placeholder: this.label("Search..."),
               on: {
                  onTimedKeyPress: () => {
                     const searchText = $$(ids.globalSearchToolbar).getValue();

                     this.view.filterHelper.externalSearchText(searchText);
                  },
               },
            },
         ],
      };
   }

   ui() {
      const _uiGrid = {
         id: this.ids.table,
         type: "space",
         borderless: true,
         rows: [
            {},
            {
               view: "label",
               label: this.label("Select an object to load."),
               inputWidth: 200,
               align: "center",
            },
            {},
         ],
      };

      const settings = this.settings;

      if (this.datacollection || settings.dataviewID !== "") {
         _uiGrid.padding = settings.padding;
         _uiGrid.rows = [];
         if (settings.showToolbar) {
            _uiGrid.rows.push(this.uiToolbar());
         }
         if (this.settings.gridFilter.filterOption) {
            _uiGrid.rows.push(this.uiFilter());
         }

         _uiGrid.rows.push(this.uiDatatable());
      }

      const _ui = super.ui([_uiGrid]);

      delete _ui.type;

      return _ui;
   }

   async init(AB, accessLevel = 2) {
      if (AB) await super.init(AB);

      const self = this;
      const ids = this.ids;

      // WORKAROUND : Where should we define this ??
      // For include PDF.js
      const abWebix = AB.Webix;

      abWebix.codebase = "";
      abWebix.cdn = "/js/webix";

      // this shows the options to Hide, Filter, sort , etc...
      // only in Designer?
      // PopupHeaderEditComponent.init({
      //    onClick: _logic.callbackHeaderEdit, // be notified when there is a change in the hidden fields
      // });

      // NOTE: register the onAfterRender() here, so it only registers
      // one.
      const $DataTable = this.getDataTable();

      let throttleCustomDisplay = null;
      let scrollStarted = null;

      if (!$DataTable) return;

      abWebix.extend($DataTable, abWebix.ProgressBar);

      $DataTable.config.accessLevel = accessLevel;

      if (accessLevel < 2) $DataTable.define("editable", false);

      const settings = this.settings;

      const customDisplays = (data) => {
         const CurrentObject = this.datacollection?.datasource;

         if (!CurrentObject || !$DataTable.data) return;

         const displayRecords = [];

         const verticalScrollState = $DataTable.getScrollState().y,
            rowHeight = $DataTable.config.rowHeight,
            height =
               $DataTable.$view.querySelector(".webix_ss_body").clientHeight,
            startRecIndex = Math.floor(verticalScrollState / rowHeight),
            endRecIndex = startRecIndex + $DataTable.getVisibleCount();

         let index = 0;

         $DataTable.data.order.each((id) => {
            if (id != null && startRecIndex <= index && index <= endRecIndex)
               displayRecords.push(id);

            index++;
         });

         let editable = settings.isEditable;

         if ($DataTable.config.accessLevel < 2) editable = false;

         CurrentObject.customDisplays(
            data,
            this.AB._App,
            $DataTable,
            displayRecords,
            editable
         );
      };

      $DataTable.attachEvent("onAfterRender", function (data) {
         $DataTable.resize();

         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);

         throttleCustomDisplay = setTimeout(() => {
            if (scrollStarted) clearTimeout(scrollStarted);
            customDisplays(this.data);
         }, 350);

         AB.ClassUI.CYPRESS_REF($DataTable);
         Object.keys(ids).forEach((key) => {
            const $el = $$(ids[key]);
            if ($el) {
               AB.ClassUI.CYPRESS_REF($el);
            }
         });
      });

      // we have some data types that have custom displays that don't look
      // right after scrolling large data sets we need to call customDisplays
      // again
      $DataTable.attachEvent("onScroll", function () {
         if (scrollStarted) clearTimeout(scrollStarted);

         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);

         scrollStarted = setTimeout(() => {
            customDisplays(this.data);
         }, 1500);
      });
      $DataTable.attachEvent("onAfterScroll", function () {
         if (throttleCustomDisplay) clearTimeout(throttleCustomDisplay);

         throttleCustomDisplay = setTimeout(() => {
            if (scrollStarted) clearTimeout(scrollStarted);
            customDisplays(this.data);
         }, 350);
      });

      // Process our onItemClick events.
      // this is a good place to check if our delete/trash icon was clicked.
      $DataTable.attachEvent("onItemClick", function (id, e, node) {
         // make sure we have an object selected before processing this.
         const dc = self.datacollection;
         const CurrentObject = dc?.datasource;

         if (!CurrentObject) return;

         if (settings.isEditable === 0) {
            const items = $DataTable.getItem(id);
         }
         // if this was our edit icon:
         // console.log(e.target.className);
         if (e === "auto" || e.target.className.indexOf("eye") > -1) {
            // View a Details Page:
            self.changePage(dc, id, settings.detailsPage);
            self.toggleTab(settings.detailsTab, this);
         } else if (e.target.className.indexOf("pencil") > -1) {
            self.changePage(dc, id, settings.editPage);
            self.toggleTab(settings.editTab, this);
         } else if (e.target.className.indexOf("track") > -1)
            self.emit("object.track", CurrentObject, id.row);
         // App.actions.openObjectTrack(CurrentObject, id.row);
         else if (e.target.className.indexOf("clear-combo-value") > -1) {
            const clearValue = {};

            clearValue[id.column] = "";

            const updateRow = async () => {
               try {
                  const response = await CurrentObject.model().update(
                     id.row,
                     clearValue
                  );

                  // console.log(response);
               } catch (err) {
                  self.AB.notify.developer(err, {
                     context: "ABViewGridComponent.onItemClick",
                     message: "Error updating item",
                     obj: CurrentObject.toObj(),
                     id: id.row,
                  });
               }
            };

            updateRow();
         }
         // if this was our trash icon:
         else if (e.target.className.indexOf("trash") > -1) {
            // If the confirm popup is showing, then skip to show a new one
            if (!this._deleteConfirmPopup) {
               this._deleteConfirmPopup = abWebix.confirm({
                  title: self.label("Delete data"),
                  text: self.label("Do you want to delete this row?"),
                  callback: (result) => {
                     delete this._deleteConfirmPopup;
                     if (result) {
                        const deleteRow = async () => {
                           try {
                              const response =
                                 await CurrentObject.model().delete(id.row);

                              if (response.numRows > 0) {
                                 $DataTable.remove(id);
                                 $DataTable.clearSelection();
                              } else
                                 abWebix.alert({
                                    text: self.label(
                                       "No rows were effected.  This does not seem right."
                                    ),
                                 });
                           } catch (err) {
                              self.AB.notify.developer(err, {
                                 context: "ABViewGridComponent.onItemClick",
                                 message: "Error deleting item",
                                 obj: CurrentObject.toObj(),
                                 id: id.row,
                              });

                              //// TODO: what do we do here?
                           }
                        };

                        deleteRow();
                     }

                     $DataTable.clearSelection();

                     return true;
                  },
               });
            }
         } else if (settings.detailsPage.length) {
            // If an icon wasn't selected but a details page is set
            // view the details page
            self.changePage(dc, id, settings.detailsPage);
            self.toggleTab(settings.detailsTab, this);
         } else if (settings.editPage.length) {
            // If an icon wasn't selected but an edit page is set
            // view the edit page
            self.changePage(dc, id, settings.editPage);
            self.toggleTab(settings.editTab, this);
         }
      });

      // ABViewGrid Original init();
      if (settings.showToolbar) {
         if (
            settings.massUpdate ||
            settings.isSortable ||
            settings.isExportable ||
            (settings.gridFilter &&
               settings.gridFilter.filterOption &&
               settings.gridFilter.userFilterPosition === "toolbar")
         )
            $$(ids.toolbar).show();

         if (!settings.massUpdate) {
            $$(ids.buttonMassUpdate).hide();
            $$(ids.buttonDeleteSelected).hide();
         }

         if (!settings.allowDelete) $$(ids.buttonDeleteSelected).hide();

         if (settings.gridFilter) {
            if (
               settings.gridFilter.filterOption !== 1 ||
               settings.gridFilter.userFilterPosition !== "toolbar"
            )
               $$(ids.buttonFilter).hide();

            if (
               settings.gridFilter.filterOption === 3 &&
               settings.gridFilter.globalFilterPosition === "single"
            )
               $DataTable.hide();

            if (settings.gridFilter.isGlobalToolbar)
               $$(ids.globalSearchToolbar).show();
            else $$(ids.globalSearchToolbar).hide();

            if (settings.gridFilter.filterOption)
               this.view.filterHelper.init(this.AB);
         }

         if (!settings.isSortable) $$(ids.buttonSort).hide();

         if (!settings.isExportable) $$(ids.buttonExport).hide();
      }

      if (settings.hideHeader) this.hideHeader();

      const dc =
         this.datacollection || this.AB.datacollectionByID(settings.dataviewID);

      if (!this._isDatacollectionLoaded) this.datacollectionLoad(dc);

      // Make sure
      this._gridSettings =
         this._gridSettings ||
         (await this.AB.Storage.get(this.keyStorageSettings)) ||
         {};

      if (dc?.datasource) {
         // TRANSITION: ABViewGrid_orig line 862 ...

         this.linkPage.init({
            view: this.view,
            datacollection: dc,
         });

         this.refreshHeader();
      }
   }

   /**
    * @method busy()
    * Indicate that our datatable is currently busy loading/processing
    * data.
    */
   busy() {
      this.getDataTable()?.showProgress?.({ type: "icon" });
   }

   /**
    * @method callbackFilterData()
    * Process the provided filter options from our filterHelper.
    * @param {fn} fnFilter
    *        A function that returns true/false for each row of data
    *        to determine if is should exist.
    * @param {array} filterRules
    *        Any Filter Rules added by the user.
    */
   callbackFilterData(fnFilter, filterRules = []) {
      const ids = this.ids;
      const $ButtonFilter = $$(ids.buttonFilter);

      if ($ButtonFilter) {
         const onlyFilterRules = this.view.filterHelper.filterRules();

         $ButtonFilter.define("badge", onlyFilterRules?.rules?.length ?? 0);
         $ButtonFilter.refresh();
      }

      const dc = this.datacollection;

      dc.filterCondition(filterRules);
      dc.reloadData();
   }

   async callbackSortData(sortRules = []) {
      const $buttonSort = $$(this.ids.buttonSort);

      $buttonSort.define("badge", sortRules.length || null);
      $buttonSort.refresh();

      const gridElem = this.getDataTable();

      if (gridElem.data.find({}).length < gridElem.data.count()) {
         try {
            // NOTE: Webix's client sorting does not support dynamic loading.
            // If the data does not be loaded, then load all data.
            await this.datacollection.reloadData(0, 0);
         } catch (err) {
            this.AB.notify.developer(err, {
               context:
                  "ABViewGrid:callbackSortData(): Error perform datacollection.reloadData()",
            });
         }
      }

      // wait until the grid component will done to repaint UI
      setTimeout(() => {
         gridElem.sort((a, b) => this.PopupSortDataTableComponent.sort(a, b));
      }, 777);
   }

   /**
    * @method changePage()
    * Helper method to switch to another View.
    * @param {ABDataCollection} dv
    *        The DataCollection we are working with.
    * @param {obj} rowItem
    *        the { row:#, column:{string} } of the item that was clicked.
    * @param {ABViewPage.uuid} page
    *        The .uuid of the ABViewPage/ABViewTab we are to swtich to.
    *
    */
   changePage(dv, rowItem, page) {
      const rowId = rowItem?.row ?? null;

      // Set cursor to data view
      if (dv) dv.setCursor(rowId);

      // Pass settings to link page module
      if (this.linkPage) this.linkPage.changePage(page, rowId);
      else super.changePage(page);
   }

   columnConfig(headers = []) {
      this.settings.columnConfig = headers;
   }
   /**
    * @method datacollectionLoad()
    * Assign an ABDataCollection to this component to use instead of any
    * provided .dataviewID in our settings.
    * NOTE: this primarily happens in the ABDesigner's Object Workspace.
    * @param {ABDataCollection} dc
    */
   datacollectionLoad(dc) {
      const oldDC = this.datacollection;
      this.datacollection = dc;

      const CurrentObject = dc?.datasource;
      const $DataTable = this.getDataTable();

      if ($DataTable) {
         // preventing too many handlers
         if (!this.__handler_dc_busy) {
            this.__handler_dc_busy = () => {
               this.busy();
            };

            this.__handler_dc_ready = () => {
               this.ready();
               this.populateGroupData();
            };

            this.__handler_dc_loadData = () => {
               this.populateGroupData();
            };
         }

         if (oldDC) {
            // remove our listeners from the previous DC
            oldDC.removeListener("initializingData", this.__handler_dc_busy);
            oldDC.removeListener("initializedData", this.__handler_dc_ready);
            oldDC.removeListener("loadData", this.__handler_dc_loadData);
         }

         if (dc) {
            if (dc.datacollectionLink && dc.fieldLink)
               dc.bind($DataTable, dc.datacollectionLink, dc.fieldLink);
            else dc.bind($DataTable);

            // making sure we only have 1 registered listener on this dc
            dc.removeListener("initializingData", this.__handler_dc_busy);
            dc.on("initializingData", this.__handler_dc_busy);
            dc.removeListener("initializedData", this.__handler_dc_ready);
            dc.on("initializedData", this.__handler_dc_ready);
            dc.removeListener("loadData", this.__handler_dc_loadData);
            dc.on("loadData", this.__handler_dc_loadData);
            this.grouping();

            this._isDatacollectionLoad = true;
         } else $DataTable.unbind();

         // Be sure to pass on our CurrentObject to our dependent components.
         if (CurrentObject) {
            this.view.filterHelper.objectLoad(CurrentObject);
            this.PopupMassUpdateComponent.objectLoad(
               CurrentObject,
               this.getDataTable()
            );
            this.PopupSortDataTableComponent.objectLoad(CurrentObject);

            this.PopupExport.objectLoad(CurrentObject);
            this.PopupExport.dataCollectionLoad(dc);
            this.PopupExport.setGridComponent(this.getDataTable());
            this.PopupExport.setHiddenFields(this.settings.hiddenFields);
            this.PopupExport.setFilename(this.view.label);
         }
      }
   }

   /**
    * @function enableUpdateDelete
    *
    * disable the update or delete buttons in the toolbar if there no items selected
    * we will make this externally accessible so we can call it from within the datatable component
    */
   disableUpdateDelete() {
      $$(this.ids.buttonMassUpdate)?.disable();
      $$(this.ids.buttonDeleteSelected)?.disable();
      // externally indicate that no rows are selected
      this.emit("selection.cleared");
   }

   /**
    * @function enableUpdateDelete
    *
    * enable the update or delete buttons in the toolbar if there are any items selected
    * we will make this externally accessible so we can call it from within the datatable component
    */
   enableUpdateDelete() {
      $$(this.ids.buttonMassUpdate)?.enable();
      $$(this.ids.buttonDeleteSelected)?.enable();
      // externally indicate that a row has been selected
      this.emit("selection");
   }

   freezeDeleteColumn() {
      // we are going to always freeze the delete column if the datatable
      // is wider than the container so it is easy to get to
      return this.getDataTable().define("rightSplit", this.columnSplitRight);
   }

   /**
    * @method getDataTable()
    * return the webix grid component.
    * @return {webix.grid}
    */
   getDataTable() {
      return $$(this.ids.datatable);
   }

   /**
    * @method getLastColumn
    * return the last column of a datagrid that is resizeable
    */
   getLastColumn() {
      const $DataTable = this.getDataTable();

      let lastColumn = {};

      // Loop through each columns config to find out if it is in the split 1 region and set it as the last item...then it will be overwritten by next in line
      $DataTable.eachColumn((columnId) => {
         const columnConfig = $DataTable.getColumnConfig(columnId);

         if (columnConfig.split === 1) lastColumn = columnConfig;
      });

      return lastColumn;
   }

   /**
    * @method grouping()
    * perform any grouping operations
    */
   grouping() {
      if (!this.settings.groupBy) return;

      const $treetable = this.getDataTable();

      // map: {
      //     votes:["votes", "sum"],
      //     title:["year"]
      // }
      const baseGroupMap = {};
      const CurrentObject = this.datacollection.datasource;

      CurrentObject.fields().forEach((f) => {
         switch (f.key) {
            case "number":
               baseGroupMap[f.columnName] = [f.columnName, "sum"];

               break;

            case "calculate":
            case "formula":
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  (prop, listData) => {
                     if (!listData) return 0;

                     let sum = 0;

                     listData.forEach((r) => {
                        // we only want numbers returned so pass `true` as third param
                        // to signify that this is part of a grouping row
                        sum += f.format(r, false, true) * 1;
                     });

                     // simulate reformat from ABFieldFormulaCore
                     if (!f.fieldLink || f.fieldLink.key === "calculate")
                        return sum;
                     else {
                        const rowDataFormat = {};

                        rowDataFormat[f.fieldLink.columnName] = sum;

                        return f.fieldLink.format(rowDataFormat);
                     }
                  },
               ];

               break;

            case "connectObject":
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  (prop, listData) => {
                     if (!listData || !listData.length) return 0;

                     let count = 0;

                     listData.forEach((r) => {
                        const valRelation = r[f.relationName()];

                        // array
                        if (valRelation?.length) count += valRelation.length;
                        // object
                        else if (valRelation) count += 1;
                     });

                     return count;
                  },
               ];

               break;

            default:
               baseGroupMap[f.columnName] = [
                  f.columnName,
                  function (prop, listData) {
                     if (!listData || !listData.length) return 0;

                     let count = 0;

                     listData.forEach((r) => {
                        const val = prop(r);

                        // count only exists data
                        if (val) count += 1;
                     });

                     return count;
                  },
               ];

               break;
         }
      });

      // set group definition
      // $DataTable.define("scheme", {
      //    $group: {
      //       by: settings.groupBy,
      //       map: groupMap
      //    }
      // });

      // NOTE: https://snippet.webix.com/e3a2bf60
      let groupBys = (this.settings.groupBy || "")
         .split(",")
         .map((g) => g.trim());
      // Reverse the array NOTE: call .group from child to root
      groupBys = groupBys.reverse();

      groupBys.forEach((colName, gIndex) => {
         const groupMap = this.AB.cloneDeep(baseGroupMap);

         let by;

         // Root
         if (gIndex === groupBys.length - 1) by = colName;
         // Sub groups
         else {
            by = (row) => {
               let byValue = row[colName];

               for (let i = gIndex + 1; i < groupBys.length; i++) {
                  byValue = `${row[groupBys[i]]} - ${byValue}`;
               }

               return byValue;
            };

            // remove parent group data
            groupBys.forEach((gColName) => {
               if (gColName !== colName) groupMap[gColName] = [gColName];
            });
         }

         $treetable.data.group({
            by: by,
            map: groupMap,
         });
      });
   }

   hideHeader() {
      const $DataTable = this.getDataTable();

      $DataTable.define("header", false);
      $DataTable.refresh();
   }

   /**
    * @function onAfterColumnDrop
    * When an editor drops a column to save a new column order
    * @param {string} sourceId
    *        the columnName of the item dragged
    * @param {string} targetId
    *        the columnName of the item dropped on
    * @param {event} event
    */
   async onAfterColumnDrop(sourceId, targetId, event) {
      const $DataTable = this.getDataTable();
      const CurrentObject = this.datacollection.datasource;
      const settings = this.settings;
      const columnConfig = this.localSettings();

      // Reorder our current columnConfig
      // We know what was moved and what item it has replaced/pushed forward
      // so first we want to splice the item moved out of the array of fields
      // and store it so we can put it somewhere else
      let itemMoved = null;
      let oPos = 0; // original position

      for (let i = 0; i < columnConfig.length; i++)
         if (columnConfig[i].id == sourceId) {
            itemMoved = columnConfig[i];
            columnConfig.splice(i, 1);
            oPos = i;

            break;
         }
      // once we have removed/stored it we can find where its new position
      // will be by looping back through the array and finding the item it
      // is going to push forward
      for (let j = 0; j < columnConfig.length; j++)
         if (columnConfig[j].id == targetId) {
            // if the original position was before the new position we will
            // follow webix's logic that the drop should go after the item
            // it was placed on
            if (oPos <= j) j++;

            columnConfig.splice(j, 0, itemMoved);

            break;
         }

      // special case: dropped on end and need to update .fillspace
      // if (j == columnConfig.length - 1) {
      //    if (columnConfig[j - 1].fillspace) {
      //       columnConfig[j - 1].fillspace = false;
      //       columnConfig[j].fillspace = true;
      //    }
      // }

      // if we allow local changes
      this.localSettings(columnConfig);

      if (settings.saveLocal) this.localSettingsSave();

      // Now emit this event, in case an external object is wanting to
      // respond to this: ABDesigner.objectBuilder, Interface  Designer,
      // we send back an array[ ABField.id, ...] in the order we have
      // them.
      this.emit(
         "column.order",
         columnConfig.map((c) => c.fieldID)
      );

      this.refreshHeader();

      // CurrentObject.fieldReorder(sourceId, targetId)
      //    .then(() => {
      //       // reset each column after a drop so we do not have multiple fillspace and minWidth settings
      //       var editiable = settings.isEditable;
      //       if ($DataTable.config.accessLevel < 2) {
      //          editiable = false;
      //       }
      //       var columnHeaders = CurrentObject.columnHeaders(true, editiable);
      //       columnHeaders.forEach(function (col) {
      //          if (col.id == sourceId && col.fillspace == true) {
      //             columnHeader.fillspace = false;
      //             columnHeader.minWidth = columnHeader.width;
      //          }
      //       });

      //       _logic.callbacks.onColumnOrderChange(CurrentObject);
      //       // freeze columns:
      //       let frozenColumnID =
      //          settings.frozenColumnID != null
      //             ? settings.frozenColumnID
      //             : CurrentObject.workspaceFrozenColumnID;
      //       if (frozenColumnID != "") {
      //          $DataTable.define(
      //             "leftSplit",
      //             $DataTable.getColumnIndex(frozenColumnID) + columnSplitLeft
      //          );
      //       } else {
      //          $DataTable.define("leftSplit", columnSplitLeft);
      //       }
      //       _logic.freezeDeleteColumn();
      //       $DataTable.refreshColumns();
      //    })
      //    .catch((err) => {
      //       OP.Error.log("Error saving new column order:", {
      //          error: err,
      //       });
      //    });
   }

   /**
    * @function onAfterEditStop
    * When an editor is finished.
    * @param {json} state
    * @param {} editor
    * @param {} ignoreUpdate
    * @return
    */
   async onAfterEditStop(state, editor, ignoreUpdate) {
      // state:   {value: "new value", old: "old value"}
      // editor:  { column:"columnName", row:ID, value:'value', getInputNode:fn(), config:{}, focus: fn(), getValue: fn(), setValue: function, getInputNode: function, render: function…}

      const $DataTable = this.getDataTable();

      // if you don't edit an empty cell we just need to move on
      if (
         (!state.old && state.value === "") ||
         (state.old === "" && state.value === "")
      ) {
         $DataTable.clearSelection();

         return false;
      }

      if (editor.config)
         switch (editor.config.editor) {
            case "number":
               state.value = parseFloat(state.value);

               break;

            case "datetime":
               state.value = state.value.getTime();

               if (state && state.old && state.old.getTime)
                  state.old = state.old.getTime();

               break;

            default:
            // code block
         }

      if (state.value !== state.old) {
         const item = $DataTable?.getItem(editor.row);

         item[editor.column] = state.value;

         $DataTable.removeCellCss(item.id, editor.column, "webix_invalid");
         $DataTable.removeCellCss(item.id, editor.column, "webix_invalid_cell");

         const CurrentObject = this.datacollection.datasource;
         const validator = CurrentObject.isValidData(item);

         if (validator.pass()) {
            //// Question: do we submit full item updates?  or just patches?
            // IF Patch:
            // var patch = {};
            // patch.id = item.id;
            // patch[editor.column] = item[editor.column];
            // await CurrentObject.model().update(item.id, patch)

            const ab = this.AB;

            try {
               await CurrentObject.model().update(item.id, item);

               if ($DataTable.exists(editor.row)) {
                  $DataTable.updateItem(editor.row, item);
                  $DataTable.clearSelection();
                  $DataTable.refresh(editor.row);
               }
            } catch (err) {
               ab.notify.developer(err, {
                  context: "ABViewGrid:onAfterEditStop(): Error saving item",
                  item,
                  editor,
                  state,
                  object: CurrentObject.toObj(),
               });

               $DataTable.clearSelection();

               if (
                  ab.Validation.isGridValidationError(
                     err,
                     editor.row,
                     $DataTable
                  )
               ) {
                  // Do we reset the value?
                  // item[editor.column] = state.old;
                  // $DataTable.updateItem(editor.row, item);
               } else {
                  // this was some other Error!
               }
            }
            // CurrentObject.model()
            //    .update(item.id, item)
            //    .then(() => {
            //       if ($DataTable.exists(editor.row)) {
            //          $DataTable.updateItem(editor.row, item);
            //          $DataTable.clearSelection();
            //          $DataTable.refresh(editor.row);
            //       }
            //    })
            //    .catch((err) => {
            //       OP.Error.log("Error saving item:", {
            //          error: err
            //       });

            //       $DataTable.clearSelection();
            //       if (
            //          OP.Validation.isGridValidationError(
            //             err,
            //             editor.row,
            //             $DataTable
            //          )
            //       ) {
            //          // Do we reset the value?
            //          // item[editor.column] = state.old;
            //          // $DataTable.updateItem(editor.row, item);
            //       } else {
            //          // this was some other Error!
            //       }
            //    });
         } else validator.updateGrid(editor.row, $DataTable);
      } else $DataTable.clearSelection();

      return false;

      // var item = $$(self.webixUiId.objectDatatable).getItem(editor.row);

      // self.updateRowData(state, editor, ignoreUpdate)
      //    .fail(function (err) { // Cached
      //       item[editor.column] = state.old;
      //       $$(self.webixUiId.objectDatatable).updateItem(editor.row, item);
      //       $$(self.webixUiId.objectDatatable).refresh(editor.row);

      //       // TODO : Message

      //       $$(self.webixUiId.objectDatatable).hideProgress();
      //    })
      //    .then(function (result) {
      //       if (item) {
      //          item[editor.column] = state.value;

      //          if (result && result.constructor.name === 'Cached' && result.isUnsync())
      //             item.isUnsync = true;

      //          $$(self.webixUiId.objectDatatable).updateItem(editor.row, item);
      //       }

      //       // TODO : Message

      //       $$(self.webixUiId.objectDatatable).hideProgress();
      //    });
   }

   /**
    * @function onAfterSelect
    * This is when a user clicks on a cell.  We use the onAfterSelect to
    * trigger a normal .editCell() if there isn't a custom editor for this field.
    * @param {json} data webix cell data
    * @return
    */
   onAfterSelect(data /*, preserve */) {
      // data: {row: 1, column: "name", id: "1_name", toString: function}
      // data.row: ABObject.id
      // data.column => columnName of the field

      // Normal update data
      this.getDataTable()?.editCell(data.row, data.column);
   }

   /**
    * @function onColumnResizeResize
    * This is when a user adjusts the size of a column
    * @param {} columnName
    * @param {int} newWidth
    * @param {int} oldWidth
    * @param {} user_action
    * @return
    */
   async onColumnResize(columnName, newWidth, oldWidth, user_action) {
      // update the settings

      let requireRefresh = false;

      const ab = this.AB;

      if (newWidth < 30) {
         newWidth = 30;
         requireRefresh = true;

         ab.Webix.message({
            type: "info",
            text: this.label("minimum column width is {0}", [30]),
            expire: 1000,
         });
      }

      const localSettings = this.localSettings();

      if (localSettings) {
         const header = localSettings.find((h) => h.id == columnName);

         if (header) {
            header.width = newWidth;

            delete header.adjust;
         }
      }

      this.localSettings(localSettings);

      if (this.settings.saveLocal) {
         await this.localSettingsSave();
         // for (const item in GridSettings) {
         //    GridSettings[item].forEach((item) => {
         //       // we cannot include field info because of the cicular structure
         //       if (item?.footer?.field) {
         //          delete item.footer.field;
         //       }
         //    });
         // }
         // await this.AB.Storage.set(this.keyStorageSettings, GridSettings);
      }

      // refresh the display
      if (requireRefresh) this.refreshHeader();

      this.freezeDeleteColumn();

      // this.getDataTable().refreshColumns();

      // TODO: allow external app to respond in special cases:
      // eg: ABDesigner object workspace, interface builder, etc...
      this.emit("column.resize", columnName, newWidth, oldWidth);
   }

   /**
    * @method onHeaderClick
    * process the user clicking on the header for one of our columns.
    */
   onHeaderClick(id, e, node) {
      if (this.skippableColumns.indexOf(id.column) !== -1) return false;

      // save our EditNode & EditField:
      // this.EditNode = node;

      const EditField = this.datacollection.datasource.fields(
         (f) => f.columnName === id.column
      )[0];
      // if (this.EditField) {
      //    // show the popup
      //    PopupHeaderEditComponent.show(node, this.EditField);
      // }

      this.emit("column.header.clicked", node, EditField);

      return false;
   }

   /**
    * @method onShow()
    * perform any preparations necessary when showing this component.
    */
   onShow() {
      super.onShow();

      // make sure our grid is properly .adjust()ed to the screen.
      this.getDataTable()?.adjust();

      const dv = this.datacollection;

      if (dv)
         ["changeCursor", "cursorStale", "cursorSelect"].forEach((key) => {
            this.eventAdd({
               emitter: dv,
               eventName: key,
               listener: this.handler_select.bind(this),
            });
         });
   }

   /**
    * @method ready()
    * Indicate that our datatable is currently ready for operation.
    */
   ready() {
      const dc = this.datacollection;
      if (
         this.isCustomGroup &&
         dc?.dataStatus != dc?.dataStatusFlag.initialized
      )
         return;

      this.getDataTable()?.hideProgress?.();
   }

   /**
    * @function refreshHeader()
    *
    * refresh the header for the table apart from the refresh() command
    * @param {bool} ignoreLocal
    *        Should we ignore our local settings and build directly from
    *        our config settings?
    */
   refreshHeader(ignoreLocal = this.ignoreLocal) {
      // columnSplitRight = 0;
      // wait until we have an Object defined:
      const CurrentObject = this.datacollection.datasource;

      if (!CurrentObject) return;

      const ids = this.ids;
      const $DataTable = $$(ids.datatable);

      if (!$DataTable) return;

      const accessLevel = $DataTable.config.accessLevel;

      $DataTable.define("leftSplit", 0);
      $DataTable.define("rightSplit", 0);

      let rowHeight = 0;

      CurrentObject.imageFields().forEach((image) => {
         const settings = image.getSettings();

         if (settings.useHeight && settings.imageHeight > rowHeight)
            rowHeight = settings.imageHeight;
      });

      if (rowHeight) $DataTable.define("rowHeight", rowHeight);

      // $DataTable.clearAll();

      const settings = this.settings;

      let editable = settings.isEditable;

      if ($DataTable.config.accessLevel < 2) editable = false;

      //// update DataTable structure:
      // get column list from our local settings
      const objColumnHeaders = CurrentObject.columnHeaders(
         true,
         editable,
         // TRANSITION: moving these from .columnHeaders() to here:
         [], //settings.summaryColumns,
         [], //settings.countColumns,
         [] //settings.hiddenFields
      );

      let columnHeaders = this.localSettings();

      const ab = this.AB;

      // if that is empty, pull from our settings.columnConfig
      if (!columnHeaders || ignoreLocal)
         columnHeaders = ab.cloneDeep(this.settings.columnConfig);

      // if that is empty for some reason, rebuild from our CurrentObject
      if (columnHeaders.length === 0) columnHeaders = objColumnHeaders;

      // sanity check:
      // columnHeaders can't contain a column that doesn't exist in objColumHeaders:
      // (eg: a field might have been removed but localStorage doesn't know that )
      const objColumnHeaderIDs = objColumnHeaders.map((h) => h.fieldID);

      columnHeaders = columnHeaders.filter(
         (c) => objColumnHeaderIDs.indexOf(c.fieldID) > -1
      );

      // default our columnConfig values to our columnHeaders:
      columnHeaders.forEach((c) => {
         // we want to overwrite our default settings with anything stored
         // in local storage
         const origCol = objColumnHeaders.find((h) => h.fieldID === c.fieldID);

         // none of our functions can be stored in localStorage, so scan
         // the original column and attach any template functions to our
         // stashed copy.
         // also the suggest for selects and connected fields may contain a
         // function so go ahead and copy the original suggest to the column
         Object.keys(origCol).forEach((k) => {
            if (typeof origCol[k] === "function" || k === "suggest") {
               c[k] = origCol[k];
            }
         });

         const f = CurrentObject.fieldByID(c.fieldID);

         if (!f) return;

         // if it's a hidden field:
         if (settings.hiddenFields.indexOf(f.columnName) > -1) {
            c.hidden = true;
         }

         // add summary footer:
         if (settings.summaryColumns.indexOf(f.id) > -1) {
            if (f.key == "calculate" || f.key == "formula")
               c.footer = { content: "totalColumn", field: f };
            else c.footer = { content: "summColumn" };
         }
         // or add the count footer
         else if (settings.countColumns.indexOf(f.id) > -1)
            c.footer = { content: "countColumn" };
      });

      let localSettings = this.localSettings();

      if (!localSettings || ignoreLocal) {
         this.localSettings(columnHeaders);

         localSettings = columnHeaders;
      }

      columnHeaders = ab.cloneDeep(localSettings);

      const fieldValidations = [];
      const rulePops = [];

      columnHeaders.forEach((col) => {
         col.fillspace = false;

         // parse the rules because they were stored as a string
         // check if rules are still a string...if so lets parse them
         if (col.validationRules) {
            if (typeof col.validationRules === "string") {
               col.validationRules = JSON.parse(col.validationRules);
            }

            if (col.validationRules.length) {
               const validationUI = [];

               // there could be more than one so lets loop through and build the UI
               col.validationRules.forEach((rule) => {
                  const Filter = ab.filterComplexNew(
                     col.id /*+ "_" + webix.uid()*/
                  );
                  // add the new ui to an array so we can add them all at the same time
                  validationUI.push(Filter.ui);
                  // store the filter's info so we can assign values and settings after the ui is rendered
                  fieldValidations.push({
                     filter: Filter,
                     view: Filter.ids.querybuilder,
                     columnName: col.id,
                     validationRules: rule.rules,
                     invalidMessage: rule.invalidMessage,
                  });
               });

               // create a unique view id for popup
               const popUpId =
                  ids.rules + "_" + col.id; /* + "_" + webix.uid() */

               // store the popup ids so we can remove the later
               rulePops.push(popUpId);
               // add the popup to the UI but don't show it
               ab.Webix.ui({
                  view: "popup",
                  css: "ab-rules-popup",
                  id: popUpId,
                  body: {
                     rows: validationUI,
                  },
               });
            }
         }

         // group header
         if (
            settings.groupBy &&
            (settings.groupBy || "").indexOf(col.id) > -1
         ) {
            const groupField = CurrentObject.fieldByID(col.fieldID);

            if (groupField)
               col.template = (obj, common) => {
                  // return common.treetable(obj, common) + obj.value;
                  if (obj.$group) {
                     const rowData = ab.cloneDeep(obj);

                     rowData[groupField.columnName] = rowData.value;

                     return (
                        common.treetable(obj, common) +
                        groupField.format(rowData)
                     );
                  } else return groupField.format(obj);
               };
         }
      });

      if (fieldValidations.length) {
         // we need to store the rules for use later so lets build a container array
         const complexValidations = [];

         fieldValidations.forEach((f) => {
            // init each ui to have the properties (app and fields) of the object we are editing
            // f.filter.applicationLoad(CurrentObject.application);
            f.filter.fieldsLoad(CurrentObject.fields());
            // now we can set the value because the fields are properly initialized
            f.filter.setValue(f.validationRules);
            // if there are validation rules present we need to store them in a lookup hash
            // so multiple rules can be stored on a single field
            if (!Array.isArray(complexValidations[f.columnName]))
               complexValidations[f.columnName] = [];

            // now we can push the rules into the hash
            complexValidations[f.columnName].push({
               filters: $$(f.view).getFilterHelper(),
               values: $DataTable.getSelectedItem(),
               invalidMessage: f.invalidMessage,
            });
         });

         const rules = {};

         // store the rules in a data param to be used later
         $DataTable.$view.complexValidations = complexValidations;
         // use the lookup to build the validation rules
         Object.keys(complexValidations).forEach((key) => {
            rules[key] = (value, data) => {
               // default valid is true
               let isValid = true;
               let invalidMessage = "";

               $DataTable.$view.complexValidations[key].forEach((filter) => {
                  // convert rowData from { colName : data } to { id : data }
                  const newData = {};

                  (CurrentObject.fields() || []).forEach((field) => {
                     newData[field.id] = data[field.columnName];
                  });

                  // for the case of "this_object" conditions:
                  if (data.uuid) newData["this_object"] = data.uuid;

                  // use helper funtion to check if valid
                  const ruleValid = filter.filters(newData);

                  // if invalid we need to tell the field
                  if (!ruleValid) {
                     isValid = false;
                     invalidMessage = filter.invalidMessage;
                  }
               });

               // we also need to define an error message
               if (!isValid)
                  ab.Webix.message({
                     type: "error",
                     text: invalidMessage,
                  });

               return isValid;
            };
         });
         // define validation rules
         $DataTable.define("rules", rules);
         // store the array of view ids on the webix object so we can get it later
         $DataTable.config.rulePops = rulePops;
         $DataTable.refresh();
      } else {
         // check if the previous datatable had rule popups and remove them
         if ($DataTable.config.rulePops)
            $DataTable.config.rulePops.forEach((popup) => {
               if ($$(popup)) $$(popup).destructor();
            });
         // remove any validation rules from the previous table
         $DataTable.define("rules", {});
         $DataTable.refresh();
      }

      const addedColumns = [];
      // {array} the .id of the columnHeaders we add based upon our settings.
      // this will help us pick the lastColumn that is part of the
      // object.

      if (settings.labelAsField) {
         // console.log(CurrentObject);
         columnHeaders.unshift({
            id: "appbuilder_label_field",
            header: "Label",
            fillspace: true,
            template: (obj) => CurrentObject.displayData(obj),
            // css: { 'text-align': 'center' }
         });
         addedColumns.push("appbuilder_label_field");
      }

      if (settings.massUpdate && accessLevel === 2) {
         columnHeaders.unshift({
            id: "appbuilder_select_item",
            header: { content: "masterCheckbox", contentId: "mch" },
            width: 40,
            template: "<div class='singleSelect'>{common.checkbox()}</div>",
            css: { "text-align": "center" },
         });
         this.columnSplitLeft = 1;
         addedColumns.push("appbuilder_select_item");
      } else this.columnSplitLeft = 0;

      if (settings.detailsPage !== "" && !settings.hideButtons) {
         columnHeaders.push({
            id: "appbuilder_view_detail",
            header: "",
            width: 40,
            template: (obj, common) =>
               "<div class='detailsView'><span class='webix_icon fa fa-eye'></span></div>",
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_detail");
      }

      if (settings.trackView !== 0 && accessLevel === 2) {
         columnHeaders.push({
            id: "appbuilder_view_track",
            header: "",
            width: 40,
            template:
               "<div class='track'><span class='track fa fa-history'></span></div>",
            css: { "text-align": "center", cursor: "pointer" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_track");
      }

      if (
         settings.editPage !== "" &&
         !settings.hideButtons &&
         accessLevel === 2
      ) {
         columnHeaders.push({
            id: "appbuilder_view_edit",
            header: "",
            width: 40,
            template: "<div class='edit'>{common.editIcon()}</div>",
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_view_edit");
      }

      if (settings.allowDelete && accessLevel === 2) {
         columnHeaders.push({
            id: "appbuilder_trash",
            header: "",
            width: 40,
            template: "<div class='trash'>{common.trashIcon()}</div>",
            css: { "text-align": "center" },
         });
         // columnSplitRight++;
         addedColumns.push("appbuilder_trash");
      }

      // find our last displayed column (that isn't one we added);
      let lastCol = null;

      for (let i = columnHeaders.length - 1; i >= 0; i--) {
         const col = columnHeaders[i];
         if (!col.hidden && addedColumns.indexOf(col.id) === -1) {
            lastCol = col;
            break;
         }
      }

      if (lastCol) {
         lastCol.fillspace = true;
         lastCol.minWidth = lastCol.width;
         lastCol.width = 150; // set a width for last column but by default it will fill the available space or use the minWidth to take up more
      }

      $DataTable.refreshColumns(columnHeaders);

      // the addedColumns represent the additional icons that can be added.
      this.columnSplitRight = addedColumns.length;

      // the .massUpdate gets added to Left so don't include that in split right:
      if (addedColumns.indexOf("appbuilder_select_item") > -1)
         this.columnSplitRight -= 1;
      // .columnSplitRight can't be < 0
      if (this.columnSplitRight < 0) this.columnSplitRight = 0;

      // freeze columns:
      const frozenColumnID = settings.frozenColumnID;

      if (frozenColumnID != "")
         $DataTable.define(
            "leftSplit",
            $DataTable.getColumnIndex(frozenColumnID) + 1
         );
      else $DataTable.define("leftSplit", this.columnSplitLeft);

      this.freezeDeleteColumn();
      $DataTable.refreshColumns();
      // }
   }

   /**
    * localSettingsSave()
    * Persist our current working copy of our GridSettings to localStorage.
    * @return {Promise}
    */
   async localSettingsSave() {
      const ab = this.AB;
      const savedLocalSettings =
         (await ab.Storage.get(this.keyStorageSettings)) || {};
      const _gridSettings = this._gridSettings;

      savedLocalSettings[this.settingsID()] = _gridSettings[this.settingsID()]
         ? _gridSettings[this.settingsID()]
         : [];

      for (const item in savedLocalSettings) {
         savedLocalSettings[item].forEach((item) => {
            // we cannot include field info because of the cicular structure
            if (item?.footer?.field) delete item.footer.field;
         });
      }

      await ab.Storage.set(this.keyStorageSettings, savedLocalSettings);
   }

   /**
    * @method localSettings()
    * An interface method to handle get/set operations on our local GridSettings
    * storage.
    * .localStorage() : a getter to return the current value
    * .localStorage(value) : a setter to save value as our current value.
    * @param {various} value
    *        the value to set to our settings.
    * @return {various}
    */
   localSettings(value = null) {
      const _gridSettings = this._gridSettings;

      if (value) _gridSettings[this.settingsID()] = value;
      else return _gridSettings[this.settingsID()];
   }

   /**
    * @method selectRow()
    * Select the grid row that correspondes to the provided rowData.
    * @param {json} rowData
    *        A key=>value hash of data that matches an entry in the grid.
    *        rowData.id should match an existing entry.
    */
   selectRow(rowData) {
      let id = rowData?.id ?? rowData;
      if (this.__timeout_selectRow) {
         console.log("Duplicate selectRow():", id);
         clearTimeout(this.__timeout_selectRow);
      }
      this.__timeout_selectRow = setTimeout(() => {
         const $DataTable = this.getDataTable();
         if (!$DataTable) return;

         if (!id) $DataTable.unselect();
         else if ($DataTable.exists(id)) {
            $DataTable.select(id, false);
            $DataTable.showItem(id);
         } else $DataTable.select(null, false);

         this.__timeout_selectRow = null;
      }, 15);
   }

   /**
    * @method settingsID()
    * return the unique key for this Grid + object combo to store data
    * in our localStorage.
    * @return {string}
    */
   settingsID() {
      const CurrentObject = this.datacollection.datasource;

      return `${this.id}-${CurrentObject ? CurrentObject.id : "0"}`;
   }

   /**
    * @method toggleTab()
    * recursively toggle tabs into view once a user chooses a detail/edit view
    * to display.
    * @param {ABView.id} parentTab
    * @param {webix.view} wb
    */
   toggleTab(parentTab, wb) {
      // find the tab || if we didn't pass and id we may have passed a domNode
      const tab =
         wb.getTopParentView().queryView({ id: parentTab }) || $$(parentTab);

      if (!tab) return;

      // set the tabbar to to the tab
      const tabbar = tab.getParentView().getParentView();

      if (!tabbar) return;

      // if we have reached the top we won't have a tab
      if (tabbar.setValue) tabbar.setValue(parentTab);

      // find if it is in a multiview of a tab
      const nextTab = tabbar.queryView({ view: "scrollview" }, "parent");

      // if so then do this again
      if (nextTab) this.toggleTab(nextTab, wb);
   }

   toggleUpdateDelete() {
      const $DataTable = this.getDataTable();

      let checkedItems = 0;

      $DataTable.data.each((obj) => {
         if (
            typeof obj !== "undefined" &&
            Object.prototype.hasOwnProperty.call(
               obj,
               "appbuilder_select_item"
            ) &&
            obj.appbuilder_select_item === 1
         )
            checkedItems++;
      });

      if (checkedItems > 0) this.enableUpdateDelete();
      else this.disableUpdateDelete();
   }

   toolbarDeleteSelected($view) {
      const $DataTable = this.getDataTable();
      const CurrentObject = this.datacollection.datasource;
      const deleteTasks = [];

      $DataTable.data.each((row) => {
         if (
            typeof row !== "undefined" &&
            // row.hasOwnProperty("appbuilder_select_item") &&
            Object.prototype.hasOwnProperty.call(
               row,
               "appbuilder_select_item"
            ) &&
            row.appbuilder_select_item === 1
         ) {
            // NOTE: store a fn() to run later.
            deleteTasks.push(() => CurrentObject.model().delete(row.id));
         }
      });

      const abWebix = this.AB.Webix;

      if (deleteTasks.length > 0)
         abWebix.confirm({
            title: this.label("Delete Multiple Records"),
            text: this.label(
               "Are you sure you want to delete the selected records?"
            ),
            callback: async (result) => {
               if (result) {
                  // Now run those functions
                  await Promise.all(deleteTasks.map((t) => t()));

                  // Anything we need to do after we are done.
                  this.disableUpdateDelete();
               }
            },
         });
      else
         abWebix.alert({
            title: this.label("No Records Selected"),
            text: this.label(
               "You need to select at least one record...did you drink your coffee today?"
            ),
         });
   }

   toolbarFilter($view) {
      this.view.filterHelper.showPopup($view);
   }

   toolbarSort($view) {
      this.PopupSortDataTableComponent.show($view);
   }

   toolbarExport($view) {
      this.PopupExport.show($view);
   }

   toolbarMassUpdate($view) {
      this.PopupMassUpdateComponent.show($view);
   }

   /**
    * @function toolTip()
    *
    * Retrieve the items toolTip
    */
   toolTip(obj, common) {
      const CurrentObject = this.datacollection.datasource;
      const imageFieldColNames = CurrentObject.imageFields().map(
         (f) => f.columnName
      );

      let tip = "";

      const columnName = common.column.id.replace(" ", "");

      if (Array.isArray(obj[columnName])) {
         obj[columnName].forEach(function (o) {
            if (o.text) tip += o.text + "<br/>";
         });
      } else if (
         typeof obj[columnName + "__relation"] !== "undefined" &&
         typeof obj[columnName] === "number"
      )
         tip = obj[columnName + "__relation"].text;
      else if (typeof obj[columnName + "__relation"] !== "undefined") {
         let relationData = obj[columnName + "__relation"];

         if (!Array.isArray(relationData)) relationData = [relationData];

         (relationData || []).forEach(function (o) {
            if (o) tip += o.text + "<br/>";
         });
      } else if (imageFieldColNames.indexOf(columnName) !== -1) {
         if (!obj[columnName]) {
            return "";
         } else {
            // TODO: we need to get this URL from the ABFieldImage object!
            tip = `<img style='max-width: 500px; max-height: 500px;' src='/file/${obj[columnName]}' />`;
         }
      } else if (common.column.editor === "date")
         tip = common.column.format(obj[columnName]);
      else if (common.column.editor === "richselect")
         CurrentObject.fields().forEach((f) => {
            if (f.columnName === columnName) {
               if (f.settings.options) {
                  f.settings.options.forEach((o) => {
                     if (o.id === obj[columnName]) {
                        tip = o.text;
                     }
                  });
               }
            }
         });
      else tip = obj[columnName];

      if (!tip) return "";
      else return tip;
   }

   /**
    * @function toolTipOnBeforeRender()
    *
    * Add visibility "hidden" to all tooltips before render so we can move to a new location without the visual jump
    */
   toolTipOnBeforeRender(node) {
      // var node = $$(ids.tooltip).getNode();
      node.style.visibility = "hidden";
   }

   /**
    * @function toolTipOnAfterRender()
    *
    * If the tooltip is displaying off the screen we want to try to reposition it for a better experience
    */
   toolTipOnAfterRender(node) {
      // var node = $$(ids.tooltip).getNode();
      if (node.firstChild?.nodeName === "IMG") {
         setTimeout(() => {
            const imgBottom = parseInt(node.style.top.replace("px", "")) + 500;
            const imgRight = parseInt(node.style.left.replace("px", "")) + 500;

            if (imgBottom > window.innerHeight) {
               const imgOffsetY = imgBottom - window.innerHeight;
               const newTop =
                  parseInt(node.style.top.replace("px", "")) - imgOffsetY;
               node.style.top = newTop + "px";
            }

            if (imgRight > window.innerWidth) {
               const imgOffsetX = imgRight - window.innerWidth;
               const newLeft =
                  parseInt(node.style.left.replace("px", "")) - imgOffsetX;
               node.style.left = newLeft + "px";
            }

            node.style.visibility = "visible";
         }, 250);
      } else node.style.visibility = "visible";
   }

   get isCustomGroup() {
      const dc = this.datacollection;
      const CurrentObject = dc?.datasource;
      const $DataTable = this.getDataTable();

      return (
         $DataTable?.config?.view === "treetable" && !CurrentObject?.isGroup
      );
   }

   populateGroupData() {
      if (!this.isCustomGroup) return;

      this.busy();

      const dc = this.datacollection;
      const $DataTable = this.getDataTable();

      $DataTable.clearAll();
      $DataTable.parse(dc.getData() || []);

      this.grouping();
      this.ready();
   }
}


/***/ }),

/***/ 58942:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewImageComponent.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewImageComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewImage_${baseView.id}`,
         Object.assign({ image: "" }, ids)
      );
   }

   ui() {
      const settings = this.settings;
      const _ui = super.ui([
         {
            cols: [
               {
                  id: this.ids.image,
                  view: "template",
                  template: "",
                  height: settings.height,
                  width: settings.width,
               },
               {},
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const $image = $$(this.ids.image);
      if (!$image) return;

      const settings = this.settings;

      if (settings.filename)
         $image.define(
            "template",
            `<img src="/file/${settings.filename}" height="${settings.height}" width="${settings.width}">`
         );
      else $image.define("template", "");

      $image.refresh();
   }
};


/***/ }),

/***/ 3893:
/*!**************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewKanbanComponent.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);
const ABFormSidePanel = __webpack_require__(/*! ../ABViewKanbanFormSidePanel */ 47304);

module.exports = class ABViewKanbanComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewKanBan_${baseView.id}`,
         Object.assign(
            {
               kanbanView: "",

               kanban: "",
               resizer: "",
               formSidePanel: "",
            },
            ids
         )
      );

      this.FormSide = new ABFormSidePanel(
         this,
         this.ids.formSidePanel,
         this.settings.editFields
      );

      this.CurrentVerticalField = null;
      this.CurrentHorizontalField = null;
      this.CurrentOwnerField = null;

      this.TextTemplate = baseView.TextTemplate;

      this._updatingOwnerRowId = null;
      this._ABFieldConnect = null;
      this._ABFieldUser = null;
      this._ABFieldList = null;
   }

   get ABFieldConnect() {
      return (this._ABFieldConnect =
         this._ABFieldConnect ||
         this.AB.Class.ABFieldManager.fieldByKey("connectObject"));
   }

   get ABFieldUser() {
      return (this._ABFieldUser =
         this._ABFieldUser || this.AB.Class.ABFieldManager.fieldByKey("user"));
   }

   get ABFieldList() {
      return (this._ABFieldList =
         this._ABFieldList || this.AB.Class.ABFieldManager.fieldByKey("list"));
   }

   ui() {
      const ids = this.ids;
      const self = this;
      this.linkPage = this.view.linkPageHelper.component();

      const _ui = super.ui([
         {
            id: ids.kanbanView,
            cols: [
               {
                  id: ids.kanban,
                  view: "kanban",
                  cols: [],
                  userList: {
                     view: "menu",
                     // yCount: 8,
                     // scroll: false,
                     template: '<i class="fa fa-user"></i> #value#',
                     width: 150,
                     on: {
                        onSelectChange: function () {
                           // get this row id from onAvatarClick event
                           if (!self._updatingOwnerRowId) return;

                           const userId = this.getSelectedId(false);
                           if (!userId) return;

                           self.updateOwner(self._updatingOwnerRowId, userId);
                        },
                     },
                  },
                  editor: false, // we use side bar
                  users: [],
                  tags: [],
                  data: [],
                  on: {
                     onListAfterSelect: (itemId, list) => {
                        this.CurrentDatacollection?.setCursor(itemId);
                        this.emit("select", itemId);

                        // link pages events
                        const editPage = this.settings.editPage;
                        if (editPage)
                           this.linkPage.changePage(editPage, itemId);

                        const detailsPage = this.settings.detailsPage;
                        if (detailsPage)
                           this.linkPage.changePage(detailsPage, itemId);
                     },
                     onAfterStatusChange: (rowId, status /*, list */) => {
                        this.updateStatus(rowId, status);
                     },
                     onAvatarClick: (rowId /*, ev, node, list */) => {
                        // keep this row id for update owner data in .userList
                        this._updatingOwnerRowId = rowId;
                     },
                  },
               },
               {
                  id: ids.resizer,
                  view: "resizer",
                  css: "bg_gray",
                  width: 11,
                  hidden: true,
               },
               this.FormSide.ui(),
            ],
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const abWebix = this.AB.Webix;

      if (this.$kb) abWebix.extend(this.$kb, abWebix.ProgressBar);

      this.FormSide.init(AB);
      this.FormSide.on("add", (newVals) => {
         this.saveData(newVals);
      });
      this.FormSide.on("update", (updateVals) => {
         this.saveData(updateVals);
      });

      let dc = this.view.datacollection;
      if (dc) this.datacollectionLoad(dc);

      this.linkPage.init({
         view: this.view,
         datacollection: dc,
      });

      this.show();
   }

   get $kb() {
      return (this._kb = this._kb || $$(this.ids.kanban));
   }

   kanbanListTemplate() {
      return {
         icons: [
            // { icon: "mdi mdi-comment", show: function (obj) { return !!obj.comments }, template: "#comments.length#" },
            {
               icon: "fa fa-trash-o",
               click: (rowId /*, e */) => {
                  this.removeCard(rowId);
               },
            },
         ],
         // avatar template
         templateAvatar: (obj) => {
            if (
               this.CurrentOwnerField &&
               obj[this.CurrentOwnerField.columnName]
            )
               return this.CurrentOwnerField.format(obj);
            else return "<span class='webix_icon fa fa-user'></span>";
         },
         // template for item body
         // show item image and text
         templateBody: (data) => {
            // if (!this.settings.template)
            if (!this.TextTemplate.text)
               return this.CurrentObject?.displayData(data);

            // return our default text template
            return this.TextTemplate.displayText(data);
         },
      };
   }

   /**
    * @function hide()
    *
    * hide this component.
    */
   hide() {
      $$(this.ids.kanbanView)?.hide();
   }

   /**
    * @function show()
    * Show this component.
    */
   async show() {
      const ids = this.ids;

      $$(ids.kanbanView)?.show();

      this.FormSide.hide();

      $$(ids.resizer)?.hide();

      var CurrentObject = this.CurrentObject;
      if (!CurrentObject) {
         CurrentObject = this.datacollection?.datasource;
      }
      if (!CurrentObject) return;

      // Get vertical grouping field and populate to kanban list
      // NOTE: this field should be the select list type
      const CurrentVerticalField = CurrentObject.fieldByID(
         this.settings.verticalGroupingField
      );
      if (!CurrentVerticalField) return;

      this.CurrentVerticalField = CurrentVerticalField;

      let horizontalOptions = [];

      const CurrentHorizontalField = CurrentObject.fieldByID(
         this.settings.horizontalGroupingField
      );

      this.CurrentHorizontalField = CurrentHorizontalField;

      if (
         CurrentHorizontalField &&
         CurrentHorizontalField instanceof this.ABFieldConnect
      )
         // Pull horizontal options
         horizontalOptions = await CurrentHorizontalField.getOptions();

      // Option format -  { id: "1543563751920", text: "Normal", hex: "#4CAF50" }
      const verticalOptions = (CurrentVerticalField.settings.options || []).map(
         (opt) => {
            // Vertical & Horizontal fields
            if (CurrentVerticalField && CurrentHorizontalField) {
               let rows = [],
                  // [{
                  //    id: '',
                  //    text: ''
                  // }]
                  horizontalVals = [];

               // pull options of the Horizontal field
               if (CurrentHorizontalField instanceof this.ABFieldList) {
                  // make a copy of the settings.
                  horizontalVals = (
                     CurrentHorizontalField.settings.options || []
                  ).map((o) => o);
               } else if (CurrentHorizontalField instanceof this.ABFieldUser) {
                  horizontalVals = CurrentHorizontalField.getUsers().map(
                     (u) => {
                        return {
                           id: u.id,
                           text: u.text || u.value,
                        };
                     }
                  );
               } else if (CurrentHorizontalField instanceof this.ABFieldConnect)
                  horizontalVals = horizontalOptions.map(({ id, text }) => ({
                     id,
                     text,
                  }));

               horizontalVals.push({
                  id: null,
                  text: this.label("Other"),
               });

               horizontalVals.forEach((val) => {
                  const statusOps = {};

                  statusOps[CurrentVerticalField.columnName] = opt.id;
                  statusOps[CurrentHorizontalField.columnName] = val.id;

                  // Header
                  rows.push({
                     template: val.text,
                     height: 20,
                     css: "progress_header",
                  });

                  // Kanban list
                  rows.push({
                     view: "kanbanlist",
                     status: statusOps,
                     type: this.kanbanListTemplate(),
                  });
               });

               return {
                  header: opt.text,
                  body: {
                     margin: 0,
                     rows: rows,
                  },
               };
            }
            // Vertical field only
            else if (CurrentVerticalField) {
               const statusOps = {};

               statusOps[CurrentVerticalField.columnName] = opt.id;

               return {
                  header: opt.text,
                  body: {
                     view: "kanbanlist",
                     status: statusOps,
                     type: this.kanbanListTemplate(),
                  },
               };
            }
         }
      );

      const ab = this.AB;
      const abWebix = ab.Webix;

      // Rebuild kanban that contains options
      // NOTE: webix kanban does not support dynamic vertical list
      abWebix.ui(verticalOptions, $$(ids.kanban));
      $$(ids.kanban).reconstruct();

      // Owner field
      const CurrentOwnerField = CurrentObject.fieldByID(
         this.settings.ownerField
      );

      this.CurrentOwnerField = CurrentOwnerField;

      if (CurrentOwnerField) {
         const $menuUser = $$(ids.kanban).getUserList();

         $menuUser.clearAll();

         if (CurrentOwnerField instanceof this.ABFieldUser) {
            const users = ab.Account.userList().map((u) => {
               return {
                  id: u.username,
                  value: u.username,
               };
            });

            $menuUser.parse(users);
         } else if (CurrentOwnerField instanceof this.ABFieldConnect) {
            const options = await CurrentOwnerField.getOptions();

            try {
               $menuUser.parse(
                  options.map((opt) => {
                     return {
                        id: opt.id,
                        value: opt.text,
                     };
                  })
               );
            } catch (e) {
               // TODO: remove this.  Trying to catch a random webix error:
               // Cannot read properties of null (reading 'driver')
               console.error(e);
               console.warn(options);
            }
         }
      }
   }

   busy() {
      this.$kb?.showProgress?.({ type: "icon" });
   }

   ready() {
      this.$kb?.hideProgress?.();
   }

   objectLoad(object) {
      super.objectLoad(object);

      this.TextTemplate.objectLoad(object);
      this.FormSide.objectLoad(object);
   }

   /**
    * @method datacollectionLoad
    *
    * @param datacollection {ABDatacollection}
    */
   datacollectionLoad(datacollection) {
      super.datacollectionLoad(datacollection);

      const DC = this.CurrentDatacollection || datacollection;

      if (DC) {
         DC.bind(this.$kb);

         const obj = DC.datasource;

         if (obj) this.objectLoad(obj);

         return;
      }

      this.$kb.unbind();
   }

   async updateStatus(rowId, status) {
      if (!this.CurrentVerticalField) return;

      // Show loading cursor
      this.busy();

      let patch = {};

      // update multi-values
      if (status instanceof Object) patch = status;
      // update single value
      else patch[this.CurrentVerticalField.columnName] = status;

      // update empty value
      let needRefresh = false;

      for (const key in patch)
         if (!patch[key]) {
            patch[key] = "";

            // WORKAROUND: if update data is empty, then it will need to refresh
            // the kanban after update
            needRefresh = true;
         }

      try {
         await this.CurrentObject?.model().update(rowId, patch);

         this.ready();

         if (needRefresh) this.show();

         // update form data
         if (this.FormSide.isVisible()) {
            const data = $$(this.ids.kanban).getItem(rowId);

            this.FormSide.refresh(data);
         }
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABViewKanban:updateStatus(): Error saving item:",
            rowId,
            patch,
         });
      }
   }

   async updateOwner(rowId, val) {
      if (!this.CurrentOwnerField) return;

      // Show loading cursor
      this.busy();

      const patch = {};

      patch[this.CurrentOwnerField.columnName] = val;

      try {
         const updatedRow = await this.CurrentObject?.model().update(
            rowId,
            patch
         );

         // update card
         this.$kb?.updateItem(rowId, updatedRow);

         // update form data
         if (this.FormSide.isVisible()) {
            const data = this.$kb.getItem(rowId);

            this.FormSide.refresh(data);
         }

         this.ready();
      } catch (err) {
         this.AB.notify.developer(err, {
            context: "ABViewKanban:updateOwner(): Error saving item:",
            rowId,
            val,
         });

         this.ready();
      }
   }

   saveData(data) {
      // update
      if (data.id && this.$kb.exists(data.id))
         this.$kb.updateItem(data.id, data);
      // insert
      else this.$kb.add(data);
   }

   unselect() {
      if (this.$kb)
         this.$kb.eachList((list /*, status*/) => {
            list?.unselect?.();
         });
   }

   addCard() {
      this.unselect();

      // show the side form
      this.FormSide.show();
      $$(this.ids.resizer).show();
   }

   async removeCard(rowId) {
      const ab = this.AB;
      const abWebix = ab.Webix;

      abWebix.confirm({
         title: this.label("Remove card"),
         text: this.label("Do you want to delete this card?"),
         callback: async (result) => {
            if (!result) return;

            this.busy();

            try {
               const response = await this.CurrentObject?.model().delete(rowId);

               if (response.numRows > 0) {
                  this.$kb.remove(rowId);
               } else {
                  abWebix.alert({
                     text: this.label(
                        "No rows were effected. This does not seem right."
                     ),
                  });
               }
            } catch (err) {
               ab.notify.developer(err, {
                  message: "ABViewKanban:removeCard(): Error deleting item:",
                  rowId,
               });
            }

            this.ready();
         },
      });
   }

   /**
    * @method setFields()
    * Save the current view options.
    * @param options - {
    *       verticalGrouping:    {ABField} - required
    *       horizontalGrouping:  {ABField} - optional
    *       ownerField:          {ABField} - optional
    * }
    */
   setFields(options) {
      this.CurrentVerticalField = options.verticalGrouping;
      this.CurrentHorizontalField = options.horizontalGrouping;
      this.CurrentOwnerField = options.ownerField;
   }
};


/***/ }),

/***/ 97922:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewLabelComponent.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewLabelComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewLabel_${baseView.id}`, ids);
   }

   ui() {
      const baseView = this.view;

      const _ui = super.ui([
         this.uiFormatting({
            view: "label",
            // css: 'ab-component-header ab-ellipses-text',
            label: baseView.text || "*",
            align: this.settings.alignment,
            type: {
               height: "auto",
            },
         }),
      ]);

      delete _ui.type;

      return _ui;
   }

   /**
    * @method uiFormatting
    * a common routine to properly update the displayed label
    * UI with the css formatting for the given .settings
    * @param {obj} _ui the current webix.ui definition
    * @return {obj} a properly formatted webix.ui definition
    */
   uiFormatting(ui) {
      // add different css settings based upon it's format
      // type.
      switch (parseInt(this.settings.format)) {
         // normal
         case 0:
            ui.css = "ab-component-label ab-ellipses-text";
            break;

         // title
         case 1:
            ui.css = "ab-component-header ab-ellipses-text";
            break;

         // description
         case 2:
            ui.css = "ab-component-description ab-ellipses-text";
            break;
      }

      return ui;
   }
};


/***/ }),

/***/ 30909:
/*!**************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewLayoutComponent.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewLayoutComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(baseView, idBase || `ABViewLayout_${baseView.id}`, ids);

      const viewComponents = this.viewComponents ?? {}; // { viewId: viewComponent, ..., viewIdn: viewComponent }

      baseView.views().forEach((v) => {
         viewComponents[v.id] = v.component();
      });

      this.viewComponents = viewComponents;
   }

   ui() {
      const viewComponents = this.viewComponents;
      const uiComponents = Object.keys(viewComponents)
         .map((vId) => viewComponents[vId].ui())
         .filter((ui) => ui);

      if (uiComponents.length == 0) {
         uiComponents.push({});
         uiComponents.push({
            view: "label",
            label: this.label("no content"),
         });
         uiComponents.push({});
      }

      const _ui = super.ui([
         {
            view: "layout",
            cols: uiComponents,
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async init(AB, accessLevel) {
      await super.init(AB);

      const baseView = this.view;

      // make sure each of our child views get .init() called
      baseView.views().forEach((v) => {
         const component = this.viewComponents[v.id];

         // initial sub-component
         component?.init(AB, accessLevel);

         // Trigger 'changePage' event to parent
         baseView.eventAdd({
            emitter: v,
            eventName: "changePage",
            listener: (pageId) => {
               baseView.changePage(pageId);
            },
         });
      });
   }

   onShow() {
      // calll .onShow in child components
      this.view.views().forEach((v) => {
         const component = this.viewComponents[v.id];
         component?.onShow();
      });
   }
};


/***/ }),

/***/ 4030:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewListComponent.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewListComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewList_${baseView.id}`,
         Object.assign({ list: "" }, ids)
      );
   }

   ui() {
      const settings = this.settings;
      const _uiList = {
         id: this.ids.list,
         view: "dataview",
         type: {
            width: 1000,
            height: 30,
         },
         template: (item) => {
            const field = this.view.field();

            if (!field) return "";

            return field.format(item);
         },
      };

      // set height or autoHeight
      if (settings.height !== 0) _uiList.height = settings.height;
      else _uiList.autoHeight = true;

      const _ui = super.ui([_uiList]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const dc = this.datacollection;

      if (!dc) return;

      // bind dc to component
      dc.bind($$(this.ids.list));
      // $$(ids.list).sync(dv);
   }
};


/***/ }),

/***/ 46078:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewMenuComponent.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewMenuComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewMenu_${baseView.id}`,
         Object.assign(
            {
               menu: "",
            },
            ids
         )
      );
   }

   ui() {
      const settings = this.settings;
      const _ui = super.ui([
         parseInt(settings.menuInToolbar) ? this.uiToolbar() : this.uiMenu(),
      ]);

      delete _ui.type;

      return _ui;
   }

   uiMenu() {
      const baseView = this.view;
      const settings = this.settings;
      const defaultSettings = baseView.constructor.defaultValues();
      const css = `${settings.buttonStyle || defaultSettings.buttonStyle} ${
         settings.menuAlignment || defaultSettings.menuAlignment
      } `;

      return {
         id: this.ids.menu,
         view: "menu",
         autoheight: true,
         autowidth: true,
         datatype: "json",
         css: css,
         layout: settings.orientation || defaultSettings.orientation,
         on: {
            onMenuItemClick: (id /*, e, node */) => {
               this.onClick(id);
            },
            onAfterRender: () => {
               this.defineCypress();
            },
         },
         type: {
            subsign: true,
         },
      };
   }

   uiToolbar() {
      const settings = this.settings;
      const baseView = this.view;
      const defaultSettings = baseView.constructor.defaultValues();
      const _uiMenu = this.uiMenu();

      let elems = [];
      let menuIncluded = false;

      // Legacy support: use old settings values if translated values are not set
      const menuTextLeft = baseView.menuTextLeft ?? settings.menuTextLeft;
      const menuTextCenter = baseView.menuTextCenter ?? settings.menuTextCenter;
      const menuTextRight = baseView.menuTextRight ?? settings.menuTextRight;

      if (settings.menuPosition === "left") {
         menuIncluded = true;
         elems.push(_uiMenu);
      } else if (menuTextLeft?.length) {
         const width = menuTextLeft.length * 15;

         elems.push({
            view: "label",
            label: menuTextLeft,
            align: "left",
            width: width,
         });
      } else
         elems.push({
            view: "label",
            label: "",
            autowidth: true,
         });

      if (settings?.menuPosition === "center") {
         menuIncluded = true;

         elems.push(_uiMenu);
      } else if (menuTextCenter?.length) {
         const width = menuTextLeft.length * 15;

         elems.push(
            {},
            {
               view: "label",
               label: menuTextCenter,
               align: "center",
               width: width,
            },
            {}
         );
      } else
         elems.push({
            view: "label",
            label: "",
            autowidth: true,
         });

      if (settings?.menuPosition === "right") {
         menuIncluded = true;

         elems.push(_uiMenu);
      } else if (menuTextRight?.length) {
         const width = menuTextLeft.length * 15;

         elems.push({
            view: "label",
            label: menuTextRight,
            align: "right",
            width: width,
         });
      } else
         elems.push({
            view: "label",
            label: "",
            autowidth: true,
         });

      if (menuIncluded === false) elems = [_uiMenu];

      return {
         view: "toolbar",
         css: settings.menuTheme ?? defaultSettings.menuTheme,
         padding: settings.menuPadding
            ? parseInt(settings.menuPadding)
            : defaultSettings.menuPadding,
         elements: elems,
      };
   }

   async init(AB) {
      await super.init(AB);

      const $menu = $$(this.ids.menu);
      const baseView = this.view;

      if ($menu) {
         const settings = this.settings;

         baseView.ClearPagesInView($menu);

         if (settings.order?.length) {
            baseView.AddPagesToView($menu, settings.order);
            // Force onAfterRender to fire
            $menu.refresh();
         }
      }
   }

   onClick(itemId) {
      const $menu = $$(this.ids.menu);
      let $item;
      try {
         $item = $menu.getMenuItem(itemId);
      } catch (err) {
         this.AB.notify.developer(err, {
            context:
               "ABViewMenuComponent > onClick error gettint menu / menu item",
            itemId,
            menu: {
               id: this.view.id,
               settings: this.view.settings,
            },
         });
         return;
      }
      const baseView = this.view;

      // switch tab view
      if ($item.type === "tab") {
         baseView.changePage($item.pageId);

         const redirectPage = baseView.application.pages(
            (p) => p.id === $item.pageId,
            true
         )[0];

         if (!redirectPage) return;

         const tabView = redirectPage.views((v) => v.id === $item.id, true)[0];

         if (!tabView) return;

         const tab = tabView.parent;

         if (!tab) return;

         this.toggleParent(tab);

         // if (!$$(tabView.id) || !$$(tabView.id).isVisible()) {
         const showIt = setInterval(() => {
            if ($$(tabView.id) && $$(tabView.id).isVisible()) {
               clearInterval(showIt);

               return;
            }

            tab.emit("changeTab", tabView.id);
         }, 100);
         // }
      }
      // switch page
      else baseView.changePage(itemId);
   }

   toggleParent(element) {
      if (!element.parent) return false;

      const parentElem = element.parent;

      if (!parentElem?.parent) return false;

      parentElem.parent.emit("changeTab", parentElem.id);
      this.toggleParent(parentElem.parent);
   }

   defineCypress() {
      const $menu = $$(this.ids.menu);

      if (!$menu) return;

      $menu.data.each((item) => {
         const node = $menu.getItemNode(item.id);

         if (!node) return;

         // get linked page/tab info so we can use its name in the data-cy
         const viewInfo = this.AB.definitionByID(item.id);

         node.setAttribute(
            "data-cy",
            `menu-item ${viewInfo?.name} ${item.id} ${this.view.id}`
         );
      });
   }
};


/***/ }),

/***/ 90510:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewPDFImporterComponent.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

const SMALL_PAGE_WIDTH = 150;
const BIG_PAGE_WIDTH = 250;

module.exports = class ABViewPDFImporterComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewPDFImporter_${baseView.id}`,
         Object.assign(
            {
               fileUploader: "",
               uploadList: "",
               dataview: "",
               fullImagePopup: "",
               fullImageCarousel: "",
               fullImageSelectToggle: "",
               fullImageLabel: "",
               selectAll: "",
               unselectAll: "",
               submit: "",
            },
            ids
         )
      );
   }

   ui() {
      const ids = this.ids;
      const self = this;
      const _ui = super.ui([
         {
            rows: [
               {
                  cols: [
                     {
                        id: ids.fileUploader,
                        view: "uploader",
                        name: "records",
                        link: ids.uploadList,
                        label: this.label("Upload a PDF file"),
                        inputWidth: 200,
                        width: 210,
                        accept: "application/pdf",
                        multiple: false,
                        autosend: false,
                        type: "icon",
                        icon: "fa fa-file-pdf-o",
                        on: {
                           onBeforeFileAdd: (fileInfo) => {
                              this._csvFileInfo = fileInfo;
                              if (!this._csvFileInfo) return false;

                              this.loadFile();

                              return true;
                           },
                        },
                     },
                     {
                        id: ids.uploadList,
                        view: "list",
                        type: "uploader",
                        autoheight: true,
                        borderless: true,
                        onClick: {
                           webix_remove_upload: (e, id) => {
                              this.removeFile(id);
                           },
                        },
                     },
                     {
                        width: 10,
                     },
                     {
                        view: "button",
                        type: "icon",
                        icon: "fa fa-th-large",
                        maxWidth: 30,
                        click: () => {
                           this.displayBig();
                        },
                     },
                     {
                        view: "button",
                        type: "icon",
                        icon: "fa fa-th",
                        maxWidth: 30,
                        click: () => {
                           this.displaySmall();
                        },
                     },
                  ],
               },
               {
                  height: 10,
               },
               {
                  id: ids.dataview,
                  view: "dataview",
                  borderless: true,
                  css: "pdf-data-view",
                  multiselect: false,
                  select: false,
                  type: {
                     template: (item) => {
                        return this.pageTemplate(item);
                     },
                     width: "auto",
                     height: "auto",
                  },
                  on: {
                     onSelectChange: (pageIds) => {
                        this.renderPageImages();
                     },
                     onItemClick: function (id, e, node) {
                        // Unselect
                        if (e?.target?.className?.includes?.("unselect-page")) {
                           self.unselect(id);
                        }
                        // Select
                        else if (
                           e?.target?.className?.includes?.("select-page")
                        ) {
                           self.select(id);
                        }
                        // Zoom
                        else if (e?.target?.className?.includes?.("pdf-zoom")) {
                           self._fullImagePopup.show();
                           $$(self.ids.fullImageCarousel).setActiveIndex(
                              parseInt(id ?? 0) - 1
                           );
                           self.refreshFullImage();
                        }
                     },
                  },
               },
               {
                  height: 10,
               },
               {
                  cols: [
                     {
                        id: ids.selectAll,
                        view: "button",
                        type: "icon",
                        icon: "fa fa-check-square-o",
                        maxWidth: 160,
                        label: this.label("Select All"),
                        click: () => {
                           this.selectAll();
                        },
                     },
                     {
                        id: ids.unselectAll,
                        view: "button",
                        type: "icon",
                        icon: "fa fa-square-o",
                        maxWidth: 160,
                        label: this.label("Unselect All"),
                        click: () => {
                           this.unselectAll();
                        },
                     },
                     {
                        fillspace: true,
                     },
                     {
                        id: ids.submit,
                        view: "button",
                        css: "webix_primary",
                        type: "icon",
                        icon: "fa fa-floppy-o",
                        disabled: true,
                        maxWidth: 180,
                        label: this.label("Submit"),
                        click: () => {
                           this.submit();
                        },
                     },
                  ],
               },
            ],
         },
      ]);

      return _ui;
   }

   uiPopup() {
      const ids = this.ids;
      return {
         id: ids.fullImagePopup,
         view: "window",
         modal: true,
         position: "center",
         headHeight: 25,
         head: {
            cols: [
               { fillspace: true },
               {
                  view: "button",
                  type: "icon",
                  icon: "fa fa-times",
                  maxWidth: 25,
                  height: 25,
                  click: () => {
                     $$(ids.fullImagePopup)?.hide();
                  },
               },
            ],
         },
         body: {
            rows: [
               {
                  id: ids.fullImageCarousel,
                  view: "carousel",
                  width: 600,
                  height: 500,
                  navigation: {
                     items: true,
                     buttons: true,
                     type: "side",
                  },
                  cols: [],
                  on: {
                     onShow: () => {
                        this.refreshFullImage();
                     },
                  },
               },
               {
                  view: "layout",
                  cols: [
                     {
                        id: ids.fullImageSelectToggle,
                        view: "toggle",
                        type: "icon",
                        offIcon: "fa fa-square-o",
                        onIcon: "fa fa-check-square-o",
                        offLabel: this.label("Unselected"),
                        onLabel: this.label("Selected"),
                        width: 130,
                        on: {
                           onChange: (isSelected) => {
                              const activeIndex = $$(
                                 this.ids.fullImageCarousel
                              ).getActiveIndex();
                              const pageNumber = activeIndex + 1;

                              if (isSelected) this.select(pageNumber);
                              else this.unselect(pageNumber);
                           },
                        },
                     },
                     {
                        fillspace: true,
                     },
                     {
                        id: ids.fullImageLabel,
                        view: "label",
                        width: 120,
                        label: `${this.label("Page Number")}: ${"#"}`,
                     },
                  ],
               },
            ],
         },
      };
   }

   async init(AB) {
      await super.init(AB);

      const $dataview = $$(this.ids.dataview);
      if ($dataview) this.AB.Webix.extend($dataview, webix.ProgressBar);

      if (!this._fullImagePopup) {
         const fullImagePopup = this.uiPopup();
         this._fullImagePopup = this.AB.Webix.ui(fullImagePopup);
      }
   }

   onShow() {
      this.initPdfjs();
      super.onShow();
   }

   /**
    * Loads the pdfjs dependecies. We defer loading since it is a large library
    * that is not needed in the initial page load.
    */
   async initPdfjs() {
      if (this.pdfjs && window.pdfjsWorker) return;
      this.busy();
      this.pdfjs = (
         await Promise.all(/*! import() */[__webpack_require__.e("pdfjs-node_modules_pdfjs-dist_build_pdf_worker_js"), __webpack_require__.e("pdfjs-init_pdfjs_js"), __webpack_require__.e("_4a14-_fe90-_d446-_4c38-_9f5f-_afbb")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../../../init/pdfjs */ 12555))
      ).default;

      this.ready();
   }

   async _readFileBuffer() {
      const _csvFileInfo = this._csvFileInfo;
      if (!_csvFileInfo || !_csvFileInfo.file)
         return Promise.resolve(new ArrayBuffer(0));

      const fileReader = new FileReader();

      return new Promise((resolve, reject) => {
         fileReader.onload = (event) => {
            const fileBuffer = event.target.result;
            resolve(fileBuffer);
         };
         fileReader.onerror = (event) => {
            reject(event);
         };
         fileReader.readAsArrayBuffer(_csvFileInfo.file);
      });
   }

   async _toBlob(pageNumber, canvas) {
      if (!canvas) return;

      return new Promise((resolve, reject) => {
         canvas.toBlob((blob) => {
            const file = new File([blob], `${pageNumber}.png`, {
               type: "image/png",
            });

            resolve(file);
         }, "image/png");
      });
   }

   async _uploadImage(pageNumber) {
      // Create a temporary CANVAS dom to render page image with specify the height
      const $carousel = $$(this.ids.fullImageCarousel);
      const canvasId = `${this.view.id}_temp_canvas`;
      const canvas =
         document.getElementById(canvasId) ?? document.createElement("canvas");
      canvas.id = canvasId;
      canvas.width = $carousel.config.width - 20;

      await this.showPage(pageNumber, canvas);
      const fileBlob = await this._toBlob(pageNumber, canvas);

      return new Promise((resolve, reject) => {
         // Create a uploader to upload images
         const $uploader = this.AB.Webix.ui({
            view: "uploader",
            apiOnly: true,
            upload: this.field.urlUpload(),
            inputName: "file",
            multiple: false,
            on: {
               // when upload is complete:
               onFileUpload: (item, response) => {
                  // RETURN HERE
                  resolve(response?.data?.uuid);
               },
               // if an error was returned
               onFileUploadError: (item, response) => {
                  reject(response);
               },
               onUploadComplete: () => $uploader.destructor(),
            },
         });

         $uploader.addFile(fileBlob, fileBlob.size);
      });
   }

   _increaseProgressValue() {
      const $dataview = $$(this.ids.dataview);
      const maxProgressStep = ($dataview.getSelectedId(true) ?? []).length * 2;

      this._progressSteps = this._progressSteps ?? 0;
      this._progressSteps++;

      $dataview?.showProgress?.({
         type: "bottom",
         position: this._progressSteps / maxProgressStep,
      });
   }

   async loadFile() {
      this.clearDataview();

      const _csvFileInfo = this._csvFileInfo;
      if (!_csvFileInfo) return;

      const fileBuffer = await this._readFileBuffer();
      this._pdfDoc = await this.pdfjs.getDocument(fileBuffer).promise;

      const total_page = this._pdfDoc.numPages;
      const $dataview = $$(this.ids.dataview);
      const $carousel = $$(this.ids.fullImageCarousel);
      const carousel_list = [];
      for (let pageNumber = 1; pageNumber <= total_page; pageNumber++) {
         $dataview.add({
            id: pageNumber,
            pageNumber,
         });

         carousel_list.push({
            template: (item) => {
               return this.fullImageTemplate(item);
            },
            data: {
               pageNumber,
            },
         });
      }

      this.renderPageImages();
      if ($carousel) this.AB.Webix.ui(carousel_list, $carousel);

      // Select all of images by default
      this.selectAll();

      $$(this.ids.submit)?.enable();
   }

   removeFile(id) {
      $$(this.ids.uploadList)?.remove(id);

      delete this._pdfDoc;
      delete this._csvFileInfo;
      this.clearDataview();

      $$(this.ids.submit)?.disable();

      return true;
   }

   pageTemplateId(pageNumber) {
      return `pdf-importer-${this.view.id}-${pageNumber}`;
   }

   pageTemplate(item) {
      const $dataview = $$(this.ids.dataview);
      let selectedPageIds = $dataview.getSelectedId(true);

      return `
      <div>
         <div class="pdf-data-view-item">
            <div>
            ${
               selectedPageIds.filter((pageId) => pageId == item.id).length
                  ? '<i class="unselect-page fa fa-check-square-o"></i>'
                  : '<i class="select-page fa fa-square-o"></i>'
            }
            </div>
            <div style="width: 15px;">
               ${item.pageNumber}
            </div>
         </div>
         <div class="pdf-zoom pdf-data-view-image">
            <canvas class="pdf-zoom" width="${
               this.pageItemWidth
            }" id="${this.pageTemplateId(item.pageNumber)}"></canvas>
            <div class="pdf-zoom pdf-data-view-image-icon">
               <i class="pdf-zoom fa fa-search-plus fa-4x"></i>
            </div>
         </div>
      </div>
      `;
   }

   renderPageImages() {
      const $dataview = $$(this.ids.dataview);
      $dataview?.find({}).forEach((item) => {
         const canvas_dom = document.querySelector(
            `#${this.pageTemplateId(item.pageNumber)}`
         );
         this.showPage(item.pageNumber, canvas_dom);
      });
   }

   async showPage(pageNumber, canvas_dom) {
      if (!this._pdfDoc) return;

      pageNumber = parseInt(pageNumber);
      const page = await this._pdfDoc.getPage(pageNumber);
      const pdf_original_width = page.getViewport({ scale: 1 }).width;
      const scale_required = canvas_dom.width / pdf_original_width;

      // get viewport to render the page at required scale
      const viewport = page.getViewport({ scale: scale_required });
      canvas_dom.height = viewport.height;

      return page.render({
         canvasContext: canvas_dom.getContext("2d"),
         viewport: viewport,
      }).promise;
   }

   clearDataview() {
      const $dataview = $$(this.ids.dataview);
      const $carousel = $$(this.ids.fullImageCarousel);

      $dataview?.clearAll();
      if ($carousel)
         this.AB.Webix.ui(
            [
               {
                  view: "label",
                  align: "center",
                  height: $carousel.height,
                  label: this.label("No image"),
               },
            ],
            $carousel
         );
   }

   displaySmall() {
      this._isDisplayBig = false;
      $$(this.ids.dataview)?.render();
      this.renderPageImages();
   }

   displayBig() {
      this._isDisplayBig = true;
      $$(this.ids.dataview)?.render();
      this.renderPageImages();
   }

   get pageItemWidth() {
      return this._isDisplayBig ? BIG_PAGE_WIDTH : SMALL_PAGE_WIDTH;
   }

   select(pageNumber) {
      const $dataview = $$(this.ids.dataview);

      let selectedIds = $dataview.getSelectedId(true);

      selectedIds.push(pageNumber);
      selectedIds = selectedIds.filter((pageId) => pageId);

      if (selectedIds.length) $dataview.select(selectedIds);
      else $dataview.unselectAll();
   }

   unselect(pageNumber) {
      const $dataview = $$(this.ids.dataview);

      let selectedIds = $dataview.getSelectedId(true);

      selectedIds = selectedIds.filter(
         (pageId) => pageId && pageId != pageNumber
      );

      if (selectedIds.length) $dataview.select(selectedIds);
      else $dataview.unselectAll();
   }

   selectAll() {
      $$(this.ids.dataview)?.selectAll();
   }

   unselectAll() {
      $$(this.ids.dataview)?.unselectAll();
   }

   fullImageTemplateId(pageNumber) {
      return `${this.pageTemplateId(pageNumber)}_full_size`;
   }

   fullImageTemplate(item) {
      const $carousel = $$(this.ids.fullImageCarousel);
      return `<canvas width="${
         $carousel.config.width - 20
      }" id="${this.fullImageTemplateId(item.pageNumber)}"></canvas>`;
   }

   refreshFullImage() {
      const ids = this.ids;
      const activeIndex = $$(ids.fullImageCarousel).getActiveIndex();
      const pageNumber = activeIndex + 1;
      const canvas_dom = document.querySelector(
         `#${this.fullImageTemplateId(pageNumber)}`
      );
      this.showPage(pageNumber, canvas_dom);

      const selectedPageIds = $$(ids.dataview).getSelectedId(true);
      const isSelected =
         selectedPageIds.filter((pageId) => pageId == pageNumber).length > 0;
      $$(ids.fullImageSelectToggle).setValue(isSelected);

      $$(ids.fullImageLabel).setValue(
         `${this.label("Page Number")}: ${pageNumber}`
      );
   }

   get object() {
      return this.view.datacollection?.datasource;
   }

   get field() {
      return this.object?.fields?.(
         (f) => f.id == this.view.settings.fieldID
      )[0];
   }

   busy() {
      const ids = this.ids;

      const $fileUploader = $$(ids.fileUploader);
      const $uploadList = $$(ids.uploadList);
      const $dataview = $$(ids.dataview);
      const $submit = $$(ids.submit);
      const $selectAll = $$(ids.selectAll);
      const $unselectAll = $$(ids.unselectAll);
      const $selectToggle = $$(ids.fullImageSelectToggle);

      $fileUploader?.disable();
      $uploadList?.disable();
      $submit?.disable();
      $selectAll?.disable();
      $unselectAll?.disable();
      $selectToggle?.disable();
      $dataview?.showProgress?.({
         type: "bottom",
         position: 0.001,
      });
   }

   ready() {
      const ids = this.ids;

      const $fileUploader = $$(ids.fileUploader);
      const $uploadList = $$(ids.uploadList);
      const $dataview = $$(ids.dataview);
      const $submit = $$(ids.submit);
      const $selectAll = $$(ids.selectAll);
      const $unselectAll = $$(ids.unselectAll);
      const $selectToggle = $$(ids.fullImageSelectToggle);

      $fileUploader?.enable();
      $uploadList?.enable();
      $submit?.enable();
      $selectAll?.enable();
      $unselectAll?.enable();
      $selectToggle?.enable();
      $dataview?.hideProgress?.();

      delete this._progressSteps;
   }

   async submit() {
      const field = this.field;
      if (!this._pdfDoc || !field) return;

      this.busy();

      const ids = this.ids;
      const $dataview = $$(ids.dataview);
      const selectedPageIds = $dataview.getSelectedId(true) ?? [];
      const model = field.object.model();
      const dcLink = this.datacollection.datacollectionLink;
      const newValues = [];

      for (let i = 0; i < selectedPageIds.length; i++) {
         const pageNumber = selectedPageIds[i];
         if (pageNumber == null || pageNumber == "") return;

         const uploadId = await this._uploadImage(pageNumber);

         this._increaseProgressValue();

         // Insert Data
         const values = field.object.defaultValues();
         values[field.columnName] = uploadId;

         // Set linked data from the parent DC
         const linkValues = dcLink?.getCursor();
         if (linkValues) {
            const objectLink = dcLink?.datasource;

            const connectFields = field.object.connectFields();
            connectFields.forEach((f) => {
               if (
                  objectLink.id == f.settings.linkObject &&
                  values[f.columnName] === undefined
               ) {
                  const linkColName = f.indexField
                     ? f.indexField.columnName
                     : objectLink.PK();

                  values[f.columnName] = {};
                  values[f.columnName][linkColName] =
                     linkValues[linkColName] ?? linkValues.id;
               }
            });
         }

         newValues.push(await model.create(values));

         this._increaseProgressValue();
      }

      this.view.doSubmitRules(newValues);

      // NOTE: trigger this event to ABViewPropertyAddPage
      if (newValues) this.view.emit("saved", newValues);

      this.ready();
   }
};


/***/ }),

/***/ 5740:
/*!*************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewPivotComponent.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);
const ABFieldCalculate = __webpack_require__(/*! ../../dataFields/ABFieldCalculate */ 59675);
const ABFieldFormula = __webpack_require__(/*! ../../dataFields/ABFieldFormula */ 37900);
const ABFieldNumber = __webpack_require__(/*! ../../dataFields/ABFieldNumber */ 18799);
/* global pivot */
module.exports = class ABViewPivotComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewPivot_${baseView.id}`,
         Object.assign({ pivot: "" }, ids)
      );
   }

   ui() {
      const self = this;
      const settings = this.settings;
      const uiPivot = {
         id: this.ids.pivot,
         view: "pivot",
         readonly: true,
         removeMissed: settings.removeMissed,
         totalColumn: settings.totalColumn,
         separateLabel: settings.separateLabel,
         min: settings.min,
         max: settings.max,
         height: settings.height,
         fields: this._getFields(),
         format: (value) => {
            const decimalPlaces = settings.decimalPlaces ?? 2;

            return value && value != "0"
               ? parseFloat(value).toFixed(decimalPlaces || 0)
               : value;
         },
         override: new Map([
            [
               pivot.services.Backend,
               class MyBackend extends pivot.services.Backend {
                  async data() {
                     const dc = self.datacollection;
                     if (!dc) return webix.promise.resolve([]);

                     const object = dc.datasource;
                     if (!object) return webix.promise.resolve([]);

                     switch (dc.dataStatus) {
                        case dc.dataStatusFlag.notInitial:
                           await dc.loadData();
                           break;
                     }

                     const data = dc.getData();
                     const dataMapped = data.map((d) => {
                        const result = {};

                        object.fields().forEach((f) => {
                           if (
                              f instanceof ABFieldCalculate ||
                              f instanceof ABFieldFormula ||
                              f instanceof ABFieldNumber
                           )
                              result[f.columnName] = d[f.columnName];
                           else result[f.columnName] = f.format(d);
                        });

                        return result;
                     });

                     return webix.promise.resolve(dataMapped);
                  }
               },
            ],
            [
               pivot.views.table,
               class CustomTable extends pivot.views.table {
                  CellFormat(value) {
                     const decimalPlaces = settings.decimalPlaces ?? 2;
                     if (!value) value = value === 0 ? "0" : "";
                     return value
                        ? parseFloat(value).toFixed(decimalPlaces)
                        : value;
                  }
               },
            ],
         ]),
      };

      if (settings.structure) uiPivot.structure = settings.structure;

      const _ui = super.ui([uiPivot]);
      delete _ui.type;

      return _ui;
   }

   _getFields() {
      const dc = this.datacollection;
      if (!dc) return [];

      const object = dc.datasource;
      if (!object) return [];

      const fields = object.fields().map((f) => {
         let fieldType = "text";

         switch (f.key) {
            case "calculate":
            case "formula":
            case "number":
               fieldType = "number";
               break;
            case "date":
            case "datetime":
               fieldType = "date";
               break;
         }

         return {
            id: f.columnName,
            value: f.label,
            type: fieldType,
         };
      });

      return fields;
   }
};


/***/ }),

/***/ 33188:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewReportsManagerComponent.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewReportsManagerComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewReportManager_${baseView.id}`,
         Object.assign(
            {
               reportManager: "",
            },
            ids
         )
      );

      this.readonly = false;
   }

   ui() {
      const self = this;
      const settings = this.settings;
      const ab = this.AB;
      const abWebix = ab.Webix;
      const dc = this.datacollection;
      const fieldName = dc?.datasource.fieldByID(
         settings.dataviewFields.name
      )?.columnName;
      const fieldText = dc?.datasource.fieldByID(
         settings.dataviewFields.text
      )?.columnName;
      const fieldQueries = dc?.datasource.fieldByID(
         settings.dataviewFields.queries
      )?.columnName;
      const ids = this.ids;
      class MyBackend extends reports.services.Backend {
         async getModules() {
            if (dc == null) return [];

            await self.waitInitializingDCEvery(1000, dc);

            return dc.getData().map((e) => {
               return {
                  id: e.id,
                  name: e[fieldName],
                  text: JSON.stringify(e[fieldText]),
                  updated: e["updated_at"],
               };
            });
         }

         async addModule(data) {
            const parsedData = {};

            parsedData[fieldName] = data.name;
            parsedData[fieldText] = data.text;

            const response = await dc.model.create(parsedData);

            return {
               id: response.id,
            };
         }

         async updateModule(id, data) {
            const parsedData = {};

            parsedData[fieldName] = data.name;
            parsedData[fieldText] = data.text;

            let response = {};

            response = await dc.model.update(id, parsedData);

            return { id: response.id };
         }

         async deleteModule(id) {
            await dc.model.delete(id);

            return { id: id };
         }

         async getModels() {
            const reportModels = {};

            // If no selected DC then get all DCs
            (settings.datacollectionIDs.length > 0
               ? settings.datacollectionIDs
               : self.view.application.datacollectionIDs
            ).forEach((dcID) => {
               const dc = ab.datacollectionByID(dcID);

               if (!dc) return;

               const obj = dc.datasource;

               if (!obj) return;

               const reportFields = self.getReportFields(dc);

               // get connected data collections
               // let linkedFields = [];
               // (obj.connectFields() || []).forEach((f, index) => {
               //    let connectedDcs = ab.datacollections(
               //       (dColl) =>
               //          dColl &&
               //          dColl.datasource &&
               //          dColl.datasource.id === f.settings.linkObject
               //    );
               //    (connectedDcs || []).forEach((linkedDc) => {
               //       linkedFields.push({
               //          id: index + 1,
               //          name: linkedDc.label,
               //          source: dc.id,
               //          target: linkedDc.id
               //       });
               //    });
               // });

               // // MOCK UP for testing
               // let linkedFields = [
               //    {
               //       id: "id",
               //       name: "id",
               //       source: "39378ee0-38f0-4b9d-a5aa-dddc61137fcd", // Player
               //       target: "0de82362-4ab5-4f0f-8cfa-d1288d173cba" // Team
               //    }
               // ];

               reportModels[dc.id] = {
                  id: dc.id,
                  name: dc.label,
                  data: reportFields,
                  refs: [],
               };
            });

            return reportModels;
         }

         async getQueries() {
            const moduleID = $$(ids.reportManager).getState().moduleId || "";

            if (moduleID === "") return [];

            return (
               (
                  await dc.model.findAll({
                     where: {
                        uuid: moduleID,
                     },
                  })
               ).data[0][fieldQueries] || []
            );
         }

         async addQuery(data) {
            const moduleID = $$(ids.reportManager).getState().moduleId || "";

            if (moduleID === "") return {};

            const moduleData = (
               await dc.model.findAll({
                  where: {
                     uuid: moduleID,
                  },
               })
            ).data[0];

            if (moduleData == null) return {};

            const queries = [...(moduleData[fieldQueries] || [])];
            const queryID = abWebix.uid();

            queries.push(Object.assign({ id: queryID }, data));

            const parsedData = {};

            parsedData[fieldQueries] = queries.sort((a, b) => {
               if (a.name < b.name) return -1;

               if (a.name > b.name) return 1;

               return 0;
            });

            await dc.model.update(moduleID, parsedData);

            return { id: queryID };
         }

         async updateQuery(id, data) {
            const moduleID = $$(ids.reportManager).getState().moduleId || "";

            if (moduleID === "") return {};

            const moduleData = (
               await dc.model.findAll({
                  where: {
                     uuid: moduleID,
                  },
               })
            ).data[0];

            if (moduleData == null) return {};

            const queries = [...(moduleData[fieldQueries] || [])];
            const queryIndex = queries.findIndex((e) => e.id === id);

            queries[queryIndex] = Object.assign({ id }, data);

            const parsedData = {};

            parsedData[fieldQueries] = queries.sort((a, b) => {
               if (a.name < b.name) return -1;

               if (a.name > b.name) return 1;

               return 0;
            });

            await dc.model.update(moduleID, parsedData);

            return { id };
         }

         async deleteQuery(id) {
            const moduleID = $$(ids.reportManager).getState().moduleId || "";

            if (moduleID === "") return {};

            const moduleData = (
               await dc.model.findAll({
                  where: {
                     uuid: moduleID,
                  },
               })
            ).data[0];

            if (moduleData == null) return {};

            const queries = moduleData[fieldQueries] || [];
            const queryIndex = queries.findIndex((e) => e.id === id);

            if (queryIndex >= 0) {
               const parsedData = {};

               parsedData[fieldQueries] = queries
                  .filter((e, i) => i !== queryIndex)
                  .sort((a, b) => {
                     if (a.name < b.name) return -1;

                     if (a.name > b.name) return 1;

                     return 0;
                  });

               await dc.model.update(moduleID, parsedData);
            }

            return { id: id };
         }

         async getData(config) {
            let result = [];
            let pullDataTasks = [];
            let dcIds = [];
            let dcData = {};
            let reportFields = [];

            // pull data of the base and join DCs
            dcIds.push(config.data);
            (config.joins || []).forEach((j) => {
               dcIds.push(j.sid);
               dcIds.push(j.tid);
            });
            dcIds = ab.uniq(dcIds);
            dcIds.forEach((dcId) => {
               pullDataTasks.push(
                  new Promise((resolve, reject) => {
                     const getData = async () => {
                        try {
                           dcData[dcId] = (await self.getData(dcId)) || [];

                           resolve();
                        } catch (err) {
                           reject(err);
                        }
                     };

                     getData();
                  })
               );
            });

            dcIds.forEach((dcId) => {
               const dataCol = ab.datacollectionByID(dcId);

               if (!dataCol) return;

               reportFields = reportFields.concat(
                  self.getReportFields(dataCol).map((f) => {
                     // change format of id to match the report widget
                     f.id = `${dcId}.${f.id}`; // dc_id.field_id
                     return f;
                  })
               );
            });

            await Promise.all(pullDataTasks);

            // the data result equals data of the base DC
            result = dcData[config.data] || [];

            if (config.joins?.length)
               (config.joins || []).forEach((j) => {
                  const sourceDc = ab.datacollectionByID(j.sid);
                  if (!sourceDc) return;

                  const sourceObj = sourceDc.datasource;
                  if (!sourceObj) return;

                  const targetDc = ab.datacollectionByID(j.tid);
                  if (!targetDc) return;

                  const targetObj = targetDc.datasource;
                  if (!targetObj) return;

                  const sourceLinkField = sourceObj.fieldByID(j.sf);
                  const targetLinkField = targetObj.fieldByID(j.tf);
                  if (!sourceLinkField && !targetLinkField) return;

                  const sourceData = dcData[j.sid] || [];
                  const targetData = dcData[j.tid] || [];

                  sourceData.forEach((sData) => {
                     targetData.forEach((tData) => {
                        let sVal =
                           sData[
                              sourceLinkField
                                 ? `${j.sid}.${sourceLinkField.columnName}.id`
                                 : `${j.sid}.id`
                           ] || [];

                        let tVal =
                           tData[
                              targetLinkField
                                 ? `${j.tid}.${targetLinkField.columnName}.id`
                                 : `${j.tid}.id`
                           ] || [];

                        if (!Array.isArray(sVal)) sVal = [sVal];

                        if (!Array.isArray(tVal)) tVal = [tVal];

                        // Add joined row to the result array
                        const matchedVal = sVal.filter(
                           (val) => tVal.indexOf(val) > -1
                        );

                        if (matchedVal?.length) {
                           const updateRows =
                              result.filter(
                                 (r) =>
                                    r[`${j.sid}.id`] === sData[`${j.sid}.id`] &&
                                    !r[`${j.tid}.id`]
                              ) || [];

                           if (updateRows?.length)
                              (updateRows || []).forEach((r) => {
                                 for (const key in tData)
                                    if (key !== "id") r[key] = tData[key];
                              });
                           else
                              result.push(
                                 Object.assign(
                                    ab.cloneDeep(sData),
                                    ab.cloneDeep(tData)
                                 )
                              );
                        }
                     });
                  });
               });

            // filter & sort
            const queryVal = JSON.parse(config.query || "{}");

            if (queryVal?.rules?.length)
               queryVal.rules.forEach((r) => {
                  if (!r || !r.type || !r.condition) return;

                  switch (r.type) {
                     case "date":
                        // Convert string to Date object
                        if (r.condition.filter) {
                           if (typeof r.condition.filter === "string")
                              r.condition.filter = ab.rules.toDate(
                                 r.condition.filter
                              );

                           if (
                              r.condition.filter.start &&
                              typeof r.condition.filter.start === "string"
                           )
                              r.condition.filter.start = ab.rules.toDate(
                                 r.condition.filter.start
                              );

                           if (
                              r.condition.filter.end &&
                              typeof r.condition.filter.end === "string"
                           )
                              r.condition.filter.end = ab.rules.toDate(
                                 r.condition.filter.end
                              );
                        }

                        break;
                  }
               });

            // create a new query widget to get the filter function
            const filterElem = abWebix.ui({
               view: "query",
               fields: reportFields,
               value: queryVal,
            });

            // create a new data collection and apply the query filter
            const tempDc = new abWebix.DataCollection();

            tempDc.parse(result);

            // filter
            let filterFn;

            try {
               filterFn = filterElem.getFilterFunction();
            } catch (error) {
               // continue regardless of error
            }

            if (filterFn) tempDc.filter(filterFn);

            // sorting
            (config.sort || []).forEach((sort) => {
               if (sort.id)
                  tempDc.sort({
                     as: "string",
                     dir: sort.mod || "asc",
                     by: `#${sort.id}#`,
                  });
            });

            result = tempDc.serialize();

            // clear
            filterElem.destructor();
            tempDc.destructor();

            // group by
            if (config?.group?.length) {
               result = _.groupBy(result, (e) => {
                  return config.group
                     .map((column) => {
                        const parsedColumn = column.split(".");
                        const originalColumn =
                           parsedColumn.length > 2
                              ? `${parsedColumn[1]}.${parsedColumn[2]}`
                              : column;
                        const reportField = reportFields.find(
                           (reportField) => reportField.id === originalColumn
                        );

                        switch (reportField.type) {
                           case "date": {
                              const dateStringData = abWebix.i18n.dateFormatStr(
                                 e[originalColumn]
                              );
                              const parsedDateStringData =
                                 dateStringData.split("/");

                              switch (parsedColumn[0]) {
                                 case "day":
                                    e[column] = parsedDateStringData[1];

                                    return parsedDateStringData[1];

                                 case "month":
                                    e[column] = parsedDateStringData[0];

                                    return parsedDateStringData[0];

                                 case "year":
                                    e[column] = parsedDateStringData[2];

                                    return parsedDateStringData[2];

                                 case "yearmonth": {
                                    e[
                                       column
                                    ] = `${parsedDateStringData[0]}/${parsedDateStringData[2]}`;

                                    return e[column];
                                 }

                                 default:
                                    e[column] = dateStringData;

                                    return dateStringData;

                                 // switch (reportField.abField.key) {
                                 //    case "datetime":
                                 //       return abWebix.i18n.fullDateFormatStr(
                                 //          e[originalColumn]
                                 //       );

                                 //    default:
                                 //       break;
                                 // }
                              }
                           }

                           default:
                              return e[originalColumn]?.toString?.();
                        }
                     })
                     .join("");
               });

               result = Object.values(result).map((groupedData) => {
                  const groupedResult = {};

                  (config.columns || []).forEach((col) => {
                     const agg = col.split(".")[0];
                     const rawCol = col.replace(
                        /sum.|avg.|count.|max.|min./g,
                        ""
                     );

                     switch (agg) {
                        case "sum":
                           groupedResult[col] = ab.sumBy(groupedData, rawCol);
                           break;
                        case "avg":
                           groupedResult[col] = ab.meanBy(groupedData, rawCol);
                           break;
                        case "count":
                           groupedResult[col] = (groupedData || []).length;
                           break;
                        case "max":
                           groupedResult[col] =
                              (ab.maxBy(groupedData, rawCol) || {})[rawCol] ||
                              "";
                           break;
                        case "min":
                           groupedResult[col] =
                              (ab.minBy(groupedData, rawCol) || {})[rawCol] ||
                              "";
                           break;
                        default:
                           groupedResult[col] = groupedData[0][col];
                           break;
                     }
                  });

                  return groupedResult;
               });
            }

            return result;
         }

         async getOptions(fields) {
            return [];
         }
         async getFieldData(fieldId) {
            return [];
         }
      }
      class MyLocal extends reports.services.Local {
         constructor(app) {
            super(app);

            this._currentModuleID = "";
         }

         getQueries() {
            const currentModuleID = $$(ids.reportManager).getState().moduleId;

            if (this._currentModuleID !== currentModuleID) {
               this._currentModuleID = currentModuleID;
               this._queries = null;
            }

            return super.getQueries();
         }
      }
      class MyEditor extends reports.views.editor {
         init() {
            super.init();

            if (!self.readonly || settings.editMode === 1) return;

            const $tabbar = this.$$("tabbar");

            if (settings.hideCommonTab === 1) {
               const listener = () => {
                  $tabbar.callEvent("onChange", ["data"]);
                  $tabbar.disableOption("common");
                  self.removeListener("editMode.tabbar.query", listener);
               };

               self.on("editMode.tabbar.query", listener);
            }

            if (settings.hideDataTab === 1) $tabbar.disableOption("other");

            if (settings.hideViewTab === 1) $tabbar.disableOption("structure");

            this.on(this.app, "editMode.button.back", () => {
               this.Reset(true);
            });
         }

         Reset(forceReset = false) {
            const id = this.AppState.moduleId;
            const condition = self.readonly && !(settings.editMode === 1);

            if (!condition || id == null || forceReset) super.Reset();

            this.Local.getModule(id);
         }

         TrackChanges() {
            super.TrackChanges();

            if (settings.hideCommonTab) self.emit("editMode.tabbar.query");
         }
      }
      class MyToolBar extends reports.views.toolbar {
         config() {
            const ui = super.config();

            if (self.readonly && !(settings.editMode === 1)) {
               ui.elements[5].cols = ui.elements[5].cols.map((e) =>
                  Object.assign(e, {
                     hidden: self.readonly && !(settings.editMode === 1),
                  })
               );

               ui.elements[5].cols.push(
                  {},
                  {
                     view: "button",
                     type: "icon",
                     icon: "wxi-angle-double-left",
                     label: self.label("Back"),
                     localId: "forceReset",
                     click: () => {
                        return this.app.callEvent("editMode.button.back", []);
                     },
                  }
               );
            }

            return ui;
         }
      }
      class MyEditorCommon extends reports.views["editor/common"] {
         config() {
            const ui = super.config();

            if (!self.readonly) return ui;

            return Object.assign({}, ui, {
               elements: ui.elements.map((e, i) =>
                  Object.assign(
                     {
                        hidden: !(i >= 2 && i < 5),
                     },
                     e
                  )
               ),
            });
         }

         ShowDeleteButton() {
            super.ShowDeleteButton();

            if (self.readonly) this.$$("delete").hide();
         }
      }
      class MyEditorData extends reports.views["editor/data"] {
         config() {
            const ui = super.config();

            if (self.readonly) {
               ui.rows[0].rows[0].hidden = true;

               ui.rows[0].rows.unshift({
                  label: "Filtering query",
                  view: "label",
                  width: 120,
               });
            }

            return ui;
         }
      }
      class MyTable extends reports.views.table {
         // NOTE: fix format of date column type
         GetColumnConfig(a) {
            let config = {
               id: a.id,
               header:
                  !a.meta.header || a.meta.header === "none"
                     ? a.meta.name || a.name
                     : [
                          a.meta.name || a.name,
                          {
                             content:
                                a.header === "text"
                                   ? "textFilter"
                                   : "richSelectFilter",
                          },
                       ],
               type: a.type,
               sort: "date",
               width: a.width || 200,
            };

            const abField = self.AB.datacollectionByID(
               a.mid
            )?.datasource.fields((field) => field.columnName === a.name)[0];

            switch (a.type) {
               case "date":
                  config.format = (val) => {
                     // check valid date
                     if (val?.getTime && !isNaN(val.getTime()))
                        return abField?.key === "datetime"
                           ? abWebix.i18n.fullDateFormatStr(val)
                           : abWebix.i18n.dateFormatStr(val);
                     else return "";
                  };

                  break;

               default:
                  config = super.GetColumnConfig(a);

                  break;
            }

            return config;
         }

         async GetTableData(mod) {
            const data = await super.GetTableData(mod);
            const buckets = mod.buckets;

            if (!buckets) return data;

            if (buckets.length === 0) return data;

            const columnIDs = mod.columns.map((e) => e.id);
            const parsedBuckets = mod.buckets.filter((bucket) =>
               columnIDs.includes(bucket.column)
            );

            if (parsedBuckets.length === 0) return data;

            const records = data[0].map((e) => {
               const parseRecord = {};

               parsedBuckets.forEach((bucket) => {
                  const options = bucket.options;

                  for (let i = 0; i < options.length; i++)
                     if (
                        options[i].values?.includes(e[bucket.column]) ||
                        i === options.length - 1
                     ) {
                        parseRecord[bucket.column] = options[i].id;

                        break;
                     }
               });

               return Object.assign({}, e, parseRecord);
            });

            return [records, data[1]];
         }
      }

      const _ui = super.ui([
         {
            id: ids.reportManager,
            view: "reports",
            toolbar: true,
            override: new Map([
               [reports.services.Backend, MyBackend],
               [reports.services.Local, MyLocal],
               [reports.views.editor, MyEditor],
               [reports.views.toolbar, MyToolBar],
               [reports.views["editor/common"], MyEditorCommon],
               [reports.views["editor/data"], MyEditorData],
               [reports.views.table, MyTable],
            ]),
         },
      ]);

      delete _ui.type;
      delete _ui.height;

      return _ui;
   }

   async init(AB, accessLevel) {
      this.AB = AB;
      this.readonly = accessLevel < 2;

      const $reportManager = $$(this.ids.reportManager);
      const state = $reportManager.getState();

      state.readonly = this.readonly;
      state.mode =
         this.readonly && this.settings.editMode === 1 ? "edit" : "list";
   }

   getReportFields(dc) {
      if (!dc) return [];

      const object = dc.datasource;
      if (!object) return [];

      const fields = [];

      object.fields().forEach((f) => {
         const columnFormat = f.columnHeader();

         if (!f.isConnection) {
            let type = "text";

            switch (f.key) {
               case "boolean":
               case "number":
               case "date":
                  type = f.key;

                  break;

               case "datetime":
                  type = "date";

                  break;

               default:
                  break;
            }

            fields.push({
               id: f.columnName,
               name: f.label,
               filter: f.fieldIsFilterable(),
               edit: false,
               type: type,
               format: columnFormat.format,
               options: columnFormat.options,
               ref: "",
               key: false,
               show: true,
               abField: f,
            });

            return;
         }

         if (f.isSource()) {
            const linkedDcs = this.view.application.datacollectionsIncluded(
               (dc) =>
                  this.settings.datacollectionIDs.includes(dc.id) &&
                  dc.settings.datasourceID === f.settings.linkObject
            );

            (linkedDcs || []).forEach((linkDc) => {
               fields.push({
                  id: f.id,
                  name: f.label,
                  filter: false,
                  edit: false,
                  type: "reference",
                  ref: linkDc.id,
                  key: false,
                  show: false,
               });
            });
         }
      });

      return fields;
   }

   async getData(datacollectionId) {
      const datacollection = this.AB.datacollectionByID(datacollectionId);
      if (!datacollection) return [];

      const object = datacollection.datasource;
      if (!object) return [];

      await this.waitInitializingDCEvery(1000, datacollection);

      const reportFields = this.getReportFields(datacollection);
      const reportData = [];
      const rawData = datacollection.getData();

      (rawData || []).forEach((row) => {
         const reportRow = { id: row.id };

         reportRow[`${datacollection.id}.id`] = row.id;

         object.fields().forEach((field) => {
            const columnName = field.columnName;
            const col = `${datacollection.id}.${columnName}`;

            if (field) {
               // FK value of the connect field
               if (field.isConnection) {
                  let $pk = field.datasourceLink.PK();
                  if (Array.isArray(row[columnName]))
                     reportRow[`${col}.id`] = row[columnName].map(
                        (link) => link[$pk] || link.id || link
                     );
                  else if (row[columnName])
                     reportRow[`${col}.id`] =
                        row[columnName][$pk] ||
                        row[columnName].id ||
                        row[columnName];
               } else reportRow[col] = field.format(row);
            } else reportRow[col] = row[columnName];

            const rField = reportFields.find(
               (f) => f.id === columnName || f.id === field.id
            );

            if (!rField) return;

            switch (rField.type) {
               case "text":
               case "reference":
                  reportRow[col] = (reportRow[col] || "").toString();
                  break;

               case "number":
                  reportRow[col] = parseFloat(
                     (reportRow[col] || 0).toString().replace(/[^\d.-]/g, "")
                  );
                  break;

               case "date":
                  reportRow[col] = row[columnName];
                  if (reportRow[col]) {
                     if (!(reportRow[col] instanceof Date))
                        reportRow[col] = this.AB.rules.toDate(row[columnName]);
                  } else reportRow[col] = "";
                  break;
            }
         });

         reportData.push(reportRow);
      });

      return reportData;
   }

   async onShow() {
      super.onShow();

      const ids = this.ids;
      const $component = $$(ids.component);

      if ($component != null && !this.__isShowing) {
         this.__isShowing = true;

         $component.reconstruct();
      }
   }
};


/***/ }),

/***/ 79608:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewSchedulerComponent.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewSchedulerComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewScheduler_${baseView.id}`,
         Object.assign(
            {
               scheduler: "",
            },
            ids
         )
      );
   }

   ui() {
      const ids = this.ids;
      const ab = this.AB;
      const self = this;
      const abWebix = this.AB.Webix;
      const settings = this.settings;
      const dc = this.datacollection;
      const fieldName = dc?.datasource.fieldByID(
         settings.dataviewFields.name
      )?.columnName;
      const fieldStart = dc?.datasource.fieldByID(
         settings.dataviewFields.start
      )?.columnName;
      const fieldEnd = dc?.datasource.fieldByID(
         settings.dataviewFields.end
      )?.columnName;
      const fieldAllDay = dc?.datasource.fieldByID(
         settings.dataviewFields.allDay
      )?.columnName;
      const fieldRepeat = dc?.datasource.fieldByID(
         settings.dataviewFields.repeat
      )?.columnName;
      const fieldCalendar = dc?.datasource.fieldByID(
         settings.dataviewFields.calendar
      )?.columnName;
      const fieldEventColor = dc?.datasource.fieldByID(
         settings.dataviewFields.color
      )?.columnName;
      const fieldNotes = dc?.datasource.fieldByID(
         settings.dataviewFields.notes
      )?.columnName;
      const fieldOriginID = dc?.datasource.fieldByID(
         settings.dataviewFields.originID
      )?.columnName;
      const fieldSectionID = dc?.datasource.fieldByID(
         settings.dataviewFields.sectionID
      )?.columnName;
      const fieldUnitID = dc?.datasource.fieldByID(
         settings.dataviewFields.unitID
      )?.columnName;
      const dcCalendar = ab.datacollectionByID(
         this.settings.calendarDataviewID
      );
      const fieldTitle = dcCalendar?.datasource.fieldByID(
         settings.calendarDataviewFields.title
      )?.columnName;
      const fieldCalendarColor = dcCalendar?.datasource.fieldByID(
         settings.calendarDataviewFields.color
      )?.columnName;
      const fieldActive = dcCalendar?.datasource.fieldByID(
         settings.calendarDataviewFields.active
      )?.columnName;
      const timelineOptions = [];

      Object.keys(settings.timeline).forEach((key) => {
         if (settings.timeline[key] === 0) return;

         timelineOptions.push({
            id: `${key}`,
            value: `${key.charAt(0).toUpperCase()}${key.slice(1)}`,
         });
      });

      const _ui = super.ui([
         {
            padding: 6,
            cols: [
               { view: "label", width: 150, label: "Export events data to: " },
               {
                  view: "button",
                  width: 100,
                  value: this.label("Excel"),
                  hidden: settings.export.excel === 0,
                  click: () => {
                     abWebix.toExcel(ids.scheduler);
                  },
               },
               {
                  view: "button",
                  width: 100,
                  value: this.label("CSV"),
                  hidden: settings.export.csv === 0,
                  click: () => {
                     abWebix.toCSV(ids.scheduler);
                  },
               },
               {
                  view: "button",
                  width: 100,
                  value: this.label("PDF"),
                  hidden: settings.export.pdf === 0,
                  click: () => {
                     abWebix.toPDF(ids.scheduler, { autowidth: true });
                  },
               },
               {},
            ],
         },
         {
            id: ids.scheduler,
            view: "scheduler",
            date: new Date(),
            readonly: settings.readonly === 1,
            timeline: settings.timeline.timeline === 1,
            override: new Map([
               [
                  scheduler.services.Backend,
                  class MyBackend extends reports.services.Backend {
                     async addCalendar(obj) {
                        if (dcCalendar == null) return {};

                        const data = {};

                        data[fieldTitle] = obj.text;
                        data[fieldCalendarColor] = obj.color;
                        data[fieldActive] = obj.active;

                        const response = await dcCalendar.model.create(data);

                        return { id: response.id };
                     }
                     async addEvent(obj) {
                        if (dc == null) return {};

                        const data = {};

                        data[fieldName] = obj.text;
                        data[fieldStart] = new Date(obj.start_date);
                        data[fieldEnd] = new Date(obj.end_date);
                        data[fieldAllDay] = obj.all_day;
                        data[fieldRepeat] = obj.recurring;
                        data[fieldCalendar] = obj.calendar;
                        data[fieldEventColor] = obj.color;
                        data[fieldSectionID] = obj.section || "No Section";
                        data[fieldUnitID] = obj.units || "No Unit";
                        data[fieldNotes] = obj.details;
                        data[fieldOriginID] = obj.origin_id;

                        const response = await dc.model.create(data);

                        return { id: response.id };
                     }
                     async calendars() {
                        // if we manage a datacollection, then make sure it has started
                        // loading it's data when we are showing our component.
                        if (dcCalendar == null) return [];

                        await self.waitInitializingDCEvery(1000, dcCalendar);

                        return dcCalendar.getData().map((e) => {
                           return {
                              id: e.id,
                              text: e[fieldTitle],
                              color: e[fieldCalendarColor],
                              active: e[fieldActive],
                           };
                        });
                     }
                     async events(params) {
                        // if we manage a datacollection, then make sure it has started
                        // loading it's data when we are showing our component.
                        if (dc == null) return [];

                        await self.waitInitializingDCEvery(1000, dc);

                        const units = await this.units();
                        const sections = await this.sections();

                        return dc.getData().map((e) => {
                           let unitID = units.find(
                              (u) => u.id === e[fieldUnitID]
                           )?.id;
                           let sectionID = sections.find(
                              (s) => s.id === e[fieldSectionID]
                           )?.id;

                           if (sectionID == null || unitID == null) {
                              sectionID = sectionID || "No Section";
                              unitID = unitID || "No Unit";

                              // const data = {};

                              // data[fieldSectionID] = sectionID;
                              // data[fieldUnitID] = unitID;

                              // dc.model.update(e.id, data);
                           }

                           return {
                              id: e.id,
                              text: e[fieldName],
                              start_date: abWebix.Date.dateToStr(
                                 "%Y-%m-%d %H:%i:%s"
                              )(e[fieldStart]),
                              end_date: abWebix.Date.dateToStr(
                                 "%Y-%m-%d %H:%i:%s"
                              )(e[fieldEnd]),
                              all_day: e[fieldAllDay],
                              recurring: e[fieldRepeat],
                              calendar: e[fieldCalendar],
                              color: e[fieldEventColor],
                              section: sectionID,
                              units: unitID,
                              details: e[fieldNotes],
                              origin_id: e[fieldOriginID],
                           };
                        });
                     }
                     async removeCalendar(id) {
                        await dcCalendar.model.delete(id);
                     }
                     async removeEvent(id) {
                        await dc.model.delete(id);
                     }
                     async sections() {
                        return [
                           { text: "No Section", id: "No Section" },
                        ].concat(
                           settings.timelineSectionList.split(", ").map((e) => {
                              return {
                                 id: e,
                                 text: e,
                              };
                           })
                        );
                     }
                     async units() {
                        return [{ id: "No Unit", value: "No Unit" }].concat(
                           settings.unitList.split(", ").map((e) => {
                              return {
                                 id: e,
                                 value: e,
                              };
                           })
                        );
                     }
                     async updateCalendar(id, obj) {
                        if (dcCalendar == null) return {};

                        const data = {};

                        data[fieldTitle] = obj.text;
                        data[fieldCalendarColor] = obj.color;
                        data[fieldActive] = obj.active;

                        await dcCalendar.model.update(id, data);
                     }
                     async updateEvent(id, obj, mode, date) {
                        if (dc == null) return {};

                        const data = {};

                        data[fieldName] = obj.text;
                        data[fieldStart] = new Date(obj.start_date);
                        data[fieldEnd] = new Date(obj.end_date);
                        data[fieldAllDay] = obj.all_day;
                        data[fieldRepeat] = obj.recurring;
                        data[fieldCalendar] = obj.calendar;
                        data[fieldEventColor] = obj.color;
                        data[fieldSectionID] = obj.section || "No Section";
                        data[fieldUnitID] = obj.units || "No Unit";
                        data[fieldNotes] = obj.details;
                        data[fieldOriginID] = obj.origin_id;

                        await dc.model.update(id, data);
                     }
                  },
               ],
               [
                  scheduler.views["bars/nav"],
                  class CustomBarsView extends scheduler.views["bars/nav"] {
                     config() {
                        const uiNav = super.config();
                        uiNav.width = 160;
                        uiNav.options = timelineOptions;
                        return uiNav;
                     }
                  },
               ],
               [
                  scheduler.views["bars/navpopup"],
                  class CustomNavPopupView extends scheduler.views[
                     "bars/navpopup"
                  ] {
                     config() {
                        const uiNavPopup = super.config();

                        const options = timelineOptions.map((e) =>
                           Object.assign({ icon: `shi-${e.id}` }, e)
                        );

                        if (this.app.config.calendars)
                           uiNavPopup.body.body.rows[0].data = options;
                        else uiNavPopup.body.data = options;

                        return uiNavPopup;
                     }
                  },
               ],
               [
                  scheduler.views["modes/day/multiday"],
                  class CustomModesDayMultiday extends scheduler.views[
                     "modes/day/multiday"
                  ] {
                     LimitData(data) {
                        // Get an error the case when the data parameter is undefined.
                        super.LimitData(data || []);
                     }
                  },
               ],
            ]),
         },
      ]);

      delete _ui.type;

      return _ui;
   }

   async onShow() {
      super.onShow();

      const ids = this.ids;
      const $component = $$(ids.component);

      if ($component != null && !this.__isShowing) {
         this.__isShowing = true;

         $component.reconstruct();
      }
   }
};


/***/ }),

/***/ 59724:
/*!***********************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewTabComponent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewTabComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewTab_${baseView.id}`,
         Object.assign(
            {
               tab: "",

               sidebar: "",
               expandMenu: "",
               collapseMenu: "",

               popupTabManager: "",
               popupTabManagerForm: "",
               popupTabManagerSaveButton: "",
            },
            ids
         )
      );

      this.viewComponents =
         this.viewComponents ||
         baseView
            .views((v) => v.getUserAccess())
            .map((v) => {
               return {
                  view: v,
                  // component: v.component(App)
               };
            });
   }

   ui() {
      const ids = this.ids;
      const baseView = this.view;
      const ab = this.AB;
      const abWebix = ab.Webix;

      let _ui = null;

      // We are going to make a custom icon using the first letter of a menu item for menu items that don't have an icon
      // to do this we need to modify the default template with the method webix recommended form this snippet https://snippet.webix.com/b566d9f8
      abWebix.type(abWebix.ui.tree, {
         baseType: "sideBar", // inherit everything else from sidebar type
         name: "customIcons",
         icon: (obj, common) => {
            if (obj.icon.length)
               return [
                  "<span class='webix_icon webix_sidebar_icon fa fa-fw fa-",
                  obj.icon,
                  "'></span>",
               ].join("");

            return [
               "<span class='webix_icon webix_sidebar_icon sidebarCustomIcon'>",
               obj.value.charAt(0).toUpperCase(),
               "</span>",
            ].join("");
         },
      });

      const viewComponents = this.viewComponents;
      const settings = this.settings;

      if (viewComponents.length > 0) {
         if (settings.stackTabs) {
            // define your menu items from the view components
            const menuItems = viewComponents.map((vc) => {
               const view = vc.view;

               return {
                  id: `${view.id}_menu`,
                  value: view.label,
                  icon: view.tabicon ? view.tabicon : "",
               };
            });

            if (menuItems.length) {
               // create a menu item for the collapse option to use later
               const collapseMenu = {
                  id: ids.collapseMenu,
                  value: this.label("Collapse Menu"),
                  icon: "chevron-circle-left",
               };

               // create a menu item from the expand option to use later
               const expandMenu = {
                  id: ids.expandMenu,
                  value: this.label("Expand Menu"),
                  icon: "chevron-circle-right",
                  hidden: true,
               };

               // find out what the first option is so we can set it later
               let selectedItem = `${viewComponents[0].view.id}_menu`;

               const abStorage = ab.Storage;
               const sidebar = {
                  view: "sidebar",
                  type: "customIcons", // define the sidebar type with the new template created above
                  id: ids.sidebar,
                  height: settings.height,
                  width: settings.sidebarWidth ? settings.sidebarWidth : 0,
                  scroll: true,
                  position: settings.sidebarPos ? settings.sidebarPos : "left",
                  css: settings.darkTheme ? "webix_dark" : "",
                  data: menuItems.concat(collapseMenu), // add you menu items along with the collapse option to start
                  on: {
                     onItemClick: (id) => {
                        // when a menu item is clicked
                        if (id === ids.collapseMenu) {
                           // if it was the collapse menu item
                           setTimeout(() => {
                              const $sidebar = $$(ids.sidebar);

                              // remove the collapse option from the menu
                              $sidebar.remove(ids.collapseMenu);
                              // add the expand option to the menu
                              $sidebar.add(expandMenu);
                              // toggle the sidebar state
                              $sidebar.toggle();
                              // we just clicked the collapse...but we don't wanted highlighted
                              // so highlight the previously selected menu item
                              $sidebar.select(selectedItem);
                              // store this state in local storage the user preference is
                              // remembered next time they see this sidebar
                              abStorage.set(
                                 `${ids.tab}-state`,
                                 $sidebar.getState()
                              );
                           }, 0);
                        } else if (id === ids.expandMenu) {
                           setTimeout(() => {
                              const $sidebar = $$(ids.sidebar);

                              // remove the expand option from the menu
                              $sidebar.remove(ids.expandMenu);
                              // add the collapse option to the menu
                              $sidebar.add(collapseMenu);
                              // toggle the sidebar state
                              $sidebar.toggle();
                              // we just clicked the collapse...but we don't wanted highlighted
                              // so highlight the previously selected menu item
                              $sidebar.select(selectedItem);
                              // store this state in local storage the user preference is
                              // remembered next time they see this sidebar
                              abStorage.set(
                                 `${ids.tab}-state`,
                                 $sidebar.getState()
                              );
                           }, 0);
                        } else {
                           // store the selecte menu item just in case someone toggles the menu later
                           selectedItem = id;
                           // if the menu item is a regular menu item
                           // call the onShow with the view id to load the view

                           id = id.replace("_menu", "");
                           let node = $$(id);
                           if (node) {
                              node.show(false, false);
                           } else {
                              // How often does this occure?
                              let msg = `ABViewTabComponent[${this.name}][${this.id}] could not resolve UI panel for provided menu [${selectedItem}].`;
                              this.AB.notify("developer", msg, {});
                           }
                           // $$(id).show(false, false);

                           // onShow(id);
                        }
                     },
                     onSelectChange: () => {
                        addDataCy();
                     },
                     onAfterRender: () => {
                        addDataCy();
                     },
                  },
               };

               const multiview = {
                  view: "multiview",
                  id: ids.tab,
                  keepViews: true,
                  minWidth: settings.minWidth,
                  cells: viewComponents.map((view) => {
                     const tabUi = {
                        id: view.view.id,
                        // ui will be loaded when its tab is opened
                        view: "layout",
                        rows: [],
                     };

                     return tabUi;
                  }),
                  on: {
                     onViewChange: (prevId, nextId) => {
                        this.onShow(nextId);
                     },
                  },
               };

               const addDataCy = function () {
                  const $sidebar = $$(ids.sidebar);

                  // set ids of controller buttons
                  const collapseNode = $sidebar?.$view.querySelector(
                     `[webix_tm_id="${ids.collapseMenu}"]`
                  );

                  if (collapseNode)
                     collapseNode.setAttribute(
                        "data-cy",
                        `tab-collapseMenu-${ids.collapseMenu}`
                     );

                  const expandNode = $sidebar?.$view.querySelector(
                     `[webix_tm_id="${ids.expandMenu}"]`
                  );

                  if (expandNode)
                     expandNode.setAttribute(
                        "data-cy",
                        `tab-expandMenu-${ids.expandMenu}`
                     );

                  baseView.views((view) => {
                     const node = $sidebar?.$view?.querySelector(
                        `[webix_tm_id="${view.id}_menu"]`
                     );

                     if (!node) {
                        return;
                     }

                     node.setAttribute(
                        "data-cy",
                        `tab-${view.name.replace(" ", "")}-${view.id}-${
                           baseView.id
                        }`
                     );
                  });
               };

               let columns = [sidebar, multiview];

               if (settings.sidebarPos === "right") {
                  columns = [multiview, sidebar];
               }

               _ui = {
                  cols: columns,
               };
            } else
               _ui = {
                  view: "spacer",
               };
         } else {
            const cells = baseView
               .views((view) => {
                  const accessLevel = view.getUserAccess();

                  if (accessLevel > 0) {
                     return view;
                  }
               })
               .map((view) => {
                  const tabUi = {
                     id: view.id,
                     // ui will be loaded when its tab is opened
                     view: "layout",
                     rows: [],
                  };

                  let tabTemplate = "";

                  // tab icon
                  if (view.tabicon) {
                     if (settings.iconOnTop)
                        tabTemplate = [
                           "<div class='ab-tabIconContainer'><span class='fa fa-lg fa-fw fa-",
                           view.tabicon,
                           "'></span><br/>",
                           view.label,
                           "</div>",
                        ].join("");
                     else
                        tabTemplate = [
                           "<span class='fa fa-lg fa-fw fa-",
                           view.tabicon,
                           "'></span> ",
                           view.label,
                        ].join("");
                  }

                  // no icon
                  else tabTemplate = view.label;

                  return {
                     header: tabTemplate,
                     body: tabUi,
                  };
               });

            // if there are cells to display then return a tabview
            if (cells.length) {
               _ui = {
                  rows: [
                     {
                        view: "tabview",
                        id: ids.tab,
                        minWidth: settings.minWidth,
                        height: settings.height,
                        tabbar: {
                           height: 60,
                           type: "bottom",
                           css: settings.darkTheme ? "webix_dark" : "",
                           on: {
                              onAfterRender: () => {
                                 baseView.views((view) => {
                                    const node = $$(
                                       ids.tab
                                    )?.$view?.querySelector(
                                       `[button_id="${view.id}"]`
                                    );

                                    if (!node) return;

                                    node.setAttribute(
                                       "data-cy",
                                       `tab ${view.name} ${view.id} ${baseView.id}`
                                    );
                                 });
                              },
                           },
                        },
                        multiview: {
                           on: {
                              onViewChange: (prevId, nextId) => {
                                 this.onShow(nextId);
                              },
                           },
                        },
                        cells: cells,
                     },
                  ],
               };
            }
            // else we return a spacer
            else
               _ui = {
                  view: "spacer",
               };
         }
      } else
         _ui = {
            view: "spacer",
         };

      _ui = super.ui([_ui]);

      delete _ui.type;

      return _ui;
   }

   async init(AB) {
      await super.init(AB);

      const ids = this.ids;
      const $tab = $$(ids.tab);
      const ab = this.AB;
      const abWebix = ab.Webix;

      if ($tab) abWebix.extend($tab, abWebix.ProgressBar);

      const baseView = this.view;
      const viewComponents = this.viewComponents;

      viewComponents.forEach((vc) => {
         // vc.component.init(AB);

         // Trigger 'changePage' event to parent
         this.eventAdd({
            emitter: vc.view,
            eventName: "changePage",
            listener: (...p) => this.changePage(...p),
         });
      });

      // Trigger 'changeTab' event to parent
      this.eventAdd({
         emitter: baseView,
         eventName: "changeTab",
         listener: (...p) => this.changeTab(...p),
      });

      // initialize the sidebar and figure out if it should be collased or not
      const $sidebar = $$(ids.sidebar);

      if (!$sidebar) return;

      const state = await ab.Storage.get(`${ids.tab}-state`);

      if (!state) return;

      // create a menu item for the collapse option to use later
      const collapseMenu = {
         id: ids.collapseMenu,
         value: this.label("Collapse Menu"),
         icon: "chevron-circle-left",
      };

      // create a menu item from the expand option to use later
      const expandMenu = {
         id: ids.expandMenu,
         value: this.label("Expand Menu"),
         icon: "chevron-circle-right",
         hidden: true,
      };

      // this will collapse or expand the sidebar
      $sidebar.setState(state);

      const checkCollapseMenu = $sidebar.getItem(ids.collapseMenu) ?? null;
      const checkExpandMenu = $sidebar.getItem(ids.expandMenu) ?? null;

      // if the state is collapsed we need to make sure the expand option is available
      if (state.collapsed) {
         if (checkCollapseMenu && checkExpandMenu)
            // $sidebar.remove(ids.collapseMenu);
            $sidebar.add(expandMenu);
      } else if (checkCollapseMenu && checkExpandMenu)
         // $sidebar.remove(ids.collapseMenu);
         $sidebar.add(collapseMenu);
   }

   changePage(pageId) {
      const $tab = $$(this.ids.tab);

      $tab?.blockEvent();
      this.view.changePage(pageId);
      $tab?.unblockEvent();
   }

   changeTab(tabViewId) {
      const baseView = this.view;
      const $tabViewId = $$(tabViewId);

      // switch tab view
      this.toggleParent(baseView.parent);

      if (this.settings.stackTabs)
         if (!$tabViewId.isVisible()) {
            const showIt = setInterval(() => {
               if ($tabViewId.isVisible()) clearInterval(showIt);

               $tabViewId.show(false, false);
            }, 200);
         } else $$(this.ids.tab).setValue(tabViewId);
   }

   toggleParent(view) {
      const $viewID = $$(view.id);

      if (view.key === "tab" || view.key === "viewcontainer") {
         $viewID?.show(false, false);
      }
      if (view.parent) {
         this.toggleParent(view.parent);
      }
   }

   onShow(viewId) {
      const ids = this.ids;

      let defaultViewIsSet = false;

      const $sidebar = $$(ids.sidebar);

      // if no viewId is given, then try to get the currently selected ID
      if (!viewId && $sidebar)
         viewId = $sidebar.getSelectedId().replace("_menu", "");

      const baseView = this.view;
      const viewComponents = this.viewComponents;

      viewComponents.forEach((vc) => {
         // set default view id
         const currView = baseView.views((view) => {
            return view.id === vc.view.id;
         });

         let accessLevel = 0;

         if (currView.length) accessLevel = currView[0].getUserAccess();

         // choose the 1st View if we don't have one we are looking for.
         if (!viewId && !defaultViewIsSet && accessLevel > 0) {
            viewId = vc.view.id;

            defaultViewIsSet = true;
         }

         // create view's component once
         const $tab = $$(ids.tab);
         const settings = this.settings;

         if (!vc?.component && vc?.view?.id === viewId) {
            // show loading cursor
            if ($tab?.showProgress) $tab.showProgress({ type: "icon" });

            vc.component = vc.view.component();

            const $viewID = $$(vc.view.id);
            const ab = this.AB;
            const abWebix = ab.Webix;

            if (settings.stackTabs) {
               // update multiview UI
               abWebix.ui(
                  {
                     // able to 'scroll' in tab view
                     id: vc.view.id,
                     view: "scrollview",
                     css: "ab-multiview-scrollview",
                     body: vc.component.ui(),
                  },
                  $viewID
               );
            } else {
               // update tab UI
               abWebix.ui(
                  {
                     // able to 'scroll' in tab view
                     id: vc.view.id,
                     view: "scrollview",
                     css: "ab-tabview-scrollview",
                     body: vc.component.ui(),
                  },
                  $viewID
               );
            }

            // for tabs we need to look at the view's accessLevels
            accessLevel = vc.view.getUserAccess();

            vc.component.init(ab, accessLevel);

            // done
            setTimeout(() => {
               // $$(v.view.id).adjust();

               $tab?.hideProgress?.();
               // check if tab has a hint
               // if (vc?.view?.settings?.hintID) {
               //    // fetch the steps for the hint
               //    let hint = ab.hintID(vc.view.settings.hintID);
               //    hint.createHintUI();
               // }
            }, 10);
         }

         // show UI
         if (vc?.view?.id === viewId && vc?.component?.onShow)
            vc.component.onShow();

         if (settings.stackTabs && vc?.view?.id === viewId) {
            $$(viewId)?.show(false, false);
            $sidebar?.select(`${viewId}_menu`);
         }
      });
   }
};


/***/ }),

/***/ 97669:
/*!************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewComponent/ABViewTextComponent.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ABViewComponent = (__webpack_require__(/*! ./ABViewComponent */ 44363)["default"]);

module.exports = class ABViewTextComponent extends ABViewComponent {
   constructor(baseView, idBase, ids) {
      super(
         baseView,
         idBase || `ABViewText_${baseView.id}`,
         Object.assign(
            {
               text: "",
            },
            ids
         )
      );
   }

   ui() {
      const ids = this.ids;
      const settings = this.settings;

      const _uiText = {
         id: ids.text,
         view: "template",
         minHeight: 10,
         css: "ab-custom-template",
         borderless: true,
      };

      if (settings.height) _uiText.height = settings.height;
      else _uiText.autoheight = true;

      const _ui = super.ui([_uiText]);

      delete _ui.type;

      return _ui;
   }

   displayText(value) {
      const ids = this.ids;
      const result = this.view.displayText(value, ids.text);

      const $text = $$(ids.text);

      if (!$text) return;

      $text.define("template", result);
      $text.refresh();
   }

   onShow() {
      super.onShow();

      // listen DC events
      const dataview = this.datacollection;
      const baseView = this.view;

      if (dataview && baseView.parent.key !== "dataview") {
         ["changeCursor", "cursorStale"].forEach((key) => {
            baseView.eventAdd({
               emitter: dataview,
               eventName: key,
               listener: (...p) => this.displayText(...p),
            });
         });
      }

      this.displayText();
   }
};


/***/ }),

/***/ 81209:
/*!********************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewProperty.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewProperty)
/* harmony export */ });
/* harmony import */ var _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../ui/ClassUI */ 32019);


class ABViewProperty extends _ui_ClassUI__WEBPACK_IMPORTED_MODULE_0__["default"] {
   // constructor() {}

   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {};
   }

   /** == Property == */
   /**
    * @function propertyComponent
    * return the view and logic to display in property panel
    *
    * @return {Object} - {
    * 						ui: webix element,
    * 						init: function,
    * 						logic: object
    * 					}
    */
   static propertyComponent() {
      let ui = {
         view: "template",
         template: "No UI",
      };

      let init = (options) => {
         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }
      };

      let logic = {
         callbacks: {},
      };

      return {
         ui: ui,
         init: init,
         logic: logic,
      };
   }

   fromSettings(settings) {
      this.settings = settings;
   }

   toSettings() {
      return this.settings || {};
   }

   /** == UI == */
   /**
    * @function component
    * return the view and logic to display in display widget
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    *
    * @return {Object} - {
    * 						ui: webix element,
    * 						init: function,
    * 						logic: object
    * 					}
    */
   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      let ui = {
         view: "template",
         template: "No UI",
      };

      let init = (options) => {
         // register callbacks:
         for (var c in logic.callbacks) {
            logic.callbacks[c] = options[c] || logic.callbacks[c];
         }
      };

      let logic = {
         callbacks: {},
      };

      return {
         ui: ui,
         init: init,
         logic: logic,
      };
   }
}


/***/ }),

/***/ 71695:
/*!***************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyAddPage.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyAddPage)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewProperty */ 81209);
/* harmony import */ var _ABViewFormButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ABViewFormButton */ 44388);
/* harmony import */ var _ABViewFormButton__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ABViewFormButton__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ABViewPDFImporter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ABViewPDFImporter */ 7617);
/* harmony import */ var _ABViewPDFImporter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ABViewPDFImporter__WEBPACK_IMPORTED_MODULE_2__);




let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyAddPage extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         formView: "none", // id of form to add new data
      };
   }

   static propertyComponent(App, idBase) {
      let ids = {
         formView: `${idBase}_formView`,
      };

      let ui = {
         id: ids.formView,
         name: "formView",
         view: "richselect",
         label: L("Add New Form"),
         labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         on: {
            onChange: (newVal, oldVal) => {
               if (newVal == L("No add new option")) {
                  $$(ids.formView).setValue("");
               }

               _logic.callbacks.onSave();
            },
         },
      };

      let _init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      let _logic = {
         callbacks: {
            onSave: function () {
               console.warn("NO onSave()!");
            },
         },

         setSettings: (view, settings = {}) => {
            if (view == null) return;

            // Set the options of the possible edit forms
            let editForms = [
               {
                  id: "none",
                  value: L("No add new option"),
               },
            ];

            let pagesHasForm = view
               .pageRoot()
               .pages((p) => {
                  return p.views((v) => {
                     return (
                        v &&
                        v.key == "form" &&
                        v.datacollection &&
                        v.datacollection.datasource &&
                        v.datacollection.datasource.id ==
                           view.field().settings.linkObject
                     );
                  }, true).length;
               }, true)
               .map((p) => {
                  return {
                     id: p.id,
                     value: p.label,
                  };
               });

            editForms = editForms.concat(pagesHasForm);

            let $selector = $$(ids.formView);
            if ($selector) {
               $selector.define("options", editForms);
               $selector.define(
                  "value",
                  settings.formView || this.default.formView
               );
               $selector.refresh();
            }
         },

         getSettings: (view) => {
            let settings = view.settings || {};

            settings.formView = $$(ids.formView).getValue();

            return settings;
         },
      };

      return {
         ui: ui,
         init: _init,
         setSettings: _logic.setSettings,
         getSettings: _logic.getSettings,
      };
   }

   fromSettings(settings = {}) {
      this.settings = this.settings || {};
      this.settings.formView =
         settings.formView || this.constructor.default.formView;
   }

   getIds(idBase, App) {
      return {
         popup: App._App.unique(`${idBase}_popup_add_new`),
         field: idBase.split("_")[1],
         button: App._App.unique(`${idBase}_popup_add_new_button`),
      };
   }

   component(App, idBase) {
      // This can be overwritten by creating a different getIds before calling .super
      let ids = this.getIds(idBase, App);

      let ui = "";

      if (
         this.settings.formView &&
         this.settings.formView != this.constructor.default.formView
      ) {
         // let iDiv = document.createElement("div");
         // iDiv.className = "ab-connect-add-new";
         const dataCy = `add new CR button ${this.settings.formView} ${ids.field}`;
         // iDiv.innerHTML = `<a href="javascript:void(0);" class="fa fa-plus ab-connect-add-new-link" data-cy="${dataCy}"></a>`;
         // iDiv.appendChild(node);
         // ui = iDiv.outerHTML;
         ui = {
            id: ids.button,
            view: "button",
            type: "icon",
            icon: "fa fa-plus",
            width: 32,
            height: 32,
            css: "webix_primary ab-connect-add-new-link",
            on: {
               onAfterRender: () => {
                  $$(ids.button)
                     ?.$view.querySelector("button")
                     .setAttribute("data-cy", dataCy);
               },
            },
         };
      }

      let _logic = {
         callbacks: {
            onSaveData: (saveData) => {
               if ($$(ids.popup)) $$(ids.popup).close();
            },
            onCancel: () => {
               if ($$(ids.popup)) $$(ids.popup).close();

               return false;
            },
            onClearOnLoad: () => {
               return true;
            },
            clearOnLoad: () => {
               return true;
            },
         },

         applicationLoad: (application) => {
            this._application = application;
         },

         onClick: (dc) => {
            let pageId = this.settings.formView;
            let page = this._application.pages((p) => p.id == pageId, true)[0];

            return _logic.openFormPopup(page, dc);
         },

         /**
          * @method openFormPopup
          *
          * @param page {ABViewPage}
          * @param dc {ABDataCollection}
          */
         openFormPopup: (page, dc) => {
            return new Promise((resolve, reject) => {
               if (this._application == null) return resolve();

               if ($$(ids.popup)) {
                  $$(ids.popup).show();
                  return resolve();
               }

               // Clone page so we modify without causing problems
               let pageClone = page.clone(null, null, { ignoreSubPages: true });
               pageClone.id = this._application.AB.uuid(); // lets take the stored id can create a new dynamic one so our views don't duplicate
               // pageClone.id = pageClone.id + "-" + webix.uid(); // lets take the stored id can create a new dynamic one so our views don't duplicate
               let popUpComp = pageClone.component();
               let ui = popUpComp.ui();

               // Listen 'saved' event of the form widget
               const saveViews =
                  pageClone.views(
                     (v) =>
                        v instanceof (_ABViewFormButton__WEBPACK_IMPORTED_MODULE_1___default()) ||
                        v instanceof (_ABViewPDFImporter__WEBPACK_IMPORTED_MODULE_2___default()),
                     true
                  ) ?? [];

               saveViews.forEach((view) => {
                  const v =
                     view instanceof (_ABViewFormButton__WEBPACK_IMPORTED_MODULE_1___default()) ? view.parent : view;
                  v.on("saved", (savedData) => {
                     _logic?.callbacks?.onSaveData(savedData);
                     // ? is there ever a case where we want to keep an add popup open after saving?
                     // ! setting this to always close

                     if ($$(ids.popup)) {
                        $$(ids.popup).close();
                     } else {
                        var popup = this.getTopParentView();
                        popup.close();
                     }
                  });
               });

               let popupTemplate = {
                  view: "window",
                  id: ids.popup,
                  modal: true,
                  position: "center",
                  // position:function(stthis.__addPageToolate){
                  // 	state.left = x + 20this.__addPageTool; // offset the popups
                  // 	state.top = y + 20;this.__addPageTool
                  // },
                  resize: true,
                  width: parseInt(this.settings.popupWidth) || 700,
                  height: parseInt(this.settings.popupHeight) + 44 || 450,
                  css: "ab-main-container",
                  head: {
                     view: "toolbar",
                     css: "webix_dark",
                     cols: [
                        {
                           view: "label",
                           label: page.label,
                           css: "modal_title",
                           align: "center",
                        },
                        {
                           view: "button",
                           label: L("Close"),
                           autowidth: true,
                           align: "center",
                           click: function () {
                              var popup = this.getTopParentView();
                              popup.close();
                           },
                        },
                     ],
                  },
                  body: {
                     view: "scrollview",
                     scroll: true,
                     body: ui,
                  },
               };

               // Create popup
               webix.ui(popupTemplate).show();

               // Initial UI components
               const accessLevel = 3; // TODO: Is it correct
               popUpComp.init(this._application.AB, accessLevel, {
                  onSaveData: _logic.callbacks.onSaveData,
                  onCancelClick: _logic.callbacks.onCancel,
                  clearOnLoad: _logic.callbacks.clearOnLoad,
                  onClearOnLoad: _logic.callbacks.onClearOnLoad,
               });

               popUpComp.onShow();

               setTimeout(async () => {
                  _logic.setDefaultValue(dc, pageClone);

                  resolve();
               }, 100);
            });
         },

         setDefaultValue: (dc, page) => {
            if (!dc) return;

            let obj = dc.datasource;
            if (!obj) return;

            let linkedData = dc.getCursor();
            if (!linkedData) return;

            page.views().forEach((v) => {
               if (!v || v.key != "form") return;

               v.views().forEach((fView) => {
                  if (fView.key != "connect" || fView.settings == null) return;

                  let field = fView.field();
                  if (field == null) return;

                  let objLink = field.datasourceLink;
                  if (objLink == null || objLink.id != obj.id) return;

                  let data = {};
                  let relationName = field.relationName();
                  data[relationName] = {
                     id: linkedData.id,
                  };

                  // Add custom index values
                  let indexes = obj.indexes() || [];
                  indexes.forEach((idx) => {
                     (idx.fields || []).forEach((f) => {
                        data[relationName][f.columnName] =
                           linkedData[f.columnName];
                     });
                  });

                  // Set label of selected item
                  if (linkedData.text) {
                     data[relationName].text = linkedData.text;
                     data[relationName].value = data[relationName].text;
                  } else {
                     let rawData = {};
                     rawData[relationName] = linkedData;
                     data[relationName].text = field.format(rawData);
                     data[relationName].value = data[relationName].text;
                  }

                  let comp = v.viewComponents[fView.id];
                  if (!comp) return;

                  const ui = typeof comp.ui == "function" ? comp.ui() : comp.ui;
                  const inputId = ui?.inputId || ui?.rows?.[0]?.inputId;

                  if (inputId) field.setValue($$(inputId), data);
               });
            });
         },
      };

      let init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
         if (ui) {
            for (let c in options) {
               ui.on[c] = options[c];
            }
         }
      };

      return {
         ui: ui,
         init: init,

         applicationLoad: _logic.applicationLoad,
         onClick: _logic.onClick,
         openFormPopup: _logic.openFormPopup,
      };
   }
}


/***/ }),

/***/ 39747:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyEditPage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyEditPage)
/* harmony export */ });
/* harmony import */ var _ABViewPropertyAddPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ABViewPropertyAddPage */ 71695);


let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyEditPage extends _ABViewPropertyAddPage__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         editForm: "none", // The url pointer of ABViewForm
      };
   }

   static propertyComponent(App, idBase) {
      let ids = {
         formEdit: `${idBase}_editForm`,
      };

      let ui = {
         id: ids.formEdit,
         name: "editForm",
         view: "richselect",
         label: L("Edit Form"),
         labelWidth: this.AB.UISettings.config().labelWidthXLarge,
         on: {
            onChange: (newVal, oldVal) => {
               if (newVal == L("No add new option")) {
                  $$(ids.formEdit).setValue("");
               }

               _logic.callbacks.onSave();
            },
         },
      };

      let _init = (options) => {
         for (let c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      let _logic = {
         callbacks: {
            onSave: function () {
               console.warn("NO onSave()!");
            },
            clearOnLoad: () => {
               return false; // always false, we're trying to edit data
            },
         },

         setSettings: (view, settings = {}) => {
            if (view == null) return;
            settings.clearOnLoad = false; // doesn't work

            // Set the options of the possible edit forms
            let editForms = [
               {
                  id: "none",

                  value: L("No add new option"),
               },
            ];

            (view.pageRoot().pages(() => true, true) || []).forEach((p) => {
               if (!p) return;

               p.views(() => true, true).forEach((v) => {
                  if (
                     v &&
                     v.key == "form" &&
                     v.datacollection &&
                     v.datacollection.datasource &&
                     v.datacollection.datasource.id ==
                        view.field().settings.linkObject
                  ) {
                     editForms.push({
                        id: v.urlPointer(),
                        value: `${p.label} - ${v.label}`,
                     });
                  }
               });
            });

            let $selector = $$(ids.formEdit);
            if ($selector) {
               $selector.define("options", editForms);
               $selector.define(
                  "value",
                  settings.editForm || this.default.editForm
               );
               $selector.refresh();
            }
         },

         getSettings: (view) => {
            let settings = view.settings || {};

            let $selector = $$(ids.formEdit);
            let $selectPopup = $selector.getPopup();
            let selectedItem = ($selectPopup.config.body.data || []).filter(
               (opt) => opt.id == $selector.getValue()
            )[0];
            if (selectedItem) {
               settings.editForm = selectedItem.id; // The url pointer of ABViewForm
            }

            return settings;
         },
      };

      return {
         ui: ui,
         init: _init,
         setSettings: _logic.setSettings,
         getSettings: _logic.getSettings,
      };
   }

   fromSettings(settings = {}) {
      this.settings = this.settings || {};
      this.settings.editForm =
         settings.editForm || this.constructor.default.editForm;
   }

   component(App, idBase) {
      // Overwrite the popup-lookup function
      function getIds(idBase, App) {
         return {
            popup: App._App.unique(`${idBase}_popup_edit_form`),
            field: idBase.split("_")[1],
         };
      }
      this.getIds = getIds;

      // call to addpage
      let comp = super.component(App, idBase);

      comp.onClick = () => {
         if (
            !this._application ||
            !this.settings.editForm ||
            this.settings.editForm == this.constructor.default.editForm
         )
            return Promise.resolve();

         let form = this._application.urlResolve(this.settings.editForm);
         if (!form) return Promise.resolve();

         let page = form.pageParent();
         if (!page) return Promise.resolve();

         return comp.openFormPopup(page);
      };

      return comp;
   }
}


/***/ }),

/***/ 43348:
/*!******************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyFilterData.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyFilterData)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewProperty */ 81209);
/* harmony import */ var _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../viewComponent/ABViewComponent */ 44363);
/*
 * ABViewPropertyFilterData
 * This is a displayable ui component that will manage displaying a
 * means of searching for the user.
 *
 * This component will emit: "filter.data" when one of the filter options
 * have been enabled.
 *    "filter.data" has 2 parameters: fnFilter, filterRules
 *       fnFilter {function} when passed a row of data from the grid,
 *                return true/false if it passes the filter.
 *       filterRules {array} of each of the filter rules that have been
 *                created. Note: the fnFilter still checks the validity
 *                of the row based on these rules.
 *                (this is used for the parent component to indicate how
 *                many rules are currently applied to the data being displayed)
 */
const ABMLClass = __webpack_require__(/*! ../../ABMLClass */ 70504);



// const ABViewGridFilterRule = require("../../../rules/ABViewGridFilterRule");

let L = (...params) => AB.Multilingual.label(...params);

class FilterRuleSettings extends ABMLClass {
   constructor() {
      super(["label"], AB);
   }

   fromSettings(settings) {
      super.fromValues(settings);
      this.filters = settings.filters;
   }

   toSettings() {
      let obj = super.toObj();
      obj.filters = this.filters;
      return obj;
   }
}

class ABViewPropertyFilterDataComponent extends _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(viewPropertyFilterData, idBase) {
      var base = idBase || viewPropertyFilterData.idBase;
      super(base, {});
   }
}

class ABViewPropertyFilterData extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_1__["default"] {
   constructor(AB, idBase) {
      super(idBase, {
         buttonAddfilter: "",
         filterPanel: "",
         globalFilterFormContainer: "",
         globalFilterForm: "",
         filterMenutoolbar: "",
         resetFilterButton: "",
      });

      this.AB = AB;
      this.idBase = idBase;
      this.object = null;
      // this.queryRules = [];

      this.__externalSearchText = null;
      // {string}
      // External sources of text filters are stored here. This is most likely
      // from the global search toolbar entry.
      this.rowFilter = this.AB.filterComplexNew(`${this.ids.component}_filter`);
      // {RowFilter}
      // When .userFilterPosition == "toolbar" we use this RowFilter to
      // display a form in a popup where the toolbar button is.

      this.rowFilterForm = this.AB.filterComplexNew(
         `${this.ids.component}_filter_form`
      );
      // {RowFilter}
      // When .userFilterPosition == "form" we use this RowFilter to
      // display a form under the toolbar.

      this._handler_rowFilterChanged = (value) => {
         let filterRules = value.rules || [];

         // if ($$(ids.buttonFilter)) {
         //    $$(ids.buttonFilter).define('badge', filterRules.length || null);
         //    $$(ids.buttonFilter).refresh();
         // }

         // be notified when there is a change in the filter
         this.triggerCallback((rowData) => {
            return this.rowFilter.isValid(rowData);
         }, filterRules);
      };

      this._handler_rowFilterFormChanged = () => {
         this.triggerCallback();
      };

      this.initialized = false;
      // {bool}
      // make sure this is not .init() more than once
   }

   /**
    * @property default
    * return default settings
    *
    * @return {Object}
    */
   static get default() {
      return {
         filterOption: 1,
         // {integer}
         // 0 - Not allow
         // 1 - Enable user filter
         // 2 - Predefined filter menu
         // 3 - Global filter input

         // filterOptions == 1 options
         userFilterPosition: "toolbar",
         // {string} the location of the filter:
         //    "toolbar" : there will be an "Add Filters" button on
         //                the toolbar that will trigger the form popup
         //    "form"    : there will be a button under the toolbar that
         //                will bring up the form popup.

         isGlobalToolbar: 1,
         // {boolean|truthy}
         // when "toolbar" is chosen for userFilterPosition, this setting
         // allows us to also include the search criteria specified in
         // the search box on the toolbar.

         // filterOptions == 2 options
         // predefined filters created by the builders. There will be
         // an area under the toolbar that displays buttons to choose
         // between one of the predefined queryRules.
         // queryRules: [], // An array of ABViewGridFilterRule object

         // filterOptions == 3 options
         // globalFilterPosition: "default",
         // {string} [ "default", "single" ]
         //    "default" : shows default grid with all potential matches
         //    "single"  : grid only shows when it has a match.  only 1
         //                match is shown. ( is this true?? )
      };
   }

   /**
    * @method fromSettings
    * Create an initial set of default values based upon our settings object.
    * @param {obj} settings  The settings object we created in .toSettings()
    */
   fromSettings(settings) {
      settings = settings || {};

      settings.filterOption =
         typeof settings.filterOption != "undefined"
            ? settings.filterOption
            : ABViewPropertyFilterData.default.filterOption;

      settings.isGlobalToolbar =
         typeof settings.isGlobalToolbar != "undefined"
            ? settings.isGlobalToolbar
            : ABViewPropertyFilterData.default.isGlobalToolbar;

      this.settings = settings;
   }

   /**
    * @method objectLoad
    * A rule is based upon a Form that was working with an Object.
    * .objectLoad() is how we specify which object we are working with.
    *
    * @param {ABObject} The object that will be used to evaluate the Rules
    */
   objectLoad(object) {
      this.object = object;

      if (this.rowFilter) {
         // this.rowFilter.applicationLoad(object.application);
         this.rowFilter.fieldsLoad(object.fields());
      }

      if (this.rowFilterForm) {
         // this.rowFilterForm.applicationLoad(object.application);
         this.rowFilterForm.fieldsLoad(object.fields());
      }
   }

   viewLoad(view) {
      this.view = view;
   }

   /** == UI == */
   ui() {
      var self = this;
      var ids = this.ids;

      return {
         id: ids.filterPanel,
         type: "space",
         borderless: true,
         padding: 0,
         hidden: true,
         rows: [
            {
               id: ids.globalFilterFormContainer,
               hidden: true,
               cols: [
                  {
                     id: ids.globalFilterForm,
                     view: "text",
                     placeholder: L("Search or scan a barcode to see results"),
                     on: {
                        onTimedKeyPress: () => {
                           this.triggerCallback();
                        },
                     },
                  },
                  {
                     view: "button",
                     css: "webix_primary",
                     width: 28,
                     type: "icon",
                     icon: "fa fa-times",
                     click: function () {
                        var $form = $$(ids.globalFilterForm);
                        $form.setValue("");
                        $form.focus();
                        $form.callEvent("onTimedKeyPress");
                     },
                  },
               ],
            },
            {
               id: ids.buttonAddfilter,
               view: "button",
               css: "webix_primary",
               value: L("Add Filter"),
               click: () => {
                  this.rowFilterForm.popUp($$(ids.buttonAddfilter).getNode(), {
                     pos: "bottom",
                  });
               },
            },
            {
               view: "toolbar",
               id: ids.filterMenutoolbar,
               css: "ab-data-toolbar",
               hidden: true,
               cols: [
                  {
                     view: "button",
                     css: "webix_primary",
                     id: ids.resetFilterButton,
                     label: L("Reset Filter"),
                     icon: "fa fa-ban",
                     type: "icon",
                     // badge: 0,
                     autowidth: true,
                     click: function () {
                        self.resetFilter();
                     },
                  },
               ],
            },
         ],
      };
   }

   async init(AB) {
      if (AB) {
         this.AB = AB;
      }

      var ids = this.ids;
      // this.filter_popup = webix.ui({
      //    view: "popup",
      //    id: ids.component,
      //    width: 600,
      //    height: 400,
      //    hidden: true,
      //    body: this.rowFilter.ui,
      // });

      this.rowFilter.init();
      this.rowFilter.removeListener("changed", this._handler_rowFilterChanged);
      this.rowFilter.on("changed", this._handler_rowFilterChanged);

      this.rowFilterForm.init();
      this.rowFilterForm.removeListener(
         "changed",
         this._handler_rowFilterFormChanged
      );
      this.rowFilterForm.on("changed", this._handler_rowFilterFormChanged);
      this.rowFilterForm.removeListener(
         "save",
         this._handler_rowFilterFormChanged
      );
      this.rowFilterForm.on("save", this._handler_rowFilterFormChanged);

      $$(ids.filterPanel)?.hide();
      $$(ids.buttonAddfilter)?.hide();
      $$(ids.filterMenutoolbar)?.hide();
      $$(ids.globalFilterFormContainer)?.hide();

      switch (this.settings.filterOption) {
         case 0:
            break;
         case 1:
            switch (this.settings.userFilterPosition) {
               case "form":
                  $$(ids.buttonAddfilter)?.show();
                  $$(ids.filterPanel)?.show();
                  break;
               case "toolbar":
                  $$(ids.filterPanel)?.hide();
                  break;
            }
            break;
         case 2:
            $$(ids.filterPanel)?.show();
            var $filterMenutoolbar = $$(ids.filterMenutoolbar);
            if ($filterMenutoolbar) {
               $filterMenutoolbar.show();

               // populate filter items
               if (this.settings?.queryRules) {
                  (this.settings.queryRules || []).forEach((qr) => {
                     let Rule = new FilterRuleSettings();
                     Rule.fromSettings(qr);
                     var filterRuleButton = {
                        view: "button",
                        css: "webix_primary",
                        label: Rule.label,
                        icon: "fa fa-filter",
                        type: "icon",
                        // badge: 0,
                        autowidth: true,
                        click: () => {
                           this.emit("filter.data", null, Rule.filters);
                           // this.selectFilter(qr.filter);
                        },
                     };
                     $filterMenutoolbar.addView(filterRuleButton);
                  });
               }
            }
            break;
         case 3:
            $$(ids.globalFilterFormContainer)?.show();
            $$(ids.filterPanel)?.show();
            break;
      }
   }

   filterRules() {
      let rowFilterRules = null;

      switch (this.settings.userFilterPosition) {
         case "form":
            rowFilterRules = this.rowFilterForm.getValue();
            break;
         case "toolbar":
            rowFilterRules = this.rowFilter.getValue();
            break;
      }

      return rowFilterRules;
   }

   /**
    * @method getFilter()
    * Return a fn() that returns {truthy} with a given row of
    * data.
    */
   getFilter() {
      // default filter
      if (this.__currentFilter == null) {
         // if empty search text in global single mode, then no display rows
         if (
            this.settings.filterOption == 3 &&
            this.settings.globalFilterPosition == "single"
         )
            this.__currentFilter = (/* row */) => {
               return false;
            };
         // always true, show every rows
         else
            this.__currentFilter = (/* row */) => {
               return true;
            };
      }

      return this.__currentFilter;
   }

   /**
    * @method triggerCallback()
    * We compile our current search options and emit them back to our
    * parent container.
    */
   triggerCallback(/*fnFilter, filterRules*/) {
      let searchRules = this.searchText(this.__externalSearchText);
      let rowFilterRules = this.filterRules();

      let badgeCount = 0;
      if (rowFilterRules?.rules?.length) {
         badgeCount = rowFilterRules?.rules?.length;
         if (searchRules) {
            badgeCount++;
            rowFilterRules = {
               glue: "and",
               rules: [rowFilterRules, searchRules],
            };
         }
      } else {
         rowFilterRules = searchRules;
      }

      this.emit("filter.data", null, rowFilterRules);

      if (badgeCount == 0) badgeCount = false;
      const $button = $$(this.ids.buttonAddfilter);
      if ($button) {
         $button.config.badge = badgeCount;
         $button.refresh();
      }
   }

   resetFilter() {
      this.triggerCallback(() => true, []);
   }

   /**
    * @method externalSearchText()
    * Save any search criteria established from outside this filterHelper.
    * NOTE: The ABViewGrid has a toolbar search entry that will provide
    * this value.
    * @param {string} search
    *        The typed in search criteria.
    */
   externalSearchText(search = null) {
      this.__externalSearchText = search;
      this.triggerCallback(); // update each time
   }

   /**
    * @method searchText()
    * Retrieve the typed in search terms from the user, and convert them
    * into a set of Rules that will modify our results.
    * If an external search param is provided, use that instead.
    * @param {string} externalText
    * @return {json} The QB Rule condition for the search criteria
    */
   searchText(externalText) {
      var search;
      if (externalText) {
         search = externalText;
      } else {
         search = ($$(this.ids.globalFilterForm)?.getValue() ?? "").trim();
      }
      if (!search) return null; // <-- includes ""

      // find the individual "terms" that we should search for
      let terms = search.trim().toLowerCase().split(" ");

      // build a set of conditions for each term
      var allTerms = [];

      var allFields = this.object?.fields() || [];

      terms.forEach((t) => {
         var fieldTerms = [];

         // for each field, add a match condition for that field
         // (if the field applies)
         allFields.forEach((f) => {
            if (f.fieldIsFilterable()) {
               switch (f.key) {
                  case "number":
                  case "string":
                  case "LongText":
                  case "email":
                     fieldTerms.push({
                        key: f.id,
                        rule: "contains",
                        value: t,
                     });
                     break;

                  case "list":
                     var options = f.options();
                     options.forEach((o) => {
                        if (o.text.indexOf(t) > -1) {
                           fieldTerms.push({
                              key: f.id,
                              rule: "equals",
                              value: o.id,
                           });
                        }
                     });
                     break;
               }
            }
         });

         if (fieldTerms.length > 0) {
            allTerms.push({
               glue: "or",
               rules: fieldTerms,
            });
         }
      });

      if (allTerms.length > 0) {
         var searchRules = {
            glue: "and",
            rules: allTerms,
         };
         return searchRules;
      } else {
         return null;
      }
   }

   showPopup($view) {
      // this.filter_popup.show($view, null, { pos: "top" });
      this.rowFilter.popUp($view, null, { pos: "center" });
   }
}


/***/ }),

/***/ 25733:
/*!****************************************************************************!*\
  !*** ./AppBuilder/platform/views/viewProperties/ABViewPropertyLinkPage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABViewPropertyLinkPage)
/* harmony export */ });
/* harmony import */ var _ABViewProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ABViewProperty */ 81209);
/* harmony import */ var _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../viewComponent/ABViewComponent */ 44363);



let L = (...params) => AB.Multilingual.label(...params);

class ABViewPropertyLinkPageComponent extends _viewComponent_ABViewComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(linkPageHelper, idBase) {
      let base = idBase || `ABViewPropertyLinkPage_xxx`;
      super(base, {});

      this.linkPageHelper = linkPageHelper;
      this.AB = linkPageHelper.AB;

      this.view = null;
      // {ABViewXXXX}
      // the ABView object this link references.

      this.datacollection = null;
      // {ABDataCollection}
      // The related Datacollection to this view that drives it's data.
      // we usually have to set the cursor before the view displays the
      // appropriate data.
   }

   ui() {
      return {};
   }

   init(options) {
      if (options.view) this.view = options.view;

      if (options.datacollection) this.datacollection = options.datacollection;
   }

   changePage(pageId, rowId) {
      if (this.datacollection) {
         this.datacollection.once("changeCursor", () => {
            this.view?.changePage(pageId);
         });
         this.datacollection.setCursor(rowId);
      } else {
         this.view?.changePage(pageId);
      }
   }
}

class ABViewPropertyLinkPage extends _ABViewProperty__WEBPACK_IMPORTED_MODULE_1__["default"] {
   // constructor() {
   //    super();
   // }

   /** == UI == */
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   component(v1App = false) {
      let component = new ABViewPropertyLinkPageComponent(this);

      // if this is our v1Interface
      if (v1App) {
         var newComponent = component;
         component = {
            ui: newComponent.ui(),
            init: (...params) => {
               return newComponent.init(...params);
            },
            onShow: (...params) => {
               return newComponent.onShow?.(...params);
            },
            changePage: (...params) => {
               return newComponent.changePage(...params);
            },
         };
      }

      return component;
   }
}


/***/ }),

/***/ 25358:
/*!*********************************************************************!*\
  !*** ./AppBuilder/rules/ABViewQueryBuilderObjectFieldConditions.js ***!
  \*********************************************************************/
/***/ ((module) => {

//
// ABViewQueryBuilderObjectFieldConditions
//
// A UI component that is responsible for displaying a QueryBuilder based upon
// the fields of a given ABObject.
//
// This object is also responsible for saving it's state to a settings value,
// and generating the settings value to be saved.

module.exports = class ABViewQueryBuilderObjectFieldConditions {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(label) {
      this.label = label;
      this.ui = null;
   }

   /**
    * cleanRules
    * walk through all the QueryBuilder (QB) rules and make conversions
    * of the data into their proper formats.
    * @param {obj} rules  the {rules} obj that is returned from the QB object
    * @param {array} fields  an array of field definitions from the QB object
    * @param {bool} dateToString  convert Dates to String format?
    */
   cleanRules(rules, fields, dateToString) {
      if (typeof dateToString == "undefined") dateToString = true;

      // walk the given condition rules / values, walk them and make sure
      // any given rules have properly formatted values.
      function processCondition(rule) {
         // make sure rule is provided
         if (rule) {
            if (rule.glue && rule.rules) {
               rule.rules.forEach((r) => {
                  processCondition(r);
               });
            } else {
               // converting a single rule:

               var field = fields.filter((f) => {
                  return f.id == rule.key;
               })[0];
               if (field) {
                  switch (field.type) {
                     case "number":
                     case "formula":
                        // when getting data from the server, the numbers are
                        // sent back as strings ("100.25").
                        // make sure to convert strings to numbers:
                        if (typeof rule.value == "string") {
                           if (rule.value.indexOf(".") == -1) {
                              rule.value = parseInt(rule.value);
                           } else {
                              rule.value = parseFloat(rule.value);
                           }
                        }
                        break;
                     case "date":
                        // in some cases we want to convert the Date() object returned
                        // by QueryBuilder into a string for saving on the Server.
                        if (dateToString) {
                           // if we have a Date() obj returned from QueryBuilder,
                           // convert to a string format:
                           if (rule.value instanceof Date) {
                              rule.value = webix.i18n.dateFormatStr(rule.value);
                           }
                        } else {
                           // in other cases we want to convert the string returned
                           // by the server into a Date() for the QB
                           if (typeof rule.value == "string") {
                              rule.value = new Date(rule.value);
                           }
                        }

                        break;
                  }
               }
            }
         }
      }
      processCondition(rules);
   }

   // component
   // initialize the UI display for this popup editor.
   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      var L = App.Label;

      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return this.unique(idBase + key ) + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         component: myUnique("qbObjectFieldConditions"),
         queryBuilder: myUnique("qBuilder"),
         queryBuilderContainer: myUnique("qBuilderContainer"),
         queryBuilderLayout: myUnique("qBuilderLayout"),
         showQBButton: myUnique("showQBButton"),
      });

      // webix UI definition:
      this.ui = {
         view: "layout",
         id: ids.queryBuilderLayout,
         hidden: true,
         type: "line",
         rows: [
            {
               id: ids.showQBButton,
               cols: [
                  { fillspace: true },
                  {
                     view: "button",
                     css: "webix_primary",
                     name: "addqb",
                     value: L("Add Custom Conditions"),
                     autowidth: true,
                     click: function () {
                        $$(ids.queryBuilderContainer).show();
                        $$(ids.showQBButton).hide();
                        // _logic.buttonCancel();
                     },
                  },
                  { fillspace: true },
               ],
            },
            {
               hidden: true,
               id: ids.queryBuilderContainer,
               cols: [
                  {
                     view: "querybuilder",
                     id: ids.queryBuilder,
                     fields: this.conditionFields(),
                  },
               ],
            },
         ],
      };

      // tack on a label if provided.
      if (this.label) {
         this.ui.rows[1].cols.unshift({
            view: "label",
            css: "ab-text-bold",
            label: this.label,
            width: this.AB.UISettings.config().labelWidthLarge,
         });
      }

      // for setting up UI
      this.init = (options) => {
         options = options || {};

         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onCancel: function () {
               console.warn("NO onCancel()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         /**
          * cleanRules
          * walk through all the QueryBuilder (QB) rules and make conversions
          * of the data into their proper formats.
          * @param {obj} rules  the {rules} obj that is returned from the QB object
          * @param {array} fields  an array of field definitions from the QB object
          * @param {bool} dateToString  convert Dates to String format?
          */
         cleanRules: (rules, fields, dateToString) => {
            this.cleanRules(rules, fields, dateToString);
         },

         getValue: () => {
            var values = null;
            var QB = $$(ids.queryBuilder);
            if (QB) {
               values = QB.getValue();
            }

            // convert dates to simpler format:
            // by default we're getting long values: "Mon Feb 2, 2018 GMT xxxxxxx",
            // and webix doesn't seem to understand them when we send them back.
            // so save simple date values: "mm/dd/yyyy"
            if (values) {
               _logic.cleanRules(values[0], values[1], true);
            }

            return values;
         },

         setValue: (values) => {
            values = values || [];
            if (!Array.isArray(values)) values = [values];
            if (values.length == 0) {
               values.push({});
            } // push default rules
            if (values.length < 2) {
               values.push(this.conditionFields());
            }

            // convert dates from our server side "string" format into
            // Date() objects.
            _logic.cleanRules(values[0], values[1], false);

            var QB = $$(ids.queryBuilder);
            if (QB) {
               if (values[0] && values[0].rules && values[0].rules.length) {
                  QB.setValue(values[0]);
                  $$(ids.queryBuilderContainer).show();
                  $$(ids.showQBButton).hide();
               }
            }
         },
      });

      this.getValue = _logic.getValue;
      this.show = _logic.show;
      this.setValue = _logic.setValue;
   }

   objectLoad(object) {
      this.currentObject = object;
   }

   // conditionFields()
   // Return the list of fields we are able to update.
   // @return {array} of querybuilder field definitions:
   //					[
   // 						{ id:"fname",   value:"First Name", type:"string" },
   //					    { id:"lname",   value:"Last Name",  type:"string" },
   //					    { id:"age",     value:"Age",        type:"number" },
   //					    { id:"bdate",   value:"Birth Date", type:"date" }
   //					]
   conditionFields() {
      var fieldTypes = [
         "string",
         "LongText",
         "number",
         "date",
         "email",
         "formula",
         "calculate",
      ];

      var currFields = [];

      if (this.currentObject) {
         this.currentObject.fields().forEach((f) => {
            if (fieldTypes.indexOf(f.key) != -1) {
               // NOTE: the .id value must match the obj[.id]  in the data set
               // so if your object data looks like:
               // 	{
               //		name_first:'Neo',
               //		name_last: 'The One'
               //  },
               // then the ids should be:
               // { id:'name_first', value:'xxx', type:'string' }

               let type = f.key;
               if (f.key == "formula" || f.key == "calculate") type = "number";
               else if (f.key == "LongText") type = "string";

               currFields.push({
                  id: f.columnName,
                  value: f.label,
                  type: type,
               });
            }
         });
      }

      return currFields;
   }

   // process
   // Take the provided data and process each of our rules.
   // @param {obj} options
   // @return {promise}
   process(options) {
      return new Promise((resolve, reject) => {
         var numDone = 0;
         var onDone = () => {
            numDone++;
            if (numDone >= this.listRules.length) {
               resolve();
            }
         };

         this.listRules.forEach((rule) => {
            rule
               .process(options)
               .then(function () {
                  onDone();
               })
               .catch((err) => {
                  reject(err);
               });
         });

         if (this.listRules.length == 0) {
            resolve();
         }
      });
   }

   showQueryBuilderContainer() {
      $$(this.ids.queryBuilderLayout).show();
      $$(this.ids.queryBuilderContainer).show();
      $$(this.ids.showQBButton).hide();
   }

   // // fromSettings
   // // Create an initial set of default values based upon our settings object.
   // // @param {obj} settings  The settings object we created in .toSettings()
   // fromSettings (settings) {
   // 	// settings: [
   // 	//  { rule.settings },
   // 	//  { rule.settings }
   // 	// ]

   // 	// clear any existing Rules:
   // 	this.listRules.forEach((rule)=>{
   // 		$$(this.ids.rules).removeView(rule.ids.component);
   // 	})
   // 	this.listRules = [];

   // 	if (settings) {
   // 		settings.forEach((ruleSettings)=>{
   // 			this.addRule(ruleSettings);
   // 		})
   // 	}
   // }

   // // toSettings
   // // create a settings object to be persisted with the application.
   // // @return {array} of rule settings.
   // toSettings () {
   // 	var settings = [];
   // 	this.listRules.forEach((r)=>{
   // 		settings.push(r.toSettings());
   // 	})
   // 	return settings;
   // }
};


/***/ }),

/***/ 17172:
/*!****************************************!*\
  !*** ./AppBuilder/rules/ABViewRule.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRule
//
// A component that manages an individual Rule in a Rule list.
//
// Each rule can manage a set of given Actions.  For each Rule, one Action
// can be chosen, A condition for when that action is executed, and then
// inputs for any additional data required by that action.
//
// Rules are used in the Interface Builder to present the designer an interface
// for defining the Action+Condition:
//
//
//
// In live apps, Rules are used when processing events and determining if an
// action is to be performed:
//
//
//
// A Rule needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//
const ObjectQueryBuilder = __webpack_require__(/*! ./ABViewQueryBuilderObjectFieldConditions */ 25358);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRule {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(listActions) {
      this.listActions = listActions || []; // the list of Actions this Rule manages

      this.actionDropList = []; // the Webix UI droplist
      this.listActions.forEach((a) => {
         this.actionDropList.push({ id: a.key, value: a.label });
      });

      this.selectedAction = null; // the currently selected Action.key
      if (this.actionDropList.length > 0) {
         this.selectedAction = this.actionDropList[0].id;
      }

      this.removable = true; // can I delete this rule?

      this.currentObject = null; // What ABObject is this associated with
      // NOTE: this is important for Actions.

      this.objectQB = null; // The QueryBuilder (QB) object

      this.currentForm = null;
   }

   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      // this is different because multiple instances of this View can be displayed
      // at the same time.  So make each instance Unique:
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return this.unique(idBase + key ) + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         // each instance must be unique
         component: myUnique("component"),

         selectAction: myUnique("chooseAction"),

         queryBuilder: myUnique("queryBuilder"),

         valueDisplay: myUnique("valueArea"),
      });

      this.objectQB.label = L("When");
      this.objectQB.component(this.App, this.idBase);
      this.ui = this._generateUI();

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         this.objectQB.init();

         // make sure the current Action's value display is initialized:
         var Action = this.currentAction();
         if (Action) {
            Action.component(this.App, this.idBase);
            var comp = Action.valueDisplay(ids.valueDisplay);

            _logic.replaceValueDisplay(comp);

            // webix.ui(comp.ui, $$(this.ids.valueDisplay));
            comp.init();
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onDelete: function () {
               console.warn("NO onDelete()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         replaceValueDisplay: (component) => {
            // remove current content area:
            var $ValueDisplay = $$(this.ids.valueDisplay);
            if (!$ValueDisplay) return;

            var children = $ValueDisplay.getChildViews();
            var cloneChildren = [];
            children.forEach((c) => {
               cloneChildren.push(c);
            });
            cloneChildren.forEach((c) => {
               $ValueDisplay.removeView(c);
            });

            $ValueDisplay.addView(component.ui);
         },

         selectAction: (newValue, oldVal) => {
            if (newValue) {
               $$(this.ids.component)
                  .getChildViews()
                  .forEach((views) => {
                     views.show();
                  });
            }
            // bonus:  save current state of previous Action
            var prevAction = this.getAction(oldVal);
            if (prevAction) {
               prevAction.stashCondition(this.objectQB.getValue());
            }

            // now switch to the new Action
            this.selectedAction = newValue;
            var currAction = this.currentAction();
            if (currAction) {
               // reset Condition filters.
               this.objectQB.setValue(currAction.condition());

               // have Action display it's values form
               currAction.component(this.App, this.idBase);
               var component = currAction.valueDisplay(ids.valueDisplay);
               _logic.replaceValueDisplay(component);
               component.init();
               // currAction.valueDisplay(ids.valueDisplay);
            }
         },
      });
   }

   // not intended to be called externally
   _generateUI() {
      return {
         id: this.ids.component,
         view: "layout",
         css: "ab-component-form-rules",
         padding: 20,
         // margin: 10,

         // this should be a CSS setting: this.AB.Config.xxxx
         // width: 680,
         type: "line",
         rows: [
            {
               view: "template",
               css: "ab-component-form-rules-delete",
               template: '<i class="fa fa-trash ab-component-remove"></i>',
               height: 30,
               borderless: true,
               hidddatasourceen: this.removable == false,
               onClick: {
                  "ab-component-remove": (e, id, trg) => {
                     this._logic.callbacks.onDelete(this);
                  },
               },
            },
            // Action
            {
               id: this.ids.selectAction,
               view: "richselect",
               label: L("Action"),
               placeholder: L("Choose an action"),
               labelWidth: this.AB.UISettings.config().labelWidthLarge,
               options: this.actionDropList,
               on: {
                  onChange: (newVal, oldVal) => {
                     this._logic.selectAction(newVal, oldVal);
                  },
               },
            },

            // Values
            {
               for: "values",
               hidden: true,
               cells: [
                  {
                     view: "layout",
                     cols: [
                        {
                           view: "label",
                           label: L("Values"),
                           css: "ab-text-bold",
                           width: this.AB.UISettings.config().labelWidthLarge,
                        },
                        {
                           id: this.ids.valueDisplay,
                           view: "layout",
                           rows: [
                              {
                                 label: L(
                                    " ABViewRule: This should be the Set Area"
                                 ),
                                 css: "ab-text-bold",
                                 height: 30,
                              },
                           ],
                        },
                     ],
                  },
               ],
            },

            // When
            this.objectQB.ui,
         ],
      };
   }

   // return the QueryBuilder fields data for the currently selected Action.
   conditionFields() {
      var fields = [];

      var selectedAction = this.currentAction();
      if (selectedAction) {
         fields = selectedAction.conditionFields();
      }

      return fields;
   }

   currentAction() {
      return this.getAction(this.selectedAction);
   }

   getAction(key) {
      return this.listActions.filter((a) => {
         return a.key == key;
      })[0];
   }

   objectLoad(object) {
      this.currentObject = object;
      this.listActions.forEach((a) => {
         a.objectLoad(object);
      });

      var label = L("When");

      this.objectQB = new ObjectQueryBuilder(label);
      this.objectQB.objectLoad(object);

      // regenerate our UI when a new object is loaded.
      if (this.ids) {
         this.ui = this._generateUI();
      }
   }

   formLoad(form) {
      this.currentForm = form;
      this.listActions.forEach((a) => {
         a.formLoad(form);
      });
   }

   processPre(options = {}) {
      let isValid = this.isValid(options.data);
      if (!isValid) return;

      let currentAction = this.currentAction();
      if (!currentAction) return;

      currentAction.processUpdateObject({}, options.data);
   }

   // process
   // Take the provided data and process this rule
   // @param {obj} options
   // @return {Promise}
   process(options) {
      var currentAction = this.currentAction();
      if (!currentAction) return Promise.resolve();

      let isValid = this.isValid(options.data);
      if (isValid) {
         return currentAction.process(options);
      } else {
         // else just resolve and continue on
         return new Promise((resolve, reject) => {
            resolve();
         });
      }
   }

   fromSettings(settings) {
      settings = settings || {};

      if (settings.selectedAction) {
         // store our Query Rules
         this.selectedAction = settings.selectedAction;
         var selectedAction = this.currentAction();
         if (!selectedAction) return;
         selectedAction.stashCondition(settings.queryRules || {});

         // if our UI components are present, populate them properly:
         if (this.ids) {
            // Trigger our UI to refresh with this selected Action:
            // NOTE: this also populates the QueryBuilder
            $$(this.ids.selectAction).setValue(this.selectedAction);
            // this._logic.selectAction(this.selectedAction);
         }

         // now continue with setting up our settings:
         selectedAction.fromSettings(settings.actionSettings);
      }
   }

   toSettings() {
      var settings = {};

      if (this.selectedAction) {
         settings.selectedAction = this.selectedAction;
         settings.queryRules = this.objectQB.getValue();
         let currentAction = this.currentAction();
         if (currentAction) {
            settings.actionSettings = currentAction.toSettings();
         }
      }

      return settings;
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      var currAction = this.currentAction();
      if (currAction && this.objectQB) {
         this.objectQB.setValue(currAction.condition());
         currAction.qbFixAfterShow();
      }
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   async isReady() {
      let currentAction = this.currentAction();
      if (currentAction) {
         return currentAction.isReady();
      }
      return Promise.resolve();
   }

   isValid(data = {}) {
      const fields = this.currentObject.fields(),
         currentAction = this.currentAction(),
         QBCondition = currentAction.condition(),
         query = QBCondition[0] ?? {};

      const convertToNumber = (text = "") => {
         // if we have multiple rules we need to check if value is already a number before converting.
         if (typeof text == "number") return text;

         return parseFloat(text.replace(/[^-0-9.]/g, ""));
      };

      // Fix string data in number type
      // NOTE: "1000" > "99" = false    >_<!
      fields
         .filter(
            (f) =>
               f.key == "number" || f.key == "calculate" || f.key == "formula"
         )
         .forEach((f) => {
            try {
               // filter conditions
               if (Array.isArray(query?.rules)) {
                  query.rules.forEach((r) => {
                     // NOTE: compatible with old settings
                     if (r.key == f.id || r.key == f.columnName)
                        r.value = convertToNumber(r.value);
                  });
               }

               // row data
               if (
                  data[f.columnName] &&
                  typeof data[f.columnName] === "string"
               ) {
                  data[f.columnName] = convertToNumber(data[f.columnName]);
               }
            } catch (e) {
               // continue regardless of error
            }
         });

      const hiddenFilter = (this.AB ?? AB).filterComplexNew(
         `${this.idBase}_filter_complex`
      );
      hiddenFilter.fieldsLoad(fields, this.currentObject);
      hiddenFilter.setValue(query);
      hiddenFilter.init();

      return hiddenFilter.isValid(data);

      // var id = "hiddenQB_" + webix.uid();

      // // if our data passes the QueryRules then tell Action to process
      // var ui = {
      //    id: id,
      //    hidden: true,
      //    view: "querybuilder",
      // };
      // var hiddenQB = webix.ui(ui);

      // let currentAction = this.currentAction();
      // var QBCondition = currentAction.condition();

      // if (this.objectQB) {
      //    this.objectQB.cleanRules(QBCondition[0], QBCondition[1], false);
      // }

      // let query = QBCondition[0] || {},
      //    fields = QBCondition[1] || [];

      // // hiddenQB.setValue(QBCondition);
      // hiddenQB.setValue({
      //    query: query,
      //    fields: fields,
      // });

      // var QBHelper = hiddenQB.getFilterHelper();
      // var isValid = QBHelper(data);

      // hiddenQB.destructor(); // remove the QB

      // return isValid;
   }

   get isPreProcess() {
      let currentAction = this.currentAction();
      return currentAction.isPreProcess || false;
   }
};


/***/ }),

/***/ 59816:
/*!**********************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleAction.js ***!
  \**********************************************/
/***/ ((module) => {

//
// ABViewRuleAction
//
// A component that manages an individual Action in a Rule.
//
// Each Action is responsible for figuring out when it can run, and what to do.
//
// Actions are used in the Interface Builder to present the designer an interface
// for defining the a Condition and a set of data necessary to complete the Action:
//
//
//
// In live apps, Actions are used when processing events and determining if an
// if and what is to be performed:
//
//
//
// An Action needs to save it's current state to an objects settings, and to
// initialize itself from those settings.
//

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleAction {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    * @param {ABViewForm} currentForm	the current form this Action is associated with.
    */
   constructor(App, idBase, currentForm) {
      this.key = "ABViewRuleAction";

      this.queryObject = null; // the current ABObject we use to create QueryBuilder information.

      this.currentForm = null;

      this.queryRules = {}; // default set of rules for the Query Builder condition

      this.valueRules = {}; // the initial Value Rules for this Action
      // The Action Subclass defines what this {} is.

      this.currentForm = currentForm; // the ABViewForm object that this rule Action is tied to.
   }

   component(App, idBase) {
      this.App = App;
      this.idBase = idBase;

      this.label = L("generic abviewruleaction");

      function myUnique(key) {
         return App.unique(`${idBase}_${key}`);
      }

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         // each instance must be unique
         component: `${myUnique("component")}_${webix.uid()}`,
      });

      this._ui = null; // internally track our UI Component value Rules

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }
      };

      // internal business logic
      var _logic = (this._logic = {
         callbacks: {
            onDelete: function () {
               console.warn("NO onDelete()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },
      });
   }

   // condition
   // Return the querybuilder setup structure for this Action.
   // @return {array}  of querybuilder setup
   //					[
   //						{rules},
   //						[fields]
   //					]
   condition() {
      return [this.conditionRules(), this.conditionFields()];
   }

   // stashCondition
   // capture the current set of rules provided by the QB object.
   // This doesn't guarantee these will be saved to the App settings.
   // Instead it is a temporary stash. Only the selected Action's
   // values will be persisited to the App settings.
   // @param {obj/Array} rules  The QueryBuilder rule value returned from
   //							 .getValue()
   //							 note: it is the first entry .getValue()[0]
   //
   stashCondition(rules) {
      // check to see if they sent us the raw QueryBuilder values and only
      // pull off the rules if they did
      if (Array.isArray(rules)) {
         rules = rules[0];
      }

      // sanity check on glue value: don't update if null or not given.
      if (rules) {
         // sometimes .glue is undefined  so default to 'and'
         if (rules.glue != "or") rules.glue = "and";

         this.queryRules = rules;
      }
   }

   // conditionFields()
   // Return the list of fields we are able to update.
   // @return {array} of querybuilder field definitions:
   //					[
   // 						{ id:"fname",   value:"First Name", type:"string" },
   //					    { id:"lname",   value:"Last Name",  type:"string" },
   //					    { id:"age",     value:"Age",        type:"number" },
   //					    { id:"bdate",   value:"Birth Date", type:"date" }
   //					]
   conditionFields() {
      var fieldTypes = ["string", "number", "date", "formula", "calculate"];

      var currFields = [];

      if (this.queryObject) {
         this.queryObject.fields().forEach((f) => {
            if (fieldTypes.indexOf(f.key) != -1) {
               // NOTE: the .id value must match the obj[.id]  in the data set
               // so if your object data looks like:
               // 	{
               //		name_first:'Neo',
               //		name_last: 'The One'
               //  },
               // then the ids should be:
               // { id:'name_first', value:'xxx', type:'string' }
               currFields.push({
                  id: f.columnName,
                  value: f.label,
                  type: f.key,
               });
            }
         });
      }

      return currFields;
   }

   // conditionRules()
   // Return the current rule definition object for this Action.
   // @return {obj}
   conditionRules() {
      return this.queryRules;
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      // this.currentObject = object;				// DO WE NEED THIS?
      this.queryObjectLoad(object);
   }

   // queryObjectLoad
   // save the current object this Action is using to build query rules.
   queryObjectLoad(object) {
      this.queryObject = object;
   }

   formLoad(form) {
      this.currentForm = form;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      console.error(
         "!!! ABViewRuleAction.process() should be overridden by its child class."
      );
      return new Promise((resolve, reject) => {
         reject(
            new Error(
               "ABViewRuleAction.process() should be overridden by its child class."
            )
         );
      });
   }

   // valueDisplay
   // create the form to collect the specific data this Action needs to function.
   // @param {string} webixID  the $$(webixID) of the area to insert our display.
   valueDisplay(webixID) {
      return this.valueDisplayComponent(webixID);
   }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      return (this._ui = {
         ui: {
            template: "ABViewRuleAction.valueDisplayComponent",
         },
         init: (data) => {
            console.error(
               "!!! ABViewRuleAction.valueDisplayComponent() should be overridden."
            );
            console.warn(" --> passed in data:", data);
         },
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      // settings: {
      //	valueRules:{}
      // }
      settings = settings ?? {};
      this.valueRules = settings.valueRules ?? settings;
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      var settings = {};

      // require the child to insert the valueRules
      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   isReady() {
      return Promise.resolve();
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      // our child classes can implement this if needed.
      // 	- ABViewRuleActionFormRecordRuleUpdateConnected
   }
};


/***/ }),

/***/ 69159:
/*!********************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleList.js ***!
  \********************************************/
/***/ ((module) => {

//
// ABViewRuleList
//
// A UI component that is responsible for displaying a list of current "Rules"
// for a given purpose.  Some examples are the
//		Form -> Submit Rules,
//		Form -> Display Rules
// 		Form -> Record Rules.
//

// ABViewRuleList is the parent object that manages displaying the common popup,
// list, adding a rule, removing rules, etc...
//
// It is intending to be subclassed by a Specific List object that will load
// up a given set of Actions for their list.
//
// When using it in the AppBuilder Interface Builder, this object provides:
// 	var PopupRecordList = new ABViewRuleList(App, idBase);
//  PopupRecordList.fromSettings(CurrentObjectDefinition.rules); // populates List with current settings defined in CurrentObjectDefinition
//  PopupRecordList.init({ onSave:()=>{}})	// displays the popup for IB
//  CurrentObjectDefinition.rules = PopupRecordList.toSettings(); // save the settings to store in json config
//
// When using on a live running App:
//  PopupRecordList = new ABViewRuleList(App, idBase);
//  PopupRecordList.fromSettings();
//
//  onFormSubmit(data) {
//		// note: this automatically validates and runs each rule:
//		PopupRecordList.process({data:data, view:{ current ABViewForm object }})
//		.then()
//		.catch();
//  }

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleList {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(childSettings) {
      this.listRules = [];
      this.currentObject = null;

      // ensure required values:
      childSettings = childSettings || {};
      childSettings.labels = childSettings.labels || {};
      childSettings.labels.header =
         childSettings.labels.header || "ab.components.form.ruleList";
      childSettings.labels.headerDefault =
         childSettings.labels.headerDefault || "*Rule List";
      this.childSettings = childSettings;
   }

   /**
    * @method component
    * initialize the UI display for this popup editor.
    * @param {obj} App  The common UI App object shared among our UI components
    * @param {string} idBase A unique Key used the the base of our unique ids
    */
   component(App, idBase) {
      this.App = this.App || App;
      this.idBase = idBase;

      App = App || this.App;

      this.currentForm = null;

      // internal list of Webix IDs to reference our UI components.
      var ids = (this.ids = {
         component: `${idBase}_component`,
         rules: `${idBase}_rules`,
         rulesScrollview: `${idBase}_rulesScrollview`,

         action: `${idBase}_action`,
         when: `${idBase}_when`,

         values: `${idBase}_values`,
         set: `${idBase}_set`,
      });

      // webix UI definition:
      this.ui = {
         view: "window",
         id: ids.component,
         modal: true,
         position: "center",
         resize: true,
         width: 700,
         height: 450,
         css: "ab-main-container",
         head: {
            view: "toolbar",
            css: "webix_dark",
            cols: [
               {
                  view: "label",
                  label: this.childSettings.labels.headerDefault,
               },
               {
                  view: "button",
                  css: "webix_primary",
                  icon: "fa fa-plus",
                  type: "iconButton",
                  label: L("Add new rule"),
                  width: 150,
                  click: () => {
                     this.addRule();
                     console.log($$(ids.rules).$height);
                     $$(ids.rulesScrollview).scrollTo(0, $$(ids.rules).$height);
                  },
               },
            ],
         },
         body: {
            type: "form",
            rows: [
               {
                  view: "scrollview",
                  id: ids.rulesScrollview,
                  scroll: "xy",
                  body: {
                     view: "layout",
                     id: ids.rules,
                     margin: 20,
                     padding: 10,
                     rows: [],
                  },
               },
               // {
               // 	css: { 'background-color': '#fff' },
               // 	cols: [
               // 		{
               // 			view: "button",
               // 			icon: "plus",
               // 			type: "iconButton",
               // 			label: labels.component.addNewRule,
               // 			width: 150,
               // 			click: () => {
               // 				this.addRule();
               // 			}
               // 		},
               // 		{ fillspace: true }
               // 	]
               // },
               {
                  css: { "background-color": "#fff" },
                  cols: [
                     { fillspace: true },
                     {
                        view: "button",
                        name: "cancel",
                        value: L("Cancel"),
                        css: "ab-cancel-button",
                        autowidth: true,
                        click: function () {
                           _logic.buttonCancel();
                        },
                     },
                     {
                        view: "button",
                        css: "webix_primary",
                        name: "save",
                        label: L("Save"),
                        type: "form",
                        autowidth: true,
                        click: function () {
                           _logic.buttonSave();
                        },
                     },
                     { fillspace: true },
                  ],
               },
            ],
         },
      };

      // var _currentObject = null;
      var _rules = [];

      // for setting up UI
      this.init = (options) => {
         // register callbacks:
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         webix.ui(this.ui);
      };

      // internal business logic
      var _logic = (this._logic = {
         buttonCancel: function () {
            $$(ids.component).hide();
         },

         buttonSave: () => {
            var results = this.toSettings();

            _logic.callbacks.onSave(results);
            _logic.hide();
         },

         callbacks: {
            onCancel: function () {
               console.warn("NO onCancel()!");
            },
            onSave: function (field) {
               console.warn("NO onSave()!");
            },
         },

         hide: function () {
            $$(ids.component).hide();
         },

         show: function () {
            $$(ids.component).show();
         },
      });

      this.show = _logic.show;
      this.setValue = _logic.setValue;
   }

   /**
    * @method addRule
    * Instantiate a new Rule in our list.
    * @param {obj} settings  The settings object from the Rule we created in .toSettings()
    */
   addRule(settings) {
      var Rule = this.getRule();
      if (!Rule) return;

      this.listRules.push(Rule);

      // if we have tried to create our component:
      if (this.ids) {
         // if our actually exists, then populate it:
         var RulesUI = $$(this.ids.rules);
         if (RulesUI) {
            // make sure Rule.ui is created before calling .init()
            Rule.component(this.App, this.idBase); // prepare the UI component
            var viewId = RulesUI.addView(Rule.ui);

            Rule.init({
               onDelete: (deletedRule) => {
                  $$(this.ids.rules).removeView(Rule.ids.component);

                  var index = this.listRules.indexOf(deletedRule);
                  if (index !== -1) {
                     this.listRules.splice(index, 1);
                  }
               },
            });
         }
      }

      if (settings) {
         Rule.fromSettings(settings);
      }
   }

   /**
    * @method fromSettings
    * Create an initial set of default values based upon our settings object.
    * @param {obj} settings  The settings object we created in .toSettings()
    */
   fromSettings(settings) {
      // settings: [
      //  { rule.settings },
      //  { rule.settings }
      // ]

      // clear any existing Rules:
      this.listRules.forEach((rule) => {
         if (
            this.ids &&
            this.ids.rules &&
            rule &&
            rule.ids &&
            rule.ids.component
         ) {
            $$(this.ids.rules).removeView(rule.ids.component);
         }
      });
      this.listRules = [];

      if (settings) {
         settings.forEach((ruleSettings) => {
            this.addRule(ruleSettings);
         });
      }
   }

   /**
    * @method objectLoad
    * A rule is based upon a Form that was working with an Object.
    * .objectLoad() is how we specify which object we are working with.
    *
    * @param {ABObject} The object that will be used to evaluate the Rules
    */
   objectLoad(object) {
      this.currentObject = object;

      // tell each of our rules about our object
      this.listRules.forEach((r) => {
         r.objectLoad(object);
      });
   }

   processPre(options) {
      (this.listRules || [])
         .filter((rule) => rule.isPreProcess == true)
         .forEach((rule) => {
            rule.processPre(options, options.data);
         });
   }

   /**
    * @method process
    * Take the provided data and process each of our rules.
    * @param {obj} options
    * @return {promise}
    */
   process(options) {
      return new Promise((resolve, reject) => {
         let listRules = (this.listRules || []).filter(
            (rule) => !rule.isPreProcess
         );

         var numDone = 0;
         var onDone = () => {
            numDone++;
            if (numDone >= listRules.length) {
               resolve();
            }
         };

         listRules.forEach((rule) => {
            rule
               .process(options)
               .then(function () {
                  onDone();
               })
               .catch((err) => {
                  reject(err);
               });
         });

         if (listRules.length == 0) {
            resolve();
         }
      });
   }

   /**
    * @method toSettings
    * create a settings object to be persisted with the application.
    * @return {array} of rule settings.
    */
   toSettings() {
      var settings = [];
      this.listRules.forEach((r) => {
         settings.push(r.toSettings());
      });
      return settings;
   }

   getRule() {
      console.error(
         "!!! ABViewRuleList.getRule() should be overridded by a child object."
      );
      return null;
   }

   formLoad(form) {
      this.currentForm = form;
      this.App = this.App || form.App;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * @return {Promise}
    */
   rulesReady() {
      // This base class should be overwritten by any subclass that needs
      // to prepare:
      return Promise.resolve();
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      this.listRules.forEach((r) => {
         r.qbFixAfterShow();
      });
   }
};


/***/ }),

/***/ 95652:
/*!***********************************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleListFormRecordRules.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleListFormRecordRules
//
// A component that is responsible for displaying the specific list of Record
// Rules for a form.
//
const ABViewRuleList = __webpack_require__(/*! ./ABViewRuleList */ 69159);
const ABViewRule = __webpack_require__(/*! ./ABViewRule */ 17172);

const RoleUpdateExisting = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdate */ 24133);
const RoleInsertConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleInsertConnected */ 27239);
const RoleUpdateConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected */ 59196);
const RoleRemoveConnected = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected */ 75045);

module.exports = class ABViewRuleListFormRecordRules extends ABViewRuleList {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor() {
      var settings = {
         labels: {
            header: "ab.components.form.recordRules",
            headerDefault: "*Record Rules",
         },
      };
      super(settings);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new RoleUpdateExisting(
            this.App,
            `${this.idBase}_ruleActionUpdate`,
            this.currentForm
         ),
         new RoleInsertConnected(
            this.App,
            `${this.idBase}_ruleActionInsert`,
            this.currentForm
         ),
         new RoleUpdateConnected(
            this.App,
            `${this.idBase}_ruleActionUpdateConnected`,
            this.currentForm
         ),
         new RoleRemoveConnected(
            this.App,
            `${this.idBase}_ruleActionRemoveConnected`,
            this.currentForm
         ),
      ];

      var Rule = new ABViewRule(listActions);
      if (this.currentObject) {
         Rule.objectLoad(this.currentObject);
      }
      return Rule;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our list of Rules is
    * ready to work.
    * @return {Promise}
    */
   async rulesReady() {
      var allReady = (this.listRules || []).map((r) => r.isReady());
      await Promise.all(allReady);
   }
};


/***/ }),

/***/ 17004:
/*!***********************************************************!*\
  !*** ./AppBuilder/rules/ABViewRuleListFormSubmitRules.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleListFormSubmitRules
//
// A component that is responsible for displaying the specific list of Submit
// Rules for a form.
//
const ABViewRuleList = __webpack_require__(/*! ./ABViewRuleList */ 69159);
const ABViewRule = __webpack_require__(/*! ./ABViewRule */ 17172);

const RoleConfirmMessage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage */ 70559);
const RuleExistPage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleExistPage */ 60971);
const RuleParentPage = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleParentPage */ 38488);
const RuleClosePopup = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleClosePopup */ 44400);
const RuleWebsite = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleWebsite */ 96891);
const RuleEmail = __webpack_require__(/*! ./ruleActions/ABViewRuleActionFormSubmitRuleEmail */ 88493);

module.exports = class ABViewRuleListFormSubmitRules extends ABViewRuleList {
   /**
    * @param {object} App
    *      ?what is this?
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor() {
      var settings = {
         labels: {
            header: "ab.component.form.submitRule",
            headerDefault: "*Submit Rules",
         },
      };
      super(settings);
   }

   // must return the actual Rule object.
   getRule() {
      var listActions = [
         new RoleConfirmMessage(
            this.App,
            `${this.idBase}_ruleActionConfirmMessage`
         ),
         new RuleExistPage(this.App, `${this.idBase}_ruleActionExistPage`),
         new RuleParentPage(this.App, `${this.idBase}_ruleActionParentPage`),
         new RuleClosePopup(this.App, `${this.idBase}_ruleActionClosePopup`),
         new RuleWebsite(this.App, `${this.idBase}_ruleActionWebsite`),
         new RuleEmail(this.App, `${this.idBase}_ruleActionEmail`),
      ];

      var Rule = new ABViewRule(listActions);
      Rule.objectLoad(this.currentObject);
      Rule.formLoad(this.currentForm);
      return Rule;
   }
};


/***/ }),

/***/ 27239:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleInsertConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleInsertConnected
//
// An action that allows you to insert a connected object.
//
// NOTE: this is very similar to the Update Connected Rule, so we subclass that one and
// modify it to only Insert data.
//
//
const UpdateConnected = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 59196);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleInsertConnected extends (
   UpdateConnected
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleInsertConnected";
      this.label = L("Insert Connected Object");
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayChooser(idBase) {
      var Component = super.valueDisplayChooser(idBase);

      // in our case, there are no additional QB conditions:
      // so overwrite the .showQBIfNeeded() routine to not show anything:
      Component._logic.showQBIfNeeded = function () {};

      return Component;
   }

   /**
    * queryBuilderDisplay
    * override our parent .queryBuilderDisplay to not create a new .objectQB
    * @return {null}
    */
   queryBuilderDisplay() {
      return null;
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      // var condition = null; // our lookup condition

      // we are going to create a new instance of the connected object
      // and make sure our .id is in the connected object's connectionField
      // the server side will take care of making the proper relationship.

      // first, create a new set of values:
      var newObjectValues = {};

      // update them according to our rules
      this.processUpdateObject({}, newObjectValues);

      if (newObjectValues.newRecords) {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues.newRecords.forEach((r) => {
            r[connectedObjectField.columnName] = options.data.id;
            // perform the update/insert
            return model.create(r);
         });
      } else {
         // now add our .id to the proper field in newObjectValues
         let connectedObjectField = connObj.fieldByID(
            connectionField.settings.linkColumn
         );

         if (!connectedObjectField)
            return Promise.reject("No connected object field");

         newObjectValues[connectedObjectField.columnName] = options.data.id;

         // perform the update/insert
         return model.create(newObjectValues);
      }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //	valueRules:{}		// from ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      // we don't use .qpCondition
      delete settings.qbCondition;

      return settings;
   }
};


/***/ }),

/***/ 75045:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleRemoveConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleRemoveConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//
const ABViewRuleActionFormRecordRuleUpdateConnected = __webpack_require__(/*! ./ABViewRuleActionFormRecordRuleUpdateConnected */ 59196);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleRemoveConnected extends (
   ABViewRuleActionFormRecordRuleUpdateConnected
) {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleRemoveConnected";
      this.label = L("Remove Connected Record");

      this.isUpdateValueDisabled = true; // disable update data of each fields
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      let selectedField = this.selectedField();
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         // get the model from the provided Form Obj:
         let dc = options.form.datacollection;
         if (!dc) return resolve();

         let model = dc.model;
         if (!model) return resolve();

         let updatedVals = {};
         updatedVals[selectedField.columnName] = "";

         model
            .update(options.data.id, updatedVals)
            .then(resolve)
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message:
                     "!!! ABViewRuleActionFormRecordRuleUpdate.process(): update error:",
                  data: options.data,
               });
               reject(err);
            });
      });
   }
};


/***/ }),

/***/ 24133:
/*!******************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdate.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleUpdate
//
// An action that allows you to update fields on an object that was currently
// Added/Updated.
//
//
const ABViewRuleActionObjectUpdater = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 36746);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleUpdate extends (
   ABViewRuleActionObjectUpdater
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = L("Update Record");
   }

   get isPreProcess() {
      return true;
   }
};


/***/ }),

/***/ 59196:
/*!***************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormRecordRuleUpdateConnected.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormRecordRuleUpdateConnected
//
// An action that allows you to update fields on an object that is connected to
// the current object we just Added/Updated
//
//
const ABViewRuleActionObjectUpdater = __webpack_require__(/*! ./ABViewRuleActionObjectUpdater */ 36746);
const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 89981);
const ObjectQueryBuilder = __webpack_require__(/*! ../ABViewQueryBuilderObjectFieldConditions */ 25358);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormRecordRuleUpdateConnected extends (
   ABViewRuleActionObjectUpdater
) {
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdateConnected";
      this.label = L("Update Connected Record");

      this.baseObject = null; // the object the current form is working with.
      // Use this to find our connected fields.

      this.selectedFieldID = null; // the selected field ID in the .baseObject that is
      // used for updating.  This should be one of the connection Fields.

      this.fieldDropList = []; // the list of fields to offer based upon the current .baseObject.

      this.objectQB = null; // the QueryBuilder used for offering conditions based upon our connected Object.
      this.qbCondition = null; // the QB condition entered for selecting which remote object.
   }

   // field

   /**
    * objectLoad
    * save the current object this Action is associated with.
    * in the case of the UpdateConnected Action, assigning us
    * this object only impacts the queryObject.
    *
    * The Updater form will use another object we select in
    * the form dropdown.
    *
    * @param {object} object
    *
    */
   objectLoad(object) {
      this.queryObjectLoad(object);
      this.baseObject = object;

      // now build our fieldDropList for the select
      var connectionFields = this.connectedFieldList();
      connectionFields.forEach((cf) => {
         this.fieldDropList.push({
            id: cf.id,
            value: cf.label,
         });
      });
   }

   /**
    * connectedFieldList
    * return the fields in our .baseObject that are connections to other objects.
    * @return {array} of {ABField}
    */
   connectedFieldList() {
      var connectKey = ABFieldConnect.defaults().key;
      if (this.baseObject && this.baseObject.fields) {
         return this.baseObject.fields((f) => {
            return f.key == connectKey;
         });
      } else {
         return [];
      }
   }

   /**
    * connectedObject
    * return the ABObject associated with the selected connection field.
    * @return {ABObject}
    */
   connectedObject() {
      if (this.selectedFieldID) {
         var selectedField = this.selectedField();
         if (selectedField) {
            return selectedField.datasourceLink;
         }
      }

      return null;
   }

   /**
    * selectedField
    * return the selected {ABField} object.
    * @return {ABField}
    */
   selectedField() {
      return this.connectedFieldList().filter((f) => {
         return f.id == this.selectedFieldID;
      })[0];
   }

   /**
    * valueDisplayComponent
    * Return an ABView to display our values form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayComponent(idBase) {
      if (this._uiChooser == null) {
         this._uiChooser = this.valueDisplayChooser(idBase);
      }

      return this._uiChooser;
   }

   /**
    * valueDisplayChooser
    * Our Values Display is a Select Box with a choice of connected fields.
    * Once a field is chosen, then we display the Updater form.
    * @param {string}  idBase  a unique webix id to base our sub components on.
    */
   valueDisplayChooser(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return key + "_" + uniqueInstanceID;
      };

      var ids = {
         component: myUnique("updateConnectedValues"),
         updateForm: myUnique("updateChooser"),
         selectConnectedField: myUnique("updateSelect"),
         updateFieldsForm: myUnique("updateForm"),
      };

      var _ui = {
         id: ids.component,
         view: "layout",
         css: "ab-component-form-rule",
         rows: [
            {
               id: ids.selectConnectedField,
               view: "richselect",
               label: L("Select which connected object to update."),
               labelWidth: 300,
               value: this.selectedField,
               options: this.fieldDropList,
               on: {
                  onChange: (newVal, oldVal) => {
                     _logic.selectAction(newVal, oldVal);
                  },
               },
            },
         ],
      };

      var init = (valueRules) => {
         valueRules = valueRules || this.valueRules;

         // make sure our currently selected field is selected.
         if (this.selectedFieldID) {
            var select = $$(ids.selectConnectedField);
            if (select) {
               select.setValue(this.selectedFieldID);
            }
         }
      };

      var _logic = (this._logic = {
         addDisplay: (view) => {
            $$(ids.component).addView(view);
         },

         // removePreviousDisplays
         // remove the previous components that reflected the conditions and
         // update values of the previously selected field.
         removePreviousDisplays: () => {
            var allViews = $$(ids.component).getChildViews();
            var cloneAllViews = [];
            allViews.forEach((v) => {
               cloneAllViews.push(v);
            });
            cloneAllViews.forEach((v) => {
               // don't remove the field picker
               if (v.config.id != ids.selectConnectedField) {
                  $$(ids.component).removeView(v);
               }
            });
         },

         selectAction: (newVal, oldVal) => {
            _logic.removePreviousDisplays(); // of the Query Builder and Update form for old selection:

            this.selectedFieldID = newVal;
            var connectedObject = this.connectedObject();

            if (connectedObject) {
               // it is the remote object that we are allowed to Update fields on.
               this.updateObjectLoad(connectedObject);
               ///// NOTE: important to call super.valueDisplayComponent()
               this.updateComponent = super.valueDisplayComponent(
                  ids.updateFieldsForm
               ); // parent obj

               _logic.showQBIfNeeded();

               // create a new blank update form
               _logic.addDisplay(this.updateComponent.ui);
               this.updateComponent.init();

               if (this.isUpdateValueDisabled) {
                  let $updateForm = $$(this.updateComponent.ui.id);
                  if ($updateForm) {
                     $updateForm.disable();
                     $updateForm.hide();
                  }
               }
            } else {
               this.AB.notify.builder(new Error("No connectedObject found."), {
                  fieldID: this.selectedFieldID,
               });
            }
         },

         showQBIfNeeded: () => {
            //// NOTE: we decided to go ahead and display the QB in ALL situations to give
            //// the user the ability to set a condition on the update even if the field
            //// is only a one to one.
            //// If we want to remove the filter in case of a "one" linkType, then put
            //// these conditions back in:

            // var field = this.selectedField();

            // // we don't need the QB if the destination object link type if 'one'.
            // // there will only be one to get back, so no conditions needed.
            // if (field.settings.linkType != 'one') {

            var qbComponent = this.queryBuilderDisplay();

            qbComponent.component(this.App, this.idBase);
            _logic.addDisplay(qbComponent.ui);
            qbComponent.init({});

            // }
         },

         fromSettings: (settings) => {
            // // first time through, be sure to set the connectedObject first
            // this.selectedFieldID = settings.selectedFieldID;
            // var connectedObject = this.connectedObject();

            // this triggers the update of the display, creation of QB,
            $$(ids.selectConnectedField).setValue(settings.selectedFieldID);

            if (this.objectQB) {
               this.objectQB.setValue(this.qbCondition);
            }

            if (this.updateComponent) {
               this.updateComponent.fromSettings(settings);
            }
         },

         toSettings: () => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }
            var settings = { fieldOperations: [] };

            // for each of our formRows, decode the propery {}
            this.formRows.forEach((fr) => {
               var rowSettings = fr.toSettings();
               if (rowSettings) {
                  settings.fieldOperations.push(rowSettings);
               }
            });

            return settings;
         },
      });

      return {
         ui: _ui,
         init: init,
         fromSettings: (settings) => {
            _logic.fromSettings(settings);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   /**
    * queryBuilderDisplay
    * returns our Query Builder object used in our display.
    * It is called by the .showQBIfNeeded() method.
    * @return {ABViewQueryBuilderObjectFieldConditions}
    */
   queryBuilderDisplay() {
      if (!this.objectQB) {
         this.objectQB = new ObjectQueryBuilder(
            L("How to choose which object:")
         );

         var connObj = this.connectedObject();
         if (connObj) this.objectQB.objectLoad(connObj);
      }
      return this.objectQB;
   }

   /**
    * process
    * gets called when a form is submitted and the data passes the Query Builder Rules.
    * @param {obj} options
    *				options.data : {obj} the key=>value of the data just entered by the form
    *				options.form : {ABViewForm} the Form object that is processing this rule
    * @return {Promise}
    */
   process(options) {
      this._formData = options.data;

      // get connected object
      var connObj = this.connectedObject();
      var model = connObj.model();

      var connectionField = this.selectedField();

      var condition = null; // our lookup condition

      // modifyCondition
      // async fn() to fill out what the condition should be for limiting the remote
      // objects to values in use by the current object.
      // @param {fn} cb  the callback to use when we are finished:
      //					cb(err, )
      var modifyCondition = (cb) => {
         // So, let's get a copy of our current data, with all it's connected items
         // attached.
         var thisModel = this.baseObject.model();
         thisModel
            .findConnected(connectionField.columnName, options.data)
            .then((items) => {
               // if we didn't get any results, then simply return
               // NOTE: this will leave condition == null and cancel this update.
               if (!items || items.length == 0) {
                  cb();
                  return;
               }

               // then use these to limit the connected data of our Action:

               // get all the ids
               var ids = items.map((i) => {
                  return i.id;
               });

               // resulting condition: { id in [listIDs]} AND { QB Condition }
               condition = {
                  glue: "and",
                  rules: [
                     {
                        key: `${connObj.tableName}.${connObj.PK()}`,
                        rule: "in",
                        value: ids,
                     },
                  ],
               };

               // check to make sure qbCondition actually has a condition before adding it
               // to our condition:
               if (Object.keys(this.qbCondition).length > 0) {
                  condition.rules.push(this.qbCondition);
               }

               cb();
            })
            .catch(cb);
      };

      // .process() returns a Promise
      return new Promise((resolve, reject) => {
         // upateIt()
         // updates a given item with our changes.
         // @param {obj} item  the item to update
         // @param {fn}  cb    a callback function when update is complete.
         var updateIt = (item, cb) => {
            let isUpdated = this.processUpdateObject({}, item);
            if (!isUpdated) {
               cb();
            } else {
               model
                  .update(item.id, item)
                  .then(() => {
                     cb();
                  })
                  .catch((err) => {
                     this.AB.notify.developer(err, {
                        message:
                           "!!! ABViewRuleActionFormRecordRuleUpdateConnected.process(): update error:",
                        data: options.data,
                     });
                     cb(err);
                  });
            }
         };

         // now figure out which elements belong to this object
         // done in modifyCondition()
         modifyCondition((err) => {
            if (err) {
               AB.notify.developer(err, {
                  message:
                     "!!! ABViewRuleActionFormRecordRuleUpdateConnected.modifyCondition: error:",
                  data: options.data,
               });
               reject(err);
               return;
            }

            if (condition === null) {
               // this is the case where we didn't have the proper data to complete our
               // update.  So let's just fail gracefully, and continue on.

               // QUESTION: is this the right way to handle it?
               resolve();
            } else {
               // get all the entries that match our condition:
               model
                  .findAll({ where: condition })
                  .then((list) => {
                     var done = 0;

                     // list : {data: Array(4), total_count: 4, pos: null, offset: null, limit: null}
                     if (list && list.data) {
                        list = list.data;
                     }

                     // for each entry, update it with our values:
                     list.forEach((item) => {
                        updateIt(item, (err) => {
                           if (err) {
                              return reject(err);
                           }
                           done++;
                           if (done >= list.length) {
                              // now they are all updated, so continue.
                              resolve();
                           }
                        });
                     });

                     // if there were no entries to update -> continue
                     if (list.length == 0) {
                        resolve();
                     }
                  })
                  .catch(reject);
            }
         }); // end modifyCondition()
      }); // end Promise()
   }

   /**
    * fromSettings
    * initialize this Action = require(a given set of setting values.
    * @param {obj} settings  the settings {} returned = require(toSettings()
    */
   fromSettings(settings) {
      settings = settings || {};

      this.selectedFieldID = settings.selectedFieldID || null;
      this.qbCondition = settings.qbCondition || {};

      super.fromSettings(settings);

      // if we have a display component, then populate it:
      if (this._uiChooser) {
         this._logic.fromSettings(settings);
      }
   }

   /**
    * toSettings
    * return an object that represents the current state of this Action
    * @return {obj}
    */
   toSettings() {
      // settings: {
      // 	selectedFieldID: 'guid',
      //  qbCondition: [],
      //	valueRules:{}		// = require(ABViewRuleActionObjectUpdater
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.selectedFieldID = this.selectedFieldID;

      var qbCond = null;
      if (this.objectQB) {
         qbCond = this.objectQB.getValue();
         if (Array.isArray(qbCond)) {
            qbCond = qbCond[0];
         }

         // FIX: make sure qbCond root element has a 'glue'
         if (qbCond) {
            qbCond.glue = qbCond?.glue || "and";
         }
      }
      settings.qbCondition = qbCond;

      // if we have a display component, then request our details = require(it:
      if (this._uiChooser) {
         settings.valueRules = this._logic.toSettings();
      }

      return settings;
   }

   // NOTE: Querybuilder v5.2 has a bug where it won't display the [and/or]
   // choosers properly if it hasn't been shown before the .setValue() call.
   // so this work around allows us to refresh the display after the .show()
   // on the popup.
   // When they've fixed the bug, we'll remove this workaround:
   qbFixAfterShow() {
      if (this.objectQB) {
         this.objectQB.setValue(this.qbCondition);
      }
   }
};


/***/ }),

/***/ 44400:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleClosePopup.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleClosePopup
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleClosePopup extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleClosePopup";
      this.label = L("Close the current popup");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      this._ui = {
         ui: {
            view: "layout",
            rows: [],
         },

         init: () => {},
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         let form = options.form;
         if (!form) return;

         let popup = form.pageParent((p) => p.settings.type == "popup");
         if (!popup) return;

         // get the dom id of page. it is dom id that is generated in ABLiveTool.js
         // let pageDomId = ["ab_live_page", popup.application.id, popup.id].join(
         //    "_"
         // );

         // close current popup
         let $popup = $$(popup.id);
         if ($popup) $popup.hide();

         // this clears the UI's record of the current form.
         options.form.changePage(null);

         resolve();
      });
   }
};


/***/ }),

/***/ 70559:
/*!**************************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleConfirmMessage.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleConfirmMessage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleConfirmMessage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleConfirmMessage";
      this.label = L("Show a confirmation message");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         message: `${idBase}_message`,
      };

      this._ui = {
         ui: {
            id: ids.message,
            view: "textarea",
            // label: this.labels.component.message,
            // labelWidth: this.AB.UISettings.config().labelWidthLarge,
            height: 130,
         },

         init: () => {},

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.message).setValue(valueRules.message || "");
         },

         toSettings: () => {
            // return the confirm message
            return {
               message: $$(ids.message).getValue() || "",
            };
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var confirmMessage = this.valueRules.message || "";

         webix.message({
            text: confirmMessage,
            type: "info",
         });

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 88493:
/*!*****************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleEmail.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);
const ABFieldConnect = __webpack_require__(/*! ../../platform/dataFields/ABFieldConnect */ 89981);
const ABFieldEmail = __webpack_require__(/*! ../../platform/dataFields/ABFieldEmail */ 75922);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleEmail extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleEmail";
      this.label = L("Send a custom email");

      this.queryObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.queryObject) {
   //       this.queryObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         form: `${idBase}_form`,
         popup: `${idBase}_popup`,
         list: `${idBase}_fieldList`,
         toEmailsContainer: `${idBase}_toEmailsContainer`,
         toEmails: `${idBase}_toEmails`,
         message: `${idBase}_message`,
      };

      this._ui = {
         ui: {
            id: ids.form,
            view: "form",
            width: 450,
            elementsConfig: {
               labelPosition: "top",
               labelWidth: 100,
            },
            cols: [
               // email form
               {
                  width: 330,
                  rows: [
                     {
                        view: "text",
                        name: "fromName",
                        label: L("From Name"),
                     },
                     {
                        view: "text",
                        name: "fromEmail",
                        label: L("From Email"),
                        validate: webix.rules.isEmail,
                        on: {
                           onChange: function (newVal, oldVal) {
                              if (this.getValue() && !this.validate()) {
                                 $$(ids.form).markInvalid(
                                    "fromEmail",
                                    "Email is invalid"
                                 );
                              } else {
                                 $$(ids.form).markInvalid("fromEmail", false);
                              }
                           },
                        },
                     },
                     {
                        id: ids.toEmailsContainer,
                        view: "forminput",
                        name: "toEmails",
                        label: L("Send"),
                        css: "ab-rich-text",
                        width: 320,
                        body: {
                           width: 320,
                           rows: [
                              {
                                 height: 25,
                              },
                              {
                                 id: ids.toEmails,
                                 width: 320,
                                 view: "layout",
                                 rows: [],
                              },
                              {
                                 view: "button",
                                 css: "webix_primary",
                                 type: "icon",
                                 icon: "fa fa-plus",
                                 label: L("Add a recipient"),
                                 width: 150,
                                 click: () => {
                                    _logic.toEmailAdd();
                                 },
                              },
                           ],
                        },
                     },
                     {
                        view: "text",
                        name: "subject",
                        label: L("Subject"),
                     },
                     {
                        view: "textarea",
                        id: ids.message,
                        name: "message",
                        label: L("Message"),
                        width: 320,
                        height: 400,
                     },
                     // {
                     // 	view: 'label',
                     // 	label: 'Message',
                     // 	css: { 'font-weight': 'bold' }
                     // },
                     // {
                     // 	view: 'forminput',
                     // 	id: ids.message,
                     // 	name: 'message',
                     // 	label: 'Message',
                     // 	css: "ab-rich-text",
                     // 	width: 320,
                     // 	height: 400,
                     // 	body: {
                     // 		view: 'tinymce-editor'
                     // 	}
                     // }
                  ],
               },
               // field list
               {
                  rows: [
                     {
                        view: "template",
                        type: "header",
                        template: "Fields",
                     },
                     {
                        id: ids.list,
                        view: "list",
                        width: 120,
                        css: { "background-color": "#fff !important;" },
                        template: function (obj, common) {
                           return _logic.fieldTemplate(obj, common);
                        },
                        on: {
                           onItemClick: function (id, e, node) {
                              var component = this.getItem(id);

                              _logic.enterField(component);
                           },
                        },
                     },
                  ],
               },
            ],
         },

         init: () => {
            if (this.queryObject) {
               $$(ids.list).parse(
                  this.queryObject.fields((f) => f.fieldUseAsLabel())
               );
               $$(ids.list).refresh();
            }

            _logic.refreshUI();
         },

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.form).setValues(valueRules);

            // Populate recipients
            var recipients = valueRules.toEmails || [];
            recipients.forEach((r) => {
               _logic.toEmailAdd({
                  type: r.type, // 'to', 'cc' or 'bcc'
                  emailType: r.emailType, // 'email' or 'field'
                  value: r.value,
               });
            });

            _logic.refreshUI();
         },

         toSettings: () => {
            var formVals = $$(ids.form).getValues() || {};

            // Get recipients
            var recipients = [];
            $$(ids.toEmails)
               .getChildViews()
               .forEach((e) => {
                  // var type = e.queryView({ name: 'type' }).getValue();
                  var type = "to"; // TODO
                  var emailType = e.queryView({ name: "emailType" }).getValue();
                  var value = e.queryView({ name: emailType }).getValue();

                  recipients.push({
                     type: type,
                     emailType: emailType,
                     value: value,
                  });
               });

            // return the confirm message
            return {
               fromName: formVals["fromName"],
               fromEmail: formVals["fromEmail"],
               toEmails: recipients,
               subject: formVals["subject"],
               message: formVals["message"],
            };
         },

         /**
          * @method toEmailTemplate
          *
          * @param settings - {
          * 			type: string, // 'to', 'cc' or 'bcc'
          * 			emailType: string, // 'email' or 'field'
          * 			value: string
          * }
          */
         toEmailTemplate: (settings) => {
            settings = settings || {};

            return {
               width: 320,
               cols: [
                  // {
                  // 	view: 'richselect',
                  // 	name: 'type',
                  // 	value: settings.type || 'to',
                  // 	width: 80,
                  // 	options: [
                  // 		{ id: 'to', value: "To:" },
                  // 		// EmailNotification does not support cc, bcc and reply.
                  // 		// { id: 'cc', value: "Cc:" },
                  // 		// { id: 'bcc', value: "Bcc:" },
                  // 		// { id: 'reply', value: "Reply-To:" }
                  // 	]
                  // },
                  {
                     view: "richselect",
                     name: "emailType",
                     value: settings.emailType || "email",
                     width: 150,
                     options: [
                        {
                           id: "email",
                           value: L("A custom email address"),
                        },
                        { id: "field", value: L("An email field") },
                        { id: "query", value: L("From query") },
                     ],
                     on: {
                        onChange: function (newVal, oldVal) {
                           _logic.emailTypeChange(newVal, this);
                        },
                     },
                  },
                  {
                     width: 150,
                     name: "emailValue",
                     visibleBatch: settings.emailType || "email",
                     cols: [
                        {
                           view: "text",
                           name: "email",
                           batch: "email",
                           value:
                              settings.emailType == "email"
                                 ? settings.value
                                 : "",
                           validate: webix.rules.isEmail,
                           width: 150,
                           on: {
                              onChange: function (newVal, oldVal) {
                                 _logic.toEmailValidate();
                              },
                           },
                        },
                        {
                           view: "richselect",
                           name: "field",
                           batch: "field",
                           value:
                              settings.emailType == "field"
                                 ? settings.value
                                 : "",
                           width: 150,
                           suggest: {
                              on: {
                                 onBeforeShow: function () {
                                    this.define("width", 300);
                                    this.resize();
                                 },
                              },
                              data: _logic.emailFieldOptions(),
                           },
                        },
                        {
                           view: "richselect",
                           name: "query",
                           batch: "query",
                           value:
                              settings.emailType == "query"
                                 ? settings.value
                                 : "",
                           width: 150,
                           suggest: {
                              on: {
                                 onBeforeShow: function () {
                                    this.define("width", 300);
                                    this.resize();
                                 },
                              },
                              data: _logic.queryOptions(),
                           },
                        },
                     ],
                  },
                  {
                     view: "button",
                     css: "webix_danger",
                     type: "icon",
                     icon: "fa fa-trash-o",
                     width: 32,
                     click: function () {
                        var $toView = this.getParentView();

                        _logic.toEmailRemove($toView);
                     },
                  },
               ],
            };
         },

         toEmailAdd: (settings) => {
            var count = $$(ids.toEmails).getChildViews().length;

            $$(ids.toEmails).addView(_logic.toEmailTemplate(settings), count);

            _logic.refreshUI();
         },

         emailTypeChange: (type, $select) => {
            var $recipient = $select.getParentView();
            var $emailValue = $recipient.queryView({ name: "emailValue" });

            switch (type) {
               case "field":
                  $emailValue.showBatch("field");
                  break;
               case "query":
                  $emailValue.showBatch("query");
                  break;
               default:
                  $emailValue.showBatch("email");
                  break;
            }

            $$(ids.toEmailsContainer).adjust();
         },

         toEmailRemove: ($toView) => {
            $$(ids.toEmails).removeView($toView);

            _logic.refreshUI();
         },

         toEmailValidate: () => {
            var isAllValid = true;

            $$(ids.toEmails)
               .getChildViews()
               .forEach((v) => {
                  let emailText = v.queryView({ name: "email" });
                  if (emailText.getValue() && !emailText.validate()) {
                     isAllValid = false;
                  }
               });

            if (isAllValid) $$(ids.form).markInvalid("toEmails", false);
            else $$(ids.form).markInvalid("toEmails", "Email is invalid");
         },

         fieldTemplate: (field, common) => {
            return `<i class='fa fa-${field.icon} webix_icon_btn' aria-hidden='true'></i> ${field.label}`;
         },

         emailFieldOptions: () => {
            var existsFieldIds = [];
            var options = [];

            var fnAddOptions = (currObj, fLink) => {
               var emailFields = currObj
                  .fields((f) => f instanceof ABFieldEmail)
                  .map((f) => {
                     var optId = "",
                        optLabel = "";

                     if (fLink) {
                        optId = `${fLink.id}|${f.urlPointer()}`;
                        optLabel = `${currObj.label}.${f.label} (${fLink.label})`;
                     } else {
                        optId = `|${f.urlPointer()}`;
                        optLabel = `${currObj.label}.${f.label}`;
                     }

                     return {
                        id: optId, // linkFieldId|fieldUrl
                        value: optLabel,
                     };
                  });

               // TODO: prevent duplicate

               options = options.concat(emailFields);
            };

            fnAddOptions(this.queryObject);

            this.queryObject.connectFields().forEach((f) => {
               // prevent looping
               if (
                  // - prevent include connect objects of the base object
                  // f.datasourceLink.id == this.queryObject.id ||
                  // - check duplicate include objects
                  existsFieldIds.indexOf(f.id) > -1
               )
                  return;

               // store
               existsFieldIds.push(f.id);

               // add email fields of link object
               fnAddOptions(f.datasourceLink, f);
            });

            return options;
         },

         queryOptions: () => {
            var options = [];

            // get data collections who is query and contains email field
            let dcQueries = this.currentForm.AB.datacollections((dc) => {
               let obj = dc.datasource;
               return (
                  dc.settings.isQuery &&
                  obj &&
                  obj.fields((f) => f.key == "email").length > 0
               );
            });

            dcQueries.forEach((dv) => {
               if (dv.datasource) {
                  dv.datasource
                     .fields((f) => f.key == "email")
                     .forEach((f) => {
                        options.push({
                           id: `${dv.id}|${f.id}`, // ABDatacollectionID|fieldID
                           value: `${dv.label}.${f.label}`,
                        });
                     });
               }
            });

            return options;
         },

         enterField: (field) => {
            var focusElem = webix.UIManager.getFocus();
            var val = "";

            if (
               focusElem.config.view != "text" ||
               focusElem.config.view != "textarea"
            ) {
               if (focusElem.getValue) val = focusElem.getValue();

               if (focusElem.setValue)
                  focusElem.setValue(`${val}${field.label}`);

               webix.UIManager.setFocus(focusElem);
            }
         },

         refreshUI: () => {
            $$(ids.toEmailsContainer).adjust();
            $$(ids.message).adjust();
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options - {
   //							data: {obj} rowData,
   //							form: {ABViewForm}
   //						}
   process(options) {
      // validate sender's email is invalid
      if (!webix.rules.isEmail(this.valueRules.fromEmail)) {
         return Promise.resolve();
      }

      var recipients = [];

      return Promise.resolve()
         .then(() => {
            // Pull recipients data
            return new Promise((resolve, reject) => {
               var tasks = [];

               this.valueRules.toEmails.forEach((rec) => {
                  tasks.push(
                     new Promise((next, err) => {
                        // TODO: Cc, Bcc

                        // field
                        if (rec.emailType == "field") {
                           var emailFieldUrl = rec.value.split("|")[1]; // linkFieldId|emailFieldUrl
                           var emailField =
                              this.queryObject.application.urlResolve(
                                 emailFieldUrl
                              );
                           if (emailField) {
                              // Pull email source object
                              if (emailField.object.id == this.queryObject.id) {
                                 var emailData =
                                    options.data[emailField.columnName];
                                 if (emailData)
                                    recipients = recipients.concat(emailData);
                              }
                              // Pull emails from link object
                              else {
                                 let linkFieldId = rec.value.split("|")[0];
                                 let linkFields = this.queryObject.fields(
                                    (f) =>
                                       f instanceof ABFieldConnect &&
                                       f.id == linkFieldId
                                 );
                                 linkFields.forEach((f) => {
                                    var linkedData =
                                       options.data[f.relationName()] || [];

                                    // convert to an array
                                    if (
                                       linkedData &&
                                       !Array.isArray(linkedData)
                                    )
                                       linkedData = [linkedData];

                                    // pull email address
                                    linkedData.forEach((d) => {
                                       var email = d[emailField.columnName];
                                       if (email)
                                          recipients = recipients.concat(email);
                                    });
                                 });
                              }

                              next();
                           } else {
                              next();
                           }
                        }

                        // query
                        else if (rec.emailType == "query") {
                           var dvIdAndFieldId = rec.value; // ABDatacollectionId|fieldId
                           if (!dvIdAndFieldId) return next();

                           var dcId = dvIdAndFieldId.split("|")[0];
                           var fieldId = dvIdAndFieldId.split("|")[1];

                           var dcQuery =
                              this.currentForm.AB.datacollectionByID(dcId);
                           if (!dcQuery) return next();

                           var field = dcQuery.datasource.fieldByID(fieldId);
                           if (!field) return next();

                           // get data of data collection
                           dcQuery.getData().forEach((data) => {
                              var emailAddr = data[field.columnName];
                              if (emailAddr) recipients.push(emailAddr);
                           });

                           next();
                        }

                        // email
                        else {
                           recipients.push(rec.value);
                           next();
                        }
                     })
                  );
               });

               Promise.all(tasks).catch(reject).then(resolve);
            });
         })
         .then(() => {
            // send out
            return new Promise((resolve, reject) => {
               recipients = this.AB.uniq(recipients).filter((r) => r);

               if (!recipients || recipients.length < 1) return resolve();

               // replace form value to template
               var fromName = this.valueRules.fromName,
                  subject = this.valueRules.subject,
                  message = this.valueRules.message;

               this.queryObject
                  .fields((f) => f.fieldUseAsLabel())
                  .forEach((f) => {
                     var template = new RegExp(`{${f.label}}`, "g"),
                        data = f.format(options.data);

                     fromName = fromName.replace(template, data);
                     subject = subject.replace(template, data);
                     message = message.replace(template, data);
                  });

               // send a email
               this.AB.Network.post({
                  url: "/app_builder/email",
                  params: {
                     fromName: fromName,
                     fromEmail: this.valueRules.fromEmail,
                     subject: subject,
                     message: message,
                     recipients: this.AB.uniq(recipients),
                  },
               })
                  .then(() => {
                     resolve();
                  })
                  .catch(reject);
            });
         });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 60971:
/*!*********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleExistPage.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleExistPage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleExistPage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleExistPage";
      this.label = L("Redirect to an existing page");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         pagesAndTabs: `${idBase}_PagesAndTabs`,
      };

      this._ui = {
         ui: { id: ids.pagesAndTabs, view: "richselect", options: [] },

         init: () => {
            _logic.populateOptions();
         },

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         populateOptions: () => {
            // Pull page list to "Redirect to an existing page"
            var _pageOptions = [];

            /**
             * @param pageOrTab	{Object}	- ABViewPage or ABViewTab
             * @param indent	{integer}
             * @param type		{string}	- 'page' or 'tab'
             * @param pageId	{uuid}		- the id of page (only tab)
             */
            var addPage = (pageOrTab, indent, type, pageId) => {
               indent = indent || "";

               let icon = "fa fa-file-o";
               if (type == "tab") icon = "fa fa-window-maximize";

               let pageParent = pageOrTab.pageParent();

               _pageOptions.push({
                  id: pageOrTab.id,
                  value: indent + pageOrTab.label,
                  type: type,
                  pageId: pageParent ? pageParent.id : null,

                  icon: icon,
               });

               if (type == "page" || type == "tab") {
                  if (pageOrTab.pages) {
                     pageOrTab.pages().forEach(function (p) {
                        addPage(p, indent + "-", "page");
                     });
                  }

                  // add 'tab' options
                  if (pageOrTab.views) {
                     pageOrTab
                        .views((v) => v.key == "tab")
                        .forEach((tab) => {
                           // add 'tab view' to options
                           tab.views().forEach((tabView) => {
                              addPage(
                                 tabView,
                                 indent + "-",
                                 "tab",
                                 pageOrTab.id
                              );
                           });
                        });
                  }
               }
            };

            addPage(this.currentForm.pageRoot(), "", "page");

            $$(ids.pagesAndTabs).define("options", _pageOptions);
            $$(ids.pagesAndTabs).refresh();
         },

         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.pagesAndTabs).setValue(
               valueRules.tabId || valueRules.pageId || ""
            );
         },

         toSettings: () => {
            var result = {};

            var selectedId = $$(ids.pagesAndTabs).getValue();
            var selectedItem = $$(ids.pagesAndTabs)
               .getPopup()
               .getList()
               .config.data.filter((opt) => opt.id == selectedId)[0];
            if (selectedItem) {
               if (selectedItem.type == "tab") {
                  // store page id and tab id
                  result = {
                     pageId: selectedItem.pageId,
                     tabId: selectedId,
                  };
               } else {
                  // store only page id
                  result = {
                     pageId: selectedId,
                  };
               }
            }

            // return the confirm message
            return result;
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect page
         if (this.valueRules.pageId) {
            options.form.changePage(this.valueRules.pageId);

            if (this.valueRules.tabId) {
               var curPage = options.form.application.pages(
                  (p) => p.id == this.valueRules.pageId,
                  true
               )[0];
               if (!curPage) return resolve();

               // switch tab
               var tabView = curPage.views(
                  (v) => v.id == this.valueRules.tabId,
                  true
               )[0];
               if (!tabView) return resolve();

               var tab = tabView.parent;
               if (!tab) return resolve();

               var toggleParent = (element) => {
                  if (!element.parent) return false;
                  var parentElem = element.parent;
                  if (!parentElem.parent) return false;
                  parentElem.parent.emit("changeTab", parentElem.id);
                  toggleParent(parentElem.parent);
               };

               toggleParent(tab);
               let showIt = setInterval(function () {
                  if ($$(tabView.id) && $$(tabView.id).isVisible()) {
                     clearInterval(showIt);
                     return;
                  }
                  tab.emit("changeTab", tabView.id);
               }, 100);
            }
         }

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 38488:
/*!**********************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleParentPage.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleParentPage
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleParentPage extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleParentPage";
      this.label = L("Redirect to the parent page");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      this._ui = {
         ui: {
            view: "label",
            label: this.label,
         },

         init: () => {},

         _logic: _logic,
      };

      var _logic = {};

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         var pageCurrent = options.form.pageParent();
         var pageParent = pageCurrent.pageParent();

         // redirect page
         options.form.changePage(pageParent.id);

         resolve();
      });
   }
};


/***/ }),

/***/ 96891:
/*!*******************************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionFormSubmitRuleWebsite.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// ABViewRuleActionFormSubmitRuleWebsite
//
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

module.exports = class ABViewRuleActionFormSubmitRuleWebsite extends (
   ABViewRuleAction
) {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase) {
      super();

      this.App = App;
      this.key = "ABViewRuleActionFormSubmitRuleWebsite";
      this.label = L("Redirect to another website URL");

      this.currentObject = null; // the object this Action is tied to.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]
   }

   // conditionFields() {
   //    var fieldTypes = ["string", "number", "date", "formula", "calculate"];

   //    var currFields = [];

   //    if (this.currentObject) {
   //       this.currentObject.fields().forEach((f) => {
   //          if (fieldTypes.indexOf(f.key) != -1) {
   //             // NOTE: the .id value must match the obj[.id]  in the data set
   //             // so if your object data looks like:
   //             // 	{
   //             //		name_first:'Neo',
   //             //		name_last: 'The One'
   //             //  },
   //             // then the ids should be:
   //             // { id:'name_first', value:'xxx', type:'string' }
   //             currFields.push({
   //                id: f.columnName,
   //                value: f.label,
   //                type: f.key
   //             });
   //          }
   //       });
   //    }

   //    return currFields;
   // }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      var ids = {
         website: `${idBase}_website`,
      };

      this._ui = {
         ui: {
            id: ids.website,
            view: "text",
         },

         init: () => {},

         _logic: _logic,

         fromSettings: (valueRules) => {
            _logic.fromSettings(valueRules);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
      };

      var _logic = {
         fromSettings: (valueRules) => {
            valueRules = valueRules || {};

            $$(ids.website).setValue(valueRules.website || "");
         },

         toSettings: () => {
            // return the confirm message
            return {
               website: $$(ids.website).getValue() || "",
            };
         },
      };

      return this._ui;
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   process(options) {
      return new Promise((resolve, reject) => {
         // redirect to website
         if (this.valueRules.website)
            window.open(
               `http://${this.valueRules.website.replace("http://", "")}`,
               "_blank"
            );

         resolve();
      });
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};
      super.fromSettings(settings); // let the parent handle the QB

      // if we have a display component, then populate it:
      if (this._ui) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._ui.fromSettings(settings.valueRules);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	message:''
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._ui.toSettings();

      return settings;
   }
};


/***/ }),

/***/ 36746:
/*!***********************************************************************!*\
  !*** ./AppBuilder/rules/ruleActions/ABViewRuleActionObjectUpdater.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// ABViewRuleActionObjectUpdater
//
// An action that allows you to update fields on an object.
//
//
const ABViewRuleAction = __webpack_require__(/*! ../ABViewRuleAction */ 59816);

let L = (...params) => AB.Multilingual.label(...params);

var ABViewRuleActionObjectUpdaterDefaults = {
   filterConditions: {
      // array of filters to apply to the data table
      glue: "and",
      rules: [],
   },
};

module.exports = class ABViewRuleActionObjectUpdater extends ABViewRuleAction {
   /**
    * @param {object} App
    *      The shared App object that is created in OP.Component
    * @param {string} idBase
    *      Identifier for this component
    */
   constructor(App, idBase, currentForm) {
      super(App, idBase, currentForm);

      this.key = "ABViewRuleActionFormRecordRuleUpdate";
      this.label = L("Update Record");

      this.updateObject = null; // the object this Action will Update.

      this.formRows = []; // keep track of the Value Components being set
      // [
      //		{ fieldId: xxx, value:yyy, type:key['string', 'number', 'date',...]}
      // ]

      this.stashRules = {}; // keep track of rule settings among our selected objects.
   }

   // valueDisplayComponent
   // Return an ABView to display our values form.
   //
   valueDisplayComponent(idBase) {
      if (this._uiUpdater == null) {
         this._uiUpdater = this.valueDisplayList(idBase);
      }

      return this._uiUpdater;
   }

   // Our Values Display is a List of ValueRows
   // Each ValueRow will display an additional set of [add] [delete] buttons.

   valueDisplayList(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return `${idBase}_${key}_${uniqueInstanceID}`;
      };
      var ids = {
         updateForm: myUnique("updateForm"),
      };

      var _ui = {
         view: "form",
         id: ids.updateForm,
         elements: [],
      };

      var init = (valueRules) => {
         valueRules = valueRules || this.valueRules;
         _logic.setValues(valueRules);
      };

      var _logic = {
         removeAddRow: () => {
            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // check row that's unselect a field
            var rows = UpdateForm.getChildViews();

            var addRow = rows.filter((r) => {
               return r.queryView(function (view) {
                  return view.config.name == "field" && !view.getValue();
               });
            })[0];
            if (!addRow) return;

            UpdateForm.removeView(addRow);
         },

         // addRow
         // add a new data entry to this form.
         // @param {obj} data  (optional) initial values for this row.
         addRow: (data) => {
            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // check row that's unselect a field
            var rows = UpdateForm.getChildViews();
            if (
               data == null &&
               rows.filter((r) => {
                  return r.queryView(function (view) {
                     return view.config.name == "field" && !view.getValue();
                  });
               }).length > 0
            )
               return;

            // get a new Row Component
            var row = this.valueDisplayRow(idBase);

            // add row to Form
            UpdateForm.addView(row.ui);

            // initialize row with any provided data:
            row.init({
               onAdd: () => {
                  // add a new Row
                  _logic.addRow();
               },
               onDelete: (rowId) => {
                  // remove a row
                  _logic.delRow(rowId);
               },
               data: data,
            });

            // store this row
            this.formRows.push(row);
         },

         delRow: (rowId) => {
            // store this row
            this.formRows.forEach((r, index) => {
               if (r.ui.id == rowId) this.formRows.splice(index, 0);
            });

            // get our Form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // remove UI
            UpdateForm.removeView($$(rowId));
         },

         formClear: () => {
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            var children = UpdateForm.getChildViews();

            // NOTE: need to clone this array, because it is connected with the UpdatForm's
            // internal array of items.  Once we start .removeView() the element actually
            // is removed from the internal array, which then upset's the .forEach() from
            // properly iterating through the structure.  It results in missed items from
            // being sent to the .forEach().
            // So Clone it and use that for .forEach()
            var cloneChildren = [];
            children.forEach((c) => {
               cloneChildren.push(c);
            });
            cloneChildren.forEach((c) => {
               UpdateForm.removeView(c);
            });

            // clear our stored .formRows
            this.formRows = [];
         },

         formGet: () => {
            var UpdateForm = $$(ids.updateForm);
            if (!UpdateForm) {
               // this is a problem!
               this.currentForm.AB.notify.developer(
                  new Error("no webix form"),
                  {
                     context:
                        "ABViewRuleActionObjectUpdater:formGet  could not find webix form",
                     id: ids.updateForm,
                  }
               );
               return null;
            }

            return UpdateForm;
         },

         setValues: (valueRules) => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }

            valueRules = valueRules || {};
            valueRules.fieldOperations = valueRules.fieldOperations || [];

            // find the form
            var UpdateForm = _logic.formGet();
            if (!UpdateForm) return;

            // clear form:
            _logic.formClear();

            // if there are values to
            if (valueRules.fieldOperations.length > 0) {
               valueRules.fieldOperations.forEach((r) => {
                  _logic.addRow(r);
               });
            }

            // our default operation will cause an empty row to
            // appear after our first value entry.
            // let's remove that one, and then add a new one
            // at the end:
            _logic.removeAddRow();

            // display an empty row
            _logic.addRow();
         },

         fromSettings: (settings) => {
            // Note: we just want the { valueRules:[] } here:
            var mySettings = settings.valueRules || settings;

            _logic.setValues(mySettings);
         },

         toSettings: () => {
            // valueRules = {
            //	fieldOperations:[
            //		{ fieldID:xxx, value:yyyy, type:zzz, op:aaa }
            //	]
            // }
            var settings = { fieldOperations: [] };

            // for each of our formRows, decode the propery {}
            this.formRows.forEach((fr) => {
               var rowSettings = fr.toSettings();
               if (rowSettings) {
                  settings.fieldOperations.push(fr.toSettings());
               }
            });

            return settings;
         },
      };

      return {
         ui: _ui,
         init: init,
         fromSettings: (settings) => {
            _logic.fromSettings(settings);
         },
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   valueDisplayRow(idBase) {
      var uniqueInstanceID = webix.uid();
      var myUnique = (key) => {
         // return idBase + '_' + key  + '_' + uniqueInstanceID;
         return key + "_" + uniqueInstanceID;
      };

      var ids = {
         row: myUnique("row"),
         updateForm: myUnique("updateFormRow"),
         field: myUnique("field"),
         value: myUnique("value"),
         selectDc: myUnique("selectDc"),
         selectBy: myUnique("selectBy"),
         queryField: myUnique("queryField"),
         multiview: myUnique("multiview"),
         buttonAdd: myUnique("add"),
         buttonDelete: myUnique("delete"),
      };

      var FilterComponent;

      var _logic = {
         callbacks: {
            onAdd: () => {},
            onDelete: () => {},
         },

         buttonsToggle: () => {
            $$(ids.row).getChildViews()[0].getChildViews()[4].hide();
            $$(ids.row).getChildViews()[0].getChildViews()[5].show();
         },

         getFieldList: (shouldFilter) => {
            var options = [];
            if (this.updateObject) {
               options = (this.updateObject.fields() || []).map((f) => {
                  return {
                     id: f.id,
                     value: f.label,
                  };
               });

               // options = (this.updateObject.fields() || [])
               // .filter(f => {
               //
               // 	if (f.key != 'connectObject') {
               // 		return true;
               // 	} else {
               // 		// if this is a connection field, only return
               // 		// fields that are 1:x  where this field is the
               // 		// source:
               // 		// return ((f.linkType() == 'one') && (f.isSource()))
               //
               // 		// 6-14-2018 Changing from only 1:x to support many
               // 		// if this is a connected field, only return
               // 		// fields that this is the source
               // 		return (f.isSource())
               // 	}
               // })
               // .map(f => {
               // 	return {
               // 		id: f.id,
               // 		value: f.label
               // 	};
               // });

               // Remove fields who are selected
               if (shouldFilter) {
                  // store this row
                  var usedHash = {};
                  this.formRows.forEach((row) => {
                     var rowView = $$(row.ui.id);
                     if (rowView) {
                        var field = rowView
                           .getChildViews()[0]
                           .getChildViews()[1];
                        usedHash[field.getValue()] = true;
                     }
                  });
                  options = options.filter((o) => {
                     return !usedHash[o.id];
                  });
               }
            }
            return options;
         },

         isValid: () => {
            var validator = this.currentForm.AB.Validation.validator();
            var valueField = $$(ids.row).getChildViews()[0].getChildViews()[3];
            var FormView = valueField.getParentView().getParentView();

            var field = this.getUpdateObjectField($$(ids.field).getValue());
            if (field) {
               var value = field.getValue(valueField, {});

               // // if a standard component that supports .getValue()
               // if (valueField.getValue) {
               // 	value = valueField.getValue();
               // } else {
               // 	// else use for field.getValue();
               // 	value = field.getValue(valueField, {});
               // }

               // our .isValidData() wants value in an object:
               var obj = {};
               obj[field.columnName] = value;

               field.isValidData(obj, validator);

               // if value is empty, this is also an error:
               if (
                  value == "" ||
                  value == null ||
                  (Array.isArray(value) && value.length == 0)
               ) {
                  validator.addError(
                     field.columnName,
                     L("A value is required")
                  );
               }

               // field.getParentView()  ->  row
               // row.getParentView()  -> Form
               FormView.clearValidation();
               validator.updateForm(FormView);

               return validator.pass();
            } else {
               // if we didn't find an associated field ... then this isn't good
               // data.

               //// TODO: display error for our field picker.  Note, it doesn't have a unique .name
               // field.
               var fieldField = $$(ids.row)
                  .getChildViews()[0]
                  .getChildViews()[1];
               fieldField.define("invalidMessage", L("A value is required"));
               fieldField.define("invalid", true);
               fieldField.refresh();
               // fieldField.markInvalid(this.labels.component.errorRequired);
               return false;
            }
         },

         selectField: (columnID) => {
            var field = this.getUpdateObjectField(columnID);
            if (!field) return;

            var fieldComponent = field.formComponent(),
               abView = fieldComponent.newInstance(field.object.application),
               formFieldComponent = abView.component(this.App),
               $componentView = formFieldComponent.ui,
               $inputView;

            $componentView.id = ids.value; // set our expected id

            // find all the DataSources
            var datasources = this.currentForm.AB.datacollections(
               (dc) => dc.datasource
            );

            // create a droplist with those dataSources
            var optionsDataSources = [];
            datasources.forEach((dc) => {
               optionsDataSources.push({ id: dc.id, value: dc.label });
            });

            // create a droplist with select options
            var optionsSelectBy = [
               { id: "select-one", value: L("Current selection") },
               {
                  id: "filter-select-one",
                  value: L("Select first after filter by..."),
               },
            ];

            var $optionUpdateExsits = {
               type: "clean",
               rows: [
                  {
                     cols: [
                        {
                           id: ids.selectDc,
                           view: "combo",
                           options: optionsDataSources,
                           placeholder: L("Choose a data source"),
                           on: {
                              onChange: (newv, oldv) => {
                                 var selectedDC =
                                    this.currentForm.AB.datacollectionByID(
                                       newv
                                    );
                                 if (
                                    selectedDC &&
                                    (selectedDC.sourceType == "query" ||
                                       !field.isConnection)
                                 ) {
                                    var queryFieldOptions = [];
                                    selectedDC.datasource
                                       .fields()
                                       .forEach((f) => {
                                          queryFieldOptions.push({
                                             id: f.id,
                                             value: f.label,
                                          });
                                       });
                                    $$(ids.queryField).define(
                                       "options",
                                       queryFieldOptions
                                    );
                                    $$(ids.queryField).refresh();
                                    $$(ids.queryField).show();
                                 } else {
                                    $$(ids.queryField).hide();
                                 }
                              },
                           },
                        },
                        // we will place a list of query fields if you choose a datasource that has a query source type
                        {
                           id: ids.queryField,
                           view: "combo",
                           hidden: true,
                           placeholder: L("Choose value from..."),
                           options: [{ id: 1, value: "figure this out" }],
                        },
                     ],
                  },
                  {
                     id: ids.selectBy,
                     view: "combo",
                     options: optionsSelectBy,
                     placeholder: L("Choose select option"),
                     on: {
                        onChange: (newv, oldv) => {
                           var $row = $$(ids.row);
                           $row.removeView($row.getChildViews()[1]);
                           if (newv == "select-one") {
                              $row.addView({}, 1);
                           } else {
                              var options =
                                 this.currentForm.datacollection.datasource
                                    .fields()
                                    .map(function (f) {
                                       return {
                                          id: f.id,
                                          value: f.label,
                                       };
                                    });

                              FilterComponent = this.AB.filterComplexNew(
                                 `${idBase}_filter`
                              );
                              // FilterComponent.applicationLoad(
                              //    this.currentForm.application
                              // );
                              FilterComponent.init({
                                 isRecordRule: true,
                                 recordRuleFieldOptions: options,
                              });
                              FilterComponent.on("change", (val) => {
                                 _logic.onFilterChange(val);
                              });

                              $row.addView(FilterComponent.ui, 1);

                              var dcId = $$(ids.selectDc).getValue();
                              var dataCollection =
                                 this.currentForm.AB.datacollectionByID(dcId);
                              if (dataCollection) {
                                 _logic.populateFilters(dataCollection);
                              }
                           }
                        },
                     },
                  },
               ],
            };

            // WORKAROUND: add '[Current User]' option to the user data field
            if (field.key == "user") {
               $componentView.options = $componentView.options || [];
               $componentView.options.unshift({
                  id: "ab-current-user",
                  value: L("[Current User]"),
               });
            }

            // UPDATE: ok, in practice we have not had any use cases where
            // we want individual values on connectedObject fields, but
            // instead we want to insert the current selected element from
            // a relevant data view.  So, replace the fieldComponet
            // from a connectedObject field with a list of data views that
            // are based upon the same object we are connected to:
            if (field.isConnection) {
               // find the ABObject this field connects to
               var connectedObject = field.datasourceLink;

               // find all the DataSources that are based upon this ABObject
               // to do this, we find the root Page we are on, then ask that Page for datasources:
               datasources = datasources.filter((dc) => {
                  return dc.datasource.id == connectedObject.id;
               });

               var dcQueries = this.currentForm.AB.datacollections((dc) => {
                  return (
                     dc.sourceType == "query" &&
                     dc.datasource &&
                     dc.datasource.canFilterObject(connectedObject)
                  );
                  // return dc.datasource.id == connectedObject.id;
               });

               datasources = datasources.concat(dcQueries);

               // refresh a droplist with those dataSources
               optionsDataSources = [];
               datasources.forEach((dc) => {
                  optionsDataSources.push({ id: dc.id, value: dc.label });
               });

               // add select an array value option
               optionsSelectBy.push({
                  id: "filter-select-all",
                  value: L("Select all after filter by..."),
               });

               $inputView = $optionUpdateExsits;

               // and the upcoming formFieldComponent.init()
               // doesn't need to do anything:
               formFieldComponent = {
                  init: function () {},
               };

               // and we reset field so it's customDisplay isn't called:
               // field = {};
            } else {
               $inputView = {
                  id: ids.multiview,
                  view: "multiview",
                  cells: [
                     {
                        batch: "custom",
                        rows: [
                           $componentView,
                           {
                              view: "label",
                              label: `<a>${L("Or exists value")}</a>`,
                              on: {
                                 onItemClick: function () {
                                    var $container = this.getParentView(),
                                       $multiview = $container.getParentView();

                                    $multiview.showBatch("exist");
                                 },
                              },
                           },
                        ],
                     },
                     {
                        // Update value from exists object
                        batch: "exist",
                        rows: [
                           $optionUpdateExsits,
                           {
                              view: "label",
                              label: `<a>${L("Or custom value")}</a>`,
                              on: {
                                 onItemClick: function () {
                                    var $container = this.getParentView(),
                                       $multiview = $container.getParentView();

                                    // clear filter view
                                    $$(ids.selectBy).setValue("select-one");

                                    $multiview.showBatch("custom");
                                 },
                              },
                           },
                        ],
                     },
                  ],
               };
            }

            // Change component to display this field's form input
            var $row = $$(ids.row).getChildViews()[0];
            $row.removeView($row.getChildViews()[3]);
            $row.addView($inputView, 3);

            formFieldComponent.init();

            // Show custom display of data field
            if (!field.isConnection && field.customDisplay) {
               // field.customDisplay(field, this.App, $row.getChildViews()[3].$view, {

               var compNodeView = $$($componentView.id).$view;

               // wait until render UI complete
               setTimeout(() => {
                  field.customDisplay(field, this.App, compNodeView, {
                     editable: true,

                     // tree
                     isForm: true,
                  });
               }, 50);
            }

            // Show the remove button
            var $buttonRemove = $row.getChildViews()[4];
            $buttonRemove.show();

            // Add a new row
            if (columnID) _logic.callbacks.onAdd();
         },

         setValue: (data) => {
            $$(ids.field).setValue(data.fieldID);
            // note: this triggers our _logic.selectField() fn.
            var field = this.getUpdateObjectField(data.fieldID);
            if (field) {
               var setValueFn = () => {
                  $$(ids.selectDc).setValue(data.value);
                  if (data.queryField) {
                     $$(ids.queryField).setValue(data.queryField);
                  }
                  var selectBy = data.selectBy || "select-one";
                  $$(ids.selectBy).setValue(selectBy);

                  if (selectBy != "select-one") {
                     var collectionId = data.value;
                     var dataCollection =
                        this.currentForm.AB.datacollectionByID(collectionId);
                     if (dataCollection && data.filterConditions) {
                        _logic.populateFilters(
                           dataCollection,
                           data.filterConditions
                        );
                     }
                  }
               };

               // now handle our special connectedObject case:
               if (field.isConnection) {
                  setValueFn();
               } else {
                  if (data.valueType == "exist") {
                     $$(ids.multiview).showBatch("exist");

                     setValueFn();
                  } else {
                     $$(ids.multiview).showBatch("custom");

                     // wait until render UI complete
                     setTimeout(function () {
                        // set value to custom field
                        var rowData = {};
                        rowData[field.columnName] = data.value;
                        field.setValue($$(ids.value), rowData);
                     }, 50);
                  }
               }
            }
         },

         populateFilters: (dataView, filterConditions) => {
            filterConditions =
               filterConditions ||
               ABViewRuleActionObjectUpdaterDefaults.filterConditions;

            // Populate data to popups
            // FilterComponent.objectLoad(objectCopy);
            FilterComponent.fieldsLoad(
               dataView.datasource ? dataView.datasource.fields() : []
            );
            FilterComponent.setValue(filterConditions);
         },

         toSettings: () => {
            // if this isn't the last entry row
            // * a row with valid data has the [delete] button showing.
            var buttonDelete = $$(ids.buttonDelete);
            if (buttonDelete && buttonDelete.isVisible()) {
               var data = {};
               data.fieldID = $$(ids.field).getValue();

               var $valueField = $$(ids.value);
               var field = this.getUpdateObjectField(data.fieldID);

               var getValueFn = () => {
                  data.value = $$(ids.selectDc).getValue();
                  data.queryField = $$(ids.queryField).getValue();
                  data.op = "set"; // possible to create other types of operations.
                  data.type = field.key;
                  data.selectBy = $$(ids.selectBy).getValue();
                  data.valueType = "exist";
                  if (FilterComponent) {
                     data.filterConditions = FilterComponent.getValue();
                  }
               };

               // now handle our special connectedObject case:
               if (field.isConnection) {
                  getValueFn();
               } else {
                  if ($$(ids.multiview).config.visibleBatch == "exist") {
                     getValueFn();
                  } else {
                     data.value = field.getValue($valueField, {});
                     data.op = "set"; // possible to create other types of operations.
                     data.type = field.key;
                     data.valueType = "custom";
                  }
               }

               return data;
            } else {
               return null;
            }
         },
      };

      var _ui = {
         id: ids.row,
         view: "layout",
         rows: [
            {
               cols: [
                  {
                     // Label
                     view: "label",
                     width: this.currentForm.AB.Config.labelWidthSmall,
                     label: L("Set"),
                  },
                  {
                     // Field list
                     view: "combo",
                     name: "field",
                     placeholder: L("Choose a field"),
                     id: ids.field,
                     height: 32,
                     options: _logic.getFieldList(true),
                     on: {
                        onChange: function (columnId) {
                           _logic.selectField(columnId);
                        },
                     },
                  },
                  {
                     // Label
                     view: "label",
                     width: this.currentForm.AB.Config.labelWidthSmall,
                     label: L("To"),
                  },

                  // Field value
                  // NOTE: this view gets replaced each time a field is selected.
                  // We replace it with a component associated with the Field
                  {},

                  {
                     // "Remove" button
                     view: "button",
                     css: "webix_danger",
                     id: ids.buttonDelete,
                     icon: "fa fa-trash",
                     type: "icon",
                     width: 30,
                     hidden: true,
                     click: function () {
                        _logic.callbacks.onDelete(ids.row);
                     },
                  },
               ],
            },
            {}, // we will add filters here if we need them
         ],
      };

      var init = (options) => {
         for (var c in _logic.callbacks) {
            _logic.callbacks[c] = options[c] || _logic.callbacks[c];
         }

         if (options.data) {
            // options.data = { formID:xxx, value:yyy,  type:zzzz }
            _logic.setValue(options.data);

            // _logic.buttonsToggle();
         }
      };

      return {
         ui: _ui,
         init: init,
         toSettings: () => {
            return _logic.toSettings();
         },
         _logic: _logic,
      };
   }

   getUpdateObjectField(fieldID) {
      return (
         this.queryObject?.fieldByID(fieldID) ??
         this.updateObject?.fieldByID(fieldID) ??
         this.currentForm.AB.fieldNew(
            this.currentForm.AB.definitionByID(fieldID) ?? {},
            this.currentForm.AB.objectNew({})
         )
      );
   }

   /**
    * @method processUpdateObject
    * Perform the specified update actions on the provided objectToUpdate
    * @param {obj} options  Additional information required to make updates.
    * @param {obj} objectToUpdate  The object to make the updates on.
    * @return {boolean}   true if an update took place, false if no updates.
    */
   processUpdateObject(options, objectToUpdate) {
      this._formData = objectToUpdate;
      // return new Promise((resolve, reject) => {
      var isUpdated = false;

      this.valueRules = this.valueRules || {};
      this.valueRules.fieldOperations = this.valueRules.fieldOperations || [];

      // var allPromises = [];

      // for each of our operations
      this.valueRules.fieldOperations.forEach((op) => {
         // op = {
         // 	fieldID:'zzzzz',
         //	value: 'xxx',
         //	op: 'set',
         //  type:'',
         //  queryField: '', // id of ABField
         //  selectBy:'',   ['select-one', 'filter-select-one', 'filter-select-all']
         //  valueType: "", ['custom', 'exist']
         // 	filterConditions: { // array of filters to apply to the data table
         //		glue: 'and',
         // 		rules: []
         //  }
         // }

         var field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;

         let value = op?.value?.id ?? op?.value;

         switch (value) {
            case "ab-current-user":
               value = this.currentForm.AB.Account.username();
               break;
            case "ab-current-date":
               value = new Date();
               break;
         }

         // in the case of a connected Field, we use op.value to get the
         // datacollection, and find it's currently selected value:
         if (field.isConnection || op.valueType == "exist") {
            // NOTE: 30 May 2018 :current decision from Ric is to limit this
            // to only handle 1:x connections where we update the current obj
            // with the PK of the value from the DC.
            //
            // In the future, if we want to handle the other options,
            // we need to modify this to handle the M:x connections where
            // we insert our PK into the value from the DC.

            // op.value is the ABDatacollection.id we need to find
            const dataCollection = this.currentForm.AB.datacollectionByID(
               op.value
            );
            if (!dataCollection) return;

            // we don't want to mess with the dataView directly since it might
            // be used by other parts of the system and this refresh might reset
            // it's cursor.
            // var clonedDataCollection = dataView.filteredClone(op.filterConditions);

            // loop through rules to find "same-as-field" or "not-same-as-field"
            // adjust operator and switch key value to actual value when found
            var filterConditions = this.currentForm.AB.cloneDeep(
               op.filterConditions
            );
            if (filterConditions && filterConditions.rules) {
               filterConditions.rules
                  .filter((r) => {
                     return (
                        r.rule == "same_as_field" ||
                        r.rule == "not_same_as_field"
                     );
                  })
                  .forEach((item) => {
                     var valueField =
                        this.currentForm.datacollection.datasource.fieldByID(
                           item.value
                        );
                     if (valueField.isConnection) {
                        item.value = valueField.format(this._formData);
                     } else {
                        item.value = this._formData[valueField.columnName];
                     }

                     if (item.rule == "not_same_as_field") {
                        item.rule = "not equals";
                     } else {
                        item.rule = "equals";
                     }
                  });
            }

            let clonedDataCollection =
               dataCollection.filteredClone(filterConditions);

            switch (op.selectBy) {
               // the 'select-one' is getting the currently set cursor on this data collection
               // and using that value.
               // TODO: rename to 'select-cursor'
               case "select-one":
               default: // dataView.getItem(dataView.getCursor());
                  value = clonedDataCollection.getCursor();

                  if (value) {
                     // NOTE: webix documentation issue: .getCursor() is supposed to return
                     // the .id of the item.  However it seems to be returning the {obj}

                     if (op.valueType == "exist") {
                        let fieldWithValue =
                           clonedDataCollection.datasource.fieldByID(
                              op.queryField
                           );

                        if (fieldWithValue)
                           value = value[fieldWithValue.columnName];
                     } else if (value.id) {
                        value = value.id;
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (!value) break;

                        if (field.isConnection) {
                           // if we are setting a connection we do not want to pass the full object because
                           // batch creates payload gets too large
                           objectToUpdate[field.columnName] = {};
                           objectToUpdate[field.columnName].id =
                              value[field.datasourceLink.PK()];
                           objectToUpdate[field.columnName][
                              field.datasourceLink.PK()
                           ] = value[field.datasourceLink.PK()];

                           // If the connect field use the custom FK, then it requires to pass value of the custom FK.
                           if (field.settings.isCustomFK) {
                              if (field.indexField) {
                                 objectToUpdate[field.columnName][
                                    field.indexField.columnName
                                 ] = value[field.indexField.columnName];
                              }
                              if (field.indexField2) {
                                 objectToUpdate[field.columnName][
                                    field.indexField2.columnName
                                 ] = value[field.indexField2.columnName];
                              }
                           }

                           field.datasourceLink
                              .fields(
                                 (f) =>
                                    f.key == "combined" || f.key == "AutoIndex"
                              )
                              .forEach((f) => {
                                 objectToUpdate[field.columnName][
                                    f.columnName
                                 ] = value[f.columnName];
                              });
                        } else {
                           objectToUpdate[field.columnName] = value;
                        }

                        break;
                  }
                  break;

               // attempt to filter this data collection by the given filterConditions
               case "filter-select-all":
                  var newValues = [];

                  var currRow = clonedDataCollection.getFirstRecord();
                  while (currRow) {
                     // do something there

                     switch (clonedDataCollection.sourceType) {
                        // case: datacollection is an object
                        // we want to set our field to this values
                        case "object":
                           newValues.push(currRow.id);
                           break;

                        // case: datacollection is a query
                        // our field is a pointer to an object. we want to pull out that object
                        // from the query data.
                        case "query": {
                           let fieldWithValue =
                              clonedDataCollection.datasource.fieldByID(
                                 op.queryField
                              );

                           var newValue = currRow[fieldWithValue.columnName];

                           if (typeof newValue == "undefined") {
                              newValue = currRow[fieldWithValue.relationName()];

                              if (Array.isArray(newValue)) {
                                 newValue = newValue.map((v) => {
                                    return v.id ? v.id : v;
                                 });
                              } else if (newValue.id) {
                                 newValue = newValue.id;
                              }
                           }

                           newValues = this.currentForm.AB.uniq(
                              newValues.concat(newValue)
                           );

                           break;
                        }
                     }

                     currRow = clonedDataCollection.getNextRecord(currRow);
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        if (field.linkType() == "one") {
                           var updates = [];
                           newValues.forEach((v) => {
                              var objectToUpdateClone =
                                 this.currentForm.AB.cloneDeep(objectToUpdate);
                              objectToUpdateClone[field.columnName] = v;
                              updates.push(objectToUpdateClone);
                           });
                           objectToUpdate.newRecords = updates;
                        } else {
                           objectToUpdate[field.columnName] = newValues;
                        }
                        break;
                  }
                  break;

               case "filter-select-one":
                  newValues = [];

                  value = clonedDataCollection.getFirstRecord();

                  if (value) {
                     // case: datacollection is a query
                     // our field is a pointer to an object. we want to pull out that object
                     // from the query data.
                     if (
                        clonedDataCollection.sourceType == "query" ||
                        (op.valueType == "exist" && op.queryField)
                     ) {
                        let fieldWithValue =
                           clonedDataCollection.datasource.fieldByID(
                              op.queryField
                           );

                        newValue = value[fieldWithValue.columnName];

                        if (typeof newValue == "undefined") {
                           newValue = value[fieldWithValue.relationName()];
                           if (Array.isArray(newValue)) {
                              newValue = newValue[0];
                           }
                           if (newValue.id) newValue = newValue.id;
                        }

                        value = newValue;
                     }
                     // case: datacollection is an object
                     // we want to set our field to this values
                     else if (clonedDataCollection.sourceType == "object") {
                        // NOTE: webix documentation issue: .getCursor() is supposed to return
                        // the .id of the item.  However it seems to be returning the {obj}

                        // we need to use the objects indexField(2) if there is one
                        // otherwise default to the id
                        var lookup;
                        if (field.indexField) {
                           lookup = field.indexField.columnName;
                        } else if (field.indexField2) {
                           lookup = field.indexField2.columnName;
                        }
                        if (lookup && value[lookup]) {
                           value = value[lookup];
                        } else if (value.id) {
                           value = value.id;
                        }
                     }
                  }

                  // QUESTION: if value returns undefined should we do something else?
                  switch (op.op) {
                     case "set":
                        objectToUpdate[field.columnName] = value;
                        break;
                  }
                  break;
            }

            isUpdated = true;

            // allPromises.push(connectedPromise);
         } else {
            // var setPromise = new Promise((resolve, reject) => {
            switch (op.op) {
               case "set":
                  objectToUpdate[field.columnName] = value;
                  break;
            }

            isUpdated = true;

            //    resolve(isUpdated);
            // });

            // allPromises.push(setPromise);

            // console.log("finished");
         }
      });

      return isUpdated;
      // Promise.all(allPromises).then(() => {
      //    resolve(isUpdated);
      // });
      // });
   }

   // process
   // gets called when a form is submitted and the data passes the Query Builder Rules.
   // @param {obj} options
   // @return {Promise}
   process(options) {
      this._formData = options.data;

      return new Promise((resolve, reject) => {
         let isUpdated = this.processUpdateObject({}, options.data);
         if (!isUpdated) {
            resolve();
         } else {
            // get the model from the provided Form Obj:
            var dv = options.form.datacollection;
            if (!dv) return resolve();

            var model = dv.model;
            model
               .update(options.data.id, options.data)
               .then(resolve)
               .catch((err) => {
                  this.currentForm.AB.notify.developer(err, {
                     context:
                        "ABViewRuleActionObjectUpdater:process  update error",
                     id: options.data.id,
                     data: options.data,
                  });
                  reject(err);
               });
         }
      });
   }

   // objectLoad
   // save the current object this Action is associated with.
   objectLoad(object) {
      super.objectLoad(object);
      this.updateObjectLoad(object);
   }

   // updateObjectLoad
   // save the given object as the object we will update.
   updateObjectLoad(object) {
      // stash rules for old object
      if (this.updateObject) {
         this.stashRules[this.updateObject.id] = this.valueRules;
      }

      this.updateObject = object;

      // with a new updateObject, then reset our UI
      this._uiUpdater = null;

      // reload any stashed rules, or set to {}
      this.valueRules = this.stashRules[this.updateObject.id] || {};
   }

   // fromSettings
   // initialize this Action from a given set of setting values.
   // @param {obj}  settings
   fromSettings(settings) {
      settings = settings || {};

      super.fromSettings(settings); // let the parent handle the QB

      // make sure UI is updated:
      // set our updateObject
      if (settings.updateObjectURL) {
         var updateObject = this.currentForm.application.urlResolve(
            settings.updateObjectURL
         );
         this.updateObject = updateObject;
      }

      // if we have a display component, then populate it:
      if (this._uiUpdater) {
         // now we handle our valueRules:{} object settings.
         // pass the settings off to our DisplayList component:
         this._uiUpdater.fromSettings(settings);
      }
   }

   // toSettings
   // return an object that represents the current state of this Action
   // @return {obj}
   toSettings() {
      // settings: {
      //	valueRules:{}
      // }

      // let our parent store our QB settings
      var settings = super.toSettings();

      settings.valueRules = this._uiUpdater.toSettings();
      settings.updateObjectURL = this.updateObject.urlPointer();

      return settings;
   }

   /**
    * @method isReady()
    * returns a promise that gets resolved once our action is ready to work.
    * Here we need to scan each of our field operations, and verify all
    * related data collections are initialized before we can continue.
    * @return {Promise}
    */
   isReady() {
      var allReady = [];
      let fieldOps = this.valueRules?.fieldOperations ?? [];
      fieldOps.forEach((op) => {
         let field = this.getUpdateObjectField(op.fieldID);
         if (!field) return;
         if (!field.isConnection && op.valueType !== "exist") return;

         // this references a DC
         let DC = this.currentForm.AB.datacollectionByID(op.value);
         if (DC?.dataStatus === DC?.dataStatusFlag.initialized) return;

         // not ready yet, so wait until the 'initializedData' event
         allReady.push(
            new Promise((resolve /*, reject */) => {
               DC.on("initializedData", () => {
                  resolve();
               });
            })
         );
      });
      return Promise.all(allReady);
   }
};


/***/ }),

/***/ 96253:
/*!*****************************************!*\
  !*** ./AppBuilder/uiSettings/config.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _configDesktop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./configDesktop */ 26173);
/* harmony import */ var _configMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configMobile */ 26737);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ 65484);
/**
 * @class config
 *
 * Manage our configuration settings.
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   config: function () {
      // TODO: decide which config file to return here:
      if (window.innerWidth < 768) {
         return _configMobile__WEBPACK_IMPORTED_MODULE_0__["default"];
      }
      return _configDesktop__WEBPACK_IMPORTED_MODULE_1__["default"];
   },
   icons: _icons__WEBPACK_IMPORTED_MODULE_2__["default"].icons,
});


/***/ }),

/***/ 26173:
/*!************************************************!*\
  !*** ./AppBuilder/uiSettings/configDesktop.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class configDesktop
 *
 * Manage our configuration settings for Desktop styles.

 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Application List
   appListRowHeight: 67,

   // button types
   buttonWidthLarge: 200,
   buttonWidthMedium: 150,
   buttonWidthSmall: 100,
   buttonWidthExtraSmall: 50,

   // tab types
   tabWidthLarge: 200,
   tabWidthMedium: 120,
   tabWidthSmall: 100,
   tabWidthExtraSmall: 50,

   // column types
   columnWidthXLarge: 350,
   columnWidthLarge: 250,
   columnWidthMedium: 200,
   columnWidthSmall: 150,
   columnWidthExtraSmall: 100,

   // spacers
   xSmallSpacer: 5,
   smallSpacer: 10,
   mediumSpacer: 25,
   largeSpacer: 50,
   xLargeSpacer: 100,
   xxLargeSpacer: 200,
   xxxLargeSpacer: 400,
   appListSpacerRowHeight: 100,
   appListSpacerColMinWidth: 100,
   appListSpacerColMaxWidth: 200,
   objectWorkspaceColWidth: 20,

   // labels
   labelWidthSmall: 50,
   labelWidthMedium: 80,
   labelWidthLarge: 120,
   labelWidthXLarge: 150,
   labelWidthXXLarge: 200,
   labelWidthXXXLarge: 280,
   labelWidthCheckbox: 0,

   // show elements on desktop
   hideMobile: false,
});


/***/ }),

/***/ 26737:
/*!***********************************************!*\
  !*** ./AppBuilder/uiSettings/configMobile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class configMobile
 *
 * Manage our configuration settings for mobile styles.

 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   // Application List
   appListRowHeight: 67,

   // button types
   buttonWidthLarge: 200,
   buttonWidthMedium: 150,
   buttonWidthSmall: 100,
   buttonWidthExtraSmall: 50,

   // tab types
   tabWidthLarge: 200,
   tabWidthMedium: 120,
   tabWidthSmall: 100,
   tabWidthExtraSmall: 50,

   // column types
   columnWidthLarge: 250,
   columnWidthMedium: 200,
   columnWidthSmall: 150,
   columnWidthExtraSmall: 100,

   // spacers
   xSmallSpacer: 1,
   smallSpacer: 1,
   mediumSpacer: 10,
   largeSpacer: 20,
   xLargeSpacer: 50,
   xxLargeSpacer: 100,
   xxxLargeSpacer: 120,
   appListSpacerRowHeight: 10,
   appListSpacerColMinWidth: 1,
   appListSpacerColMaxWidth: 1,
   objectWorkspaceColWidth: 1,

   // labels
   labelWidthSmall: 50,
   labelWidthMedium: 80,
   labelWidthLarge: 120,
   labelWidthXLarge: 120,
   labelWidthXXLarge: 120,
   labelWidthCheckbox: 0,

   // hide elements for mobile
   hideMobile: true,
});


/***/ }),

/***/ 65484:
/*!****************************************!*\
  !*** ./AppBuilder/uiSettings/icons.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
   icons: [
      "500px",
      "address-book",
      "address-book-o",
      "address-card",
      "address-card-o",
      "adjust",
      "adn",
      "align-center",
      "align-justify",
      "align-left",
      "align-right",
      "amazon",
      "ambulance",
      "american-sign-language-interpreting",
      "anchor",
      "android",
      "angellist",
      "angle-double-down",
      "angle-double-left",
      "angle-double-right",
      "angle-double-up",
      "angle-down",
      "angle-left",
      "angle-right",
      "angle-up",
      "apple",
      "archive",
      "area-chart",
      "arrow-circle-down",
      "arrow-circle-left",
      "arrow-circle-o-down",
      "arrow-circle-o-left",
      "arrow-circle-o-right",
      "arrow-circle-o-up",
      "arrow-circle-right",
      "arrow-circle-up",
      "arrow-down",
      "arrow-left",
      "arrow-right",
      "arrow-up",
      "arrows",
      "arrows-alt",
      "arrows-h",
      "arrows-v",
      "asl-interpreting",
      "assistive-listening-systems",
      "asterisk",
      "at",
      "audio-description",
      "automobile",
      "backward",
      "balance-scale",
      "ban",
      "bandcamp",
      "bank",
      "bar-chart",
      "bar-chart-o",
      "barcode",
      "bars",
      "bath",
      "bathtub",
      "battery",
      "battery-0",
      "battery-1",
      "battery-2",
      "battery-3",
      "battery-4",
      "battery-empty",
      "battery-full",
      "battery-half",
      "battery-quarter",
      "battery-three-quarters",
      "bed",
      "beer",
      "behance",
      "behance-square",
      "bell",
      "bell-o",
      "bell-slash",
      "bell-slash-o",
      "bicycle",
      "binoculars",
      "birthday-cake",
      "bitbucket",
      "bitbucket-square",
      "bitcoin",
      "black-tie",
      "blind",
      "bluetooth",
      "bluetooth-b",
      "bold",
      "bolt",
      "bomb",
      "book",
      "bookmark",
      "bookmark-o",
      "braille",
      "briefcase",
      "btc",
      "bug",
      "building",
      "building-o",
      "bullhorn",
      "bullseye",
      "bus",
      "buysellads",
      "cab",
      "calculator",
      "calendar",
      "calendar-check-o",
      "calendar-minus-o",
      "calendar-o",
      "calendar-plus-o",
      "calendar-times-o",
      "camera",
      "camera-retro",
      "car",
      "caret-down",
      "caret-left",
      "caret-right",
      "caret-square-o-down",
      "caret-square-o-left",
      "caret-square-o-right",
      "caret-square-o-up",
      "caret-up",
      "cart-arrow-down",
      "cart-plus",
      "cc",
      "cc-amex",
      "cc-diners-club",
      "cc-discover",
      "cc-jcb",
      "cc-mastercard",
      "cc-paypal",
      "cc-stripe",
      "cc-visa",
      "certificate",
      "chain",
      "chain-broken",
      "check",
      "check-circle",
      "check-circle-o",
      "check-square",
      "check-square-o",
      "chevron-circle-down",
      "chevron-circle-left",
      "chevron-circle-right",
      "chevron-circle-up",
      "chevron-down",
      "chevron-left",
      "chevron-right",
      "chevron-up",
      "child",
      "chrome",
      "circle",
      "circle-o",
      "circle-o-notch",
      "circle-thin",
      "clipboard",
      "clock-o",
      "clone",
      "close",
      "cloud",
      "cloud-download",
      "cloud-upload",
      "cny",
      "code",
      "code-fork",
      "codepen",
      "codiepie",
      "coffee",
      "cog",
      "cogs",
      "columns",
      "comment",
      "comment-o",
      "commenting",
      "commenting-o",
      "comments",
      "comments-o",
      "compass",
      "compress",
      "connectdevelop",
      "contao",
      "copy",
      "copyright",
      "creative-commons",
      "credit-card",
      "credit-card-alt",
      "crop",
      "crosshairs",
      "css3",
      "cube",
      "cubes",
      "cut",
      "cutlery",
      "dashboard",
      "dashcube",
      "database",
      "deaf",
      "deafness",
      "dedent",
      "delicious",
      "desktop",
      "deviantart",
      "diamond",
      "digg",
      "dollar",
      "dot-circle-o",
      "download",
      "dribbble",
      "drivers-license",
      "drivers-license-o",
      "dropbox",
      "drupal",
      "edge",
      "edit",
      "eercast",
      "eject",
      "ellipsis-h",
      "ellipsis-v",
      "empire",
      "envelope",
      "envelope-o",
      "envelope-open",
      "envelope-open-o",
      "envelope-square",
      "envira",
      "eraser",
      "etsy",
      "eur",
      "euro",
      "exchange",
      "exclamation",
      "exclamation-circle",
      "exclamation-triangle",
      "expand",
      "expeditedssl",
      "external-link",
      "external-link-square",
      "eye",
      "eye-slash",
      "eyedropper",
      "fa",
      "facebook",
      "facebook-f",
      "facebook-official",
      "facebook-square",
      "fast-backward",
      "fast-forward",
      "fax",
      "feed",
      "female",
      "fighter-jet",
      "file",
      "file-archive-o",
      "file-audio-o",
      "file-code-o",
      "file-excel-o",
      "file-image-o",
      "file-movie-o",
      "file-o",
      "file-pdf-o",
      "file-photo-o",
      "file-picture-o",
      "file-powerpoint-o",
      "file-sound-o",
      "file-text",
      "file-text-o",
      "file-video-o",
      "file-word-o",
      "file-zip-o",
      "files-o",
      "film",
      "filter",
      "fire",
      "fire-extinguisher",
      "firefox",
      "first-order",
      "flag",
      "flag-checkered",
      "flag-o",
      "flash",
      "flask",
      "flickr",
      "floppy-o",
      "folder",
      "folder-o",
      "folder-open",
      "folder-open-o",
      "font",
      "font-awesome",
      "fonticons",
      "fort-awesome",
      "forumbee",
      "forward",
      "foursquare",
      "free-code-camp",
      "frown-o",
      "futbol-o",
      "gamepad",
      "gavel",
      "gbp",
      "ge",
      "gear",
      "gears",
      "genderless",
      "get-pocket",
      "gg",
      "gg-circle",
      "gift",
      "git",
      "git-square",
      "github",
      "github-alt",
      "github-square",
      "gitlab",
      "gittip",
      "glass",
      "glide",
      "glide-g",
      "globe",
      "google",
      "google-plus",
      "google-plus-circle",
      "google-plus-official",
      "google-plus-square",
      "google-wallet",
      "graduation-cap",
      "gratipay",
      "grav",
      "group",
      "h-square",
      "hacker-news",
      "hand-grab-o",
      "hand-lizard-o",
      "hand-o-down",
      "hand-o-left",
      "hand-o-right",
      "hand-o-up",
      "hand-paper-o",
      "hand-peace-o",
      "hand-pointer-o",
      "hand-rock-o",
      "hand-scissors-o",
      "hand-spock-o",
      "hand-stop-o",
      "handshake-o",
      "hard-of-hearing",
      "hashtag",
      "hdd-o",
      "header",
      "headphones",
      "heart",
      "heart-o",
      "heartbeat",
      "history",
      "home",
      "hospital-o",
      "hotel",
      "hourglass",
      "hourglass-1",
      "hourglass-2",
      "hourglass-3",
      "hourglass-end",
      "hourglass-half",
      "hourglass-o",
      "hourglass-start",
      "houzz",
      "html5",
      "i-cursor",
      "id-badge",
      "id-card",
      "id-card-o",
      "ils",
      "image",
      "imdb",
      "inbox",
      "indent",
      "industry",
      "info",
      "info-circle",
      "inr",
      "instagram",
      "institution",
      "internet-explorer",
      "intersex",
      "ioxhost",
      "italic",
      "joomla",
      "jpy",
      "jsfiddle",
      "key",
      "keyboard-o",
      "krw",
      "language",
      "laptop",
      "lastfm",
      "lastfm-square",
      "leaf",
      "leanpub",
      "legal",
      "lemon-o",
      "level-down",
      "level-up",
      "life-bouy",
      "life-buoy",
      "life-ring",
      "life-saver",
      "lightbulb-o",
      "line-chart",
      "link",
      "linkedin",
      "linkedin-square",
      "linode",
      "linux",
      "list",
      "list-alt",
      "list-ol",
      "list-ul",
      "location-arrow",
      "lock",
      "long-arrow-down",
      "long-arrow-left",
      "long-arrow-right",
      "long-arrow-up",
      "low-vision",
      "magic",
      "magnet",
      "mail-forward",
      "mail-reply",
      "mail-reply-all",
      "male",
      "map",
      "map-marker",
      "map-o",
      "map-pin",
      "map-signs",
      "mars",
      "mars-double",
      "mars-stroke",
      "mars-stroke-h",
      "mars-stroke-v",
      "maxcdn",
      "meanpath",
      "medium",
      "medkit",
      "meetup",
      "meh-o",
      "mercury",
      "microchip",
      "microphone",
      "microphone-slash",
      "minus",
      "minus-circle",
      "minus-square",
      "minus-square-o",
      "mixcloud",
      "mobile",
      "mobile-phone",
      "modx",
      "money",
      "moon-o",
      "mortar-board",
      "motorcycle",
      "mouse-pointer",
      "music",
      "navicon",
      "neuter",
      "newspaper-o",
      "object-group",
      "object-ungroup",
      "odnoklassniki",
      "odnoklassniki-square",
      "opencart",
      "openid",
      "opera",
      "optin-monster",
      "outdent",
      "pagelines",
      "paint-brush",
      "paper-plane",
      "paper-plane-o",
      "paperclip",
      "paragraph",
      "paste",
      "pause",
      "pause-circle",
      "pause-circle-o",
      "paw",
      "paypal",
      "pencil",
      "pencil-square",
      "pencil-square-o",
      "percent",
      "phone",
      "phone-square",
      "photo",
      "picture-o",
      "pie-chart",
      "pied-piper",
      "pied-piper-alt",
      "pied-piper-pp",
      "pinterest",
      "pinterest-p",
      "pinterest-square",
      "plane",
      "play",
      "play-circle",
      "play-circle-o",
      "plug",
      "plus",
      "plus-circle",
      "plus-square",
      "plus-square-o",
      "podcast",
      "power-off",
      "print",
      "product-hunt",
      "puzzle-piece",
      "qq",
      "qrcode",
      "question",
      "question-circle",
      "question-circle-o",
      "quora",
      "quote-left",
      "quote-right",
      "ra",
      "random",
      "ravelry",
      "rebel",
      "recycle",
      "reddit",
      "reddit-alien",
      "reddit-square",
      "refresh",
      "registered",
      "remove",
      "renren",
      "reorder",
      "repeat",
      "reply",
      "reply-all",
      "resistance",
      "retweet",
      "rmb",
      "road",
      "rocket",
      "rotate-left",
      "rotate-right",
      "rouble",
      "rss",
      "rss-square",
      "rub",
      "ruble",
      "rupee",
      "s15",
      "safari",
      "save",
      "scissors",
      "scribd",
      "search",
      "search-minus",
      "search-plus",
      "sellsy",
      "send",
      "send-o",
      "server",
      "share",
      "share-alt",
      "share-alt-square",
      "share-square",
      "share-square-o",
      "shekel",
      "sheqel",
      "shield",
      "ship",
      "shirtsinbulk",
      "shopping-bag",
      "shopping-basket",
      "shopping-cart",
      "shower",
      "sign-in",
      "sign-language",
      "sign-out",
      "signal",
      "signing",
      "simplybuilt",
      "sitemap",
      "skyatlas",
      "skype",
      "slack",
      "sliders",
      "slideshare",
      "smile-o",
      "snapchat",
      "snapchat-ghost",
      "snapchat-square",
      "snowflake-o",
      "soccer-ball-o",
      "sort",
      "sort-alpha-asc",
      "sort-alpha-desc",
      "sort-amount-asc",
      "sort-amount-desc",
      "sort-asc",
      "sort-desc",
      "sort-down",
      "sort-numeric-asc",
      "sort-numeric-desc",
      "sort-up",
      "soundcloud",
      "space-shuttle",
      "spinner",
      "spoon",
      "spotify",
      "square",
      "square-o",
      "stack-exchange",
      "stack-overflow",
      "star",
      "star-half",
      "star-half-empty",
      "star-half-full",
      "star-half-o",
      "star-o",
      "steam",
      "steam-square",
      "step-backward",
      "step-forward",
      "stethoscope",
      "sticky-note",
      "sticky-note-o",
      "stop",
      "stop-circle",
      "stop-circle-o",
      "street-view",
      "strikethrough",
      "stumbleupon",
      "stumbleupon-circle",
      "subscript",
      "subway",
      "suitcase",
      "sun-o",
      "superpowers",
      "superscript",
      "support",
      "table",
      "tablet",
      "tachometer",
      "tag",
      "tags",
      "tasks",
      "taxi",
      "telegram",
      "television",
      "tencent-weibo",
      "terminal",
      "text-height",
      "text-width",
      "th",
      "th-large",
      "th-list",
      "themeisle",
      "thermometer",
      "thermometer-0",
      "thermometer-1",
      "thermometer-2",
      "thermometer-3",
      "thermometer-4",
      "thermometer-empty",
      "thermometer-full",
      "thermometer-half",
      "thermometer-quarter",
      "thermometer-three-quarters",
      "thumb-tack",
      "thumbs-down",
      "thumbs-o-down",
      "thumbs-o-up",
      "thumbs-up",
      "ticket",
      "times",
      "times-circle",
      "times-circle-o",
      "times-rectangle",
      "times-rectangle-o",
      "tint",
      "toggle-down",
      "toggle-left",
      "toggle-off",
      "toggle-on",
      "toggle-right",
      "toggle-up",
      "trademark",
      "train",
      "transgender",
      "transgender-alt",
      "trash",
      "trash-o",
      "tree",
      "trello",
      "tripadvisor",
      "trophy",
      "truck",
      "try",
      "tty",
      "tumblr",
      "tumblr-square",
      "turkish-lira",
      "tv",
      "twitch",
      "twitter",
      "twitter-square",
      "umbrella",
      "underline",
      "undo",
      "universal-access",
      "university",
      "unlink",
      "unlock",
      "unlock-alt",
      "unsorted",
      "upload",
      "usb",
      "usd",
      "user",
      "user-circle",
      "user-circle-o",
      "user-md",
      "user-o",
      "user-plus",
      "user-secret",
      "user-times",
      "users",
      "vcard",
      "vcard-o",
      "venus",
      "venus-double",
      "venus-mars",
      "viacoin",
      "viadeo",
      "viadeo-square",
      "video-camera",
      "vimeo",
      "vimeo-square",
      "vine",
      "vk",
      "volume-control-phone",
      "volume-down",
      "volume-off",
      "volume-up",
      "warning",
      "wechat",
      "weibo",
      "weixin",
      "whatsapp",
      "wheelchair",
      "wheelchair-alt",
      "wifi",
      "wikipedia-w",
      "window-close",
      "window-close-o",
      "window-maximize",
      "window-minimize",
      "window-restore",
      "windows",
      "won",
      "wordpress",
      "wpbeginner",
      "wpexplorer",
      "wpforms",
      "wrench",
      "xing",
      "xing-square",
      "y-combinator",
      "y-combinator-square",
      "yahoo",
      "yc",
      "yc-square",
      "yelp",
      "yen",
      "yoast",
      "youtube",
      "youtube-play",
      "youtube-square",
   ],
});


/***/ }),

/***/ 11619:
/*!*****************************************************!*\
  !*** ./js/docxtemplater-image-module.v3.0.2.min.js ***!
  \*****************************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";var DocUtils=require("docxtemplater").DocUtils;DocUtils.convertPixelsToEmus=function(pixel){return Math.round(pixel*9525)};module.exports=DocUtils},{docxtemplater:5}],2:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./docUtils");var extensionRegex=/[^.]+\.([^.]+)/;var rels={getPrefix:function getPrefix(fileType){return fileType==="docx"?"word":"ppt"},getFileTypeName:function getFileTypeName(fileType){return fileType==="docx"?"document":"presentation"},getRelsFileName:function getRelsFileName(fileName){return fileName.replace(/^.*?([a-zA-Z0-9]+)\.xml$/,"$1")+".xml.rels"},getRelsFilePath:function getRelsFilePath(fileName,fileType){var relsFileName=rels.getRelsFileName(fileName);var prefix=fileType==="pptx"?"ppt/slides":"word";return prefix+"/_rels/"+relsFileName}};module.exports=function(){function ImgManager(zip,fileName,xmlDocuments,fileType){_classCallCheck(this,ImgManager);this.fileName=fileName;this.prefix=rels.getPrefix(fileType);this.zip=zip;this.xmlDocuments=xmlDocuments;this.fileTypeName=rels.getFileTypeName(fileType);this.mediaPrefix=fileType==="pptx"?"../media":"media";var relsFilePath=rels.getRelsFilePath(fileName,fileType);this.relsDoc=xmlDocuments[relsFilePath]||this.createEmptyRelsDoc(xmlDocuments,relsFilePath)}_createClass(ImgManager,[{key:"createEmptyRelsDoc",value:function createEmptyRelsDoc(xmlDocuments,relsFileName){var mainRels=this.prefix+"/_rels/"+this.fileTypeName+".xml.rels";var doc=xmlDocuments[mainRels];if(!doc){var err=new Error("Could not copy from empty relsdoc");err.properties={mainRels:mainRels,relsFileName:relsFileName,files:Object.keys(this.zip.files)};throw err}var relsDoc=DocUtils.str2xml(DocUtils.xml2str(doc));var relationships=relsDoc.getElementsByTagName("Relationships")[0];var relationshipChilds=relationships.getElementsByTagName("Relationship");for(var i=0,l=relationshipChilds.length;i<l;i++){relationships.removeChild(relationshipChilds[i])}xmlDocuments[relsFileName]=relsDoc;return relsDoc}},{key:"loadImageRels",value:function loadImageRels(){var iterable=this.relsDoc.getElementsByTagName("Relationship");return Array.prototype.reduce.call(iterable,function(max,relationship){var id=relationship.getAttribute("Id");if(/^rId[0-9]+$/.test(id)){return Math.max(max,parseInt(id.substr(3),10))}return max},0)}},{key:"addExtensionRels",value:function addExtensionRels(contentType,extension){var contentTypeDoc=this.xmlDocuments["[Content_Types].xml"];var defaultTags=contentTypeDoc.getElementsByTagName("Default");var extensionRegistered=Array.prototype.some.call(defaultTags,function(tag){return tag.getAttribute("Extension")===extension});if(extensionRegistered){return}var types=contentTypeDoc.getElementsByTagName("Types")[0];var newTag=contentTypeDoc.createElement("Default");newTag.namespaceURI=null;newTag.setAttribute("ContentType",contentType);newTag.setAttribute("Extension",extension);types.appendChild(newTag)}},{key:"addImageRels",value:function addImageRels(imageName,imageData,i){if(i==null){i=0}var realImageName=i===0?imageName:imageName+("("+i+")");var imagePath=this.prefix+"/media/"+realImageName;if(this.zip.files[imagePath]!=null){return this.addImageRels(imageName,imageData,i+1)}var image={name:imagePath,data:imageData,options:{binary:true}};this.zip.file(image.name,image.data,image.options);var extension=realImageName.replace(extensionRegex,"$1");this.addExtensionRels("image/"+extension,extension);var relationships=this.relsDoc.getElementsByTagName("Relationships")[0];var newTag=this.relsDoc.createElement("Relationship");newTag.namespaceURI=null;var maxRid=this.loadImageRels()+1;newTag.setAttribute("Id","rId"+maxRid);newTag.setAttribute("Type","http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");newTag.setAttribute("Target",this.mediaPrefix+"/"+realImageName);relationships.appendChild(newTag);return maxRid}}]);return ImgManager}()},{"./docUtils":1}],3:[function(require,module,exports){"use strict";module.exports={getImageXml:function getImageXml(rId,size){return('<w:drawing>\n\t\t<wp:inline distT="0" distB="0" distL="0" distR="0">\n\t\t\t<wp:extent cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t<wp:effectExtent l="0" t="0" r="0" b="0"/>\n\t\t\t<wp:docPr id="2" name="Image 2" descr="image"/>\n\t\t\t<wp:cNvGraphicFramePr>\n\t\t\t\t<a:graphicFrameLocks xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" noChangeAspect="1"/>\n\t\t\t</wp:cNvGraphicFramePr>\n\t\t\t<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n\t\t\t\t<a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t<pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:cNvPr id="0" name="Picture 1" descr="image"/>\n\t\t\t\t\t\t\t<pic:cNvPicPr>\n\t\t\t\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t\t\t\t</pic:cNvPicPr>\n\t\t\t\t\t\t</pic:nvPicPr>\n\t\t\t\t\t\t<pic:blipFill>\n\t\t\t\t\t\t\t<a:blip r:embed="rId'+rId+'">\n\t\t\t\t\t\t\t\t<a:extLst>\n\t\t\t\t\t\t\t\t\t<a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n\t\t\t\t\t\t\t\t\t\t<a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n\t\t\t\t\t\t\t\t\t</a:ext>\n\t\t\t\t\t\t\t\t</a:extLst>\n\t\t\t\t\t\t\t</a:blip>\n\t\t\t\t\t\t\t<a:srcRect/>\n\t\t\t\t\t\t\t<a:stretch>\n\t\t\t\t\t\t\t\t<a:fillRect/>\n\t\t\t\t\t\t\t</a:stretch>\n\t\t\t\t\t\t</pic:blipFill>\n\t\t\t\t\t\t<pic:spPr bwMode="auto">\n\t\t\t\t\t\t\t<a:xfrm>\n\t\t\t\t\t\t\t\t<a:off x="0" y="0"/>\n\t\t\t\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t\t\t</a:xfrm>\n\t\t\t\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t\t\t\t<a:avLst/>\n\t\t\t\t\t\t\t</a:prstGeom>\n\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t<a:ln>\n\t\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t</a:ln>\n\t\t\t\t\t\t</pic:spPr>\n\t\t\t\t\t</pic:pic>\n\t\t\t\t</a:graphicData>\n\t\t\t</a:graphic>\n\t\t</wp:inline>\n\t</w:drawing>\n\t\t').replace(/\t|\n/g,"")},getImageXmlCentered:function getImageXmlCentered(rId,size){return('<w:p>\n\t\t\t<w:pPr>\n\t\t\t\t<w:jc w:val="center"/>\n\t\t\t</w:pPr>\n\t\t\t<w:r>\n\t\t\t\t<w:rPr/>\n\t\t\t\t<w:drawing>\n\t\t\t\t\t<wp:inline distT="0" distB="0" distL="0" distR="0">\n\t\t\t\t\t<wp:extent cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t<wp:docPr id="0" name="Picture" descr=""/>\n\t\t\t\t\t<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">\n\t\t\t\t\t\t<a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">\n\t\t\t\t\t\t\t<pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:cNvPr id="0" name="Picture" descr=""/>\n\t\t\t\t\t\t\t<pic:cNvPicPr>\n\t\t\t\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t\t\t\t</pic:cNvPicPr>\n\t\t\t\t\t\t\t</pic:nvPicPr>\n\t\t\t\t\t\t\t<pic:blipFill>\n\t\t\t\t\t\t\t<a:blip r:embed="rId'+rId+'"/>\n\t\t\t\t\t\t\t<a:stretch>\n\t\t\t\t\t\t\t\t<a:fillRect/>\n\t\t\t\t\t\t\t</a:stretch>\n\t\t\t\t\t\t\t</pic:blipFill>\n\t\t\t\t\t\t\t<pic:spPr bwMode="auto">\n\t\t\t\t\t\t\t<a:xfrm>\n\t\t\t\t\t\t\t\t<a:off x="0" y="0"/>\n\t\t\t\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t\t\t\t</a:xfrm>\n\t\t\t\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t\t\t\t<a:avLst/>\n\t\t\t\t\t\t\t</a:prstGeom>\n\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t<a:ln w="9525">\n\t\t\t\t\t\t\t\t<a:noFill/>\n\t\t\t\t\t\t\t\t<a:miter lim="800000"/>\n\t\t\t\t\t\t\t\t<a:headEnd/>\n\t\t\t\t\t\t\t\t<a:tailEnd/>\n\t\t\t\t\t\t\t</a:ln>\n\t\t\t\t\t\t\t</pic:spPr>\n\t\t\t\t\t\t</pic:pic>\n\t\t\t\t\t\t</a:graphicData>\n\t\t\t\t\t</a:graphic>\n\t\t\t\t\t</wp:inline>\n\t\t\t\t</w:drawing>\n\t\t\t</w:r>\n\t\t</w:p>\n\t\t').replace(/\t|\n/g,"")},getPptxImageXml:function getPptxImageXml(rId,size,offset){return('<p:pic>\n\t\t\t<p:nvPicPr>\n\t\t\t\t<p:cNvPr id="6" name="Picture 2"/>\n\t\t\t\t<p:cNvPicPr>\n\t\t\t\t\t<a:picLocks noChangeAspect="1" noChangeArrowheads="1"/>\n\t\t\t\t</p:cNvPicPr>\n\t\t\t\t<p:nvPr/>\n\t\t\t</p:nvPicPr>\n\t\t\t<p:blipFill>\n\t\t\t\t<a:blip r:embed="rId'+rId+'" cstate="print">\n\t\t\t\t\t<a:extLst>\n\t\t\t\t\t\t<a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n\t\t\t\t\t\t\t<a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n\t\t\t\t\t\t</a:ext>\n\t\t\t\t\t</a:extLst>\n\t\t\t\t</a:blip>\n\t\t\t\t<a:srcRect/>\n\t\t\t\t<a:stretch>\n\t\t\t\t\t<a:fillRect/>\n\t\t\t\t</a:stretch>\n\t\t\t</p:blipFill>\n\t\t\t<p:spPr bwMode="auto">\n\t\t\t\t<a:xfrm>\n\t\t\t\t\t<a:off x="'+offset.x+'" y="'+offset.y+'"/>\n\t\t\t\t\t<a:ext cx="'+size[0]+'" cy="'+size[1]+'"/>\n\t\t\t\t</a:xfrm>\n\t\t\t\t<a:prstGeom prst="rect">\n\t\t\t\t\t<a:avLst/>\n\t\t\t\t</a:prstGeom>\n\t\t\t\t<a:noFill/>\n\t\t\t\t<a:ln>\n\t\t\t\t\t<a:noFill/>\n\t\t\t\t</a:ln>\n\t\t\t\t<a:effectLst/>\n\t\t\t\t<a:extLst>\n\t\t\t\t\t<a:ext uri="{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}">\n\t\t\t\t\t\t<a14:hiddenFill xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main">\n\t\t\t\t\t\t\t<a:solidFill>\n\t\t\t\t\t\t\t\t<a:schemeClr val="accent1"/>\n\t\t\t\t\t\t\t</a:solidFill>\n\t\t\t\t\t\t</a14:hiddenFill>\n\t\t\t\t\t</a:ext>\n\t\t\t\t\t<a:ext uri="{91240B29-F687-4F45-9708-019B960494DF}">\n\t\t\t\t\t\t<a14:hiddenLine xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" w="9525">\n\t\t\t\t\t\t\t<a:solidFill>\n\t\t\t\t\t\t\t\t<a:schemeClr val="tx1"/>\n\t\t\t\t\t\t\t</a:solidFill>\n\t\t\t\t\t\t\t<a:miter lim="800000"/>\n\t\t\t\t\t\t\t<a:headEnd/>\n\t\t\t\t\t\t\t<a:tailEnd/>\n\t\t\t\t\t\t</a14:hiddenLine>\n\t\t\t\t\t</a:ext>\n\t\t\t\t\t<a:ext uri="{AF507438-7753-43E0-B8FC-AC1667EBCBE1}">\n\t\t\t\t\t\t<a14:hiddenEffects xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main">\n\t\t\t\t\t\t\t<a:effectLst>\n\t\t\t\t\t\t\t\t<a:outerShdw dist="35921" dir="2700000" algn="ctr" rotWithShape="0">\n\t\t\t\t\t\t\t\t\t<a:schemeClr val="bg2"/>\n\t\t\t\t\t\t\t\t</a:outerShdw>\n\t\t\t\t\t\t\t</a:effectLst>\n\t\t\t\t\t\t</a14:hiddenEffects>\n\t\t\t\t\t</a:ext>\n\t\t\t\t</a:extLst>\n\t\t\t</p:spPr>\n\t\t</p:pic>\n\t\t').replace(/\t|\n/g,"")}}},{}],4:[function(require,module,exports){"use strict";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}var memoize=require("./memoize");var DOMParser=require("xmldom").DOMParser;var XMLSerializer=require("xmldom").XMLSerializer;var Errors=require("./errors");var DocUtils={};function parser(tag){return _defineProperty({},"get",function get(scope){if(tag==="."){return scope}return scope[tag]})}DocUtils.defaults={nullGetter:function nullGetter(part){if(!part.module){return"undefined"}if(part.module==="rawxml"){return""}return""},parser:memoize(parser),fileType:"docx",delimiters:{start:"{",end:"}"}};DocUtils.mergeObjects=function(){var resObj={};var obj=void 0,keys=void 0;for(var i=0;i<arguments.length;i+=1){obj=arguments[i];keys=Object.keys(obj);for(var j=0;j<keys.length;j+=1){resObj[keys[j]]=obj[keys[j]]}}return resObj};DocUtils.xml2str=function(xmlNode){var a=new XMLSerializer;return a.serializeToString(xmlNode)};DocUtils.decodeUtf8=function(s){try{if(s===undefined){return undefined}return decodeURIComponent(escape(DocUtils.convertSpaces(s)))}catch(e){var err=new Error("End");err.properties.data=s;err.properties.explanation="Could not decode string to UTF8";throw err}};DocUtils.encodeUtf8=function(s){return unescape(encodeURIComponent(s))};DocUtils.str2xml=function(str,errorHandler){var parser=new DOMParser({errorHandler:errorHandler});return parser.parseFromString(str,"text/xml")};DocUtils.charMap={"&":"&amp;","'":"&apos;","<":"&lt;",">":"&gt;"};var regexStripRegexp=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;DocUtils.escapeRegExp=function(str){return str.replace(regexStripRegexp,"\\$&")};DocUtils.charMapRegexes=Object.keys(DocUtils.charMap).map(function(endChar){var startChar=DocUtils.charMap[endChar];return{rstart:new RegExp(DocUtils.escapeRegExp(startChar),"g"),rend:new RegExp(DocUtils.escapeRegExp(endChar),"g"),start:startChar,end:endChar}});DocUtils.wordToUtf8=function(string){var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rstart,r.end)}return string};DocUtils.utf8ToWord=function(string){if(typeof string!=="string"){string=string.toString()}var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rend,r.start)}return string};DocUtils.cloneDeep=function(obj){return JSON.parse(JSON.stringify(obj))};DocUtils.concatArrays=function(arrays){return arrays.reduce(function(result,array){Array.prototype.push.apply(result,array);return result},[])};var spaceRegexp=new RegExp(String.fromCharCode(160),"g");DocUtils.convertSpaces=function(s){return s.replace(spaceRegexp," ")};DocUtils.pregMatchAll=function(regex,content){var matchArray=[];var match=void 0;while((match=regex.exec(content))!=null){matchArray.push({array:match,offset:match.index})}return matchArray};DocUtils.sizeOfObject=function(obj){return Object.keys(obj).length};function throwXmlTagNotFound(options){var err=new Errors.XTTemplateError("No tag '"+options.element+"' was found at the "+options.position);err.properties={id:"no_xml_tag_found_at_"+options.position,explanation:"No tag '"+options.element+"' was found at the "+options.position,parsed:options.parsed,index:options.index,element:options.element};throw err}DocUtils.getRight=function(parsed,element,index){for(var i=index,l=parsed.length;i<l;i++){var part=parsed[i];if(part.value==="</"+element+">"){return i}}throwXmlTagNotFound({position:"right",element:element,parsed:parsed,index:index})};DocUtils.getLeft=function(parsed,element,index){var parts=parsed.slice(0,index);for(var i=parts.length-1;i>=0;i--){var part=parts[i];if(part.value.indexOf("<"+element)===0&&[">"," "].indexOf(part.value[element.length+1])!==-1){return i}}throwXmlTagNotFound({position:"left",element:element,parsed:parsed,index:index})};module.exports=DocUtils;DocUtils.traits=require("./traits");DocUtils.moduleWrapper=require("./module-wrapper")},{"./errors":6,"./memoize":9,"./module-wrapper":11,"./traits":20,xmldom:23}],5:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var wrapper=DocUtils.moduleWrapper;var Docxtemplater=function(){function Docxtemplater(){_classCallCheck(this,Docxtemplater);if(arguments.length>0){throw new Error("The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.")}this.compiled={};this.modules=[];this.setOptions({})}_createClass(Docxtemplater,[{key:"attachModule",value:function attachModule(module){this.modules.push(wrapper(module));return this}},{key:"setOptions",value:function setOptions(options){var _this=this;this.options=options;Object.keys(DocUtils.defaults).forEach(function(key){var defaultValue=DocUtils.defaults[key];_this[key]=_this.options[key]!=null?_this.options[key]:defaultValue});if(this.fileType==="docx"||this.fileType==="pptx"){this.fileTypeConfig=Docxtemplater.FileTypeConfig[this.fileType]}this.fileTypeConfig=this.options.fileTypeConfig||this.fileTypeConfig;this.options.xmlFileNames=[];return this}},{key:"loadZip",value:function loadZip(zip){if(zip.loadAsync){throw new Error("Docxtemplater doesn't handle JSZip version >=3, see changelog")}this.zip=zip;return this}},{key:"compileFile",value:function compileFile(fileName){var currentFile=this.createTemplateClass(fileName);currentFile.parse();this.compiled[fileName]=currentFile}},{key:"compile",value:function compile(){this.templatedFiles=this.fileTypeConfig.getTemplatedFiles(this.zip)}},{key:"render",value:function render(){var _this2=this;this.modules=this.fileTypeConfig.baseModules.map(function(moduleFunction){return moduleFunction()}).concat(this.modules);this.options=this.modules.reduce(function(options,module){return module.optionsTransformer(options,_this2)},this.options);this.xmlDocuments=this.options.xmlFileNames.reduce(function(xmlDocuments,fileName){var content=_this2.zip.files[fileName].asText();xmlDocuments[fileName]=DocUtils.str2xml(content);return xmlDocuments},{});this.modules.forEach(function(module){module.set({zip:_this2.zip,xmlDocuments:_this2.xmlDocuments,data:_this2.data})});this.compile();this.modules.forEach(function(module){module.set({compiled:_this2.compiled})});this.templatedFiles.forEach(function(fileName){if(_this2.zip.files[fileName]!=null){_this2.compileFile(fileName)}});this.mapper=this.modules.reduce(function(value,module){return module.getRenderedMap(value)},{});Object.keys(this.mapper).forEach(function(to){var mapped=_this2.mapper[to];var from=mapped.from;var currentFile=_this2.compiled[from];currentFile.setTags(mapped.data);currentFile.render();_this2.zip.file(to,currentFile.content)});Object.keys(this.xmlDocuments).forEach(function(fileName){_this2.zip.remove(fileName);var content=DocUtils.encodeUtf8(DocUtils.xml2str(_this2.xmlDocuments[fileName]));return _this2.zip.file(fileName,content,{})});return this}},{key:"setData",value:function setData(data){this.data=data;return this}},{key:"getZip",value:function getZip(){return this.zip}},{key:"createTemplateClass",value:function createTemplateClass(path){var usedData=this.zip.files[path].asText();return this.createTemplateClassFromContent(usedData,path)}},{key:"createTemplateClassFromContent",value:function createTemplateClassFromContent(content,filePath){var _this3=this;var xmltOptions={filePath:filePath};Object.keys(DocUtils.defaults).forEach(function(key){xmltOptions[key]=_this3[key]});xmltOptions.fileTypeConfig=this.fileTypeConfig;xmltOptions.modules=this.modules;return new Docxtemplater.XmlTemplater(content,xmltOptions)}},{key:"getFullText",value:function getFullText(path){return this.createTemplateClass(path||this.fileTypeConfig.textPath).getFullText()}},{key:"getTemplatedFiles",value:function getTemplatedFiles(){this.compile();return this.templatedFiles}}]);return Docxtemplater}();Docxtemplater.DocUtils=require("./doc-utils");Docxtemplater.Errors=require("./errors");Docxtemplater.XmlTemplater=require("./xml-templater");Docxtemplater.FileTypeConfig=require("./file-type-config");Docxtemplater.XmlMatcher=require("./xml-matcher");module.exports=Docxtemplater},{"./doc-utils":4,"./errors":6,"./file-type-config":7,"./xml-matcher":21,"./xml-templater":22}],6:[function(require,module,exports){"use strict";function XTError(message){this.name="GenericError";this.message=message;this.stack=new Error(message).stack}XTError.prototype=Error.prototype;function XTTemplateError(message){this.name="TemplateError";this.message=message;this.stack=new Error(message).stack}XTTemplateError.prototype=new XTError;function XTScopeParserError(message){this.name="ScopeParserError";this.message=message;this.stack=new Error(message).stack}XTScopeParserError.prototype=new XTError;function XTInternalError(message){this.name="InternalError";this.properties={explanation:"InternalError"};this.message=message;this.stack=new Error(message).stack}XTInternalError.prototype=new XTError;module.exports={XTError:XTError,XTTemplateError:XTTemplateError,XTInternalError:XTInternalError,XTScopeParserError:XTScopeParserError}},{}],7:[function(require,module,exports){"use strict";var loopModule=require("./modules/loop");var spacePreserveModule=require("./modules/space-preserve");var rawXmlModule=require("./modules/rawxml");var expandPairTrait=require("./modules/expand-pair-trait");var render=require("./modules/render");var PptXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["ppt/presentation.xml"])},textPath:"ppt/slides/slide1.xml",tagsXmlTextArray:["a:t","m:t"],tagsXmlLexedArray:["p:sp","a:tc","a:tr","a:table","a:p","a:r"],tagRawXml:"p:sp",tagTextXml:"a:t",baseModules:[render,expandPairTrait,rawXmlModule,loopModule]};var DocXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/word\/(header|footer)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["word/document.xml"])},textPath:"word/document.xml",tagsXmlTextArray:["w:t","m:t"],tagsXmlLexedArray:["w:tc","w:tr","w:table","w:p","w:r"],tagRawXml:"w:p",tagTextXml:"w:t",baseModules:[render,spacePreserveModule,expandPairTrait,rawXmlModule,loopModule]};module.exports={docx:DocXFileTypeConfig,pptx:PptXFileTypeConfig}},{"./modules/expand-pair-trait":12,"./modules/loop":13,"./modules/rawxml":14,"./modules/render":15,"./modules/space-preserve":16}],8:[function(require,module,exports){"use strict";var Errors=require("./errors");var DocUtils=require("./doc-utils");function inRange(range,match){return range[0]<=match.offset&&match.offset<range[1]}function updateInTextTag(part,inTextTag){if(part.type==="tag"&&part.position==="start"&&part.text){if(inTextTag){throw new Error("Malformed xml : Already in text tag")}return true}if(part.type==="tag"&&part.position==="end"&&part.text){if(!inTextTag){throw new Error("Malformed xml : Already not in text tag")}return false}return inTextTag}function offsetSort(a,b){return a.offset-b.offset}function getTag(tag){var start=1;if(tag[1]==="/"){start=2}var index=tag.indexOf(" ");var end=index===-1?tag.length-1:index;return{tag:tag.slice(start,end),position:start===1?"start":"end"}}function tagMatcher(content,textMatchArray,othersMatchArray){var cursor=0;var contentLength=content.length;var allMatches=DocUtils.concatArrays([textMatchArray.map(function(tag){return{tag:tag,text:true}}),othersMatchArray.map(function(tag){return{tag:tag,text:false}})]).reduce(function(allMatches,t){allMatches[t.tag]=t.text;return allMatches},{});var totalMatches=[];while(cursor<contentLength){cursor=content.indexOf("<",cursor);if(cursor===-1){break}var offset=cursor;cursor=content.indexOf(">",cursor);var tagText=content.slice(offset,cursor+1);var _getTag=getTag(tagText),tag=_getTag.tag,position=_getTag.position;var text=allMatches[tag];if(text==null){continue}totalMatches.push({type:"tag",position:position,text:text,offset:offset,value:tagText})}return totalMatches}function throwUnopenedTagException(options){var err=new Errors.XTTemplateError("Unopened tag");err.properties={xtag:options.xtag.split(" ")[0],id:"unopened_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function throwUnclosedTagException(options){var err=new Errors.XTTemplateError("Unclosed tag");err.properties={xtag:options.xtag.split(" ")[0].substr(1),id:"unclosed_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function assertDelimiterOrdered(delimiterMatches,fullText){var inDelimiter=false;var lastDelimiterMatch={offset:0};var xtag=void 0;delimiterMatches.forEach(function(delimiterMatch){xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(delimiterMatch.position==="start"&&inDelimiter||delimiterMatch.position==="end"&&!inDelimiter){if(delimiterMatch.position==="start"){throwUnclosedTagException({xtag:xtag})}else{throwUnopenedTagException({xtag:xtag})}}inDelimiter=!inDelimiter;lastDelimiterMatch=delimiterMatch});var delimiterMatch={offset:fullText.length};xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(inDelimiter){throwUnclosedTagException({xtag:xtag})}}function getAllIndexes(arr,val,position){var indexes=[];var offset=-1;do{offset=arr.indexOf(val,offset+1);if(offset!==-1){indexes.push({offset:offset,position:position})}}while(offset!==-1);return indexes}function Reader(innerContentParts){var _this=this;this.innerContentParts=innerContentParts;this.full="";this.parseDelimiters=function(delimiters){_this.full=_this.innerContentParts.join("");var offset=0;_this.ranges=_this.innerContentParts.map(function(part){offset+=part.length;return offset-part.length});var delimiterMatches=DocUtils.concatArrays([getAllIndexes(_this.full,delimiters.start,"start"),getAllIndexes(_this.full,delimiters.end,"end")]).sort(offsetSort);assertDelimiterOrdered(delimiterMatches,_this.full);var delimiterLength={start:delimiters.start.length,end:delimiters.end.length};var cutNext=0;var delimiterIndex=0;_this.parsed=_this.ranges.map(function(offset,i){var range=[offset,offset+this.innerContentParts[i].length];var partContent=this.innerContentParts[i];var delimitersInOffset=[];while(delimiterIndex<delimiterMatches.length&&inRange(range,delimiterMatches[delimiterIndex])){delimitersInOffset.push(delimiterMatches[delimiterIndex]);delimiterIndex++}var parts=[];var cursor=0;if(cutNext>0){cursor=cutNext;cutNext=0}delimitersInOffset.forEach(function(delimiterInOffset){var value=partContent.substr(cursor,delimiterInOffset.offset-offset-cursor);if(value.length>0){parts.push({type:"content",value:value})}parts.push({type:"delimiter",position:delimiterInOffset.position});cursor=delimiterInOffset.offset-offset+delimiterLength[delimiterInOffset.position]});cutNext=cursor-partContent.length;var value=partContent.substr(cursor);if(value.length>0){parts.push({type:"content",value:value})}return parts},_this)}}module.exports={parse:function parse(xmlparsed,delimiters){var inTextTag=false;var innerContentParts=[];xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(inTextTag&&part.type==="content"){innerContentParts.push(part.value)}});var reader=new Reader(innerContentParts);reader.parseDelimiters(delimiters);var newArray=[];var index=0;xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(part.type==="content"){part.position=inTextTag?"insidetag":"outsidetag"}if(inTextTag&&part.type==="content"){Array.prototype.push.apply(newArray,reader.parsed[index].map(function(p){if(p.type==="content"){p.position="insidetag"}return p}));index++}else{newArray.push(part)}});return newArray},xmlparse:function xmlparse(content,xmltags){var matches=tagMatcher(content,xmltags.text,xmltags.other);var cursor=0;var parsed=matches.reduce(function(parsed,match){var value=content.substr(cursor,match.offset-cursor);if(value.length>0){parsed.push({type:"content",value:value})}cursor=match.offset+match.value.length;delete match.offset;if(match.value.length>0){parsed.push(match)}return parsed},[]);var value=content.substr(cursor);if(value.length>0){parsed.push({type:"content",value:value})}return parsed}}},{"./doc-utils":4,"./errors":6}],9:[function(require,module,exports){"use strict";function memoize(func){var stringifyJson=JSON.stringify,cache={};function cachedfun(){var hash=stringifyJson(arguments);return hash in cache?cache[hash]:cache[hash]=func.apply(this,arguments)}return cachedfun}module.exports=memoize},{}],10:[function(require,module,exports){"use strict";function getMinFromArrays(arrays,state){var minIndex=-1;for(var i=0,l=arrays.length;i<l;i++){if(state[i]>=arrays[i].length){continue}if(minIndex===-1||arrays[i][state[i]].offset<arrays[minIndex][state[minIndex]].offset){minIndex=i}}if(minIndex===-1){throw new Error("minIndex negative")}return minIndex}module.exports=function(arrays){var totalLength=arrays.reduce(function(sum,array){return sum+array.length},0);arrays=arrays.filter(function(array){return array.length>0});var resultArray=new Array(totalLength);var state=arrays.map(function(){return 0});var i=0;while(i<=totalLength-1){var arrayIndex=getMinFromArrays(arrays,state);resultArray[i]=arrays[arrayIndex][state[arrayIndex]];state[arrayIndex]++;i++}return resultArray}},{}],11:[function(require,module,exports){"use strict";function emptyFun(){}function identity(i){return i}module.exports=function(module){var defaults={set:emptyFun,parse:emptyFun,render:emptyFun,getTraits:emptyFun,optionsTransformer:identity,getRenderedMap:identity,postparse:identity};if(Object.keys(defaults).every(function(key){return!module[key]})){throw new Error("This module cannot be wrapped, because it doesn't define any of the necessary functions")}Object.keys(defaults).forEach(function(key){module[key]=module[key]||defaults[key]});return module}},{}],12:[function(require,module,exports){"use strict";var traitName="expandPair";var mergeSort=require("../mergesort");var DocUtils=require("../doc-utils");var wrapper=require("../module-wrapper");var _require=require("../traits"),getExpandToDefault=_require.getExpandToDefault;var Errors=require("../errors");function throwUnmatchedLoopException(options){var location=options.location;var t=location==="start"?"unclosed":"unopened";var T=location==="start"?"Unclosed":"Unopened";var err=new Errors.XTTemplateError(T+" loop");var tag=options.part.value;err.properties={id:t+"_loop",explanation:"The loop with tag "+tag+" is "+t,xtag:tag};throw err}function throwClosingTagNotMatchOpeningTag(options){var tags=options.tags;var err=new Errors.XTTemplateError("Closing tag does not match opening tag");err.properties={id:"closing_tag_does_not_match_opening_tag",explanation:'The tag "'+tags[0].value+'" is closed by the tag "'+tags[1].value+'"',openingtag:tags[0].value,closingtag:tags[1].value};throw err}function getOpenCountChange(part){switch(part.location){case"start":return 1;case"end":return-1;default:throw new Error("Location should be one of 'start' or 'end' (given : "+part.location+")")}}function getPairs(traits){if(traits.length===0){return[]}var countOpen=1;var firstTrait=traits[0];for(var i=1;i<traits.length;i++){var currentTrait=traits[i];countOpen+=getOpenCountChange(currentTrait.part);if(countOpen===0){if(currentTrait.part.value!==firstTrait.part.value&&currentTrait.part.value!==""){throwClosingTagNotMatchOpeningTag({tags:[firstTrait.part,currentTrait.part]})}var outer=getPairs(traits.slice(i+1));
return[[firstTrait,currentTrait]].concat(outer)}}var part=firstTrait.part;throwUnmatchedLoopException({part:part,location:part.location})}var expandPairTrait={name:"ExpandPairTrait",postparse:function postparse(parsed,_ref){var getTraits=_ref.getTraits,_postparse=_ref.postparse;var traits=getTraits(traitName,parsed);traits=traits.map(function(trait){return trait||[]});traits=mergeSort(traits);var pairs=getPairs(traits);var expandedPairs=pairs.map(function(pair){var expandTo=pair[0].part.expandTo;if(expandTo==="auto"){expandTo=getExpandToDefault(parsed.slice(pair[0].offset,pair[1].offset))}if(!expandTo){return[pair[0].offset,pair[1].offset]}var left=DocUtils.getLeft(parsed,expandTo,pair[0].offset);var right=DocUtils.getRight(parsed,expandTo,pair[1].offset);return[left,right]});var currentPairIndex=0;var innerParts=void 0;return parsed.reduce(function(newParsed,part,i){var inPair=currentPairIndex<pairs.length&&expandedPairs[currentPairIndex][0]<=i;var pair=pairs[currentPairIndex];var expandedPair=expandedPairs[currentPairIndex];if(!inPair){newParsed.push(part);return newParsed}if(expandedPair[0]===i){innerParts=[]}if(pair[0].offset!==i&&pair[1].offset!==i){innerParts.push(part)}if(expandedPair[1]===i){var basePart=parsed[pair[0].offset];delete basePart.location;delete basePart.expandTo;basePart.subparsed=_postparse(innerParts);newParsed.push(basePart);currentPairIndex++}return newParsed},[])}};module.exports=function(){return wrapper(expandPairTrait)}},{"../doc-utils":4,"../errors":6,"../mergesort":10,"../module-wrapper":11,"../traits":20}],13:[function(require,module,exports){"use strict";var DocUtils=require("../doc-utils");var dashInnerRegex=/^-([^\s]+)\s(.+)$/;var wrapper=require("../module-wrapper");var moduleName="loop";var loopModule={name:"LoopModule",parse:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent[0]==="#"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:false}}if(placeHolderContent[0]==="^"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:true}}if(placeHolderContent[0]==="/"){return{type:type,value:placeHolderContent.substr(1),module:module,location:"end"}}if(placeHolderContent[0]==="-"){var value=placeHolderContent.replace(dashInnerRegex,"$2");var expandTo=placeHolderContent.replace(dashInnerRegex,"$1");return{type:type,value:value,expandTo:expandTo,module:module,location:"start",inverted:false}}return null},getTraits:function getTraits(traitName,parsed){if(traitName!=="expandPair"){return}return parsed.reduce(function(tags,part,offset){if(part.type==="placeholder"&&part.module===moduleName){tags.push({part:part,offset:offset})}return tags},[])},render:function render(part,options){if(!part.type==="placeholder"||part.module!==moduleName){return null}var totalValue=[];function loopOver(scope){var scopeManager=options.scopeManager.createSubScopeManager(scope,part.value);totalValue.push(options.render(DocUtils.mergeObjects({},options,{compiled:part.subparsed,tags:{},scopeManager:scopeManager})))}options.scopeManager.loopOver(part.value,loopOver,part.inverted);return{value:totalValue.join("")}}};module.exports=function(){return wrapper(loopModule)}},{"../doc-utils":4,"../module-wrapper":11}],14:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("../doc-utils");var Errors=require("../errors");var moduleName="rawxml";var wrapper=require("../module-wrapper");function throwRawTagShouldBeOnlyTextInParagraph(options){var err=new Errors.XTTemplateError("Raw tag should be the only text in paragraph");var tag=options.part.value;err.properties={id:"raw_xml_tag_should_be_only_text_in_paragraph",explanation:"The tag "+tag,xtag:options.part.value,paragraphParts:options.paragraphParts};throw err}function getInner(_ref){var part=_ref.part,left=_ref.left,right=_ref.right,postparsed=_ref.postparsed,index=_ref.index;var paragraphParts=postparsed.slice(left+1,right);paragraphParts.forEach(function(p,i){if(i===index-left-1){return}if(p.type==="placeholder"||p.type==="content"&&p.position==="insidetag"){throwRawTagShouldBeOnlyTextInParagraph({paragraphParts:paragraphParts,part:part})}});return part}var RawXmlModule=function(){function RawXmlModule(){_classCallCheck(this,RawXmlModule);this.name="RawXmlModule"}_createClass(RawXmlModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){this.fileTypeConfig=docxtemplater.fileTypeConfig;return options}},{key:"parse",value:function parse(placeHolderContent){var type="placeholder";if(placeHolderContent[0]!=="@"){return null}return{type:type,value:placeHolderContent.substr(1),module:moduleName}}},{key:"postparse",value:function postparse(parsed){return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:this.fileTypeConfig.tagRawXml})}},{key:"render",value:function render(part,options){if(part.module!==moduleName){return null}var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return{value:value}}}]);return RawXmlModule}();module.exports=function(){return wrapper(new RawXmlModule)}},{"../doc-utils":4,"../errors":6,"../module-wrapper":11}],15:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var wrapper=require("../module-wrapper");var Render=function(){function Render(){_classCallCheck(this,Render);this.name="Render"}_createClass(Render,[{key:"set",value:function set(obj){if(obj.compiled){this.compiled=obj.compiled}if(obj.data!=null){this.data=obj.data}}},{key:"getRenderedMap",value:function getRenderedMap(mapper){var _this=this;return Object.keys(this.compiled).reduce(function(mapper,from){mapper[from]={from:from,data:_this.data};return mapper},mapper)}}]);return Render}();module.exports=function(){return wrapper(new Render)}},{"../module-wrapper":11}],16:[function(require,module,exports){"use strict";var wrapper=require("../module-wrapper");var spacePreserve={name:"SpacePreserveModule",postparse:function postparse(parsed){var chunk=[];var inChunk=false;var result=parsed.reduce(function(parsed,part){if(part.type==="tag"&&part.position==="start"&&part.text&&part.value==="<w:t>"){inChunk=true}if(inChunk){if(part.type==="placeholder"&&!part.module){chunk[0].value='<w:t xml:space="preserve">'}chunk.push(part)}else{parsed.push(part)}if(part.type==="tag"&&part.position==="end"&&part.text&&part.value==="</w:t>"){Array.prototype.push.apply(parsed,chunk);inChunk=false;chunk=[]}return parsed},[]);Array.prototype.push.apply(result,chunk);return result}};module.exports=function(){return wrapper(spacePreserve)}},{"../module-wrapper":11}],17:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var parser={postparse:function postparse(parsed,modules){function getTraits(traitName,parsed){return modules.map(function(module){return module.getTraits(traitName,parsed)})}function postparse(parsed){return modules.reduce(function(parsed,module){return module.postparse(parsed,{postparse:postparse,getTraits:getTraits})},parsed)}return postparse(parsed)},parse:function parse(lexed,modules){function moduleParse(placeHolderContent,parsed){var moduleParsed=void 0;for(var i=0,l=modules.length;i<l;i++){var _module=modules[i];moduleParsed=_module.parse(placeHolderContent);if(moduleParsed){parsed.push(moduleParsed);return moduleParsed}}return null}var inPlaceHolder=false;var placeHolderContent=void 0;var tailParts=[];return lexed.reduce(function(parsed,token){if(token.type==="delimiter"){inPlaceHolder=token.position==="start";if(token.position==="end"){placeHolderContent=DocUtils.wordToUtf8(placeHolderContent);if(!moduleParse(placeHolderContent,parsed)){parsed.push({type:"placeholder",value:placeHolderContent})}Array.prototype.push.apply(parsed,tailParts);tailParts=[];return parsed}placeHolderContent="";return parsed}if(inPlaceHolder){if(token.type==="content"&&token.position==="insidetag"){placeHolderContent+=token.value}else{tailParts.push(token)}return parsed}parsed.push(token);return parsed},[])}};module.exports=parser},{"./doc-utils":4}],18:[function(require,module,exports){"use strict";var ScopeManager=require("./scope-manager");var DocUtils=require("./doc-utils");function moduleRender(part,options){var moduleRendered=void 0;for(var i=0,l=options.modules.length;i<l;i++){var _module=options.modules[i];moduleRendered=_module.render(part,options);if(moduleRendered){return moduleRendered}}return false}function render(options){options.render=render;options.modules=options.modules;if(!options.scopeManager){options.scopeManager=ScopeManager.createBaseScopeManager(options)}return options.compiled.map(function(part){var moduleRendered=moduleRender(part,options);if(moduleRendered){return moduleRendered.value}if(part.type==="placeholder"){var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return DocUtils.utf8ToWord(value)}if(part.type==="content"||part.type==="tag"){return part.value}throw new Error('Unimplemented tag type "'+part.type+'"')}).join("")}module.exports=render},{"./doc-utils":4,"./scope-manager":19}],19:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var Errors=require("./errors");var ScopeManager=function(){function ScopeManager(options){_classCallCheck(this,ScopeManager);this.scopePath=options.scopePath;this.scopeList=options.scopeList;this.parser=options.parser}_createClass(ScopeManager,[{key:"loopOver",value:function loopOver(tag,callback,inverted){inverted=inverted||false;return this.loopOverValue(this.getValue(tag),callback,inverted)}},{key:"functorIfInverted",value:function functorIfInverted(inverted,functor,value){if(inverted){functor(value)}}},{key:"isValueFalsy",value:function isValueFalsy(value,type){return value==null||!value||type==="[object Array]"&&value.length===0}},{key:"loopOverValue",value:function loopOverValue(value,functor,inverted){var type=Object.prototype.toString.call(value);var currentValue=this.scopeList[this.num];if(this.isValueFalsy(value,type)){return this.functorIfInverted(inverted,functor,currentValue)}if(type==="[object Array]"){for(var i=0,scope;i<value.length;i++){scope=value[i];this.functorIfInverted(!inverted,functor,scope)}return}if(type==="[object Object]"){return this.functorIfInverted(!inverted,functor,value)}if(value===true){return this.functorIfInverted(!inverted,functor,currentValue)}}},{key:"getValue",value:function getValue(tag,num){this.num=num==null?this.scopeList.length-1:num;var err=void 0;var parser=void 0;var result=void 0;var scope=this.scopeList[this.num];try{parser=this.parser(tag)}catch(error){err=new Errors.XTScopeParserError("Scope parser compilation failed");err.properties={id:"scopeparser_compilation_failed",tag:tag,explanation:"The scope parser for the tag "+tag+" failed to compile",rootError:error};throw err}try{result=parser.get(scope,{num:this.num,scopeList:this.scopeList})}catch(error){err=new Errors.XTScopeParserError("Scope parser execution failed");err.properties={id:"scopeparser_execution_failed",explanation:"The scope parser for the tag "+tag+" failed to execute",scope:scope,tag:tag,rootError:error};throw err}if(result==null&&this.num>0){return this.getValue(tag,this.num-1)}return result}},{key:"createSubScopeManager",value:function createSubScopeManager(scope,tag){var options={scopePath:this.scopePath.slice(0),scopeList:this.scopeList.slice(0)};options.parser=this.parser;options.scopeList=this.scopeList.concat(scope);options.scopePath=this.scopePath.concat(tag);return new ScopeManager(options)}}]);return ScopeManager}();ScopeManager.createBaseScopeManager=function(_ref){var parser=_ref.parser,tags=_ref.tags;var options={parser:parser,tags:tags};options.scopePath=[];options.scopeList=[tags];return new ScopeManager(options)};module.exports=ScopeManager},{"./errors":6}],20:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var Errors=require("./errors");function throwRawTagNotInParagraph(options){var err=new Errors.XTTemplateError("Raw tag not in paragraph");var tag=options.part.value;err.properties={id:"raw_tag_outerxml_invalid",explanation:'The tag "'+tag+'"',rootError:options.rootError,xtag:tag};throw err}function lastTagIsOpenTag(array,tag){if(array.length===0){return false}var lastTag=array[array.length-1];var innerLastTag=lastTag.tag.substr(1);var innerCurrentTag=tag.substr(2,tag.length-3);return innerLastTag.indexOf(innerCurrentTag)===0}function addTag(array,tag){array.push({tag:tag});return array}function getListXmlElements(parts){var tags=parts.filter(function(part){return part.type==="tag"}).map(function(part){return part.value});var result=[];for(var i=0,tag;i<tags.length;i++){tag=tags[i];if(tag[1]==="/"){if(lastTagIsOpenTag(result,tag)){result.pop()}else{result=addTag(result,tag)}}else if(tag[tag.length-1]!=="/"){result=addTag(result,tag)}}return result}function getExpandToDefault(parts){var xmlElements=getListXmlElements(parts);for(var i=0;i<xmlElements.length;i++){var xmlElement=xmlElements[i];if(xmlElement.tag.indexOf("<w:tc")===0){return"w:tr"}}return false}function expandOne(part,postparsed,options){var expandTo=part.expandTo||options.expandTo;var index=postparsed.indexOf(part);if(!expandTo){return postparsed}var right=void 0,left=void 0;try{right=DocUtils.getRight(postparsed,expandTo,index);left=DocUtils.getLeft(postparsed,expandTo,index)}catch(rootError){throwRawTagNotInParagraph({part:part,rootError:rootError})}var leftParts=postparsed.slice(left,index);var rightParts=postparsed.slice(index+1,right+1);var inner=options.getInner({index:index,part:part,leftParts:leftParts,rightParts:rightParts,left:left,right:right,postparsed:postparsed});var type=Object.prototype.toString.call(inner);if(type==="[object Array]"){inner=DocUtils.concatArrays(inner)}return DocUtils.concatArrays([postparsed.slice(0,left),[inner],postparsed.slice(right+1)])}function expandToOne(postparsed,options){var expandToElements=postparsed.reduce(function(elements,part){if(part.type==="placeholder"&&part.module===options.moduleName){elements.push(part)}return elements},[]);expandToElements.forEach(function(part){postparsed=expandOne(part,postparsed,options)});return postparsed}module.exports={expandToOne:expandToOne,getExpandToDefault:getExpandToDefault}},{"./doc-utils":4,"./errors":6}],21:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var memoize=require("./memoize");function handleRecursiveCase(res){function replacerUnshift(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.shift();var match=pn.array[0]+pn.array[1];pn.array.unshift(match);pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.first=true;res.matches.unshift(pn);res.charactersAdded.unshift(0);return res.charactersAddedCumulative.unshift(0)}if(res.content.indexOf("<")===-1&&res.content.indexOf(">")===-1){res.content.replace(/^()([^<>]*)$/,replacerUnshift)}var r=new RegExp("^()([^<]+)</(?:"+res.tagsXmlArrayJoined+")>");res.content.replace(r,replacerUnshift);function replacerPush(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.last=true;res.matches.push(pn);res.charactersAdded.push(0);return res.charactersAddedCumulative.push(0)}r=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^>]+)$");res.content.replace(r,replacerPush);return res}function xmlMatcher(content,tagsXmlArray){var res={};res.content=content;res.tagsXmlArray=tagsXmlArray;res.tagsXmlArrayJoined=res.tagsXmlArray.join("|");var regexp=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^<>]*)</(?:"+res.tagsXmlArrayJoined+")>","g");res.matches=DocUtils.pregMatchAll(regexp,res.content);res.charactersAddedCumulative=res.matches.map(function(){return 0});res.charactersAdded=res.matches.map(function(){return 0});return handleRecursiveCase(res)}var memoized=memoize(xmlMatcher);module.exports=function(content,tagsXmlArray){return DocUtils.cloneDeep(memoized(content,tagsXmlArray))}},{"./doc-utils":4,"./memoize":9}],22:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var ScopeManager=require("./scope-manager");var xmlMatcher=require("./xml-matcher");var Errors=require("./errors");var Lexer=require("./lexer");var Parser=require("./parser.js");var _render=require("./render.js");function _getFullText(content,tagsXmlArray){var matcher=xmlMatcher(content,tagsXmlArray);var result=matcher.matches.map(function(match){return match.array[2]});return DocUtils.wordToUtf8(DocUtils.convertSpaces(result.join("")))}module.exports=function(){function XmlTemplater(content,options){_classCallCheck(this,XmlTemplater);this.fromJson(options);this.setModules({inspect:{filePath:this.filePath}});this.load(content)}_createClass(XmlTemplater,[{key:"load",value:function load(content){if(typeof content!=="string"){var err=new Errors.XTInternalError("Content must be a string");err.properties.id="xmltemplater_content_must_be_string";throw err}this.content=content}},{key:"setTags",value:function setTags(tags){this.tags=tags!=null?tags:{};this.scopeManager=ScopeManager.createBaseScopeManager({tags:this.tags,parser:this.parser});return this}},{key:"fromJson",value:function fromJson(options){this.filePath=options.filePath;this.modules=options.modules;this.fileTypeConfig=options.fileTypeConfig;Object.keys(DocUtils.defaults).map(function(key){this[key]=options[key]!=null?options[key]:DocUtils.defaults[key]},this)}},{key:"getFullText",value:function getFullText(){return _getFullText(this.content,this.fileTypeConfig.tagsXmlTextArray)}},{key:"setModules",value:function setModules(obj){this.modules.forEach(function(module){module.set(obj)})}},{key:"parse",value:function parse(){this.xmllexed=Lexer.xmlparse(this.content,{text:this.fileTypeConfig.tagsXmlTextArray,other:this.fileTypeConfig.tagsXmlLexedArray});this.setModules({inspect:{xmllexed:this.xmllexed}});this.lexed=Lexer.parse(this.xmllexed,this.delimiters);this.setModules({inspect:{lexed:this.lexed}});this.parsed=Parser.parse(this.lexed,this.modules);this.setModules({inspect:{parsed:this.parsed}});this.postparsed=Parser.postparse(this.parsed,this.modules);return this}},{key:"render",value:function render(){this.setModules({inspect:{postparsed:this.postparsed}});this.content=_render({compiled:this.postparsed,tags:this.tags,modules:this.modules,parser:this.parser,nullGetter:this.nullGetter,filePath:this.filePath});this.setModules({inspect:{content:this.content}});return this}}]);return XmlTemplater}()},{"./doc-utils":4,"./errors":6,"./lexer":8,"./parser.js":17,"./render.js":18,"./scope-manager":19,"./xml-matcher":21}],23:[function(require,module,exports){function DOMParser(options){this.options=options||{locator:{}}}DOMParser.prototype.parseFromString=function(source,mimeType){var options=this.options;var sax=new XMLReader;var domBuilder=options.domBuilder||new DOMHandler;var errorHandler=options.errorHandler;var locator=options.locator;var defaultNSMap=options.xmlns||{};var entityMap={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"};if(locator){domBuilder.setDocumentLocator(locator)}sax.errorHandler=buildErrorHandler(errorHandler,domBuilder,locator);sax.domBuilder=options.domBuilder||domBuilder;if(/\/x?html?$/.test(mimeType)){entityMap.nbsp=" ";entityMap.copy="©";defaultNSMap[""]="http://www.w3.org/1999/xhtml"}defaultNSMap.xml=defaultNSMap.xml||"http://www.w3.org/XML/1998/namespace";if(source){sax.parse(source,defaultNSMap,entityMap)}else{sax.errorHandler.error("invalid doc source")}return domBuilder.doc};function buildErrorHandler(errorImpl,domBuilder,locator){if(!errorImpl){if(domBuilder instanceof DOMHandler){return domBuilder}errorImpl=domBuilder}var errorHandler={};var isCallback=errorImpl instanceof Function;locator=locator||{};function build(key){var fn=errorImpl[key];if(!fn&&isCallback){fn=errorImpl.length==2?function(msg){errorImpl(key,msg)}:errorImpl}errorHandler[key]=fn&&function(msg){fn("[xmldom "+key+"]\t"+msg+_locator(locator))}||function(){}}build("warning");build("error");build("fatalError");return errorHandler}function DOMHandler(){this.cdata=false}function position(locator,node){node.lineNumber=locator.lineNumber;node.columnNumber=locator.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=(new DOMImplementation).createDocument(null,null,null);if(this.locator){this.doc.documentURI=this.locator.systemId}},startElement:function(namespaceURI,localName,qName,attrs){var doc=this.doc;var el=doc.createElementNS(namespaceURI,qName||localName);var len=attrs.length;appendElement(this,el);this.currentElement=el;this.locator&&position(this.locator,el);for(var i=0;i<len;i++){var namespaceURI=attrs.getURI(i);var value=attrs.getValue(i);var qName=attrs.getQName(i);var attr=doc.createAttributeNS(namespaceURI,qName);this.locator&&position(attrs.getLocator(i),attr);attr.value=attr.nodeValue=value;el.setAttributeNode(attr)}},endElement:function(namespaceURI,localName,qName){var current=this.currentElement;var tagName=current.tagName;this.currentElement=current.parentNode},startPrefixMapping:function(prefix,uri){},endPrefixMapping:function(prefix){},processingInstruction:function(target,data){var ins=this.doc.createProcessingInstruction(target,data);this.locator&&position(this.locator,ins);appendElement(this,ins)},ignorableWhitespace:function(ch,start,length){},characters:function(chars,start,length){chars=_toString.apply(this,arguments);if(chars){if(this.cdata){var charNode=this.doc.createCDATASection(chars)}else{var charNode=this.doc.createTextNode(chars)}if(this.currentElement){this.currentElement.appendChild(charNode)}else if(/^\s*$/.test(chars)){this.doc.appendChild(charNode)}this.locator&&position(this.locator,charNode)}},skippedEntity:function(name){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(locator){if(this.locator=locator){locator.lineNumber=0}},comment:function(chars,start,length){chars=_toString.apply(this,arguments);var comm=this.doc.createComment(chars);this.locator&&position(this.locator,comm);appendElement(this,comm)},startCDATA:function(){this.cdata=true},endCDATA:function(){this.cdata=false},startDTD:function(name,publicId,systemId){var impl=this.doc.implementation;if(impl&&impl.createDocumentType){var dt=impl.createDocumentType(name,publicId,systemId);this.locator&&position(this.locator,dt);appendElement(this,dt)}},warning:function(error){console.warn("[xmldom warning]\t"+error,_locator(this.locator))},error:function(error){console.error("[xmldom error]\t"+error,_locator(this.locator))},fatalError:function(error){console.error("[xmldom fatalError]\t"+error,_locator(this.locator));throw error}};function _locator(l){if(l){return"\n@"+(l.systemId||"")+"#[line:"+l.lineNumber+",col:"+l.columnNumber+"]"}}function _toString(chars,start,length){if(typeof chars=="string"){return chars.substr(start,length)}else{if(chars.length>=start+length||start){return new java.lang.String(chars,start,length)+""}return chars}}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){DOMHandler.prototype[key]=function(){return null}});function appendElement(hander,node){if(!hander.currentElement){hander.doc.appendChild(node)}else{hander.currentElement.appendChild(node)}}var XMLReader=require("./sax").XMLReader;var DOMImplementation=exports.DOMImplementation=require("./dom").DOMImplementation;exports.XMLSerializer=require("./dom").XMLSerializer;exports.DOMParser=DOMParser},{"./dom":24,"./sax":25}],24:[function(require,module,exports){function copy(src,dest){for(var p in src){dest[p]=src[p]}}function _extends(Class,Super){var pt=Class.prototype;if(Object.create){var ppt=Object.create(Super.prototype);pt.__proto__=ppt}if(!(pt instanceof Super)){function t(){}t.prototype=Super.prototype;t=new t;copy(pt,t);Class.prototype=pt=t}if(pt.constructor!=Class){if(typeof Class!="function"){console.error("unknow Class:"+Class)}pt.constructor=Class}}var htmlns="http://www.w3.org/1999/xhtml";var NodeType={};var ELEMENT_NODE=NodeType.ELEMENT_NODE=1;var ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2;var TEXT_NODE=NodeType.TEXT_NODE=3;var CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4;var ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5;var ENTITY_NODE=NodeType.ENTITY_NODE=6;var PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7;var COMMENT_NODE=NodeType.COMMENT_NODE=8;var DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9;var DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10;var DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11;var NOTATION_NODE=NodeType.NOTATION_NODE=12;var ExceptionCode={};var ExceptionMessage={};var INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1);var DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2);var HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3);var WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4);var INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5);var NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6);var NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7);var NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8);var NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9);var INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10);var INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11);var SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12);var INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13);var NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14);var INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(code,message){if(message instanceof Error){var error=message}else{error=this;Error.call(this,ExceptionMessage[code]);this.message=ExceptionMessage[code];if(Error.captureStackTrace)Error.captureStackTrace(this,DOMException)}error.code=code;if(message)this.message=this.message+": "+message;return error}DOMException.prototype=Error.prototype;copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(index){return this[index]||null},toString:function(isHTML,nodeFilter){for(var buf=[],i=0;i<this.length;i++){serializeToString(this[i],buf,isHTML,nodeFilter)}return buf.join("")}};function LiveNodeList(node,refresh){this._node=node;this._refresh=refresh;_updateLiveList(this)}function _updateLiveList(list){var inc=list._node._inc||list._node.ownerDocument._inc;if(list._inc!=inc){var ls=list._refresh(list._node);__set__(list,"length",ls.length);copy(ls,list);list._inc=inc}}LiveNodeList.prototype.item=function(i){_updateLiveList(this);return this[i]};_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(list,node){var i=list.length;while(i--){if(list[i]===node){return i}}}function _addNamedNode(el,list,newAttr,oldAttr){if(oldAttr){list[_findNodeIndex(list,oldAttr)]=newAttr}else{list[list.length++]=newAttr}if(el){newAttr.ownerElement=el;var doc=el.ownerDocument;if(doc){oldAttr&&_onRemoveAttribute(doc,el,oldAttr);_onAddAttribute(doc,el,newAttr)}}}function _removeNamedNode(el,list,attr){var i=_findNodeIndex(list,attr);if(i>=0){var lastIndex=list.length-1;while(i<lastIndex){list[i]=list[++i]}list.length=lastIndex;if(el){var doc=el.ownerDocument;if(doc){_onRemoveAttribute(doc,el,attr);attr.ownerElement=null}}}else{throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+"@"+attr))}}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(key){var i=this.length;while(i--){var attr=this[i];if(attr.nodeName==key){return attr}}},setNamedItem:function(attr){var el=attr.ownerElement;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}var oldAttr=this.getNamedItem(attr.nodeName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},setNamedItemNS:function(attr){var el=attr.ownerElement,oldAttr;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}oldAttr=this.getNamedItemNS(attr.namespaceURI,attr.localName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},removeNamedItem:function(key){var attr=this.getNamedItem(key);_removeNamedNode(this._ownerElement,this,attr);return attr},removeNamedItemNS:function(namespaceURI,localName){var attr=this.getNamedItemNS(namespaceURI,localName);_removeNamedNode(this._ownerElement,this,attr);return attr},getNamedItemNS:function(namespaceURI,localName){var i=this.length;while(i--){var node=this[i];if(node.localName==localName&&node.namespaceURI==namespaceURI){return node}}return null}};function DOMImplementation(features){this._features={};if(features){for(var feature in features){this._features=features[feature]}}}DOMImplementation.prototype={hasFeature:function(feature,version){var versions=this._features[feature.toLowerCase()];if(versions&&(!version||version in versions)){
return true}else{return false}},createDocument:function(namespaceURI,qualifiedName,doctype){var doc=new Document;doc.implementation=this;doc.childNodes=new NodeList;doc.doctype=doctype;if(doctype){doc.appendChild(doctype)}if(qualifiedName){var root=doc.createElementNS(namespaceURI,qualifiedName);doc.appendChild(root)}return doc},createDocumentType:function(qualifiedName,publicId,systemId){var node=new DocumentType;node.name=qualifiedName;node.nodeName=qualifiedName;node.publicId=publicId;node.systemId=systemId;return node}};function Node(){}Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(newChild,refChild){return _insertBefore(this,newChild,refChild)},replaceChild:function(newChild,oldChild){this.insertBefore(newChild,oldChild);if(oldChild){this.removeChild(oldChild)}},removeChild:function(oldChild){return _removeChild(this,oldChild)},appendChild:function(newChild){return this.insertBefore(newChild,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(deep){return cloneNode(this.ownerDocument||this,this,deep)},normalize:function(){var child=this.firstChild;while(child){var next=child.nextSibling;if(next&&next.nodeType==TEXT_NODE&&child.nodeType==TEXT_NODE){this.removeChild(next);child.appendData(next.data)}else{child.normalize();child=next}}},isSupported:function(feature,version){return this.ownerDocument.implementation.hasFeature(feature,version)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(namespaceURI){var el=this;while(el){var map=el._nsMap;if(map){for(var n in map){if(map[n]==namespaceURI){return n}}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},lookupNamespaceURI:function(prefix){var el=this;while(el){var map=el._nsMap;if(map){if(prefix in map){return map[prefix]}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},isDefaultNamespace:function(namespaceURI){var prefix=this.lookupPrefix(namespaceURI);return prefix==null}};function _xmlEncoder(c){return c=="<"&&"&lt;"||c==">"&&"&gt;"||c=="&"&&"&amp;"||c=='"'&&"&quot;"||"&#"+c.charCodeAt()+";"}copy(NodeType,Node);copy(NodeType,Node.prototype);function _visitNode(node,callback){if(callback(node)){return true}if(node=node.firstChild){do{if(_visitNode(node,callback)){return true}}while(node=node.nextSibling)}}function Document(){}function _onAddAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){el._nsMap[newAttr.prefix?newAttr.localName:""]=newAttr.value}}function _onRemoveAttribute(doc,el,newAttr,remove){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){delete el._nsMap[newAttr.prefix?newAttr.localName:""]}}function _onUpdateChild(doc,el,newChild){if(doc&&doc._inc){doc._inc++;var cs=el.childNodes;if(newChild){cs[cs.length++]=newChild}else{var child=el.firstChild;var i=0;while(child){cs[i++]=child;child=child.nextSibling}cs.length=i}}}function _removeChild(parentNode,child){var previous=child.previousSibling;var next=child.nextSibling;if(previous){previous.nextSibling=next}else{parentNode.firstChild=next}if(next){next.previousSibling=previous}else{parentNode.lastChild=previous}_onUpdateChild(parentNode.ownerDocument,parentNode);return child}function _insertBefore(parentNode,newChild,nextChild){var cp=newChild.parentNode;if(cp){cp.removeChild(newChild)}if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){var newFirst=newChild.firstChild;if(newFirst==null){return newChild}var newLast=newChild.lastChild}else{newFirst=newLast=newChild}var pre=nextChild?nextChild.previousSibling:parentNode.lastChild;newFirst.previousSibling=pre;newLast.nextSibling=nextChild;if(pre){pre.nextSibling=newFirst}else{parentNode.firstChild=newFirst}if(nextChild==null){parentNode.lastChild=newLast}else{nextChild.previousSibling=newLast}do{newFirst.parentNode=parentNode}while(newFirst!==newLast&&(newFirst=newFirst.nextSibling));_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){newChild.firstChild=newChild.lastChild=null}return newChild}function _appendSingleChild(parentNode,newChild){var cp=newChild.parentNode;if(cp){var pre=parentNode.lastChild;cp.removeChild(newChild);var pre=parentNode.lastChild}var pre=parentNode.lastChild;newChild.parentNode=parentNode;newChild.previousSibling=pre;newChild.nextSibling=null;if(pre){pre.nextSibling=newChild}else{parentNode.firstChild=newChild}parentNode.lastChild=newChild;_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);return newChild}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(newChild,refChild){if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){var child=newChild.firstChild;while(child){var next=child.nextSibling;this.insertBefore(child,refChild);child=next}return newChild}if(this.documentElement==null&&newChild.nodeType==ELEMENT_NODE){this.documentElement=newChild}return _insertBefore(this,newChild,refChild),newChild.ownerDocument=this,newChild},removeChild:function(oldChild){if(this.documentElement==oldChild){this.documentElement=null}return _removeChild(this,oldChild)},importNode:function(importedNode,deep){return importNode(this,importedNode,deep)},getElementById:function(id){var rtv=null;_visitNode(this.documentElement,function(node){if(node.nodeType==ELEMENT_NODE){if(node.getAttribute("id")==id){rtv=node;return true}}});return rtv},createElement:function(tagName){var node=new Element;node.ownerDocument=this;node.nodeName=tagName;node.tagName=tagName;node.childNodes=new NodeList;var attrs=node.attributes=new NamedNodeMap;attrs._ownerElement=node;return node},createDocumentFragment:function(){var node=new DocumentFragment;node.ownerDocument=this;node.childNodes=new NodeList;return node},createTextNode:function(data){var node=new Text;node.ownerDocument=this;node.appendData(data);return node},createComment:function(data){var node=new Comment;node.ownerDocument=this;node.appendData(data);return node},createCDATASection:function(data){var node=new CDATASection;node.ownerDocument=this;node.appendData(data);return node},createProcessingInstruction:function(target,data){var node=new ProcessingInstruction;node.ownerDocument=this;node.tagName=node.target=target;node.nodeValue=node.data=data;return node},createAttribute:function(name){var node=new Attr;node.ownerDocument=this;node.name=name;node.nodeName=name;node.localName=name;node.specified=true;return node},createEntityReference:function(name){var node=new EntityReference;node.ownerDocument=this;node.nodeName=name;return node},createElementNS:function(namespaceURI,qualifiedName){var node=new Element;var pl=qualifiedName.split(":");var attrs=node.attributes=new NamedNodeMap;node.childNodes=new NodeList;node.ownerDocument=this;node.nodeName=qualifiedName;node.tagName=qualifiedName;node.namespaceURI=namespaceURI;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}attrs._ownerElement=node;return node},createAttributeNS:function(namespaceURI,qualifiedName){var node=new Attr;var pl=qualifiedName.split(":");node.ownerDocument=this;node.nodeName=qualifiedName;node.name=qualifiedName;node.namespaceURI=namespaceURI;node.specified=true;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}return node}};_extends(Document,Node);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(name){return this.getAttributeNode(name)!=null},getAttribute:function(name){var attr=this.getAttributeNode(name);return attr&&attr.value||""},getAttributeNode:function(name){return this.attributes.getNamedItem(name)},setAttribute:function(name,value){var attr=this.ownerDocument.createAttribute(name);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},removeAttribute:function(name){var attr=this.getAttributeNode(name);attr&&this.removeAttributeNode(attr)},appendChild:function(newChild){if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){return this.insertBefore(newChild,null)}else{return _appendSingleChild(this,newChild)}},setAttributeNode:function(newAttr){return this.attributes.setNamedItem(newAttr)},setAttributeNodeNS:function(newAttr){return this.attributes.setNamedItemNS(newAttr)},removeAttributeNode:function(oldAttr){return this.attributes.removeNamedItem(oldAttr.nodeName)},removeAttributeNS:function(namespaceURI,localName){var old=this.getAttributeNodeNS(namespaceURI,localName);old&&this.removeAttributeNode(old)},hasAttributeNS:function(namespaceURI,localName){return this.getAttributeNodeNS(namespaceURI,localName)!=null},getAttributeNS:function(namespaceURI,localName){var attr=this.getAttributeNodeNS(namespaceURI,localName);return attr&&attr.value||""},setAttributeNS:function(namespaceURI,qualifiedName,value){var attr=this.ownerDocument.createAttributeNS(namespaceURI,qualifiedName);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},getAttributeNodeNS:function(namespaceURI,localName){return this.attributes.getNamedItemNS(namespaceURI,localName)},getElementsByTagName:function(tagName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType==ELEMENT_NODE&&(tagName==="*"||node.tagName==tagName)){ls.push(node)}});return ls})},getElementsByTagNameNS:function(namespaceURI,localName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType===ELEMENT_NODE&&(namespaceURI==="*"||node.namespaceURI===namespaceURI)&&(localName==="*"||node.localName==localName)){ls.push(node)}});return ls})}};Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName;Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS;_extends(Element,Node);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE;_extends(Attr,Node);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(offset,count){return this.data.substring(offset,offset+count)},appendData:function(text){text=this.data+text;this.nodeValue=this.data=text;this.length=text.length},insertData:function(offset,text){this.replaceData(offset,0,text)},appendChild:function(newChild){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(offset,count){this.replaceData(offset,count,"")},replaceData:function(offset,count,text){var start=this.data.substring(0,offset);var end=this.data.substring(offset+count);text=start+text+end;this.nodeValue=this.data=text;this.length=text.length}};_extends(CharacterData,Node);function Text(){}Text.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(offset){var text=this.data;var newText=text.substring(offset);text=text.substring(0,offset);this.data=this.nodeValue=text;this.length=text.length;var newNode=this.ownerDocument.createTextNode(newText);if(this.parentNode){this.parentNode.insertBefore(newNode,this.nextSibling)}return newNode}};_extends(Text,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE};_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE};_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE;_extends(DocumentType,Node);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE;_extends(Notation,Node);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE;_extends(Entity,Node);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE;_extends(EntityReference,Node);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment";DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE;_extends(DocumentFragment,Node);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE;_extends(ProcessingInstruction,Node);function XMLSerializer(){}XMLSerializer.prototype.serializeToString=function(node,isHtml,nodeFilter){return nodeSerializeToString.call(node,isHtml,nodeFilter)};Node.prototype.toString=nodeSerializeToString;function nodeSerializeToString(isHtml,nodeFilter){var buf=[];var refNode=this.nodeType==9?this.documentElement:this;var prefix=refNode.prefix;var uri=refNode.namespaceURI;if(uri&&prefix==null){var prefix=refNode.lookupPrefix(uri);if(prefix==null){var visibleNamespaces=[{namespace:uri,prefix:null}]}}serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);return buf.join("")}function needNamespaceDefine(node,isHTML,visibleNamespaces){var prefix=node.prefix||"";var uri=node.namespaceURI;if(!prefix&&!uri){return false}if(prefix==="xml"&&uri==="http://www.w3.org/XML/1998/namespace"||uri=="http://www.w3.org/2000/xmlns/"){return false}var i=visibleNamespaces.length;while(i--){var ns=visibleNamespaces[i];if(ns.prefix==prefix){return ns.namespace!=uri}}return true}function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){if(nodeFilter){node=nodeFilter(node);if(node){if(typeof node=="string"){buf.push(node);return}}else{return}}switch(node.nodeType){case ELEMENT_NODE:if(!visibleNamespaces)visibleNamespaces=[];var startVisibleNamespaces=visibleNamespaces.length;var attrs=node.attributes;var len=attrs.length;var child=node.firstChild;var nodeName=node.tagName;isHTML=htmlns===node.namespaceURI||isHTML;buf.push("<",nodeName);for(var i=0;i<len;i++){var attr=attrs.item(i);if(attr.prefix=="xmlns"){visibleNamespaces.push({prefix:attr.localName,namespace:attr.value})}else if(attr.nodeName=="xmlns"){visibleNamespaces.push({prefix:"",namespace:attr.value})}}for(var i=0;i<len;i++){var attr=attrs.item(i);if(needNamespaceDefine(attr,isHTML,visibleNamespaces)){var prefix=attr.prefix||"";var uri=attr.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces)}if(needNamespaceDefine(node,isHTML,visibleNamespaces)){var prefix=node.prefix||"";var uri=node.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}if(child||isHTML&&!/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){buf.push(">");if(isHTML&&/^script$/i.test(nodeName)){while(child){if(child.data){buf.push(child.data)}else{serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces)}child=child.nextSibling}}else{while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}}buf.push("</",nodeName,">")}else{buf.push("/>")}return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var child=node.firstChild;while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}return;case ATTRIBUTE_NODE:return buf.push(" ",node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');case TEXT_NODE:return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));case CDATA_SECTION_NODE:return buf.push("<![CDATA[",node.data,"]]>");case COMMENT_NODE:return buf.push("<!--",node.data,"-->");case DOCUMENT_TYPE_NODE:var pubid=node.publicId;var sysid=node.systemId;buf.push("<!DOCTYPE ",node.name);if(pubid){buf.push(' PUBLIC "',pubid);if(sysid&&sysid!="."){buf.push('" "',sysid)}buf.push('">')}else if(sysid&&sysid!="."){buf.push(' SYSTEM "',sysid,'">')}else{var sub=node.internalSubset;if(sub){buf.push(" [",sub,"]")}buf.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return buf.push("<?",node.target," ",node.data,"?>");case ENTITY_REFERENCE_NODE:return buf.push("&",node.nodeName,";");default:buf.push("??",node.nodeName)}}function importNode(doc,node,deep){var node2;switch(node.nodeType){case ELEMENT_NODE:node2=node.cloneNode(false);node2.ownerDocument=doc;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:deep=true;break}if(!node2){node2=node.cloneNode(false)}node2.ownerDocument=doc;node2.parentNode=null;if(deep){var child=node.firstChild;while(child){node2.appendChild(importNode(doc,child,deep));child=child.nextSibling}}return node2}function cloneNode(doc,node,deep){var node2=new node.constructor;for(var n in node){var v=node[n];if(typeof v!="object"){if(v!=node2[n]){node2[n]=v}}}if(node.childNodes){node2.childNodes=new NodeList}node2.ownerDocument=doc;switch(node2.nodeType){case ELEMENT_NODE:var attrs=node.attributes;var attrs2=node2.attributes=new NamedNodeMap;var len=attrs.length;attrs2._ownerElement=node2;for(var i=0;i<len;i++){node2.setAttributeNode(cloneNode(doc,attrs.item(i),true))}break;case ATTRIBUTE_NODE:deep=true}if(deep){var child=node.firstChild;while(child){node2.appendChild(cloneNode(doc,child,deep));child=child.nextSibling}}return node2}function __set__(object,key,value){object[key]=value}try{if(Object.defineProperty){Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){_updateLiveList(this);return this.$$length}});Object.defineProperty(Node.prototype,"textContent",{get:function(){return getTextContent(this)},set:function(data){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:while(this.firstChild){this.removeChild(this.firstChild)}if(data||String(data)){this.appendChild(this.ownerDocument.createTextNode(data))}break;default:this.data=data;this.value=data;this.nodeValue=data}}});function getTextContent(node){switch(node.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var buf=[];node=node.firstChild;while(node){if(node.nodeType!==7&&node.nodeType!==8){buf.push(getTextContent(node))}node=node.nextSibling}return buf.join("");default:return node.nodeValue}}__set__=function(object,key,value){object["$$"+key]=value}}}catch(e){}exports.DOMImplementation=DOMImplementation;exports.XMLSerializer=XMLSerializer},{}],25:[function(require,module,exports){var nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;var nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");var tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$");var S_TAG=0;var S_ATTR=1;var S_ATTR_SPACE=2;var S_EQ=3;var S_ATTR_NOQUOT_VALUE=4;var S_ATTR_END=5;var S_TAG_SPACE=6;var S_TAG_CLOSE=7;function XMLReader(){}XMLReader.prototype={parse:function(source,defaultNSMap,entityMap){var domBuilder=this.domBuilder;domBuilder.startDocument();_copy(defaultNSMap,defaultNSMap={});parse(source,defaultNSMap,entityMap,domBuilder,this.errorHandler);domBuilder.endDocument()}};function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){function fixedFromCharCode(code){if(code>65535){code-=65536;var surrogate1=55296+(code>>10),surrogate2=56320+(code&1023);return String.fromCharCode(surrogate1,surrogate2)}else{return String.fromCharCode(code)}}function entityReplacer(a){var k=a.slice(1,-1);if(k in entityMap){return entityMap[k]}else if(k.charAt(0)==="#"){return fixedFromCharCode(parseInt(k.substr(1).replace("x","0x")))}else{errorHandler.error("entity not found:"+a);return a}}function appendText(end){if(end>start){var xt=source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);locator&&position(start);domBuilder.characters(xt,0,end-start);start=end}}function position(p,m){while(p>=lineEnd&&(m=linePattern.exec(source))){lineStart=m.index;lineEnd=lineStart+m[0].length;locator.lineNumber++}locator.columnNumber=p-lineStart+1}var lineStart=0;var lineEnd=0;var linePattern=/.*(?:\r\n?|\n)|.*$/g;var locator=domBuilder.locator;var parseStack=[{currentNSMap:defaultNSMapCopy}];var closeMap={};var start=0;while(true){try{var tagStart=source.indexOf("<",start);if(tagStart<0){if(!source.substr(start).match(/^\s*$/)){var doc=domBuilder.doc;var text=doc.createTextNode(source.substr(start));doc.appendChild(text);domBuilder.currentElement=text}return}if(tagStart>start){appendText(tagStart)}switch(source.charAt(tagStart+1)){case"/":var end=source.indexOf(">",tagStart+3);var tagName=source.substring(tagStart+2,end);var config=parseStack.pop();if(end<0){tagName=source.substring(tagStart+2).replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" is not complete:"+config.tagName);end=tagStart+1+tagName.length}else if(tagName.match(/\s</)){tagName=tagName.replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" maybe not complete");end=tagStart+1+tagName.length}var localNSMap=config.localNSMap;var endMatch=config.tagName==tagName;var endIgnoreCaseMach=endMatch||config.tagName&&config.tagName.toLowerCase()==tagName.toLowerCase();if(endIgnoreCaseMach){domBuilder.endElement(config.uri,config.localName,tagName);if(localNSMap){for(var prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}if(!endMatch){errorHandler.fatalError("end tag name: "+tagName+" is not match the current start tagName:"+config.tagName)}}else{parseStack.push(config)}end++;break;case"?":locator&&position(tagStart);end=parseInstruction(source,tagStart,domBuilder);break;case"!":locator&&position(tagStart);end=parseDCC(source,tagStart,domBuilder,errorHandler);break;default:locator&&position(tagStart);var el=new ElementAttributes;var currentNSMap=parseStack[parseStack.length-1].currentNSMap;var end=parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);var len=el.length;if(!el.closed&&fixSelfClosed(source,end,el.tagName,closeMap)){el.closed=true;if(!entityMap.nbsp){errorHandler.warning("unclosed xml attribute")}}if(locator&&len){var locator2=copyLocator(locator,{});for(var i=0;i<len;i++){var a=el[i];position(a.offset);a.locator=copyLocator(locator,{})}domBuilder.locator=locator2;if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}domBuilder.locator=locator}else{if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}}if(el.uri==="http://www.w3.org/1999/xhtml"&&!el.closed){end=parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)}else{end++}}}catch(e){errorHandler.error("element parse error: "+e);end=-1}if(end>start){start=end}else{appendText(Math.max(tagStart,start)+1)}}}function copyLocator(f,t){t.lineNumber=f.lineNumber;t.columnNumber=f.columnNumber;return t}function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){var attrName;var value;var p=++start;var s=S_TAG;while(true){var c=source.charAt(p);switch(c){case"=":if(s===S_ATTR){attrName=source.slice(start,p);s=S_EQ}else if(s===S_ATTR_SPACE){s=S_EQ}else{throw new Error("attribute equal must after attrName")}break;case"'":case'"':if(s===S_EQ||s===S_ATTR){if(s===S_ATTR){errorHandler.warning('attribute value must after "="');attrName=source.slice(start,p)}start=p+1;p=source.indexOf(c,start);if(p>0){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start-1);s=S_ATTR_END}else{throw new Error("attribute value no end '"+c+"' match")}}else if(s==S_ATTR_NOQUOT_VALUE){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start);errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+")!!");start=p+1;s=S_ATTR_END}else{throw new Error('attribute value must after "="')}break;case"/":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:s=S_TAG_CLOSE;el.closed=true;case S_ATTR_NOQUOT_VALUE:case S_ATTR:case S_ATTR_SPACE:break;default:throw new Error("attribute invalid close char('/')")}break;case"":errorHandler.error("unexpected end of input");if(s==S_TAG){el.setTagName(source.slice(start,p))}return p;case">":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:value=source.slice(start,p);if(value.slice(-1)==="/"){el.closed=true;value=value.slice(0,-1)}case S_ATTR_SPACE:if(s===S_ATTR_SPACE){value=attrName}if(s==S_ATTR_NOQUOT_VALUE){errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)}else{if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!value.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')}el.add(value,value,start)}break;case S_EQ:throw new Error("attribute value missed!!")}return p;case"":c=" ";default:if(c<=" "){switch(s){case S_TAG:el.setTagName(source.slice(start,p));s=S_TAG_SPACE;break;case S_ATTR:attrName=source.slice(start,p);s=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value,start);case S_ATTR_END:s=S_TAG_SPACE;break}}else{switch(s){case S_ATTR_SPACE:var tagName=el.tagName;if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!attrName.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')}el.add(attrName,attrName,start);start=p;s=S_ATTR;break;case S_ATTR_END:errorHandler.warning('attribute space is required"'+attrName+'"!!');case S_TAG_SPACE:s=S_ATTR;start=p;break;case S_EQ:s=S_ATTR_NOQUOT_VALUE;start=p;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}}p++}}function appendElement(el,domBuilder,currentNSMap){var tagName=el.tagName;var localNSMap=null;var i=el.length;while(i--){var a=el[i];var qName=a.qName;var value=a.value;var nsp=qName.indexOf(":");if(nsp>0){var prefix=a.prefix=qName.slice(0,nsp);var localName=qName.slice(nsp+1);var nsPrefix=prefix==="xmlns"&&localName}else{localName=qName;prefix=null;nsPrefix=qName==="xmlns"&&""}a.localName=localName;if(nsPrefix!==false){if(localNSMap==null){localNSMap={};_copy(currentNSMap,currentNSMap={})}currentNSMap[nsPrefix]=localNSMap[nsPrefix]=value;a.uri="http://www.w3.org/2000/xmlns/";domBuilder.startPrefixMapping(nsPrefix,value)}}var i=el.length;while(i--){a=el[i];var prefix=a.prefix;if(prefix){if(prefix==="xml"){a.uri="http://www.w3.org/XML/1998/namespace"}if(prefix!=="xmlns"){a.uri=currentNSMap[prefix||""]}}}var nsp=tagName.indexOf(":");if(nsp>0){prefix=el.prefix=tagName.slice(0,nsp);localName=el.localName=tagName.slice(nsp+1)}else{prefix=null;localName=el.localName=tagName}var ns=el.uri=currentNSMap[prefix||""];domBuilder.startElement(ns,localName,tagName,el);if(el.closed){domBuilder.endElement(ns,localName,tagName);if(localNSMap){for(prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}}else{el.currentNSMap=currentNSMap;el.localNSMap=localNSMap;return true}}function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){if(/^(?:script|textarea)$/i.test(tagName)){var elEndStart=source.indexOf("</"+tagName+">",elStartEnd);var text=source.substring(elStartEnd+1,elEndStart);if(/[&<]/.test(text)){if(/^script$/i.test(tagName)){domBuilder.characters(text,0,text.length);return elEndStart}text=text.replace(/&#?\w+;/g,entityReplacer);domBuilder.characters(text,0,text.length);return elEndStart}}return elStartEnd+1}function fixSelfClosed(source,elStartEnd,tagName,closeMap){var pos=closeMap[tagName];if(pos==null){pos=source.lastIndexOf("</"+tagName+">");if(pos<elStartEnd){pos=source.lastIndexOf("</"+tagName)}closeMap[tagName]=pos}return pos<elStartEnd}function _copy(source,target){for(var n in source){target[n]=source[n]}}function parseDCC(source,start,domBuilder,errorHandler){var next=source.charAt(start+2);switch(next){case"-":if(source.charAt(start+3)==="-"){var end=source.indexOf("-->",start+4);if(end>start){domBuilder.comment(source,start+4,end-start-4);return end+3}else{errorHandler.error("Unclosed comment");return-1}}else{return-1}default:if(source.substr(start+3,6)=="CDATA["){var end=source.indexOf("]]>",start+9);domBuilder.startCDATA();domBuilder.characters(source,start+9,end-start-9);domBuilder.endCDATA();return end+3}var matchs=split(source,start);var len=matchs.length;if(len>1&&/!doctype/i.test(matchs[0][0])){var name=matchs[1][0];var pubid=len>3&&/^public$/i.test(matchs[2][0])&&matchs[3][0];var sysid=len>4&&matchs[4][0];var lastMatch=matchs[len-1];domBuilder.startDTD(name,pubid&&pubid.replace(/^(['"])(.*?)\1$/,"$2"),sysid&&sysid.replace(/^(['"])(.*?)\1$/,"$2"));domBuilder.endDTD();return lastMatch.index+lastMatch[0].length}}return-1}function parseInstruction(source,start,domBuilder){var end=source.indexOf("?>",start);if(end){var match=source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(match){var len=match[0].length;domBuilder.processingInstruction(match[1],match[2]);return end+2}else{return-1}}return-1}function ElementAttributes(source){}ElementAttributes.prototype={setTagName:function(tagName){if(!tagNamePattern.test(tagName)){throw new Error("invalid tagName:"+tagName)}this.tagName=tagName},add:function(qName,value,offset){if(!tagNamePattern.test(qName)){throw new Error("invalid attribute:"+qName)}this[this.length++]={qName:qName,value:value,offset:offset}},length:0,getLocalName:function(i){return this[i].localName},getLocator:function(i){return this[i].locator},getQName:function(i){return this[i].qName},getURI:function(i){return this[i].uri},getValue:function(i){return this[i].value}};function _set_proto_(thiz,parent){thiz.__proto__=parent;return thiz}if(!(_set_proto_({},_set_proto_.prototype)instanceof _set_proto_)){_set_proto_=function(thiz,parent){function p(){}p.prototype=parent;p=new p;for(parent in thiz){p[parent]=thiz[parent]}return p}}function split(source,start){var match;var buf=[];var reg=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;reg.lastIndex=start;reg.exec(source);while(match=reg.exec(source)){buf.push(match);if(match[1])return buf}}exports.XMLReader=XMLReader},{}],"/src/js/index.js":[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var templates=require("./templates");var DocUtils=require("docxtemplater").DocUtils;var DOMParser=require("xmldom").DOMParser;function isNaN(number){return!(number===number)}var ImgManager=require("./imgManager");var moduleName="open-xml-templating/docxtemplater-image-module";function getInnerDocx(_ref){var part=_ref.part;return part}function getInnerPptx(_ref2){var part=_ref2.part,left=_ref2.left,right=_ref2.right,postparsed=_ref2.postparsed;var xmlString=postparsed.slice(left+1,right).reduce(function(concat,item){return concat+item.value},"");var xmlDoc=(new DOMParser).parseFromString("<xml>"+xmlString+"</xml>");var offset=xmlDoc.getElementsByTagName("a:off");var ext=xmlDoc.getElementsByTagName("a:ext");part.ext={cx:parseInt(ext[0].getAttribute("cx"),10),cy:parseInt(ext[0].getAttribute("cy"),10)};part.offset={x:parseInt(offset[0].getAttribute("x"),10),y:parseInt(offset[0].getAttribute("y"),10)};return part}var ImageModule=function(){function ImageModule(options){_classCallCheck(this,ImageModule);this.name="ImageModule";this.options=options||{};this.imgManagers={};if(this.options.centered==null){this.options.centered=false}if(this.options.getImage==null){throw new Error("You should pass getImage")}if(this.options.getSize==null){throw new Error("You should pass getSize")}this.imageNumber=1}_createClass(ImageModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){
var relsFiles=docxtemplater.zip.file(/\.xml\.rels/).concat(docxtemplater.zip.file(/\[Content_Types\].xml/)).map(function(file){return file.name});this.fileTypeConfig=docxtemplater.fileTypeConfig;this.fileType=docxtemplater.fileType;this.zip=docxtemplater.zip;options.xmlFileNames=options.xmlFileNames.concat(relsFiles);return options}},{key:"set",value:function set(options){if(options.zip){this.zip=options.zip}if(options.xmlDocuments){this.xmlDocuments=options.xmlDocuments}}},{key:"parse",value:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent.substring(0,2)==="%%"){return{type:type,value:placeHolderContent.substr(2),module:module,centered:true}}if(placeHolderContent.substring(0,1)==="%"){return{type:type,value:placeHolderContent.substr(1),module:module,centered:false}}return null}},{key:"postparse",value:function postparse(parsed){var expandTo=void 0;var getInner=void 0;if(this.fileType==="pptx"){expandTo="p:sp";getInner=getInnerPptx}else{expandTo=this.options.centered?"w:p":"w:t";getInner=getInnerDocx}return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:expandTo})}},{key:"render",value:function render(part,options){this.imgManagers[options.filePath]=this.imgManagers[options.filePath]||new ImgManager(this.zip,options.filePath,this.xmlDocuments,this.fileType);var imgManager=this.imgManagers[options.filePath];if(!part.type==="placeholder"||part.module!==moduleName){return null}try{var tagValue=options.scopeManager.getValue(part.value);if(!tagValue){throw new Error("tagValue is empty")}var imgBuffer=this.options.getImage(tagValue,part.value);var rId=imgManager.addImageRels(this.getNextImageName(),imgBuffer);var sizePixel=this.options.getSize(imgBuffer,tagValue,part.value);return this.getRenderedPart(part,rId,sizePixel)}catch(e){return{value:this.fileTypeConfig.tagTextXml}}}},{key:"getRenderedPart",value:function getRenderedPart(part,rId,sizePixel){if(isNaN(rId)){throw new Error("rId is NaN, aborting")}var size=[DocUtils.convertPixelsToEmus(sizePixel[0]),DocUtils.convertPixelsToEmus(sizePixel[1])];var centered=this.options.centered||part.centered;var newText=void 0;if(this.fileType==="pptx"){newText=this.getRenderedPartPptx(part,rId,size,centered)}else{newText=this.getRenderedPartDocx(rId,size,centered)}return{value:newText}}},{key:"getRenderedPartPptx",value:function getRenderedPartPptx(part,rId,size,centered){var offset={x:part.offset.x,y:part.offset.y};var cellCX=part.ext.cx;var cellCY=part.ext.cy;var imgW=size[0];var imgH=size[1];if(centered){offset.x+=cellCX/2-imgW/2;offset.y+=cellCY/2-imgH/2}return templates.getPptxImageXml(rId,[imgW,imgH],offset)}},{key:"getRenderedPartDocx",value:function getRenderedPartDocx(rId,size,centered){return centered?templates.getImageXmlCentered(rId,size):templates.getImageXml(rId,size)}},{key:"getNextImageName",value:function getNextImageName(){var name="image_generated_"+this.imageNumber+".png";this.imageNumber++;return name}}]);return ImageModule}();module.exports=ImageModule},{"./imgManager":2,"./templates":3,docxtemplater:5,xmldom:23}]},{},[])("/src/js/index.js")});

/***/ }),

/***/ 11824:
/*!*****************************************!*\
  !*** ./js/docxtemplater.v3.0.12.min.js ***!
  \*****************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}var memoize=require("./memoize");var DOMParser=require("xmldom").DOMParser;var XMLSerializer=require("xmldom").XMLSerializer;var Errors=require("./errors");var DocUtils={};function parser(tag){return _defineProperty({},"get",function get(scope){if(tag==="."){return scope}return scope[tag]})}DocUtils.defaults={nullGetter:function nullGetter(part){if(!part.module){return"undefined"}if(part.module==="rawxml"){return""}return""},parser:memoize(parser),delimiters:{start:"{",end:"}"}};DocUtils.mergeObjects=function(){var resObj={};var obj=void 0,keys=void 0;for(var i=0;i<arguments.length;i+=1){obj=arguments[i];keys=Object.keys(obj);for(var j=0;j<keys.length;j+=1){resObj[keys[j]]=obj[keys[j]]}}return resObj};DocUtils.xml2str=function(xmlNode){var a=new XMLSerializer;return a.serializeToString(xmlNode)};DocUtils.decodeUtf8=function(s){try{if(s===undefined){return undefined}return decodeURIComponent(escape(DocUtils.convertSpaces(s)))}catch(e){var err=new Error("End");err.properties.data=s;err.properties.explanation="Could not decode string to UTF8";throw err}};DocUtils.encodeUtf8=function(s){return unescape(encodeURIComponent(s))};DocUtils.str2xml=function(str,errorHandler){var parser=new DOMParser({errorHandler:errorHandler});return parser.parseFromString(str,"text/xml")};DocUtils.charMap={"&":"&amp;","'":"&apos;","<":"&lt;",">":"&gt;"};var regexStripRegexp=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;DocUtils.escapeRegExp=function(str){return str.replace(regexStripRegexp,"\\$&")};DocUtils.charMapRegexes=Object.keys(DocUtils.charMap).map(function(endChar){var startChar=DocUtils.charMap[endChar];return{rstart:new RegExp(DocUtils.escapeRegExp(startChar),"g"),rend:new RegExp(DocUtils.escapeRegExp(endChar),"g"),start:startChar,end:endChar}});DocUtils.wordToUtf8=function(string){var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rstart,r.end)}return string};DocUtils.utf8ToWord=function(string){if(typeof string!=="string"){string=string.toString()}var r=void 0;for(var i=0,l=DocUtils.charMapRegexes.length;i<l;i++){r=DocUtils.charMapRegexes[i];string=string.replace(r.rend,r.start)}return string};DocUtils.cloneDeep=function(obj){return JSON.parse(JSON.stringify(obj))};DocUtils.concatArrays=function(arrays){return arrays.reduce(function(result,array){Array.prototype.push.apply(result,array);return result},[])};var spaceRegexp=new RegExp(String.fromCharCode(160),"g");DocUtils.convertSpaces=function(s){return s.replace(spaceRegexp," ")};DocUtils.pregMatchAll=function(regex,content){var matchArray=[];var match=void 0;while((match=regex.exec(content))!=null){matchArray.push({array:match,offset:match.index})}return matchArray};DocUtils.sizeOfObject=function(obj){return Object.keys(obj).length};function throwXmlTagNotFound(options){var err=new Errors.XTTemplateError("No tag '"+options.element+"' was found at the "+options.position);err.properties={id:"no_xml_tag_found_at_"+options.position,explanation:"No tag '"+options.element+"' was found at the "+options.position,parsed:options.parsed,index:options.index,element:options.element};throw err}DocUtils.getRight=function(parsed,element,index){for(var i=index,l=parsed.length;i<l;i++){var part=parsed[i];if(part.value==="</"+element+">"){return i}}throwXmlTagNotFound({position:"right",element:element,parsed:parsed,index:index})};DocUtils.getLeft=function(parsed,element,index){for(var i=index;i>=0;i--){var part=parsed[i];if(part.value.indexOf("<"+element)===0&&[">"," "].indexOf(part.value[element.length+1])!==-1){return i}}throwXmlTagNotFound({position:"left",element:element,parsed:parsed,index:index})};module.exports=DocUtils},{"./errors":2,"./memoize":5,xmldom:19}],2:[function(require,module,exports){"use strict";function XTError(message){this.name="GenericError";this.message=message;this.stack=new Error(message).stack}XTError.prototype=Error.prototype;function XTTemplateError(message){this.name="TemplateError";this.message=message;this.stack=new Error(message).stack}XTTemplateError.prototype=new XTError;function XTScopeParserError(message){this.name="ScopeParserError";this.message=message;this.stack=new Error(message).stack}XTScopeParserError.prototype=new XTError;function XTInternalError(message){this.name="InternalError";this.properties={explanation:"InternalError"};this.message=message;this.stack=new Error(message).stack}XTInternalError.prototype=new XTError;module.exports={XTError:XTError,XTTemplateError:XTTemplateError,XTInternalError:XTInternalError,XTScopeParserError:XTScopeParserError}},{}],3:[function(require,module,exports){"use strict";var loopModule=require("./modules/loop");var spacePreserveModule=require("./modules/space-preserve");var rawXmlModule=require("./modules/rawxml");var expandPairTrait=require("./modules/expand-pair-trait");var render=require("./modules/render");var PptXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/ppt\/(slides|slideMasters)\/(slide|slideMaster)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["ppt/presentation.xml"])},textPath:"ppt/slides/slide1.xml",tagsXmlTextArray:["a:t","m:t"],tagsXmlLexedArray:["p:sp","a:tc","a:tr","a:table","a:p","a:r"],tagRawXml:"p:sp",tagTextXml:"a:t",baseModules:[render,expandPairTrait,rawXmlModule,loopModule]};var DocXFileTypeConfig={getTemplatedFiles:function getTemplatedFiles(zip){var slideTemplates=zip.file(/word\/(header|footer)\d+\.xml/).map(function(file){return file.name});return slideTemplates.concat(["word/document.xml"])},textPath:"word/document.xml",tagsXmlTextArray:["w:t","m:t"],tagsXmlLexedArray:["w:tc","w:tr","w:table","w:p","w:r"],tagRawXml:"w:p",tagTextXml:"w:t",baseModules:[render,spacePreserveModule,expandPairTrait,rawXmlModule,loopModule]};module.exports={docx:DocXFileTypeConfig,pptx:PptXFileTypeConfig}},{"./modules/expand-pair-trait":8,"./modules/loop":9,"./modules/rawxml":10,"./modules/render":11,"./modules/space-preserve":12}],4:[function(require,module,exports){"use strict";var Errors=require("./errors");var DocUtils=require("./doc-utils");function inRange(range,match){return range[0]<=match.offset&&match.offset<range[1]}function updateInTextTag(part,inTextTag){if(part.type==="tag"&&part.position==="start"&&part.text){if(inTextTag){throw new Error("Malformed xml : Already in text tag")}return true}if(part.type==="tag"&&part.position==="end"&&part.text){if(!inTextTag){throw new Error("Malformed xml : Already not in text tag")}return false}return inTextTag}function offsetSort(a,b){return a.offset-b.offset}function getTag(tag){var start=1;if(tag[1]==="/"){start=2}var index=tag.indexOf(" ");var end=index===-1?tag.length-1:index;return{tag:tag.slice(start,end),position:start===1?"start":"end"}}function tagMatcher(content,textMatchArray,othersMatchArray){var cursor=0;var contentLength=content.length;var allMatches=DocUtils.concatArrays([textMatchArray.map(function(tag){return{tag:tag,text:true}}),othersMatchArray.map(function(tag){return{tag:tag,text:false}})]).reduce(function(allMatches,t){allMatches[t.tag]=t.text;return allMatches},{});var totalMatches=[];while(cursor<contentLength){cursor=content.indexOf("<",cursor);if(cursor===-1){break}var offset=cursor;cursor=content.indexOf(">",cursor);var tagText=content.slice(offset,cursor+1);var _getTag=getTag(tagText),tag=_getTag.tag,position=_getTag.position;var text=allMatches[tag];if(text==null){continue}totalMatches.push({type:"tag",position:position,text:text,offset:offset,value:tagText})}return totalMatches}function throwUnopenedTagException(options){var err=new Errors.XTTemplateError("Unopened tag");err.properties={xtag:options.xtag.split(" ")[0],id:"unopened_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function throwUnclosedTagException(options){var err=new Errors.XTTemplateError("Unclosed tag");err.properties={xtag:options.xtag.split(" ")[0].substr(1),id:"unclosed_tag",context:options.xtag,explanation:"The tag beginning with '"+options.xtag.substr(0,10)+"' is unclosed"};throw err}function assertDelimiterOrdered(delimiterMatches,fullText){var inDelimiter=false;var lastDelimiterMatch={offset:0};var xtag=void 0;delimiterMatches.forEach(function(delimiterMatch){xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(delimiterMatch.position==="start"&&inDelimiter||delimiterMatch.position==="end"&&!inDelimiter){if(delimiterMatch.position==="start"){throwUnclosedTagException({xtag:xtag})}else{throwUnopenedTagException({xtag:xtag})}}inDelimiter=!inDelimiter;lastDelimiterMatch=delimiterMatch});var delimiterMatch={offset:fullText.length};xtag=fullText.substr(lastDelimiterMatch.offset,delimiterMatch.offset-lastDelimiterMatch.offset);if(inDelimiter){throwUnclosedTagException({xtag:xtag})}}function getAllIndexes(arr,val,position){var indexes=[];var offset=-1;do{offset=arr.indexOf(val,offset+1);if(offset!==-1){indexes.push({offset:offset,position:position})}}while(offset!==-1);return indexes}function Reader(innerContentParts){var _this=this;this.innerContentParts=innerContentParts;this.full="";this.parseDelimiters=function(delimiters){_this.full=_this.innerContentParts.join("");var offset=0;_this.ranges=_this.innerContentParts.map(function(part){offset+=part.length;return offset-part.length});var delimiterMatches=DocUtils.concatArrays([getAllIndexes(_this.full,delimiters.start,"start"),getAllIndexes(_this.full,delimiters.end,"end")]).sort(offsetSort);assertDelimiterOrdered(delimiterMatches,_this.full);var delimiterLength={start:delimiters.start.length,end:delimiters.end.length};var cutNext=0;var delimiterIndex=0;_this.parsed=_this.ranges.map(function(offset,i){var range=[offset,offset+this.innerContentParts[i].length];var partContent=this.innerContentParts[i];var delimitersInOffset=[];while(delimiterIndex<delimiterMatches.length&&inRange(range,delimiterMatches[delimiterIndex])){delimitersInOffset.push(delimiterMatches[delimiterIndex]);delimiterIndex++}var parts=[];var cursor=0;if(cutNext>0){cursor=cutNext;cutNext=0}delimitersInOffset.forEach(function(delimiterInOffset){var value=partContent.substr(cursor,delimiterInOffset.offset-offset-cursor);if(value.length>0){parts.push({type:"content",value:value})}parts.push({type:"delimiter",position:delimiterInOffset.position});cursor=delimiterInOffset.offset-offset+delimiterLength[delimiterInOffset.position]});cutNext=cursor-partContent.length;var value=partContent.substr(cursor);if(value.length>0){parts.push({type:"content",value:value})}return parts},_this)}}module.exports={parse:function parse(xmlparsed,delimiters){var inTextTag=false;var innerContentParts=[];xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(inTextTag&&part.type==="content"){innerContentParts.push(part.value)}});var reader=new Reader(innerContentParts);reader.parseDelimiters(delimiters);var newArray=[];var index=0;xmlparsed.forEach(function(part){inTextTag=updateInTextTag(part,inTextTag);if(part.type==="content"){part.position=inTextTag?"insidetag":"outsidetag"}if(inTextTag&&part.type==="content"){Array.prototype.push.apply(newArray,reader.parsed[index].map(function(p){if(p.type==="content"){p.position="insidetag"}return p}));index++}else{newArray.push(part)}});return newArray},xmlparse:function xmlparse(content,xmltags){var matches=tagMatcher(content,xmltags.text,xmltags.other);var cursor=0;var parsed=matches.reduce(function(parsed,match){var value=content.substr(cursor,match.offset-cursor);if(value.length>0){parsed.push({type:"content",value:value})}cursor=match.offset+match.value.length;delete match.offset;if(match.value.length>0){parsed.push(match)}return parsed},[]);var value=content.substr(cursor);if(value.length>0){parsed.push({type:"content",value:value})}return parsed}}},{"./doc-utils":1,"./errors":2}],5:[function(require,module,exports){"use strict";function memoize(func){var stringifyJson=JSON.stringify,cache={};function cachedfun(){var hash=stringifyJson(arguments);return hash in cache?cache[hash]:cache[hash]=func.apply(this,arguments)}return cachedfun}module.exports=memoize},{}],6:[function(require,module,exports){"use strict";function getMinFromArrays(arrays,state){var minIndex=-1;for(var i=0,l=arrays.length;i<l;i++){if(state[i]>=arrays[i].length){continue}if(minIndex===-1||arrays[i][state[i]].offset<arrays[minIndex][state[minIndex]].offset){minIndex=i}}if(minIndex===-1){throw new Error("minIndex negative")}return minIndex}module.exports=function(arrays){var totalLength=arrays.reduce(function(sum,array){return sum+array.length},0);arrays=arrays.filter(function(array){return array.length>0});var resultArray=new Array(totalLength);var state=arrays.map(function(){return 0});var i=0;while(i<=totalLength-1){var arrayIndex=getMinFromArrays(arrays,state);resultArray[i]=arrays[arrayIndex][state[arrayIndex]];state[arrayIndex]++;i++}return resultArray}},{}],7:[function(require,module,exports){"use strict";function emptyFun(){}function identity(i){return i}module.exports=function(module){var defaults={set:emptyFun,parse:emptyFun,render:emptyFun,getTraits:emptyFun,optionsTransformer:identity,getRenderedMap:identity,postparse:identity};if(Object.keys(defaults).every(function(key){return!module[key]})){throw new Error("This module cannot be wrapped, because it doesn't define any of the necessary functions")}Object.keys(defaults).forEach(function(key){module[key]=module[key]||defaults[key]});return module}},{}],8:[function(require,module,exports){"use strict";var traitName="expandPair";var mergeSort=require("../mergesort");var DocUtils=require("../doc-utils");var wrapper=require("../module-wrapper");var _require=require("../traits"),getExpandToDefault=_require.getExpandToDefault;var Errors=require("../errors");function throwUnmatchedLoopException(options){var location=options.location;var t=location==="start"?"unclosed":"unopened";var T=location==="start"?"Unclosed":"Unopened";var err=new Errors.XTTemplateError(T+" loop");var tag=options.part.value;err.properties={id:t+"_loop",explanation:"The loop with tag "+tag+" is "+t,xtag:tag};throw err}function throwClosingTagNotMatchOpeningTag(options){var tags=options.tags;var err=new Errors.XTTemplateError("Closing tag does not match opening tag");err.properties={id:"closing_tag_does_not_match_opening_tag",explanation:'The tag "'+tags[0].value+'" is closed by the tag "'+tags[1].value+'"',openingtag:tags[0].value,closingtag:tags[1].value};throw err}function getOpenCountChange(part){switch(part.location){case"start":return 1;case"end":return-1;default:throw new Error("Location should be one of 'start' or 'end' (given : "+part.location+")")}}function getPairs(traits){if(traits.length===0){return[]}var countOpen=1;var firstTrait=traits[0];for(var i=1;i<traits.length;i++){var currentTrait=traits[i];countOpen+=getOpenCountChange(currentTrait.part);if(countOpen===0){if(currentTrait.part.value!==firstTrait.part.value&&currentTrait.part.value!==""){throwClosingTagNotMatchOpeningTag({tags:[firstTrait.part,currentTrait.part]})}var outer=getPairs(traits.slice(i+1));return[[firstTrait,currentTrait]].concat(outer)}}var part=firstTrait.part;throwUnmatchedLoopException({part:part,location:part.location})}var expandPairTrait={name:"ExpandPairTrait",postparse:function postparse(parsed,_ref){var getTraits=_ref.getTraits,_postparse=_ref.postparse;var traits=getTraits(traitName,parsed);traits=traits.map(function(trait){return trait||[]});traits=mergeSort(traits);var pairs=getPairs(traits);var expandedPairs=pairs.map(function(pair){var expandTo=pair[0].part.expandTo;if(expandTo==="auto"){expandTo=getExpandToDefault(parsed.slice(pair[0].offset,pair[1].offset))}if(!expandTo){return[pair[0].offset,pair[1].offset]}var left=DocUtils.getLeft(parsed,expandTo,pair[0].offset);var right=DocUtils.getRight(parsed,expandTo,pair[1].offset);return[left,right]});var currentPairIndex=0;var innerParts=void 0;return parsed.reduce(function(newParsed,part,i){var inPair=currentPairIndex<pairs.length&&expandedPairs[currentPairIndex][0]<=i;var pair=pairs[currentPairIndex];var expandedPair=expandedPairs[currentPairIndex];if(!inPair){newParsed.push(part);return newParsed}if(expandedPair[0]===i){innerParts=[]}if(pair[0].offset!==i&&pair[1].offset!==i){innerParts.push(part)}if(expandedPair[1]===i){var basePart=parsed[pair[0].offset];delete basePart.location;delete basePart.expandTo;basePart.subparsed=_postparse(innerParts);newParsed.push(basePart);currentPairIndex++}return newParsed},[])}};module.exports=function(){return wrapper(expandPairTrait)}},{"../doc-utils":1,"../errors":2,"../mergesort":6,"../module-wrapper":7,"../traits":16}],9:[function(require,module,exports){"use strict";var DocUtils=require("../doc-utils");var dashInnerRegex=/^-([^\s]+)\s(.+)$/;var wrapper=require("../module-wrapper");var moduleName="loop";var loopModule={name:"LoopModule",parse:function parse(placeHolderContent){var module=moduleName;var type="placeholder";if(placeHolderContent[0]==="#"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:false}}if(placeHolderContent[0]==="^"){return{type:type,value:placeHolderContent.substr(1),expandTo:"auto",module:module,location:"start",inverted:true}}if(placeHolderContent[0]==="/"){return{type:type,value:placeHolderContent.substr(1),module:module,location:"end"}}if(placeHolderContent[0]==="-"){var value=placeHolderContent.replace(dashInnerRegex,"$2");var expandTo=placeHolderContent.replace(dashInnerRegex,"$1");return{type:type,value:value,expandTo:expandTo,module:module,location:"start",inverted:false}}return null},getTraits:function getTraits(traitName,parsed){if(traitName!=="expandPair"){return}return parsed.reduce(function(tags,part,offset){if(part.type==="placeholder"&&part.module===moduleName){tags.push({part:part,offset:offset})}return tags},[])},render:function render(part,options){if(!part.type==="placeholder"||part.module!==moduleName){return null}var totalValue=[];function loopOver(scope){var scopeManager=options.scopeManager.createSubScopeManager(scope,part.value);totalValue.push(options.render(DocUtils.mergeObjects({},options,{compiled:part.subparsed,tags:{},scopeManager:scopeManager})))}options.scopeManager.loopOver(part.value,loopOver,part.inverted);return{value:totalValue.join("")}}};module.exports=function(){return wrapper(loopModule)}},{"../doc-utils":1,"../module-wrapper":7}],10:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("../doc-utils");var Errors=require("../errors");var moduleName="rawxml";var wrapper=require("../module-wrapper");function throwRawTagShouldBeOnlyTextInParagraph(options){var err=new Errors.XTTemplateError("Raw tag should be the only text in paragraph");var tag=options.part.value;err.properties={id:"raw_xml_tag_should_be_only_text_in_paragraph",explanation:"The tag "+tag,xtag:options.part.value,paragraphParts:options.paragraphParts};throw err}function getInner(_ref){var part=_ref.part,left=_ref.left,right=_ref.right,postparsed=_ref.postparsed,index=_ref.index;var paragraphParts=postparsed.slice(left+1,right);paragraphParts.forEach(function(p,i){if(i===index-left-1){return}if(p.type==="placeholder"||p.type==="content"&&p.position==="insidetag"){throwRawTagShouldBeOnlyTextInParagraph({paragraphParts:paragraphParts,part:part})}});return part}var RawXmlModule=function(){function RawXmlModule(){_classCallCheck(this,RawXmlModule);this.name="RawXmlModule"}_createClass(RawXmlModule,[{key:"optionsTransformer",value:function optionsTransformer(options,docxtemplater){this.fileTypeConfig=docxtemplater.fileTypeConfig;return options}},{key:"parse",value:function parse(placeHolderContent){var type="placeholder";if(placeHolderContent[0]!=="@"){return null}return{type:type,value:placeHolderContent.substr(1),module:moduleName}}},{key:"postparse",value:function postparse(parsed){return DocUtils.traits.expandToOne(parsed,{moduleName:moduleName,getInner:getInner,expandTo:this.fileTypeConfig.tagRawXml})}},{key:"render",value:function render(part,options){if(part.module!==moduleName){return null}var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return{value:value}}}]);return RawXmlModule}();module.exports=function(){return wrapper(new RawXmlModule)}},{"../doc-utils":1,"../errors":2,"../module-wrapper":7}],11:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var wrapper=require("../module-wrapper");var Render=function(){function Render(){_classCallCheck(this,Render);this.name="Render"}_createClass(Render,[{key:"set",value:function set(obj){if(obj.compiled){this.compiled=obj.compiled}if(obj.data!=null){this.data=obj.data}}},{key:"getRenderedMap",value:function getRenderedMap(mapper){var _this=this;return Object.keys(this.compiled).reduce(function(mapper,from){mapper[from]={from:from,data:_this.data};return mapper},mapper)}}]);return Render}();module.exports=function(){return wrapper(new Render)}},{"../module-wrapper":7}],12:[function(require,module,exports){"use strict";var wrapper=require("../module-wrapper");var spacePreserve={name:"SpacePreserveModule",postparse:function postparse(parsed){var chunk=[];var inChunk=false;var result=parsed.reduce(function(parsed,part){if(part.type==="tag"&&part.position==="start"&&part.text&&part.value==="<w:t>"){inChunk=true}if(inChunk){if(part.type==="placeholder"&&!part.module){chunk[0].value='<w:t xml:space="preserve">'}chunk.push(part)}else{parsed.push(part)}if(part.type==="tag"&&part.position==="end"&&part.text&&part.value==="</w:t>"){Array.prototype.push.apply(parsed,chunk);inChunk=false;chunk=[]}return parsed},[]);Array.prototype.push.apply(result,chunk);return result}};module.exports=function(){return wrapper(spacePreserve)}},{"../module-wrapper":7}],13:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var parser={postparse:function postparse(parsed,modules){function getTraits(traitName,parsed){return modules.map(function(module){return module.getTraits(traitName,parsed)})}function postparse(parsed){return modules.reduce(function(parsed,module){return module.postparse(parsed,{postparse:postparse,getTraits:getTraits})},parsed)}return postparse(parsed)},parse:function parse(lexed,modules){function moduleParse(placeHolderContent,parsed){var moduleParsed=void 0;for(var i=0,l=modules.length;i<l;i++){var _module=modules[i];moduleParsed=_module.parse(placeHolderContent);if(moduleParsed){parsed.push(moduleParsed);return moduleParsed}}return null}var inPlaceHolder=false;var placeHolderContent=void 0;var tailParts=[];return lexed.reduce(function(parsed,token){if(token.type==="delimiter"){inPlaceHolder=token.position==="start";if(token.position==="end"){placeHolderContent=DocUtils.wordToUtf8(placeHolderContent);if(!moduleParse(placeHolderContent,parsed)){parsed.push({type:"placeholder",value:placeHolderContent})}Array.prototype.push.apply(parsed,tailParts);tailParts=[];return parsed}placeHolderContent="";return parsed}if(inPlaceHolder){if(token.type==="content"&&token.position==="insidetag"){placeHolderContent+=token.value}else{tailParts.push(token)}return parsed}parsed.push(token);return parsed},[])}};module.exports=parser},{"./doc-utils":1}],14:[function(require,module,exports){"use strict";var ScopeManager=require("./scope-manager");var DocUtils=require("./doc-utils");function moduleRender(part,options){var moduleRendered=void 0;for(var i=0,l=options.modules.length;i<l;i++){var _module=options.modules[i];moduleRendered=_module.render(part,options);if(moduleRendered){return moduleRendered}}return false}function render(options){options.render=render;options.modules=options.modules;if(!options.scopeManager){options.scopeManager=ScopeManager.createBaseScopeManager(options)}return options.compiled.map(function(part){var moduleRendered=moduleRender(part,options);if(moduleRendered){return moduleRendered.value}if(part.type==="placeholder"){var value=options.scopeManager.getValue(part.value);if(value==null){value=options.nullGetter(part)}return DocUtils.utf8ToWord(value)}if(part.type==="content"||part.type==="tag"){return part.value}throw new Error('Unimplemented tag type "'+part.type+'"')}).join("")}module.exports=render},{"./doc-utils":1,"./scope-manager":15}],15:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var Errors=require("./errors");var ScopeManager=function(){function ScopeManager(options){_classCallCheck(this,ScopeManager);this.scopePath=options.scopePath;this.scopeList=options.scopeList;this.parser=options.parser}_createClass(ScopeManager,[{key:"loopOver",value:function loopOver(tag,callback,inverted){inverted=inverted||false;return this.loopOverValue(this.getValue(tag),callback,inverted)}},{key:"functorIfInverted",value:function functorIfInverted(inverted,functor,value){if(inverted){functor(value)}}},{key:"isValueFalsy",value:function isValueFalsy(value,type){return value==null||!value||type==="[object Array]"&&value.length===0}},{key:"loopOverValue",value:function loopOverValue(value,functor,inverted){var type=Object.prototype.toString.call(value);var currentValue=this.scopeList[this.num];if(this.isValueFalsy(value,type)){return this.functorIfInverted(inverted,functor,currentValue)}if(type==="[object Array]"){for(var i=0,scope;i<value.length;i++){scope=value[i];this.functorIfInverted(!inverted,functor,scope)}return}if(type==="[object Object]"){return this.functorIfInverted(!inverted,functor,value)}if(value===true){return this.functorIfInverted(!inverted,functor,currentValue)}}},{key:"getValue",value:function getValue(tag,num){this.num=num==null?this.scopeList.length-1:num;var err=void 0;var parser=void 0;var result=void 0;var scope=this.scopeList[this.num];try{parser=this.parser(tag)}catch(error){err=new Errors.XTScopeParserError("Scope parser compilation failed");err.properties={id:"scopeparser_compilation_failed",tag:tag,explanation:"The scope parser for the tag "+tag+" failed to compile",rootError:error};throw err}try{result=parser.get(scope,{num:this.num,scopeList:this.scopeList})}catch(error){err=new Errors.XTScopeParserError("Scope parser execution failed");err.properties={id:"scopeparser_execution_failed",explanation:"The scope parser for the tag "+tag+" failed to execute",scope:scope,tag:tag,rootError:error};throw err}if(result==null&&this.num>0){return this.getValue(tag,this.num-1)}return result}},{key:"createSubScopeManager",value:function createSubScopeManager(scope,tag){var options={scopePath:this.scopePath.slice(0),scopeList:this.scopeList.slice(0)};options.parser=this.parser;options.scopeList=this.scopeList.concat(scope);options.scopePath=this.scopePath.concat(tag);return new ScopeManager(options)}}]);return ScopeManager}();ScopeManager.createBaseScopeManager=function(_ref){var parser=_ref.parser,tags=_ref.tags;var options={parser:parser,tags:tags};options.scopePath=[];options.scopeList=[tags];return new ScopeManager(options)};module.exports=ScopeManager},{"./errors":2}],16:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var Errors=require("./errors");function throwRawTagNotInParagraph(options){var err=new Errors.XTTemplateError("Raw tag not in paragraph");var tag=options.part.value;err.properties={id:"raw_tag_outerxml_invalid",explanation:'The tag "'+tag+'"',rootError:options.rootError,xtag:tag,postparsed:options.postparsed,expandTo:options.expandTo,index:options.index};throw err}function lastTagIsOpenTag(array,tag){if(array.length===0){return false}var lastTag=array[array.length-1];var innerLastTag=lastTag.tag.substr(1);var innerCurrentTag=tag.substr(2,tag.length-3);return innerLastTag.indexOf(innerCurrentTag)===0}function addTag(array,tag){array.push({tag:tag});return array}function getListXmlElements(parts){var tags=parts.filter(function(part){return part.type==="tag"}).map(function(part){return part.value});var result=[];for(var i=0,tag;i<tags.length;i++){tag=tags[i];if(tag[1]==="/"){if(lastTagIsOpenTag(result,tag)){result.pop()}else{result=addTag(result,tag)}}else if(tag[tag.length-1]!=="/"){result=addTag(result,tag)}}return result}function getExpandToDefault(parts){var xmlElements=getListXmlElements(parts);for(var i=0;i<xmlElements.length;i++){var xmlElement=xmlElements[i];if(xmlElement.tag.indexOf("<w:tc")===0){return"w:tr"}if(xmlElement.tag.indexOf("<a:tc")===0){return"a:tr"}}return false}function expandOne(part,postparsed,options){var expandTo=part.expandTo||options.expandTo;var index=postparsed.indexOf(part);if(!expandTo){return postparsed}var right=void 0,left=void 0;try{right=DocUtils.getRight(postparsed,expandTo,index);left=DocUtils.getLeft(postparsed,expandTo,index)}catch(rootError){if(rootError instanceof Errors.XTTemplateError){throwRawTagNotInParagraph({part:part,rootError:rootError,postparsed:postparsed,expandTo:expandTo,index:index})}throw rootError}var leftParts=postparsed.slice(left,index);var rightParts=postparsed.slice(index+1,right+1);var inner=options.getInner({index:index,part:part,leftParts:leftParts,rightParts:rightParts,left:left,right:right,postparsed:postparsed});if(!inner.length){inner.expanded=[leftParts,rightParts];inner=[inner]}return DocUtils.concatArrays([postparsed.slice(0,left),inner,postparsed.slice(right+1)])}function expandToOne(postparsed,options){var expandToElements=postparsed.reduce(function(elements,part){if(part.type==="placeholder"&&part.module===options.moduleName){elements.push(part)}return elements},[]);expandToElements.forEach(function(part){postparsed=expandOne(part,postparsed,options)});return postparsed}module.exports={expandToOne:expandToOne,getExpandToDefault:getExpandToDefault}},{"./doc-utils":1,"./errors":2}],17:[function(require,module,exports){"use strict";var DocUtils=require("./doc-utils");var memoize=require("./memoize");function handleRecursiveCase(res){function replacerUnshift(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.shift();var match=pn.array[0]+pn.array[1];pn.array.unshift(match);pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.first=true;res.matches.unshift(pn);res.charactersAdded.unshift(0);return res.charactersAddedCumulative.unshift(0)}if(res.content.indexOf("<")===-1&&res.content.indexOf(">")===-1){res.content.replace(/^()([^<>]*)$/,replacerUnshift)}var r=new RegExp("^()([^<]+)</(?:"+res.tagsXmlArrayJoined+")>");res.content.replace(r,replacerUnshift);function replacerPush(){var pn={array:Array.prototype.slice.call(arguments)};pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.last=true;res.matches.push(pn);res.charactersAdded.push(0);return res.charactersAddedCumulative.push(0)}r=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^>]+)$");res.content.replace(r,replacerPush);return res}function xmlMatcher(content,tagsXmlArray){var res={};res.content=content;res.tagsXmlArray=tagsXmlArray;res.tagsXmlArrayJoined=res.tagsXmlArray.join("|");var regexp=new RegExp("(<(?:"+res.tagsXmlArrayJoined+")[^>]*>)([^<>]*)</(?:"+res.tagsXmlArrayJoined+")>","g");res.matches=DocUtils.pregMatchAll(regexp,res.content);res.charactersAddedCumulative=res.matches.map(function(){return 0});res.charactersAdded=res.matches.map(function(){return 0});return handleRecursiveCase(res)}var memoized=memoize(xmlMatcher);module.exports=function(content,tagsXmlArray){return DocUtils.cloneDeep(memoized(content,tagsXmlArray))}},{"./doc-utils":1,"./memoize":5}],18:[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");var ScopeManager=require("./scope-manager");var xmlMatcher=require("./xml-matcher");var Errors=require("./errors");var Lexer=require("./lexer");var Parser=require("./parser.js");var _render=require("./render.js");function _getFullText(content,tagsXmlArray){var matcher=xmlMatcher(content,tagsXmlArray);var result=matcher.matches.map(function(match){return match.array[2]});return DocUtils.wordToUtf8(DocUtils.convertSpaces(result.join("")))}module.exports=function(){function XmlTemplater(content,options){_classCallCheck(this,XmlTemplater);this.fromJson(options);this.setModules({inspect:{filePath:this.filePath}});this.load(content)}_createClass(XmlTemplater,[{key:"load",value:function load(content){if(typeof content!=="string"){var err=new Errors.XTInternalError("Content must be a string");err.properties.id="xmltemplater_content_must_be_string";throw err}this.content=content}},{key:"setTags",value:function setTags(tags){this.tags=tags!=null?tags:{};this.scopeManager=ScopeManager.createBaseScopeManager({tags:this.tags,parser:this.parser});return this}},{key:"fromJson",value:function fromJson(options){this.filePath=options.filePath;this.modules=options.modules;this.fileTypeConfig=options.fileTypeConfig;Object.keys(DocUtils.defaults).map(function(key){this[key]=options[key]!=null?options[key]:DocUtils.defaults[key]},this)}},{key:"getFullText",value:function getFullText(){return _getFullText(this.content,this.fileTypeConfig.tagsXmlTextArray)}},{key:"setModules",value:function setModules(obj){this.modules.forEach(function(module){module.set(obj)})}},{key:"parse",value:function parse(){this.xmllexed=Lexer.xmlparse(this.content,{text:this.fileTypeConfig.tagsXmlTextArray,other:this.fileTypeConfig.tagsXmlLexedArray});this.setModules({inspect:{xmllexed:this.xmllexed}});this.lexed=Lexer.parse(this.xmllexed,this.delimiters);this.setModules({inspect:{lexed:this.lexed}});this.parsed=Parser.parse(this.lexed,this.modules);this.setModules({inspect:{parsed:this.parsed}});this.postparsed=Parser.postparse(this.parsed,this.modules);return this}},{key:"render",value:function render(to){this.filePath=to;this.setModules({inspect:{postparsed:this.postparsed}});this.content=_render({compiled:this.postparsed,tags:this.tags,modules:this.modules,parser:this.parser,nullGetter:this.nullGetter,filePath:this.filePath});this.setModules({inspect:{content:this.content}});return this}}]);return XmlTemplater}()},{"./doc-utils":1,"./errors":2,"./lexer":4,"./parser.js":13,"./render.js":14,"./scope-manager":15,"./xml-matcher":17}],19:[function(require,module,exports){function DOMParser(options){this.options=options||{locator:{}}}DOMParser.prototype.parseFromString=function(source,mimeType){var options=this.options;var sax=new XMLReader;var domBuilder=options.domBuilder||new DOMHandler;var errorHandler=options.errorHandler;var locator=options.locator;var defaultNSMap=options.xmlns||{};var entityMap={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"};if(locator){domBuilder.setDocumentLocator(locator)}sax.errorHandler=buildErrorHandler(errorHandler,domBuilder,locator);sax.domBuilder=options.domBuilder||domBuilder;if(/\/x?html?$/.test(mimeType)){entityMap.nbsp=" ";entityMap.copy="©";defaultNSMap[""]="http://www.w3.org/1999/xhtml"}defaultNSMap.xml=defaultNSMap.xml||"http://www.w3.org/XML/1998/namespace";if(source){sax.parse(source,defaultNSMap,entityMap)}else{sax.errorHandler.error("invalid doc source")}return domBuilder.doc};function buildErrorHandler(errorImpl,domBuilder,locator){if(!errorImpl){if(domBuilder instanceof DOMHandler){return domBuilder}errorImpl=domBuilder}var errorHandler={};var isCallback=errorImpl instanceof Function;locator=locator||{};function build(key){var fn=errorImpl[key];if(!fn&&isCallback){fn=errorImpl.length==2?function(msg){errorImpl(key,msg)}:errorImpl}errorHandler[key]=fn&&function(msg){fn("[xmldom "+key+"]\t"+msg+_locator(locator))}||function(){}}build("warning");build("error");build("fatalError");return errorHandler}function DOMHandler(){this.cdata=false}function position(locator,node){node.lineNumber=locator.lineNumber;node.columnNumber=locator.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=(new DOMImplementation).createDocument(null,null,null);if(this.locator){this.doc.documentURI=this.locator.systemId}},startElement:function(namespaceURI,localName,qName,attrs){var doc=this.doc;var el=doc.createElementNS(namespaceURI,qName||localName);var len=attrs.length;appendElement(this,el);this.currentElement=el;this.locator&&position(this.locator,el);for(var i=0;i<len;i++){var namespaceURI=attrs.getURI(i);var value=attrs.getValue(i);var qName=attrs.getQName(i);var attr=doc.createAttributeNS(namespaceURI,qName);this.locator&&position(attrs.getLocator(i),attr);attr.value=attr.nodeValue=value;el.setAttributeNode(attr)}},endElement:function(namespaceURI,localName,qName){var current=this.currentElement;var tagName=current.tagName;this.currentElement=current.parentNode},startPrefixMapping:function(prefix,uri){},endPrefixMapping:function(prefix){},processingInstruction:function(target,data){var ins=this.doc.createProcessingInstruction(target,data);this.locator&&position(this.locator,ins);appendElement(this,ins)},ignorableWhitespace:function(ch,start,length){},characters:function(chars,start,length){chars=_toString.apply(this,arguments);if(chars){if(this.cdata){var charNode=this.doc.createCDATASection(chars)}else{var charNode=this.doc.createTextNode(chars)}if(this.currentElement){this.currentElement.appendChild(charNode)}else if(/^\s*$/.test(chars)){this.doc.appendChild(charNode)}this.locator&&position(this.locator,charNode)}},skippedEntity:function(name){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(locator){if(this.locator=locator){locator.lineNumber=0}},comment:function(chars,start,length){chars=_toString.apply(this,arguments);var comm=this.doc.createComment(chars);this.locator&&position(this.locator,comm);appendElement(this,comm)},startCDATA:function(){this.cdata=true},endCDATA:function(){this.cdata=false},startDTD:function(name,publicId,systemId){var impl=this.doc.implementation;if(impl&&impl.createDocumentType){var dt=impl.createDocumentType(name,publicId,systemId);this.locator&&position(this.locator,dt);appendElement(this,dt)}},warning:function(error){console.warn("[xmldom warning]\t"+error,_locator(this.locator))},error:function(error){console.error("[xmldom error]\t"+error,_locator(this.locator))},fatalError:function(error){console.error("[xmldom fatalError]\t"+error,_locator(this.locator));throw error}};function _locator(l){if(l){return"\n@"+(l.systemId||"")+"#[line:"+l.lineNumber+",col:"+l.columnNumber+"]"}}function _toString(chars,start,length){if(typeof chars=="string"){return chars.substr(start,length)}else{if(chars.length>=start+length||start){return new java.lang.String(chars,start,length)+""}return chars}}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){DOMHandler.prototype[key]=function(){return null}});function appendElement(hander,node){if(!hander.currentElement){hander.doc.appendChild(node)}else{hander.currentElement.appendChild(node)}}var XMLReader=require("./sax").XMLReader;var DOMImplementation=exports.DOMImplementation=require("./dom").DOMImplementation;exports.XMLSerializer=require("./dom").XMLSerializer;exports.DOMParser=DOMParser},{"./dom":20,"./sax":21}],20:[function(require,module,exports){function copy(src,dest){for(var p in src){dest[p]=src[p]}}function _extends(Class,Super){var pt=Class.prototype;if(Object.create){var ppt=Object.create(Super.prototype);pt.__proto__=ppt}if(!(pt instanceof Super)){function t(){}t.prototype=Super.prototype;t=new t;copy(pt,t);Class.prototype=pt=t}if(pt.constructor!=Class){if(typeof Class!="function"){console.error("unknow Class:"+Class)}pt.constructor=Class}}var htmlns="http://www.w3.org/1999/xhtml";var NodeType={};var ELEMENT_NODE=NodeType.ELEMENT_NODE=1;var ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2;var TEXT_NODE=NodeType.TEXT_NODE=3;var CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4;var ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5;var ENTITY_NODE=NodeType.ENTITY_NODE=6;var PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7;var COMMENT_NODE=NodeType.COMMENT_NODE=8;var DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9;var DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10;var DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11;var NOTATION_NODE=NodeType.NOTATION_NODE=12;var ExceptionCode={};var ExceptionMessage={};var INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1);var DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2);var HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3);var WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4);var INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5);var NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6);var NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7);var NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8);var NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9);var INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10);var INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11);var SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12);var INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13);var NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14);var INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(code,message){if(message instanceof Error){var error=message}else{error=this;Error.call(this,ExceptionMessage[code]);this.message=ExceptionMessage[code];if(Error.captureStackTrace)Error.captureStackTrace(this,DOMException)}error.code=code;if(message)this.message=this.message+": "+message;return error}DOMException.prototype=Error.prototype;copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(index){return this[index]||null},toString:function(isHTML,nodeFilter){for(var buf=[],i=0;i<this.length;i++){serializeToString(this[i],buf,isHTML,nodeFilter)}return buf.join("")}};function LiveNodeList(node,refresh){this._node=node;this._refresh=refresh;_updateLiveList(this)}function _updateLiveList(list){var inc=list._node._inc||list._node.ownerDocument._inc;if(list._inc!=inc){var ls=list._refresh(list._node);__set__(list,"length",ls.length);copy(ls,list);list._inc=inc}}LiveNodeList.prototype.item=function(i){_updateLiveList(this);return this[i]};_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(list,node){var i=list.length;while(i--){if(list[i]===node){return i}}}function _addNamedNode(el,list,newAttr,oldAttr){if(oldAttr){list[_findNodeIndex(list,oldAttr)]=newAttr}else{list[list.length++]=newAttr}if(el){newAttr.ownerElement=el;var doc=el.ownerDocument;if(doc){oldAttr&&_onRemoveAttribute(doc,el,oldAttr);_onAddAttribute(doc,el,newAttr)}}}function _removeNamedNode(el,list,attr){var i=_findNodeIndex(list,attr);if(i>=0){var lastIndex=list.length-1;while(i<lastIndex){list[i]=list[++i]}list.length=lastIndex;if(el){var doc=el.ownerDocument;if(doc){_onRemoveAttribute(doc,el,attr);attr.ownerElement=null}}}else{throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+"@"+attr))}}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(key){var i=this.length;while(i--){var attr=this[i];if(attr.nodeName==key){return attr}}},setNamedItem:function(attr){var el=attr.ownerElement;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}var oldAttr=this.getNamedItem(attr.nodeName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},setNamedItemNS:function(attr){var el=attr.ownerElement,oldAttr;if(el&&el!=this._ownerElement){throw new DOMException(INUSE_ATTRIBUTE_ERR)}oldAttr=this.getNamedItemNS(attr.namespaceURI,attr.localName);_addNamedNode(this._ownerElement,this,attr,oldAttr);return oldAttr},removeNamedItem:function(key){var attr=this.getNamedItem(key);_removeNamedNode(this._ownerElement,this,attr);return attr},removeNamedItemNS:function(namespaceURI,localName){var attr=this.getNamedItemNS(namespaceURI,localName);_removeNamedNode(this._ownerElement,this,attr);return attr},getNamedItemNS:function(namespaceURI,localName){var i=this.length;while(i--){var node=this[i];if(node.localName==localName&&node.namespaceURI==namespaceURI){return node}}return null}};function DOMImplementation(features){this._features={};if(features){for(var feature in features){this._features=features[feature]}}}DOMImplementation.prototype={hasFeature:function(feature,version){var versions=this._features[feature.toLowerCase()];if(versions&&(!version||version in versions)){return true}else{return false}},createDocument:function(namespaceURI,qualifiedName,doctype){var doc=new Document;doc.implementation=this;doc.childNodes=new NodeList;doc.doctype=doctype;if(doctype){doc.appendChild(doctype)}if(qualifiedName){var root=doc.createElementNS(namespaceURI,qualifiedName);doc.appendChild(root)}return doc},createDocumentType:function(qualifiedName,publicId,systemId){var node=new DocumentType;node.name=qualifiedName;node.nodeName=qualifiedName;node.publicId=publicId;node.systemId=systemId;return node}};function Node(){}Node.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(newChild,refChild){return _insertBefore(this,newChild,refChild)},replaceChild:function(newChild,oldChild){this.insertBefore(newChild,oldChild);if(oldChild){this.removeChild(oldChild)}},removeChild:function(oldChild){return _removeChild(this,oldChild)},appendChild:function(newChild){return this.insertBefore(newChild,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(deep){return cloneNode(this.ownerDocument||this,this,deep)},normalize:function(){var child=this.firstChild;while(child){var next=child.nextSibling;if(next&&next.nodeType==TEXT_NODE&&child.nodeType==TEXT_NODE){this.removeChild(next);child.appendData(next.data)}else{child.normalize();child=next}}},isSupported:function(feature,version){return this.ownerDocument.implementation.hasFeature(feature,version)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(namespaceURI){var el=this;while(el){var map=el._nsMap;if(map){for(var n in map){if(map[n]==namespaceURI){return n}}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},lookupNamespaceURI:function(prefix){var el=this;while(el){var map=el._nsMap;if(map){if(prefix in map){return map[prefix]}}el=el.nodeType==ATTRIBUTE_NODE?el.ownerDocument:el.parentNode}return null},isDefaultNamespace:function(namespaceURI){var prefix=this.lookupPrefix(namespaceURI);return prefix==null}};function _xmlEncoder(c){return c=="<"&&"&lt;"||c==">"&&"&gt;"||c=="&"&&"&amp;"||c=='"'&&"&quot;"||"&#"+c.charCodeAt()+";"}copy(NodeType,Node);copy(NodeType,Node.prototype);function _visitNode(node,callback){if(callback(node)){return true}if(node=node.firstChild){do{if(_visitNode(node,callback)){return true}}while(node=node.nextSibling)}}function Document(){}function _onAddAttribute(doc,el,newAttr){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){el._nsMap[newAttr.prefix?newAttr.localName:""]=newAttr.value}}function _onRemoveAttribute(doc,el,newAttr,remove){doc&&doc._inc++;var ns=newAttr.namespaceURI;if(ns=="http://www.w3.org/2000/xmlns/"){delete el._nsMap[newAttr.prefix?newAttr.localName:""]}}function _onUpdateChild(doc,el,newChild){if(doc&&doc._inc){doc._inc++;var cs=el.childNodes;if(newChild){cs[cs.length++]=newChild}else{var child=el.firstChild;var i=0;while(child){cs[i++]=child;child=child.nextSibling}cs.length=i}}}function _removeChild(parentNode,child){var previous=child.previousSibling;var next=child.nextSibling;if(previous){previous.nextSibling=next}else{parentNode.firstChild=next}if(next){next.previousSibling=previous}else{parentNode.lastChild=previous}_onUpdateChild(parentNode.ownerDocument,parentNode);return child}function _insertBefore(parentNode,newChild,nextChild){var cp=newChild.parentNode;if(cp){cp.removeChild(newChild)}if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){var newFirst=newChild.firstChild;if(newFirst==null){return newChild}var newLast=newChild.lastChild}else{newFirst=newLast=newChild}var pre=nextChild?nextChild.previousSibling:parentNode.lastChild;newFirst.previousSibling=pre;newLast.nextSibling=nextChild;if(pre){pre.nextSibling=newFirst}else{parentNode.firstChild=newFirst}if(nextChild==null){parentNode.lastChild=newLast}else{nextChild.previousSibling=newLast}do{newFirst.parentNode=parentNode}while(newFirst!==newLast&&(newFirst=newFirst.nextSibling));_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){newChild.firstChild=newChild.lastChild=null}return newChild}function _appendSingleChild(parentNode,newChild){var cp=newChild.parentNode;if(cp){var pre=parentNode.lastChild;cp.removeChild(newChild);var pre=parentNode.lastChild}var pre=parentNode.lastChild;newChild.parentNode=parentNode;newChild.previousSibling=pre;newChild.nextSibling=null;if(pre){pre.nextSibling=newChild}else{parentNode.firstChild=newChild}parentNode.lastChild=newChild;_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);return newChild}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(newChild,refChild){if(newChild.nodeType==DOCUMENT_FRAGMENT_NODE){var child=newChild.firstChild;while(child){var next=child.nextSibling;this.insertBefore(child,refChild);child=next}return newChild}if(this.documentElement==null&&newChild.nodeType==ELEMENT_NODE){this.documentElement=newChild}return _insertBefore(this,newChild,refChild),newChild.ownerDocument=this,newChild},removeChild:function(oldChild){if(this.documentElement==oldChild){this.documentElement=null}return _removeChild(this,oldChild)},importNode:function(importedNode,deep){return importNode(this,importedNode,deep)},getElementById:function(id){var rtv=null;_visitNode(this.documentElement,function(node){if(node.nodeType==ELEMENT_NODE){if(node.getAttribute("id")==id){rtv=node;return true}}});return rtv},createElement:function(tagName){var node=new Element;node.ownerDocument=this;node.nodeName=tagName;node.tagName=tagName;node.childNodes=new NodeList;var attrs=node.attributes=new NamedNodeMap;attrs._ownerElement=node;return node},createDocumentFragment:function(){var node=new DocumentFragment;node.ownerDocument=this;node.childNodes=new NodeList;return node},createTextNode:function(data){var node=new Text;node.ownerDocument=this;node.appendData(data);return node},createComment:function(data){var node=new Comment;node.ownerDocument=this;node.appendData(data);return node},createCDATASection:function(data){var node=new CDATASection;node.ownerDocument=this;node.appendData(data);return node},createProcessingInstruction:function(target,data){var node=new ProcessingInstruction;node.ownerDocument=this;node.tagName=node.target=target;node.nodeValue=node.data=data;return node},createAttribute:function(name){var node=new Attr;node.ownerDocument=this;node.name=name;node.nodeName=name;node.localName=name;node.specified=true;return node},createEntityReference:function(name){var node=new EntityReference;node.ownerDocument=this;node.nodeName=name;return node},createElementNS:function(namespaceURI,qualifiedName){var node=new Element;var pl=qualifiedName.split(":");var attrs=node.attributes=new NamedNodeMap;node.childNodes=new NodeList;node.ownerDocument=this;node.nodeName=qualifiedName;node.tagName=qualifiedName;node.namespaceURI=namespaceURI;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}attrs._ownerElement=node;return node},createAttributeNS:function(namespaceURI,qualifiedName){var node=new Attr;var pl=qualifiedName.split(":");node.ownerDocument=this;node.nodeName=qualifiedName;node.name=qualifiedName;node.namespaceURI=namespaceURI;node.specified=true;if(pl.length==2){node.prefix=pl[0];node.localName=pl[1]}else{node.localName=qualifiedName}return node}};_extends(Document,Node);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(name){return this.getAttributeNode(name)!=null},getAttribute:function(name){var attr=this.getAttributeNode(name);return attr&&attr.value||""},getAttributeNode:function(name){return this.attributes.getNamedItem(name)},setAttribute:function(name,value){var attr=this.ownerDocument.createAttribute(name);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},removeAttribute:function(name){var attr=this.getAttributeNode(name);attr&&this.removeAttributeNode(attr)},appendChild:function(newChild){if(newChild.nodeType===DOCUMENT_FRAGMENT_NODE){return this.insertBefore(newChild,null)}else{return _appendSingleChild(this,newChild)}},setAttributeNode:function(newAttr){return this.attributes.setNamedItem(newAttr)},setAttributeNodeNS:function(newAttr){return this.attributes.setNamedItemNS(newAttr)},removeAttributeNode:function(oldAttr){return this.attributes.removeNamedItem(oldAttr.nodeName)},removeAttributeNS:function(namespaceURI,localName){var old=this.getAttributeNodeNS(namespaceURI,localName);old&&this.removeAttributeNode(old)},hasAttributeNS:function(namespaceURI,localName){return this.getAttributeNodeNS(namespaceURI,localName)!=null},getAttributeNS:function(namespaceURI,localName){var attr=this.getAttributeNodeNS(namespaceURI,localName);return attr&&attr.value||""},setAttributeNS:function(namespaceURI,qualifiedName,value){var attr=this.ownerDocument.createAttributeNS(namespaceURI,qualifiedName);attr.value=attr.nodeValue=""+value;this.setAttributeNode(attr)},getAttributeNodeNS:function(namespaceURI,localName){return this.attributes.getNamedItemNS(namespaceURI,localName)},getElementsByTagName:function(tagName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType==ELEMENT_NODE&&(tagName==="*"||node.tagName==tagName)){ls.push(node)}});return ls})},getElementsByTagNameNS:function(namespaceURI,localName){return new LiveNodeList(this,function(base){var ls=[];_visitNode(base,function(node){if(node!==base&&node.nodeType===ELEMENT_NODE&&(namespaceURI==="*"||node.namespaceURI===namespaceURI)&&(localName==="*"||node.localName==localName)){ls.push(node)}});return ls})}};Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName;Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS;_extends(Element,Node);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE;_extends(Attr,Node);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(offset,count){return this.data.substring(offset,offset+count)},appendData:function(text){text=this.data+text;this.nodeValue=this.data=text;this.length=text.length},insertData:function(offset,text){this.replaceData(offset,0,text)},appendChild:function(newChild){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(offset,count){this.replaceData(offset,count,"")},replaceData:function(offset,count,text){var start=this.data.substring(0,offset);var end=this.data.substring(offset+count);text=start+text+end;this.nodeValue=this.data=text;this.length=text.length}};_extends(CharacterData,Node);function Text(){}Text.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(offset){var text=this.data;var newText=text.substring(offset);text=text.substring(0,offset);this.data=this.nodeValue=text;this.length=text.length;var newNode=this.ownerDocument.createTextNode(newText);if(this.parentNode){this.parentNode.insertBefore(newNode,this.nextSibling)}return newNode}};_extends(Text,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE};_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE};_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE;_extends(DocumentType,Node);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE;_extends(Notation,Node);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE;_extends(Entity,Node);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE;_extends(EntityReference,Node);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment";DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE;_extends(DocumentFragment,Node);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE;_extends(ProcessingInstruction,Node);function XMLSerializer(){}XMLSerializer.prototype.serializeToString=function(node,isHtml,nodeFilter){return nodeSerializeToString.call(node,isHtml,nodeFilter)};Node.prototype.toString=nodeSerializeToString;function nodeSerializeToString(isHtml,nodeFilter){var buf=[];var refNode=this.nodeType==9?this.documentElement:this;var prefix=refNode.prefix;var uri=refNode.namespaceURI;if(uri&&prefix==null){var prefix=refNode.lookupPrefix(uri);if(prefix==null){var visibleNamespaces=[{namespace:uri,prefix:null}]}}serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);return buf.join("")}function needNamespaceDefine(node,isHTML,visibleNamespaces){var prefix=node.prefix||"";var uri=node.namespaceURI;if(!prefix&&!uri){return false}if(prefix==="xml"&&uri==="http://www.w3.org/XML/1998/namespace"||uri=="http://www.w3.org/2000/xmlns/"){return false}var i=visibleNamespaces.length;while(i--){var ns=visibleNamespaces[i];if(ns.prefix==prefix){return ns.namespace!=uri}}return true}function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){if(nodeFilter){node=nodeFilter(node);if(node){if(typeof node=="string"){buf.push(node);return}}else{return}}switch(node.nodeType){case ELEMENT_NODE:if(!visibleNamespaces)visibleNamespaces=[];var startVisibleNamespaces=visibleNamespaces.length;var attrs=node.attributes;var len=attrs.length;var child=node.firstChild;var nodeName=node.tagName;isHTML=htmlns===node.namespaceURI||isHTML;buf.push("<",nodeName);for(var i=0;i<len;i++){var attr=attrs.item(i);if(attr.prefix=="xmlns"){visibleNamespaces.push({prefix:attr.localName,namespace:attr.value})}else if(attr.nodeName=="xmlns"){visibleNamespaces.push({prefix:"",namespace:attr.value})}}for(var i=0;i<len;i++){var attr=attrs.item(i);if(needNamespaceDefine(attr,isHTML,visibleNamespaces)){var prefix=attr.prefix||"";var uri=attr.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces)}if(needNamespaceDefine(node,isHTML,visibleNamespaces)){var prefix=node.prefix||"";var uri=node.namespaceURI;var ns=prefix?" xmlns:"+prefix:" xmlns";buf.push(ns,'="',uri,'"');visibleNamespaces.push({prefix:prefix,namespace:uri})}if(child||isHTML&&!/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){buf.push(">");if(isHTML&&/^script$/i.test(nodeName)){while(child){if(child.data){buf.push(child.data)}else{serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces)}child=child.nextSibling}}else{while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}}buf.push("</",nodeName,">")}else{buf.push("/>")}return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var child=node.firstChild;while(child){serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);child=child.nextSibling}return;case ATTRIBUTE_NODE:return buf.push(" ",node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');case TEXT_NODE:return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));case CDATA_SECTION_NODE:return buf.push("<![CDATA[",node.data,"]]>");case COMMENT_NODE:return buf.push("\x3c!--",node.data,"--\x3e");case DOCUMENT_TYPE_NODE:var pubid=node.publicId;var sysid=node.systemId;buf.push("<!DOCTYPE ",node.name);if(pubid){buf.push(' PUBLIC "',pubid);if(sysid&&sysid!="."){buf.push('" "',sysid)}buf.push('">')}else if(sysid&&sysid!="."){buf.push(' SYSTEM "',sysid,'">')}else{var sub=node.internalSubset;if(sub){buf.push(" [",sub,"]")}buf.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return buf.push("<?",node.target," ",node.data,"?>");case ENTITY_REFERENCE_NODE:return buf.push("&",node.nodeName,";");default:buf.push("??",node.nodeName)}}function importNode(doc,node,deep){var node2;switch(node.nodeType){case ELEMENT_NODE:node2=node.cloneNode(false);node2.ownerDocument=doc;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:deep=true;break}if(!node2){node2=node.cloneNode(false)}node2.ownerDocument=doc;node2.parentNode=null;if(deep){var child=node.firstChild;while(child){node2.appendChild(importNode(doc,child,deep));child=child.nextSibling}}return node2}function cloneNode(doc,node,deep){var node2=new node.constructor;for(var n in node){var v=node[n];if(typeof v!="object"){if(v!=node2[n]){node2[n]=v}}}if(node.childNodes){node2.childNodes=new NodeList}node2.ownerDocument=doc;switch(node2.nodeType){case ELEMENT_NODE:var attrs=node.attributes;var attrs2=node2.attributes=new NamedNodeMap;var len=attrs.length;attrs2._ownerElement=node2;for(var i=0;i<len;i++){node2.setAttributeNode(cloneNode(doc,attrs.item(i),true))}break;case ATTRIBUTE_NODE:deep=true}if(deep){var child=node.firstChild;while(child){node2.appendChild(cloneNode(doc,child,deep));child=child.nextSibling}}return node2}function __set__(object,key,value){object[key]=value}try{if(Object.defineProperty){Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){_updateLiveList(this);return this.$$length}});Object.defineProperty(Node.prototype,"textContent",{get:function(){return getTextContent(this)},set:function(data){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:while(this.firstChild){this.removeChild(this.firstChild)}if(data||String(data)){this.appendChild(this.ownerDocument.createTextNode(data))}break;default:this.data=data;this.value=data;this.nodeValue=data}}});function getTextContent(node){switch(node.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var buf=[];node=node.firstChild;while(node){if(node.nodeType!==7&&node.nodeType!==8){buf.push(getTextContent(node))}node=node.nextSibling}return buf.join("");default:return node.nodeValue}}__set__=function(object,key,value){object["$$"+key]=value}}}catch(e){}exports.DOMImplementation=DOMImplementation;exports.XMLSerializer=XMLSerializer},{}],21:[function(require,module,exports){var nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;var nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");var tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$");var S_TAG=0;var S_ATTR=1;var S_ATTR_SPACE=2;var S_EQ=3;var S_ATTR_NOQUOT_VALUE=4;var S_ATTR_END=5;var S_TAG_SPACE=6;var S_TAG_CLOSE=7;function XMLReader(){}XMLReader.prototype={parse:function(source,defaultNSMap,entityMap){var domBuilder=this.domBuilder;domBuilder.startDocument();_copy(defaultNSMap,defaultNSMap={});parse(source,defaultNSMap,entityMap,domBuilder,this.errorHandler);domBuilder.endDocument()}};function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){function fixedFromCharCode(code){if(code>65535){code-=65536;var surrogate1=55296+(code>>10),surrogate2=56320+(code&1023);return String.fromCharCode(surrogate1,surrogate2)}else{return String.fromCharCode(code)}}function entityReplacer(a){var k=a.slice(1,-1);if(k in entityMap){return entityMap[k]}else if(k.charAt(0)==="#"){return fixedFromCharCode(parseInt(k.substr(1).replace("x","0x")))}else{errorHandler.error("entity not found:"+a);return a}}function appendText(end){if(end>start){var xt=source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);locator&&position(start);domBuilder.characters(xt,0,end-start);start=end}}function position(p,m){while(p>=lineEnd&&(m=linePattern.exec(source))){lineStart=m.index;lineEnd=lineStart+m[0].length;locator.lineNumber++}locator.columnNumber=p-lineStart+1}var lineStart=0;var lineEnd=0;var linePattern=/.*(?:\r\n?|\n)|.*$/g;var locator=domBuilder.locator;var parseStack=[{currentNSMap:defaultNSMapCopy}];var closeMap={};var start=0;while(true){try{var tagStart=source.indexOf("<",start);if(tagStart<0){if(!source.substr(start).match(/^\s*$/)){var doc=domBuilder.doc;var text=doc.createTextNode(source.substr(start));doc.appendChild(text);domBuilder.currentElement=text}return}if(tagStart>start){appendText(tagStart)}switch(source.charAt(tagStart+1)){case"/":var end=source.indexOf(">",tagStart+3);var tagName=source.substring(tagStart+2,end);var config=parseStack.pop();if(end<0){tagName=source.substring(tagStart+2).replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" is not complete:"+config.tagName);end=tagStart+1+tagName.length}else if(tagName.match(/\s</)){tagName=tagName.replace(/[\s<].*/,"");errorHandler.error("end tag name: "+tagName+" maybe not complete");end=tagStart+1+tagName.length}var localNSMap=config.localNSMap;var endMatch=config.tagName==tagName;var endIgnoreCaseMach=endMatch||config.tagName&&config.tagName.toLowerCase()==tagName.toLowerCase();if(endIgnoreCaseMach){domBuilder.endElement(config.uri,config.localName,tagName);if(localNSMap){for(var prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}if(!endMatch){errorHandler.fatalError("end tag name: "+tagName+" is not match the current start tagName:"+config.tagName)}}else{parseStack.push(config)}end++;break;case"?":locator&&position(tagStart);end=parseInstruction(source,tagStart,domBuilder);break;case"!":locator&&position(tagStart);end=parseDCC(source,tagStart,domBuilder,errorHandler);break;default:locator&&position(tagStart);var el=new ElementAttributes;var currentNSMap=parseStack[parseStack.length-1].currentNSMap;var end=parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);var len=el.length;if(!el.closed&&fixSelfClosed(source,end,el.tagName,closeMap)){el.closed=true;if(!entityMap.nbsp){errorHandler.warning("unclosed xml attribute")}}if(locator&&len){var locator2=copyLocator(locator,{});for(var i=0;i<len;i++){var a=el[i];position(a.offset);a.locator=copyLocator(locator,{})}domBuilder.locator=locator2;if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}domBuilder.locator=locator}else{if(appendElement(el,domBuilder,currentNSMap)){parseStack.push(el)}}if(el.uri==="http://www.w3.org/1999/xhtml"&&!el.closed){end=parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)}else{end++}}}catch(e){errorHandler.error("element parse error: "+e);end=-1}if(end>start){start=end}else{appendText(Math.max(tagStart,start)+1)}}}function copyLocator(f,t){t.lineNumber=f.lineNumber;t.columnNumber=f.columnNumber;return t}function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){var attrName;var value;var p=++start;var s=S_TAG;while(true){var c=source.charAt(p);switch(c){case"=":if(s===S_ATTR){attrName=source.slice(start,p);s=S_EQ}else if(s===S_ATTR_SPACE){s=S_EQ}else{throw new Error("attribute equal must after attrName")}break;case"'":case'"':if(s===S_EQ||s===S_ATTR){if(s===S_ATTR){errorHandler.warning('attribute value must after "="');attrName=source.slice(start,p)}start=p+1;p=source.indexOf(c,start);if(p>0){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start-1);s=S_ATTR_END}else{throw new Error("attribute value no end '"+c+"' match")}}else if(s==S_ATTR_NOQUOT_VALUE){value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);el.add(attrName,value,start);errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+")!!");start=p+1;s=S_ATTR_END}else{throw new Error('attribute value must after "="')}break;case"/":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:s=S_TAG_CLOSE;el.closed=true;case S_ATTR_NOQUOT_VALUE:case S_ATTR:case S_ATTR_SPACE:break;default:throw new Error("attribute invalid close char('/')")}break;case"":errorHandler.error("unexpected end of input");if(s==S_TAG){el.setTagName(source.slice(start,p))}return p;case">":switch(s){case S_TAG:el.setTagName(source.slice(start,p));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:value=source.slice(start,p);if(value.slice(-1)==="/"){el.closed=true;value=value.slice(0,-1)}case S_ATTR_SPACE:if(s===S_ATTR_SPACE){value=attrName}if(s==S_ATTR_NOQUOT_VALUE){errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)}else{if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!value.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')}el.add(value,value,start)}break;case S_EQ:throw new Error("attribute value missed!!")}return p;case"":c=" ";default:if(c<=" "){switch(s){case S_TAG:el.setTagName(source.slice(start,p));s=S_TAG_SPACE;break;case S_ATTR:attrName=source.slice(start,p);s=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var value=source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);errorHandler.warning('attribute "'+value+'" missed quot(")!!');el.add(attrName,value,start);case S_ATTR_END:s=S_TAG_SPACE;break}}else{switch(s){case S_ATTR_SPACE:var tagName=el.tagName;if(currentNSMap[""]!=="http://www.w3.org/1999/xhtml"||!attrName.match(/^(?:disabled|checked|selected)$/i)){errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')}el.add(attrName,attrName,start);start=p;s=S_ATTR;break;case S_ATTR_END:errorHandler.warning('attribute space is required"'+attrName+'"!!');case S_TAG_SPACE:s=S_ATTR;start=p;break;case S_EQ:s=S_ATTR_NOQUOT_VALUE;start=p;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}}p++}}function appendElement(el,domBuilder,currentNSMap){var tagName=el.tagName;var localNSMap=null;var i=el.length;while(i--){var a=el[i];var qName=a.qName;var value=a.value;var nsp=qName.indexOf(":");if(nsp>0){var prefix=a.prefix=qName.slice(0,nsp);var localName=qName.slice(nsp+1);var nsPrefix=prefix==="xmlns"&&localName}else{localName=qName;prefix=null;nsPrefix=qName==="xmlns"&&""}a.localName=localName;if(nsPrefix!==false){if(localNSMap==null){localNSMap={};_copy(currentNSMap,currentNSMap={})}currentNSMap[nsPrefix]=localNSMap[nsPrefix]=value;a.uri="http://www.w3.org/2000/xmlns/";domBuilder.startPrefixMapping(nsPrefix,value)}}var i=el.length;while(i--){a=el[i];var prefix=a.prefix;if(prefix){if(prefix==="xml"){a.uri="http://www.w3.org/XML/1998/namespace"}if(prefix!=="xmlns"){a.uri=currentNSMap[prefix||""]}}}var nsp=tagName.indexOf(":");if(nsp>0){prefix=el.prefix=tagName.slice(0,nsp);localName=el.localName=tagName.slice(nsp+1)}else{prefix=null;localName=el.localName=tagName}var ns=el.uri=currentNSMap[prefix||""];domBuilder.startElement(ns,localName,tagName,el);if(el.closed){domBuilder.endElement(ns,localName,tagName);if(localNSMap){for(prefix in localNSMap){domBuilder.endPrefixMapping(prefix)}}}else{el.currentNSMap=currentNSMap;el.localNSMap=localNSMap;return true}}function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){if(/^(?:script|textarea)$/i.test(tagName)){var elEndStart=source.indexOf("</"+tagName+">",elStartEnd);var text=source.substring(elStartEnd+1,elEndStart);if(/[&<]/.test(text)){if(/^script$/i.test(tagName)){domBuilder.characters(text,0,text.length);return elEndStart}text=text.replace(/&#?\w+;/g,entityReplacer);domBuilder.characters(text,0,text.length);return elEndStart}}return elStartEnd+1}function fixSelfClosed(source,elStartEnd,tagName,closeMap){var pos=closeMap[tagName];if(pos==null){pos=source.lastIndexOf("</"+tagName+">");if(pos<elStartEnd){pos=source.lastIndexOf("</"+tagName)}closeMap[tagName]=pos}return pos<elStartEnd}function _copy(source,target){for(var n in source){target[n]=source[n]}}function parseDCC(source,start,domBuilder,errorHandler){var next=source.charAt(start+2);switch(next){case"-":if(source.charAt(start+3)==="-"){var end=source.indexOf("--\x3e",start+4);if(end>start){domBuilder.comment(source,start+4,end-start-4);return end+3}else{errorHandler.error("Unclosed comment");return-1}}else{return-1}default:if(source.substr(start+3,6)=="CDATA["){var end=source.indexOf("]]>",start+9);domBuilder.startCDATA();domBuilder.characters(source,start+9,end-start-9);domBuilder.endCDATA();return end+3}var matchs=split(source,start);var len=matchs.length;if(len>1&&/!doctype/i.test(matchs[0][0])){var name=matchs[1][0];var pubid=len>3&&/^public$/i.test(matchs[2][0])&&matchs[3][0];var sysid=len>4&&matchs[4][0];var lastMatch=matchs[len-1];domBuilder.startDTD(name,pubid&&pubid.replace(/^(['"])(.*?)\1$/,"$2"),sysid&&sysid.replace(/^(['"])(.*?)\1$/,"$2"));domBuilder.endDTD();return lastMatch.index+lastMatch[0].length}}return-1}function parseInstruction(source,start,domBuilder){var end=source.indexOf("?>",start);if(end){var match=source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(match){var len=match[0].length;domBuilder.processingInstruction(match[1],match[2]);return end+2}else{return-1}}return-1}function ElementAttributes(source){}ElementAttributes.prototype={setTagName:function(tagName){if(!tagNamePattern.test(tagName)){throw new Error("invalid tagName:"+tagName)}this.tagName=tagName},add:function(qName,value,offset){if(!tagNamePattern.test(qName)){throw new Error("invalid attribute:"+qName)}this[this.length++]={qName:qName,value:value,offset:offset}},length:0,getLocalName:function(i){return this[i].localName},getLocator:function(i){return this[i].locator},getQName:function(i){return this[i].qName},getURI:function(i){return this[i].uri},getValue:function(i){return this[i].value}};function _set_proto_(thiz,parent){thiz.__proto__=parent;return thiz}if(!(_set_proto_({},_set_proto_.prototype)instanceof _set_proto_)){_set_proto_=function(thiz,parent){function p(){}p.prototype=parent;p=new p;for(parent in thiz){p[parent]=thiz[parent]}return p}}function split(source,start){var match;var buf=[];var reg=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;reg.lastIndex=start;reg.exec(source);while(match=reg.exec(source)){buf.push(match);if(match[1])return buf}}exports.XMLReader=XMLReader},{}],"/src/js/docxtemplater.js":[function(require,module,exports){"use strict";var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var DocUtils=require("./doc-utils");DocUtils.traits=require("./traits");DocUtils.moduleWrapper=require("./module-wrapper");var wrapper=DocUtils.moduleWrapper;var Docxtemplater=function(){function Docxtemplater(){_classCallCheck(this,Docxtemplater);if(arguments.length>0){throw new Error("The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.")}this.compiled={};this.modules=[];this.setOptions({})}_createClass(Docxtemplater,[{key:"attachModule",value:function attachModule(module){this.modules.push(wrapper(module));return this}},{key:"setOptions",value:function setOptions(options){var _this=this;this.options=options;Object.keys(DocUtils.defaults).forEach(function(key){var defaultValue=DocUtils.defaults[key];_this[key]=_this.options[key]!=null?_this.options[key]:defaultValue});if(this.zip){this.updateFileTypeConfig()}return this}},{key:"loadZip",value:function loadZip(zip){if(zip.loadAsync){throw new Error("Docxtemplater doesn't handle JSZip version >=3, see changelog")}this.zip=zip;this.updateFileTypeConfig();return this}},{key:"compileFile",value:function compileFile(fileName){var currentFile=this.createTemplateClass(fileName);currentFile.parse();this.compiled[fileName]=currentFile}},{key:"compile",value:function compile(){this.templatedFiles=this.fileTypeConfig.getTemplatedFiles(this.zip);return this}},{key:"updateFileTypeConfig",value:function updateFileTypeConfig(){this.fileType=this.zip.files["word/document.xml"]?"docx":"pptx";this.fileTypeConfig=this.options.fileTypeConfig||Docxtemplater.FileTypeConfig[this.fileType];return this}},{key:"render",value:function render(){var _this2=this;this.options.xmlFileNames=[];this.modules=this.fileTypeConfig.baseModules.map(function(moduleFunction){return moduleFunction()}).concat(this.modules);this.options=this.modules.reduce(function(options,module){return module.optionsTransformer(options,_this2)},this.options);this.xmlDocuments=this.options.xmlFileNames.reduce(function(xmlDocuments,fileName){var content=_this2.zip.files[fileName].asText();xmlDocuments[fileName]=DocUtils.str2xml(content);return xmlDocuments},{});this.modules.forEach(function(module){module.set({zip:_this2.zip,xmlDocuments:_this2.xmlDocuments,data:_this2.data})});this.compile();this.modules.forEach(function(module){module.set({compiled:_this2.compiled})});this.templatedFiles.forEach(function(fileName){if(_this2.zip.files[fileName]!=null){_this2.compileFile(fileName)}});this.mapper=this.modules.reduce(function(value,module){return module.getRenderedMap(value)},{});Object.keys(this.mapper).forEach(function(to){var mapped=_this2.mapper[to];var from=mapped.from;var currentFile=_this2.compiled[from];currentFile.setTags(mapped.data);currentFile.render(to);_this2.zip.file(to,currentFile.content)});Object.keys(this.xmlDocuments).forEach(function(fileName){_this2.zip.remove(fileName);var content=DocUtils.xml2str(_this2.xmlDocuments[fileName]);return _this2.zip.file(fileName,content,{})});return this}},{key:"setData",value:function setData(data){this.data=data;return this}},{key:"getZip",value:function getZip(){return this.zip}},{key:"createTemplateClass",value:function createTemplateClass(path){var usedData=this.zip.files[path].asText();return this.createTemplateClassFromContent(usedData,path)}},{key:"createTemplateClassFromContent",value:function createTemplateClassFromContent(content,filePath){var _this3=this;var xmltOptions={filePath:filePath};Object.keys(DocUtils.defaults).forEach(function(key){xmltOptions[key]=_this3[key]});xmltOptions.fileTypeConfig=this.fileTypeConfig;xmltOptions.modules=this.modules;return new Docxtemplater.XmlTemplater(content,xmltOptions)}},{key:"getFullText",value:function getFullText(path){return this.createTemplateClass(path||this.fileTypeConfig.textPath).getFullText()}},{key:"getTemplatedFiles",value:function getTemplatedFiles(){this.compile();return this.templatedFiles}}]);return Docxtemplater}();Docxtemplater.DocUtils=require("./doc-utils");Docxtemplater.Errors=require("./errors");Docxtemplater.XmlTemplater=require("./xml-templater");Docxtemplater.FileTypeConfig=require("./file-type-config");Docxtemplater.XmlMatcher=require("./xml-matcher");module.exports=Docxtemplater},{"./doc-utils":1,"./errors":2,"./file-type-config":3,"./module-wrapper":7,"./traits":16,"./xml-matcher":17,"./xml-templater":18}]},{},[])("/src/js/docxtemplater.js")});

/***/ }),

/***/ 58296:
/*!*************************!*\
  !*** ./js/jszip.min.js ***!
  \*************************/
/***/ ((module) => {

/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if(true)module.exports=a();else { var b; }}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i=undefined;if(!h&&i)return require(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f=undefined,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";function d(a){if(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0;for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}}var e=a("./dataReader");d.prototype=new e,d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6}],2:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a,b){for(var c,e,f,g,h,i,j,k="",l=0;l<a.length;)c=a.charCodeAt(l++),e=a.charCodeAt(l++),f=a.charCodeAt(l++),g=c>>2,h=(3&c)<<4|e>>4,i=(15&e)<<2|f>>6,j=63&f,isNaN(e)?i=j=64:isNaN(f)&&(j=64),k=k+d.charAt(g)+d.charAt(h)+d.charAt(i)+d.charAt(j);return k},c.decode=function(a,b){var c,e,f,g,h,i,j,k="",l=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");l<a.length;)g=d.indexOf(a.charAt(l++)),h=d.indexOf(a.charAt(l++)),i=d.indexOf(a.charAt(l++)),j=d.indexOf(a.charAt(l++)),c=g<<2|h>>4,e=(15&h)<<4|i>>2,f=(3&i)<<6|j,k+=String.fromCharCode(c),64!=i&&(k+=String.fromCharCode(e)),64!=j&&(k+=String.fromCharCode(f));return k}},{}],3:[function(a,b,c){"use strict";function d(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}d.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=d},{}],4:[function(a,b,c){"use strict";c.STORE={magic:"\0\0",compress:function(a,b){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":9}],5:[function(a,b,c){"use strict";var d=a("./utils"),e=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==d.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b^=-1;for(var i=0,j=a.length;i<j;i++)h=c?a[i]:a.charCodeAt(i),g=255&(b^h),f=e[g],b=b>>>8^f;return b^-1}},{"./utils":22}],6:[function(a,b,c){"use strict";function d(a){this.data=null,this.length=0,this.index=0,this.zero=0}var e=a("./utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=d},{"./utils":22}],7:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],8:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":22}],9:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\0",c.compress=function(a,b){return e.deflateRaw(a,{level:b.level||-1})},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:25}],10:[function(a,b,c){"use strict";function d(a,b){return this instanceof d?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new d(a,b)}var e=a("./base64");d.prototype=a("./object"),d.prototype.load=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.utils=a("./deprecatedPublicUtils"),d.base64={encode:function(a){return e.encode(a)},decode:function(a){return e.decode(a)}},d.compressions=a("./compressions"),b.exports=d},{"./base64":2,"./compressions":4,"./defaults":7,"./deprecatedPublicUtils":8,"./load":11,"./object":14,"./support":18}],11:[function(a,b,c){"use strict";var d=a("./base64"),e=a("./utf8"),f=a("./utils"),g=a("./zipEntries");b.exports=function(a,b){var c,h,i,j;for(b=f.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:e.utf8decode}),b.base64&&(a=d.decode(a)),h=new g(a,b),c=h.files,i=0;i<c.length;i++)j=c[i],this.file(j.fileNameStr,j.decompressed,{binary:!0,optimizedBinaryString:!0,date:j.date,dir:j.dir,comment:j.fileCommentStr.length?j.fileCommentStr:null,unixPermissions:j.unixPermissions,dosPermissions:j.dosPermissions,createFolders:b.createFolders});return h.zipComment.length&&(this.comment=h.zipComment),this}},{"./base64":2,"./utf8":21,"./utils":22,"./zipEntries":23}],12:[function(a,b,c){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],13:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0}var e=a("./uint8ArrayReader");d.prototype=new e,d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./uint8ArrayReader":19}],14:[function(a,b,c){"use strict";var d=a("./support"),e=a("./utils"),f=a("./crc32"),g=a("./signature"),h=a("./defaults"),i=a("./base64"),j=a("./compressions"),k=a("./compressedObject"),l=a("./nodeBuffer"),m=a("./utf8"),n=a("./stringWriter"),o=a("./uint8ArrayWriter"),p=function(a){if(a._data instanceof k&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===e.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},q=function(a){var b=p(a),c=e.getTypeOf(b);return"string"===c?!a.options.binary&&d.nodebuffer?l(b,"utf-8"):a.asBinary():b},r=function(a){var b=p(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=i.decode(b)),b=a&&this.options.binary?D.utf8decode(b):e.transformTo("string",b),a||this.options.binary||(b=e.transformTo("string",D.utf8encode(b))),b)},s=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};s.prototype={asText:function(){return r.call(this,!0)},asBinary:function(){return r.call(this,!1)},asNodeBuffer:function(){var a=q(this);return e.transformTo("nodebuffer",a)},asUint8Array:function(){var a=q(this);return e.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var t=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=e.extend(a,h),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var d,f=e.getTypeOf(b);if(c=u(c),"string"==typeof c.unixPermissions&&(c.unixPermissions=parseInt(c.unixPermissions,8)),c.unixPermissions&&16384&c.unixPermissions&&(c.dir=!0),c.dosPermissions&&16&c.dosPermissions&&(c.dir=!0),c.dir&&(a=x(a)),c.createFolders&&(d=w(a))&&y.call(this,d,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null,f=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=e.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof k))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=e.transformTo("uint8array",b))}var g=new s(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a){return"/"!=a.slice(-1)&&(a+="/"),a},y=function(a,b){return b="undefined"!=typeof b&&b,a=x(a),this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},z=function(a,b,c){var d,g=new k;return a._data instanceof k?(g.uncompressedSize=a._data.uncompressedSize,g.crc32=a._data.crc32,0===g.uncompressedSize||a.dir?(b=j.STORE,g.compressedContent="",g.crc32=0):a._data.compressionMethod===b.magic?g.compressedContent=a._data.getCompressedContent():(d=a._data.getContent(),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c))):(d=q(a),d&&0!==d.length&&!a.dir||(b=j.STORE,d=""),g.uncompressedSize=d.length,g.crc32=f(d),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c)),g.compressedSize=g.compressedContent.length,g.compressionMethod=b.magic,g},A=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},B=function(a,b){return 63&(a||0)},C=function(a,b,c,d,h,i){var j,k,l,n,o=(c.compressedContent,i!==m.utf8encode),p=e.transformTo("string",i(b.name)),q=e.transformTo("string",m.utf8encode(b.name)),r=b.comment||"",s=e.transformTo("string",i(r)),u=e.transformTo("string",m.utf8encode(r)),v=q.length!==b.name.length,w=u.length!==r.length,x=b.options,y="",z="",C="";l=b._initialMetadata.dir!==b.dir?b.dir:x.dir,n=b._initialMetadata.date!==b.date?b.date:x.date;var D=0,E=0;l&&(D|=16),"UNIX"===h?(E=798,D|=A(b.unixPermissions,l)):(E=20,D|=B(b.dosPermissions,l)),j=n.getHours(),j<<=6,j|=n.getMinutes(),j<<=5,j|=n.getSeconds()/2,k=n.getFullYear()-1980,k<<=4,k|=n.getMonth()+1,k<<=5,k|=n.getDate(),v&&(z=t(1,1)+t(f(p),4)+q,y+="up"+t(z.length,2)+z),w&&(C=t(1,1)+t(this.crc32(s),4)+u,y+="uc"+t(C.length,2)+C);var F="";F+="\n\0",F+=o||!v&&!w?"\0\0":"\0\b",F+=c.compressionMethod,F+=t(j,2),F+=t(k,2),F+=t(c.crc32,4),F+=t(c.compressedSize,4),F+=t(c.uncompressedSize,4),F+=t(p.length,2),F+=t(y.length,2);var G=g.LOCAL_FILE_HEADER+F+p+y,H=g.CENTRAL_FILE_HEADER+t(E,2)+F+t(s.length,2)+"\0\0\0\0"+t(D,4)+t(d,4)+p+y+s;return{fileRecord:G,dirRecord:H,compressedObject:c}},D={load:function(a,b){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,f,g=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],f=new s(d.name,d._data,e.extend(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,f)&&g.push(f));return g},file:function(a,b,c){if(1===arguments.length){if(e.isRegExp(a)){var d=a;return this.filter(function(a,b){return!b.dir&&d.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(e.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=y.call(this,b),d=this.clone();return d.root=c.name,d},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=e.extend(a||{},{base64:!0,compression:"STORE",compressionOptions:null,type:"base64",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:m.utf8encode}),e.checkSupport(a.type),"darwin"!==a.platform&&"freebsd"!==a.platform&&"linux"!==a.platform&&"sunos"!==a.platform||(a.platform="UNIX"),"win32"===a.platform&&(a.platform="DOS");var b,c,d=[],f=0,h=0,k=e.transformTo("string",a.encodeFileName(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var p=this.files[l],q=p.options.compression||a.compression.toUpperCase(),r=j[q];if(!r)throw new Error(q+" is not a valid compression method !");var s=p.options.compressionOptions||a.compressionOptions||{},u=z.call(this,p,r,s),v=C.call(this,l,p,u,f,a.platform,a.encodeFileName);f+=v.fileRecord.length+u.compressedSize,h+=v.dirRecord.length,d.push(v)}var w="";w=g.CENTRAL_DIRECTORY_END+"\0\0\0\0"+t(d.length,2)+t(d.length,2)+t(h,4)+t(f,4)+t(k.length,2)+k;var x=a.type.toLowerCase();for(b="uint8array"===x||"arraybuffer"===x||"blob"===x||"nodebuffer"===x?new o(f+h+w.length):new n(f+h+w.length),c=0;c<d.length;c++)b.append(d[c].fileRecord),b.append(d[c].compressedObject.compressedContent);for(c=0;c<d.length;c++)b.append(d[c].dirRecord);b.append(w);var y=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return e.transformTo(a.type.toLowerCase(),y);case"blob":return e.arrayBuffer2Blob(e.transformTo("arraybuffer",y),a.mimeType);case"base64":return a.base64?i.encode(y):y;default:return y}},crc32:function(a,b){return f(a,b)},utf8encode:function(a){return e.transformTo("string",m.utf8encode(a))},utf8decode:function(a){return m.utf8decode(a)}};b.exports=D},{"./base64":2,"./compressedObject":3,"./compressions":4,"./crc32":5,"./defaults":7,"./nodeBuffer":12,"./signature":15,"./stringWriter":17,"./support":18,"./uint8ArrayWriter":20,"./utf8":21,"./utils":22}],15:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],16:[function(a,b,c){"use strict";function d(a,b){this.data=a,b||(this.data=f.string2binary(this.data)),this.length=this.data.length,this.index=0,this.zero=0}var e=a("./dataReader"),f=a("./utils");d.prototype=new e,d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6,"./utils":22}],17:[function(a,b,c){"use strict";var d=a("./utils"),e=function(){this.data=[]};e.prototype={append:function(a){a=d.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=e},{"./utils":22}],18:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],19:[function(a,b,c){"use strict";function d(a){a&&(this.data=a,this.length=this.data.length,this.index=0,this.zero=0)}var e=a("./arrayReader");d.prototype=new e,d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./arrayReader":1}],20:[function(a,b,c){"use strict";var d=a("./utils"),e=function(a){this.data=new Uint8Array(a),this.index=0};e.prototype={append:function(a){0!==a.length&&(a=d.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=e},{"./utils":22}],21:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;h<256;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;b<h;)if(e=a[b++],e<128)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&b<h;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:e<65536?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;c<f;){var h=j(a,Math.min(c+g,f));e.uint8array?b.push(k(a.subarray(c,h))):b.push(k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":12,"./support":18,"./utils":22}],22:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;g<e&&b>1;)try{"array"===f||"nodebuffer"===f?d.push(String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e)))):d.push(String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a,b){c.checkSupport("blob"),b=b||"application/zip";try{return new Blob([a],{type:b})}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c}},{"./compressions":4,"./nodeBuffer":12,"./support":18}],23:[function(a,b,c){"use strict";function d(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var e=a("./stringReader"),f=a("./nodeBufferReader"),g=a("./uint8ArrayReader"),h=a("./arrayReader"),i=a("./utils"),j=a("./signature"),k=a("./zipEntry"),l=a("./support");a("./object");d.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+i.pretty(b)+", expected "+i.pretty(a)+")")},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=l.uint8array?"uint8array":"array",c=i.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(j.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===j.CENTRAL_FILE_HEADER;)a=new k({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(j.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,j.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip : can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(j.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,j.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,j.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){var b=i.getTypeOf(a);if(i.checkSupport(b),"string"!==b||l.uint8array)if("nodebuffer"===b)this.reader=new f(a);else if(l.uint8array)this.reader=new g(i.transformTo("uint8array",a));else{if(!l.array)throw new Error("Unexpected error: unsupported type '"+b+"'");this.reader=new h(i.transformTo("array",a))}else this.reader=new e(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./arrayReader":1,"./nodeBufferReader":13,"./object":14,"./signature":15,"./stringReader":16,"./support":18,"./uint8ArrayReader":19,"./utils":22,"./zipEntry":24}],24:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./stringReader"),f=a("./utils"),g=a("./compressedObject"),h=a("./object"),i=a("./support"),j=0,k=3;d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,e){return function(){var a=f.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==e)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize==-1||this.uncompressedSize==-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=f.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");if(this.decompressed=new g,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=f.transformTo("string",this.decompressed.getContent()),h.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch");
},readCentralPart:function(a){if(this.versionMadeBy=a.readInt(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readData(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===j&&(this.dosPermissions=63&this.externalFileAttributes),a===k&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=new e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=i.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=h.utf8decode(this.fileName),this.fileCommentStr=h.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileName)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileComment)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null}},b.exports=d},{"./compressedObject":3,"./object":14,"./stringReader":16,"./support":18,"./utils":22}],25:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":26,"./lib/inflate":27,"./lib/utils/common":28,"./lib/zlib/constants":31}],26:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":28,"./utils/strings":29,"./zlib/deflate":33,"./zlib/messages":38,"./zlib/zstream":40}],27:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":28,"./utils/strings":29,"./zlib/constants":31,"./zlib/gzheader":34,"./zlib/inflate":36,"./zlib/messages":38,"./zlib/zstream":40}],28:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],29:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":28}],30:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],31:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],32:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],33:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./messages":38,"./trees":39}],34:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],35:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],36:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,
n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./inffast":35,"./inftrees":37}],37:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":28}],38:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],39:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":28}],40:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});


/***/ }),

/***/ 7018:
/*!******************************!*\
  !*** ./resources/Account.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);

class Account extends EventEmitter {
   constructor() {
      super();

      this.isAuthenticated = false;
      this._config = null;

      this._listRoles = null;
      // {array}
      // a list of all the Defined Roles in the Tenant's system.

      this._listScopes = null;
      // {array | null}
      // a list of all the Defined Scopes in the Tenant's sytem.

      this._listUsers = null;
      // {array | null}
      // a list of all the Defined Users in the Tenant's system.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var UserConfig = this.AB.Config.userConfig();
      if (UserConfig) {
         this.isAuthenticated = true;
         this._config = UserConfig;
      }

      var MetaConfig = this.AB.Config.metaConfig();
      if (MetaConfig) {
         this._listRoles = MetaConfig.roles || [];
         this._listScopes = MetaConfig.scopes || [];
         this._listUsers = MetaConfig.users || [];
      }

      this.AB.Network.on("account.logout", (context, err, data) => {
         if (err) {
            console.error(err);
            return;
         }
         this.emit("logout", data);
      });

      return Promise.resolve();
   }

   canSwitcheroo() {
      return (
         this.roles((r) => r.uuid === "320ef94a-73b5-476e-9db4-c08130c64bb8")
            .length > 0
      );
   }

   isSwitcherood() {
      return this.AB.Config.userReal();
   }

   isSystemDesigner() {
      return (
         this.roles((r) => r.uuid === "6cc04894-a61b-4fb5-b3e5-b8c3f78bd331")
            .length > 0
      );
   }

   email() {
      return this._config?.email ?? "";
   }

   language() {
      return this._config?.languageCode ?? "en";
   }

   logout() {
      return this.AB.Network.post(
         {
            url: "/auth/logout",
            data: { tenantUrl: this.AB.Tenant.setting("url") },
         },
         {
            key: "account.logout",
            context: {},
         }
      );
   }

   roles(fn = () => true) {
      return (this._config?.roles || []).filter(fn);
   }
   rolesAll() {
      return this._listRoles;
   }

   scopes() {
      return this._listScopes;
   }

   username() {
      return this._config?.username;
   }

   userList() {
      return this._listUsers;
   }

   uuid() {
      return this._config?.uuid;
   }

   imageID() {
      return this._config?.image_id;
   }

   sendEmailNotifications() {
      return this._config?.sendEmailNotifications;
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Account());


/***/ }),

/***/ 19962:
/*!***********************************!*\
  !*** ./resources/Multilingual.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Multilingual
 * manage our multilingual Translations/Labels/etc.
 */

var MLClass = __webpack_require__(/*! ../AppBuilder/platform/ABMLClass */ 70504);

class Multilingual extends MLClass {
   constructor() {
      super([], {});
      // super()
      //    [] = no labels
      //    {} = placeholder ABFactory entry until .init() is called.

      this.isAuthenticated = false;
      this._config = null;

      this._missingLabelID = false;
      this._missingLabels = {};
      this._pluginLabelsMissing = {};
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.labels = this.AB.Config.labelConfig();
      this._languages = this.AB.Config.languageConfig();

      this.pluginLabels = {};

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   currentLanguage() {
      return this.AB.Account.language();
   }

   label(key, altText, values = [], postMissing = true) {
      // part of our transition: L("single string") should start to work:
      if (typeof altText == "undefined" && key) {
         altText = key;
      }

      // other case: L("single string {0}", [])
      if (arguments.length == 2 && Array.isArray(altText)) {
         values = altText;
         altText = key;
      }

      // We need to escape " characters or else they will get added to the the lang.js
      // then we get errors next time we try to parse it as JSON (see appbuilder.label-missing)
      altText = altText.replace(/"/g, '\\"');
      key = key.replace(/"/g, '\\"');

      // NOTE: transition to new Labels
      // currently our code still uses the L(key, altText, values) format, but
      // the labels we get back are in L(altText, values) format.
      //
      // we are going to keep this like this until we have a well functioning
      // UI display of our Apps, which should flesh out most of the missing
      // labels to our files.
      //
      // After that, convert our L(k, t, v) to L(t, v)

      var newKey = altText;
      if (newKey[0] == "*") {
         newKey = newKey.slice(1);
      }
      var label = this.labels[newKey];
      if (!label) {
         if (postMissing) {
            this.postMissingLabel(key, altText);
         }
         label = altText;
      }

      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      label = label.replace(/\\"/g, '"'); // unescape " in the label
      return label;
   }

   labelPlugin(plugin, altText, values = []) {
      // 1st check to see if it is a common label from platform:
      var label = this.label(altText, altText, values, false);
      if (!label) {
         // ok, so check to see if it is a Plugin Label:
         label = this.pluginLabels[plugin][altText];
      }
      if (!label) {
         // !! record it missing.
         this._pluginLabelsMissing[plugin] =
            this._pluginLabelsMissing[plugin] || {};
         this._pluginLabelsMissing[plugin][altText] = altText;
         label = altText;
      }
      values.forEach((v, i) => {
         var sub = `{${i}}`;
         label = label.replaceAll(sub, v);
      });
      return label;
   }

   languages() {
      return this._languages;

      // console.error(
      //    "Multilingual:languages(): Implement Language Storage/Retrieval."
      // );
      // return [];
   }

   pluginLoadLabels(key, labels) {
      this.pluginLabels[key] = labels;
   }
   pluginLabelReport(key) {
      console.warn("missing labels for plugin: ", key);
      console.warn("current language:", this.currentLanguage());
      var labels = JSON.stringify(this._pluginLabelsMissing[key], null, 3);
      console.warn(labels);
   }

   postMissingLabel(key, altText) {
      if (this._missingLabelID) {
         clearTimeout(this._missingLabelID);
      }
      var batchLength = 50;
      var sendBatch = () => {
         var batchLabels = [];
         let missingLabels = Object.keys(this._missingLabels).map(
            (k) => this._missingLabels[k]
         );
         if (missingLabels.length <= batchLength) {
            batchLabels = missingLabels;
            this._missingLabels = {};
         } else {
            for (var i = 0; i <= batchLength; i++) {
               var l = missingLabels.shift();
               batchLabels.push(l);
               delete this._missingLabels[l.key];
            }
         }
         this.AB.Network.post({
            url: "/multilingual/label-missing",
            data: { labels: JSON.stringify(batchLabels) },
         })
            .then(() => {
               if (Object.keys(this._missingLabels).length > 0) {
                  sendBatch();
               }
            })
            .catch((err) => {
               const strErr = err.toString();
               if (strErr.indexOf("unable to get") > -1) {
                  console.error(
                     "Missing language file for :" + this.currentLanguage()
                  );
               }
            });
      };
      this._missingLabelID = setTimeout(() => {
         sendBatch();
      }, 1000);

      this._missingLabels[key] = { key, altText };
   }
   ///
   /// Disable un-needed ABMLClass functionality
   ///
   /// NOTE: we are mainly Piggybacking on ABMLClass for it's
   /// .translate() and .unTranslate() capabilities. So disable these
   /// for good measure.
   destroy() {
      console.error("Multilingual:destroy(): Should not be called.");
      return Promise.resolve();
   }
   save() {
      console.error("Multilingual:save(): Should not be called.");
      return Promise.resolve();
   }
   toObj() {
      console.error("Multilingual:toObj(): Should not be called.");
      return {};
   }
   toDefinition() {
      console.error("Multilingual:toDefinition(): Should not be called.");
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Multilingual());


/***/ }),

/***/ 44730:
/*!******************************!*\
  !*** ./resources/Network.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_performance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/performance */ 18320);
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NetworkRest */ 57773);
/* harmony import */ var _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRestSocket */ 46642);
/*
 * Network.js
 * A network manager for interfacing with our AppBuilder server.
 */
/* global Connection */
var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);



// import NetworkRelay from "./NetworkRelay";

class Network extends EventEmitter {
   constructor() {
      super();

      this.setMaxListeners(0);
      // we'll have > 10 for sure!

      this.queueLock = null;
      // {Lock} .queueLock
      // our semaphore for coordinating our access to our local storage.

      this._config = null;
      this._network = null;
      // {NetworkRelay | NetworkRest | NetworkSocket}
      // the underlying Network connection object actually performing the
      // communications with the Server.
      // Which one is specified in the config.appbuilder.networkType setting

      this._queueCount = 0;
      // {int} _queueCount
      // the # of network operations currently queued, pending Network
      // reconnect.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;

      this.queueLock = new this.AB.Lock();

      this._config = this.AB.Config.siteConfig();
      if (this._config) {
         switch (this._config.appbuilder.networkType) {
            case "relay":
               // this._network = new NetworkRelay();
               break;

            case "socket":
               this._network = new _NetworkRestSocket__WEBPACK_IMPORTED_MODULE_0__["default"](this);
               break;

            case "rest":
            default:
               this._network = new _NetworkRest__WEBPACK_IMPORTED_MODULE_1__["default"](this);
               break;
         }

         return this._network.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      //
      // Handle reconnections and flushing the Queue:
      //
      if (io && io.socket) {
         // When our Socket reconnects, be sure to flush any pending transactions.
         io.socket.on("connected", () => {
            this.queueFlush();
            if (this.idConnectionCheck) {
               clearTimeout(this.idConnectionCheck);
               this.idConnectionCheck = null;
            }
         });
      } else {
         console.error("!!! Network.init() : Did not find io.socket");
         window.addEventListener("online", () => this.queueFlush());
      }

      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.isRealTime
    * indicates wether or not the current network connection supports
    * RealTime updates.
    * @return {bool}
    */
   get isRealTime() {
      return this._network.isRealTime;
   }

   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(...params) {
      return this._network.get(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * this is a CREATE operation.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(...params) {
      return this._network.post(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * This is for UPDATE/REPLACE operations to data on the server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(...params) {
      return this._network.put(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(...params) {
      return this._network.delete(...params).then((data) => {
         return this.normalizeData(data);
      });
   }

   ////
   //// Network Utilities
   ////

   _connectionCheck() {
      // if (!this.idConnectionCheck) {
      if (this.isNetworkConnected()) {
         this.queueFlush().catch(() => {
            // on an error, we are still having connection issues
            this.idConnectionCheck = setTimeout(() => {
               this._connectionCheck();
            }, 250);
         });
         this.idConnectionCheck = null;
      } else {
         this.idConnectionCheck = setTimeout(() => {
            this._connectionCheck();
         }, 250);
      }
      // }
   }

   /**
    * Check whether the network is slow
    * @returns {Boolean}
    */
   isNetworkSlow() {
      return !!this._networkSlow;
   }

   /**
    * Register the network speed test worker
    * @param {Worker} worker
    * @param {boolean} slow is the current state slow?
    */
   registerNetworkTestWorker(worker, slow) {
      this._networkTestWorker = worker;
      this._networkSlow = slow;
      this._networkTestWorker.onmessage = ({ data }) => {
         if (this._networkSlow !== data) {
            this._networkSlow = data;
            this.emit("networkslow", this._networkSlow);
            // Tell sentry our network speed changed
            _utils_performance__WEBPACK_IMPORTED_MODULE_2__["default"].setContext("breadcrumb", {
               category: "network",
               message: this._networkSlow
                  ? "Slow network detected"
                  : "Network speed restored",
               level: "info",
            });
         }
      };
   }

   /**
    * @method networkStatus
    * return the connection type currently registered with the network
    * plugin.
    * @return {string}
    */
   networkStatus() {
      return navigator.connection.type;
   }

   /**
    * @method isNetworkConnected
    * return true/false if the device is currently connected to the
    * internet.
    * @return {bool}
    */
   isNetworkConnected() {
      // if this is a Web Client and using sails.socket.io
      if (io && io.socket && io.socket.isConnected) {
         return io.socket.isConnected();
      }

      // if this isn't a Cordova Plugin, then return navigator data:
      if (typeof Connection == "undefined") {
         // NOTE: this technically only detects if we are connected to a
         // network.  It doesn't guarantee we can communicate across the 'net
         return navigator.onLine;
      }

      // Cordova Plugin:
      return this.networkStatus() != Connection.NONE;
   }

   /**
    * publishResponse()
    * emit the requested response for this network operation.
    * @param {obj} jobResponse
    * @param {obj} error
    * @param {obj} data
    */
   publishResponse(jobResponse, error, data) {
      if (data) {
         data = this.normalizeData(data);
      }
      this.emit(jobResponse.key, jobResponse.context, error, data);
   }

   normalizeData(data) {
      // Data returning from our server is wrapped in an outer layer of
      // information that is for our Networking API.
      // the outer wrapper should be:
      // on success :
      // {
      //   status: "success",
      //   data:{Data For App}
      // }
      // on Error:
      // {
      //   status: "error",
      //   id: {int} error code
      //   ... other data here
      // }

      // we have physically received a data packet from the server,
      // but we are informed that our transaction was problematic
      // (400 level USER problem?)
      if (data.status === "error") {
         // TODO: review Error procedure here
         return data;
      }

      // on success
      // make sure we return the Application Level Data packet:
      return data.data || data;
   }

   ////
   //// Queued Requests
   ////

   /**
    * refQueue()
    * sub classes can override this for their own separate Queue Data
    * @return {string}
    */
   refQueue() {
      return "networkQueue";
   }

   /**
    * queueCount()
    * return the # of messages in the queue.
    * @return {int}
    */
   queueCount() {
      return this._queueCount;
   }

   /**
    * Adds a request to the outgoing queue.
    *
    * @param {object} data
    * @param {object} jobResponse
    * @return {Promise}
    */
   queue(data, jobResponse) {
      var refQueue = this.refQueue();

      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })
            .then((queue) => {
               queue = queue || [];
               queue.push({ data, jobResponse });
               this.AB.log(
                  `:::: ${queue.length} request${
                     queue.length > 1 ? "s" : ""
                  } queued`
               );
               this._queueCount = queue.length;
               return this.AB.Storage.set(refQueue, queue);
            })
            .then(() => {
               this.emit("queued");
               // if we are not already polling the network, start
               if (!this.idConnectionCheck) {
                  this._connectionCheck();
               }
               this.queueLock.release();
               resolve();
            })
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "Error while queueing data",
               });
               this.AB.Analytics.logError(err);
               reject(err);

               this.queueLock.release();
            });
      });
   }

   /**
    * queueFlush()
    * Flush the queue and send the contents to the relay server.
    */
   queueFlush() {
      var refQueue = this.refQueue();

      // if we are not connected, then stop
      if (!this.isNetworkConnected()) {
         var error = new Error("Not connected to the internet.");
         error.code = "E_NOTCONNECTED";
         return Promise.reject(error);
      }

      // otherwise, attempt to flush the queue:
      return new Promise((resolve, reject) => {
         this.queueLock
            .acquire()

            //
            // Get queue contents
            //
            .then(() => {
               return this.AB.Storage.get(refQueue);
            })

            //
            // Send off each queued request
            //
            .then((queue) => {
               // default to [] if not found
               queue = queue || [];

               // recursively process each pending queue request
               var processRequest = (cb) => {
                  if (queue.length == 0) {
                     cb();
                  } else {
                     var entry = queue.shift();
                     var params = entry.data;
                     var job = entry.jobResponse;
                     this._network
                        .resend(params, job)
                        .then(() => {
                           processRequest(cb);
                        })
                        .catch((err) => {
                           // if the err was due to a network connection error
                           if (err && err.code == "E_TOMANYRETRIES") {
                              cb(err);
                              return;
                           }
                           // otherwise, try the next
                           processRequest(cb);
                        });
                  }
               };

               return new Promise((res, rej) => {
                  processRequest((err) => {
                     if (err) {
                        rej(err);
                     } else {
                        res();
                     }
                  });
               });
            })

            //
            // Clear queue contents
            //
            .then(() => {
               this._queueCount = 0;
               return this.AB.Storage.set(refQueue, []);
            })

            // release the Lock
            .then(() => {
               this.emit("queue.synced");
               return this.queueLock.release();
            })

            // all done.
            .then(() => {
               resolve();
            })

            // respond to errors:
            .catch((err) => {
               this.AB.notify.developer(err, {
                  message: "commAPI queueFlush error",
               });
               this.AB.Analytics.logError(err);

               this.queueLock.release().then(() => {
                  reject(err);
               });
            });
      });
   }

   /**
    * Reset credentials to a blank state.
    * @return {Promise}
    */
   reset() {
      return Promise.resolve();
   }

   /**
    * type()
    * return the type of network connection we are using.
    * ["rest", "socket", "relay"]
    * @return {string}
    */
   type() {
      return this._config.appbuilder.networkType;
   }

   // uuid() {
   //    return this.AB.uuid();
   // }

   getTokens() {
      // called in appPage.js : openRelayLoader()
      return {};
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Network());


/***/ }),

/***/ 57773:
/*!**********************************!*\
  !*** ./resources/NetworkRest.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */

/* global Connection */
// import Account from "./Account";
// import analytics from "./Analytics";
// import EventEmitter from "eventemitter2";
var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);
// import Lock from "./Lock";

// import { storage } from "./Storage";
// import Tenant from "./Tenant";
// import { v4 as uuidv4 } from "uuid";

// Temp placeholders until Resources are implemented:

// End Temp

const Atomic = __webpack_require__(/*! atomicjs/dist/atomic.min.js */ 8262);
// Atomic : a small $.ajax() replacement

var Config = null;
// {} Config
// the site specific configuration information

class NetworkRest extends EventEmitter {
   constructor(parent) {
      // {Network} parent

      super({
         wildcard: true,
         newListener: false,
         maxListeners: 0,
      });

      this.baseURL = null;
      // {string} .baseURL
      // the url of our site.

      this.numRetries = 3;
      // {int} .numRetries
      // the number or times we should attempt to issue a network request.

      this._network = parent;
      // {Network} ._network
      // the Parent Network Resource that the rest of the Platform actually
      // works with.

      this.isRealTime = false;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);
   }

   /**
    * @method init
    * @param {ABFactory} AB
    * @param {object} options
    * @param {string} options.baseURL
    * @return {Promise}
    */
   init(AB, options) {
      this.AB = AB;

      Config = this.AB.Config.siteConfig();
      options = options || {};
      if (options) {
         this.baseURL = options.baseURL || Config.appbuilder.urlCoreServer;
         this.numRetries =
            options.networkNumRetries || Config.appbuilder.networkNumRetries;
      }
      return Promise.resolve();
   }

   //
   // Interface API
   //
   /**
    * Network.get(options, jobResponse)
    * perform a GET request back to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   get(params, jobResponse) {
      params.type = params.type || "GET";

      // data sent to params on a "GET" request need to be converted to
      // uri querystring values:
      var data = params.data || params.params;
      if (data) {
         var useThese = ["string", "number", "boolean"];
         var search = Object.keys(data)
            .map(function (key) {
               var val = data[key];
               if (useThese.indexOf(typeof val) == -1) {
                  val = JSON.stringify(val);
               }
               return key + "=" + encodeURIComponent(val);
            })
            .join("&");

         var join = "?";
         if (params.url.indexOf("?") > -1) {
            join = "&";
         }
         params.url = [params.url, search].join(join);
      }

      return this._request(params, jobResponse);
   }

   /**
    * Network.post()
    * perform an AJAX POST request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   post(params, jobResponse) {
      params.type = params.type || "POST";
      return this._request(params, jobResponse);
   }

   /**
    * Network.put()
    * perform a PUT request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   put(params, jobResponse) {
      params.type = params.type || "PUT";
      return this._request(params, jobResponse);
   }

   /**
    * Network.delete()
    * perform an AJAX DELETE request to the AppBuilder server.
    * @param {obj} params the request parameters that need to be executed on
    *              the AppBuilder Server
    * @param {obj} jobResponse the callback info for handling the response.
    *              {
    *                  key:'unique.key',
    *                  context:{ obj data }
    *              }
    * @return {Promise}
    */
   delete(params, jobResponse) {
      params.type = params.type || "DELETE";
      return this._request(params, jobResponse);
   }

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return this._network.isNetworkConnected();
   }

   salSend(params) {
      return Atomic(params.url, params).then((packet) => {
         // {json} packet
         // the response from Atomic is in format:
         // {data: {…}, xhr: XMLHttpRequest}
         // we just want to send back our { status:"", data:xxx } packet.
         return packet.data;
      });
   }

   /**
    * _request()
    * perform the actual AJAX request for this operation.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   _request(params, jobResponse) {
      // make sure we don't process too many retries:
      params._retry = params._retry || 0;
      if (params._retry >= this.numRetries) {
         var err = new Error(
            `Too many retries (${this.numRetries}) for ${params.url}`
         );
         err.code = "E_TOMANYRETRIES";
         this.AB.notify.developer(err, {
            context: "NetworkRest:_request: Too Many Retries",
         });
         // this.AB.Analytics.logError(err);
         if (jobResponse) {
            this._network.publishResponse(jobResponse, err);
         }

         return Promise.reject(err);
      }

      return new Promise((resolve, reject) => {
         params.url = params.url || "/";
         if (params.url[0] == "/") {
            params.url = this.baseURL + params.url;
         }

         params.headers = params.headers || {};
         if (this.AB.Account.authToken) {
            params.headers.Authorization = this.AB.Account.authToken;
         }
         params.headers["Content-type"] = "application/json";

         var tenantID = this.AB.Tenant.id();
         if (tenantID) {
            params.headers["tenant-token"] = tenantID;
         }

         // params.timeout = params.timeout || 6000;

         if (this.isNetworkConnected()) {
            params.method = params.method || params.type;
            params.timeout = 6000; // ??
            params.data = params.data || params.params;
            delete params.params;

            this.salSend(params)
               .then((packet) => {
                  // TODO: check if packet.status == "error"
                  // and then .publishResponse() as an error

                  //
                  var data = packet;
                  if (jobResponse) {
                     this._network.publishResponse(jobResponse, null, data);
                  }
                  resolve(data);
               })
               .catch((err) => {
                  // err.status
                  // err.statusText
                  // err.responseText
                  // err.message  {socket}
                  // err.stack    {socket}

                  // if this is a network connection error, send the attempt again:
                  if (
                     err.statusText == "Request timeout" ||
                     (err.message && err.message.indexOf("disconnected") > -1)
                  ) {
                     //// Network Error: conneciton refused, access denied, etc...
                     this.AB.Analytics.log(
                        "NetworkRest._request():network connection error detected. Trying again"
                     );

                     params._retry++;

                     // retry the attempt:
                     this._request(params)
                        .then((data) => {
                           // console.log('--- timeout.then():',data);
                           this.AB.warn(
                              "*** NetworkRest._request().then(): attempt resolved."
                           );
                           resolve(data);
                        })
                        .catch((_err) => {
                           this.AB.notify.developer(_err, {
                              message:
                                 "*** NetworkRest._request().catch(): retry failed:",
                           });
                           reject(_err);
                        });

                     return;
                  } else {
                     // Else attempt to emit() some common Error types for
                     // additional Platform Handling.
                     if (err.status == 403) {
                        this.emit("error.badAuth", err);
                     } else if (err.status >= 400 && err.status < 500) {
                        this.emit("error.badRequest", err);
                     } else if (err.status >= 500) {
                        this.emit("error.badServer", err);
                     }
                  }

                  var packet = null;
                  if (err.responseText) {
                     try {
                        packet = JSON.parse(err.responseText);
                     } catch (e) {
                        /* ignore */
                     }
                  }
                  // if this is an req.ab.error() response:
                  if (packet && packet.status == "error") {
                     // check if REAUTH Error:
                     if (packet.id == 5 || packet.code == "E_REAUTH") {
                        this._network.emit("reauth");
                        return;
                     }

                     this.AB.notify.developer(new Error(packet.message), {
                        context:
                           "NetworkRest:_request:Error returned from Server (req.ab.error())",
                        data: packet.data,
                        status: packet.status,
                     });
                     // this.AB.Analytics.logError(packet.data);
                     // this.AB.error(packet.data);
                     if (jobResponse) {
                        this._network.publishResponse(
                           jobResponse,
                           packet,
                           null
                        );
                     }
                     return reject(packet.data);
                  } else {
                     // unknown/unexpected error:
                     var error = new Error(
                        `${err.status} ${err.statusText || err.message}: ${
                           params.method
                        } ${params.url}`
                     );
                     error.response = err.responseText;
                     error.text = err.statusText;
                     error.err = err;
                     error.url = `${params.method} ${params.url}`;
                     this.AB.notify.developer(error, {
                        context:
                           "NetworkRest:_request:Unknown Error returned from server",
                        err,
                        response: err.responseText,
                        text: err.statusText || err.message,
                        url: error.url,
                     });
                     // this.AB.Analytics.logError(error);
                     // this.AB.error(error);
                     if (jobResponse) {
                        this._network.publishResponse(jobResponse, error);
                     }
                     return reject(error);
                  }
               });
         } else {
            // now Queue this request params.
            this.AB.Analytics.log(
               "NetworkRest:_request(): Network is offline. Queuing request."
            );
            this._network
               .queue(params, jobResponse)
               .then(() => {
                  resolve({ status: "queued" });
               })
               .catch(reject);
         }
      });
   }

   /**
    * resend()
    * processes messages that were queued due to network connectivity
    * issues.
    * @param {obj} params  the jQuery.ajax() formatted params
    * @param {obj} jobRequest  the information about the request's response.
    * @return {Promise}
    */
   resend(params, jobResponse) {
      // var op = params.type.toLowerCase();
      return this._request(params, jobResponse);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRest);


/***/ }),

/***/ 46642:
/*!****************************************!*\
  !*** ./resources/NetworkRestSocket.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_performance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/performance */ 18320);
/* harmony import */ var _NetworkRest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NetworkRest */ 57773);
/*
 * NetworkRest.js
 * The base Networking class.  This class is responsible for job submissions
 * and outlines the basic Network interface.
 */




const listSocketEvents = [
   // NOTE: ABFactory.definitionXXX() will manage emitting these
   // events internally:
   // "ab.abdefinition.create",
   // "ab.abdefinition.update",
   // "ab.abdefinition.delete",
   "ab.datacollection.create",
   "ab.datacollection.update",
   "ab.datacollection.stale",
   "ab.datacollection.delete",
   "ab.inbox.create",
   "ab.inbox.update",
   // "ab.object.update",
];
// {array}
// The io.socket.* events we are listening for that relate to our datacollection
// maintainence.

function socketDataSave(key, length) {
   if (!HashSocketJobs[key]) {
      HashSocketJobs[key] = {
         packets: 0,
         length: 0,
      };
   }

   HashSocketJobs[key].packets++;
   HashSocketJobs[key].length += length;
}
function socketDataLog(AB, key, data) {
   let length = "??";
   try {
      length = JSON.stringify(data).length;
   } catch (e) {
      console.log(e);
      //
   }

   if (data.objectId) {
      let obj = AB.objectByID(data.objectId);
      console.warn(`socket: ${key} ${obj.label ?? obj.name}(${length})`, data);
   } else {
      console.warn(`socket: ${key} (${length})`, data);
   }

   if (data.jobID) {
      socketDataSave(data.jobID, length);
      socketDataSave(`${data.jobID}-${key}`, length);
   }
}

let HashSocketJobs = {
   /* jobID : { #packets, length } */
};

class NetworkRestSocket extends _NetworkRest__WEBPACK_IMPORTED_MODULE_0__["default"] {
   constructor(parent) {
      // {Network} parent

      super(parent);

      this.isRealTime = true;
      // {bool}
      // does this Network type support RealTime updates. (socket = true);

      // Pass the io.socket.on(*) events to our AB factory.
      listSocketEvents.forEach((ev) => {
         io.socket.on(ev, (data) => {
            socketDataLog(this.AB, ev, data);

            // check if the ev contains 'datacollection'
            // and do a single normalizeData() on the incoming data here
            // before sending it off to be processed.
            if (ev.indexOf("ab.datacollection") > -1) {
               let values = data.data;
               if (values) {
                  let obj = this.AB.objectByID(data.objectId);
                  if (obj) {
                     let model = obj.model();
                     if (ev != "ab.datacollection.delete") {
                        let jobID = this.AB.jobID();
                        _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].mark(`${ev}:normalization`, {
                           op: "function",
                           data: { jobID },
                        });
                        model.normalizeData(data.data);
                        _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].measure(`${ev}:normalization`);
                     }
                  }
               }
            }
            this.AB.emit(ev, data);
         });
      });
   }

   //
   // Interface API
   //

   socketLog() {
      console.warn(JSON.stringify(HashSocketJobs, null, 4));
   }

   socketLogClear() {
      HashSocketJobs = {};
   }

   ////
   //// Network Utilities
   ////

   isNetworkConnected() {
      return io.socket.isConnected();
   }

   salSend(params) {
      let route, query;
      try {
         // Extract paramitized route (ex: `/app_builder/model/:ID`) for performance tracking
         [, route, query] = params.url.match(
            /https?:\/\/[^/]+(\/[^?]+)\??(.*)/
         );
         route = route.replace(/\b[a-fA-F\d-]{36}\b/g, ":ID");
         _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].mark(route, {
            op: "websocket.client",
            data: {
               http: {
                  query: query || undefined,
                  method: params.method,
               },
               url: params.url,
            },
         });
      } catch (err) {
         this.AB.notify.developer(err, {
            context: `salSend() create performance.mark`,
         });
      }

      return new Promise((resolve, reject) => {
         params.method = params.method.toLowerCase();

         io.socket.request(params, (data, jwres) => {
            // {json} data
            // the data response from the request
            // {json} jwres
            // A JSON WebSocket Response object.
            //    {json} jwres.headers :  header values
            //    {int}  jwres.statusCode : http response code
            //    {json} jwres.body === resData

            // if this is an  error
            if (jwres.statusCode >= 400) {
               // Our NetworkRest.error( err ) should be in this format:
               // err.status
               // err.statusText
               // err.responseText

               var errStr = jwres.error ? jwres.error.toString() : jwres.body;

               var err = new Error(`Socket Error: ${errStr}`);
               err.status = jwres.statusCode;
               err.statusText = errStr;
               err.responseText = jwres.body;

               // on RequestTimeout:
               // err.statusText == "Request timeout"

               reject(err);
            } else {
               // some errors like socket disconnected return an Error for data
               if (data instanceof Error) {
                  reject(data);
                  return;
               }

               if (typeof data == "string") {
                  _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].mark("JSON.parse", { op: "serialize" });
                  data = JSON.parse(data);
                  _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].measure("JSON.parse");
               }

               // Got a JSON response but was the service response an error?
               // this would be a strange case where the .statusCode < 400
               if (data?.status == "error") {
                  // make sure to reject an err.responseText = data
                  reject({
                     status: jwres.statusCode,
                     responseText: JSON.Stringify(data),
                  });
               }
               // Success!
               else {
                  _utils_performance__WEBPACK_IMPORTED_MODULE_1__["default"].measure(route);
                  resolve(data);
               }
            }
         });
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NetworkRestSocket);


/***/ }),

/***/ 38609:
/*!******************************!*\
  !*** ./resources/Storage.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StorageLocal.js */ 35972);
var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);



class Storage extends EventEmitter {
   constructor() {
      super();

      this.tenantStorage = null;
      this._config = null;
      this._storage = null;
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var config = this.AB.Config.siteConfig();
      if (config) {
         if (config.storage && config.storage.encrypted) {
            console.error("TODO: Implement Encrypted Storage");
            // this._storage = StorageEncrypted;
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__["default"];
         } else {
            this._storage = _StorageLocal_js__WEBPACK_IMPORTED_MODULE_0__["default"];
         }

         return this._storage.init(AB);
      } else {
         console.error("??? Why No site config ???");
      }

      return Promise.resolve();
   }

   set(...params) {
      return this._storage.set(...params);
   }

   get(...params) {
      return this._storage.get(...params);
   }

   clear(...params) {
      return this._storage.clear(...params);
   }

   clearAll(...params) {
      return this._storage.clearAll(...params);
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Storage());


/***/ }),

/***/ 35972:
/*!***********************************!*\
  !*** ./resources/StorageLocal.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * StorageLocal
 *
 * An interface for storing and retrieving Client Side data.  Data stored
 * in StorageLoacal is NOT encrypted.
 *
 * This implementation is based upon the webix.storage.local library.
 * See: https://docs.webix.com/api__refs__storage.local.html
 *
 */

var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);

class StorageLocal extends EventEmitter {
   constructor() {
      super();

      this.tenantStorage = null;
      // {Webix.storage} object.
      // We divide the storage data according to the tenant we are working
      // with.  This way Users who can move between different Tenants can
      // keep their local data separated.
   }

   init(AB) {
      // {ABFactory} AB

      this.AB = AB;
      var tenantID = this.AB.Tenant.id();
      if (!tenantID) {
         tenantID = "noAuth";
         // "noAuth" is considered the tenant on our Login sequence
         // which should have a minimum of data stored (language maybe?)
      }

      this.tenantStorage = this.AB.Webix.storage.prefix(
         tenantID,
         this.AB.Webix.storage.local
      );

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   set(key, value /* , options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.put(key, value);
      });
   }

   get(key /*, options = {} */) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.get(key);
      });
   }

   clear(key) {
      return Promise.resolve().then(() => {
         return this.tenantStorage.remove(key);
      });
   }

   clearAll() {
      return Promise.resolve().then(() => {
         return this.tenantStorage.clear();
      });
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StorageLocal());


/***/ }),

/***/ 95324:
/*!*****************************!*\
  !*** ./resources/Tenant.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _config_Config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/Config.js */ 97146);
var EventEmitter = (__webpack_require__(/*! events */ 5939).EventEmitter);



class Tenant extends EventEmitter {
   constructor() {
      super();

      this.text = false;
      this._config = null;
      this.textClickToEnter = null;
   }

   init() {
      var config = _config_Config_js__WEBPACK_IMPORTED_MODULE_0__["default"].tenantConfig();
      if (config) {
         // check if we have options that are stored as a string
         if (
            typeof config.options === "string" ||
            config.options instanceof String
         ) {
            // if we do try to parse them into a JSON object
            try {
               config.options = JSON.parse(config.options);
            } catch (error) {
               console.error(error);
            }
         }
         this._config = config;
         this.textClickToEnter = config.options.textClickToEnter;
      }

      // this isn't actually an Async operation, so just resolve()
      return Promise.resolve();
   }

   id() {
      if (!this._config || this._config.id == "??") {
         return null;
      }
      return this._config.id;
   }

   setting(key, value) {
      if (this._config) {
         if (value) {
            this._config.options[key] = value;
            return;
         }
         return this._config.options[key];
      }
   }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Tenant());


/***/ }),

/***/ 78128:
/*!***********************************************!*\
  !*** ./webix_custom_components/activelist.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * custom_activelist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomActiveList {
   get key() {
      return "activelist";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.list, webix.ActiveContent);
   }
};


/***/ }),

/***/ 11837:
/*!************************************************!*\
  !*** ./webix_custom_components/countfooter.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * countfooter
 *
 * Add the count footer to the webix's datatable.
 *
 */

module.exports = class ABCountFooter {
   get key() {
      return "countfooter";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {};

      // internal list of Webix IDs to reference our UI components.
      var ids = {};

      // Our webix UI definition:
      var _ui = {};
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix :
      webix.ui.datafilter.countColumn = webix.extend(
         {
            refresh: function (datatable, node, info) {
               var result = 0;

               var rowData = datatable.find({}) || [];
               rowData.forEach((row) => {
                  if (row == null) return;

                  var data =
                     row[info.columnId] || row[info.columnId + "__relation"];

                  // array
                  if (data && Array.isArray(data)) {
                     result += data.length;
                  } else if (
                     data != null &&
                     data != "" &&
                     data != false &&
                     data != "false" &&
                     data != "0"
                  ) {
                     result += 1;
                  }
               });

               node.innerHTML = result;
            },
         },
         webix.ui.datafilter.summColumn
      );
   }
};


/***/ }),

/***/ 60427:
/*!***********************************************************!*\
  !*** ./webix_custom_components/customComponentManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Custom Component Manager
 * Make sure our {ABComponent}s are initialized with our custom
 * Webix Components.
 */

// Import our Custom Components here:
var componentList = [
   __webpack_require__(/*! ./activelist */ 78128),
   __webpack_require__(/*! ./countfooter */ 11837),
   __webpack_require__(/*! ./datetimepicker */ 95624),
   __webpack_require__(/*! ./editlist */ 23501),
   __webpack_require__(/*! ./edittree */ 84352),
   __webpack_require__(/*! ./editunitlist */ 54520),
   __webpack_require__(/*! ./focusableTemplate */ 79119),
   __webpack_require__(/*! ./formioPreview */ 60271),
   (__webpack_require__(/*! ./formioBuilder */ 77408)["default"]),
   __webpack_require__(/*! ./numbertext */ 65179),
   __webpack_require__(/*! ./thaicalendar */ 48666),
   __webpack_require__(/*! ./timepicker */ 96437),
   (__webpack_require__(/*! ./tinyMce */ 36574)["default"]),
   __webpack_require__(/*! ./totalfooter */ 99221),
   __webpack_require__(/*! ./treesuggest */ 93930),
   // require('./savablelayout')
];

module.exports = class ABCustomComponentManager {
   constructor() {}

   initComponents(App) {
      App.custom = App.custom || {};

      componentList.forEach((Component) => {
         var component = new Component(App);
         App.custom[component.key] = component;
      });

      // Transition to v2:
      App.AB.custom = App.custom;
   }
};


/***/ }),

/***/ 95624:
/*!***************************************************!*\
  !*** ./webix_custom_components/datetimepicker.js ***!
  \***************************************************/
/***/ ((module) => {

/*
 * custom_datetimepicker
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomDateTimePicker {
   //.extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "datetimepicker";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // componentKey {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: App.unique("custom_datetimepicker"), // keep this unique for this App instance.
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.editors.$popup.datetime = {
         view: "popup",
         width: 250,
         height: 250,
         padding: 0,
         body: {
            view: "calendar",
            icons: true,
            borderless: true,
            timepicker: true,
         },
      };

      webix.editors.datetime = webix.extend(
         {
            popupType: "datetime",
         },
         webix.editors.date
      );
   }
};


/***/ }),

/***/ 23501:
/*!*********************************************!*\
  !*** ./webix_custom_components/editlist.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * custom_editlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "editlist";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.list);
   }
};


/***/ }),

/***/ 84352:
/*!*********************************************!*\
  !*** ./webix_custom_components/edittree.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * custom_edittree
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditTree {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "edittree";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.tree);
   }
};


/***/ }),

/***/ 54520:
/*!*************************************************!*\
  !*** ./webix_custom_components/editunitlist.js ***!
  \*************************************************/
/***/ ((module) => {

/*
 * custom_editunitlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditUnitList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "editunitlist";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);
      /*
      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };
*/
      // Our webix UI definition:
      var _ui = {
         name: this.key,
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.EditAbility, webix.ui.unitlist);
   }
};


/***/ }),

/***/ 79119:
/*!******************************************************!*\
  !*** ./webix_custom_components/focusableTemplate.js ***!
  \******************************************************/
/***/ ((module) => {

/*
 * custom_activelist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomFocusableTemplate {
   get key() {
      return "focusabletemplate";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         focus: function () {
            return false;
         },
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.template, webix.UIManager);
   }
};


/***/ }),

/***/ 77408:
/*!**************************************************!*\
  !*** ./webix_custom_components/formioBuilder.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABCustomFormBuilderBuilder)
/* harmony export */ });
/* harmony import */ var _lazyComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazyComponent.js */ 27787);
/* harmony import */ var _lazyComponent_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lazyComponent_js__WEBPACK_IMPORTED_MODULE_0__);
/*
 * formioBuilder
 *
 * Create a custom webix component.
 *
 * Note: Moved from ABDesigner to prevent loading formIO library globally or
 * duplicating it. Revisit when formIOv5 releases as it should then be possible
 * to package the form renderer without the builder.
 *
 * Note: This component is lazy loaded and requires calling .init() before using
 */

class ABCustomFormBuilderBuilder extends (_lazyComponent_js__WEBPACK_IMPORTED_MODULE_0___default()) {
   get key() {
      return "formiobuilder";
   }

   constructor(App) {
      super(App);
      this.label = this.AB.Label();
      this.view = this.key;
   }

   /**
    * Load the FormIO dependency and add the component to webix
    * @returns {Promise<null>}
    */
   async init() {
      if (this.initialized) return;
      const { FormBuilder } = await Promise.all(/*! import() */[__webpack_require__.e("formio-init_formio_js"), __webpack_require__.e("vendor-vendors-node_modules_formio_bootstrap3_lib_index_js-node_modules_formio_choices_js_pub-32abf8")]).then(__webpack_require__.bind(__webpack_require__, /*! ../init/formio.js */ 43083));
      this.FormBuilder = FormBuilder;
      // Tell Webix to create an INSTANCE of our custom component:
      this.AB.Webix.protoUI(this.ui(), this.AB.Webix.ui.popup);
      this.initialized = true;
   }

   /**
    * Generate the custom webix ui
    * @method ui
    * @returns {Object} custom webix ui
    */
   ui() {
      return {
         name: this.key,
         defaults: {
            css: "scrolly forceOpen",
            hidden: false,
            autofit: true,
         },
         $init: async function (config) {
            const comp = this.parseDataFields(config.dataFields);
            const formComponents = config.formComponents
               ? config.formComponents
               : { components: [comp.approveButton.schema] };
            try {
               this.builder = new this.FormBuilder(this.$view, formComponents, {
                  noDefaultSubmitButton: true,
                  noNewEdit: true,
                  builder: {
                     basic: false,
                     advanced: false,
                     customBasic: false,
                     premium: false,
                     custom: {
                        title: this.label("Fields"),
                        weight: 0,
                        default: true,
                        components: comp,
                     },
                     layout: {
                        components: {
                           table: true,
                        },
                     },
                  },
               });
               await this.builder.ready;
            } catch (err) {
               this.notify("Error initializing formio builder", err);
            }
         },
         // set up a function that can be called to request the form schema
         getFormData: function () {
            return this.builder.schema;
         },
         // Pass functions into the Webix component to be use in $init
         label: this.label,
         parseDataFields: this.parseDataFields,
         notify: this.AB.notify.developer,
         FormBuilder: this.FormBuilder,
      };
   }

   /**
    * Generate the formio custom components based on the fields.
    * Used internally in the webix component.
    * @method parseDataFields
    * @param {object[]} fields {field: ABField, key, label, object: ABObject}
    * @returns {object} each key is a formio component
    */
   parseDataFields(fields) {
      const components = {};
      fields.forEach(({ field, key, label }) => {
         if (!field) return;

         const schema = {
            abFieldID: field.id,
            label: field.label,
            disabled: true,
            key,
            _key: key,
            type: "textfield",
            input: true,
         };

         switch (field.key) {
            case "boolean":
               schema.type = "checkbox";
               break;
            case "calculate":
               schema.inputType = "text";
               schema.calculateValue = `value = ${field.settings.formula
                  .replace(/{/g, "data['")
                  .replace(/}/g, "']")}`;
               break;
            case "connectObject":
               schema.inputType = "text";
               schema.calculateValue = `value = data['${key}.format']`;
               break;
            case "date":
               schema.type = "datetime";
               schema.format = "MMMM d, yyyy";
               break;
            case "datetime":
               schema.type = "datetime";
               schema.format = "MMMM d, yyyy h:mm a";
               break;
            case "email":
               schema.type = "email";
               break;
            case "file":
               schema.type = "htmlelement";
               schema.tag = "a";
               schema.className = "btn btn-primary btn-block";
               schema.content = `<i class='fa fa-paperclip'></i> {{data['${key}']?.filename ?? "No File"}}`;
               schema.attrs = [
                  {
                     attr: "href",
                     value: field.urlFile(`{{data['${key}'].uuid}}`),
                  },
                  {
                     attr: "target",
                     value: "_blank",
                  },
               ];
               schema.refreshOnChange = true;
               schema.input = false;
               break;
            case "image":
               schema.type = "htmlelement";
               schema.tag = "img";
               schema.className = "img-thumbnail max100";
               schema.content = "";
               (schema.attrs = [
                  {
                     attr: "src",
                     value: field.urlImage(`{{data['${key}']}}`),
                  },
               ]),
                  (schema.refreshOnChange = true);
               schema.input = false;
               break;
            case "list":
               var values = [];
               field.settings.options.forEach((opt) => {
                  values.push({
                     label: opt.text,
                     value: opt.id,
                  });
               });
               schema.type = "select";
               schema.data = { values };
               schema.multiple = field.settings.isMultiple;
               break;
            case "LongText":
               schema.type = "textarea";
               break;
            case "number":
               schema.type = "number";
               break;
            case "TextFormula":
               schema.inputType = "text";
               schema.calculateValue = `value = '${field.settings.textFormula}'`;
               break;
            default:
               break;
         }
         components[key] = {
            title: label,
            key,
            icon: field.icon,
            schema,
         };
      });

      components["approveButton"] = {
         title: this.label("Approve Button"),
         key: "approve",
         icon: "check-square",
         schema: {
            label: this.label("Approve"),
            type: "button",
            key: "approve",
            event: "approve",
            block: true,
            size: "lg",
            input: false,
            leftIcon: "fa fa-thumbs-up",
            action: "event",
            theme: "success",
         },
      };
      components["denyButton"] = {
         title: this.label("Deny Button"),
         key: "deny",
         icon: "ban",
         schema: {
            label: this.label("Deny"),
            type: "button",
            key: "deny",
            event: "deny",
            block: true,
            size: "lg",
            input: false,
            leftIcon: "fa fa-thumbs-down",
            action: "event",
            theme: "danger",
         },
      };
      components["customButton"] = {
         title: this.label("Custom Action Button"),
         key: "custom",
         icon: "cog",
         schema: {
            label: this.label("Custom Name"),
            type: "button",
            key: "custom",
            event: "yourEvent",
            block: true,
            size: "lg",
            input: false,
            leftIcon: "fa fa-cog",
            action: "event",
            theme: "primary",
         },
      };
      return components;
   }
}


/***/ }),

/***/ 60271:
/*!**************************************************!*\
  !*** ./webix_custom_components/formioPreview.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * formioBuilder
 *
 * Create a custom webix component.
 *
 * Note: This component is lazy loaded and requires calling .init() before using
 *
 */
const ABLazyCustomComponent = __webpack_require__(/*! ./lazyComponent.js */ 27787);
module.exports = class ABCustomFormIOPreview extends ABLazyCustomComponent {
   get key() {
      return "formiopreview";
   }

   async init() {
      if (this.initialized) return;
      const { Form } = await Promise.all(/*! import() */[__webpack_require__.e("formio-init_formio_js"), __webpack_require__.e("vendor-vendors-node_modules_formio_bootstrap3_lib_index_js-node_modules_formio_choices_js_pub-32abf8")]).then(__webpack_require__.bind(__webpack_require__, /*! ../init/formio.js */ 43083));
      // Our webix UI definition:
      var _ui = {
         name: this.key,
         defaults: {
            css: "scrolly",
            borderless: true,
         },
         $init: async function (config) {
            this.$ready.push(() => this.initForm(config));
         },

         initForm: async (config) => {
            var formComponents = config.formComponents ?? {};
            var formData = config.formData ?? {};
            const component = $$(config.id);
            // we need to find out when we are passing an array of objects and reduce it down to an array of IDs
            for (var data in formData) {
               if (
                  Array.isArray(formData[data]) &&
                  typeof formData[data][0] == "object"
               ) {
                  formData[data] = formData[data].map((item) => item.id);
               }
            }

            const form = new Form(component.$view, formComponents);
            // readOnly: true
            // sanitizeConfig: {
            //     addTags: ["a", "label", "img", "i"],
            //     addAttr: ["src", "href", "class", "target"]
            // }
            // }).then(function (form) {
            await form.build();
            // now that it is set up we can push it into the global var
            // formBuilder = builder;
            // Provide a default submission.
            form.instance.submission = {
               data: formData,
            };
            (formComponents.components || []).forEach((comp) => {
               if (
                  comp.type == "button" &&
                  comp.action == "event" &&
                  comp.event
               ) {
                  form.instance.once(comp.event, function (/* click */) {
                     config?.onButton(comp.event);
                     // _this.emit("button", comp.event);
                  });
               }
            });
            // });
         },
      };
      this.view = this.key;

      // our internal business logic
      this._logic = {};

      // Tell Webix to create an INSTANCE of our custom component:
      this.AB.Webix.protoUI(_ui, this.AB.Webix.ui.view);
      this.initialized = true;
   }
};


/***/ }),

/***/ 27787:
/*!**************************************************!*\
  !*** ./webix_custom_components/lazyComponent.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Base class for any custom webix component that we want to initalize lazily,
 * usually to reduce the dependency size required on load.
 */
var ABEmitter = __webpack_require__(/*! ../AppBuilder/platform/ABEmitter.js */ 26263);
module.exports = class ABLazyCustomComponent extends ABEmitter {
   constructor({ AB }) {
      super();
      this.initialized = false;
      this.AB = AB;
      this.setDefaultUI();
   }

   /**
    * Sets a default UI used before the actual webix component is ready. Meant as
    * a helper to future developers.
    */
   setDefaultUI() {
      this.AB.Webix.protoUI(
         {
            name: this.key,
            defaults: {
               template:
                  "This custom webix component has not been initialized. <br>Call AB.custom.#key#.init() before using this component.",
               data: { key: this.key },
            },
            $init: () =>
               console.warn(
                  `${this.key} custom webix component used before being initalized`
               ),
         },
         this.AB.Webix.ui.template
      );
   }
};


/***/ }),

/***/ 65179:
/*!***********************************************!*\
  !*** ./webix_custom_components/numbertext.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * numbertext
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomNumberText {
   get key() {
      return "numbertext";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,

         defaults: {
            css: "webix_el_text",
         },

         // override this function to return number value type
         $getValue: function () {
            var val = this.getInputNode().value;
            if (val) return JSON.parse(val);
            // Convert to number
            else return "";
         },
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.text);
   }
};


/***/ }),

/***/ 48666:
/*!*************************************************!*\
  !*** ./webix_custom_components/thaicalendar.js ***!
  \*************************************************/
/***/ ((module) => {

/*
 * Thai Calendar
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomThaiCalendar {
   get key() {
      return "thaicalendar";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // componentKey {string}	the destination key in App.custom[componentKey] for the instance of this component:

      this.view = this.key;

      const i18n = webix.i18n;

      // Our webix UI definition:
      const _ui = {
         name: this.key,
         defaults: {
            calendarHeader: function (d) {
               return `${i18n.calendar.monthFull[d.getMonth()]} ${
                  d.getFullYear() + 543
               }`;
            },
         },
      };

      if (webix.ui.calendar.$protoWait[0]._zoom_logic) {
         _ui._zoom_logic = AB.cloneDeep(
            webix.ui.calendar.$protoWait[0]._zoom_logic
         );
         _ui._zoom_logic[1] = Object.assign(_ui._zoom_logic[1], {
            _getTitle: this._getYearTitle,
         });
         _ui._zoom_logic[2] = Object.assign(_ui._zoom_logic[2], {
            _getTitle: this._getYearRangeTitle,
            _getContent: this._getYearContent,
            _setContent: this._setYear,
         });
      }

      if (webix.ui.calendar.$protoWait[0].Qd) {
         _ui.Qd = AB.cloneDeep(webix.ui.calendar.$protoWait[0].Qd);
         _ui.Qd[1] = Object.assign(_ui.Qd[1], {
            Jv: this._getYearTitle,
         });
         _ui.Qd[2] = Object.assign(_ui.Qd[2], {
            Jv: this._getYearRangeTitle,
            Zv: this._getYearContent,
            Xv: this._setYear,
         });
      }

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.calendar);

      webix.editors.$popup.thaidate = {
         view: "popup",
         width: 250,
         height: 250,
         padding: 0,
         body: {
            view: this.key,
            icons: true,
            borderless: true,
            timepicker: false,
         },
      };

      webix.editors.$popup.thaidatetime = {
         view: "popup",
         width: 250,
         height: 250,
         padding: 0,
         body: {
            view: this.key,
            icons: true,
            borderless: true,
            timepicker: true,
         },
      };

      webix.editors.thaidate = webix.extend(
         {
            popupType: "thaidate",
         },
         webix.editors.date
      );

      webix.editors.thaidatetime = webix.extend(
         {
            popupType: "thaidatetime",
         },
         webix.editors.date
      );
   }

   _getYearTitle(date) {
      return date.getFullYear() + 543;
   }

   _getYearRangeTitle(date, calendar) {
      let start = date.getFullYear() + 543;
      calendar._zoom_start_date = start = start - (start % 10) - 1;
      return start + " - " + (start + 10 + 1);
   }

   _getYearContent(i, calendar) {
      return calendar._zoom_start_date + i;
   }

   _setYear(next, i, calendar) {
      next.setFullYear(calendar._zoom_start_date - 543 + i);
   }
};


/***/ }),

/***/ 96437:
/*!***********************************************!*\
  !*** ./webix_custom_components/timepicker.js ***!
  \***********************************************/
/***/ ((module) => {

/*
 * custom_timepicker
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomTimePicker {
   //.extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "timepicker";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // componentKey {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: App.unique("custom_timepicker"), // keep this unique for this App instance.
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.editors.$popup.time = {
         view: "popup",
         body: {
            view: "calendar",
            width: 220,
            height: 200,
            type: "time",
         },
      };

      webix.editors.time = webix.extend(
         {
            popupType: "time",
         },
         webix.editors.date
      );
   }
};


/***/ }),

/***/ 36574:
/*!********************************************!*\
  !*** ./webix_custom_components/tinyMce.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ABCustomTinyMCE)
/* harmony export */ });
/* harmony import */ var _lazyComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazyComponent.js */ 27787);
/* harmony import */ var _lazyComponent_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lazyComponent_js__WEBPACK_IMPORTED_MODULE_0__);
/*
 * tinyMce
 *
 * Create a custom webix component.
 *
 * Note: This component is lazy loaded and requires calling .init() before using
 */

class ABCustomTinyMCE extends (_lazyComponent_js__WEBPACK_IMPORTED_MODULE_0___default()) {
   get key() {
      return "tinymce-editor";
   }

   async init() {
      if (this.initialized) return;

      await Promise.all(/*! import() */[__webpack_require__.e("tinymce-vendors-node_modules_tinymce_icons_default_index_js-node_modules_tinymce_plugins_link-1e1308"), __webpack_require__.e("tinymce-js_webix_extras_tinymce_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ../js/webix/extras/tinymce.js */ 76041));
      this.initialized = true;
   }
}


/***/ }),

/***/ 99221:
/*!************************************************!*\
  !*** ./webix_custom_components/totalfooter.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * totalfooter
 *
 * Add the contents of records to show in footer of the webix's datatable.
 *
 */

module.exports = class ABTotalFooter {
   get key() {
      return "totalfooter";
   }

   constructor(App, key) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {};

      // internal list of Webix IDs to reference our UI components.
      var ids = {};

      // Our webix UI definition:
      var _ui = {};
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix :
      webix.ui.datafilter.totalColumn = webix.extend(
         {
            refresh: function (datatable, node, info) {
               var result = 0;

               datatable.eachRow(function (row) {
                  var record = datatable.getItem(row);

                  var data = info.field.format(record);

                  // array
                  if (data) {
                     result += parseFloat(data); // we need to use parseFloat because numbers could be decimals
                  }
               });

               node.innerHTML = result;
            },
         },
         webix.ui.datafilter.summColumn
      );
   }
};


/***/ }),

/***/ 93930:
/*!************************************************!*\
  !*** ./webix_custom_components/treesuggest.js ***!
  \************************************************/
/***/ ((module) => {

/*
 * custom_editlist
 *
 * Create a custom webix component.
 *
 */

module.exports = class ABCustomEditList {
   // .extend(ComponentKey, function(App, componentKey ) {

   get key() {
      return "treesuggest";
   }

   constructor(App) {
      // App 	{obj}	our application instance object.
      // key {string}	the destination key in App.custom[componentKey] for the instance of this component:

      // super(App, key);

      var L = App.Label;

      var labels = {
         common: App.labels,

         component: {},
      };

      // internal list of Webix IDs to reference our UI components.
      var ids = {
         component: App.unique(this.key),
      };

      // Our webix UI definition:
      var _ui = {
         name: this.key,
         defaults: {
            type: "tree",
            width: 0,
            body: {
               borderless: true,
               select: true,
               template: function (obj, common) {
                  return (
                     "<span>" +
                     (obj.$count ? "<b>" + obj.value + "</b>" : obj.value) +
                     "</span>"
                  );
               },
               ready: function () {
                  this.openAll();
               },
               on: {
                  onAfterSelect: function (id, e) {
                     if (this.getItem(id).$count) {
                        this.getParentView().setMasterValue("");
                        this.show(
                           $$(this.getParentView().config.master).getInputNode()
                        );
                     }
                  },
               },
            },
         },
      };
      this.view = this.key;

      // our internal business logic
      var _logic = {};
      this._logic = _logic;

      // Tell Webix to create an INSTANCE of our custom component:
      webix.protoUI(_ui, webix.ui.suggest);
   }
};


/***/ }),

/***/ 47990:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 38497:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 77585:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=AB.ac2d8caedb2bb4f94b07.js.map